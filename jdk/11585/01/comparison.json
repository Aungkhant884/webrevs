{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=20\n+version=21\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+$(if $(filter $(TOPDIR)\/%, $(SUPPORT_OUTPUTDIR)), $(eval SRC_ZIP_BASE := $(TOPDIR)), $(eval SRC_ZIP_BASE := $(SUPPORT_OUTPUTDIR)))\n@@ -48,1 +49,1 @@\n-    $(eval $d_TARGET := $(SRC_ZIP_WORK_DIR)\/$(patsubst $(TOPDIR)\/%,%,$d)\/$m) \\\n+    $(eval $d_TARGET := $(SRC_ZIP_WORK_DIR)\/$(patsubst $(TOPDIR)\/%,%,$(patsubst $(SUPPORT_OUTPUTDIR)\/%,%,$d))\/$m) \\\n@@ -51,1 +52,1 @@\n-          $$(if $(filter $(TOPDIR)\/%, $d), $$(link-file-relative), $$(link-file-absolute)) \\\n+          $$(if $(filter $(SRC_ZIP_BASE)\/%, $d), $$(link-file-relative), $$(link-file-absolute)) \\\n","filename":"make\/ZipSource.gmk","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -309,1 +309,11 @@\n-define link-file-relative\n+# In msys2 we use mklink \/J because its ln would perform a deep copy of the target.\n+# This inhibits performance and can lead to issues with long paths. With mklink \/J\n+# relative linking does not work, so we handle the link as absolute path.\n+ifeq ($(OPENJDK_BUILD_OS_ENV), windows.msys2)\n+  define link-file-relative\n+\t$(call MakeTargetDir)\n+\t$(RM) '$(call DecodeSpace, $@)'\n+\tcmd \/\/c \"mklink \/J $(call FixPath, $(call DecodeSpace, $@)) $(call FixPath, $(call DecodeSpace, $<))\"\n+  endef\n+else\n+  define link-file-relative\n@@ -313,1 +323,2 @@\n-endef\n+  endef\n+endif\n@@ -315,1 +326,8 @@\n-define link-file-absolute\n+ifeq ($(OPENJDK_BUILD_OS_ENV), windows.msys2)\n+  define link-file-absolute\n+\t$(call MakeTargetDir)\n+\t$(RM) '$(call DecodeSpace, $@)'\n+\tcmd \/\/c \"mklink \/J $(call FixPath, $(call DecodeSpace, $@)) $(call FixPath, $(call DecodeSpace, $<))\"\n+  endef\n+else\n+  define link-file-absolute\n@@ -319,1 +337,2 @@\n-endef\n+  endef\n+endif\n","filename":"make\/common\/MakeBase.gmk","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-DEFAULT_VERSION_FEATURE=20\n+DEFAULT_VERSION_FEATURE=21\n@@ -36,2 +36,2 @@\n-DEFAULT_VERSION_DATE=2023-03-21\n-DEFAULT_VERSION_CLASSFILE_MAJOR=64  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n+DEFAULT_VERSION_DATE=2023-09-19\n+DEFAULT_VERSION_CLASSFILE_MAJOR=65  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n@@ -40,2 +40,2 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"19 20\"\n-DEFAULT_JDK_SOURCE_TARGET_VERSION=20\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"19 20 21\"\n+DEFAULT_JDK_SOURCE_TARGET_VERSION=21\n","filename":"make\/conf\/version-numbers.conf","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -197,2 +197,0 @@\n-JVM_ExtentLocalCache\n-JVM_SetExtentLocalCache\n@@ -228,0 +226,6 @@\n+\n+# Scoped values\n+JVM_EnsureMaterializedForStackWalk_func\n+JVM_FindScopedValueBindings\n+JVM_ScopedValueCache\n+JVM_SetScopedValueCache\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,7 @@\n+\n+ifeq ($(call isTargetOsType, unix), true)\n+  ifeq ($(call isTargetOs, macosx aix), false)\n+    # This class is not needed on \"unix\" because SCTP in Java is supported for that platform\n+    EXCLUDE_FILES += $(TOPDIR)\/src\/jdk.sctp\/share\/classes\/sun\/nio\/ch\/sctp\/UnsupportedUtil.java\n+  endif\n+endif\n","filename":"make\/modules\/jdk.sctp\/Java.gmk","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n@@ -576,0 +601,2 @@\n+            out.write(\"enum PeriodicType {BEGIN_CHUNK, INTERVAL, END_CHUNK};\");\n+            out.write(\"\");\n@@ -578,1 +605,3 @@\n-            out.write(\"  static void requestEvent(JfrEventId id) {\");\n+            out.write(\"  static void requestEvent(JfrEventId id, jlong timestamp, PeriodicType periodicType) {\");\n+            out.write(\"    _timestamp = Ticks(timestamp);\");\n+            out.write(\"    _type = periodicType;\");\n@@ -598,0 +627,4 @@\n+            out.write(\" static Ticks timestamp(void);\");\n+            out.write(\" static Ticks _timestamp;\");\n+            out.write(\" static PeriodicType type(void);\");\n+            out.write(\" static PeriodicType _type;\");\n","filename":"make\/src\/classes\/build\/tools\/jfr\/GenerateJfrFiles.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1799,2 +1799,3 @@\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n+        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+        Compile::current()->output()->add_stub(stub);\n+        slow_path = &stub->entry();\n@@ -1882,1 +1883,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n@@ -3635,0 +3638,5 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ nop();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5872,1 +5872,1 @@\n-instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_anytrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -5875,3 +5875,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_anytrue_neon $src1\\t# KILL $tmp\" %}\n@@ -5883,3 +5883,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, zr);\n@@ -5890,1 +5889,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(rFlagsReg cr, pReg src1, pReg src2) %{\n@@ -5893,3 +5892,2 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vtest_anytrue_sve $src1\" %}\n@@ -5899,1 +5897,0 @@\n-    __ csetw($dst$$Register, Assembler::NE);\n@@ -5906,1 +5903,1 @@\n-instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -5909,3 +5906,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_alltrue_neon $src1\\t# KILL $tmp\" %}\n@@ -5917,3 +5914,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, 0xff);\n@@ -5924,1 +5920,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(rFlagsReg cr, pReg src1, pReg src2, pReg ptmp) %{\n@@ -5927,3 +5923,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP ptmp);\n+  format %{ \"vtest_alltrue_sve $src1, $src2\\t# KILL $ptmp\" %}\n@@ -5932,1 +5928,0 @@\n-    __ csetw($dst$$Register, Assembler::EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -4244,1 +4244,1 @@\n-instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_anytrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -4247,3 +4247,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_anytrue_neon $src1\\t# KILL $tmp\" %}\n@@ -4255,3 +4255,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, zr);\n@@ -4262,1 +4261,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(rFlagsReg cr, pReg src1, pReg src2) %{\n@@ -4265,3 +4264,2 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vtest_anytrue_sve $src1\" %}\n@@ -4271,1 +4269,0 @@\n-    __ csetw($dst$$Register, Assembler::NE);\n@@ -4278,1 +4275,1 @@\n-instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -4281,3 +4278,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_alltrue_neon $src1\\t# KILL $tmp\" %}\n@@ -4289,3 +4286,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, 0xff);\n@@ -4296,1 +4292,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(rFlagsReg cr, pReg src1, pReg src2, pReg ptmp) %{\n@@ -4299,3 +4295,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP ptmp);\n+  format %{ \"vtest_alltrue_sve $src1, $src2\\t# KILL $ptmp\" %}\n@@ -4304,1 +4300,0 @@\n-    __ csetw($dst$$Register, Assembler::EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+#define __ masm.\n+\n+int C2SafepointPollStub::max_size() const {\n+  return 20;\n+}\n+\n+void C2SafepointPollStub::emit(C2_MacroAssembler& masm) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  RuntimeAddress callback_addr(stub);\n+\n+  __ bind(entry());\n+  InternalAddress safepoint_pc(masm.pc() - masm.offset() + _safepoint_offset);\n+  __ adr(rscratch1, safepoint_pc);\n+  __ str(rscratch1, Address(rthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(callback_addr);\n+}\n+\n+int C2EntryBarrierStub::max_size() const {\n+  return 24;\n+}\n+\n+void C2EntryBarrierStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+  __ movptr(rscratch1, (uintptr_t) StubRoutines::aarch64::method_entry_barrier());\n+  __ blr(rscratch1);\n+  __ b(continuation());\n+\n+  __ bind(guard());\n+  __ relocate(entry_guard_Relocation::spec());\n+  __ emit_int32(0);   \/\/ nmethod guard value\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -48,15 +48,0 @@\n-void C2_MacroAssembler::emit_entry_barrier_stub(C2EntryBarrierStub* stub) {\n-  bind(stub->slow_path());\n-  movptr(rscratch1, (uintptr_t) StubRoutines::aarch64::method_entry_barrier());\n-  blr(rscratch1);\n-  b(stub->continuation());\n-\n-  bind(stub->guard());\n-  relocate(entry_guard_Relocation::spec());\n-  emit_int32(0);   \/\/ nmethod guard value\n-}\n-\n-int C2_MacroAssembler::entry_barrier_stub_size() {\n-  return 4 * 6;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"opto\/compile.hpp\"\n-#include \"opto\/node.hpp\"\n-#include \"opto\/output.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-#define __ masm.\n-void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n-  RuntimeAddress callback_addr(stub);\n-\n-  __ bind(entry->_stub_label);\n-  InternalAddress safepoint_pc(masm.pc() - masm.offset() + entry->_safepoint_offset);\n-  __ adr(rscratch1, safepoint_pc);\n-  __ str(rscratch1, Address(rthread, JavaThread::saved_exception_pc_offset()));\n-  __ far_jump(callback_addr);\n-}\n-#undef __\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_safepointPollStubTable_aarch64.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -166,0 +166,10 @@\n+  \/\/ An all-set mask is used for the alltrue vector test with SVE\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return is_predicate && is_alltrue;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return is_alltrue ? BoolTest::eq : BoolTest::ne;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -225,2 +225,2 @@\n-  sprintf(buf, \"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n-  if (_model2) sprintf(buf+strlen(buf), \"(0x%03x)\", _model2);\n+  int buf_used_len = os::snprintf_checked(buf, sizeof(buf), \"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n+  if (_model2) os::snprintf_checked(buf + buf_used_len, sizeof(buf) - buf_used_len, \"(0x%03x)\", _model2);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -158,0 +158,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+\n+#define __ masm.\n+\n+int C2SafepointPollStub::max_size() const {\n+  return 56;\n+}\n+\n+void C2SafepointPollStub::emit(C2_MacroAssembler& masm) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  __ bind(entry());\n+  \/\/ Using pc relative address computation.\n+  {\n+    Label next_pc;\n+    __ bl(next_pc);\n+    __ bind(next_pc);\n+  }\n+  int current_offset = __ offset();\n+  \/\/ Code size should not depend on offset: see _stub_size computation in output.cpp\n+  __ load_const32(R12, _safepoint_offset - current_offset);\n+  __ mflr(R0);\n+  __ add(R12, R12, R0);\n+  __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n+\n+  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n+  __ mtctr(R0);\n+  __ bctr();\n+}\n+#undef __\n","filename":"src\/hotspot\/cpu\/ppc\/c2_CodeStubs_ppc.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"macroAssembler_ppc.inline.hpp\"\n-#include \"opto\/compile.hpp\"\n-#include \"opto\/node.hpp\"\n-#include \"opto\/output.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-#define __ masm.\n-void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n-  __ bind(entry->_stub_label);\n-  \/\/ Using pc relative address computation.\n-  {\n-    Label next_pc;\n-    __ bl(next_pc);\n-    __ bind(next_pc);\n-  }\n-  int current_offset = __ offset();\n-  \/\/ Code size should not depend on offset: see _stub_size computation in output.cpp\n-  __ load_const32(R12, entry->_safepoint_offset - current_offset);\n-  __ mflr(R0);\n-  __ add(R12, R12, R0);\n-  __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n-\n-  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n-  __ mtctr(R0);\n-  __ bctr();\n-}\n-#undef __\n","filename":"src\/hotspot\/cpu\/ppc\/c2_safepointPollStubTable_ppc.cpp","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -57,1 +57,1 @@\n-define_pd_global(bool,  VMContinuations, true);\n+define_pd_global(bool,  VMContinuations, AIX_ONLY(false) NOT_AIX(true));\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,0 +167,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -985,0 +985,1 @@\n+#include \"opto\/c2_CodeStubs.hpp\"\n@@ -1619,1 +1620,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n@@ -14377,0 +14380,6 @@\n+source %{\n+\n+#include \"runtime\/continuation.hpp\"\n+\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-    __ la(t0, safepoint_pc.target());\n+    int32_t offset;\n+    __ la_patchable(t0, safepoint_pc.target(), offset);\n+    __ addi(t0, t0, offset);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+#define __ masm.\n+\n+int C2SafepointPollStub::max_size() const {\n+  return 13 * 4;\n+}\n+\n+void C2SafepointPollStub::emit(C2_MacroAssembler& masm) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  RuntimeAddress callback_addr(stub);\n+\n+  __ bind(entry());\n+  InternalAddress safepoint_pc(__ pc() - __ offset() + _safepoint_offset);\n+  __ relocate(safepoint_pc.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(t0, safepoint_pc.target(), offset);\n+    __ addi(t0, t0, offset);\n+  });\n+  __ sd(t0, Address(xthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(callback_addr);\n+}\n+\n+int C2EntryBarrierStub::max_size() const {\n+  \/\/ 4 bytes for alignment\n+  return 8 * 4 + 4;\n+}\n+\n+void C2EntryBarrierStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+\n+  int32_t offset = 0;\n+  __ movptr(t0, StubRoutines::riscv::method_entry_barrier(), offset);\n+  __ jalr(ra, t0, offset);\n+  __ j(continuation());\n+\n+  \/\/ make guard value 4-byte aligned so that it can be accessed by atomic instructions on RISC-V\n+  __ align(4);\n+  __ bind(guard());\n+  __ relocate(entry_guard_Relocation::spec());\n+  __ emit_int32(0);  \/\/ nmethod guard value\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/riscv\/c2_CodeStubs_riscv.cpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -246,31 +246,0 @@\n-void C2_MacroAssembler::emit_entry_barrier_stub(C2EntryBarrierStub* stub) {\n-  IncompressibleRegion ir(this);  \/\/ Fixed length: see C2_MacroAssembler::entry_barrier_stub_size()\n-\n-  \/\/ make guard value 4-byte aligned so that it can be accessed by atomic instructions on riscv\n-  int alignment_bytes = align(4);\n-\n-  bind(stub->slow_path());\n-\n-  int32_t offset = 0;\n-  movptr(t0, StubRoutines::riscv::method_entry_barrier(), offset);\n-  jalr(ra, t0, offset);\n-  j(stub->continuation());\n-\n-  bind(stub->guard());\n-  relocate(entry_guard_Relocation::spec());\n-  assert_alignment(pc());\n-  emit_int32(0);  \/\/ nmethod guard value\n-  \/\/ make sure the stub with a fixed code size\n-  if (alignment_bytes == 2) {\n-    assert(UseRVC, \"bad alignment\");\n-    c_nop();\n-  } else {\n-    assert(alignment_bytes == 0, \"bad alignment\");\n-    nop();\n-  }\n-}\n-\n-int C2_MacroAssembler::entry_barrier_stub_size() {\n-  return 8 * 4 + 4; \/\/ 4 bytes for alignment margin\n-}\n-\n@@ -1729,1 +1698,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"opto\/compile.hpp\"\n-#include \"opto\/node.hpp\"\n-#include \"opto\/output.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-#define __ masm.\n-void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-  RuntimeAddress callback_addr(stub);\n-\n-  __ bind(entry->_stub_label);\n-  InternalAddress safepoint_pc(__ pc() - __ offset() + entry->_safepoint_offset);\n-  __ relocate(safepoint_pc.rspec(), [&] {\n-    __ la(t0, safepoint_pc.target());\n-  });\n-  __ sd(t0, Address(xthread, JavaThread::saved_exception_pc_offset()));\n-  __ far_jump(callback_addr);\n-}\n-#undef __\n","filename":"src\/hotspot\/cpu\/riscv\/c2_safepointPollStubTable_riscv.cpp","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -213,0 +213,1 @@\n+    li32(zr, 0);\n@@ -1386,1 +1387,1 @@\n-static int patch_imm_in_li32(address branch, int32_t target) {\n+int MacroAssembler::patch_imm_in_li32(address branch, int32_t target) {\n@@ -1450,1 +1451,1 @@\n-static address get_target_of_li32(address insn_addr) {\n+address MacroAssembler::get_target_of_li32(address insn_addr) {\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -390,0 +390,3 @@\n+  static address get_target_of_li32(address insn_addr);\n+  static int patch_imm_in_li32(address branch, int32_t target);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -164,0 +164,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -447,0 +447,5 @@\n+int NativePostCallNop::displacement() const {\n+  \/\/ Discard the high 32 bits\n+  return (int)(intptr_t)MacroAssembler::get_target_of_li32(addr_at(4));\n+}\n+\n@@ -448,1 +453,4 @@\n-  \/\/ unsupported for now\n+  assert(diff != 0, \"must be\");\n+  assert(is_lui_to_zr_at(addr_at(4)) && is_addiw_to_zr_at(addr_at(8)), \"must be\");\n+\n+  MacroAssembler::patch_imm_in_li32(addr_at(4), diff);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  static bool is_addiw_to_zr_at(address instr) { assert_cond(instr != NULL); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n@@ -82,0 +83,1 @@\n+  static bool is_lui_to_zr_at(address instr)  { assert_cond(instr != NULL); return is_lui_at(instr) && extract_rd(instr) == zr; }\n@@ -557,0 +559,6 @@\n+\/\/ A NativePostCallNop takes the form of three instructions:\n+\/\/     nop; lui zr, hi20; addiw zr, lo12\n+\/\/\n+\/\/ The nop is patchable for a deoptimization trap. The lui and addiw\n+\/\/ instructions execute as nops but have a 20\/12-bit payload in which we\n+\/\/ can store an offset from the initial nop to the nmethod.\n@@ -559,2 +567,8 @@\n-  bool check() const { return is_nop(); }\n-  int displacement() const { return 0; }\n+  bool check() const {\n+    \/\/ Check for two instructions: nop; lui zr, hi20\n+    \/\/ These instructions only ever appear together in a post-call\n+    \/\/ NOP, so it's unnecessary to check that the third instruction is\n+    \/\/ an addiw as well.\n+    return is_nop() && is_lui_to_zr_at(addr_at(4));\n+  }\n+  int displacement() const;\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1364,2 +1364,3 @@\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n+        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+        Compile::current()->output()->add_stub(stub);\n+        slow_path = &stub->entry();\n@@ -1446,1 +1447,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -156,0 +156,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1934,1 +1934,1 @@\n-  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1941,1 +1941,1 @@\n-  assert(VM_Version::supports_avx512vl(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -1954,0 +1954,11 @@\n+void Assembler::vcvtps2ph(Address dst, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x1D);\n+  emit_operand(src, dst, 1);\n+  emit_int8(imm8);\n+}\n+\n@@ -1955,1 +1966,1 @@\n-  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1961,0 +1972,10 @@\n+void Assembler::vcvtph2ps(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x13);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -5429,0 +5450,7 @@\n+void Assembler::vtestps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x0E, (0xC0 | encode));\n+}\n+\n@@ -5430,2 +5458,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n-  \/\/ Encoding: EVEX.NDS.XXX.66.0F.W0 DB \/r\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : VM_Version::supports_avx512vlbw(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F38.W0 DB \/r\n@@ -5435,1 +5463,19 @@\n-  emit_int16((unsigned char)0x26, (0xC0 | encode));\n+  emit_int16(0x26, (0xC0 | encode));\n+}\n+\n+void Assembler::evptestmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx512vl(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F38.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x27, (0xC0 | encode));\n+}\n+\n+void Assembler::evptestnmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx512vl(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.F3.0F38.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x27, (0xC0 | encode));\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":52,"deletions":6,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1163,0 +1163,2 @@\n+  void vcvtps2ph(Address dst, XMMRegister src, int imm8, int vector_len);\n+  void vcvtph2ps(XMMRegister dst, Address src, int vector_len);\n@@ -1974,0 +1976,2 @@\n+  void evptestmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evptestnmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1977,0 +1981,1 @@\n+  void vtestps(XMMRegister dst, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+#define __ masm.\n+\n+int C2SafepointPollStub::max_size() const {\n+  return 33;\n+}\n+\n+void C2SafepointPollStub::emit(C2_MacroAssembler& masm) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  RuntimeAddress callback_addr(stub);\n+\n+  __ bind(entry());\n+  InternalAddress safepoint_pc(masm.pc() - masm.offset() + _safepoint_offset);\n+#ifdef _LP64\n+  __ lea(rscratch1, safepoint_pc);\n+  __ movptr(Address(r15_thread, JavaThread::saved_exception_pc_offset()), rscratch1);\n+#else\n+  const Register tmp1 = rcx;\n+  const Register tmp2 = rdx;\n+  __ push(tmp1);\n+  __ push(tmp2);\n+\n+  __ lea(tmp1, safepoint_pc);\n+  __ get_thread(tmp2);\n+  __ movptr(Address(tmp2, JavaThread::saved_exception_pc_offset()), tmp1);\n+\n+  __ pop(tmp2);\n+  __ pop(tmp1);\n+#endif\n+  __ jump(callback_addr);\n+}\n+\n+int C2EntryBarrierStub::max_size() const {\n+  return 10;\n+}\n+\n+void C2EntryBarrierStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+  __ call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));\n+  __ jmp(continuation(), false \/* maybe_short *\/);\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -141,2 +141,3 @@\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n+        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+        Compile::current()->output()->add_stub(stub);\n+        slow_path = &stub->entry();\n@@ -154,10 +155,0 @@\n-void C2_MacroAssembler::emit_entry_barrier_stub(C2EntryBarrierStub* stub) {\n-  bind(stub->slow_path());\n-  call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));\n-  jmp(stub->continuation(), false \/* maybe_short *\/);\n-}\n-\n-int C2_MacroAssembler::entry_barrier_stub_size() {\n-  return 10;\n-}\n-\n@@ -2418,52 +2409,26 @@\n-void C2_MacroAssembler::vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2,\n-                                   XMMRegister vtmp1, XMMRegister vtmp2, KRegister mask) {\n-  switch(vlen) {\n-    case 4:\n-      assert(vtmp1 != xnoreg, \"required.\");\n-      \/\/ Broadcast lower 32 bits to 128 bits before ptest\n-      pshufd(vtmp1, src1, 0x0);\n-      if (bt == BoolTest::overflow) {\n-        assert(vtmp2 != xnoreg, \"required.\");\n-        pshufd(vtmp2, src2, 0x0);\n-      } else {\n-        assert(vtmp2 == xnoreg, \"required.\");\n-        vtmp2 = src2;\n-      }\n-      ptest(vtmp1, vtmp2);\n-     break;\n-    case 8:\n-      assert(vtmp1 != xnoreg, \"required.\");\n-      \/\/ Broadcast lower 64 bits to 128 bits before ptest\n-      pshufd(vtmp1, src1, 0x4);\n-      if (bt == BoolTest::overflow) {\n-        assert(vtmp2 != xnoreg, \"required.\");\n-        pshufd(vtmp2, src2, 0x4);\n-      } else {\n-        assert(vtmp2 == xnoreg, \"required.\");\n-        vtmp2 = src2;\n-      }\n-      ptest(vtmp1, vtmp2);\n-     break;\n-    case 16:\n-      assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-      ptest(src1, src2);\n-      break;\n-    case 32:\n-      assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-      vptest(src1, src2, Assembler::AVX_256bit);\n-      break;\n-    case 64:\n-      {\n-        assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-        evpcmpeqb(mask, src1, src2, Assembler::AVX_512bit);\n-        if (bt == BoolTest::ne) {\n-          ktestql(mask, mask);\n-        } else {\n-          assert(bt == BoolTest::overflow, \"required\");\n-          kortestql(mask, mask);\n-        }\n-      }\n-      break;\n-    default:\n-      assert(false,\"Should not reach here.\");\n-      break;\n+void C2_MacroAssembler::vectortest(BasicType bt, XMMRegister src1, XMMRegister src2, XMMRegister vtmp, int vlen_in_bytes) {\n+  assert(vlen_in_bytes <= 32, \"\");\n+  int esize = type2aelembytes(bt);\n+  if (vlen_in_bytes == 32) {\n+    assert(vtmp == xnoreg, \"required.\");\n+    if (esize >= 4) {\n+      vtestps(src1, src2, AVX_256bit);\n+    } else {\n+      vptest(src1, src2, AVX_256bit);\n+    }\n+    return;\n+  }\n+  if (vlen_in_bytes < 16) {\n+    \/\/ Duplicate the lower part to fill the whole register,\n+    \/\/ Don't need to do so for src2\n+    assert(vtmp != xnoreg, \"required\");\n+    int shuffle_imm = (vlen_in_bytes == 4) ? 0x00 : 0x04;\n+    pshufd(vtmp, src1, shuffle_imm);\n+  } else {\n+    assert(vtmp == xnoreg, \"required\");\n+    vtmp = src1;\n+  }\n+  if (esize >= 4 && VM_Version::supports_avx()) {\n+    vtestps(vtmp, src2, AVX_128bit);\n+  } else {\n+    ptest(vtmp, src2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":29,"deletions":64,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -141,2 +141,1 @@\n-  void vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2,\n-                  XMMRegister vtmp1 = xnoreg, XMMRegister vtmp2 = xnoreg, KRegister mask = knoreg);\n+  void vectortest(BasicType bt, XMMRegister src1, XMMRegister src2, XMMRegister vtmp, int vlen_in_bytes);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"opto\/compile.hpp\"\n-#include \"opto\/node.hpp\"\n-#include \"opto\/output.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-#define __ masm.\n-void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n-  RuntimeAddress callback_addr(stub);\n-\n-  __ bind(entry->_stub_label);\n-  InternalAddress safepoint_pc(masm.pc() - masm.offset() + entry->_safepoint_offset);\n-#ifdef _LP64\n-  __ lea(rscratch1, safepoint_pc);\n-  __ movptr(Address(r15_thread, JavaThread::saved_exception_pc_offset()), rscratch1);\n-#else\n-  const Register tmp1 = rcx;\n-  const Register tmp2 = rdx;\n-  __ push(tmp1);\n-  __ push(tmp2);\n-\n-  __ lea(tmp1, safepoint_pc);\n-  __ get_thread(tmp2);\n-  __ movptr(Address(tmp2, JavaThread::saved_exception_pc_offset()), tmp1);\n-\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-#endif\n-  __ jump(callback_addr);\n-}\n-#undef __\n","filename":"src\/hotspot\/cpu\/x86\/c2_safepointPollStubTable_x86.cpp","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -38,1 +38,1 @@\n-    return;\t\t\t\/\/ Elided.\n+    return;\n@@ -63,0 +63,21 @@\n+static void z_cmpxchg_common(MacroAssembler& _masm, const MachNode* node, Register mem_reg, Register newval, Register tmp) {\n+  \/\/ Compare value (oldval) is in rax\n+   const Address mem = Address(mem_reg, 0);\n+\n+  if (node->barrier_data() != ZLoadBarrierElided) {\n+    __ movptr(tmp, rax);\n+  }\n+\n+  __ lock();\n+  __ cmpxchgptr(newval, mem);\n+\n+  if (node->barrier_data() != ZLoadBarrierElided) {\n+    Label good;\n+    z_load_barrier_cmpxchg(_masm, node, mem, rax, tmp, good);\n+    __ movptr(rax, tmp);\n+    __ lock();\n+    __ cmpxchgptr(newval, mem);\n+    __ bind(good);\n+  }\n+}\n+\n@@ -84,1 +105,1 @@\n-instruct zCompareAndExchangeP(memory mem, rax_RegP oldval, rRegP newval, rRegP tmp, rFlagsReg cr) %{\n+instruct zCompareAndExchangeP(indirect mem, rax_RegP oldval, rRegP newval, rRegP tmp, rFlagsReg cr) %{\n@@ -93,14 +114,2 @@\n-    if (barrier_data() != ZLoadBarrierElided) { \/\/ barrier could be elided by ZBarrierSetC2::analyze_dominating_barriers()\n-      __ movptr($tmp$$Register, $oldval$$Register);\n-    }\n-    __ lock();\n-    __ cmpxchgptr($newval$$Register, $mem$$Address);\n-\n-    if (barrier_data() != ZLoadBarrierElided) {\n-      Label good;\n-      z_load_barrier_cmpxchg(_masm, this, $mem$$Address, $oldval$$Register, $tmp$$Register, good);\n-      __ movptr($oldval$$Register, $tmp$$Register);\n-      __ lock();\n-      __ cmpxchgptr($newval$$Register, $mem$$Address);\n-      __ bind(good);\n-    }\n+    precond($oldval$$Register == rax);\n+    z_cmpxchg_common(_masm, this, $mem$$Register, $newval$$Register, $tmp$$Register);\n@@ -112,1 +121,1 @@\n-instruct zCompareAndSwapP(rRegI res, memory mem, rRegP newval, rRegP tmp, rFlagsReg cr, rax_RegP oldval) %{\n+instruct zCompareAndSwapP(rRegI res, indirect mem, rRegP newval, rRegP tmp, rFlagsReg cr, rax_RegP oldval) %{\n@@ -124,6 +133,2 @@\n-    if (barrier_data() != ZLoadBarrierElided) { \/\/ barrier could be elided by ZBarrierSetC2::analyze_dominating_barriers()\n-      __ movptr($tmp$$Register, $oldval$$Register);\n-    }\n-    __ lock();\n-    __ cmpxchgptr($newval$$Register, $mem$$Address);\n-\n+    precond($oldval$$Register == rax);\n+    z_cmpxchg_common(_masm, this, $mem$$Register, $newval$$Register, $tmp$$Register);\n@@ -131,7 +136,1 @@\n-      Label good;\n-      z_load_barrier_cmpxchg(_masm, this, $mem$$Address, $oldval$$Register, $tmp$$Register, good);\n-      __ movptr($oldval$$Register, $tmp$$Register);\n-      __ lock();\n-      __ cmpxchgptr($newval$$Register, $mem$$Address);\n-      __ bind(good);\n-      __ cmpptr($tmp$$Register, $oldval$$Register);\n+      __ cmpptr($tmp$$Register, rax);\n@@ -146,1 +145,1 @@\n-instruct zXChgP(memory mem, rRegP newval, rFlagsReg cr) %{\n+instruct zXChgP(indirect mem, rRegP newval, rFlagsReg cr) %{\n@@ -154,1 +153,1 @@\n-    __ xchgptr($newval$$Register, $mem$$Address);\n+    __ xchgptr($newval$$Register, Address($mem$$Register, 0));\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/z_x86_64.ad","additions":31,"deletions":32,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -9016,20 +9016,0 @@\n-void MacroAssembler::anytrue(Register dst, uint masklen, KRegister src1, KRegister src2) {\n-   masklen = masklen < 8 ? 8 : masklen;\n-   ktest(masklen, src1, src2);\n-   setb(Assembler::notZero, dst);\n-   movzbl(dst, dst);\n-}\n-\n-void MacroAssembler::alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch) {\n-  if (masklen < 8) {\n-    knotbl(kscratch, src2);\n-    kortestbl(src1, kscratch);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  } else {\n-    ktest(masklen, src1, src2);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1771,3 +1771,0 @@\n-  void alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch);\n-  void anytrue(Register dst, uint masklen, KRegister src, KRegister kscratch);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,0 +186,19 @@\n+  \/\/ Without predicated input, an all-one vector is needed for the alltrue vector test\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return is_alltrue && !is_predicate;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    if (!is_alltrue) {\n+      return BoolTest::ne;\n+    }\n+    if (!is_predicate) {\n+      return BoolTest::lt;\n+    }\n+    if ((vlen == 8 && !VM_Version::supports_avx512dq()) || vlen < 8) {\n+      return BoolTest::eq;\n+    }\n+    return BoolTest::lt;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -959,0 +959,1 @@\n+    _features &= ~CPU_F16C;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1690,0 +1690,6 @@\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if (!VM_Version::supports_f16c() && !VM_Version::supports_evex()) {\n+        return false;\n+      }\n+      break;\n@@ -1847,2 +1853,0 @@\n-      } else if (size_in_bits == 512 && (VM_Version::supports_avx512bw() == false)) {\n-        return false; \/\/ Implementation limitation\n@@ -1904,0 +1908,8 @@\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if (!VM_Version::supports_f16c() &&\n+         ((!VM_Version::supports_evex() ||\n+         ((size_in_bits != 512) && !VM_Version::supports_avx512vl())))) {\n+        return false;\n+      }\n+      break;\n@@ -3676,0 +3688,20 @@\n+instruct vconvF2HF(vec dst, vec src) %{\n+  match(Set dst (VectorCastF2HF src));\n+  format %{ \"vector_conv_F2HF $dst $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvF2HF_mem_reg(memory mem, vec src) %{\n+  match(Set mem (StoreVector mem (VectorCastF2HF src)));\n+  format %{ \"vcvtps2ph $mem,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($mem$$Address, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -3686,0 +3718,21 @@\n+instruct vconvHF2F_reg_mem(vec dst, memory mem) %{\n+  match(Set dst (VectorCastHF2F (LoadVector mem)));\n+  format %{ \"vcvtph2ps $dst,$mem\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvHF2F(vec dst, vec src) %{\n+  match(Set dst (VectorCastHF2F src));\n+  ins_cost(125);\n+  format %{ \"vector_conv_HF2F $dst,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7996,8 +8049,5 @@\n-instruct vptest_alltrue_lt16(rRegI dst, legVec src1, legVec src2, legVec vtmp1, legVec vtmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP vtmp1, TEMP vtmp2, KILL cr);\n-  format %{ \"vptest_alltrue_lt16 $dst,$src1, $src2\\t! using $vtmp1, $vtmp2 and $cr as TEMP\" %}\n+instruct vptest_lt16(rFlagsRegU cr, legVec src1, legVec src2, legVec vtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) < 16);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP vtmp);\n+  format %{ \"vptest_lt16  $src1, $src2\\t! using $vtmp as TEMP\" %}\n@@ -8005,0 +8055,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -8006,3 +8057,1 @@\n-    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);\n-    __ setb(Assembler::carrySet, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ vectortest(bt, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister, vlen);\n@@ -8013,8 +8062,4 @@\n-instruct vptest_alltrue_ge16(rRegI dst, legVec src1, legVec src2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) <  64 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(KILL cr);\n-  format %{ \"vptest_alltrue_ge16  $dst,$src1, $src2\\t! using $cr as TEMP\" %}\n+instruct vptest_ge16(rFlagsRegU cr, legVec src1, legVec src2) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 16);\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vptest_ge16  $src1, $src2\\n\\t\" %}\n@@ -8022,0 +8067,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -8023,3 +8069,1 @@\n-    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n-    __ setb(Assembler::carrySet, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ vectortest(bt, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, vlen);\n@@ -8030,27 +8074,7 @@\n-instruct vptest_alltrue_lt8_evex(rRegI dst, kReg src1, kReg src2, kReg kscratch, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow &&\n-            n->in(1)->bottom_type()->isa_vectmask() &&\n-            Matcher::vector_length(n->in(1)) < 8);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr, TEMP kscratch);\n-  format %{ \"vptest_alltrue_lt8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    uint masklen = Matcher::vector_length(this, $src1);\n-    __ alltrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister, $kscratch$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vptest_alltrue_ge8_evex(rRegI dst, kReg src1, kReg src2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow &&\n-            n->in(1)->bottom_type()->isa_vectmask() &&\n-            Matcher::vector_length(n->in(1)) >= 8);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vptest_alltrue_ge8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n+instruct ktest_alltrue_le8(rFlagsRegU cr, kReg src1, kReg src2, rRegI tmp) %{\n+  predicate((Matcher::vector_length(n->in(1)) < 8 ||\n+             (Matcher::vector_length(n->in(1)) == 8 && !VM_Version::supports_avx512dq())) &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"ktest_alltrue_le8  $src1, $src2\\t! using $tmp as TEMP\" %}\n@@ -8058,3 +8082,0 @@\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n@@ -8062,19 +8083,3 @@\n-    __ alltrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vptest_anytrue_lt16(rRegI dst, legVec src1, legVec src2, legVec vtmp, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP vtmp, KILL cr);\n-  format %{ \"vptest_anytrue_lt16 $dst,$src1,$src2\\t! using $vtmp, $cr as TEMP\" %}\n-  ins_encode %{\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister);\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ kmovwl($tmp$$Register, $src1$$KRegister);\n+    __ andl($tmp$$Register, (1 << masklen) - 1);\n+    __ cmpl($tmp$$Register, (1 << masklen) - 1);\n@@ -8085,4 +8090,3 @@\n-instruct vptest_anytrue_ge16(rRegI dst, legVec src1, legVec src2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 64  &&\n+instruct ktest_anytrue_le8(rFlagsRegU cr, kReg src1, kReg src2, rRegI tmp) %{\n+  predicate((Matcher::vector_length(n->in(1)) < 8 ||\n+             (Matcher::vector_length(n->in(1)) == 8 && !VM_Version::supports_avx512dq())) &&\n@@ -8090,50 +8094,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(KILL cr);\n-  format %{ \"vptest_anytrue_ge16 $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vptest_anytrue_evex(rRegI dst, kReg src1, kReg src2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vptest_anytrue_lt8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    uint  masklen = Matcher::vector_length(this, $src1);\n-    __ anytrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct cmpvptest_anytrue_lt16(rFlagsReg cr, legVec src1, legVec src2, immI_0 zero, legVec vtmp) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  effect(TEMP vtmp);\n-  format %{ \"cmpvptest_anytrue_lt16 $src1,$src2\\t! using $vtmp as TEMP\" %}\n-  ins_encode %{\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct cmpvptest_anytrue_ge16(rFlagsReg cr, legVec src1, legVec src2, immI_0 zero) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <  64 &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  format %{ \"cmpvptest_anytrue_ge16 $src1,$src2\\t!\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"ktest_anytrue_le8  $src1, $src2\\t! using $tmp as TEMP\" %}\n@@ -8141,2 +8098,3 @@\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n+    uint masklen = Matcher::vector_length(this, $src1);\n+    __ kmovwl($tmp$$Register, $src1$$KRegister);\n+    __ andl($tmp$$Register, (1 << masklen) - 1);\n@@ -8147,5 +8105,5 @@\n-instruct cmpvptest_anytrue_evex(rFlagsReg cr, kReg src1, kReg src2, immI_0 zero) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  format %{ \"cmpvptest_anytrue_evex $src1,$src2\\t!\" %}\n+instruct ktest_ge8(rFlagsRegU cr, kReg src1, kReg src2) %{\n+  predicate(Matcher::vector_length(n->in(1)) >= 16 ||\n+            (Matcher::vector_length(n->in(1)) == 8 && VM_Version::supports_avx512dq()));\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"ktest_ge8  $src1, $src2\\n\\t\" %}\n@@ -8154,5 +8112,1 @@\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    masklen = masklen < 8 ? 8 : masklen;\n-    __ ktest(masklen, $src1$$KRegister, $src2$$KRegister);\n+    __ kortest(masklen, $src1$$KRegister, $src1$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":93,"deletions":139,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -711,1 +711,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1023,1 +1023,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n@@ -2167,1 +2169,0 @@\n-    $$$emit8$primary;\n@@ -2170,0 +2171,1 @@\n+      $$$emit8$primary;\n@@ -2173,0 +2175,5 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ addr_nop_5();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n@@ -2174,0 +2181,1 @@\n+      $$$emit8$primary;\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-  sprintf(ver_str, \"%d\", ATTACH_PROTOCOL_VER);\n+  size_t ver_str_len = os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n@@ -291,1 +291,1 @@\n-          if ((strlen(buf) != strlen(ver_str)) ||\n+          if ((strlen(buf) != ver_str_len) ||\n@@ -294,2 +294,2 @@\n-            sprintf(msg, \"%d\\n\", ATTACH_ERROR_BADVERSION);\n-            write_fully(s, msg, strlen(msg));\n+            int msg_len = os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n+            write_fully(s, msg, msg_len);\n@@ -414,2 +414,2 @@\n-  sprintf(msg, \"%d\\n\", result);\n-  int rc = BsdAttachListener::write_fully(this->socket(), msg, strlen(msg));\n+  int msg_len = os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n+  int rc = BsdAttachListener::write_fully(this->socket(), msg, msg_len);\n","filename":"src\/hotspot\/os\/bsd\/attachListener_bsd.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  \/\/ Buffer that fits several sprintfs.\n+  \/\/ Buffer that fits several snprintfs.\n@@ -379,5 +379,4 @@\n-    char *ld_library_path = NEW_C_HEAP_ARRAY(char,\n-                                             strlen(v) + 1 +\n-                                             sizeof(SYS_EXT_DIR) + sizeof(\"\/lib\/\") + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,\n-                                             mtInternal);\n-    sprintf(ld_library_path, \"%s%s\" SYS_EXT_DIR \"\/lib\/%s:\" DEFAULT_LIBPATH, v, v_colon, cpu_arch);\n+    const size_t ld_library_path_size = strlen(v) + 1 + sizeof(SYS_EXT_DIR) +\n+            sizeof(\"\/lib\/\") + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1;\n+    char *ld_library_path = NEW_C_HEAP_ARRAY(char, ld_library_path_size, mtInternal);\n+    os::snprintf_checked(ld_library_path, ld_library_path_size, \"%s%s\" SYS_EXT_DIR \"\/lib\/%s:\" DEFAULT_LIBPATH, v, v_colon, cpu_arch);\n@@ -389,1 +388,1 @@\n-  sprintf(buf, \"%s\" EXTENSIONS_DIR \":\" SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());\n+  os::snprintf_checked(buf, bufsize, \"%s\" EXTENSIONS_DIR \":\" SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());\n@@ -404,1 +403,1 @@\n-  \/\/ Buffer that fits several sprintfs.\n+  \/\/ Buffer that fits several snprintfs.\n@@ -474,5 +473,3 @@\n-    char *ld_library_path = NEW_C_HEAP_ARRAY(char,\n-                                             strlen(v) + 1 + strlen(l) + 1 +\n-                                             system_ext_size + 3,\n-                                             mtInternal);\n-    sprintf(ld_library_path, \"%s%s%s%s%s\" SYS_EXTENSIONS_DIR \":\" SYS_EXTENSIONS_DIRS \":.\",\n+    const size_t ld_library_path_size = strlen(v) + 1 + strlen(l) + 1 + system_ext_size + 3;\n+    char *ld_library_path = NEW_C_HEAP_ARRAY(char, ld_library_path_size, mtInternal);\n+    os::snprintf_checked(ld_library_path, ld_library_path_size, \"%s%s%s%s%s\" SYS_EXTENSIONS_DIR \":\" SYS_EXTENSIONS_DIRS \":.\",\n@@ -489,1 +486,1 @@\n-  sprintf(buf, \"%s\" SYS_EXTENSIONS_DIR \":%s\" EXTENSIONS_DIR \":\" SYS_EXTENSIONS_DIRS,\n+  os::snprintf_checked(buf, bufsize, \"%s\" SYS_EXTENSIONS_DIR \":%s\" EXTENSIONS_DIR \":\" SYS_EXTENSIONS_DIRS,\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-                     \"Raw value for CPU quota is: %s\", \"%s %*d\", quota, 1024);\n+                     \"Raw value for CPU quota is: %s\", \"%1023s %*d\", quota, 1024);\n@@ -144,1 +144,1 @@\n-                         \"Memory Soft Limit is: %s\", \"%s\", mem_soft_limit_str, 1024);\n+                         \"Memory Soft Limit is: %s\", \"%1023s\", mem_soft_limit_str, 1024);\n@@ -166,1 +166,1 @@\n-                         \"Memory and Swap Limit is: %s\", \"%s\", mem_swp_limit_str, 1024);\n+                         \"Memory and Swap Limit is: %s\", \"%1023s\", mem_swp_limit_str, 1024);\n@@ -173,1 +173,1 @@\n-                         \"Swap currently used is: %s\", \"%s\", mem_swp_current_str, 1024);\n+                         \"Swap currently used is: %s\", \"%1023s\", mem_swp_current_str, 1024);\n@@ -200,1 +200,1 @@\n-                         \"Raw value for memory limit is: %s\", \"%s\", mem_limit_str, 1024);\n+                         \"Raw value for memory limit is: %s\", \"%1023s\", mem_limit_str, 1024);\n@@ -226,1 +226,1 @@\n-                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n+                     \"Maximum number of tasks is: %s\", \"%1023s %*d\", pidsmax, 1024);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -103,0 +103,4 @@\n+\/\/ Performs snprintf and asserts the result is non-negative (so there was not\n+\/\/ an encoding error) and that the output was not truncated.\n+extern int snprintf_checked(char* buf, size_t len, const char* fmt, ...);\n+\n","filename":"src\/hotspot\/share\/adlc\/adlc.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -214,2 +214,3 @@\n-          char* buf = (char*) AdlAllocateHeap(strlen(instr->_ident) + 4);\n-          sprintf(buf, \"%s_%d\", instr->_ident, match_rules_cnt++);\n+          const size_t buf_size = strlen(instr->_ident) + 4;\n+          char* buf = (char*) AdlAllocateHeap(buf_size);\n+          snprintf_checked(buf, buf_size, \"%s_%d\", instr->_ident, match_rules_cnt++);\n@@ -2879,2 +2880,3 @@\n-  char* ec_name = (char*) AdlAllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n-  sprintf(ec_name, \"%s%s\", prefix, inst._ident);\n+  const size_t ec_name_size = strlen(inst._ident) + strlen(prefix) + 1;\n+  char* ec_name = (char*) AdlAllocateHeap(ec_name_size);\n+  snprintf_checked(ec_name, ec_name_size, \"%s%s\", prefix, inst._ident);\n@@ -3350,2 +3352,3 @@\n-  char* ec_name = (char*) AdlAllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n-  sprintf(ec_name, \"%s%s\", prefix, inst._ident);\n+  const size_t ec_name_size = strlen(inst._ident) + strlen(prefix) + 1;\n+  char* ec_name = (char*) AdlAllocateHeap(ec_name_size);\n+  snprintf_checked(ec_name, ec_name_size, \"%s%s\", prefix, inst._ident);\n@@ -4670,2 +4673,3 @@\n-      char* buf = (char*) AdlAllocateHeap(strlen(param) + 3);\n-      sprintf(buf, \"(%s)\", param);\n+      const size_t buf_size = strlen(param) + 3;\n+      char* buf = (char*) AdlAllocateHeap(buf_size);\n+      snprintf_checked(buf, buf_size, \"(%s)\", param);\n@@ -5278,2 +5282,3 @@\n-  char* location = (char *)AdlAllocateHeap(strlen(file) + 100);\n-  sprintf(location, \"\\n#line %d \\\"%s\\\"\\n\", line, file);\n+  const size_t location_size = strlen(file) + 100;\n+  char* location = (char *)AdlAllocateHeap(location_size);\n+  snprintf_checked(location, location_size, \"\\n#line %d \\\"%s\\\"\\n\", line, file);\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -818,1 +818,1 @@\n-    sprintf(regMask,\"%s%s()\", rc_name, mask);\n+    snprintf_checked(regMask, length, \"%s%s()\", rc_name, mask);\n@@ -911,1 +911,1 @@\n-  sprintf(result,\"%s%s\", stack_or, reg_mask_name);\n+  snprintf_checked(result, length, \"%s%s\", stack_or, reg_mask_name);\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-    sprintf(Expr::buffer(), \"_kids[0]->_cost[%s]\", lchild_to_upper);\n+    snprintf_checked(Expr::buffer(), STRING_BUFFER_LENGTH, \"_kids[0]->_cost[%s]\", lchild_to_upper);\n@@ -221,1 +221,1 @@\n-    sprintf(Expr::buffer(), \"_kids[1]->_cost[%s]\", rchild_to_upper);\n+    snprintf_checked(Expr::buffer(), STRING_BUFFER_LENGTH, \"_kids[1]->_cost[%s]\", rchild_to_upper);\n@@ -760,1 +760,1 @@\n-    sprintf( string_buffer, \"0\");\n+    snprintf_checked(string_buffer, STRING_BUFFER_LENGTH, \"0\");\n","filename":"src\/hotspot\/share\/adlc\/dfa.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#define remaining_buflen(buffer, position) (sizeof(buffer) - ((position) - (buffer)))\n+\n@@ -1536,1 +1538,1 @@\n-      sprintf(s,\"\/*%s*\/(\",(char*)i._key);\n+      snprintf_checked(s, remaining_buflen(buf, s), \"\/*%s*\/(\",(char*)i._key);\n@@ -3475,1 +3477,1 @@\n-  sprintf(subtree,\"_%s_%s_%s\", _opType, lstr, rstr);\n+  snprintf_checked(subtree, len, \"_%s_%s_%s\", _opType, lstr, rstr);\n@@ -3922,2 +3924,3 @@\n-  char* buf = (char*) AdlAllocateHeap(strlen(instr_ident) + 4);\n-  sprintf(buf, \"%s_%d\", instr_ident, match_rules_cnt++);\n+  const size_t buf_size = strlen(instr_ident) + 4;\n+  char* buf = (char*) AdlAllocateHeap(buf_size);\n+  snprintf_checked(buf, buf_size, \"%s_%d\", instr_ident, match_rules_cnt++);\n@@ -4226,1 +4229,1 @@\n-    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\",\n+    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\", \"VectorCastF2HF\", \"VectorCastHF2F\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -469,1 +469,1 @@\n-  sprintf(fname,\"%s%s\",base,suffix);\n+  snprintf_checked(fname,len,\"%s%s\",base,suffix);\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#define remaining_buflen(buffer, position) (sizeof(buffer) - (position - buffer))\n+\n@@ -38,0 +40,10 @@\n+int snprintf_checked(char* buf, size_t len, const char* fmt, ...) {\n+  va_list args;\n+  va_start(args, fmt);\n+  int result = vsnprintf(buf, len, fmt, args);\n+  va_end(args);\n+  assert(result >= 0, \"snprintf error\");\n+  assert(static_cast<size_t>(result) < len, \"snprintf truncated\");\n+  return result;\n+}\n+\n@@ -200,1 +212,2 @@\n-  char *operand_stages = new char [templen];\n+  const size_t operand_stages_size = templen;\n+  char *operand_stages = new char [operand_stages_size];\n@@ -214,1 +227,1 @@\n-    templen += sprintf(&operand_stages[templen], \"  stage_%s%c\\n\",\n+    templen += snprintf_checked(&operand_stages[templen], operand_stages_size - templen, \"  stage_%s%c\\n\",\n@@ -281,0 +294,1 @@\n+  const size_t resource_stages_size = templen;\n@@ -288,1 +302,1 @@\n-    templen += sprintf(&resource_stages[templen], \"  stage_%s%-*s \/\/ %s\\n\",\n+    templen += snprintf_checked(&resource_stages[templen], resource_stages_size - templen, \"  stage_%s%-*s \/\/ %s\\n\",\n@@ -347,1 +361,1 @@\n-    templen = sprintf(temp, \"%d\", res_cycles[i]);\n+    templen = snprintf_checked(temp, sizeof(temp), \"%d\", res_cycles[i]);\n@@ -356,1 +370,2 @@\n-  char * resource_cycles = new char [templen];\n+  const size_t resource_cycles_size = templen;\n+  char * resource_cycles = new char [resource_cycles_size];\n@@ -361,1 +376,1 @@\n-    templen += sprintf(&resource_cycles[templen], \"  %*d%c \/\/ %s\\n\",\n+    templen += snprintf_checked(&resource_cycles[templen], resource_cycles_size - templen, \"  %*d%c \/\/ %s\\n\",\n@@ -434,1 +449,2 @@\n-  char * resource_mask = new char [templen];\n+  const size_t resource_mask_size = templen;\n+  char * resource_mask = new char [resource_mask_size];\n@@ -459,1 +475,1 @@\n-      sprintf(&resource_mask[templen], \"  %s(0x%0*x, %*d, %*d, %s %s(\",\n+      snprintf_checked(&resource_mask[templen], resource_mask_size - templen, \"  %s(0x%0*x, %*d, %*d, %s %s(\",\n@@ -499,1 +515,1 @@\n-        sprintf(&resource_mask[templen], \"0x%08x%s\", res_mask[j], j > 0 ? \", \" : \"\");\n+        snprintf_checked(&resource_mask[templen], resource_mask_size - templen, \"0x%08x%s\", res_mask[j], j > 0 ? \", \" : \"\");\n@@ -530,3 +546,2 @@\n-    int printed = sprintf(args, \"0x%x, 0x%x, %u\",\n-      resources_used, resources_used_exclusively, element_count);\n-    assert(printed <= 36, \"overflow\");\n+    snprintf_checked(args, 36 + 1, \"0x%x, 0x%x, %u\",\n+        resources_used, resources_used_exclusively, element_count);\n@@ -1069,1 +1084,1 @@\n-        sprintf(inst_prefix, \"inst%d_\",   inst_position);\n+        snprintf_checked(inst_prefix, sizeof(inst_prefix), \"inst%d_\",   inst_position);\n@@ -1071,1 +1086,1 @@\n-        sprintf(receiver,    \"inst%d->\", inst_position);\n+        snprintf_checked(receiver, sizeof(receiver), \"inst%d->\", inst_position);\n@@ -1165,1 +1180,1 @@\n-          sprintf(left_reg_index,\",inst%u_idx%u\", (unsigned)left_index, (unsigned)left_op_index);\n+          snprintf_checked(left_reg_index, sizeof(left_reg_index), \",inst%u_idx%u\", (unsigned)left_index, (unsigned)left_op_index);\n@@ -1177,1 +1192,1 @@\n-            sprintf(right_reg_index,\",inst%u_idx%u\", (unsigned)right_index, (unsigned)right_op_index);\n+            snprintf_checked(right_reg_index, sizeof(right_reg_index), \",inst%u_idx%u\", (unsigned)right_index, (unsigned)right_op_index);\n@@ -2566,1 +2581,1 @@\n-      ib += sprintf(ib, \"  unsigned idx_%-5s = mach_constant_base_node_input(); \\t\/\/ %s, \\t%s\\n\",\n+      ib += snprintf_checked(ib, remaining_buflen(idxbuf, ib), \"  unsigned idx_%-5s = mach_constant_base_node_input(); \\t\/\/ %s, \\t%s\\n\",\n@@ -2568,1 +2583,1 @@\n-      nb += sprintf(nb, \"  Node    *n_%-7s = lookup(idx_%s);\\n\", name, name);\n+      nb += snprintf_checked(nb, remaining_buflen(nbuf, nb), \"  Node    *n_%-7s = lookup(idx_%s);\\n\", name, name);\n@@ -2575,1 +2590,1 @@\n-      ib += sprintf(ib, \"  unsigned idx_%-5s = idx%d; \\t\/\/ %s, \\t%s\\n\",\n+      ib += snprintf_checked(ib, remaining_buflen(idxbuf, ib), \"  unsigned idx_%-5s = idx%d; \\t\/\/ %s, \\t%s\\n\",\n@@ -2577,2 +2592,2 @@\n-      nb += sprintf(nb, \"  Node    *n_%-7s = lookup(idx_%s);\\n\", name, name);\n-      ob += sprintf(ob, \"  %sOper *op_%s = (%sOper *)opnd_array(%d);\\n\", type, name, type, idx);\n+      nb += snprintf_checked(nb, remaining_buflen(nbuf, nb), \"  Node    *n_%-7s = lookup(idx_%s);\\n\", name, name);\n+      ob += snprintf_checked(ob, remaining_buflen(opbuf, ob), \"  %sOper *op_%s = (%sOper *)opnd_array(%d);\\n\", type, name, type, idx);\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":36,"deletions":21,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1431,2 +1431,2 @@\n-void LIRGenerator::do_extentLocalCache(Intrinsic* x) {\n-  do_JavaThreadField(x, JavaThread::extentLocalCache_offset());\n+void LIRGenerator::do_scopedValueCache(Intrinsic* x) {\n+  do_JavaThreadField(x, JavaThread::scopedValueCache_offset());\n@@ -2951,1 +2951,1 @@\n-  case vmIntrinsics::_extentLocalCache: do_extentLocalCache(x); break;\n+  case vmIntrinsics::_scopedValueCache: do_scopedValueCache(x); break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  void do_extentLocalCache(Intrinsic* x);\n+  void do_scopedValueCache(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -691,1 +691,1 @@\n-  sprintf(message, \"Index %d out of bounds for length %d\", index, a->length());\n+  os::snprintf_checked(message, sizeof(message), \"Index %d out of bounds for length %d\", index, a->length());\n@@ -703,1 +703,1 @@\n-  sprintf(message, \"%d\", index);\n+  os::snprintf_checked(message, sizeof(message), \"%d\", index);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    trace_to_root(orig_obj, NULL, &value);\n+    trace_to_root(&ls, orig_obj, NULL, &value);\n@@ -251,1 +251,1 @@\n-  LogStream* _ls;\n+  outputStream* _st;\n@@ -254,2 +254,2 @@\n-  TraceFields(oop orig_obj, oop orig_field, LogStream* ls)\n-    : _orig_obj(orig_obj), _orig_field(orig_field), _ls(ls) {}\n+  TraceFields(oop orig_obj, oop orig_field, outputStream* st)\n+    : _orig_obj(orig_obj), _orig_field(orig_field), _st(st) {}\n@@ -261,1 +261,1 @@\n-        _ls->print(\"::%s (offset = %d)\", fd->name()->as_C_string(), fd->offset());\n+        _st->print(\"::%s (offset = %d)\", fd->name()->as_C_string(), fd->offset());\n@@ -267,2 +267,11 @@\n-\/\/ Hint: to exercise this function, uncomment out one of the ADD_EXCL lines above.\n-int CDSHeapVerifier::trace_to_root(oop orig_obj, oop orig_field, HeapShared::CachedOopInfo* p) {\n+\/\/ Call this function (from gdb, etc) if you want to know why an object is archived.\n+void CDSHeapVerifier::trace_to_root(outputStream* st, oop orig_obj) {\n+  HeapShared::CachedOopInfo* info = HeapShared::archived_object_cache()->get(orig_obj);\n+  if (info != NULL) {\n+    trace_to_root(st, orig_obj, NULL, info);\n+  } else {\n+    st->print_cr(\"Not an archived object??\");\n+  }\n+}\n+\n+int CDSHeapVerifier::trace_to_root(outputStream* st, oop orig_obj, oop orig_field, HeapShared::CachedOopInfo* info) {\n@@ -270,3 +279,2 @@\n-  LogStream ls(Log(cds, heap)::warning());\n-  if (p->_referrer != NULL) {\n-    HeapShared::CachedOopInfo* ref = HeapShared::archived_object_cache()->get(p->_referrer);\n+  if (info->_referrer != NULL) {\n+    HeapShared::CachedOopInfo* ref = HeapShared::archived_object_cache()->get(info->_referrer);\n@@ -274,1 +282,1 @@\n-    level = trace_to_root(p->_referrer, orig_obj, ref) + 1;\n+    level = trace_to_root(st, info->_referrer, orig_obj, ref) + 1;\n@@ -276,1 +284,1 @@\n-    ls.print_cr(\"[%2d] (shared string table)\", level++);\n+    st->print_cr(\"[%2d] (shared string table)\", level++);\n@@ -280,3 +288,3 @@\n-  ls.print(\"[%2d] \", level);\n-  orig_obj->print_address_on(&ls);\n-  ls.print(\" %s\", k->internal_name());\n+  st->print(\"[%2d] \", level);\n+  orig_obj->print_address_on(st);\n+  st->print(\" %s\", k->internal_name());\n@@ -285,1 +293,1 @@\n-      TraceFields clo(orig_obj, orig_field, &ls);;\n+      TraceFields clo(orig_obj, orig_field, st);\n@@ -292,1 +300,1 @@\n-          ls.print(\" @[%d]\", i);\n+          st->print(\" @[%d]\", i);\n@@ -298,1 +306,1 @@\n-  ls.cr();\n+  st->cr();\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  int trace_to_root(oop orig_obj, oop orig_field, HeapShared::CachedOopInfo* p);\n+  static int trace_to_root(outputStream* st, oop orig_obj, oop orig_field, HeapShared::CachedOopInfo* p);\n@@ -86,0 +86,2 @@\n+\n+  static void trace_to_root(outputStream* st, oop orig_obj);\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-    sprintf(&header_version[JVM_IDENT_MAX-9], \"%08x\", hash);\n+    os::snprintf_checked(&header_version[JVM_IDENT_MAX-9], 9, \"%08x\", hash);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,5 @@\n+size_t HeapShared::_alloc_count[HeapShared::ALLOC_STAT_SLOTS];\n+size_t HeapShared::_alloc_size[HeapShared::ALLOC_STAT_SLOTS];\n+size_t HeapShared::_total_obj_count;\n+size_t HeapShared::_total_obj_size;\n+\n@@ -304,0 +309,1 @@\n+    count_allocation(len);\n@@ -589,0 +595,1 @@\n+  count_allocation(roots()->size());\n@@ -834,0 +841,3 @@\n+  if (log_is_enabled(Info, cds, heap)) {\n+    print_stats();\n+  }\n@@ -1861,0 +1871,45 @@\n+void HeapShared::count_allocation(size_t size) {\n+  _total_obj_count ++;\n+  _total_obj_size += size;\n+  for (int i = 0; i < ALLOC_STAT_SLOTS; i++) {\n+    if (size <= (size_t(1) << i)) {\n+      _alloc_count[i] ++;\n+      _alloc_size[i] += size;\n+      return;\n+    }\n+  }\n+}\n+\n+static double avg_size(size_t size, size_t count) {\n+  double avg = 0;\n+  if (count > 0) {\n+    avg = double(size * HeapWordSize) \/ double(count);\n+  }\n+  return avg;\n+}\n+\n+void HeapShared::print_stats() {\n+  size_t huge_count = _total_obj_count;\n+  size_t huge_size = _total_obj_size;\n+\n+  for (int i = 0; i < ALLOC_STAT_SLOTS; i++) {\n+    size_t byte_size_limit = (size_t(1) << i) * HeapWordSize;\n+    size_t count = _alloc_count[i];\n+    size_t size = _alloc_size[i];\n+    log_info(cds, heap)(SIZE_FORMAT_W(8) \" objects are <= \" SIZE_FORMAT_W(-6)\n+                        \" bytes (total \" SIZE_FORMAT_W(8) \" bytes, avg %8.1f bytes)\",\n+                        count, byte_size_limit, size * HeapWordSize, avg_size(size, count));\n+    huge_count -= count;\n+    huge_size -= size;\n+  }\n+\n+  log_info(cds, heap)(SIZE_FORMAT_W(8) \" huge  objects               (total \"  SIZE_FORMAT_W(8) \" bytes\"\n+                      \", avg %8.1f bytes)\",\n+                      huge_count, huge_size * HeapWordSize,\n+                      avg_size(huge_size, huge_count));\n+  log_info(cds, heap)(SIZE_FORMAT_W(8) \" total objects               (total \"  SIZE_FORMAT_W(8) \" bytes\"\n+                      \", avg %8.1f bytes)\",\n+                      _total_obj_count, _total_obj_size * HeapWordSize,\n+                      avg_size(_total_obj_size, _total_obj_count));\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -165,0 +165,9 @@\n+  \/\/ statistics\n+  constexpr static int ALLOC_STAT_SLOTS = 16;\n+  static size_t _alloc_count[ALLOC_STAT_SLOTS];\n+  static size_t _alloc_size[ALLOC_STAT_SLOTS];\n+  static size_t _total_obj_count;\n+  static size_t _total_obj_size; \/\/ in HeapWords\n+\n+  static void count_allocation(size_t size);\n+  static void print_stats();\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -145,0 +145,2 @@\n+#define JAVA_21_VERSION                   65\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -674,0 +674,12 @@\n+\/\/ Gets the exploded path for the named module. The memory for the path\n+\/\/ is allocated on the C heap if `c_heap` is true otherwise in the resource area.\n+static const char* get_exploded_module_path(const char* module_name, bool c_heap) {\n+  const char *home = Arguments::get_java_home();\n+  const char file_sep = os::file_separator()[0];\n+  \/\/ 10 represents the length of \"modules\" + 2 file separators + \\0\n+  size_t len = strlen(home) + strlen(module_name) + 10;\n+  char *path = c_heap ? NEW_C_HEAP_ARRAY(char, len, mtModule) : NEW_RESOURCE_ARRAY(char, len);\n+  jio_snprintf(path, len, \"%s%cmodules%c%s\", home, file_sep, file_sep, module_name);\n+  return path;\n+}\n+\n@@ -683,6 +695,1 @@\n-  const char *home = Arguments::get_java_home();\n-  const char file_sep = os::file_separator()[0];\n-  \/\/ 10 represents the length of \"modules\" + 2 file separators + \\0\n-  size_t len = strlen(home) + strlen(module_name) + 10;\n-  char *path = NEW_RESOURCE_ARRAY(char, len);\n-  jio_snprintf(path, len, \"%s%cmodules%c%s\", home, file_sep, file_sep, module_name);\n+  const char *path = get_exploded_module_path(module_name, false);\n@@ -1418,0 +1425,14 @@\n+bool ClassLoader::is_module_observable(const char* module_name) {\n+  assert(JImageOpen != NULL, \"jimage library should have been opened\");\n+  if (JImage_file == NULL) {\n+    struct stat st;\n+    const char *path = get_exploded_module_path(module_name, true);\n+    bool res = os::stat(path, &st) == 0;\n+    FREE_C_HEAP_ARRAY(char, path);\n+    return res;\n+  }\n+  jlong size;\n+  const char *jimage_version = get_jimage_version_string();\n+  return (*JImageFindResource)(JImage_file, module_name, jimage_version, \"module-info.class\", &size) != 0;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -377,0 +377,4 @@\n+  \/\/ Determines if the named module is present in the\n+  \/\/ modules jimage file or in the exploded modules directory.\n+  static bool is_module_observable(const char* module_name);\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1686,1 +1686,1 @@\n-int java_lang_Thread::_extentLocalBindings_offset;\n+int java_lang_Thread::_scopedValueBindings_offset;\n@@ -1699,1 +1699,1 @@\n-  macro(_extentLocalBindings_offset, k, \"extentLocalBindings\", object_signature, false);\n+  macro(_scopedValueBindings_offset, k, \"scopedValueBindings\", object_signature, false);\n@@ -1732,2 +1732,3 @@\n-void java_lang_Thread::clear_extentLocalBindings(oop java_thread) {\n-  java_thread->obj_field_put(_extentLocalBindings_offset, NULL);\n+void java_lang_Thread::clear_scopedValueBindings(oop java_thread) {\n+  assert(java_thread != NULL, \"need a java_lang_Thread pointer here\");\n+  java_thread->obj_field_put(_scopedValueBindings_offset, NULL);\n@@ -2494,1 +2495,2 @@\n-  char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);\n+  const size_t buf_size = buf_len + 64;\n+  char* buf = NEW_RESOURCE_ARRAY(char, buf_size);\n@@ -2497,1 +2499,1 @@\n-  sprintf(buf, \"\\tat %s.%s(\", klass_name, method_name);\n+  size_t buf_off = os::snprintf_checked(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n@@ -2502,1 +2504,1 @@\n-      sprintf(buf + (int)strlen(buf), \"%s@%s\/\", module_name, module_version);\n+      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n@@ -2504,1 +2506,1 @@\n-      sprintf(buf + (int)strlen(buf), \"%s\/\", module_name);\n+      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n@@ -2519,1 +2521,1 @@\n-        sprintf(buf + (int)strlen(buf), \"%s:%d)\", source_file_name, line_number);\n+        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n@@ -2522,1 +2524,1 @@\n-        sprintf(buf + (int)strlen(buf), \"%s)\", source_file_name);\n+        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n@@ -2525,1 +2527,1 @@\n-        sprintf(buf + (int)strlen(buf), \"Unknown Source)\");\n+        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n@@ -2529,1 +2531,1 @@\n-        sprintf(buf + (int)strlen(buf), \"(nmethod \" INTPTR_FORMAT \")\", (intptr_t)nm);\n+        os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"(nmethod \" INTPTR_FORMAT \")\", (intptr_t)nm);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-  static int _extentLocalBindings_offset;\n+  static int _scopedValueBindings_offset;\n@@ -401,2 +401,2 @@\n-  \/\/ Clear all extent local bindings on error\n-  static void clear_extentLocalBindings(oop java_thread);\n+  \/\/ Clear all scoped value bindings on error\n+  static void clear_scopedValueBindings(oop java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n@@ -130,2 +130,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n@@ -268,2 +268,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                                                                                                                       \\\n+                                                                                                                        \\\n@@ -289,6 +289,9 @@\n-  do_intrinsic(_extentLocalCache,          java_lang_Thread,       extentLocalCache_name, extentLocalCache_signature, F_SN) \\\n-   do_name(     extentLocalCache_name,                            \"extentLocalCache\")                                     \\\n-   do_signature(extentLocalCache_signature,                       \"()[Ljava\/lang\/Object;\")                               \\\n-  do_intrinsic(_setExtentLocalCache,       java_lang_Thread,       setExtentLocalCache_name, setExtentLocalCache_signature, F_SN) \\\n-   do_name(     setExtentLocalCache_name,                         \"setExtentLocalCache\")                                  \\\n-   do_signature(setExtentLocalCache_signature,                    \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_scopedValueCache,         java_lang_Thread,       scopedValueCache_name, scopedValueCache_signature, F_SN) \\\n+   do_name(     scopedValueCache_name,                           \"scopedValueCache\")                                    \\\n+   do_signature(scopedValueCache_signature,                      \"()[Ljava\/lang\/Object;\")                               \\\n+  do_intrinsic(_setScopedValueCache,      java_lang_Thread,       setScopedValueCache_name, setScopedValueCache_signature, F_SN) \\\n+   do_name(     setScopedValueCache_name,                        \"setScopedValueCache\")                                 \\\n+   do_signature(setScopedValueCache_signature,                   \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_findScopedValueBindings,  java_lang_Thread,       findScopedValueBindings_name, void_object_signature, F_SN) \\\n+   do_name(     findScopedValueBindings_name,                    \"findScopedValueBindings\")                             \\\n+                                                                                                                        \\\n@@ -334,0 +337,3 @@\n+  do_intrinsic(_ensureMaterializedForStackWalk, java_lang_Thread, ensureMaterializedForStackWalk_name, object_void_signature, F_SN)  \\\n+   do_name(     ensureMaterializedForStackWalk_name,              \"ensureMaterializedForStackWalk\")                     \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -159,0 +159,2 @@\n+  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n+  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n@@ -399,0 +401,1 @@\n+  template(runWith_method_name,                       \"runWith\")                                  \\\n@@ -604,0 +607,1 @@\n+  template(runnable_void_signature,                   \"(Ljava\/lang\/Runnable;)V\")                                   \\\n@@ -744,0 +748,4 @@\n+  template(serializeSavedPropertiesToByteArray_name,   \"serializeSavedPropertiesToByteArray\")                     \\\n+  template(encodeThrowable_name,                       \"encodeThrowable\")                                         \\\n+  template(encodeThrowable_signature,                  \"(Ljava\/lang\/Throwable;JI)I\")                              \\\n+  template(decodeAndThrowThrowable_name,               \"decodeAndThrowThrowable\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -780,1 +780,2 @@\n-      char xn[12]; sprintf(xn, \"x%d\", j);\n+      char xn[12];\n+      os::snprintf_checked(xn, sizeof(xn), \"x%d\", j);\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -935,1 +935,1 @@\n-    sprintf(name_buffer, \"%s CompilerThread%d\", _compilers[1]->name(), i);\n+    os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", _compilers[1]->name(), i);\n@@ -957,1 +957,1 @@\n-    sprintf(name_buffer, \"C1 CompilerThread%d\", i);\n+    os::snprintf_checked(name_buffer, sizeof(name_buffer), \"C1 CompilerThread%d\", i);\n@@ -1021,1 +1021,1 @@\n-        sprintf(name_buffer, \"%s CompilerThread%d\", _compilers[1]->name(), i);\n+        os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", _compilers[1]->name(), i);\n@@ -2603,1 +2603,1 @@\n-      sprintf(tier_name, \"Tier%d\", tier);\n+      os::snprintf_checked(tier_name, sizeof(tier_name), \"Tier%d\", tier);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1012,1 +1012,1 @@\n-                    && (if_ctrl->in(0)->is_MultiBranch() && if_ctrl->in(0)->Opcode() == Op_NeverBranch)) {\n+                    && if_ctrl->in(0)->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2561,2 +2561,3 @@\n-  size_t eden_used_bytes = _eden.used_bytes();\n-  size_t survivor_used_bytes = _survivor.used_bytes();\n+  size_t eden_used_bytes = _monitoring_support->eden_space_used();\n+  size_t survivor_used_bytes = _monitoring_support->survivor_space_used();\n+  size_t old_gen_used_bytes = _monitoring_support->old_gen_used();\n@@ -2569,2 +2570,2 @@\n-  return G1HeapSummary(heap_summary, heap_used, eden_used_bytes,\n-                       eden_capacity_bytes, survivor_used_bytes, num_regions());\n+  return G1HeapSummary(heap_summary, heap_used, eden_used_bytes, eden_capacity_bytes,\n+                       survivor_used_bytes, old_gen_used_bytes, num_regions());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -415,2 +415,1 @@\n-  const double sum_ms = _root_region_scan_wait_time_ms +\n-                        _cur_prepare_tlab_time_ms +\n+  const double sum_ms = _cur_prepare_tlab_time_ms +\n@@ -426,3 +425,0 @@\n-  if (_root_region_scan_wait_time_ms > 0.0) {\n-    debug_time(\"Root Region Scan Waiting\", _root_region_scan_wait_time_ms);\n-  }\n@@ -560,0 +556,4 @@\n+  if (_root_region_scan_wait_time_ms > 0.0) {\n+    debug_time(\"Root Region Scan Waiting\", _root_region_scan_wait_time_ms);\n+  }\n+\n@@ -568,0 +568,4 @@\n+\n+  accounted_ms += _root_region_scan_wait_time_ms;\n+  accounted_ms += _cur_verify_before_time_ms;\n+\n@@ -572,0 +576,3 @@\n+\n+  accounted_ms += _cur_verify_after_time_ms;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  _incremental_memory_manager(\"G1 Young Generation\", \"end of minor GC\"),\n+  _young_gc_memory_manager(\"G1 Young Generation\", \"end of minor GC\"),\n@@ -97,1 +97,1 @@\n-  _incremental_collection_counters(NULL),\n+  _young_collection_counters(NULL),\n@@ -124,1 +124,1 @@\n-  _incremental_collection_counters =\n+  _young_collection_counters =\n@@ -205,3 +205,3 @@\n-  _incremental_memory_manager.add_pool(_eden_space_pool);\n-  _incremental_memory_manager.add_pool(_survivor_space_pool);\n-  _incremental_memory_manager.add_pool(_old_gen_pool, false \/* always_affected_by_gc *\/);\n+  _young_gc_memory_manager.add_pool(_eden_space_pool);\n+  _young_gc_memory_manager.add_pool(_survivor_space_pool);\n+  _young_gc_memory_manager.add_pool(_old_gen_pool, false \/* always_affected_by_gc *\/);\n@@ -217,1 +217,1 @@\n-  memory_managers.append(&_incremental_memory_manager);\n+  memory_managers.append(&_young_gc_memory_manager);\n@@ -301,1 +301,1 @@\n-   \/\/ only the \"to\" survivor space is active, so we don't need to\n+    \/\/ only the \"to\" survivor space is active, so we don't need to\n@@ -370,2 +370,2 @@\n-                    monitoring_support->_incremental_collection_counters,\n-                    &monitoring_support->_incremental_memory_manager,\n+                    monitoring_support->_young_collection_counters,\n+                    &monitoring_support->_young_gc_memory_manager,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  GCMemoryManager _incremental_memory_manager;\n+  GCMemoryManager _young_gc_memory_manager;\n@@ -140,2 +140,2 @@\n-  \/\/  incremental collections both young and mixed\n-  CollectorCounters*   _incremental_collection_counters;\n+  \/\/  young stop-the-world collections (including mixed)\n+  CollectorCounters*   _young_collection_counters;\n@@ -144,1 +144,1 @@\n-  \/\/  stop-the-world phases in G1\n+  \/\/  stop-the-world phases in G1 concurrent collection\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-        MarkingCodeBlobClosure code_closure(&roots_to_old_closure, CodeBlobToOopClosure::FixRelocations, true \/* keepalive nmethods *\/);\n+        MarkingCodeBlobClosure code_closure(&roots_to_old_closure, CodeBlobToOopClosure::FixRelocations, false \/* keepalive nmethods *\/);\n@@ -273,1 +273,1 @@\n-    MarkingCodeBlobClosure roots_in_blobs(&roots_closure, CodeBlobToOopClosure::FixRelocations, true \/* keepalive nmethods *\/);\n+    MarkingCodeBlobClosure roots_in_blobs(&roots_closure, CodeBlobToOopClosure::FixRelocations, false \/* keepalive nmethods *\/);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,6 +188,7 @@\n-    gch->full_process_roots(false, \/\/ not the adjust phase\n-                            GenCollectedHeap::SO_None,\n-                            ClassUnloading, \/\/ only strong roots if ClassUnloading\n-                                            \/\/ is enabled\n-                            &follow_root_closure,\n-                            &follow_cld_closure);\n+    CLDClosure* weak_cld_closure = ClassUnloading ? NULL : &follow_cld_closure;\n+    MarkingCodeBlobClosure mark_code_closure(&follow_root_closure, !CodeBlobToOopClosure::FixRelocations, true);\n+    gch->process_roots(GenCollectedHeap::SO_None,\n+                       &follow_root_closure,\n+                       &follow_cld_closure,\n+                       weak_cld_closure,\n+                       &mark_code_closure);\n@@ -265,9 +266,6 @@\n-  {\n-    StrongRootsScope srs(0);\n-\n-    gch->full_process_roots(true,  \/\/ this is the adjust phase\n-                            GenCollectedHeap::SO_AllCodeCache,\n-                            false, \/\/ all roots\n-                            &adjust_pointer_closure,\n-                            &adjust_cld_closure);\n-  }\n+  CodeBlobToOopClosure code_closure(&adjust_pointer_closure, CodeBlobToOopClosure::FixRelocations);\n+  gch->process_roots(GenCollectedHeap::SO_AllCodeCache,\n+                     &adjust_pointer_closure,\n+                     &adjust_cld_closure,\n+                     &adjust_cld_closure,\n+                     &code_closure);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-MarkAndPushClosure MarkSweep::mark_and_push_closure;\n+MarkAndPushClosure MarkSweep::mark_and_push_closure(ClassLoaderData::_claim_stw_fullgc_mark);\n@@ -68,1 +68,1 @@\n-template <class T> inline void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {\n+template <class T> void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {\n@@ -78,1 +78,1 @@\n-inline void MarkSweep::follow_array(objArrayOop array) {\n+void MarkSweep::follow_array(objArrayOop array) {\n@@ -86,1 +86,1 @@\n-inline void MarkSweep::follow_object(oop obj) {\n+void MarkSweep::follow_object(oop obj) {\n@@ -131,1 +131,1 @@\n-template <class T> inline void MarkSweep::follow_root(T* p) {\n+template <class T> void MarkSweep::follow_root(T* p) {\n@@ -176,0 +176,40 @@\n+void MarkSweep::mark_object(oop obj) {\n+  if (StringDedup::is_enabled() &&\n+      java_lang_String::is_instance(obj) &&\n+      SerialStringDedup::is_candidate_from_mark(obj)) {\n+    _string_dedup_requests->add(obj);\n+  }\n+\n+  \/\/ some marks may contain information we need to preserve so we store them away\n+  \/\/ and overwrite the mark.  We'll restore it at the end of markSweep.\n+  markWord mark = obj->mark();\n+  obj->set_mark(markWord::prototype().set_marked());\n+\n+  ContinuationGCSupport::transform_stack_chunk(obj);\n+\n+  if (obj->mark_must_be_preserved(mark)) {\n+    preserve_mark(obj, mark);\n+  }\n+}\n+\n+template <class T> void MarkSweep::mark_and_push(T* p) {\n+  T heap_oop = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(heap_oop)) {\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+    if (!obj->mark().is_marked()) {\n+      mark_object(obj);\n+      _marking_stack.push(obj);\n+    }\n+  }\n+}\n+\n+void MarkSweep::follow_klass(Klass* klass) {\n+  oop op = klass->class_loader_data()->holder_no_keepalive();\n+  MarkSweep::mark_and_push(&op);\n+}\n+\n+template <typename T>\n+void MarkAndPushClosure::do_oop_work(T* p)            { MarkSweep::mark_and_push(p); }\n+void MarkAndPushClosure::do_oop(      oop* p)         { do_oop_work(p); }\n+void MarkAndPushClosure::do_oop(narrowOop* p)         { do_oop_work(p); }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-class Method;\n-class nmethod;\n@@ -155,2 +153,0 @@\n-  static void follow_cld(ClassLoaderData* cld);\n-\n@@ -177,1 +173,1 @@\n-class MarkAndPushClosure: public OopIterateClosure {\n+class MarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n@@ -179,0 +175,2 @@\n+  MarkAndPushClosure(int claim) : ClaimMetadataVisitingOopIterateClosure(claim) {}\n+\n@@ -180,1 +178,1 @@\n-  virtual void do_oop(oop* p);\n+  virtual void do_oop(      oop* p);\n@@ -183,6 +181,0 @@\n-  virtual bool do_metadata() { return true; }\n-  virtual void do_klass(Klass* k);\n-  virtual void do_cld(ClassLoaderData* cld);\n-  virtual void do_method(Method* m);\n-  virtual void do_nmethod(nmethod* nm);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"code\/nmethod.hpp\"\n@@ -39,1 +38,0 @@\n-#include \"oops\/method.hpp\"\n@@ -44,48 +42,0 @@\n-inline void MarkSweep::mark_object(oop obj) {\n-  if (StringDedup::is_enabled() &&\n-      java_lang_String::is_instance(obj) &&\n-      SerialStringDedup::is_candidate_from_mark(obj)) {\n-    _string_dedup_requests->add(obj);\n-  }\n-\n-  \/\/ some marks may contain information we need to preserve so we store them away\n-  \/\/ and overwrite the mark.  We'll restore it at the end of markSweep.\n-  markWord mark = obj->mark();\n-  obj->set_mark(markWord::prototype().set_marked());\n-\n-  ContinuationGCSupport::transform_stack_chunk(obj);\n-\n-  if (obj->mark_must_be_preserved(mark)) {\n-    preserve_mark(obj, mark);\n-  }\n-}\n-\n-template <class T> inline void MarkSweep::mark_and_push(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    if (!obj->mark().is_marked()) {\n-      mark_object(obj);\n-      _marking_stack.push(obj);\n-    }\n-  }\n-}\n-\n-inline void MarkSweep::follow_klass(Klass* klass) {\n-  oop op = klass->class_loader_data()->holder_no_keepalive();\n-  MarkSweep::mark_and_push(&op);\n-}\n-\n-inline void MarkSweep::follow_cld(ClassLoaderData* cld) {\n-  MarkSweep::follow_cld_closure.do_cld(cld);\n-}\n-\n-template <typename T>\n-inline void MarkAndPushClosure::do_oop_work(T* p)            { MarkSweep::mark_and_push(p); }\n-inline void MarkAndPushClosure::do_oop(oop* p)               { do_oop_work(p); }\n-inline void MarkAndPushClosure::do_oop(narrowOop* p)         { do_oop_work(p); }\n-inline void MarkAndPushClosure::do_klass(Klass* k)           { MarkSweep::follow_klass(k); }\n-inline void MarkAndPushClosure::do_cld(ClassLoaderData* cld) { MarkSweep::follow_cld(cld); }\n-inline void MarkAndPushClosure::do_method(Method* m)         { m->record_gc_epoch(); }\n-inline void MarkAndPushClosure::do_nmethod(nmethod* nm)      { nm->follow_nmethod(this); }\n-\n@@ -111,1 +61,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-void CardTableRS::younger_refs_in_space_iterate(Space* sp,\n+void CardTableRS::younger_refs_in_space_iterate(ContiguousSpace* sp,\n@@ -443,1 +443,1 @@\n-void CardTableRS::non_clean_card_iterate(Space* sp,\n+void CardTableRS::non_clean_card_iterate(ContiguousSpace* sp,\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class ContiguousSpace;\n@@ -35,1 +36,0 @@\n-\n@@ -50,1 +50,1 @@\n-  void younger_refs_in_space_iterate(Space* sp, HeapWord* gen_boundary, OopIterateClosure* cl);\n+  void younger_refs_in_space_iterate(ContiguousSpace* sp, HeapWord* gen_boundary, OopIterateClosure* cl);\n@@ -73,1 +73,1 @@\n-  void non_clean_card_iterate(Space* sp,\n+  void non_clean_card_iterate(ContiguousSpace* sp,\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,1 @@\n+  size_t  _oldGenUsed;\n@@ -122,2 +123,2 @@\n-   G1HeapSummary(VirtualSpaceSummary& heap_space, size_t heap_used, size_t edenUsed, size_t edenCapacity, size_t survivorUsed, uint numberOfRegions) :\n-      GCHeapSummary(heap_space, heap_used), _edenUsed(edenUsed), _edenCapacity(edenCapacity), _survivorUsed(survivorUsed), _numberOfRegions(numberOfRegions) { }\n+   G1HeapSummary(VirtualSpaceSummary& heap_space, size_t heap_used, size_t edenUsed, size_t edenCapacity, size_t survivorUsed, size_t oldGenUsed, uint numberOfRegions) :\n+      GCHeapSummary(heap_space, heap_used), _edenUsed(edenUsed), _edenCapacity(edenCapacity), _survivorUsed(survivorUsed), _oldGenUsed(oldGenUsed), _numberOfRegions(numberOfRegions) { }\n@@ -127,0 +128,1 @@\n+   const size_t oldGenUsed() const { return _oldGenUsed; }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcHeapSummary.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -247,0 +247,1 @@\n+      e.set_oldGenUsedSize(g1_heap_summary->oldGenUsed());\n@@ -392,0 +393,1 @@\n+      event.set_endtime(_needs_gc_start_timestamp);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceSend.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -796,14 +796,0 @@\n-void GenCollectedHeap::full_process_roots(bool is_adjust_phase,\n-                                          ScanningOption so,\n-                                          bool only_strong_roots,\n-                                          OopClosure* root_closure,\n-                                          CLDClosure* cld_closure) {\n-  \/\/ Called from either the marking phase or the adjust phase.\n-  const bool is_marking_phase = !is_adjust_phase;\n-\n-  MarkingCodeBlobClosure mark_code_closure(root_closure, is_adjust_phase, is_marking_phase);\n-  CLDClosure* weak_cld_closure = only_strong_roots ? NULL : cld_closure;\n-\n-  process_roots(so, root_closure, cld_closure, weak_cld_closure, &mark_code_closure);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -329,0 +329,5 @@\n+  virtual void gc_prologue(bool full);\n+  virtual void gc_epilogue(bool full);\n+\n+ public:\n+  \/\/ Apply closures on various roots in Young GC or marking\/adjust phases of Full GC.\n@@ -335,10 +340,0 @@\n-  virtual void gc_prologue(bool full);\n-  virtual void gc_epilogue(bool full);\n-\n- public:\n-  void full_process_roots(bool is_adjust_phase,\n-                          ScanningOption so,\n-                          bool only_strong_roots,\n-                          OopClosure* root_closure,\n-                          CLDClosure* cld_closure);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class KlassRemSet;\n","filename":"src\/hotspot\/share\/gc\/shared\/genOopClosures.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+    event.set_starttime(timestamp);\n+    event.set_endtime(timestamp);\n@@ -61,1 +63,0 @@\n-    event.set_endtime(timestamp);\n","filename":"src\/hotspot\/share\/gc\/shared\/objectCountEventSender.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,6 +164,0 @@\n-DirtyCardToOopClosure* Space::new_dcto_cl(OopIterateClosure* cl,\n-                                          CardTable::PrecisionStyle precision,\n-                                          HeapWord* boundary) {\n-  return new DirtyCardToOopClosure(this, cl, precision, boundary);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -135,1 +135,0 @@\n-  bool not_empty() const             { return used() > 0; }\n@@ -177,8 +176,0 @@\n-  \/\/ Create and return a new dirty card to oop closure. Can be\n-  \/\/ overridden to return the appropriate type of closure\n-  \/\/ depending on the type of space in which the closure will\n-  \/\/ operate. ResourceArea allocated.\n-  virtual DirtyCardToOopClosure* new_dcto_cl(OopIterateClosure* cl,\n-                                             CardTable::PrecisionStyle precision,\n-                                             HeapWord* boundary);\n-\n@@ -288,9 +279,0 @@\n-\n-  void set_min_done(HeapWord* min_done) {\n-    _min_done = min_done;\n-  }\n-#ifndef PRODUCT\n-  void set_last_bottom(HeapWord* last_bottom) {\n-    _last_bottom = last_bottom;\n-  }\n-#endif\n@@ -399,7 +381,0 @@\n-\n-  \/\/ Return a size with adjustments as required of the space.\n-  virtual size_t adjust_object_size_v(size_t size) const { return size; }\n-\n-  void set_first_dead(HeapWord* value) { _first_dead = value; }\n-  void set_end_of_live(HeapWord* value) { _end_of_live = value; }\n-\n@@ -494,1 +469,0 @@\n-  \/\/ Override.\n@@ -497,1 +471,1 @@\n-                                     HeapWord* boundary) override;\n+                                     HeapWord* boundary);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1031,1 +1031,1 @@\n-                      && (if_ctrl->in(0)->is_MultiBranch() && if_ctrl->in(0)->Opcode() == Op_NeverBranch)) {\n+                      && if_ctrl->in(0)->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,1 +760,1 @@\n-      } else if (c->Opcode() == Op_CProj && next->Opcode() == Op_NeverBranch) {\n+      } else if (c->Opcode() == Op_CProj && next->is_NeverBranch()) {\n@@ -2005,1 +2005,1 @@\n-    if (in != NULL && in->Opcode() == Op_Halt && in->in(0)->is_Proj() && in->in(0)->in(0)->Opcode() == Op_NeverBranch) {\n+    if (in != NULL && in->Opcode() == Op_Halt && in->in(0)->is_Proj() && in->in(0)->in(0)->is_NeverBranch()) {\n@@ -2036,1 +2036,1 @@\n-              assert(r->in(j)->Opcode() != Op_NeverBranch, \"\");\n+              assert(!r->in(j)->is_NeverBranch(), \"\");\n@@ -2042,1 +2042,1 @@\n-            assert(in->is_CallStaticJava() || in->Opcode() == Op_NeverBranch || in->Opcode() == Op_Catch || proj->is_IfProj(), \"\");\n+            assert(in->is_CallStaticJava() || in->is_NeverBranch() || in->Opcode() == Op_Catch || proj->is_IfProj(), \"\");\n@@ -2049,1 +2049,1 @@\n-            } else if (in->Opcode() == Op_NeverBranch) {\n+            } else if (in->is_NeverBranch()) {\n@@ -2521,1 +2521,1 @@\n-                     !(u->Opcode() == Op_CProj && u->in(0)->Opcode() == Op_NeverBranch && u->as_Proj()->_con == 1)) {\n+                     !(u->Opcode() == Op_CProj && u->in(0)->is_NeverBranch() && u->as_Proj()->_con == 1)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    while (v > 1) {\n+    while (v >= 1) {\n@@ -74,1 +74,1 @@\n-  \/\/ Defensively saturate for product bits:\n+  \/\/ Defensively saturate for product bits\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-class BinaryMagnitudeSeq {\n+class BinaryMagnitudeSeq : public CHeapObj<mtGC> {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-JVM_ExtentLocalCache(JNIEnv *env, jclass threadClass);\n+JVM_ScopedValueCache(JNIEnv *env, jclass threadClass);\n@@ -316,1 +316,4 @@\n-JVM_SetExtentLocalCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+JVM_SetScopedValueCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+\n+JNIEXPORT jobject JNICALL\n+JVM_FindScopedValueBindings(JNIEnv *env, jclass threadClass);\n@@ -745,0 +748,2 @@\n+JNIEXPORT void JNICALL\n+JVM_EnsureMaterializedForStackWalk_func(JNIEnv* env, jobject vthread, jobject value);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-    sprintf(what, \"indy#%d\", decode_indy_index());\n+    os::snprintf_checked(what, sizeof(what), \"indy#%d\", decode_indy_index());\n@@ -235,1 +235,1 @@\n-    sprintf(what, \"condy\");\n+    os::snprintf_checked(what, sizeof(what), \"condy\");\n@@ -254,1 +254,1 @@\n-        sprintf(argbuf + pos, \"...\");\n+        os::snprintf_checked(argbuf + pos, sizeof(argbuf) - pos, \"...\");\n@@ -258,1 +258,1 @@\n-      sprintf(argbuf+pos, \"%d\", arg_index(i));\n+      os::snprintf_checked(argbuf+pos, sizeof(argbuf) - pos, \"%d\", arg_index(i));\n","filename":"src\/hotspot\/share\/interpreter\/bootstrapInfo.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -375,0 +375,3 @@\n+  \/\/ Remove the ScopedValue bindings in case we got a StackOverflowError\n+  \/\/ while we were trying to manipulate ScopedValue bindings.\n+  current->clear_scopedValueBindings();\n@@ -386,0 +389,3 @@\n+  \/\/ Remove the ScopedValue bindings in case we got a StackOverflowError\n+  \/\/ while we were trying to manipulate ScopedValue bindings.\n+  current->clear_scopedValueBindings();\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -241,2 +241,2 @@\n-JVM_ENTRY_NO_ENV(jboolean, jfr_emit_event(JNIEnv* env, jobject jvm, jlong eventTypeId, jlong timeStamp, jlong when))\n-  JfrPeriodicEventSet::requestEvent((JfrEventId)eventTypeId);\n+JVM_ENTRY_NO_ENV(jboolean, jfr_emit_event(JNIEnv* env, jobject jvm, jlong event_type_id, jlong timestamp, jlong periodic_type))\n+  JfrPeriodicEventSet::requestEvent((JfrEventId)event_type_id, timestamp, static_cast<PeriodicType>(periodic_type));\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -332,0 +332,1 @@\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"oldGenUsedSize\" label=\"Old Generation Used Size\" \/>\n@@ -569,1 +570,3 @@\n-  <Event name=\"JITRestart\" category=\"Java Virtual Machine, Compiler\" label=\"JIT Restart\" stackTrace=\"false\" startTime=\"false\" thread=\"true\">\n+  <Event name=\"JITRestart\" category=\"Java Virtual Machine, Compiler\" label=\"JIT Restart\"\n+         description=\"Restart of the JIT compilers after they were stopped\"\n+         stackTrace=\"false\" startTime=\"false\" thread=\"true\">\n@@ -574,1 +577,3 @@\n-  <Event name=\"Compilation\" category=\"Java Virtual Machine, Compiler\" label=\"Compilation\" thread=\"true\">\n+  <Event name=\"Compilation\" category=\"Java Virtual Machine, Compiler\" label=\"Compilation\"\n+         description=\"Results of method compilation attempts\"\n+         thread=\"true\">\n@@ -585,1 +590,3 @@\n-  <Event name=\"CompilerPhase\" category=\"Java Virtual Machine, Compiler\" label=\"Compiler Phase\" thread=\"true\" >\n+  <Event name=\"CompilerPhase\" category=\"Java Virtual Machine, Compiler\" label=\"Compiler Phase\"\n+         description=\"Describes various phases of the compilation process like inlining or string optimization related phases\"\n+         thread=\"true\">\n@@ -591,1 +598,3 @@\n-  <Event name=\"CompilationFailure\" category=\"Java Virtual Machine, Compiler\" label=\"Compilation Failure\" thread=\"true\"  startTime=\"false\">\n+  <Event name=\"CompilationFailure\" category=\"Java Virtual Machine, Compiler\" label=\"Compilation Failure\"\n+         description=\"In case a JIT compilation failed, a compilation failure is triggered, reporting the reason\"\n+         thread=\"true\" startTime=\"false\">\n@@ -602,1 +611,3 @@\n-  <Event name=\"CompilerInlining\" category=\"Java Virtual Machine, Compiler, Optimization\" label=\"Method Inlining\" thread=\"true\" startTime=\"false\">\n+  <Event name=\"CompilerInlining\" category=\"Java Virtual Machine, Compiler, Optimization\" label=\"Method Inlining\"\n+         description=\"Describes the result of a method inlining attempt\"\n+         thread=\"true\" startTime=\"false\">\n@@ -611,1 +622,3 @@\n-  <Event name=\"CodeCacheFull\" category=\"Java Virtual Machine, Code Cache\" label=\"Code Cache Full\" thread=\"true\" startTime=\"false\">\n+  <Event name=\"CodeCacheFull\" category=\"Java Virtual Machine, Code Cache\" label=\"Code Cache Full\"\n+         description=\"A code heap is full, this leads to disabling the compiler\"\n+         thread=\"true\" startTime=\"false\">\n@@ -624,1 +637,3 @@\n-  <Event name=\"Deoptimization\" category=\"Java Virtual Machine, Compiler\" label=\"Deoptimization\" thread=\"true\" stackTrace=\"true\" startTime=\"false\">\n+  <Event name=\"Deoptimization\" category=\"Java Virtual Machine, Compiler\" label=\"Deoptimization\"\n+         description=\"Describes the detection of an uncommon situation in a compiled method which may lead to deoptimization of the method\"\n+         thread=\"true\" stackTrace=\"true\" startTime=\"false\">\n@@ -709,0 +724,13 @@\n+  <Event name=\"NativeMemoryUsage\" category=\"Java Virtual Machine, Memory\" label=\"Native Memory Usage Per Type\"\n+    description=\"Native memory usage for a given memory type in the JVM\" period=\"everyChunk\">\n+    <Field type=\"string\" name=\"type\" label=\"Memory Type\" description=\"Type used for the native memory allocation\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Reserved bytes for this type\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Committed bytes for this type\" \/>\n+  <\/Event>\n+\n+  <Event name=\"NativeMemoryUsageTotal\" category=\"Java Virtual Machine, Memory\" label=\"Total Native Memory Usage\"\n+    description=\"Total native memory usage for the JVM. Might not be the exact sum of the NativeMemoryUsage events due to timeing.\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Total amount of reserved bytes for the JVM\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Total amount of committed bytes for the JVM\" \/>\n+  <\/Event>\n+\n@@ -913,0 +941,1 @@\n+    <Field type=\"boolean\" name=\"dynamicCompilerThreadCount\" label=\"Uses Dynamic Number of Compiler Threads\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+  event.set_starttime(timestamp);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerStatisticsEvent.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+  event.set_starttime(invocation_time);\n@@ -71,0 +72,1 @@\n+  event.set_starttime(invocation_time);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrModuleEvent.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,1 @@\n+        event.set_starttime(time_stamp);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrOSInterface.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"services\/memJfrReporter.hpp\"\n@@ -83,0 +84,12 @@\n+\/\/ Timestamp to correlate events in the same batch\/generation\n+Ticks JfrPeriodicEventSet::_timestamp;\n+PeriodicType JfrPeriodicEventSet::_type;\n+\n+Ticks JfrPeriodicEventSet::timestamp(void) {\n+  return _timestamp;\n+}\n+\n+PeriodicType JfrPeriodicEventSet::type(void) {\n+  return _type;\n+}\n+\n@@ -141,0 +154,1 @@\n+  event.set_starttime(*(JfrTicks*)param);\n@@ -415,0 +429,1 @@\n+      event.set_starttime(time_stamp);\n@@ -441,0 +456,1 @@\n+    event.set_starttime(time_stamp);\n@@ -575,0 +591,1 @@\n+  event.set_dynamicCompilerThreadCount(UseDynamicNumberOfCompilerThreads);\n@@ -627,0 +644,8 @@\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsage) {\n+  MemJFRReporter::send_type_events();\n+}\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsageTotal) {\n+  MemJFRReporter::send_total_event();\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+      event.set_endtime(event_time);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrThreadCPULoadEvent.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -303,5 +303,5 @@\n-static const juint starttime_offset = sizeof(jlong);\n-static const juint duration_offset = starttime_offset + sizeof(jlong);\n-static const juint checkpoint_type_offset = duration_offset + sizeof(jlong);\n-static const juint types_offset = checkpoint_type_offset + sizeof(juint);\n-static const juint payload_offset = types_offset + sizeof(juint);\n+static const size_t starttime_offset = sizeof(int64_t);\n+static const size_t duration_offset = starttime_offset + sizeof(int64_t);\n+static const size_t checkpoint_type_offset = duration_offset + sizeof(int64_t);\n+static const size_t types_offset = checkpoint_type_offset + sizeof(uint32_t);\n+static const size_t payload_offset = types_offset + sizeof(uint32_t);\n@@ -314,2 +314,4 @@\n-static jlong total_size(const u1* data) {\n-  return read_data<jlong>(data);\n+static size_t total_size(const u1* data) {\n+  const int64_t size = read_data<int64_t>(data);\n+  assert(size > 0, \"invariant\");\n+  return static_cast<size_t>(size);\n@@ -318,2 +320,2 @@\n-static jlong starttime(const u1* data) {\n-  return read_data<jlong>(data + starttime_offset);\n+static int64_t starttime(const u1* data) {\n+  return read_data<int64_t>(data + starttime_offset);\n@@ -322,2 +324,2 @@\n-static jlong duration(const u1* data) {\n-  return read_data<jlong>(data + duration_offset);\n+static int64_t duration(const u1* data) {\n+  return read_data<int64_t>(data + duration_offset);\n@@ -326,2 +328,2 @@\n-static juint checkpoint_type(const u1* data) {\n-  return read_data<juint>(data + checkpoint_type_offset);\n+static int32_t checkpoint_type(const u1* data) {\n+  return read_data<int32_t>(data + checkpoint_type_offset);\n@@ -330,2 +332,2 @@\n-static juint number_of_types(const u1* data) {\n-  return read_data<juint>(data + types_offset);\n+static uint32_t number_of_types(const u1* data) {\n+  return read_data<uint32_t>(data + types_offset);\n@@ -334,8 +336,2 @@\n-static void write_checkpoint_header(JfrChunkWriter& cw, int64_t delta_to_last_checkpoint, const u1* data) {\n-  cw.reserve(sizeof(u4));\n-  cw.write<u8>(EVENT_CHECKPOINT);\n-  cw.write(starttime(data));\n-  cw.write(duration(data));\n-  cw.write(delta_to_last_checkpoint);\n-  cw.write(checkpoint_type(data));\n-  cw.write(number_of_types(data));\n+static size_t payload_size(const u1* data) {\n+  return total_size(data) - sizeof(JfrCheckpointEntry);\n@@ -344,14 +340,10 @@\n-static void write_checkpoint_content(JfrChunkWriter& cw, const u1* data, size_t size) {\n-  assert(data != NULL, \"invariant\");\n-  cw.write_unbuffered(data + payload_offset, size - sizeof(JfrCheckpointEntry));\n-}\n-\n-static size_t write_thread_checkpoint_content(JfrChunkWriter& cw, const u1* data) {\n-  assert(data != NULL, \"invariant\");\n-  const size_t size = total_size(data);\n-  assert(size > sizeof(JfrCheckpointEntry), \"invariant\");\n-  assert(checkpoint_type(data) == THREADS, \"invariant\");\n-  assert(number_of_types(data) == 1, \"invariant\");\n-  \/\/ Thread checkpoints are small so write them buffered to cache as much as possible before flush.\n-  cw.write_buffered(data + payload_offset, size - sizeof(JfrCheckpointEntry));\n-  return size;\n+static uint64_t calculate_event_size_bytes(JfrChunkWriter& cw, const u1* data, int64_t event_begin, int64_t delta_to_last_checkpoint) {\n+  assert(data != nullptr, \"invariant\");\n+  size_t bytes = cw.size_in_bytes(EVENT_CHECKPOINT);\n+  bytes += cw.size_in_bytes(starttime(data));\n+  bytes += cw.size_in_bytes(duration(data));\n+  bytes += cw.size_in_bytes(delta_to_last_checkpoint);\n+  bytes += cw.size_in_bytes(checkpoint_type(data));\n+  bytes += cw.size_in_bytes(number_of_types(data));\n+  bytes += payload_size(data); \/\/ in bytes already.\n+  return bytes + cw.size_in_bytes(bytes + cw.size_in_bytes(bytes));\n@@ -364,6 +356,0 @@\n-  const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n-  const int64_t checkpoint_size = total_size(data);\n-  write_checkpoint_header(cw, delta_to_last_checkpoint, data);\n-  write_checkpoint_content(cw, data, checkpoint_size);\n-  const int64_t event_size = cw.current_offset() - event_begin;\n-  cw.write_padded_at_offset<u4>(event_size, event_begin);\n@@ -371,1 +357,12 @@\n-  return (size_t)checkpoint_size;\n+  const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n+  const uint64_t event_size = calculate_event_size_bytes(cw, data, event_begin, delta_to_last_checkpoint);\n+  cw.write(event_size);\n+  cw.write(EVENT_CHECKPOINT);\n+  cw.write(starttime(data));\n+  cw.write(duration(data));\n+  cw.write(delta_to_last_checkpoint);\n+  cw.write(checkpoint_type(data));\n+  cw.write(number_of_types(data));\n+  cw.write_unbuffered(data + payload_offset, payload_size(data));\n+  assert(static_cast<uint64_t>(cw.current_offset() - event_begin) == event_size, \"invariant\");\n+  return total_size(data);\n@@ -390,0 +387,11 @@\n+static size_t write_thread_checkpoint_content(JfrChunkWriter& cw, const u1* data) {\n+  assert(data != NULL, \"invariant\");\n+  const size_t size = total_size(data);\n+  assert(size > 0, \"invariant\");\n+  assert(checkpoint_type(data) == THREADS, \"invariant\");\n+  assert(number_of_types(data) == 1, \"invariant\");\n+  \/\/ Thread checkpoints are small so write them buffered to cache as much as possible before flush.\n+  cw.write_buffered(data + payload_offset, payload_size(data));\n+  return size;\n+}\n+\n@@ -422,1 +430,0 @@\n-\n@@ -431,1 +438,1 @@\n-  u4 _elements;\n+  uint32_t _elements;\n@@ -437,2 +444,2 @@\n-    cw.reserve(sizeof(u4));\n-    cw.write<u8>(EVENT_CHECKPOINT);\n+    cw.reserve(sizeof(uint64_t));\n+    cw.write(EVENT_CHECKPOINT);\n@@ -446,1 +453,1 @@\n-    cw.reserve(sizeof(u4));\n+    cw.reserve(sizeof(uint32_t));\n@@ -456,2 +463,2 @@\n-    _cw.write_padded_at_offset<u4>(_elements, _elements_offset);\n-    _cw.write_padded_at_offset<u4>(event_size, _begin_offset);\n+    _cw.write_padded_at_offset(_elements, _elements_offset);\n+    _cw.write_padded_at_offset(event_size, _begin_offset);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":58,"deletions":51,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -277,1 +277,4 @@\n-  HandleMark hm(jt); \/\/ RegisterMap uses Handles to support continuations.\n+  \/\/ Must use ResetNoHandleMark here to bypass if any NoHandleMark exist on stack.\n+  \/\/ This is because RegisterMap uses Handles to support continuations.\n+  ResetNoHandleMark rnhm;\n+  HandleMark hm(jt);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-  sprintf(hash_buf, \"\/\" UINTX_FORMAT, hash);\n+  os::snprintf_checked(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, hash);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -132,0 +135,11 @@\n+template <typename T>\n+inline size_t BigEndianEncoderImpl::size_in_bytes(T value) {\n+  switch (sizeof(T)) {\n+    case 1: return 1;\n+    case 2: return 2;\n+    case 4: return 4;\n+    case 8:return 8;\n+  }\n+  ShouldNotReachHere();\n+  return 0;\n+}\n@@ -163,0 +177,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -298,0 +315,30 @@\n+template <typename T>\n+inline size_t Varint128EncoderImpl::size_in_bytes(T value) {\n+  const u8 v = to_u8(value);\n+  if (LESS_THAN_128(v)) {\n+    return 1;\n+  }\n+  if (LESS_THAN_128(v >> 7)) {\n+    return 2;\n+  }\n+  if (LESS_THAN_128(v >> 14)) {\n+    return 3;\n+  }\n+  if (LESS_THAN_128(v >> 21)) {\n+    return 4;\n+  }\n+  if (LESS_THAN_128(v >> 28)) {\n+    return 5;\n+  }\n+  if (LESS_THAN_128(v >> 35)) {\n+    return 6;\n+  }\n+  if (LESS_THAN_128(v >> 42)) {\n+    return 7;\n+  }\n+  if (LESS_THAN_128(v >> 49)) {\n+    return 8;\n+  }\n+  return 9;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoders.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -72,0 +72,5 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value) {\n+    return IntegerEncoder::size_in_bytes(value);\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoding.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+  template <typename T>\n+  size_t size_in_bytes(T value);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -366,0 +366,6 @@\n+template <typename BE, typename IE, typename WriterPolicyImpl>\n+template <typename T>\n+inline size_t WriterHost<BE, IE, WriterPolicyImpl>::size_in_bytes(T value) {\n+  return IE::size_in_bytes(value);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -231,3 +232,11 @@\n-    if (thread != nullptr) {\n-      ResourceMark rm;\n-      tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+    if (thread != nullptr && thread->is_Java_thread()) {\n+      ResourceMark rm(thread);\n+      JavaThreadState state = JavaThread::cast(thread)->thread_state();\n+      if (state == _thread_in_vm || state == _thread_in_Java || state == _thread_new) {\n+        tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+      } else {\n+        \/\/ According to check_access_thread_state, it's unsafe to\n+        \/\/ resolve the j.l.Thread object unless the thread is in\n+        \/\/ one of the states above.\n+        tty->print(\"JVMCITrace-%d[%s@\" PTR_FORMAT \"]:%*c\", level, thread->type_name(), p2i(thread), level, ' ');\n+      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -156,2 +156,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -506,1 +506,1 @@\n-    JVMCIENV->runtime()->initialize(JVMCIENV);\n+    JVMCIENV->runtime()->initialize(JVMCI_CHECK_NULL);\n@@ -1612,1 +1612,1 @@\n-    GrowableArray<ScopeValue*>* extentLocals = cvf->scope()->locals();\n+    GrowableArray<ScopeValue*>* scopedValues = cvf->scope()->locals();\n@@ -1617,1 +1617,1 @@\n-        if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+        if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n@@ -2315,1 +2315,0 @@\n-  JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2318,0 +2317,1 @@\n+    JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2334,1 +2334,0 @@\n-  JVMCITraceMark jtm(\"getCurrentJavaThread\");\n@@ -2380,1 +2379,0 @@\n-  JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2384,0 +2382,1 @@\n+    JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2438,1 +2437,0 @@\n-  JVMCITraceMark jtm(\"detachCurrentThread\");\n@@ -2442,0 +2440,1 @@\n+    JVMCITraceMark jtm(\"detachCurrentThread\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -311,3 +311,3 @@\n-    size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 \/* \"::\" *\/;\n-    char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);\n-    sprintf(name_buf, \"%s::%s\", vmField.typeName, vmField.fieldName);\n+    const size_t name_buf_size = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 + 1 \/* \"::\" *\/;\n+    char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_size);\n+    os::snprintf_checked(name_buf, name_buf_size, \"%s::%s\", vmField.typeName, vmField.fieldName);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -47,0 +48,3 @@\n+jbyte* JVMCIEnv::_serialized_saved_properties = nullptr;\n+int JVMCIEnv::_serialized_saved_properties_len = 0;\n+\n@@ -101,4 +105,6 @@\n-void JVMCIEnv::copy_saved_properties() {\n-  assert(!is_hotspot(), \"can only copy saved properties from HotSpot to native image\");\n-\n-  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+jbyte* JVMCIEnv::get_serialized_saved_properties(int& props_len, TRAPS) {\n+  jbyte* props = _serialized_saved_properties;\n+  if (props == nullptr) {\n+    \/\/ load VMSupport\n+    Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n+    Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n@@ -106,9 +112,3 @@\n-  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    JVMCIRuntime::fatal_exception(NULL, \"Error initializing jdk.vm.ci.services.Services\");\n-  }\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (ik->should_be_initialized()) {\n-    ik->initialize(THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      JVMCIRuntime::fatal_exception(NULL, \"Error initializing jdk.vm.ci.services.Services\");\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->should_be_initialized()) {\n+      ik->initialize(CHECK_NULL);\n@@ -116,1 +116,0 @@\n-  }\n@@ -118,7 +117,26 @@\n-  \/\/ Get the serialized saved properties from HotSpot\n-  TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol(\"serializeSavedProperties\");\n-  JavaValue result(T_OBJECT);\n-  JavaCallArguments args;\n-  JavaCalls::call_static(&result, ik, serializeSavedProperties, vmSymbols::void_byte_array_signature(), &args, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    JVMCIRuntime::fatal_exception(NULL, \"Error calling jdk.vm.ci.services.Services.serializeSavedProperties\");\n+    \/\/ invoke the serializeSavedPropertiesToByteArray method\n+    JavaValue result(T_OBJECT);\n+    JavaCallArguments args;\n+\n+    Symbol* signature = vmSymbols::void_byte_array_signature();\n+    JavaCalls::call_static(&result,\n+                           ik,\n+                           vmSymbols::serializeSavedPropertiesToByteArray_name(),\n+                           signature,\n+                           &args,\n+                           CHECK_NULL);\n+\n+    oop res = result.get_oop();\n+    assert(res->is_typeArray(), \"must be\");\n+    assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"must be\");\n+    typeArrayOop ba = typeArrayOop(res);\n+    props_len = ba->length();\n+\n+    \/\/ Copy serialized saved properties from HotSpot object into C heap\n+    props = NEW_C_HEAP_ARRAY(jbyte, props_len, mtJVMCI);\n+    memcpy(props, ba->byte_at_addr(0), props_len);\n+\n+    _serialized_saved_properties_len = props_len;\n+    _serialized_saved_properties = props;\n+  } else {\n+    props_len = _serialized_saved_properties_len;\n@@ -126,5 +144,2 @@\n-  oop res = result.get_oop();\n-  assert(res->is_typeArray(), \"must be\");\n-  assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"must be\");\n-  typeArrayOop ba = typeArrayOop(res);\n-  int serialized_properties_len = ba->length();\n+  return props;\n+}\n@@ -132,3 +147,3 @@\n-  \/\/ Copy serialized saved properties from HotSpot object into native buffer\n-  jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);\n-  memcpy(serialized_properties, ba->byte_at_addr(0), serialized_properties_len);\n+void JVMCIEnv::copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS) {\n+  assert(!is_hotspot(), \"can only copy saved properties from HotSpot to native image\");\n+  JavaThread* thread = JavaThread::current(); \/\/ For exception macros.\n@@ -137,1 +152,1 @@\n-  JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);\n+  JVMCIPrimitiveArray buf = new_byteArray(properties_len, this);\n@@ -139,2 +154,1 @@\n-    describe_pending_exception(true);\n-    fatal(\"Error in copy_saved_properties\");\n+    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n@@ -142,1 +156,1 @@\n-  copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);\n+  copy_bytes_from(properties, buf, 0, properties_len);\n@@ -144,2 +158,1 @@\n-    describe_pending_exception(true);\n-    fatal(\"Error in copy_saved_properties\");\n+    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n@@ -151,5 +164,8 @@\n-  JNIAccessMark jni(this, THREAD);\n-  jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());\n-  if (jni()->ExceptionCheck()) {\n-    jni()->ExceptionDescribe();\n-    fatal(\"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n+  bool exception = false;\n+  {\n+    JNIAccessMark jni(this, thread);\n+    jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());\n+    exception = jni()->ExceptionCheck();\n+  }\n+  if (exception) {\n+    _runtime->fatal_exception(JVMCIENV, \"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n@@ -305,1 +321,1 @@\n-  virtual int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) = 0;\n+  virtual int encode(JavaThread* THREAD, Klass* vmSupport, jlong buffer, int buffer_size) = 0;\n@@ -308,1 +324,1 @@\n-  virtual void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) = 0;\n+  virtual void decode(JavaThread* THREAD, Klass* vmSupport, jlong buffer) = 0;\n@@ -312,1 +328,1 @@\n-    \/\/ Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets\n+    \/\/ Resolve VMSupport class explicitly as HotSpotJVMCI::compute_offsets\n@@ -314,1 +330,2 @@\n-    Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);\n+    Klass* vmSupport = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_vm_VMSupport(), true, THREAD);\n+    guarantee(!HAS_PENDING_EXCEPTION, \"\");\n@@ -321,1 +338,1 @@\n-        decode(THREAD, runtimeKlass, 0L);\n+        decode(THREAD, vmSupport, 0L);\n@@ -324,1 +341,1 @@\n-      int res = encode(THREAD, runtimeKlass, buffer, buffer_size);\n+      int res = encode(THREAD, vmSupport, buffer, buffer_size);\n@@ -329,1 +346,1 @@\n-        decode(THREAD, runtimeKlass, -2L);\n+        decode(THREAD, vmSupport, -2L);\n@@ -335,1 +352,1 @@\n-          decode(THREAD, runtimeKlass, -1L);\n+          decode(THREAD, vmSupport, -1L);\n@@ -337,1 +354,1 @@\n-          decode(THREAD, runtimeKlass, -2L);\n+          decode(THREAD, vmSupport, -2L);\n@@ -346,1 +363,1 @@\n-        decode(THREAD, runtimeKlass, buffer);\n+        decode(THREAD, vmSupport, buffer);\n@@ -348,1 +365,1 @@\n-          _to_env->throw_InternalError(\"HotSpotJVMCIRuntime.decodeAndThrowThrowable should have thrown an exception\");\n+          _to_env->throw_InternalError(\"decodeAndThrowThrowable should have thrown an exception\");\n@@ -361,1 +378,1 @@\n-  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+  int encode(JavaThread* THREAD, Klass* vmSupport, jlong buffer, int buffer_size) {\n@@ -368,1 +385,1 @@\n-                            runtimeKlass,\n+                            vmSupport,\n@@ -374,1 +391,1 @@\n-  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+  void decode(JavaThread* THREAD, Klass* vmSupport, jlong buffer) {\n@@ -376,2 +393,2 @@\n-    jni()->CallStaticVoidMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                JNIJVMCI::HotSpotJVMCIRuntime::decodeAndThrowThrowable_method(),\n+    jni()->CallStaticVoidMethod(JNIJVMCI::VMSupport::clazz(),\n+                                JNIJVMCI::VMSupport::decodeAndThrowThrowable_method(),\n@@ -390,1 +407,1 @@\n-  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+  int encode(JavaThread* THREAD, Klass* vmSupport, jlong buffer, int buffer_size) {\n@@ -392,2 +409,2 @@\n-    return jni()->CallStaticIntMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                      JNIJVMCI::HotSpotJVMCIRuntime::encodeThrowable_method(),\n+    return jni()->CallStaticIntMethod(JNIJVMCI::VMSupport::clazz(),\n+                                      JNIJVMCI::VMSupport::encodeThrowable_method(),\n@@ -397,1 +414,1 @@\n-  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+  void decode(JavaThread* THREAD, Klass* vmSupport, jlong buffer) {\n@@ -402,1 +419,1 @@\n-                            runtimeKlass,\n+                            vmSupport,\n@@ -419,0 +436,10 @@\n+jboolean JVMCIEnv::transfer_pending_exception_to_jni(JavaThread* THREAD, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env) {\n+  if (HAS_PENDING_EXCEPTION) {\n+    Handle throwable = Handle(THREAD, PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    translate_to_jni_exception(THREAD, throwable, hotspot_env, jni_env);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -421,15 +448,6 @@\n-    if (HAS_PENDING_EXCEPTION) {\n-      Handle throwable = Handle(THREAD, PENDING_EXCEPTION);\n-      CLEAR_PENDING_EXCEPTION;\n-      translate_to_jni_exception(THREAD, throwable, this, peer_env);\n-      return true;\n-    }\n-  } else {\n-    jthrowable ex = nullptr;\n-    {\n-      JNIAccessMark jni(this, THREAD);\n-      ex = jni()->ExceptionOccurred();\n-      if (ex != nullptr) {\n-        jni()->ExceptionClear();\n-      }\n-    }\n+    return transfer_pending_exception_to_jni(THREAD, this, peer_env);\n+  }\n+  jthrowable ex = nullptr;\n+  {\n+    JNIAccessMark jni(this, THREAD);\n+    ex = jni()->ExceptionOccurred();\n@@ -437,2 +455,1 @@\n-      translate_from_jni_exception(THREAD, ex, peer_env, this);\n-      return true;\n+      jni()->ExceptionClear();\n@@ -441,0 +458,4 @@\n+  if (ex != nullptr) {\n+    translate_from_jni_exception(THREAD, ex, peer_env, this);\n+    return true;\n+  }\n@@ -444,1 +465,0 @@\n-\n@@ -472,1 +492,2 @@\n-      jio_snprintf(message, 256, \"Uncaught exception exiting JVMCIEnv scope entered at %s:%d\", _file, _line);\n+      jio_snprintf(message, 256, \"Uncaught exception exiting %s JVMCIEnv scope entered at %s:%d\",\n+          is_hotspot() ? \"HotSpot\" : \"libjvmci\", _file, _line);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":101,"deletions":80,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -183,0 +183,6 @@\n+  \/\/ Used by copy_saved_properties() to avoid OutOfMemoryErrors when\n+  \/\/ initializing a libjvmci runtime in low HotSpot heap conditions.\n+  \/\/ Must hold JVMCI_lock when initializing.\n+  static jbyte* _serialized_saved_properties;\n+  static int _serialized_saved_properties_len;\n+\n@@ -224,3 +230,7 @@\n-  \/\/ Initializes Services.savedProperties in the shared library by copying\n-  \/\/ the values from the same field in the HotSpot heap.\n-  void copy_saved_properties();\n+  \/\/ Gets the serialized saved properties from the HotSpot heap.\n+  \/\/ The length of the returned array is saved in `len`.\n+  jbyte* get_serialized_saved_properties(int& len, TRAPS);\n+\n+  \/\/ Initializes Services.savedProperties in the shared library from the given\n+  \/\/ properties in the format produced by `get_serialized_saved_properties`.\n+  void copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS);\n@@ -236,0 +246,5 @@\n+  \/\/ If there is a pending HotSpot exception, clears it and translates it to the shared library heap.\n+  \/\/ The translated exception is pending in the shared library upon returning.\n+  \/\/ Returns true if a pending exception was transferred, false otherwise.\n+  static jboolean transfer_pending_exception_to_jni(JavaThread* THREAD, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-      \/* values across all JavaVMs executing on the same native image. *\/                   \\\n+      \/* value across all JavaVMs executing on the same native image. *\/                    \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,2 +194,0 @@\n-    jvmci_method(CallStaticBooleanMethod, GetStaticMethodID, call_static, bool, HotSpotJVMCIRuntime, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, decodeAndThrowThrowable, long_void_signature, (jlong buffer)) \\\n@@ -219,0 +217,4 @@\n+  start_class(VMSupport, jdk_internal_vm_VMSupport)                                                           \\\n+    jvmci_method(CallStaticIntMethod, GetStaticMethodID, call_static, int, VMSupport, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, VMSupport, decodeAndThrowThrowable, long_void_signature, (jlong buffer)) \\\n+  end_class                                                                                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -752,1 +752,1 @@\n-  initialize(JVMCIENV);\n+  initialize(JVMCI_CHECK);\n@@ -1318,1 +1318,1 @@\n-  initialize(JVMCIENV);\n+  initialize(JVMCI_CHECK);\n@@ -1373,1 +1373,1 @@\n-void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {\n+void JVMCIRuntime::initialize(JVMCI_TRAPS) {\n@@ -1379,0 +1379,5 @@\n+  JavaThread* THREAD = JavaThread::current();\n+\n+  int properties_len = 0;\n+  jbyte* properties = NULL;\n+\n@@ -1400,1 +1405,0 @@\n-    JavaThread* THREAD = JavaThread::current();\n@@ -1444,1 +1448,6 @@\n-      JVMCIENV->copy_saved_properties();\n+      Handle properties_exception;\n+      properties = JVMCIENV->get_serialized_saved_properties(properties_len, THREAD);\n+      if (JVMCIEnv::transfer_pending_exception_to_jni(THREAD, nullptr, JVMCIENV)) {\n+        return;\n+      }\n+      JVMCIENV->copy_saved_properties(properties, properties_len, JVMCI_CHECK);\n@@ -1487,1 +1496,1 @@\n-  initialize(JVMCIENV);\n+  initialize(JVMCI_CHECK_(JVMCIObject()));\n@@ -1995,1 +2004,7 @@\n-    fatal_exception(JVMCIENV, \"Exception during HotSpotJVMCIRuntime initialization\");\n+    if (PrintWarnings) {\n+      ResourceMark rm(thread);\n+      warning(\"HotSpotJVMCIRuntime initialization failed when compiling %s\", method->name_and_sig_as_C_string());\n+      JVMCIENV->describe_pending_exception(true);\n+    }\n+    compile_state->set_failure(false, \"exception during HotSpotJVMCIRuntime initialization\");\n+    return;\n@@ -1999,1 +2014,5 @@\n-    JVMCIENV->describe_pending_exception(true);\n+    if (PrintWarnings) {\n+      ResourceMark rm(thread);\n+      warning(\"Error creating JVMCI wrapper for %s\", method->name_and_sig_as_C_string());\n+      JVMCIENV->describe_pending_exception(true);\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  nonstatic_field(JavaThread,                  _extentLocalCache,                             OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                             OopHandle)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,3 +82,0 @@\n-  template(encodeThrowable_name,                                  \"encodeThrowable\")                                                      \\\n-  template(encodeThrowable_signature,                             \"(Ljava\/lang\/Throwable;JI)I\")                                           \\\n-  template(decodeAndThrowThrowable_name,                          \"decodeAndThrowThrowable\")                                              \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include <type_traits>\n@@ -64,1 +65,1 @@\n-  static void free_metadata(ClassLoaderData* loader_data, T md) {\n+  static void free_metadata(ClassLoaderData* loader_data, T* md) {\n@@ -68,1 +69,1 @@\n-      \/\/ Call metadata's deallocate function which will call deallocate fields\n+      \/\/ Call metadata's deallocate function which will deallocate fields and release_C_heap_structures\n@@ -72,0 +73,7 @@\n+      \/\/ Call the destructor. This is currently used for MethodData which has a member\n+      \/\/ that needs to be destructed to release resources. Most Metadata derived classes have noop\n+      \/\/ destructors and\/or cleanup using deallocate_contents.\n+      \/\/ T is a potentially const or volatile qualified pointer. Remove any const\n+      \/\/ or volatile so we can call the destructor of the type T points to.\n+      using U = std::remove_cv_t<T>;\n+      md->~U();\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -598,4 +598,4 @@\n-  \/\/ Can't release the constant pool here because the constant pool can be\n-  \/\/ deallocated separately from the InstanceKlass for default methods and\n-  \/\/ redefine classes.\n-  release_C_heap_structures(\/* release_constant_pool *\/ false);\n+  \/\/ Can't release the constant pool or MethodData C heap data here because the constant\n+  \/\/ pool can be deallocated separately from the InstanceKlass for default methods and\n+  \/\/ redefine classes.  MethodData can also be released separately.\n+  release_C_heap_structures(\/* release_sub_metadata *\/ false);\n@@ -2151,9 +2151,2 @@\n-      \/\/ cache can grow so we have to be more careful\n-      if (Threads::number_of_threads() == 0 ||\n-          SafepointSynchronize::is_at_safepoint()) {\n-        \/\/ we're single threaded or at a safepoint - no locking needed\n-        get_jmethod_id_length_value(jmeths, idnum, &length, &id);\n-      } else {\n-        MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n-        get_jmethod_id_length_value(jmeths, idnum, &length, &id);\n-      }\n+      MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n+      get_jmethod_id_length_value(jmeths, idnum, &length, &id);\n@@ -2169,2 +2162,2 @@\n-    \/\/ This function can be called by the VMThread so we have to do all\n-    \/\/ things that might block on a safepoint before grabbing the lock.\n+    \/\/ This function can be called by the VMThread or GC worker threads so we\n+    \/\/ have to do all things that might block on a safepoint before grabbing the lock.\n@@ -2189,18 +2182,1 @@\n-    jmethodID new_id = NULL;\n-    if (method_h->is_old() && !method_h->is_obsolete()) {\n-      \/\/ The method passed in is old (but not obsolete), we need to use the current version\n-      Method* current_method = method_with_idnum((int)idnum);\n-      assert(current_method != NULL, \"old and but not obsolete, so should exist\");\n-      new_id = Method::make_jmethod_id(class_loader_data(), current_method);\n-    } else {\n-      \/\/ It is the current version of the method or an obsolete method,\n-      \/\/ use the version passed in\n-      new_id = Method::make_jmethod_id(class_loader_data(), method_h());\n-    }\n-\n-    if (Threads::number_of_threads() == 0 ||\n-        SafepointSynchronize::is_at_safepoint()) {\n-      \/\/ we're single threaded or at a safepoint - no locking needed\n-      id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,\n-                                          &to_dealloc_id, &to_dealloc_jmeths);\n-    } else {\n+    {\n@@ -2208,0 +2184,12 @@\n+      jmethodID new_id = NULL;\n+      if (method_h->is_old() && !method_h->is_obsolete()) {\n+        \/\/ The method passed in is old (but not obsolete), we need to use the current version\n+        Method* current_method = method_with_idnum((int)idnum);\n+        assert(current_method != NULL, \"old and but not obsolete, so should exist\");\n+        new_id = Method::make_jmethod_id(class_loader_data(), current_method);\n+      } else {\n+        \/\/ It is the current version of the method or an obsolete method,\n+        \/\/ use the version passed in\n+        new_id = Method::make_jmethod_id(class_loader_data(), method_h());\n+      }\n+\n@@ -2257,3 +2245,1 @@\n-  assert(Threads::number_of_threads() == 0 ||\n-         SafepointSynchronize::is_at_safepoint() ||\n-         JmethodIdCreation_lock->owned_by_self(), \"sanity check\");\n+  assert(JmethodIdCreation_lock->owned_by_self(), \"sanity check\");\n@@ -2667,2 +2653,2 @@\n-\/\/ Called also by InstanceKlass::deallocate_contents, with false for release_constant_pool.\n-void InstanceKlass::release_C_heap_structures(bool release_constant_pool) {\n+\/\/ Called also by InstanceKlass::deallocate_contents, with false for release_sub_metadata.\n+void InstanceKlass::release_C_heap_structures(bool release_sub_metadata) {\n@@ -2673,1 +2659,3 @@\n-  methods_do(method_release_C_heap_structures);\n+  if (release_sub_metadata) {\n+    methods_do(method_release_C_heap_structures);\n+  }\n@@ -2713,1 +2701,1 @@\n-  if (release_constant_pool) {\n+  if (release_sub_metadata) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":28,"deletions":40,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-  virtual void release_C_heap_structures(bool release_constant_pool = true);\n+  virtual void release_C_heap_structures(bool release_sub_metadata = true);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,4 +144,3 @@\n-#if INCLUDE_JVMCI\n-    FailedSpeculation::free_failed_speculations(method_data()->get_failed_speculations_address());\n-#endif\n-    \/\/ Destroy MethodData\n+    method_data()->release_C_heap_structures();\n+\n+    \/\/ Destroy MethodData embedded lock\n@@ -2168,12 +2167,7 @@\n-void Method::ensure_jmethod_ids(ClassLoaderData* loader_data, int capacity) {\n-  ClassLoaderData* cld = loader_data;\n-  if (!SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ Have to add jmethod_ids() to class loader data thread-safely.\n-    \/\/ Also have to add the method to the list safely, which the lock\n-    \/\/ protects as well.\n-    MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n-    if (cld->jmethod_ids() == NULL) {\n-      cld->set_jmethod_ids(new JNIMethodBlock(capacity));\n-    } else {\n-      cld->jmethod_ids()->ensure_methods(capacity);\n-    }\n+void Method::ensure_jmethod_ids(ClassLoaderData* cld, int capacity) {\n+  \/\/ Have to add jmethod_ids() to class loader data thread-safely.\n+  \/\/ Also have to add the method to the list safely, which the lock\n+  \/\/ protects as well.\n+  MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n+  if (cld->jmethod_ids() == NULL) {\n+    cld->set_jmethod_ids(new JNIMethodBlock(capacity));\n@@ -2181,6 +2175,1 @@\n-    \/\/ At safepoint, we are single threaded and can set this.\n-    if (cld->jmethod_ids() == NULL) {\n-      cld->set_jmethod_ids(new JNIMethodBlock(capacity));\n-    } else {\n-      cld->jmethod_ids()->ensure_methods(capacity);\n-    }\n+    cld->jmethod_ids()->ensure_methods(capacity);\n@@ -2191,20 +2180,7 @@\n-jmethodID Method::make_jmethod_id(ClassLoaderData* loader_data, Method* m) {\n-  ClassLoaderData* cld = loader_data;\n-\n-  if (!SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ Have to add jmethod_ids() to class loader data thread-safely.\n-    \/\/ Also have to add the method to the list safely, which the lock\n-    \/\/ protects as well.\n-    MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n-    if (cld->jmethod_ids() == NULL) {\n-      cld->set_jmethod_ids(new JNIMethodBlock());\n-    }\n-    \/\/ jmethodID is a pointer to Method*\n-    return (jmethodID)cld->jmethod_ids()->add_method(m);\n-  } else {\n-    \/\/ At safepoint, we are single threaded and can set this.\n-    if (cld->jmethod_ids() == NULL) {\n-      cld->set_jmethod_ids(new JNIMethodBlock());\n-    }\n-    \/\/ jmethodID is a pointer to Method*\n-    return (jmethodID)cld->jmethod_ids()->add_method(m);\n+jmethodID Method::make_jmethod_id(ClassLoaderData* cld, Method* m) {\n+  \/\/ Have to add jmethod_ids() to class loader data thread-safely.\n+  \/\/ Also have to add the method to the list safely, which the lock\n+  \/\/ protects as well.\n+  assert(JmethodIdCreation_lock->owned_by_self(), \"sanity check\");\n+  if (cld->jmethod_ids() == NULL) {\n+    cld->set_jmethod_ids(new JNIMethodBlock());\n@@ -2212,0 +2188,2 @@\n+  \/\/ jmethodID is a pointer to Method*\n+  return (jmethodID)cld->jmethod_ids()->add_method(m);\n@@ -2221,2 +2199,1 @@\n-void Method::destroy_jmethod_id(ClassLoaderData* loader_data, jmethodID m) {\n-  ClassLoaderData* cld = loader_data;\n+void Method::destroy_jmethod_id(ClassLoaderData* cld, jmethodID m) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":21,"deletions":44,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -777,2 +777,2 @@\n-  static jmethodID make_jmethod_id(ClassLoaderData* loader_data, Method* mh);\n-  static void destroy_jmethod_id(ClassLoaderData* loader_data, jmethodID mid);\n+  static jmethodID make_jmethod_id(ClassLoaderData* cld, Method* mh);\n+  static void destroy_jmethod_id(ClassLoaderData* cld, jmethodID mid);\n@@ -783,1 +783,1 @@\n-  static void ensure_jmethod_ids(ClassLoaderData* loader_data, int capacity);\n+  static void ensure_jmethod_ids(ClassLoaderData* cld, int capacity);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1824,0 +1824,10 @@\n+\n+void MethodData::deallocate_contents(ClassLoaderData* loader_data) {\n+  release_C_heap_structures();\n+}\n+\n+void MethodData::release_C_heap_structures() {\n+#if INCLUDE_JVMCI\n+  FailedSpeculation::free_failed_speculations(get_failed_speculations_address());\n+#endif\n+}\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2452,2 +2452,3 @@\n-  \/\/ Deallocation support - no metaspace pointer fields to deallocate\n-  void deallocate_contents(ClassLoaderData* loader_data) {}\n+  \/\/ Deallocation support\n+  void deallocate_contents(ClassLoaderData* loader_data);\n+  void release_C_heap_structures();\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  \/\/ Used only for removing handle.\n","filename":"src\/hotspot\/share\/oops\/oopHandle.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+  inline oop cont() const;\n+  template<typename P>\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,12 @@\n-inline oop stackChunkOopDesc::cont() const                { return jdk_internal_vm_StackChunk::cont(as_oop()); }\n+inline oop stackChunkOopDesc::cont() const                { return UseCompressedOops ? cont<narrowOop>() : cont<oop>(); \/* jdk_internal_vm_StackChunk::cont(as_oop()); *\/ }\n+template<typename P>\n+inline oop stackChunkOopDesc::cont() const                {\n+  \/\/ The state of the cont oop is used by ZCollectedHeap::requires_barriers,\n+  \/\/ to determine the age of the stackChunkOopDesc. For that to work, it is\n+  \/\/ only the GC that is allowed to perform a load barrier on the oop.\n+  \/\/ This function is used by non-GC code and therfore create a stack-local\n+  \/\/ copy on the oop and perform the load barrier on that copy instead.\n+  oop obj = jdk_internal_vm_StackChunk::cont_raw<P>(as_oop());\n+  obj = (oop)NativeAccess<>::oop_load(&obj);\n+  return obj;\n+}\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -623,1 +623,0 @@\n-  \/\/ Find true target\n@@ -625,2 +624,6 @@\n-  int idx = b->get_node(end_idx+1)->as_Proj()->_con;\n-  Block *succ = b->_succs[idx];\n+  NeverBranchNode* never_branch = b->get_node(end_idx)->as_NeverBranch();\n+  Block* succ = get_block_for_node(never_branch->proj_out(0)->unique_ctrl_out_or_null());\n+  Block* dead = get_block_for_node(never_branch->proj_out(1)->unique_ctrl_out_or_null());\n+  assert(succ == b->_succs[0] || succ == b->_succs[1], \"succ is a successor\");\n+  assert(dead == b->_succs[0] || dead == b->_succs[1], \"dead is a successor\");\n+\n@@ -645,1 +648,0 @@\n-  Block* dead = b->_succs[1 - idx];\n@@ -743,1 +745,1 @@\n-    if (block->get_node(block->end_idx())->Opcode() == Op_NeverBranch) {\n+    if (block->get_node(block->end_idx())->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/output.hpp\"\n+\n+C2CodeStubList::C2CodeStubList() :\n+  _stubs(Compile::current()->comp_arena(), 2, 0, NULL) {}\n+\n+void C2CodeStubList::emit(CodeBuffer& cb) {\n+  C2_MacroAssembler masm(&cb);\n+  for (int i = _stubs.length() - 1; i >= 0; i--) {\n+    C2CodeStub* stub = _stubs.at(i);\n+    int max_size = stub->max_size();\n+    \/\/ Make sure there is enough space in the code buffer\n+    if (cb.insts()->maybe_expand_to_ensure_remaining(max_size) && cb.blob() == NULL) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n+\n+    DEBUG_ONLY(int size_before = cb.insts_size();)\n+\n+    stub->emit(masm);\n+\n+    DEBUG_ONLY(int actual_size = cb.insts_size() - size_before;)\n+    assert(max_size >= actual_size, \"Expected stub size (%d) must be larger than or equal to actual stub size (%d)\", max_size, actual_size);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+#ifndef SHARE_OPTO_C2_CODESTUBS_HPP\n+#define SHARE_OPTO_C2_CODESTUBS_HPP\n+\n+class C2CodeStub : public ArenaObj {\n+private:\n+  Label _entry;\n+  Label _continuation;\n+\n+protected:\n+  C2CodeStub() :\n+    _entry(),\n+    _continuation() {}\n+\n+public:\n+  Label& entry()        { return _entry; }\n+  Label& continuation() { return _continuation; }\n+\n+  virtual void emit(C2_MacroAssembler& masm) = 0;\n+  virtual int max_size() const = 0;\n+};\n+\n+class C2CodeStubList {\n+private:\n+  GrowableArray<C2CodeStub*> _stubs;\n+\n+public:\n+  C2CodeStubList();\n+\n+  void add_stub(C2CodeStub* stub) { _stubs.append(stub); }\n+  void emit(CodeBuffer& cb);\n+};\n+\n+class C2SafepointPollStub : public C2CodeStub {\n+private:\n+  uintptr_t _safepoint_offset;\n+\n+public:\n+  C2SafepointPollStub(uintptr_t safepoint_offset) :\n+    _safepoint_offset(safepoint_offset) {}\n+  int max_size() const;\n+  void emit(C2_MacroAssembler& masm);\n+};\n+\n+\/\/ We move non-hot code of the nmethod entry barrier to an out-of-line stub\n+class C2EntryBarrierStub: public C2CodeStub {\n+private:\n+  Label _guard; \/\/ Used on AArch64 and RISCV\n+\n+public:\n+  C2EntryBarrierStub() : C2CodeStub(),\n+    _guard() {}\n+\n+  Label& guard() { return _guard; }\n+\n+  int max_size() const;\n+  void emit(C2_MacroAssembler& masm);\n+};\n+\n+#endif \/\/ SHARE_OPTO_C2_CODESTUBS_HPP\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/opto\/c2_MacroAssembler.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -683,2 +683,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -622,1 +622,1 @@\n-          assert(opaq->Opcode() == Op_Opaque1, \"\");\n+          assert(opaq->Opcode() == Op_OpaqueZeroTripGuard, \"\");\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -594,1 +594,4 @@\n-  NeverBranchNode( Node *ctrl ) : MultiBranchNode(1) { init_req(0,ctrl); }\n+  NeverBranchNode(Node* ctrl) : MultiBranchNode(1) {\n+    init_req(0, ctrl);\n+    init_class_id(Class_NeverBranch);\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+macro(OpaqueZeroTripGuard)\n@@ -508,0 +509,2 @@\n+macro(VectorCastF2HF)\n+macro(VectorCastHF2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -897,1 +897,1 @@\n-\/\/ no subklasses.  We do a Deutsch-Shiffman style type-check on the incoming\n+\/\/ no subklasses.  We do a Deutsch-Schiffman style type-check on the incoming\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -736,0 +736,1 @@\n+    ctrl->in(0)->in(1)->in(1)->in(1) != igvn->C->top() &&\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -475,2 +475,2 @@\n-  case vmIntrinsics::_extentLocalCache:          return inline_native_extentLocalCache();\n-  case vmIntrinsics::_setExtentLocalCache:       return inline_native_setExtentLocalCache();\n+  case vmIntrinsics::_scopedValueCache:          return inline_native_scopedValueCache();\n+  case vmIntrinsics::_setScopedValueCache:       return inline_native_setScopedValueCache();\n@@ -3360,1 +3360,1 @@\n-Node* LibraryCallKit::extentLocalCache_helper() {\n+Node* LibraryCallKit::scopedValueCache_helper() {\n@@ -3367,3 +3367,7 @@\n-  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::extentLocalCache_offset()));\n-  return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n-        TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered));\n+  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::scopedValueCache_offset()));\n+  \/\/ We cannot use immutable_memory() because we might flip onto a\n+  \/\/ different carrier thread, at which point we'll need to use that\n+  \/\/ carrier thread's cache.\n+  \/\/ return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n+  \/\/       TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered));\n+  return make_load(NULL, p, p->bottom_type()->is_ptr(), T_ADDRESS, MemNode::unordered);\n@@ -3372,2 +3376,2 @@\n-\/\/------------------------inline_native_extentLocalCache------------------\n-bool LibraryCallKit::inline_native_extentLocalCache() {\n+\/\/------------------------inline_native_scopedValueCache------------------\n+bool LibraryCallKit::inline_native_scopedValueCache() {\n@@ -3378,1 +3382,1 @@\n-  \/\/ Because we create the extentLocal cache lazily we have to make the\n+  \/\/ Because we create the scopedValue cache lazily we have to make the\n@@ -3382,1 +3386,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n@@ -3388,2 +3392,2 @@\n-\/\/------------------------inline_native_setExtentLocalCache------------------\n-bool LibraryCallKit::inline_native_setExtentLocalCache() {\n+\/\/------------------------inline_native_setScopedValueCache------------------\n+bool LibraryCallKit::inline_native_setScopedValueCache() {\n@@ -3391,1 +3395,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -242,3 +242,3 @@\n-  bool inline_native_extentLocalCache();\n-  Node* extentLocalCache_helper();\n-  bool inline_native_setExtentLocalCache();\n+  bool inline_native_scopedValueCache();\n+  Node* scopedValueCache_helper();\n+  bool inline_native_setScopedValueCache();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,3 +112,3 @@\n-                                                      Deoptimization::DeoptReason reason, int opcode,\n-                                                      bool if_cont_is_true_proj, Node_List* old_new,\n-                                                      UnswitchingAction unswitching_action) {\n+                                                      Deoptimization::DeoptReason reason,\n+                                                      const int opcode, const bool rewire_uncommon_proj_phi_inputs,\n+                                                      const bool if_cont_is_true_proj) {\n@@ -199,14 +199,13 @@\n-      if (unswitching_action == UnswitchingAction::FastLoopCloning\n-          && !phi_input->is_CFG() && !phi_input->is_Phi() && get_ctrl(phi_input) == uncommon_proj) {\n-        \/\/ There are some control dependent nodes on the uncommon projection and we are currently copying predicates\n-        \/\/ to the fast loop in loop unswitching (first step, slow loop is processed afterwards). For the fast loop,\n-        \/\/ we need to clone all the data nodes in the chain from the phi ('use') up until the node whose control input\n-        \/\/ is the uncommon_proj. The slow loop can reuse the old data nodes and thus only needs to update the control\n-        \/\/ input to the uncommon_proj (done on the next invocation of this method when 'unswitch_is_slow_loop' is true.\n-        assert(LoopUnswitching, \"sanity check\");\n-        phi_input = clone_data_nodes_for_fast_loop(phi_input, uncommon_proj, if_uct, old_new);\n-      } else if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n-        \/\/ Replace phi input for the old predicate path with TOP as the predicate is dying anyways. This avoids the need\n-        \/\/ to clone the data nodes again for the slow loop.\n-        assert(LoopUnswitching, \"sanity check\");\n-        _igvn.replace_input_of(use, proj_index, C->top());\n+\n+      if (uncommon_proj->outcnt() > 1 && !phi_input->is_CFG() && !phi_input->is_Phi() && get_ctrl(phi_input) == uncommon_proj) {\n+        \/\/ There are some control dependent nodes on the uncommon projection. We cannot simply reuse these data nodes.\n+        \/\/ We either need to rewire them from the old uncommon projection to the newly created uncommon proj (if the old\n+        \/\/ If is dying) or clone them and update their control (if the old If is not dying).\n+        if (rewire_uncommon_proj_phi_inputs) {\n+          \/\/ Replace phi input for the old uncommon projection with TOP as the If is dying anyways. Reuse the old data\n+          \/\/ nodes by simply updating control inputs and ctrl.\n+          _igvn.replace_input_of(use, proj_index, C->top());\n+          set_ctrl_of_nodes_with_same_ctrl(phi_input, uncommon_proj, if_uct);\n+        } else {\n+          phi_input = clone_nodes_with_same_ctrl(phi_input, uncommon_proj, if_uct);\n+        }\n@@ -219,13 +218,0 @@\n-  if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n-    \/\/ Rewire the control dependent data nodes for the slow loop from the old to the new uncommon projection.\n-    assert(uncommon_proj->outcnt() > 1 && old_new == NULL, \"sanity\");\n-    for (DUIterator_Fast jmax, j = uncommon_proj->fast_outs(jmax); j < jmax; j++) {\n-      Node* data = uncommon_proj->fast_out(j);\n-      if (!data->is_CFG()) {\n-        _igvn.replace_input_of(data, 0, if_uct);\n-        set_ctrl(data, if_uct);\n-        --j;\n-        --jmax;\n-      }\n-    }\n-  }\n@@ -243,13 +229,19 @@\n-\/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate. Returns the node which is\n-\/\/ used for the uncommon trap phi input.\n-Node* PhaseIdealLoop::clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new) {\n-  \/\/ Step 1: Clone all nodes on the data chain but do not rewire anything, yet. Keep track of the cloned nodes\n-  \/\/ by using the old_new mapping. This mapping is then used in step 2 to rewire the cloned nodes accordingly.\n-  DEBUG_ONLY(uint last_idx = C->unique();)\n-  Unique_Node_List list;\n-  list.push(phi_input);\n-  for (uint j = 0; j < list.size(); j++) {\n-    Node* next = list.at(j);\n-    Node* clone = next->clone();\n-    _igvn.register_new_node_with_optimizer(clone);\n-    old_new->map(next->_idx, clone);\n+\/\/ Update ctrl and control inputs of all data nodes starting from 'node' to 'new_ctrl' which have 'old_ctrl' as\n+\/\/ current ctrl.\n+void PhaseIdealLoop::set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n+  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n+  for (uint j = 0; j < nodes_with_same_ctrl.size(); j++) {\n+    Node* next = nodes_with_same_ctrl[j];\n+    if (next->in(0) == old_ctrl) {\n+      _igvn.replace_input_of(next, 0, new_ctrl);\n+    }\n+    set_ctrl(next, new_ctrl);\n+  }\n+}\n+\n+\/\/ Recursively find all input nodes with the same ctrl.\n+Unique_Node_List PhaseIdealLoop::find_nodes_with_same_ctrl(Node* node, const ProjNode* ctrl) {\n+  Unique_Node_List nodes_with_same_ctrl;\n+  nodes_with_same_ctrl.push(node);\n+  for (uint j = 0; j < nodes_with_same_ctrl.size(); j++) {\n+    Node* next = nodes_with_same_ctrl[j];\n@@ -258,2 +250,2 @@\n-      if (!in->is_Phi() && get_ctrl(in) == uncommon_proj) {\n-        list.push(in);\n+      if (!in->is_Phi() && get_ctrl(in) == ctrl) {\n+        nodes_with_same_ctrl.push(in);\n@@ -263,0 +255,26 @@\n+  return nodes_with_same_ctrl;\n+}\n+\n+\/\/ Clone all nodes with the same ctrl as 'old_ctrl' starting from 'node' by following its inputs. Rewire the cloned nodes\n+\/\/ to 'new_ctrl'. Returns the clone of 'node'.\n+Node* PhaseIdealLoop::clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n+  DEBUG_ONLY(uint last_idx = C->unique();)\n+  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n+  Dict old_new_mapping = clone_nodes(nodes_with_same_ctrl); \/\/ Cloned but not rewired, yet\n+  rewire_cloned_nodes_to_ctrl(old_ctrl, new_ctrl, nodes_with_same_ctrl, old_new_mapping);\n+  Node* clone_phi_input = static_cast<Node*>(old_new_mapping[node]);\n+  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n+  return clone_phi_input;\n+}\n+\n+\/\/ Clone all the nodes on 'list_to_clone' and return an old->new mapping.\n+Dict PhaseIdealLoop::clone_nodes(const Node_List& list_to_clone) {\n+  Dict old_new_mapping(cmpkey, hashkey);\n+  for (uint i = 0; i < list_to_clone.size(); i++) {\n+    Node* next = list_to_clone[i];\n+    Node* clone = next->clone();\n+    _igvn.register_new_node_with_optimizer(clone);\n+    old_new_mapping.Insert(next, clone);\n+  }\n+  return old_new_mapping;\n+}\n@@ -264,6 +282,8 @@\n-  \/\/ Step 2: All nodes are cloned. Rewire them by using the old_new mapping.\n-  for (uint j = 0; j < list.size(); j++) {\n-    Node* next = list.at(j);\n-    Node* clone = old_new->at(next->_idx);\n-    assert(clone != NULL && clone->_idx >= last_idx, \"must exist and be a proper clone\");\n-    if (next->in(0) == uncommon_proj) {\n+\/\/ Rewire inputs of the unprocessed cloned nodes (inputs are not updated, yet, and still point to the old nodes) by\n+\/\/ using the old_new_mapping.\n+void PhaseIdealLoop::rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl,\n+                                                 const Node_List& nodes_with_same_ctrl, const Dict& old_new_mapping) {\n+  for (uint i = 0; i < nodes_with_same_ctrl.size(); i++) {\n+    Node* next = nodes_with_same_ctrl[i];\n+    Node* clone = static_cast<Node*>(old_new_mapping[next]);\n+    if (next->in(0) == old_ctrl) {\n@@ -272,2 +292,2 @@\n-      _igvn.replace_input_of(clone, 0, if_uct);\n-      set_ctrl(clone, if_uct);\n+      _igvn.replace_input_of(clone, 0, new_ctrl);\n+      set_ctrl(clone, new_ctrl);\n@@ -275,0 +295,3 @@\n+    rewire_inputs_of_clones_to_clones(new_ctrl, clone, old_new_mapping, next);\n+  }\n+}\n@@ -276,11 +299,11 @@\n-    \/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n-    for (uint k = 1; k < next->req(); k++) {\n-      Node* in = next->in(k);\n-      if (!in->is_Phi()) {\n-        assert(!in->is_CFG(), \"must be data node\");\n-        Node* in_clone = old_new->at(in->_idx);\n-        if (in_clone != NULL) {\n-          assert(in_clone->_idx >= last_idx, \"must be a valid clone\");\n-          _igvn.replace_input_of(clone, k, in_clone);\n-          set_ctrl(clone, if_uct);\n-        }\n+\/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n+void PhaseIdealLoop::rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping,\n+                                                       const Node* next) {\n+  for (uint i = 1; i < next->req(); i++) {\n+    Node* in = next->in(i);\n+    if (!in->is_Phi()) {\n+      assert(!in->is_CFG(), \"must be data node\");\n+      Node* in_clone = static_cast<Node*>(old_new_mapping[in]);\n+      if (in_clone != NULL) {\n+        _igvn.replace_input_of(clone, i, in_clone);\n+        set_ctrl(clone, new_ctrl);\n@@ -290,3 +313,0 @@\n-  Node* clone_phi_input = old_new->at(phi_input->_idx);\n-  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n-  return clone_phi_input;\n@@ -294,0 +314,1 @@\n+\n@@ -296,8 +317,1 @@\n-                                                             Deoptimization::DeoptReason reason, Node_List* old_new) {\n-  UnswitchingAction unswitching_action;\n-  if (predicate_proj->other_if_proj()->outcnt() > 1) {\n-    \/\/ There are some data dependencies that need to be taken care of when cloning a predicate.\n-    unswitching_action = old_new == NULL ? UnswitchingAction::SlowLoopRewiring : UnswitchingAction::FastLoopCloning;\n-  } else {\n-    unswitching_action = UnswitchingAction::None;\n-  }\n+                                                             Deoptimization::DeoptReason reason, const bool slow_loop) {\n@@ -306,1 +320,1 @@\n-                                                             true, old_new, unswitching_action);\n+                                                             slow_loop);\n@@ -405,1 +419,2 @@\n-  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(), predicate->is_IfTrue());\n+  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(),\n+                                               false, predicate->is_IfTrue());\n@@ -438,2 +453,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate,false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate,true);\n@@ -447,2 +462,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred, Deoptimization::Reason_profile_predicate, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred, Deoptimization::Reason_profile_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred,Deoptimization::Reason_profile_predicate, false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred,Deoptimization::Reason_profile_predicate, true);\n@@ -458,2 +473,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred, Deoptimization::Reason_loop_limit_check, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred, Deoptimization::Reason_loop_limit_check);\n+    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred,Deoptimization::Reason_loop_limit_check, false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred,Deoptimization::Reason_loop_limit_check, true);\n@@ -1430,1 +1445,1 @@\n-  if (head->unique_ctrl_out()->Opcode() == Op_NeverBranch) {\n+  if (head->unique_ctrl_out()->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":99,"deletions":84,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -1303,1 +1303,1 @@\n-  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_Opaque1, \"must be Opaque1\");\n+  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_OpaqueZeroTripGuard, \"must be OpaqueZeroTripGuard\");\n@@ -1708,1 +1708,1 @@\n-  Node *min_opaq = new Opaque1Node(C, limit);\n+  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit);\n@@ -1997,1 +1997,1 @@\n-  Node *zer_opaq = new Opaque1Node(C, incr);\n+  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr);\n@@ -3579,1 +3579,1 @@\n-  \/\/ Remove the Opaque1Node of the main loop so it can be optimized out\n+  \/\/ Remove the OpaqueZeroTripGuardNode of the main loop so it can be optimized out\n@@ -3581,1 +3581,1 @@\n-  assert(main_cmp->in(2)->Opcode() == Op_Opaque1, \"main loop has no opaque node?\");\n+  assert(main_cmp->in(2)->Opcode() == Op_OpaqueZeroTripGuard, \"main loop has no opaque node?\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4193,2 +4193,2 @@\n-\/\/ Goes over all children of the root of the loop tree, collects all controls for the loop and its inner loops then\n-\/\/ checks whether any control is a branch out of the loop and if it is, whether it's not a NeverBranch.\n+\/\/ Goes over all children of the root of the loop tree. Check if any of them have a path\n+\/\/ down to Root, that does not go via a NeverBranch exit.\n@@ -4196,0 +4196,3 @@\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  \/\/ start traversal at all loop heads of first-level loops\n@@ -4197,1 +4200,0 @@\n-    Unique_Node_List wq;\n@@ -4200,28 +4202,20 @@\n-    for (uint i = 1; i < head->req(); ++i) {\n-      Node* in = head->in(i);\n-      if (get_loop(in) != _ltree_root) {\n-        wq.push(in);\n-      }\n-    }\n-    for (uint i = 0; i < wq.size(); ++i) {\n-      Node* c = wq.at(i);\n-      if (c == head) {\n-        continue;\n-      } else if (c->is_Region()) {\n-        for (uint j = 1; j < c->req(); ++j) {\n-          wq.push(c->in(j));\n-        }\n-      } else {\n-        wq.push(c->in(0));\n-      }\n-    }\n-    assert(wq.member(head), \"\");\n-    for (uint i = 0; i < wq.size(); ++i) {\n-      Node* c = wq.at(i);\n-      if (c->is_MultiBranch()) {\n-        for (DUIterator_Fast jmax, j = c->fast_outs(jmax); j < jmax; j++) {\n-          Node* u = c->fast_out(j);\n-          assert(u->is_CFG(), \"\");\n-          if (!wq.member(u) && c->Opcode() != Op_NeverBranch) {\n-            return false;\n-          }\n+    worklist.push(head);\n+  }\n+  \/\/ BFS traversal down the CFG, except through NeverBranch exits\n+  for (uint i = 0; i < worklist.size(); ++i) {\n+    Node* n = worklist.at(i);\n+    assert(n->is_CFG(), \"only traverse CFG\");\n+    if (n->is_Root()) {\n+      \/\/ Found root -> there was an exit!\n+      return false;\n+    } else if (n->is_NeverBranch()) {\n+      \/\/ Only follow the loop-internal projection, not the NeverBranch exit\n+      ProjNode* proj = n->as_NeverBranch()->proj_out_or_null(0);\n+      assert(proj != nullptr, \"must find loop-internal projection of NeverBranch\");\n+      worklist.push(proj);\n+    } else {\n+      \/\/ Traverse all CFG outputs\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node* use = n->fast_out(i);\n+        if (use->is_CFG()) {\n+          worklist.push(use);\n@@ -4232,0 +4226,1 @@\n+  \/\/ No exit found for any loop -> all are infinite\n@@ -5483,1 +5478,1 @@\n-  bool res = cmpzm->in(input)->Opcode() == Op_Opaque1;\n+  bool res = cmpzm->in(input)->Opcode() == Op_OpaqueZeroTripGuard;\n@@ -5488,1 +5483,1 @@\n-    if (opnd && opnd->Opcode() == Op_Opaque1) {\n+    if (opnd && opnd->is_Opaque1()) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":28,"deletions":33,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1311,8 +1311,0 @@\n-\n-  \/\/ Enum to determine the action to be performed in create_new_if_for_predicate() when processing phis of UCT regions.\n-  enum class UnswitchingAction {\n-    None,            \/\/ No special action.\n-    FastLoopCloning, \/\/ Need to clone nodes for the fast loop.\n-    SlowLoopRewiring \/\/ Need to rewire nodes for the slow loop.\n-  };\n-\n@@ -1321,2 +1313,2 @@\n-                                        int opcode, bool if_cont_is_true_proj = true, Node_List* old_new = NULL,\n-                                        UnswitchingAction unswitching_action = UnswitchingAction::None);\n+                                        int opcode, bool rewire_uncommon_proj_phi_inputs = false,\n+                                        bool if_cont_is_true_proj = true);\n@@ -1324,2 +1316,9 @@\n-  \/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate.\n-  Node* clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new);\n+ private:\n+  \/\/ Helper functions for create_new_if_for_predicate()\n+  void set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Unique_Node_List find_nodes_with_same_ctrl(Node* node, const ProjNode* ctrl);\n+  Node* clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Dict clone_nodes(const Node_List& list_to_clone);\n+  void rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl, const Node_List& nodes_with_same_ctrl,\n+                                   const Dict& old_new_mapping);\n+  void rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping, const Node* next);\n@@ -1327,0 +1326,1 @@\n+ public:\n@@ -1643,2 +1643,2 @@\n-  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n-                                               Node_List* old_new = NULL);\n+  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry,\n+                                               Deoptimization::DeoptReason reason, bool slow_loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -795,2 +795,2 @@\n-      if (u->Opcode() == Op_NeverBranch) {\n-        u = ((NeverBranchNode*)u)->proj_out(0);\n+      if (u->is_NeverBranch()) {\n+        u = u->as_NeverBranch()->proj_out(0);\n@@ -979,1 +979,1 @@\n-            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->Opcode() == Op_NeverBranch, \"must not be moved into inner loop\");\n+            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch(), \"must not be moved into inner loop\");\n@@ -1184,1 +1184,1 @@\n-        (dom->Opcode() == Op_NeverBranch && loop->is_member(get_loop(dom->in(0))))) {\n+        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n@@ -1736,1 +1736,1 @@\n-    if (u->Opcode() == Op_Opaque1) {\n+    if (u->is_Opaque1()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/subnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -868,1 +868,1 @@\n-      in_bytes(JavaThread::extentLocalCache_offset()),\n+      in_bytes(JavaThread::scopedValueCache_offset()),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -925,0 +925,1 @@\n+  DEFINE_CLASS_QUERY(NeverBranch)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,0 +73,7 @@\n+class OpaqueZeroTripGuardNode : public Opaque1Node {\n+public:\n+  OpaqueZeroTripGuardNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -221,104 +221,0 @@\n-volatile int C2SafepointPollStubTable::_stub_size = 0;\n-\n-Label& C2SafepointPollStubTable::add_safepoint(uintptr_t safepoint_offset) {\n-  C2SafepointPollStub* entry = new (Compile::current()->comp_arena()) C2SafepointPollStub(safepoint_offset);\n-  _safepoints.append(entry);\n-  return entry->_stub_label;\n-}\n-\n-void C2SafepointPollStubTable::emit(CodeBuffer& cb) {\n-  MacroAssembler masm(&cb);\n-  for (int i = _safepoints.length() - 1; i >= 0; i--) {\n-    \/\/ Make sure there is enough space in the code buffer\n-    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n-      ciEnv::current()->record_failure(\"CodeCache is full\");\n-      return;\n-    }\n-\n-    C2SafepointPollStub* entry = _safepoints.at(i);\n-    emit_stub(masm, entry);\n-  }\n-}\n-\n-int C2SafepointPollStubTable::stub_size_lazy() const {\n-  int size = Atomic::load(&_stub_size);\n-\n-  if (size != 0) {\n-    return size;\n-  }\n-\n-  Compile* const C = Compile::current();\n-  BufferBlob* const blob = C->output()->scratch_buffer_blob();\n-  CodeBuffer cb(blob->content_begin(), C->output()->scratch_buffer_code_size());\n-  MacroAssembler masm(&cb);\n-  C2SafepointPollStub* entry = _safepoints.at(0);\n-  emit_stub(masm, entry);\n-  size += cb.insts_size();\n-\n-  Atomic::store(&_stub_size, size);\n-\n-  return size;\n-}\n-\n-int C2SafepointPollStubTable::estimate_stub_size() const {\n-  if (_safepoints.length() == 0) {\n-    return 0;\n-  }\n-\n-  int result = stub_size_lazy() * _safepoints.length();\n-\n-#ifdef ASSERT\n-  Compile* const C = Compile::current();\n-  BufferBlob* const blob = C->output()->scratch_buffer_blob();\n-  int size = 0;\n-\n-  for (int i = _safepoints.length() - 1; i >= 0; i--) {\n-    CodeBuffer cb(blob->content_begin(), C->output()->scratch_buffer_code_size());\n-    MacroAssembler masm(&cb);\n-    C2SafepointPollStub* entry = _safepoints.at(i);\n-    emit_stub(masm, entry);\n-    size += cb.insts_size();\n-  }\n-  assert(size == result, \"stubs should not have variable size\");\n-#endif\n-\n-  return result;\n-}\n-\n-\/\/ Nmethod entry barrier stubs\n-C2EntryBarrierStub* C2EntryBarrierStubTable::add_entry_barrier() {\n-  assert(_stub == NULL, \"There can only be one entry barrier stub\");\n-  _stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n-  return _stub;\n-}\n-\n-void C2EntryBarrierStubTable::emit(CodeBuffer& cb) {\n-  if (_stub == NULL) {\n-    \/\/ No stub - nothing to do\n-    return;\n-  }\n-\n-  C2_MacroAssembler masm(&cb);\n-  \/\/ Make sure there is enough space in the code buffer\n-  if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return;\n-  }\n-\n-  intptr_t before = masm.offset();\n-  masm.emit_entry_barrier_stub(_stub);\n-  intptr_t after = masm.offset();\n-  int actual_size = (int)(after - before);\n-  int expected_size = masm.entry_barrier_stub_size();\n-  assert(actual_size == expected_size, \"Estimated size is wrong, expected %d, was %d\", expected_size, actual_size);\n-}\n-\n-int C2EntryBarrierStubTable::estimate_stub_size() const {\n-  if (BarrierSet::barrier_set()->barrier_set_nmethod() == NULL) {\n-    \/\/ No nmethod entry barrier?\n-    return 0;\n-  }\n-\n-  return C2_MacroAssembler::entry_barrier_stub_size();\n-}\n-\n@@ -331,2 +227,1 @@\n-    _safepoint_poll_table(),\n-    _entry_barrier_table(),\n+    _stub_list(),\n@@ -1352,2 +1247,0 @@\n-  stub_req += safepoint_poll_table()->estimate_stub_size();\n-  stub_req += entry_barrier_table()->estimate_stub_size();\n@@ -1860,6 +1753,2 @@\n-  \/\/ Fill in stubs for calling the runtime from safepoint polls.\n-  safepoint_poll_table()->emit(*cb);\n-  if (C->failing())  return;\n-\n-  \/\/ Fill in stubs for calling the runtime from nmethod entries.\n-  entry_barrier_table()->emit(*cb);\n+  \/\/ Fill in stubs.\n+  _stub_list.emit(*cb);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":114,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"opto\/c2_CodeStubs.hpp\"\n@@ -76,69 +77,0 @@\n-class C2SafepointPollStubTable {\n-private:\n-  struct C2SafepointPollStub: public ArenaObj {\n-    uintptr_t _safepoint_offset;\n-    Label     _stub_label;\n-    Label     _trampoline_label;\n-    C2SafepointPollStub(uintptr_t safepoint_offset) :\n-      _safepoint_offset(safepoint_offset),\n-      _stub_label(),\n-      _trampoline_label() {}\n-  };\n-\n-  GrowableArray<C2SafepointPollStub*> _safepoints;\n-\n-  static volatile int _stub_size;\n-\n-  void emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const;\n-\n-  \/\/ The selection logic below relieves the need to add dummy files to unsupported platforms.\n-  template <bool enabled>\n-  typename EnableIf<enabled>::type\n-  select_emit_stub(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-    emit_stub_impl(masm, entry);\n-  }\n-\n-  template <bool enabled>\n-  typename EnableIf<!enabled>::type\n-  select_emit_stub(MacroAssembler& masm, C2SafepointPollStub* entry) const {}\n-\n-  void emit_stub(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-    select_emit_stub<VM_Version::supports_stack_watermark_barrier()>(masm, entry);\n-  }\n-\n-  int stub_size_lazy() const;\n-\n-public:\n-  Label& add_safepoint(uintptr_t safepoint_offset);\n-  int estimate_stub_size() const;\n-  void emit(CodeBuffer& cb);\n-};\n-\n-\/\/ We move non-hot code of the nmethod entry barrier to an out-of-line stub\n-class C2EntryBarrierStub: public ArenaObj {\n-  Label _slow_path;\n-  Label _continuation;\n-  Label _guard; \/\/ Used on AArch64 and RISCV\n-\n-public:\n-  C2EntryBarrierStub() :\n-    _slow_path(),\n-    _continuation(),\n-    _guard() {}\n-\n-  Label& slow_path() { return _slow_path; }\n-  Label& continuation() { return _continuation; }\n-  Label& guard() { return _guard; }\n-\n-};\n-\n-class C2EntryBarrierStubTable {\n-  C2EntryBarrierStub* _stub;\n-\n-public:\n-  C2EntryBarrierStubTable() : _stub(NULL) {}\n-  C2EntryBarrierStub* add_entry_barrier();\n-  int estimate_stub_size() const;\n-  void emit(CodeBuffer& cb);\n-};\n-\n@@ -153,2 +85,1 @@\n-  C2SafepointPollStubTable _safepoint_poll_table;\/\/ Table for safepoint polls\n-  C2EntryBarrierStubTable _entry_barrier_table;  \/\/ Table for entry barrier stubs\n+  C2CodeStubList          _stub_list;            \/\/ List of code stubs\n@@ -202,5 +133,2 @@\n-  \/\/ Safepoint poll table\n-  C2SafepointPollStubTable* safepoint_poll_table() { return &_safepoint_poll_table; }\n-\n-  \/\/ Entry barrier table\n-  C2EntryBarrierStubTable* entry_barrier_table() { return &_entry_barrier_table; }\n+  \/\/ Code stubs list\n+  void add_stub(C2CodeStub* stub) { _stub_list.add_stub(stub); }\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":5,"deletions":77,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1251,0 +1251,5 @@\n+  \/\/ Allow Bool -> Cmp idealisation in late inlining intrinsics that return a bool\n+  if (n->is_Cmp()) {\n+    add_users_to_worklist(n);\n+  }\n+\n@@ -1780,0 +1785,1 @@\n+  DEBUG_ONLY(Unique_Node_List worklist_verify;)\n@@ -1788,0 +1794,1 @@\n+    DEBUG_ONLY(worklist_verify.push(n);)\n@@ -1801,0 +1808,1 @@\n+  DEBUG_ONLY(verify_analyze(worklist_verify);)\n@@ -1803,0 +1811,45 @@\n+#ifdef ASSERT\n+\/\/ For every node n on verify list, check if type(n) == n->Value()\n+\/\/ We have a list of exceptions, see comments in code.\n+void PhaseCCP::verify_analyze(Unique_Node_List& worklist_verify) {\n+  bool failure = false;\n+  while (worklist_verify.size()) {\n+    Node* n = worklist_verify.pop();\n+    const Type* told = type(n);\n+    const Type* tnew = n->Value(this);\n+    if (told != tnew) {\n+      \/\/ Check special cases that are ok\n+      if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n+        const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n+        const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n+        if (t0->lo_as_long() == t1->lo_as_long() &&\n+            t0->hi_as_long() == t1->hi_as_long()) {\n+          continue; \/\/ ignore integer widen\n+        }\n+      }\n+      if (n->is_Load()) {\n+        \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n+        \/\/ which means we would need to notify modifications from far up in\n+        \/\/ the inputs all the way down to the LoadNode. We don't do that.\n+        continue;\n+      }\n+      tty->cr();\n+      tty->print_cr(\"Missed optimization (PhaseCCP):\");\n+      n->dump_bfs(1, 0, \"\");\n+      tty->print_cr(\"Current type:\");\n+      told->dump_on(tty);\n+      tty->cr();\n+      tty->print_cr(\"Optimized type:\");\n+      tnew->dump_on(tty);\n+      tty->cr();\n+      failure = true;\n+    }\n+  }\n+  \/\/ If we get this assert, check why the reported nodes were not processed again in CCP.\n+  \/\/ We should either make sure that these nodes are properly added back to the CCP worklist\n+  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type or add an exception\n+  \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+  assert(!failure, \"Missed optimization opportunity in PhaseCCP\");\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -606,0 +606,4 @@\n+#ifdef ASSERT\n+  \/\/ For every node n on verify list, check if type(n) == n->Value()\n+  void verify_analyze(Unique_Node_List& worklist_verify);\n+#endif\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -223,0 +224,18 @@\n+  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n+    \/\/ If this Opaque1 is part of the zero trip guard for a loop:\n+    \/\/ 1- it can't be shared\n+    \/\/ 2- the zero trip guard can't be the if that's being split\n+    \/\/ As a consequence, this node could be assigned control anywhere between its current control and the zero trip guard.\n+    \/\/ Move it down to get it out of the way of split if and avoid breaking the zero trip guard shape.\n+    Node* cmp = n->unique_out();\n+    assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n+    Node* bol = cmp->unique_out();\n+    assert(bol->Opcode() == Op_Bool, \"bad zero trip guard shape\");\n+    Node* iff = bol->unique_out();\n+    assert(iff->Opcode() == Op_If, \"bad zero trip guard shape\");\n+    set_ctrl(n, iff->in(0));\n+    set_ctrl(cmp, iff->in(0));\n+    set_ctrl(bol, iff->in(0));\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1430,1 +1430,4 @@\n-  if( cop == Op_FastLock || cop == Op_FastUnlock || cmp->is_SubTypeCheck()) return NULL;\n+  if( cop == Op_FastLock || cop == Op_FastUnlock ||\n+      cmp->is_SubTypeCheck() || cop == Op_VectorTest ) {\n+    return NULL;\n+  }\n@@ -1447,1 +1450,1 @@\n-  if( con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_Opaque1 &&\n+  if (con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_OpaqueZeroTripGuard &&\n@@ -1462,0 +1465,14 @@\n+  \/\/ Change \"bool eq\/ne (cmp (cmove (bool tst (cmp2)) 1 0) 0)\" into \"bool tst\/~tst (cmp2)\"\n+  if (cop == Op_CmpI &&\n+      (_test._test == BoolTest::eq || _test._test == BoolTest::ne) &&\n+      cmp1_op == Op_CMoveI && cmp2->find_int_con(1) == 0) {\n+    \/\/ 0 should be on the true branch\n+    if (cmp1->in(CMoveNode::IfTrue)->find_int_con(1) == 0 &&\n+        cmp1->in(CMoveNode::IfFalse)->find_int_con(0) != 0) {\n+      BoolNode* target = cmp1->in(CMoveNode::Condition)->as_Bool();\n+      return new BoolNode(target->in(1),\n+                          (_test._test == BoolTest::eq) ? target->_test._test :\n+                                                          target->_test.negate());\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2715,1 +2715,1 @@\n-        int vopc = VectorCastNode::opcode(in->bottom_type()->is_vect()->element_basic_type());\n+        int vopc = VectorCastNode::opcode(opc, in->bottom_type()->is_vect()->element_basic_type());\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -778,1 +778,1 @@\n-  int cast_vopc = VectorCastNode::opcode(T_BYTE); \/\/ from shuffle of type T_BYTE\n+  int cast_vopc = VectorCastNode::opcode(-1, T_BYTE); \/\/ from shuffle of type T_BYTE\n@@ -1802,1 +1802,7 @@\n-  Node* opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* opd2;\n+  if (Matcher::vectortest_needs_second_argument(booltest == BoolTest::overflow,\n+                                                opd1->bottom_type()->isa_vectmask())) {\n+    opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  } else {\n+    opd2 = opd1;\n+  }\n@@ -1806,2 +1812,0 @@\n-  Node* test = new VectorTestNode(opd1, opd2, booltest);\n-  test = gvn().transform(test);\n@@ -1809,1 +1813,7 @@\n-  set_result(test);\n+  Node* cmp = gvn().transform(new VectorTestNode(opd1, opd2, booltest));\n+  BoolTest::mask test = Matcher::vectortest_mask(booltest == BoolTest::overflow,\n+                                                 opd1->bottom_type()->isa_vectmask(), num_elem);\n+  Node* bol = gvn().transform(new BoolNode(cmp, test));\n+  Node* res = gvn().transform(new CMoveINode(bol, gvn().intcon(0), gvn().intcon(1), TypeInt::BOOL));\n+\n+  set_result(res);\n@@ -2492,1 +2502,1 @@\n-    int cast_vopc = VectorCastNode::opcode(elem_bt_from, !is_ucast);\n+    int cast_vopc = VectorCastNode::opcode(-1, elem_bt_from, !is_ucast);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -470,0 +470,2 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n@@ -1331,0 +1333,2 @@\n+    case Op_VectorCastHF2F: return new VectorCastHF2FNode(n1, vt);\n+    case Op_VectorCastF2HF: return new VectorCastF2HFNode(n1, vt);\n@@ -1337,1 +1341,1 @@\n-int VectorCastNode::opcode(BasicType bt, bool is_signed) {\n+int VectorCastNode::opcode(int sopc, BasicType bt, bool is_signed) {\n@@ -1339,0 +1343,15 @@\n+\n+  \/\/ Handle special case for to\/from Half Float conversions\n+  switch (sopc) {\n+    case Op_ConvHF2F:\n+      assert(bt == T_SHORT, \"\");\n+      return Op_VectorCastHF2F;\n+    case Op_ConvF2HF:\n+      assert(bt == T_FLOAT, \"\");\n+      return Op_VectorCastF2HF;\n+    default:\n+      \/\/ Handled normally below\n+      break;\n+  }\n+\n+  \/\/ Handle normal conversions\n@@ -1357,1 +1376,1 @@\n-    int vopc = VectorCastNode::opcode(src_type);\n+    int vopc = VectorCastNode::opcode(opc, src_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1425,1 +1425,1 @@\n-class VectorTestNode : public Node {\n+class VectorTestNode : public CmpNode {\n@@ -1433,1 +1433,1 @@\n-  VectorTestNode(Node* in1, Node* in2, BoolTest::mask predicate) : Node(NULL, in1, in2), _predicate(predicate) {\n+  VectorTestNode(Node* in1, Node* in2, BoolTest::mask predicate) : CmpNode(in1, in2), _predicate(predicate) {\n@@ -1438,0 +1438,4 @@\n+  virtual const Type* Value(PhaseGVN* phase) const { return TypeInt::CC; }\n+  virtual const Type* sub(const Type*, const Type*) const { return TypeInt::CC; }\n+  BoolTest::mask get_predicate() const { return _predicate; }\n+\n@@ -1441,4 +1445,0 @@\n-  virtual const Type *bottom_type() const { return TypeInt::BOOL; }\n-  virtual uint ideal_reg() const { return Op_RegI; }  \/\/ TODO Should be RegFlags but due to missing comparison flags for BoolTest\n-                                                      \/\/ in middle-end, we make it boolean result directly.\n-  BoolTest::mask get_predicate() const { return _predicate; }\n@@ -1545,1 +1545,1 @@\n-  static int  opcode(BasicType bt, bool is_signed = true);\n+  static int  opcode(int opc, BasicType bt, bool is_signed = true);\n@@ -1631,0 +1631,16 @@\n+class VectorCastHF2FNode : public VectorCastNode {\n+ public:\n+  VectorCastHF2FNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorCastF2HFNode : public VectorCastNode {\n+ public:\n+  VectorCastF2HFNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -629,1 +629,1 @@\n-  thread->print_stack();\n+  thread->print_jni_stack();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  thr->print_stack();\n+  thr->print_jni_stack();\n@@ -196,1 +196,1 @@\n-      thr->print_stack();\n+      thr->print_jni_stack();\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    thr->print_stack();\n+    thr->print_jni_stack();\n","filename":"src\/hotspot\/share\/prims\/jniCheck.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1366,0 +1366,48 @@\n+class ScopedValueBindingsResolver {\n+public:\n+  InstanceKlass* Carrier_klass;\n+  ScopedValueBindingsResolver(JavaThread* THREAD) {\n+    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_incubator_concurrent_ScopedValue_Carrier(), true, THREAD);\n+    Carrier_klass = InstanceKlass::cast(k);\n+  }\n+};\n+\n+JVM_ENTRY(jobject, JVM_FindScopedValueBindings(JNIEnv *env, jclass cls))\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Handle>* local_array = new GrowableArray<Handle>(12);\n+  JvmtiVMObjectAllocEventCollector oam;\n+\n+  static ScopedValueBindingsResolver resolver(THREAD);\n+\n+  \/\/ Iterate through Java frames\n+  vframeStream vfst(thread);\n+  for(; !vfst.at_end(); vfst.next()) {\n+    int loc = -1;\n+    \/\/ get method of frame\n+    Method* method = vfst.method();\n+\n+    Symbol *name = method->name();\n+\n+    InstanceKlass* holder = method->method_holder();\n+    if (name == vmSymbols::runWith_method_name()) {\n+      if ((holder == resolver.Carrier_klass\n+           || holder == vmClasses::VirtualThread_klass()\n+           || holder == vmClasses::Thread_klass())) {\n+        loc = 1;\n+      }\n+    }\n+\n+    if (loc != -1) {\n+      javaVFrame *frame = vfst.asJavaVFrame();\n+      StackValueCollection* locals = frame->locals();\n+      StackValue* head_sv = locals->at(loc); \/\/ jdk\/incubator\/concurrent\/ScopedValue$Snapshot\n+      Handle result = head_sv->get_obj();\n+      assert(!head_sv->obj_is_scalar_replaced(), \"found scalar-replaced object\");\n+      if (result() != NULL) {\n+        return JNIHandles::make_local(THREAD, result());\n+      }\n+    }\n+  }\n+\n+  return NULL;\n+JVM_END\n@@ -3117,6 +3165,2 @@\n-JVM_ENTRY(jobject, JVM_ExtentLocalCache(JNIEnv* env, jclass threadClass))\n-  oop theCache = thread->extentLocalCache();\n-  if (theCache) {\n-    arrayOop objs = arrayOop(theCache);\n-    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n-  }\n+JVM_ENTRY(jobject, JVM_ScopedValueCache(JNIEnv* env, jclass threadClass))\n+  oop theCache = thread->scopedValueCache();\n@@ -3126,1 +3170,1 @@\n-JVM_ENTRY(void, JVM_SetExtentLocalCache(JNIEnv* env, jclass threadClass,\n+JVM_ENTRY(void, JVM_SetScopedValueCache(JNIEnv* env, jclass threadClass,\n@@ -3129,4 +3173,1 @@\n-  if (objs != NULL) {\n-    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n-  }\n-  thread->set_extentLocalCache(objs);\n+  thread->set_scopedValueCache(objs);\n@@ -4022,0 +4063,9 @@\n+\n+\/*\n+ * Ensure that code doing a stackwalk and using javaVFrame::locals() to\n+ * get the value will see a materialized value and not a scalar-replaced\n+ * null value.\n+ *\/\n+JVM_ENTRY(void, JVM_EnsureMaterializedForStackWalk_func(JNIEnv* env, jobject vthread, jobject value))\n+  JVM_EnsureMaterializedForStackWalk(env, value);\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":61,"deletions":11,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-      sprintf(buf, \"<null>\");\n+      os::snprintf_checked(buf, sizeof(buf), \"<null>\");\n","filename":"src\/hotspot\/share\/prims\/wbtestmethods\/parserTests.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -551,7 +551,0 @@\n-  { \"ExtendedDTraceProbes\",         JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"UseContainerCpuShares\",        JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"PreferContainerQuotaForCPUCount\", JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"AliasLevel\",                   JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"UseCodeAging\",                 JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"PrintSharedDictionary\",          JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-\n@@ -1957,2 +1950,4 @@\n-    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n-      return false;\n+    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+      if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -127,1 +127,2 @@\n-  static inline oop cont(oop chunk);\n+  template<typename P>\n+  static inline oop cont_raw(oop chunk);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,2 +84,3 @@\n-inline oop jdk_internal_vm_StackChunk::cont(oop chunk) {\n-  return chunk->obj_field(_cont_offset);\n+template<typename P>\n+inline oop jdk_internal_vm_StackChunk::cont_raw(oop chunk) {\n+  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_cont_offset));\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -444,5 +444,2 @@\n-    \/\/ FIXME: This very crudely destroys all ExtentLocal bindings. This\n-    \/\/ is better than a bound value escaping, but far from ideal.\n-    oop java_thread = current->threadObj();\n-    current->set_extentLocalCache(NULL);\n-    java_lang_Thread::clear_extentLocalBindings(java_thread);\n+    \/\/ This destroys all ScopedValue bindings.\n+    current->clear_scopedValueBindings();\n@@ -2586,1 +2583,1 @@\n-  sprintf(buf, \"reason%d\", reason);\n+  os::snprintf_checked(buf, sizeof(buf), \"reason%d\", reason);\n@@ -2596,1 +2593,1 @@\n-  sprintf(buf, \"action%d\", action);\n+  os::snprintf_checked(buf, sizeof(buf), \"action%d\", action);\n@@ -2719,1 +2716,1 @@\n-            sprintf(name, \"%s\/%s\/%s\",\n+            os::snprintf_checked(name, sizeof(name), \"%s\/%s\/%s\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -95,12 +95,0 @@\n-JVMFlag::Error ExtentLocalCacheSizeConstraintFunc(intx value, bool verbose) {\n-  if (!is_power_of_2(value)) {\n-    JVMFlag::printError(verbose,\n-                        \"ExtentLocalCacheSize (\" INTX_FORMAT \") must be \"\n-                        \"power of 2\\n\",\n-                        value);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  }\n-\n-  return JVMFlag::SUCCESS;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  f(intx,   ExtentLocalCacheSizeConstraintFunc)        \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1950,5 +1950,0 @@\n-  product(intx, ExtentLocalCacheSize, 16,                                   \\\n-          \"Size of the cache for scoped values\")                            \\\n-           range(0, max_intx)                                               \\\n-           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  _extentLocalCache = OopHandle(_thread_oop_storage, NULL);\n+  _scopedValueCache = OopHandle(_thread_oop_storage, NULL);\n@@ -189,2 +189,2 @@\n-oop JavaThread::extentLocalCache() const {\n-  return _extentLocalCache.resolve();\n+oop JavaThread::scopedValueCache() const {\n+  return _scopedValueCache.resolve();\n@@ -193,3 +193,16 @@\n-void JavaThread::set_extentLocalCache(oop p) {\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n-  _extentLocalCache.replace(p);\n+void JavaThread::set_scopedValueCache(oop p) {\n+  if (_scopedValueCache.ptr_raw() != NULL) { \/\/ i.e. if the OopHandle has been allocated\n+    _scopedValueCache.replace(p);\n+  } else {\n+    assert(p == NULL, \"not yet initialized\");\n+  }\n+}\n+\n+void JavaThread::clear_scopedValueBindings() {\n+  set_scopedValueCache(NULL);\n+  oop vthread_oop = vthread();\n+  \/\/ vthread may be null here if we get a VM error during startup,\n+  \/\/ before the java.lang.Thread instance has been created.\n+  if (vthread_oop != NULL) {\n+    java_lang_Thread::clear_scopedValueBindings(vthread_oop);\n+  }\n@@ -1043,5 +1056,1 @@\n-  \/\/ Clear any extent-local bindings\n-  set_extentLocalCache(NULL);\n-  oop threadOop = threadObj();\n-  assert(threadOop != NULL, \"must be\");\n-  java_lang_Thread::clear_extentLocalBindings(threadOop);\n+  clear_scopedValueBindings();\n@@ -1667,0 +1676,10 @@\n+\/\/ Print stack trace for checked JNI warnings and JNI fatal errors.\n+\/\/ This is the external format from above, but selecting the platform\n+\/\/ or vthread as applicable.\n+void JavaThread::print_jni_stack() {\n+  if (is_vthread_mounted()) {\n+    print_vthread_stack_on(tty);\n+  } else {\n+    print_stack_on(tty);\n+  }\n+}\n@@ -1700,0 +1719,42 @@\n+void JavaThread::print_vthread_stack_on(outputStream* st) {\n+  assert(is_vthread_mounted(), \"Caller should have checked this\");\n+  assert(has_last_Java_frame(), \"must be\");\n+\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  RegisterMap reg_map(this,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::include);\n+  ContinuationEntry* cont_entry = last_continuation();\n+  vframe* start_vf = last_java_vframe(&reg_map);\n+  int count = 0;\n+  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+    \/\/ Watch for end of vthread stack\n+    if (Continuation::is_continuation_enterSpecial(f->fr())) {\n+      assert(cont_entry == Continuation::get_continuation_entry_for_entry_frame(this, f->fr()), \"\");\n+      if (cont_entry->is_virtual_thread()) {\n+        break;\n+      }\n+      cont_entry = cont_entry->parent();\n+    }\n+    if (f->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(f);\n+      java_lang_Throwable::print_stack_element(st, jvf->method(), jvf->bci());\n+\n+      \/\/ Print out lock information\n+      if (JavaMonitorsInStackTrace) {\n+        jvf->print_lock_info_on(st, count);\n+      }\n+    } else {\n+      \/\/ Ignore non-Java frames\n+    }\n+\n+    \/\/ Bail-out case for too deep stacks if MaxJavaStackTraceDepth > 0\n+    count++;\n+    if (MaxJavaStackTraceDepth > 0 && MaxJavaStackTraceDepth == count) return;\n+  }\n+}\n+\n@@ -2100,1 +2161,1 @@\n-  new_head->add(_extentLocalCache);\n+  new_head->add(_scopedValueCache);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":73,"deletions":12,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  OopHandle      _extentLocalCache;\n+  OopHandle      _scopedValueCache;\n@@ -523,2 +523,3 @@\n-  oop extentLocalCache() const;\n-  void set_extentLocalCache(oop p);\n+  oop scopedValueCache() const;\n+  void set_scopedValueCache(oop p);\n+  void clear_scopedValueBindings();\n@@ -747,1 +748,1 @@\n-  static ByteSize extentLocalCache_offset()       { return byte_offset_of(JavaThread, _extentLocalCache); }\n+  static ByteSize scopedValueCache_offset()       { return byte_offset_of(JavaThread, _scopedValueCache); }\n@@ -942,0 +943,6 @@\n+  void print_vthread_stack_on(outputStream* st);\n+\n+  \/\/ Print stack trace for checked JNI warnings and JNI fatal errors.\n+  \/\/ This is the external format from above, but selecting the platform\n+  \/\/ or vthread as applicable.\n+  void print_jni_stack();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"services\/mallocHeader.inline.hpp\"\n@@ -101,0 +102,10 @@\n+int os::snprintf_checked(char* buf, size_t len, const char* fmt, ...) {\n+  va_list args;\n+  va_start(args, fmt);\n+  int result = os::vsnprintf(buf, len, fmt, args);\n+  va_end(args);\n+  assert(result >= 0, \"os::snprintf error\");\n+  assert(static_cast<size_t>(result) < len, \"os::snprintf truncated\");\n+  return result;\n+}\n+\n@@ -717,6 +728,6 @@\n-    const size_t old_size = MallocTracker::malloc_header(memblock)->size();\n-\n-    \/\/ De-account the old block from NMT *before* calling the real realloc(3) since it\n-    \/\/ may invalidate old block including its header. This will also perform integrity checks\n-    \/\/ on the old block (e.g. overwriters) and mark the old header as dead.\n-    void* const old_outer_ptr = MemTracker::record_free(memblock);\n+    \/\/ Perform integrity checks on and mark the old block as dead *before* calling the real realloc(3) since it\n+    \/\/ may invalidate the old block, including its header.\n+    MallocHeader* header = MallocTracker::malloc_header(memblock);\n+    header->assert_block_integrity(); \/\/ Assert block hasn't been tampered with.\n+    const MallocHeader::FreeInfo free_info = header->free_info();\n+    header->mark_block_as_dead();\n@@ -725,1 +736,1 @@\n-    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(old_outer_ptr, new_outer_size);)\n+    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(header, new_outer_size);)\n@@ -728,6 +739,4 @@\n-      \/\/ If realloc(3) failed, the old block still exists. We must re-instantiate the old\n-      \/\/ NMT header then, since we marked it dead already. Otherwise subsequent os::realloc()\n-      \/\/ or os::free() calls would trigger block integrity asserts.\n-      void* p = MemTracker::record_malloc(old_outer_ptr, old_size, memflags, stack);\n-      assert(p == memblock, \"sanity\");\n-      return NULL;\n+      \/\/ realloc(3) failed and the block still exists.\n+      \/\/ We have however marked it as dead, revert this change.\n+      header->revive();\n+      return nullptr;\n@@ -735,0 +744,2 @@\n+    \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n+    MemTracker::deaccount(free_info);\n@@ -736,2 +747,2 @@\n-    \/\/ After a successful realloc(3), we re-account the resized block with its new size\n-    \/\/ to NMT. This re-instantiates the NMT header.\n+    \/\/ After a successful realloc(3), we account the resized block with its new size\n+    \/\/ to NMT.\n@@ -741,0 +752,1 @@\n+    size_t old_size = free_info.size;\n@@ -777,1 +789,1 @@\n-  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n+  \/\/ When NMT is enabled this checks for heap overwrites, then deaccounts the old block.\n@@ -1315,1 +1327,1 @@\n-  sprintf(modified_mode, \"%s\" LINUX_ONLY(\"e\") BSD_ONLY(\"e\") WINDOWS_ONLY(\"N\"), mode);\n+  os::snprintf_checked(modified_mode, sizeof(modified_mode), \"%s\" LINUX_ONLY(\"e\") BSD_ONLY(\"e\") WINDOWS_ONLY(\"N\"), mode);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -750,0 +750,4 @@\n+  \/\/ Performs snprintf and asserts the result is non-negative (so there was not\n+  \/\/ an encoding error) and that the output was not truncated.\n+  static int snprintf_checked(char* buf, size_t len, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,7 +43,6 @@\n-  CPUInformation() {\n-    _no_of_sockets = 0;\n-    _no_of_cores = 0;\n-    _no_of_hw_threads = 0;\n-    _description = NULL;\n-    _name = NULL;\n-  }\n+  CPUInformation() :\n+    _no_of_sockets(0),\n+    _no_of_cores(0),\n+    _no_of_hw_threads(0),\n+    _description(nullptr),\n+    _name(nullptr) {}\n@@ -101,7 +100,13 @@\n-  SystemProcess() {\n-    _pid  = 0;\n-    _name = NULL;\n-    _path = NULL;\n-    _command_line = NULL;\n-    _next = NULL;\n-  }\n+  SystemProcess() :\n+    _pid (0),\n+    _name(nullptr),\n+    _path(nullptr),\n+    _command_line(nullptr),\n+    _next(nullptr) {}\n+\n+  SystemProcess(int pid, char* name, char* path, char* command_line, SystemProcess* next) :\n+    _pid(pid),\n+    _name(name),\n+    _path(path),\n+    _command_line(command_line),\n+    _next(next) {}\n@@ -167,1 +172,1 @@\n-  _name(NULL),\n+  _name(nullptr),\n@@ -171,1 +176,1 @@\n-    assert(name != NULL, \"invariant\");\n+    assert(name != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/os_perf.hpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n-  _name = NEW_C_HEAP_ARRAY(char, strlen(name) + strlen(prefix) + 2, mtInternal);\n+  const size_t _name_size = strlen(name) + strlen(prefix) + 2;\n+  _name = NEW_C_HEAP_ARRAY(char, _name_size, mtInternal);\n@@ -103,1 +104,1 @@\n-    sprintf(_name, \"%s.%s\", prefix, name);\n+    os::snprintf_checked(_name, _name_size, \"%s.%s\", prefix, name);\n@@ -337,1 +338,1 @@\n-   sprintf(result, \"%s.%s\", ns, name);\n+   os::snprintf_checked(result, len, \"%s.%s\", ns, name);\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -887,3 +887,4 @@\n-  \/\/ Remove the ExtentLocal cache in case we got a StackOverflowError\n-  \/\/ while we were trying to remove ExtentLocal bindings.\n-  current->set_extentLocalCache(NULL);\n+  \/\/ Remove the ScopedValue bindings in case we got a\n+  \/\/ StackOverflowError while we were trying to remove ScopedValue\n+  \/\/ bindings.\n+  current->clear_scopedValueBindings();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  GrowableArray<ScopeValue*>* extentLocals = scope()->locals();\n+  GrowableArray<ScopeValue*>* scopedValues = scope()->locals();\n@@ -153,1 +153,1 @@\n-      if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+      if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -713,1 +713,1 @@\n-  nonstatic_field(JavaThread,                  _extentLocalCache,                              OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                              OopHandle)                             \\\n@@ -1878,1 +1878,1 @@\n-  declare_c2_type(VectorTestNode, Node)                                   \\\n+  declare_c2_type(VectorTestNode, CmpNode)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-\n+  NONCOPYABLE(MallocHeader);\n@@ -118,0 +118,6 @@\n+  \/\/ Contains all of the necessary data to to deaccount block with NMT.\n+  struct FreeInfo {\n+    const size_t size;\n+    const MEMFLAGS flags;\n+    const uint32_t mst_marker;\n+  };\n@@ -126,0 +132,4 @@\n+  \/\/ Return the necessary data to deaccount the block with NMT.\n+  FreeInfo free_info() {\n+    return FreeInfo{this->size(), this->flags(), this->mst_marker()};\n+  }\n@@ -127,0 +137,1 @@\n+  inline void revive();\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,0 +48,10 @@\n+inline void MallocHeader::revive() {\n+  assert(_canary == _header_canary_dead_mark, \"must be dead\");\n+  assert(get_footer() == _footer_canary_dead_mark, \"must be dead\");\n+  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"must be dead\"));\n+  _canary = _header_canary_life_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_life_mark);\n+  set_footer(_footer_canary_life_mark);\n+}\n+\n+\/\/ The effects of this method must be reversible with MallocHeader::revive()\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-void* MallocTracker::record_free(void* memblock) {\n+void* MallocTracker::record_free_block(void* memblock) {\n@@ -190,4 +190,1 @@\n-  MallocMemorySummary::record_free(header->size(), header->flags());\n-  if (MemTracker::tracking_level() == NMT_detail) {\n-    MallocSiteTable::deallocation_at(header->size(), header->mst_marker());\n-  }\n+  deaccount(header->free_info());\n@@ -200,0 +197,7 @@\n+void MallocTracker::deaccount(MallocHeader::FreeInfo free_info) {\n+  MallocMemorySummary::record_free(free_info.size, free_info.flags);\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    MallocSiteTable::deallocation_at(free_info.size, free_info.mst_marker);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -156,1 +156,6 @@\n-  inline MallocMemory*  by_type(MEMFLAGS flags) {\n+  inline MallocMemory* by_type(MEMFLAGS flags) {\n+    int index = NMTUtil::flag_to_index(flags);\n+    return &_malloc[index];\n+  }\n+\n+  inline const MallocMemory* by_type(MEMFLAGS flags) const {\n@@ -301,2 +306,5 @@\n-  \/\/ Record free on specified memory block\n-  static void* record_free(void* memblock);\n+  \/\/ Given a block returned by os::malloc() or os::realloc():\n+  \/\/ deaccount block from NMT, mark its header as dead and return pointer to header.\n+  static void* record_free_block(void* memblock);\n+  \/\/ Given the free info from a block, de-account block from NMT.\n+  static void deaccount(MallocHeader::FreeInfo free_info);\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"services\/memJfrReporter.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ Helper class to avoid refreshing the NMTUsage to often and allow\n+\/\/ the two JFR events to use the same data.\n+class MemJFRCurrentUsage : public AllStatic {\n+private:\n+  \/\/ The age threshold in milliseconds. If older than this refresh the usage.\n+  static const uint64_t AgeThreshold = 50;\n+\n+  static Ticks _timestamp;\n+  static NMTUsage* _usage;\n+\n+public:\n+  static NMTUsage* get_usage();\n+  static Ticks get_timestamp();\n+};\n+\n+Ticks MemJFRCurrentUsage::_timestamp;\n+NMTUsage* MemJFRCurrentUsage::_usage = nullptr;\n+\n+NMTUsage* MemJFRCurrentUsage::get_usage() {\n+  Tickspan since_baselined = Ticks::now() - _timestamp;\n+\n+  if (_usage == nullptr) {\n+    \/\/ First time, create a new NMTUsage.\n+    _usage = new NMTUsage(NMTUsage::OptionsNoTS);\n+  } else if (since_baselined.milliseconds() < AgeThreshold) {\n+    \/\/ There is recent enough usage information, return it.\n+    return _usage;\n+  }\n+\n+  \/\/ Refresh the usage information.\n+  _usage->refresh();\n+  _timestamp.stamp();\n+\n+  return _usage;\n+}\n+\n+Ticks MemJFRCurrentUsage::get_timestamp() {\n+  return _timestamp;\n+}\n+\n+void MemJFRReporter::send_total_event() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  NMTUsage* usage = MemJFRCurrentUsage::get_usage();\n+  Ticks timestamp = MemJFRCurrentUsage::get_timestamp();\n+\n+  EventNativeMemoryUsageTotal event(UNTIMED);\n+  event.set_starttime(timestamp);\n+  event.set_reserved(usage->total_reserved());\n+  event.set_committed(usage->total_committed());\n+  event.commit();\n+}\n+\n+void MemJFRReporter::send_type_event(const Ticks& starttime, const char* type, size_t reserved, size_t committed) {\n+  EventNativeMemoryUsage event(UNTIMED);\n+  event.set_starttime(starttime);\n+  event.set_type(type);\n+  event.set_reserved(reserved);\n+  event.set_committed(committed);\n+  event.commit();\n+}\n+\n+void MemJFRReporter::send_type_events() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  NMTUsage* usage = MemJFRCurrentUsage::get_usage();\n+  Ticks timestamp = MemJFRCurrentUsage::get_timestamp();\n+\n+  for (int index = 0; index < mt_number_of_types; index ++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n+    if (flag == mtNone) {\n+      \/\/ Skip mtNone since it is not really used.\n+      continue;\n+    }\n+    send_type_event(timestamp, NMTUtil::flag_to_name(flag), usage->reserved(flag), usage->committed(flag));\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMJFRREPORTER_HPP\n+#define SHARE_SERVICES_MEMJFRREPORTER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ MemJFRReporter is only used by threads sending periodic JFR\n+\/\/ events. These threads are synchronized at a higher level,\n+\/\/ so no more synchronization is needed.\n+class MemJFRReporter : public AllStatic {\n+private:\n+  static void send_type_event(const Ticks& starttime, const char* tag, size_t reserved, size_t committed);\n+ public:\n+  static void send_total_event();\n+  static void send_type_events();\n+};\n+\n+#endif \/\/SHARE_SERVICES_MEMJFRREPORTER_HPP\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -34,1 +34,11 @@\n-size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+\/\/ Diff two counters, express them as signed, with range checks\n+static ssize_t counter_diff(size_t c1, size_t c2) {\n+  assert(c1 <= SSIZE_MAX, \"counter out of range: \" SIZE_FORMAT \".\", c1);\n+  assert(c2 <= SSIZE_MAX, \"counter out of range: \" SIZE_FORMAT \".\", c2);\n+  if (c1 > SSIZE_MAX || c2 > SSIZE_MAX) {\n+    return 0;\n+  }\n+  return c1 - c2;\n+}\n+\n+size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n@@ -38,1 +48,1 @@\n-size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n@@ -465,2 +475,3 @@\n-    if (current_count != early_count) {\n-      out->print(\" %+d\", (int)(current_count - early_count));\n+    const ssize_t delta_count = counter_diff(current_count, early_count);\n+    if (delta_count != 0) {\n+      out->print(\" \" SSIZE_PLUS_FORMAT, delta_count);\n@@ -481,2 +492,3 @@\n-  if (current_count != early_count) {\n-    out->print(\" %+d\", (int)(current_count - early_count));\n+  const ssize_t delta_count = counter_diff(current_count, early_count);\n+  if (delta_count != 0) {\n+    out->print(\" \" SSIZE_PLUS_FORMAT, delta_count);\n@@ -554,4 +566,4 @@\n-      int class_count_diff = (int)(_current_baseline.class_count() -\n-        _early_baseline.class_count());\n-      if (_current_baseline.class_count() != _early_baseline.class_count()) {\n-        out->print(\" %+d\", (int)(_current_baseline.class_count() - _early_baseline.class_count()));\n+      const ssize_t class_count_diff =\n+          counter_diff(_current_baseline.class_count(), _early_baseline.class_count());\n+      if (class_count_diff != 0) {\n+        out->print(\" \" SSIZE_PLUS_FORMAT, class_count_diff);\n@@ -562,2 +574,4 @@\n-      if (_current_baseline.instance_class_count() != _early_baseline.instance_class_count()) {\n-        out->print(\" %+d\", (int)(_current_baseline.instance_class_count() - _early_baseline.instance_class_count()));\n+      const ssize_t instance_class_count_diff =\n+          counter_diff(_current_baseline.instance_class_count(), _early_baseline.instance_class_count());\n+      if (instance_class_count_diff != 0) {\n+        out->print(\" \" SSIZE_PLUS_FORMAT, instance_class_count_diff);\n@@ -566,2 +580,4 @@\n-      if (_current_baseline.array_class_count() != _early_baseline.array_class_count()) {\n-        out->print(\" %+d\", (int)(_current_baseline.array_class_count() - _early_baseline.array_class_count()));\n+      const ssize_t array_class_count_diff =\n+          counter_diff(_current_baseline.array_class_count(), _early_baseline.array_class_count());\n+      if (array_class_count_diff != 0) {\n+        out->print(\" \" SSIZE_PLUS_FORMAT, array_class_count_diff);\n@@ -574,2 +590,1 @@\n-      int thread_count_diff = (int)(_current_baseline.thread_count() -\n-          _early_baseline.thread_count());\n+      const ssize_t thread_count_diff = counter_diff(_current_baseline.thread_count(), _early_baseline.thread_count());\n@@ -577,1 +592,1 @@\n-        out->print(\" %+d\", thread_count_diff);\n+        out->print(\" \" SSIZE_PLUS_FORMAT, thread_count_diff);\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":32,"deletions":17,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+  \/\/ Helper functions\n+  \/\/ Calculate total reserved and committed amount\n+  static size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+  static size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+\n@@ -76,5 +81,0 @@\n-  \/\/ Helper functions\n-  \/\/ Calculate total reserved and committed amount\n-  size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-  size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-\n","filename":"src\/hotspot\/share\/services\/memReporter.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -112,1 +112,5 @@\n-    return MallocTracker::record_free(memblock);\n+    return MallocTracker::record_free_block(memblock);\n+  }\n+  static inline void deaccount(MallocHeader::FreeInfo free_info) {\n+    assert(enabled(), \"NMT must be enabled\");\n+    MallocTracker::deaccount(free_info);\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/threadCritical.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"services\/threadStackTracker.hpp\"\n+#include \"services\/virtualMemoryTracker.hpp\"\n+\n+\/\/ Enabled all options for snapshot.\n+const NMTUsageOptions NMTUsage::OptionsAll = { true, true, true };\n+\/\/ Skip expensive thread stacks when refreshing usage.\n+const NMTUsageOptions NMTUsage::OptionsNoTS = { false, true, true };\n+\n+NMTUsage::NMTUsage(NMTUsageOptions options) :\n+    _malloc_by_type(),\n+    _malloc_total(),\n+    _vm_by_type(),\n+    _vm_total(),\n+    _usage_options(options) { }\n+\n+void NMTUsage::walk_thread_stacks() {\n+  \/\/ If backed by virtual memory, snapping the thread stacks involves walking\n+  \/\/ them to to figure out how much memory is committed if they are backed by\n+  \/\/ virtual memory. This needs ot happen before we take the snapshot of the\n+  \/\/ virtual memory since it will update this information.\n+  if (ThreadStackTracker::track_as_vm()) {\n+    VirtualMemoryTracker::snapshot_thread_stacks();\n+  }\n+}\n+\n+void NMTUsage::update_malloc_usage() {\n+  \/\/ Thread critical needed keep values in sync, total area size\n+  \/\/ is deducted from mtChunk in the end to give correct values.\n+  ThreadCritical tc;\n+  const MallocMemorySnapshot* ms = MallocMemorySummary::as_snapshot();\n+\n+  size_t total_arena_size = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    const MallocMemory* mm = ms->by_type(flag);\n+    _malloc_by_type[i] = mm->malloc_size() + mm->arena_size();\n+    total_arena_size +=  mm->arena_size();\n+  }\n+\n+  \/\/ Total malloc size.\n+  _malloc_total = ms->total();\n+\n+  \/\/ Adjustment due to mtChunk double counting.\n+  _malloc_by_type[NMTUtil::flag_to_index(mtChunk)] -= total_arena_size;\n+  _malloc_total -= total_arena_size;\n+\n+  \/\/ Adjust mtNMT to include malloc overhead.\n+  _malloc_by_type[NMTUtil::flag_to_index(mtNMT)] += ms->malloc_overhead();\n+}\n+\n+void NMTUsage::update_vm_usage() {\n+  const VirtualMemorySnapshot* vms = VirtualMemorySummary::as_snapshot();\n+\n+  \/\/ Reset total to allow recalculation.\n+  _vm_total.committed = 0;\n+  _vm_total.reserved = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    const VirtualMemory* vm = vms->by_type(flag);\n+\n+    _vm_by_type[i].reserved = vm->reserved();\n+    _vm_by_type[i].committed = vm->committed();\n+    _vm_total.reserved += vm->reserved();\n+    _vm_total.committed += vm->committed();\n+  }\n+}\n+\n+void NMTUsage::refresh() {\n+  if (_usage_options.include_malloc) {\n+    update_malloc_usage();\n+  }\n+\n+  if (_usage_options.include_vm) {\n+    \/\/ Thread stacks only makes sense if virtual memory\n+    \/\/ is also included. It must be executed before the\n+    \/\/ over all usage is calculated.\n+    if (_usage_options.update_thread_stacks) {\n+      walk_thread_stacks();\n+    }\n+    update_vm_usage();\n+  }\n+}\n+\n+size_t NMTUsage::total_reserved() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t NMTUsage::total_committed() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t NMTUsage::reserved(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_by_type[index] + _vm_by_type[index].reserved;\n+}\n+\n+size_t NMTUsage::committed(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_by_type[index] + _vm_by_type[index].committed;\n+}\n","filename":"src\/hotspot\/share\/services\/nmtUsage.cpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_NMTUSAGE_HPP\n+#define SHARE_SERVICES_NMTUSAGE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+struct NMTUsagePair {\n+  size_t reserved;\n+  size_t committed;\n+};\n+\n+struct NMTUsageOptions {\n+  bool update_thread_stacks;\n+  bool include_malloc;\n+  bool include_vm;\n+};\n+\n+class NMTUsage : public CHeapObj<mtNMT> {\n+private:\n+  size_t _malloc_by_type[mt_number_of_types];\n+  size_t _malloc_total;\n+  NMTUsagePair _vm_by_type[mt_number_of_types];\n+  NMTUsagePair _vm_total;\n+\n+  NMTUsageOptions _usage_options;\n+\n+  void walk_thread_stacks();\n+  void update_malloc_usage();\n+  void update_vm_usage();\n+\n+public:\n+  static const NMTUsageOptions OptionsAll;\n+  static const NMTUsageOptions OptionsNoTS;\n+\n+  NMTUsage(NMTUsageOptions options = OptionsAll);\n+  void refresh();\n+\n+  size_t total_reserved() const;\n+  size_t total_committed() const;\n+  size_t reserved(MEMFLAGS flag) const;\n+  size_t committed(MEMFLAGS flag) const;\n+};\n+\n+#endif \/\/ SHARE_SERVICES_NMTUSAGE_HPP\n","filename":"src\/hotspot\/share\/services\/nmtUsage.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -100,0 +100,5 @@\n+  inline const VirtualMemory* by_type(MEMFLAGS flag) const {\n+    int index = NMTUtil::flag_to_index(flag);\n+    return &_virtual_memory[index];\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-  sprintf(buffer, \"printnm: \" INTPTR_FORMAT, p);\n+  os::snprintf_checked(buffer, sizeof(buffer), \"printnm: \" INTPTR_FORMAT, p);\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,2 +163,8 @@\n-  if (h_exception->is_a(vmClasses::OutOfMemoryError_klass())) {\n-    count_out_of_memory_exceptions(h_exception);\n+  if (h_exception->is_a(vmClasses::VirtualMachineError_klass())) {\n+    \/\/ Remove the ScopedValue bindings in case we got a virtual machine\n+    \/\/ Error while we were trying to manipulate ScopedValue bindings.\n+    thread->clear_scopedValueBindings();\n+\n+    if (h_exception->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      count_out_of_memory_exceptions(h_exception);\n+    }\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+#define SSIZE_PLUS_FORMAT        \"%+\"         PRIdPTR\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,0 +132,10 @@\n+#ifndef SSIZE_MAX\n+#ifdef _LP64\n+#define SSIZE_MIN LLONG_MIN\n+#define SSIZE_MAX LLONG_MAX\n+#else\n+#define SSIZE_MIN INT_MIN\n+#define SSIZE_MAX INT_MAX\n+#endif\n+#endif \/\/ SSIZE_MAX missing\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+  friend class JfrPeriodicEventSet;\n","filename":"src\/hotspot\/share\/utilities\/ticks.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-\n+#include \"runtime\/os.hpp\"\n@@ -227,1 +227,1 @@\n-      sprintf(p, \"\\\\u%04x\", c);\n+      os::snprintf_checked(p, 7, \"\\\\u%04x\", c);  \/\/ counting terminating zero in\n@@ -521,1 +521,1 @@\n-      sprintf(p, \"\\\\u%04x\", c);\n+      os::snprintf_checked(p, 7, \"\\\\u%04x\", c);\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -229,9 +229,7 @@\n-            if (modifiers.length > 0) {\n-                for (WatchEvent.Modifier modifier: modifiers) {\n-                    if (modifier == null)\n-                        return new NullPointerException();\n-                    if (!ExtendedOptions.SENSITIVITY_HIGH.matches(modifier) &&\n-                            !ExtendedOptions.SENSITIVITY_MEDIUM.matches(modifier) &&\n-                            !ExtendedOptions.SENSITIVITY_LOW.matches(modifier)) {\n-                        return new UnsupportedOperationException(\"Modifier not supported\");\n-                    }\n+            for (WatchEvent.Modifier modifier : modifiers) {\n+                if (modifier == null)\n+                    return new NullPointerException();\n+                if (!ExtendedOptions.SENSITIVITY_HIGH.matches(modifier) &&\n+                        !ExtendedOptions.SENSITIVITY_MEDIUM.matches(modifier) &&\n+                        !ExtendedOptions.SENSITIVITY_LOW.matches(modifier)) {\n+                    return new UnsupportedOperationException(\"Modifier not supported\");\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxWatchService.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -32,0 +34,1 @@\n+import jdk.internal.io.JdkConsoleProvider;\n@@ -48,1 +51,1 @@\n- * example by a background job scheduler, then it will typically not\n+ * example by a background job scheduler, then it may not\n@@ -96,1 +99,1 @@\n-public final class Console implements Flushable\n+public class Console implements Flushable\n@@ -595,0 +598,2 @@\n+        cons = instantiateConsole(istty);\n+\n@@ -598,10 +603,1 @@\n-                if (istty) {\n-                    if (cons == null)\n-                        cons = new Console();\n-                    return cons;\n-                }\n-                return null;\n-            }\n-\n-            public Charset charset() {\n-                return CHARSET;\n+                return cons;\n@@ -611,1 +607,25 @@\n-    private static Console cons;\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Console instantiateConsole(boolean istty) {\n+        try {\n+            \/\/ Try loading providers\n+            PrivilegedAction<Console> pa = () -> {\n+                var consModName = System.getProperty(\"jdk.console\",\n+                        JdkConsoleProvider.DEFAULT_PROVIDER_MODULE_NAME);\n+                return ServiceLoader.load(ModuleLayer.boot(), JdkConsoleProvider.class).stream()\n+                        .map(ServiceLoader.Provider::get)\n+                        .filter(jcp -> consModName.equals(jcp.getClass().getModule().getName()))\n+                        .map(jcp -> jcp.console(istty, CHARSET))\n+                        .filter(Objects::nonNull)\n+                        .findAny()\n+                        .map(jc -> (Console) new ProxyingConsole(jc))\n+                        .orElse(istty ? new Console() : null);\n+            };\n+            return AccessController.doPrivileged(pa);\n+        } catch (ServiceConfigurationError ignore) {\n+            \/\/ default to built-in Console\n+            return istty ? new Console() : null;\n+        }\n+    }\n+\n+    private static final Console cons;\n@@ -613,1 +633,2 @@\n-    private Console() {\n+\n+    Console() {\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -211,0 +211,9 @@\n+    \/* Package private constructor, using the specified lock\n+     * for synchronization.\n+     *\/\n+    PrintWriter(Writer out, Object lock) {\n+        super(lock);\n+        this.out = out;\n+        this.autoFlush = false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintWriter.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.nio.charset.Charset;\n+import jdk.internal.io.JdkConsole;\n+\n+\/**\n+ * Console implementation for internal use. Custom Console delegate may be\n+ * provided with jdk.internal.io.JdkConsoleProvider.\n+ *\/\n+final class ProxyingConsole extends Console {\n+    private final JdkConsole delegate;\n+    private final Object readLock;\n+    private final Object writeLock;\n+    private final Reader reader;\n+    private final PrintWriter printWriter;\n+\n+    ProxyingConsole(JdkConsole delegate) {\n+        this.delegate = delegate;\n+        readLock = new Object();\n+        writeLock = new Object();\n+        reader = new WrappingReader(delegate.reader(), readLock);\n+        printWriter = new WrappingWriter(delegate.writer(), writeLock);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public PrintWriter writer() {\n+        return printWriter;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Reader reader() {\n+        return reader;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console format(String fmt, Object ... args) {\n+        synchronized (writeLock) {\n+            delegate.format(fmt, args);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console printf(String format, Object ... args) {\n+        synchronized (writeLock) {\n+            delegate.printf(format, args);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public String readLine(String fmt, Object ... args) {\n+        synchronized (writeLock) {\n+            synchronized (readLock) {\n+                return delegate.readLine(fmt, args);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public String readLine() {\n+        synchronized (readLock) {\n+            return delegate.readLine();\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public char[] readPassword(String fmt, Object ... args) {\n+        synchronized (writeLock) {\n+            synchronized (readLock) {\n+                return delegate.readPassword(fmt, args);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public char[] readPassword() {\n+        synchronized (readLock) {\n+            return delegate.readPassword();\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public void flush() {\n+        delegate.flush();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Charset charset() {\n+        return delegate.charset();\n+    }\n+\n+    private static class WrappingReader extends Reader {\n+        private final Reader r;\n+        private final Object lock;\n+\n+        WrappingReader(Reader r, Object lock) {\n+            super(lock);\n+            this.r = r;\n+            this.lock = lock;\n+        }\n+\n+        @Override\n+        public int read(char[] cbuf, int off, int len) throws IOException {\n+            synchronized (lock) {\n+                return r.read(cbuf, off, len);\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ no-op, per Console's spec\n+        }\n+    }\n+\n+    private static class WrappingWriter extends PrintWriter {\n+        private final PrintWriter pw;\n+        private final Object lock;\n+\n+        public WrappingWriter(PrintWriter pw, Object lock) {\n+            super(pw, lock);\n+            this.pw = pw;\n+            this.lock = lock;\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) {\n+            synchronized (lock) {\n+                pw.write(cbuf, off, len);\n+            }\n+        }\n+\n+        @Override\n+        public void flush() {\n+            pw.flush();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ no-op, per Console's spec\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ProxyingConsole.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -64,3 +65,9 @@\n-    private FileDescriptor fd;\n-    private volatile FileChannel channel;\n-    private boolean rw;\n+    private static final int O_RDONLY = 1;\n+    private static final int O_RDWR =   2;\n+    private static final int O_SYNC =   4;\n+    private static final int O_DSYNC =  8;\n+    private static final int O_TEMPORARY =  16;\n+\n+    private final FileDescriptor fd;\n+\n+    private final boolean rw;\n@@ -76,0 +83,1 @@\n+    private volatile FileChannel channel;\n@@ -78,6 +86,0 @@\n-    private static final int O_RDONLY = 1;\n-    private static final int O_RDWR =   2;\n-    private static final int O_SYNC =   4;\n-    private static final int O_DSYNC =  8;\n-    private static final int O_TEMPORARY =  16;\n-\n@@ -116,1 +118,1 @@\n-     * @throws      SecurityException   if a security manager exists and its\n+     * @throws     SecurityException   if a security manager exists and its\n@@ -222,0 +224,2 @@\n+\n+        boolean rw = false;\n@@ -236,0 +240,2 @@\n+        this.rw = rw;\n+\n@@ -273,4 +279,1 @@\n-        if (fd != null) {\n-            return fd;\n-        }\n-        throw new IOException();\n+        return fd;\n@@ -1011,9 +1014,7 @@\n-            case -1:\n-            case '\\n':\n-                eol = true;\n-                break;\n-            case '\\r':\n-                eol = true;\n-                long cur = getFilePointer();\n-                if ((read()) != '\\n') {\n-                    seek(cur);\n+                case -1, '\\n' -> eol = true;\n+                case '\\r'     -> {\n+                    eol = true;\n+                    long cur = getFilePointer();\n+                    if ((read()) != '\\n') {\n+                        seek(cur);\n+                    }\n@@ -1021,4 +1022,1 @@\n-                break;\n-            default:\n-                input.append((char)c);\n-                break;\n+                default -> input.append((char) c);\n@@ -1248,1 +1246,1 @@\n-            \/\/ is only implemented\/supported on windows.\n+            \/\/ is only implemented\/supported on Windows.\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":26,"deletions":28,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -238,0 +238,15 @@\n+\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        Objects.requireNonNull(out, \"out\");\n+        if (getClass() == SequenceInputStream.class) {\n+            long c = 0;\n+            while (in != null) {\n+                c += in.transferTo(out);\n+                nextStream();\n+            }\n+            return c;\n+        } else {\n+            return super.transferTo(out);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/SequenceInputStream.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import static java.lang.constant.ConstantDescs.CD_int;\n@@ -9378,1 +9377,1 @@\n-        if (index >= limit || limit < 0 || limit > a.length) {\n+        if (index >= limit || index < 0 || limit > a.length) {\n@@ -9481,1 +9480,1 @@\n-        if (index <= start || start < 0 || start >= a.length) {\n+        if (index <= start || start < 0 || index > a.length) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,4 +92,8 @@\n- * Java code. This includes shutdown hooks as well as daemon and non-daemon threads. The\n- * threads' current methods do not complete normally or abruptly; no {@code finally} clause\n- * of any method is executed, nor is any {@linkplain Thread.UncaughtExceptionHandler\n- * uncaught exception handler}.\n+ * Java code. This includes shutdown hooks as well as daemon and non-daemon threads.\n+ * This means, for example, that:\n+ * <ul>\n+ * <li>threads' current methods do not complete normally or abruptly;<\/li>\n+ * <li>{@code finally} clauses are not executed;<\/li>\n+ * <li>{@linkplain Thread.UncaughtExceptionHandler uncaught exception handlers} are not run; and<\/li>\n+ * <li>resources opened with try-with-resources are not {@linkplain AutoCloseable closed};<\/li>\n+ * <\/ul>\n@@ -281,1 +285,2 @@\n-     * data corruption.\n+     * data corruption. See the <a href=\"#termination\">termination<\/a> section above\n+     * for other possible consequences of halting the Java Virtual Machine.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runtime.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -191,0 +192,3 @@\n+    \/\/ Holder for the initial value of `in`, set within `initPhase1()`.\n+    private static InputStream initialIn;\n+\n@@ -2176,1 +2180,2 @@\n-        setIn0(new BufferedInputStream(fdIn));\n+        initialIn = new BufferedInputStream(fdIn);\n+        setIn0(initialIn);\n@@ -2487,0 +2492,4 @@\n+            public InputStream initialSystemIn() {\n+                return initialIn;\n+            }\n+\n@@ -2581,2 +2590,10 @@\n-            public Object[] extentLocalCache() {\n-                return Thread.extentLocalCache();\n+            public Object[] scopedValueCache() {\n+                return Thread.scopedValueCache();\n+            }\n+\n+            public void setScopedValueCache(Object[] cache) {\n+                Thread.setScopedValueCache(cache);\n+            }\n+\n+            public Object scopedValueBindings() {\n+                return Thread.scopedValueBindings();\n@@ -2585,2 +2602,2 @@\n-            public void setExtentLocalCache(Object[] cache) {\n-                Thread.setExtentLocalCache(cache);\n+            public Object findScopedValueBindings() {\n+                return Thread.findScopedValueBindings();\n@@ -2589,2 +2606,2 @@\n-            public Object extentLocalBindings() {\n-                return Thread.extentLocalBindings();\n+            public void setScopedValueBindings(Object bindings) {\n+                Thread.setScopedValueBindings(bindings);\n@@ -2593,2 +2610,3 @@\n-            public void setExtentLocalBindings(Object bindings) {\n-                Thread.setExtentLocalBindings(bindings);\n+            @ForceInline\n+            public void ensureMaterializedForStackWalk(Object value) {\n+                Thread.ensureMaterializedForStackWalk(value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.ref.Reference;\n@@ -52,1 +53,1 @@\n-import jdk.internal.vm.ExtentLocalContainer;\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -55,0 +56,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n@@ -282,1 +285,1 @@\n-     * Extent locals binding are maintained by the ExtentLocal class.\n+     * Scoped value bindings are maintained by the ScopedValue class.\n@@ -284,1 +287,1 @@\n-    private Object extentLocalBindings;\n+    private Object scopedValueBindings;\n@@ -286,2 +289,6 @@\n-    static Object extentLocalBindings() {\n-        return currentThread().extentLocalBindings;\n+    \/\/ Special value to indicate this is a newly-created Thread\n+    \/\/ Note that his must match the declaration in ScopedValue.\n+    private static final Object NEW_THREAD_BINDINGS = Thread.class;\n+\n+    static Object scopedValueBindings() {\n+        return currentThread().scopedValueBindings;\n@@ -290,2 +297,2 @@\n-    static void setExtentLocalBindings(Object bindings) {\n-        currentThread().extentLocalBindings = bindings;\n+    static void setScopedValueBindings(Object bindings) {\n+        currentThread().scopedValueBindings = bindings;\n@@ -295,1 +302,7 @@\n-     * Inherit the extent-local bindings from the given container.\n+     * Search the stack for the most recent scoped-value bindings.\n+     *\/\n+    @IntrinsicCandidate\n+    static native Object findScopedValueBindings();\n+\n+    \/**\n+     * Inherit the scoped-value bindings from the given container.\n@@ -298,2 +311,2 @@\n-    void inheritExtentLocalBindings(ThreadContainer container) {\n-        ExtentLocalContainer.BindingsSnapshot snapshot;\n+    void inheritScopedValueBindings(ThreadContainer container) {\n+        ScopedValueContainer.BindingsSnapshot snapshot;\n@@ -301,1 +314,1 @@\n-                && (snapshot = container.extentLocalBindings()) != null) {\n+                && (snapshot = container.scopedValueBindings()) != null) {\n@@ -304,3 +317,3 @@\n-            Object bindings = snapshot.extentLocalBindings();\n-            if (currentThread().extentLocalBindings != bindings) {\n-                StructureViolationExceptions.throwException(\"Extent local bindings have changed\");\n+            Object bindings = snapshot.scopedValueBindings();\n+            if (currentThread().scopedValueBindings != bindings) {\n+                StructureViolationExceptions.throwException(\"Scoped value bindings have changed\");\n@@ -309,1 +322,1 @@\n-            this.extentLocalBindings = bindings;\n+            this.scopedValueBindings = bindings;\n@@ -396,1 +409,4 @@\n-    \/\/ ExtentLocal support:\n+    \/\/ ScopedValue support:\n+\n+    @IntrinsicCandidate\n+    static native Object[] scopedValueCache();\n@@ -399,1 +415,1 @@\n-    static native Object[] extentLocalCache();\n+    static native void setScopedValueCache(Object[] cache);\n@@ -402,1 +418,1 @@\n-    static native void setExtentLocalCache(Object[] cache);\n+    static native void ensureMaterializedForStackWalk(Object o);\n@@ -731,0 +747,4 @@\n+\n+        \/\/ Special value to indicate this is a newly-created Thread\n+        \/\/ Note that his must match the declaration in ScopedValue.\n+        this.scopedValueBindings = NEW_THREAD_BINDINGS;\n@@ -770,0 +790,3 @@\n+        \/\/ Special value to indicate this is a newly-created Thread\n+        this.scopedValueBindings = NEW_THREAD_BINDINGS;\n+\n@@ -1567,2 +1590,2 @@\n-                \/\/ extent locals may be inherited\n-                inheritExtentLocalBindings(container);\n+                \/\/ scoped values may be inherited\n+                inheritScopedValueBindings(container);\n@@ -1599,1 +1622,2 @@\n-            task.run();\n+            Object bindings = scopedValueBindings();\n+            runWith(bindings, task);\n@@ -1603,0 +1627,13 @@\n+    \/**\n+     * The VM recognizes this method as special, so any changes to the\n+     * name or signature require corresponding changes in\n+     * JVM_FindScopedValueBindings().\n+     *\/\n+    @Hidden\n+    @ForceInline\n+    private void runWith(Object bindings, Runnable op) {\n+        ensureMaterializedForStackWalk(bindings);\n+        op.run();\n+        Reference.reachabilityFence(bindings);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":58,"deletions":21,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -703,17 +703,0 @@\n-    \/**\n-     * Does nothing.\n-     *\n-     * @return false\n-     *\n-     * @param b ignored\n-     *\n-     * @deprecated This method was originally intended for controlling suspension\n-     *             in low memory conditions. It was never specified.\n-     *\n-     * @since   1.1\n-     *\/\n-    @Deprecated(since=\"1.2\", forRemoval=true)\n-    public boolean allowThreadSuspension(boolean b) {\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadGroup.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.ref.Reference;\n@@ -56,0 +57,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n@@ -224,2 +227,4 @@\n-     * Submits the runContinuation task to the scheduler.\n-     * @param {@code lazySubmit} to lazy submit\n+     * Submits the runContinuation task to the scheduler. For the default scheduler,\n+     * and calling it on a worker thread, the task will be pushed to the local queue,\n+     * otherwise it will be pushed to a submission queue.\n+     *\n@@ -227,1 +232,0 @@\n-     * @see ForkJoinPool#lazySubmit(ForkJoinTask)\n@@ -229,1 +233,1 @@\n-    private void submitRunContinuation(boolean lazySubmit) {\n+    private void submitRunContinuation() {\n@@ -231,5 +235,1 @@\n-            if (lazySubmit && scheduler instanceof ForkJoinPool pool) {\n-                pool.lazySubmit(ForkJoinTask.adapt(runContinuation));\n-            } else {\n-                scheduler.execute(runContinuation);\n-            }\n+            scheduler.execute(runContinuation);\n@@ -237,7 +237,1 @@\n-            \/\/ record event\n-            var event = new VirtualThreadSubmitFailedEvent();\n-            if (event.isEnabled()) {\n-                event.javaThreadId = threadId();\n-                event.exceptionMessage = ree.getMessage();\n-                event.commit();\n-            }\n+            submitFailed(ree);\n@@ -249,1 +243,1 @@\n-     * Submits the runContinuation task to the scheduler.\n+     * Submits the runContinuation task to the scheduler with a lazy submit.\n@@ -251,0 +245,1 @@\n+     * @see ForkJoinPool#lazySubmit(ForkJoinTask)\n@@ -252,2 +247,7 @@\n-    private void submitRunContinuation() {\n-        submitRunContinuation(false);\n+    private void lazySubmitRunContinuation(ForkJoinPool pool) {\n+        try {\n+            pool.lazySubmit(ForkJoinTask.adapt(runContinuation));\n+        } catch (RejectedExecutionException ree) {\n+            submitFailed(ree);\n+            throw ree;\n+        }\n@@ -257,2 +257,1 @@\n-     * Submits the runContinuation task to the scheduler and without signalling\n-     * any threads if possible.\n+     * Submits the runContinuation task to the scheduler as an external submit.\n@@ -260,0 +259,13 @@\n+     * @see ForkJoinPool#externalSubmit(ForkJoinTask)\n+     *\/\n+    private void externalSubmitRunContinuation(ForkJoinPool pool) {\n+        try {\n+            pool.externalSubmit(ForkJoinTask.adapt(runContinuation));\n+        } catch (RejectedExecutionException ree) {\n+            submitFailed(ree);\n+            throw ree;\n+        }\n+    }\n+\n+    \/**\n+     * If enabled, emits a JFR VirtualThreadSubmitFailedEvent.\n@@ -261,2 +273,7 @@\n-    private void lazySubmitRunContinuation() {\n-        submitRunContinuation(true);\n+    private void submitFailed(RejectedExecutionException ree) {\n+        var event = new VirtualThreadSubmitFailedEvent();\n+        if (event.isEnabled()) {\n+            event.javaThreadId = threadId();\n+            event.exceptionMessage = ree.getMessage();\n+            event.commit();\n+        }\n@@ -286,0 +303,1 @@\n+        Object bindings = scopedValueBindings();\n@@ -287,1 +305,1 @@\n-            task.run();\n+            runWith(bindings, task);\n@@ -292,1 +310,0 @@\n-\n@@ -314,0 +331,8 @@\n+    @Hidden\n+    @ForceInline\n+    private void runWith(Object bindings, Runnable op) {\n+        ensureMaterializedForStackWalk(bindings);\n+        op.run();\n+        Reference.reachabilityFence(bindings);\n+    }\n+\n@@ -429,1 +454,6 @@\n-                lazySubmitRunContinuation();\n+                if (currentThread() instanceof CarrierThread ct) {\n+                    lazySubmitRunContinuation(ct.getPool());\n+                } else {\n+                    submitRunContinuation();\n+                }\n+\n@@ -437,2 +467,6 @@\n-            \/\/ lazy submit to continue on the current thread as carrier if possible\n-            lazySubmitRunContinuation();\n+            \/\/ external submit if there are no tasks in the local task queue\n+            if (currentThread() instanceof CarrierThread ct && ct.getQueuedTaskCount() == 0) {\n+                externalSubmitRunContinuation(ct.getPool());\n+            } else {\n+                submitRunContinuation();\n+            }\n@@ -491,2 +525,2 @@\n-            \/\/ extent locals may be inherited\n-            inheritExtentLocalBindings(container);\n+            \/\/ scoped values may be inherited\n+            inheritScopedValueBindings(container);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":64,"deletions":30,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import sun.invoke.util.ValueConversions;\n@@ -36,3 +35,0 @@\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n@@ -64,16 +60,0 @@\n-    static BoundMethodHandle bindSingle(MethodType type, LambdaForm form, BasicType xtype, Object x) {\n-        \/\/ for some type signatures, there exist pre-defined concrete BMH classes\n-        try {\n-            return switch (xtype) {\n-                case L_TYPE -> bindSingle(type, form, x);  \/\/ Use known fast path.\n-                case I_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n-                case J_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n-                case F_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n-                case D_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n-                default -> throw newInternalError(\"unexpected xtype: \" + xtype);\n-            };\n-        } catch (Throwable t) {\n-            throw uncaughtException(t);\n-        }\n-    }\n-\n@@ -359,1 +339,2 @@\n-            assert(args.size() == transform.getMethodType().parameterCount());\n+            MethodType tType = transform.getMethodType();\n+            assert(args.size() == tType.parameterCount());\n@@ -363,1 +344,1 @@\n-                assert(transform.getMethodType().parameterCount() == MH_AND_LF);\n+                assert(tType.parameterCount() == MH_AND_LF);\n@@ -365,1 +346,1 @@\n-                assert(transform.getMethodType().parameterCount() == MH_AND_LF+1);\n+                assert(tType.parameterCount() == MH_AND_LF+1);\n@@ -367,1 +348,1 @@\n-                assert(transform.getParameterTypes()[MH_AND_LF] == type.basicTypeClass());\n+                assert(tType.parameterType(MH_AND_LF) == type.basicTypeClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+            MethodType tmt = tm.getMethodType();\n@@ -333,1 +334,1 @@\n-            Collections.addAll(args, tm.getParameterTypes());\n+            Collections.addAll(args, tmt.ptypes());\n@@ -336,1 +337,1 @@\n-            return MethodType.methodType(tm.getReturnType(), helperArgs);\n+            return MethodType.methodType(tmt.returnType(), helperArgs);\n@@ -435,1 +436,1 @@\n-                    final Constructor<T> con = reflectConstructor(topc, baseConstructorType().parameterArray());\n+                    final Constructor<T> con = reflectConstructor(topc, baseConstructorType().ptypes());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-        return member.getReturnType().cast(obj);\n+        return member.getMethodType().returnType().cast(obj);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-        for (Class<?> ptype : mtype.parameterArray())\n+        for (Class<?> ptype : mtype.ptypes())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -367,10 +367,0 @@\n-    private static Name[] buildNames(Name[] formals, Name[] temps, Name result) {\n-        int arity = formals.length;\n-        int length = arity + temps.length + (result == null ? 0 : 1);\n-        Name[] names = Arrays.copyOf(formals, length);\n-        System.arraycopy(temps, 0, names, arity, temps.length);\n-        if (result != null)\n-            names[length - 1] = result;\n-        return names;\n-    }\n-\n@@ -1341,0 +1331,2 @@\n+        private static final Object[] EMPTY_ARGS = new Object[0];\n+\n@@ -1347,1 +1339,1 @@\n-            assert(this.index == index);\n+            assert(this.index == index && typesMatch(function, this.arguments));\n@@ -1368,0 +1360,9 @@\n+        Name(NamedFunction function) {\n+            this(-1, function.returnType(), function, EMPTY_ARGS);\n+        }\n+        Name(NamedFunction function, Object arg) {\n+            this(-1, function.returnType(), function, new Object[] { arg });\n+        }\n+        Name(NamedFunction function, Object arg0, Object arg1) {\n+            this(-1, function.returnType(), function, new Object[] { arg0, arg1 });\n+        }\n@@ -1369,2 +1370,1 @@\n-            this(-1, function.returnType(), function, arguments = Arrays.copyOf(arguments, arguments.length, Object[].class));\n-            assert(typesMatch(function, arguments));\n+            this(-1, function.returnType(), function, Arrays.copyOf(arguments, arguments.length, Object[].class));\n@@ -1537,0 +1537,4 @@\n+            if (arguments == null) {\n+                assert(function == null);\n+                return true;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import sun.invoke.util.BytecodeDescriptor;\n@@ -36,4 +35,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n@@ -77,1 +72,1 @@\n-};\n+}\n@@ -201,10 +196,0 @@\n-    \/** Utility method producing the parameter types of the method type. *\/\n-    public Class<?>[] getParameterTypes() {\n-        return getMethodType().parameterArray();\n-    }\n-\n-    \/** Utility method producing the return type of the method type. *\/\n-    public Class<?> getReturnType() {\n-        return getMethodType().returnType();\n-    }\n-\n@@ -252,16 +237,0 @@\n-    \/** Utility method to produce the signature of this member,\n-     *  used within the class file format to describe its type.\n-     *\/\n-    public String getSignature() {\n-        if (type == null) {\n-            expandFromVM();\n-            if (type == null) {\n-                return null;\n-            }\n-        }\n-        if (isInvocable())\n-            return BytecodeDescriptor.unparse(getMethodType());\n-        else\n-            return BytecodeDescriptor.unparse(getFieldType());\n-    }\n-\n@@ -359,2 +328,1 @@\n-        assert(getReferenceKind() == oldKind);\n-        assert(MethodHandleNatives.refKindIsValid(refKind));\n+        assert(getReferenceKind() == oldKind && MethodHandleNatives.refKindIsValid(refKind));\n@@ -365,2 +333,2 @@\n-    private boolean testFlags(int mask, int value) {\n-        return (flags & mask) == value;\n+    private boolean matchingFlagsSet(int mask, int flags) {\n+        return (this.flags & mask) == flags;\n@@ -368,2 +336,2 @@\n-    private boolean testAllFlags(int mask) {\n-        return testFlags(mask, mask);\n+    private boolean allFlagsSet(int flags) {\n+        return (this.flags & flags) == flags;\n@@ -371,2 +339,2 @@\n-    private boolean testAnyFlags(int mask) {\n-        return !testFlags(mask, 0);\n+    private boolean anyFlagSet(int flags) {\n+        return (this.flags & flags) != 0;\n@@ -380,2 +348,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == MethodHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == MethodHandle.class) {\n@@ -387,7 +354,4 @@\n-        switch (name) {\n-        case \"invoke\":\n-        case \"invokeExact\":\n-            return true;\n-        default:\n-            return false;\n-        }\n+        return switch (name) {\n+            case \"invoke\", \"invokeExact\" -> true;\n+            default -> false;\n+        };\n@@ -398,2 +362,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == VarHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == VarHandle.class) {\n@@ -460,1 +423,1 @@\n-        return testAllFlags(IS_METHOD | BRIDGE);\n+        return allFlagsSet(IS_METHOD | BRIDGE);\n@@ -464,1 +427,1 @@\n-        return testAllFlags(VARARGS) && isInvocable();\n+        return allFlagsSet(VARARGS) && isInvocable();\n@@ -468,1 +431,1 @@\n-        return testAllFlags(SYNTHETIC);\n+        return allFlagsSet(SYNTHETIC);\n@@ -488,2 +451,0 @@\n-    static final int IS_FIELD_OR_METHOD = IS_METHOD | IS_FIELD;\n-    static final int SEARCH_ALL_SUPERS = MN_SEARCH_SUPERCLASSES | MN_SEARCH_INTERFACES;\n@@ -493,5 +454,1 @@\n-        return testAnyFlags(IS_INVOCABLE);\n-    }\n-    \/** Utility method to query whether this member is a method, constructor, or field. *\/\n-    public boolean isFieldOrMethod() {\n-        return testAnyFlags(IS_FIELD_OR_METHOD);\n+        return anyFlagSet(IS_INVOCABLE);\n@@ -501,1 +458,1 @@\n-        return testAllFlags(IS_METHOD);\n+        return allFlagsSet(IS_METHOD);\n@@ -505,1 +462,1 @@\n-        return testAllFlags(IS_CONSTRUCTOR);\n+        return allFlagsSet(IS_CONSTRUCTOR);\n@@ -509,1 +466,1 @@\n-        return testAllFlags(IS_FIELD);\n+        return allFlagsSet(IS_FIELD);\n@@ -513,1 +470,1 @@\n-        return testAllFlags(IS_TYPE);\n+        return allFlagsSet(IS_TYPE);\n@@ -517,1 +474,1 @@\n-        return !testAnyFlags(ALL_ACCESS);\n+        return !anyFlagSet(ALL_ACCESS);\n@@ -521,1 +478,1 @@\n-        return testAllFlags(CALLER_SENSITIVE);\n+        return allFlagsSet(CALLER_SENSITIVE);\n@@ -524,7 +481,2 @@\n-    public boolean isTrustedFinalField() { return testAllFlags(TRUSTED_FINAL|IS_FIELD); }\n-\n-    \/** Utility method to query whether this member is accessible from a given lookup class. *\/\n-    public boolean isAccessibleFrom(Class<?> lookupClass) {\n-        int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);\n-        return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,\n-                                               lookupClass, null, mode);\n+    public boolean isTrustedFinalField() {\n+        return allFlagsSet(TRUSTED_FINAL | IS_FIELD);\n@@ -550,2 +502,1 @@\n-        assert(testAnyFlags(ALL_KINDS));\n-        assert(this.resolution == null);  \/\/ nobody should have touched this yet\n+        assert(anyFlagSet(ALL_KINDS) && this.resolution == null);  \/\/ nobody should have touched this yet\n@@ -571,3 +522,3 @@\n-        assert((flags & RECOGNIZED_MODIFIERS) == 0);\n-        assert((mods & ~RECOGNIZED_MODIFIERS) == 0);\n-        assert((refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n+        assert((flags & RECOGNIZED_MODIFIERS) == 0\n+                && (mods & ~RECOGNIZED_MODIFIERS) == 0\n+                && (refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n@@ -610,1 +561,1 @@\n-        assert(isResolved() && this.clazz != null);\n+        assert(isResolved());\n@@ -652,1 +603,0 @@\n-        byte normalVirtual = clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n@@ -654,9 +604,6 @@\n-        byte newRefKind = refKind;\n-        MemberName result = this;\n-        switch (refKind) {\n-        case REF_invokeInterface:\n-        case REF_invokeVirtual:\n-        case REF_invokeSpecial:\n-            newRefKind = normalVirtual;\n-            break;\n-        }\n+        byte newRefKind = switch (refKind) {\n+            case REF_invokeInterface,\n+                 REF_invokeVirtual,\n+                 REF_invokeSpecial -> clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n+            default -> refKind;\n+        };\n@@ -665,1 +612,1 @@\n-        result = clone().changeReferenceKind(newRefKind, refKind);\n+        MemberName result = clone().changeReferenceKind(newRefKind, refKind);\n@@ -685,0 +632,4 @@\n+    static {\n+        \/\/ the following MemberName constructor relies on these ranges matching up\n+        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n+    }\n@@ -693,1 +644,0 @@\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n@@ -706,7 +656,1 @@\n-    public MemberName asSetter() {\n-        byte refKind = getReferenceKind();\n-        assert(MethodHandleNatives.refKindIsGetter(refKind));\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n-        byte setterRefKind = (byte)(refKind + (REF_putField - REF_getField));\n-        return clone().changeReferenceKind(setterRefKind, refKind);\n-    }\n+\n@@ -847,5 +791,0 @@\n-    \/** Query whether this member name is resolved to a non-static, non-final method.\n-     *\/\n-    public boolean hasReceiverTypeDispatch() {\n-        return MethodHandleNatives.refKindDoesDispatch(getReferenceKind());\n-    }\n@@ -933,1 +872,1 @@\n-        message = message + \": \"+ toString();\n+        message = message + \": \" + this;\n@@ -968,1 +907,1 @@\n-        String message = message() + \": \"+ toString();\n+        String message = message() + \": \" + this;\n@@ -995,3 +934,1 @@\n-        static Factory INSTANCE = new Factory();\n-\n-        private static int ALLOWED_FLAGS = ALL_KINDS;\n+        static final Factory INSTANCE = new Factory();\n@@ -999,60 +936,0 @@\n-        \/\/\/ Queries\n-        List<MemberName> getMembers(Class<?> defc,\n-                String matchName, Object matchType,\n-                int matchFlags, Class<?> lookupClass) {\n-            matchFlags &= ALLOWED_FLAGS;\n-            String matchSig = null;\n-            if (matchType != null) {\n-                matchSig = BytecodeDescriptor.unparse(matchType);\n-                if (matchSig.startsWith(\"(\"))\n-                    matchFlags &= ~(ALL_KINDS & ~IS_INVOCABLE);\n-                else\n-                    matchFlags &= ~(ALL_KINDS & ~IS_FIELD);\n-            }\n-            final int BUF_MAX = 0x2000;\n-            int len1 = matchName == null ? 10 : matchType == null ? 4 : 1;\n-            MemberName[] buf = newMemberBuffer(len1);\n-            int totalCount = 0;\n-            ArrayList<MemberName[]> bufs = null;\n-            int bufCount = 0;\n-            for (;;) {\n-                bufCount = MethodHandleNatives.getMembers(defc,\n-                        matchName, matchSig, matchFlags,\n-                        lookupClass,\n-                        totalCount, buf);\n-                if (bufCount <= buf.length) {\n-                    if (bufCount < 0)  bufCount = 0;\n-                    totalCount += bufCount;\n-                    break;\n-                }\n-                \/\/ JVM returned to us with an intentional overflow!\n-                totalCount += buf.length;\n-                int excess = bufCount - buf.length;\n-                if (bufs == null)  bufs = new ArrayList<>(1);\n-                bufs.add(buf);\n-                int len2 = buf.length;\n-                len2 = Math.max(len2, excess);\n-                len2 = Math.max(len2, totalCount \/ 4);\n-                buf = newMemberBuffer(Math.min(BUF_MAX, len2));\n-            }\n-            ArrayList<MemberName> result = new ArrayList<>(totalCount);\n-            if (bufs != null) {\n-                for (MemberName[] buf0 : bufs) {\n-                    Collections.addAll(result, buf0);\n-                }\n-            }\n-            for (int i = 0; i < bufCount; i++) {\n-                result.add(buf[i]);\n-            }\n-            \/\/ Signature matching is not the same as type matching, since\n-            \/\/ one signature might correspond to several types.\n-            \/\/ So if matchType is a Class or MethodType, refilter the results.\n-            if (matchType != null && matchType != matchSig) {\n-                for (Iterator<MemberName> it = result.iterator(); it.hasNext();) {\n-                    MemberName m = it.next();\n-                    if (!matchType.equals(m.getType()))\n-                        it.remove();\n-                }\n-            }\n-            return result;\n-        }\n@@ -1134,64 +1011,0 @@\n-        \/** Return a list of all methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getMethods(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of matching methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned methods will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                String name, MethodType type, Class<?> lookupClass) {\n-            int matchFlags = IS_METHOD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all constructors defined by the given class.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getConstructors(Class<?> defc, Class<?> lookupClass) {\n-            return getMembers(defc, null, null, IS_CONSTRUCTOR, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getFields(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned fields will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                String name, Class<?> type, Class<?> lookupClass) {\n-            int matchFlags = IS_FIELD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all nested types defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getNestedTypes(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            int matchFlags = IS_TYPE | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, null, null, matchFlags, lookupClass);\n-        }\n-        private static MemberName[] newMemberBuffer(int length) {\n-            MemberName[] buf = new MemberName[length];\n-            \/\/ fill the buffer with dummy structs for the JVM to fill in\n-            for (int i = 0; i < length; i++)\n-                buf[i] = new MemberName();\n-            return buf;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":46,"deletions":233,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -1008,1 +1008,2 @@\n-        MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,\n+        MethodType type = MethodType.methodType(method.getMethodType().returnType(),\n+                                                UnsupportedOperationException.class,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        for (Class<?> pType : type.parameterArray()) {\n+        for (Class<?> pType : type.ptypes()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,11 @@\n-    RELEASE_20(64);\n+    RELEASE_20(64),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 21.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se21\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 21 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_21(65);\n@@ -280,1 +290,1 @@\n-        return RELEASE_20;\n+        return RELEASE_21;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    private Throwable target;\n+    private final Throwable target;\n@@ -59,0 +59,1 @@\n+        this.target = null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationTargetException.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * elements, and {@link #getExtension() getExtension} to obtain its extension.\n+ * elements.\n@@ -252,57 +252,0 @@\n-    \/**\n-     * Returns the file extension of this path's file name as a {@code String}.\n-     * The extension is derived from this {@code Path} by obtaining the\n-     * {@linkplain #getFileName file name element}, deriving its {@linkplain\n-     * #toString string representation}, and then extracting a substring\n-     * determined by the position of a period character ('.', U+002E FULL STOP)\n-     * within the file name string. If the file name element is {@code null},\n-     * or if the file name string does not contain a period character, or if\n-     * the only period in the file name string is its first character, then\n-     * the extension is {@code null}. Otherwise, the extension is the substring\n-     * after the last period in the file name string. If this last period is\n-     * also the last character in the file name string, then the  extension is\n-     * {@linkplain String#isEmpty empty}.\n-     *\n-     * @implSpec\n-     * The default implementation is equivalent for this path to:\n-     * <pre>{@code\n-     * int lastPeriod = fileName.lastIndexOf('.');\n-     * if (lastPeriod <= 0)\n-     *     return null;\n-     * return (lastPeriod == fileName.length() - 1)\n-     *     ? \"\"\n-     *     : fileName.substring(lastPeriod + 1);\n-     * }<\/pre>\n-     *\n-     * @return  the file name extension of this path, which might be the\n-     *          empty string, or {@code null} if no extension is found\n-     *\n-     * @since 20\n-     *\/\n-    default String getExtension() {\n-        Path fileName = getFileName();\n-        if (fileName == null)\n-            return null;\n-\n-        String fileNameString = fileName.toString();\n-        int length = fileNameString.length();\n-\n-        \/\/ An empty or unity length file name string has a null extension\n-        if (length > 1) {\n-            int lastPeriodIndex = fileNameString.lastIndexOf('.');\n-\n-            \/\/ Indeterminate if there is no period character or\n-            \/\/ only the first character is a period character\n-            if (lastPeriodIndex > 0) {\n-                if (lastPeriodIndex == length - 1) {\n-                    \/\/ empty string\n-                    return \"\";\n-                } else {\n-                    return fileNameString.substring(lastPeriodIndex + 1);\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":1,"deletions":58,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -414,7 +414,5 @@\n-        if (options.length > 0) {\n-            for (OpenOption opt: options) {\n-                \/\/ All OpenOption values except for APPEND and WRITE are allowed\n-                if (opt == StandardOpenOption.APPEND ||\n-                    opt == StandardOpenOption.WRITE)\n-                    throw new UnsupportedOperationException(\"'\" + opt + \"' not allowed\");\n-            }\n+        for (OpenOption opt : options) {\n+            \/\/ All OpenOption values except for APPEND and WRITE are allowed\n+            if (opt == StandardOpenOption.APPEND ||\n+                opt == StandardOpenOption.WRITE)\n+                throw new UnsupportedOperationException(\"'\" + opt + \"' not allowed\");\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/spi\/FileSystemProvider.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,5 +54,9 @@\n- * {@code System.in}:\n- * <blockquote><pre>{@code\n- *     Scanner sc = new Scanner(System.in);\n- *     int i = sc.nextInt();\n- * }<\/pre><\/blockquote>\n+ * the console.\n+ * {@snippet :\n+ *     var con = System.console();\n+ *     if (con != null) {\n+ *         \/\/ @link substring=\"reader()\" target=\"java.io.Console#reader()\" :\n+ *         Scanner sc = new Scanner(con.reader());\n+ *         int i = sc.nextInt();\n+ *     }\n+ * }\n@@ -62,1 +66,1 @@\n- * <blockquote><pre>{@code\n+ * {@snippet :\n@@ -67,1 +71,1 @@\n- * }<\/pre><\/blockquote>\n+ * }\n@@ -71,1 +75,1 @@\n- * <blockquote><pre>{@code\n+ * {@snippet :\n@@ -79,1 +83,1 @@\n- * }<\/pre><\/blockquote>\n+ * }\n@@ -91,1 +95,1 @@\n- * <blockquote><pre>{@code\n+ * {@snippet :\n@@ -99,1 +103,1 @@\n- * }<\/pre><\/blockquote>\n+ * }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Scanner.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-    \/\/ used by ExtentLocal\n+    \/\/ used by ScopedValue\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n- * schemes and whether SSL\/TLS\/DTLS servers should request or require client\n- * authentication, etc.\n+ * schemes, the key exchange named groups and whether SSL\/TLS\/DTLS servers\n+ * should request or require client authentication, etc.\n@@ -88,0 +88,1 @@\n+    private String[] namedGroups = null;\n@@ -813,0 +814,126 @@\n+\n+    \/**\n+     * Returns a prioritized array of key exchange named groups names that\n+     * can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of key exchange named groups are defined\n+     * in the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#named-groups\">\n+     * Named Groups<\/a> section of the Java Security Standard Algorithm\n+     * Names Specification.  Providers may support named groups not defined\n+     * in this list or may not use the recommended name for a certain named\n+     * group.\n+     * <p>\n+     * The set of named groups that will be used over the SSL\/TLS\/DTLS\n+     * connections is determined by the returned array of this method and the\n+     * underlying provider-specific default named groups.\n+     * <p>\n+     * If the returned array is {@code null}, then the underlying\n+     * provider-specific default named groups will be used over the\n+     * SSL\/TLS\/DTLS connections.\n+     * <p>\n+     * If the returned array is empty (zero-length), then the named group\n+     * negotiation mechanism is turned off for SSL\/TLS\/DTLS protocols, and\n+     * the connections may not be able to be established if the negotiation\n+     * mechanism is required by a certain SSL\/TLS\/DTLS protocol.  This\n+     * parameter will override the underlying provider-specific default\n+     * name groups.\n+     * <p>\n+     * If the returned array is not {@code null} or empty (zero-length),\n+     * then the named groups in the returned array will be used over\n+     * the SSL\/TLS\/DTLS connections.  This parameter will override the\n+     * underlying provider-specific default named groups.\n+     * <p>\n+     * This method returns the most recent value passed to\n+     * {@link #setNamedGroups} if that method has been called and otherwise\n+     * returns the default named groups for connection populated objects,\n+     * or {@code null} for pre-populated objects.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may return {@code null} instead of the default\n+     * named groups for connection populated objects.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @implNote\n+     * Note that applications may use the\n+     * {@systemProperty jdk.tls.namedGroups} system property with the SunJSSE\n+     * provider to override the provider-specific default named groups.\n+     *\n+     * @return an array of key exchange named group names {@code Strings} or\n+     *         {@code null} if none have been set.  For non-null returns, this\n+     *         method will return a new array each time it is invoked.  The\n+     *         array is ordered based on named group preference, with the first\n+     *         entry being the most preferred.  Providers should ignore unknown\n+     *         named group names while establishing the SSL\/TLS\/DTLS\n+     *         connections.\n+     * @see #setNamedGroups\n+     *\n+     * @since 20\n+     *\/\n+    public String[] getNamedGroups() {\n+        return clone(namedGroups);\n+    }\n+\n+    \/**\n+     * Sets the prioritized array of key exchange named groups names that\n+     * can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of key exchange named groups are defined in\n+     * the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#named-groups\">\n+     * Named Groups<\/a> section of the Java Security Standard Algorithm\n+     * Names Specification.  Providers may support named groups not defined\n+     * in this list or may not use the recommended name for a certain named\n+     * group.\n+     * <p>\n+     * The set of named groups that will be used over the SSL\/TLS\/DTLS\n+     * connections is determined by the input parameter {@code namedGroups}\n+     * array and the underlying provider-specific default named groups.\n+     * See {@link #getNamedGroups} for specific details on how the\n+     * parameters are used in SSL\/TLS\/DTLS connections.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may ignore the named groups that are set.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @param namedGroups an ordered array of key exchange named group names\n+     *        with the first entry being the most preferred, or {@code null}.\n+     *        This method will make a copy of this array. Providers should\n+     *        ignore unknown named group scheme names while establishing the\n+     *        SSL\/TLS\/DTLS connections.\n+     * @throws IllegalArgumentException if any element in the\n+     *        {@code namedGroups} array is a duplicate, {@code null} or\n+     *        {@linkplain String#isBlank() blank}.\n+     *\n+     * @see #getNamedGroups\n+     *\n+     * @since 20\n+     *\/\n+    public void setNamedGroups(String[] namedGroups) {\n+        String[] tempGroups = null;\n+\n+        if (namedGroups != null) {\n+            tempGroups = namedGroups.clone();\n+            Set<String> groupsSet = new HashSet<>();\n+            for (String namedGroup : tempGroups) {\n+                if (namedGroup == null || namedGroup.isBlank()) {\n+                    throw new IllegalArgumentException(\n+                        \"An element of namedGroups is null or blank\");\n+                }\n+\n+                if (groupsSet.contains(namedGroup)) {\n+                    throw new IllegalArgumentException(\n+                        \"Duplicate element of namedGroups: \" + namedGroup);\n+                }\n+                groupsSet.add(namedGroup);\n+            }\n+        }\n+\n+        this.namedGroups = tempGroups;\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLParameters.java","additions":129,"deletions":2,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.nio.charset.Charset;\n@@ -33,1 +32,0 @@\n-    Charset charset();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOAccess.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.InputStream;\n@@ -366,0 +367,6 @@\n+    \/**\n+     * Returns the initial `System.in` to determine if it is replaced\n+     * with `System.setIn(newIn)` method\n+     *\/\n+    InputStream initialSystemIn();\n+\n@@ -479,1 +486,1 @@\n-     * Returns the current thread's extent locals cache\n+     * Returns the current thread's scoped values cache\n@@ -481,1 +488,1 @@\n-    Object[] extentLocalCache();\n+    Object[] scopedValueCache();\n@@ -484,1 +491,1 @@\n-     * Sets the current thread's extent locals cache\n+     * Sets the current thread's scoped values cache\n@@ -486,1 +493,1 @@\n-    void setExtentLocalCache(Object[] cache);\n+    void setScopedValueCache(Object[] cache);\n@@ -489,1 +496,1 @@\n-     * Return the current thread's extent local bindings.\n+     * Return the current thread's scoped value bindings.\n@@ -491,1 +498,1 @@\n-    Object extentLocalBindings();\n+    Object scopedValueBindings();\n@@ -494,1 +501,1 @@\n-     * Set the current thread's extent local bindings.\n+     * Set the current thread's scoped value bindings.\n@@ -496,1 +503,5 @@\n-    void setExtentLocalBindings(Object bindings);\n+    void setScopedValueBindings(Object bindings);\n+\n+    Object findScopedValueBindings();\n+\n+    void ensureMaterializedForStackWalk(Object value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.io;\n+\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+\n+\/**\n+ * Delegate interface for custom Console implementations.\n+ * Methods defined here duplicates the ones in Console class.\n+ * Providers should implement jdk.internal.io.JdkConsoleProvider\n+ * to instantiate an implementation of this interface.\n+ *\/\n+public interface JdkConsole {\n+    PrintWriter writer();\n+    Reader reader();\n+    JdkConsole format(String fmt, Object ... args);\n+    JdkConsole printf(String format, Object ... args);\n+    String readLine(String fmt, Object ... args);\n+    String readLine();\n+    char[] readPassword(String fmt, Object ... args);\n+    char[] readPassword();\n+    void flush();\n+    Charset charset();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsole.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.io;\n+\n+import java.nio.charset.Charset;\n+\n+\/**\n+ * Service provider interface for JdkConsole implementations.\n+ * The provider used for instantiating JdkConsole instance can be\n+ * specified with the system property \"jdk.console\", whose value\n+ * designates the module name of the implementation, and which defaults\n+ * to \"jdk.internal.le\" (jline). If no providers is available,\n+ * or instantiation failed, java.base built-in Console implementation\n+ * is used.\n+ *\/\n+public interface JdkConsoleProvider {\n+    \/**\n+     * The module name of the JdkConsole default provider.\n+     *\/\n+    String DEFAULT_PROVIDER_MODULE_NAME = \"jdk.internal.le\";\n+\n+    \/**\n+     * {@return the Console instance, or {@code null} if not available}\n+     * @param isTTY indicates if the jvm is attached to a terminal\n+     * @param charset charset of the platform console\n+     *\/\n+    JdkConsole console(boolean isTTY, Charset charset);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleProvider.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -71,1 +71,1 @@\n-        @JEP(number=425, title=\"Virtual Threads\")\n+        @JEP(number=436, title=\"Virtual Threads\", status=\"Second Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -630,5 +630,3 @@\n-        if (options.length > 0) {\n-            for (OpenOption opt : options) {\n-                if (opt != READ) {\n-                    throw new UnsupportedOperationException(\"'\" + opt + \"' not allowed\");\n-                }\n+        for (OpenOption opt : options) {\n+            if (opt != READ) {\n+                throw new UnsupportedOperationException(\"'\" + opt + \"' not allowed\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtPath.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.internal.vm.ExtentLocalContainer;\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -102,1 +102,1 @@\n-    private final ExtentLocalContainer.BindingsSnapshot extentLocalBindings;\n+    private final ScopedValueContainer.BindingsSnapshot scopedValueBindings;\n@@ -114,1 +114,1 @@\n-        this.extentLocalBindings = ExtentLocalContainer.captureBindings();\n+        this.scopedValueBindings = ScopedValueContainer.captureBindings();\n@@ -122,2 +122,2 @@\n-    private ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n-        return extentLocalBindings;\n+    private ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n+        return scopedValueBindings;\n@@ -213,1 +213,1 @@\n-     * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n+     * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n@@ -253,1 +253,1 @@\n-     * <p> The thread is started with the extent-local bindings that were captured\n+     * <p> The thread is started with the scoped value bindings that were captured\n@@ -266,1 +266,1 @@\n-     * extent-local bindings are not the same as when the flock was created\n+     * scoped value bindings are not the same as when the flock was created\n@@ -401,6 +401,5 @@\n-     * closes this flock, and then throws {@link\n-     * jdk.incubator.concurrent.StructureViolationException}.\n-     * Similarly, if called to close a flock that <em>encloses<\/em> {@linkplain\n-     * jdk.incubator.concurrent.ExtentLocal.Carrier#run(Runnable) operations} with\n-     * extent-local bindings then it also throws {@code StructureViolationException}\n-     * after closing the flock.\n+     * closes this flock, and then throws {@code StructureViolationException}.\n+     * Similarly, if this method is called to close a thread flock while executing with\n+     * scoped value bindings, and the thread flock was created before the scoped values\n+     * were bound, then {@code StructureViolationException} is thrown after closing the\n+     * thread flock.\n@@ -588,2 +587,2 @@\n-        public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n-            return flock.extentLocalBindings();\n+        public ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n+            return flock.scopedValueBindings();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V20) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V21) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,0 +313,1 @@\n+    int V21 = 0 << 16 | 65;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private static final boolean PRESERVE_EXTENT_LOCAL_CACHE;\n+    private static final boolean PRESERVE_SCOPED_VALUE_CACHE;\n@@ -57,2 +57,2 @@\n-        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveExtentLocalCache\");\n-        PRESERVE_EXTENT_LOCAL_CACHE = (value == null) || Boolean.parseBoolean(value);\n+        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveScopedValueCache\");\n+        PRESERVE_SCOPED_VALUE_CACHE = (value == null) || Boolean.parseBoolean(value);\n@@ -132,1 +132,1 @@\n-    private Object[] extentLocalCache;\n+    private Object[] scopedValueCache;\n@@ -241,1 +241,1 @@\n-            JLA.setExtentLocalCache(extentLocalCache);\n+            JLA.setScopedValueCache(scopedValueCache);\n@@ -273,2 +273,2 @@\n-                    if (PRESERVE_EXTENT_LOCAL_CACHE) {\n-                        extentLocalCache = JLA.extentLocalCache();\n+                    if (PRESERVE_SCOPED_VALUE_CACHE) {\n+                        scopedValueCache = JLA.scopedValueCache();\n@@ -276,1 +276,1 @@\n-                        extentLocalCache = null;\n+                        scopedValueCache = null;\n@@ -278,1 +278,1 @@\n-                    JLA.setExtentLocalCache(null);\n+                    JLA.setScopedValueCache(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.vm;\n-\n-import java.util.concurrent.Callable;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.StructureViolationExceptions;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ReservedStackAccess;\n-\n-\/**\n- * A StackableScope to represent extent-local bindings.\n- *\n- * This class defines static methods to run an operation with a ExtentLocalContainer\n- * on the scope stack. It also defines a method to get the latest ExtentLocalContainer\n- * and a method to return a snapshot of the extent local bindings.\n- *\/\n-public class ExtentLocalContainer extends StackableScope {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-    static {\n-        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n-    }\n-\n-    private ExtentLocalContainer() {\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This may be on\n-     * the current thread's scope task or ma require walking up the tree to find it.\n-     *\/\n-    public static <T extends ExtentLocalContainer> T latest(Class<T> containerClass) {\n-        StackableScope scope = head();\n-        if (scope == null) {\n-            scope = JLA.threadContainer(Thread.currentThread());\n-            if (scope == null || scope.owner() == null)\n-                return null;\n-        }\n-        if (containerClass.isInstance(scope)) {\n-            @SuppressWarnings(\"unchecked\")\n-            T tmp = (T) scope;\n-            return tmp;\n-        } else {\n-            return scope.enclosingScope(containerClass);\n-        }\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This\n-     * may be on the current thread's scope task or may require walking up the\n-     * tree to find it.\n-     *\/\n-    public static ExtentLocalContainer latest() {\n-        return latest(ExtentLocalContainer.class);\n-    }\n-\n-    \/**\n-     * A snapshot of the extent local bindings. The snapshot includes the bindings\n-     * established for the current thread and extent local container.\n-     *\/\n-    public record BindingsSnapshot(Object extentLocalBindings,\n-                                   ExtentLocalContainer container) { }\n-\n-    \/**\n-     * Returns the extent local bindings for the current thread.\n-     *\/\n-    public static BindingsSnapshot captureBindings() {\n-        return new BindingsSnapshot(JLA.extentLocalBindings(), latest());\n-    }\n-\n-    \/**\n-     * For use by ExtentLocal to run an operation in a structured context.\n-     *\/\n-    public static void run(Runnable op) {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            runWithoutScope(op);\n-        } else {\n-            new ExtentLocalContainer().doRun(op);\n-        }\n-    }\n-\n-    \/**\n-     * Run an operation without a scope on the stack.\n-     *\/\n-    private static void runWithoutScope(Runnable op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();   \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * Run an operation with this scope on the stack.\n-     *\/\n-    private void doRun(Runnable op) {\n-        Throwable ex;\n-        boolean atTop;\n-        push();\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * For use by ExtentLocal to call a value returning operation in a structured context.\n-     *\/\n-    public static <V> V call(Callable<V> op) throws Exception {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            return callWithoutScope(op);\n-        } else {\n-            return new ExtentLocalContainer().doCall(op);\n-        }\n-    }\n-\n-    \/**\n-     * Call an operation without a scope on the stack.\n-     *\/\n-    private static <V> V callWithoutScope(Callable<V> op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Call an operation with this scope on the stack.\n-     *\/\n-    private <V> V doCall(Callable<V> op) {\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        push();\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n-     * as a suppressed exception when {@code atTop} is false.\n-     *\/\n-    @DontInline @ReservedStackAccess\n-    private static void throwIfFailed(Throwable ex, boolean atTop) {\n-        if (ex != null || !atTop) {\n-            if (!atTop) {\n-                var sve = StructureViolationExceptions.newException();\n-                if (ex == null) {\n-                    ex = sve;\n-                } else {\n-                    ex.addSuppressed(sve);\n-                }\n-            }\n-            Unsafe.getUnsafe().throwException(ex);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ExtentLocalContainer.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.util.concurrent.Callable;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.StructureViolationExceptions;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ReservedStackAccess;\n+\n+\/**\n+ * A StackableScope to represent scoped-value bindings.\n+ *\n+ * This class defines static methods to run an operation with a ScopedValueContainer\n+ * on the scope stack. It also defines a method to get the latest ScopedValueContainer\n+ * and a method to return a snapshot of the scoped value bindings.\n+ *\/\n+public class ScopedValueContainer extends StackableScope {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    static {\n+        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n+    }\n+\n+    private ScopedValueContainer() {\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ScopedValueContainer for the current Thread. This may be on\n+     * the current thread's scope task or may require walking up the tree to find it.\n+     *\/\n+    public static <T extends ScopedValueContainer> T latest(Class<T> containerClass) {\n+        StackableScope scope = head();\n+        if (scope == null) {\n+            scope = JLA.threadContainer(Thread.currentThread());\n+            if (scope == null || scope.owner() == null)\n+                return null;\n+        }\n+        if (containerClass.isInstance(scope)) {\n+            @SuppressWarnings(\"unchecked\")\n+            T tmp = (T) scope;\n+            return tmp;\n+        } else {\n+            return scope.enclosingScope(containerClass);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ScopedValueContainer for the current Thread. This\n+     * may be on the current thread's scope task or may require walking up the\n+     * tree to find it.\n+     *\/\n+    public static ScopedValueContainer latest() {\n+        return latest(ScopedValueContainer.class);\n+    }\n+\n+    \/**\n+     * A snapshot of the scoped value bindings. The snapshot includes the bindings\n+     * established for the current thread and scoped value container.\n+     *\/\n+    public record BindingsSnapshot(Object scopedValueBindings,\n+                                   ScopedValueContainer container) { }\n+\n+    \/**\n+     * Returns the scoped value bindings for the current thread.\n+     *\/\n+    public static BindingsSnapshot captureBindings() {\n+        return new BindingsSnapshot(JLA.scopedValueBindings(), latest());\n+    }\n+\n+    \/**\n+     * For use by ScopedValue to run an operation in a structured context.\n+     *\/\n+    public static void run(Runnable op) {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            runWithoutScope(op);\n+        } else {\n+            new ScopedValueContainer().doRun(op);\n+        }\n+    }\n+\n+    \/**\n+     * Run an operation without a scope on the stack.\n+     *\/\n+    private static void runWithoutScope(Runnable op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();   \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * Run an operation with this scope on the stack.\n+     *\/\n+    private void doRun(Runnable op) {\n+        Throwable ex;\n+        boolean atTop;\n+        push();\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * For use by ScopedValue to call a value returning operation in a structured context.\n+     *\/\n+    public static <V> V call(Callable<V> op) throws Exception {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            return callWithoutScope(op);\n+        } else {\n+            return new ScopedValueContainer().doCall(op);\n+        }\n+    }\n+\n+    \/**\n+     * Call an operation without a scope on the stack.\n+     *\/\n+    private static <V> V callWithoutScope(Callable<V> op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Call an operation with this scope on the stack.\n+     *\/\n+    private <V> V doCall(Callable<V> op) {\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        push();\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n+     * as a suppressed exception when {@code atTop} is false.\n+     *\/\n+    private static void throwIfFailed(Throwable ex, boolean atTop) {\n+        if (ex != null || !atTop) {\n+            if (!atTop) {\n+                var sve = StructureViolationExceptions.newException();\n+                if (ex == null) {\n+                    ex = sve;\n+                } else {\n+                    ex.addSuppressed(sve);\n+                }\n+            }\n+            Unsafe.getUnsafe().throwException(ex);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ScopedValueContainer.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -92,1 +92,1 @@\n-     * The extent locals captured when the thread container was created.\n+     * The scoped values captured when the thread container was created.\n@@ -94,1 +94,1 @@\n-    public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n+    public ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.GZIPOutputStream;\n+\n+\/**\n+ * Support for translating exceptions between the HotSpot heap and libjvmci heap.\n+ *\/\n+@SuppressWarnings(\"serial\")\n+final class TranslatedException extends Exception {\n+\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding\n+     * fails due to an {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding\n+     * fails for any reason other than {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_THROWABLE_BYTES;\n+    static {\n+        try {\n+            FALLBACK_ENCODED_THROWABLE_BYTES =\n+                encodeThrowable(new TranslatedException(\"error during encoding\",\n+                                                        \"<unknown>\"), false);\n+            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES =\n+                encodeThrowable(new OutOfMemoryError(), false);\n+        } catch (IOException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Class name of exception that could not be instantiated.\n+     *\/\n+    private String originalExceptionClassName;\n+\n+    private TranslatedException(String message, String originalExceptionClassName) {\n+        super(message);\n+        this.originalExceptionClassName = originalExceptionClassName;\n+    }\n+\n+    \/**\n+     * No need to record an initial stack trace since\n+     * it will be manually overwritten.\n+     *\/\n+    @SuppressWarnings(\"sync-override\")\n+    @Override\n+    public Throwable fillInStackTrace() {\n+        return this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s;\n+        if (originalExceptionClassName.equals(TranslatedException.class.getName())) {\n+            s = getClass().getName();\n+        } else {\n+            s = getClass().getName() + \"[\" + originalExceptionClassName + \"]\";\n+        }\n+        String message = getMessage();\n+        return (message != null) ? (s + \": \" + message) : s;\n+    }\n+\n+    \/**\n+     * Prints a stack trace for {@code throwable} if the system property\n+     * {@code \"jdk.internal.vm.TranslatedException.debug\"} is true.\n+     *\/\n+    private static void debugPrintStackTrace(Throwable throwable) {\n+        if (Boolean.getBoolean(\"jdk.internal.vm.TranslatedException.debug\")) {\n+            System.err.print(\"DEBUG: \");\n+            throwable.printStackTrace();\n+        }\n+    }\n+\n+    private static Throwable initCause(Throwable throwable, Throwable cause) {\n+        if (cause != null) {\n+            try {\n+                throwable.initCause(cause);\n+            } catch (IllegalStateException e) {\n+                \/\/ Cause could not be set or overwritten.\n+                debugPrintStackTrace(e);\n+            }\n+        }\n+        return throwable;\n+    }\n+\n+    private static Throwable create(String className, String message, Throwable cause) {\n+        \/\/ Try create with reflection first.\n+        try {\n+            Class<?> cls = Class.forName(className);\n+            if (cause != null) {\n+                \/\/ Handle known exception types whose cause must\n+                \/\/ be set in the constructor\n+                if (cls == InvocationTargetException.class) {\n+                    return new InvocationTargetException(cause, message);\n+                }\n+                if (cls == ExceptionInInitializerError.class) {\n+                    return new ExceptionInInitializerError(cause);\n+                }\n+            }\n+            if (message == null) {\n+                Constructor<?> cons = cls.getConstructor();\n+                return initCause((Throwable) cons.newInstance(), cause);\n+            }\n+            Constructor<?> cons = cls.getDeclaredConstructor(String.class);\n+            return initCause((Throwable) cons.newInstance(message), cause);\n+        } catch (Throwable translationFailure) {\n+            debugPrintStackTrace(translationFailure);\n+            return initCause(new TranslatedException(message, className), cause);\n+        }\n+    }\n+\n+    private static String emptyIfNull(String value) {\n+        return value == null ? \"\" : value;\n+    }\n+\n+    private static String emptyAsNull(String value) {\n+        return value.isEmpty() ? null : value;\n+    }\n+\n+    \/**\n+     * Encodes {@code throwable} including its stack and causes as a {@linkplain GZIPOutputStream\n+     * compressed} byte array that can be decoded by {@link #decodeThrowable}.\n+     *\/\n+    static byte[] encodeThrowable(Throwable throwable) {\n+        try {\n+            return encodeThrowable(throwable, true);\n+        } catch (OutOfMemoryError e) {\n+            return FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+        } catch (Throwable e) {\n+            return FALLBACK_ENCODED_THROWABLE_BYTES;\n+        }\n+    }\n+\n+    private static byte[] encodeThrowable(Throwable throwable,\n+                                          boolean withCauseAndStack) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (DataOutputStream dos = new DataOutputStream(new GZIPOutputStream(baos))) {\n+            List<Throwable> throwables = new ArrayList<>();\n+            for (Throwable current = throwable; current != null; current = current.getCause()) {\n+                throwables.add(current);\n+                if (!withCauseAndStack) {\n+                    break;\n+                }\n+            }\n+\n+            \/\/ Encode from inner most cause outwards\n+            Collections.reverse(throwables);\n+\n+            for (Throwable current : throwables) {\n+                dos.writeUTF(current.getClass().getName());\n+                dos.writeUTF(emptyIfNull(current.getMessage()));\n+                StackTraceElement[] stackTrace = withCauseAndStack ? current.getStackTrace() : null;\n+                if (stackTrace == null) {\n+                    stackTrace = new StackTraceElement[0];\n+                }\n+                dos.writeInt(stackTrace.length);\n+                for (int i = 0; i < stackTrace.length; i++) {\n+                    StackTraceElement frame = stackTrace[i];\n+                    if (frame != null) {\n+                        dos.writeUTF(emptyIfNull(frame.getClassLoaderName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleVersion()));\n+                        dos.writeUTF(emptyIfNull(frame.getClassName()));\n+                        dos.writeUTF(emptyIfNull(frame.getMethodName()));\n+                        dos.writeUTF(emptyIfNull(frame.getFileName()));\n+                        dos.writeInt(frame.getLineNumber());\n+                    }\n+                }\n+            }\n+        }\n+        return baos.toByteArray();\n+    }\n+\n+    \/**\n+     * Gets the stack of the current thread as of the first native method. The chopped\n+     * frames are for the VM call to {@link VMSupport#decodeAndThrowThrowable}.\n+     *\/\n+    private static StackTraceElement[] getMyStackTrace() {\n+        Exception ex = new Exception();\n+        StackTraceElement[] stack = ex.getStackTrace();\n+        for (int i = 0; i < stack.length; i++) {\n+            StackTraceElement e = stack[i];\n+            if (e.isNativeMethod()) {\n+                return Arrays.copyOfRange(stack, i, stack.length);\n+            }\n+        }\n+        \/\/ This should never happen but since this is exception handling\n+        \/\/ code, be defensive instead raising a nested exception.\n+        return new StackTraceElement[0];\n+    }\n+\n+    \/**\n+     * Decodes {@code encodedThrowable} into a {@link TranslatedException}.\n+     *\n+     * @param encodedThrowable an encoded exception in the format specified by\n+     *            {@link #encodeThrowable}\n+     *\/\n+    static Throwable decodeThrowable(byte[] encodedThrowable) {\n+        ByteArrayInputStream bais = new ByteArrayInputStream(encodedThrowable);\n+        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(bais))) {\n+            Throwable cause = null;\n+            Throwable throwable = null;\n+            StackTraceElement[] myStack = getMyStackTrace();\n+            while (dis.available() != 0) {\n+                String exceptionClassName = dis.readUTF();\n+                String exceptionMessage = emptyAsNull(dis.readUTF());\n+                throwable = create(exceptionClassName, exceptionMessage, cause);\n+                int stackTraceDepth = dis.readInt();\n+                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + myStack.length];\n+                int stackTraceIndex = 0;\n+                int myStackIndex = 0;\n+                for (int j = 0; j < stackTraceDepth; j++) {\n+                    String classLoaderName = emptyAsNull(dis.readUTF());\n+                    String moduleName = emptyAsNull(dis.readUTF());\n+                    String moduleVersion = emptyAsNull(dis.readUTF());\n+                    String className = emptyAsNull(dis.readUTF());\n+                    String methodName = emptyAsNull(dis.readUTF());\n+                    String fileName = emptyAsNull(dis.readUTF());\n+                    int lineNumber = dis.readInt();\n+                    StackTraceElement ste = new StackTraceElement(classLoaderName,\n+                                                                  moduleName,\n+                                                                  moduleVersion,\n+                                                                  className,\n+                                                                  methodName,\n+                                                                  fileName,\n+                                                                  lineNumber);\n+\n+                    if (ste.isNativeMethod()) {\n+                        \/\/ Best effort attempt to weave stack traces from two heaps into\n+                        \/\/ a single stack trace using native method frames as stitching points.\n+                        \/\/ This is not 100% reliable as there's no guarantee that native method\n+                        \/\/ frames only exist for calls between HotSpot and libjvmci.\n+                        while (myStackIndex < myStack.length) {\n+                            StackTraceElement suffixSTE = myStack[myStackIndex++];\n+                            if (suffixSTE.isNativeMethod()) {\n+                                break;\n+                            }\n+                            stackTrace[stackTraceIndex++] = suffixSTE;\n+                        }\n+                    }\n+                    stackTrace[stackTraceIndex++] = ste;\n+                }\n+                while (myStackIndex < myStack.length) {\n+                    stackTrace[stackTraceIndex++] = myStack[myStackIndex++];\n+                }\n+                if (stackTraceIndex != stackTrace.length) {\n+                    \/\/ Remove null entries at end of stackTrace\n+                    stackTrace = Arrays.copyOf(stackTrace, stackTraceIndex);\n+                }\n+                throwable.setStackTrace(stackTrace);\n+                cause = throwable;\n+            }\n+            return throwable;\n+        } catch (Throwable translationFailure) {\n+            debugPrintStackTrace(translationFailure);\n+            return new TranslatedException(\"Error decoding exception: \" + encodedThrowable,\n+                                           translationFailure.getClass().getName());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/TranslatedException.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import jdk.internal.misc.VM;\n+import jdk.internal.misc.Unsafe;\n+\n@@ -36,1 +39,1 @@\n- * Support class used by JVMTI and VM attach mechanism.\n+ * Support class used by JVMCI, JVMTI and VM attach mechanism.\n@@ -40,0 +43,1 @@\n+    private static final Unsafe U = Unsafe.getUnsafe();\n@@ -41,0 +45,1 @@\n+\n@@ -54,3 +59,2 @@\n-     * Write the given properties list to a byte array and return it. Properties with\n-     * a key or value that is not a String is filtered out. The stream written to the byte\n-     * array is ISO 8859-1 encoded.\n+     * Writes the given properties list to a byte array and return it. The stream written\n+     * to the byte array is ISO 8859-1 encoded.\n@@ -60,0 +64,3 @@\n+        p.store(out, null);\n+        return out.toByteArray();\n+    }\n@@ -61,0 +68,5 @@\n+    \/**\n+     * @returns a Properties object containing only the entries in {@code p}\n+     *          whose key and value are both Strings\n+     *\/\n+    private static Properties onlyStrings(Properties p) {\n@@ -69,3 +81,1 @@\n-\n-        props.store(out, null);\n-        return out.toByteArray();\n+        return props;\n@@ -75,1 +85,1 @@\n-        return serializePropertiesToByteArray(System.getProperties());\n+        return serializePropertiesToByteArray(onlyStrings(System.getProperties()));\n@@ -79,1 +89,14 @@\n-        return serializePropertiesToByteArray(getAgentProperties());\n+        return serializePropertiesToByteArray(onlyStrings(getAgentProperties()));\n+    }\n+\n+    \/**\n+     * Serializes {@link VM#getSavedProperties()} to a byte array.\n+     *\n+     * Used by JVMCI to copy properties into libjvmci.\n+     *\/\n+    public static byte[] serializeSavedPropertiesToByteArray() throws IOException {\n+        Properties props = new Properties();\n+        for (var e : VM.getSavedProperties().entrySet()) {\n+            props.put(e.getKey(), e.getValue());\n+        }\n+        return serializePropertiesToByteArray(props);\n@@ -91,0 +114,36 @@\n+\n+    \/**\n+     * Decodes the exception encoded in {@code buffer} and throws it.\n+     *\n+     * @param buffer a native byte buffer containing an exception encoded by\n+     *            {@link #encodeThrowable}\n+     *\/\n+    public static void decodeAndThrowThrowable(long buffer) throws Throwable {\n+        int encodingLength = U.getInt(buffer);\n+        byte[] encoding = new byte[encodingLength];\n+        U.copyMemory(null, buffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n+        throw TranslatedException.decodeThrowable(encoding);\n+    }\n+\n+    \/**\n+     * If {@code bufferSize} is large enough, encodes {@code throwable} into a byte array and writes\n+     * it to {@code buffer}. The encoding in {@code buffer} can be decoded by\n+     * {@link #decodeAndThrowThrowable}.\n+     *\n+     * @param throwable the exception to encode\n+     * @param buffer a native byte buffer\n+     * @param bufferSize the size of {@code buffer} in bytes\n+     * @return the number of bytes written into {@code buffer} if {@code bufferSize} is large\n+     *         enough, otherwise {@code -N} where {@code N} is the value {@code bufferSize} needs to\n+     *         be to fit the encoding\n+     *\/\n+    public static int encodeThrowable(Throwable throwable, long buffer, int bufferSize) {\n+        byte[] encoding = TranslatedException.encodeThrowable(throwable);\n+        int requiredSize = 4 + encoding.length;\n+        if (bufferSize < requiredSize) {\n+            return -requiredSize;\n+        }\n+        U.putInt(buffer, encoding.length);\n+        U.copyMemory(encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, null, buffer + 4, encoding.length);\n+        return requiredSize;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":69,"deletions":10,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+        jdk.incubator.concurrent,\n@@ -176,0 +177,3 @@\n+    exports jdk.internal.io to\n+        jdk.internal.le,\n+        jdk.jshell;\n@@ -250,0 +254,1 @@\n+        jdk.incubator.concurrent,\n@@ -256,0 +261,1 @@\n+        jdk.incubator.concurrent,\n@@ -310,1 +316,2 @@\n-        jdk.crypto.ec;\n+        jdk.crypto.ec,\n+        jdk.incubator.concurrent;\n@@ -408,0 +415,1 @@\n+    uses jdk.internal.io.JdkConsoleProvider;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -116,4 +116,0 @@\n-    public static String unparse(MethodType type) {\n-        return unparseMethod(type.returnType(), type.parameterArray());\n-    }\n-\n@@ -124,1 +120,1 @@\n-            return unparse((MethodType) type);\n+            return ((MethodType) type).toMethodDescriptorString();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,58 +345,0 @@\n-    static void empty() {\n-    }\n-\n-    static Object zeroObject() {\n-        return null;\n-    }\n-\n-    static int zeroInteger() {\n-        return 0;\n-    }\n-\n-    static long zeroLong() {\n-        return 0;\n-    }\n-\n-    static float zeroFloat() {\n-        return 0;\n-    }\n-\n-    static double zeroDouble() {\n-        return 0;\n-    }\n-\n-    private static final WrapperCache[] CONSTANT_FUNCTIONS = newWrapperCaches(2);\n-\n-    public static MethodHandle zeroConstantFunction(Wrapper wrap) {\n-        WrapperCache cache = CONSTANT_FUNCTIONS[0];\n-        MethodHandle mh = cache.get(wrap);\n-        if (mh != null) {\n-            return mh;\n-        }\n-        \/\/ slow path\n-        MethodType type = MethodType.methodType(wrap.primitiveType());\n-        switch (wrap) {\n-            case VOID:\n-                mh = Handles.EMPTY;\n-                break;\n-            case OBJECT:\n-            case INT: case LONG: case FLOAT: case DOUBLE:\n-                try {\n-                    mh = IMPL_LOOKUP.findStatic(THIS_CLASS, \"zero\"+wrap.wrapperSimpleName(), type);\n-                } catch (ReflectiveOperationException ex) {\n-                    mh = null;\n-                }\n-                break;\n-        }\n-        if (mh != null) {\n-            return cache.put(wrap, mh);\n-        }\n-\n-        \/\/ use zeroInt and cast the result\n-        if (wrap.isSubwordOrInt() && wrap != Wrapper.INT) {\n-            mh = MethodHandles.explicitCastArguments(zeroConstantFunction(Wrapper.INT), type);\n-            return cache.put(wrap, mh);\n-        }\n-        throw new IllegalArgumentException(\"cannot find zero constant for \" + wrap);\n-    }\n-\n@@ -404,1 +346,1 @@\n-        static final MethodHandle CAST_REFERENCE, IGNORE, EMPTY;\n+        static final MethodHandle IGNORE;\n@@ -409,1 +351,0 @@\n-                CAST_REFERENCE = IMPL_LOOKUP.findVirtual(Class.class, \"cast\", idType);\n@@ -411,1 +352,0 @@\n-                EMPTY = IMPL_LOOKUP.findStatic(THIS_CLASS, \"empty\", ignoreType.dropParameterTypes(0, 1));\n@@ -422,4 +362,0 @@\n-    \/** Return a method that casts its second argument (an Object) to the given type (a Class). *\/\n-    public static MethodHandle cast() {\n-        return Handles.CAST_REFERENCE;\n-    }\n@@ -676,3 +612,0 @@\n-    private static InternalError newInternalError(Throwable cause) {\n-        return new InternalError(cause);\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/ValueConversions.java","additions":2,"deletions":69,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -122,4 +122,3 @@\n-        if (modifiers.length > 0) {\n-            for (WatchEvent.Modifier modifier: modifiers) {\n-                if (modifier == null)\n-                    throw new NullPointerException();\n+        for (WatchEvent.Modifier modifier : modifiers) {\n+            if (modifier == null)\n+                throw new NullPointerException();\n@@ -127,9 +126,8 @@\n-                if (ExtendedOptions.SENSITIVITY_HIGH.matches(modifier)) {\n-                    sensitivity = ExtendedOptions.SENSITIVITY_HIGH.parameter();\n-                } else if (ExtendedOptions.SENSITIVITY_MEDIUM.matches(modifier)) {\n-                    sensitivity = ExtendedOptions.SENSITIVITY_MEDIUM.parameter();\n-                } else if (ExtendedOptions.SENSITIVITY_LOW.matches(modifier)) {\n-                    sensitivity = ExtendedOptions.SENSITIVITY_LOW.parameter();\n-                } else {\n-                    throw new UnsupportedOperationException(\"Modifier not supported\");\n-                }\n+            if (ExtendedOptions.SENSITIVITY_HIGH.matches(modifier)) {\n+                sensitivity = ExtendedOptions.SENSITIVITY_HIGH.parameter();\n+            } else if (ExtendedOptions.SENSITIVITY_MEDIUM.matches(modifier)) {\n+                sensitivity = ExtendedOptions.SENSITIVITY_MEDIUM.parameter();\n+            } else if (ExtendedOptions.SENSITIVITY_LOW.matches(modifier)) {\n+                sensitivity = ExtendedOptions.SENSITIVITY_LOW.parameter();\n+            } else {\n+                throw new UnsupportedOperationException(\"Modifier not supported\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/PollingWatchService.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -593,0 +593,1 @@\n+                    chc.sslConfig,\n@@ -904,0 +905,1 @@\n+                    context.sslConfig,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateVerify.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -316,6 +315,7 @@\n-                preferableNamedGroup =\n-                        SupportedGroups.getPreferredGroup(context.negotiatedProtocol,\n-                                context.algorithmConstraints,\n-                                new NamedGroupSpec [] {\n-                                    NamedGroupSpec.NAMED_GROUP_FFDHE },\n-                                context.clientRequestedNamedGroups);\n+                preferableNamedGroup = NamedGroup.getPreferredGroup(\n+                        context.sslConfig,\n+                        context.negotiatedProtocol,\n+                        context.algorithmConstraints,\n+                        new NamedGroupSpec [] {\n+                            NamedGroupSpec.NAMED_GROUP_FFDHE },\n+                        context.clientRequestedNamedGroups);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHKeyExchange.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+                                    shc.sslConfig,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHServerKeyExchange.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -239,1 +238,2 @@\n-                preferableNamedGroup = SupportedGroups.getPreferredGroup(\n+                preferableNamedGroup = NamedGroup.getPreferredGroup(\n+                        context.sslConfig,\n@@ -247,1 +247,2 @@\n-                preferableNamedGroup = SupportedGroups.getPreferredGroup(\n+                preferableNamedGroup = NamedGroup.getPreferredGroup(\n+                        context.sslConfig,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHKeyExchange.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -142,0 +141,1 @@\n+                                shc.sslConfig,\n@@ -207,1 +207,1 @@\n-            if (!SupportedGroups.isSupported(namedGroup)) {\n+            if (!NamedGroup.isEnabled(chc.sslConfig, namedGroup)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHServerKeyExchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -160,2 +159,2 @@\n-        this.activeProtocols = getActiveProtocols(sslConfig.enabledProtocols,\n-                sslConfig.enabledCipherSuites, algorithmConstraints);\n+        this.activeProtocols =\n+                getActiveProtocols(sslConfig, algorithmConstraints);\n@@ -176,2 +175,2 @@\n-        this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,\n-                sslConfig.enabledCipherSuites, algorithmConstraints);\n+        this.activeCipherSuites = getActiveCipherSuites(sslConfig,\n+                this.activeProtocols, algorithmConstraints);\n@@ -259,2 +258,1 @@\n-            List<ProtocolVersion> enabledProtocols,\n-            List<CipherSuite> enabledCipherSuites,\n+            SSLConfiguration sslConfig,\n@@ -264,1 +262,1 @@\n-        for (ProtocolVersion protocol : enabledProtocols) {\n+        for (ProtocolVersion protocol : sslConfig.enabledProtocols) {\n@@ -280,1 +278,1 @@\n-            for (CipherSuite suite : enabledCipherSuites) {\n+            for (CipherSuite suite : sslConfig.enabledCipherSuites) {\n@@ -282,1 +280,1 @@\n-                    if (isActivatable(suite,\n+                    if (isActivatable(sslConfig, suite,\n@@ -312,0 +310,1 @@\n+            SSLConfiguration sslConfig,\n@@ -313,1 +312,0 @@\n-            List<CipherSuite> enabledCipherSuites,\n@@ -320,1 +318,1 @@\n-            for (CipherSuite suite : enabledCipherSuites) {\n+            for (CipherSuite suite : sslConfig.enabledCipherSuites) {\n@@ -330,1 +328,1 @@\n-                    if (isActivatable(suite,\n+                    if (isActivatable(sslConfig, suite,\n@@ -528,1 +526,3 @@\n-    private static boolean isActivatable(CipherSuite suite,\n+    private static boolean isActivatable(\n+            SSLConfiguration sslConfig,\n+            CipherSuite suite,\n@@ -546,2 +546,2 @@\n-                        groupAvailable = SupportedGroups.isActivatable(\n-                                algorithmConstraints, groupType);\n+                        groupAvailable = NamedGroup.isActivatable(\n+                                sslConfig, algorithmConstraints, groupType);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -348,1 +347,1 @@\n-                if (ng == null || !SupportedGroups.isActivatable(\n+                if (ng == null || !NamedGroup.isActivatable(shc.sslConfig,\n@@ -650,1 +649,1 @@\n-            if (ng == null || !SupportedGroups.isActivatable(\n+            if (ng == null || !NamedGroup.isActivatable(chc.sslConfig,\n@@ -803,1 +802,1 @@\n-                if (SupportedGroups.isActivatable(\n+                if (NamedGroup.isActivatable(shc.sslConfig,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KeyShareExtension.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -41,1 +42,1 @@\n-\n+import sun.security.action.GetPropertyAction;\n@@ -244,3 +245,3 @@\n-               NamedGroupSpec namedGroupSpec,\n-               ProtocolVersion[] supportedProtocols,\n-               AlgorithmParameterSpec keAlgParamSpec) {\n+            NamedGroupSpec namedGroupSpec,\n+            ProtocolVersion[] supportedProtocols,\n+            AlgorithmParameterSpec keAlgParamSpec) {\n@@ -372,0 +373,120 @@\n+    public static List<NamedGroup> namesOf(String[] namedGroups) {\n+        if (namedGroups == null) {\n+            return null;\n+        }\n+\n+        if (namedGroups.length == 0) {\n+            return List.of();\n+        }\n+\n+        List<NamedGroup> ngs = new ArrayList<>(namedGroups.length);\n+        for (String ss : namedGroups) {\n+            NamedGroup ng = NamedGroup.nameOf(ss);\n+            if (ng == null || !ng.isAvailable) {\n+                if (SSLLogger.isOn &&\n+                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                    SSLLogger.finest(\n+                            \"Ignore the named group (\" + ss\n+                                    + \"), unsupported or unavailable\");\n+                }\n+\n+                continue;\n+            }\n+\n+            ngs.add(ng);\n+        }\n+\n+        return Collections.unmodifiableList(ngs);\n+    }\n+\n+    \/\/ Is there any supported group permitted by the constraints?\n+    static boolean isActivatable(SSLConfiguration sslConfig,\n+            AlgorithmConstraints constraints, NamedGroupSpec type) {\n+\n+        boolean hasFFDHEGroups = false;\n+        for (String ng : sslConfig.namedGroups) {\n+            NamedGroup namedGroup = NamedGroup.nameOf(ng);\n+            if (namedGroup != null &&\n+                namedGroup.isAvailable && namedGroup.spec == type) {\n+                if (namedGroup.isPermitted(constraints)) {\n+                    return true;\n+                }\n+\n+                if (!hasFFDHEGroups &&\n+                        (type == NamedGroupSpec.NAMED_GROUP_FFDHE)) {\n+                    hasFFDHEGroups = true;\n+                }\n+            }\n+        }\n+\n+        \/\/ For compatibility, if no FFDHE groups are defined, the non-FFDHE\n+        \/\/ compatible mode (using DHE cipher suite without FFDHE extension)\n+        \/\/ is allowed.\n+        \/\/\n+        \/\/ Note that the constraints checking on DHE parameters will be\n+        \/\/ performed during key exchanging in a handshake.\n+        return !hasFFDHEGroups && type == NamedGroupSpec.NAMED_GROUP_FFDHE;\n+    }\n+\n+    \/\/ Is the named group permitted by the constraints?\n+    static boolean isActivatable(\n+            SSLConfiguration sslConfig,\n+            AlgorithmConstraints constraints, NamedGroup namedGroup) {\n+        if (!namedGroup.isAvailable || !isEnabled(sslConfig, namedGroup)) {\n+            return false;\n+        }\n+\n+        return namedGroup.isPermitted(constraints);\n+    }\n+\n+    \/\/ Is the named group supported?\n+    static boolean isEnabled(SSLConfiguration sslConfig,\n+                             NamedGroup namedGroup) {\n+        for (String ng : sslConfig.namedGroups) {\n+            if (namedGroup.name.equalsIgnoreCase(ng)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    \/\/ Get preferred named group from the configured named groups for the\n+    \/\/ negotiated protocol and named group types.\n+    static NamedGroup getPreferredGroup(\n+            SSLConfiguration sslConfig,\n+            ProtocolVersion negotiatedProtocol,\n+            AlgorithmConstraints constraints, NamedGroupSpec[] types) {\n+        for (String name : sslConfig.namedGroups) {\n+            NamedGroup ng = NamedGroup.nameOf(name);\n+            if (ng != null && ng.isAvailable &&\n+                    (NamedGroupSpec.arrayContains(types, ng.spec)) &&\n+                    ng.isAvailable(negotiatedProtocol) &&\n+                    ng.isPermitted(constraints)) {\n+                return ng;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    \/\/ Get preferred named group from the requested and configured named\n+    \/\/ groups for the negotiated protocol and named group types.\n+    static NamedGroup getPreferredGroup(\n+            SSLConfiguration sslConfig,\n+            ProtocolVersion negotiatedProtocol,\n+            AlgorithmConstraints constraints, NamedGroupSpec[] types,\n+            List<NamedGroup> requestedNamedGroups) {\n+        for (NamedGroup namedGroup : requestedNamedGroups) {\n+            if ((namedGroup.isAvailable &&\n+                    NamedGroupSpec.arrayContains(types, namedGroup.spec)) &&\n+                    namedGroup.isAvailable(negotiatedProtocol) &&\n+                    isEnabled(sslConfig, namedGroup) &&\n+                    namedGroup.isPermitted(constraints)) {\n+                return namedGroup;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n@@ -621,0 +742,82 @@\n+\n+    static final class SupportedGroups {\n+        \/\/ the supported named groups, non-null immutable list\n+        static final String[] namedGroups;\n+\n+        static {\n+            \/\/ The value of the System Property defines a list of enabled named\n+            \/\/ groups in preference order, separated with comma.  For example:\n+            \/\/\n+            \/\/      jdk.tls.namedGroups=\"secp521r1, secp256r1, ffdhe2048\"\n+            \/\/\n+            \/\/ If the System Property is not defined or the value is empty, the\n+            \/\/ default groups and preferences will be used.\n+            String property = GetPropertyAction\n+                    .privilegedGetProperty(\"jdk.tls.namedGroups\");\n+            if (property != null && !property.isEmpty()) {\n+                \/\/ remove double quote marks from beginning\/end of the property\n+                if (property.length() > 1 && property.charAt(0) == '\"' &&\n+                        property.charAt(property.length() - 1) == '\"') {\n+                    property = property.substring(1, property.length() - 1);\n+                }\n+            }\n+\n+            ArrayList<String> groupList;\n+            if (property != null && !property.isEmpty()) {\n+                String[] groups = property.split(\",\");\n+                groupList = new ArrayList<>(groups.length);\n+                for (String group : groups) {\n+                    group = group.trim();\n+                    if (!group.isEmpty()) {\n+                        NamedGroup namedGroup = nameOf(group);\n+                        if (namedGroup != null) {\n+                            if (namedGroup.isAvailable) {\n+                                groupList.add(namedGroup.name);\n+                            }\n+                        }   \/\/ ignore unknown groups\n+                    }\n+                }\n+\n+                if (groupList.isEmpty()) {\n+                    throw new IllegalArgumentException(\n+                            \"System property jdk.tls.namedGroups(\" +\n+                            property + \") contains no supported named groups\");\n+                }\n+            } else {        \/\/ default groups\n+                NamedGroup[] groups = new NamedGroup[] {\n+\n+                        \/\/ Primary XDH (RFC 7748) curves\n+                        X25519,\n+\n+                        \/\/ Primary NIST Suite B curves\n+                        SECP256_R1,\n+                        SECP384_R1,\n+                        SECP521_R1,\n+\n+                        \/\/ Secondary XDH curves\n+                        X448,\n+\n+                        \/\/ FFDHE (RFC 7919)\n+                        FFDHE_2048,\n+                        FFDHE_3072,\n+                        FFDHE_4096,\n+                        FFDHE_6144,\n+                        FFDHE_8192,\n+                    };\n+\n+                groupList = new ArrayList<>(groups.length);\n+                for (NamedGroup group : groups) {\n+                    if (group.isAvailable) {\n+                        groupList.add(group.name);\n+                    }\n+                }\n+\n+                if (groupList.isEmpty() &&\n+                        SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.warning(\"No default named groups\");\n+                }\n+            }\n+\n+            namedGroups = groupList.toArray(new String[0]);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NamedGroup.java","additions":207,"deletions":4,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -67,0 +67,3 @@\n+    \/\/ the configured named groups for the \"supported_groups\" extensions\n+    String[]                   namedGroups;\n+\n@@ -112,0 +115,4 @@\n+    \/\/ To switch off the supported_groups extension for DHE cipher suite.\n+    static final boolean enableFFDHE =\n+            Utilities.getBooleanProperty(\"jsse.enableFFDHE\", true);\n+\n@@ -149,0 +156,1 @@\n+        this.namedGroups = NamedGroup.SupportedGroups.namedGroups;\n@@ -204,0 +212,1 @@\n+        params.setNamedGroups(this.namedGroups);\n@@ -268,0 +277,9 @@\n+        String[] ngs = params.getNamedGroups();\n+        if (ngs != null) {\n+            \/\/ Note if 'ngs' is empty, then no named groups should be\n+            \/\/ specified over the connections.\n+            this.namedGroups = ngs;\n+        } else {    \/\/ Otherwise, use the default values.\n+            this.namedGroups = NamedGroup.SupportedGroups.namedGroups;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -564,10 +562,0 @@\n-        static final Map<NamedGroup, T13KeyAgreement>\n-                supportedKeyShares = new HashMap<>();\n-\n-        static {\n-            for (NamedGroup namedGroup :\n-                    SupportedGroups.supportedNamedGroups) {\n-                supportedKeyShares.put(\n-                        namedGroup, new T13KeyAgreement(namedGroup));\n-            }\n-        }\n@@ -580,1 +568,1 @@\n-            return supportedKeyShares.get(namedGroup);\n+            return new T13KeyAgreement(namedGroup);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLKeyExchange.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -469,0 +468,1 @@\n+            SSLConfiguration sslConfig,\n@@ -522,1 +522,1 @@\n-                                SupportedGroups.isSupported(keyGroup)) {\n+                                NamedGroup.isEnabled(sslConfig, keyGroup)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.AlgorithmConstraints;\n@@ -34,1 +33,1 @@\n-import sun.security.action.GetPropertyAction;\n+\n@@ -67,4 +66,0 @@\n-        private SupportedGroupsSpec(int[] namedGroupsIds) {\n-            this.namedGroupsIds = namedGroupsIds;\n-        }\n-\n@@ -153,168 +148,0 @@\n-    static class SupportedGroups {\n-        \/\/ To switch off the supported_groups extension for DHE cipher suite.\n-        static final boolean enableFFDHE =\n-                Utilities.getBooleanProperty(\"jsse.enableFFDHE\", true);\n-\n-        \/\/ the supported named groups\n-        static final NamedGroup[] supportedNamedGroups;\n-\n-        static {\n-            \/\/ The value of the System Property defines a list of enabled named\n-            \/\/ groups in preference order, separated with comma.  For example:\n-            \/\/\n-            \/\/      jdk.tls.namedGroups=\"secp521r1, secp256r1, ffdhe2048\"\n-            \/\/\n-            \/\/ If the System Property is not defined or the value is empty, the\n-            \/\/ default groups and preferences will be used.\n-            String property = GetPropertyAction\n-                    .privilegedGetProperty(\"jdk.tls.namedGroups\");\n-            if (property != null && !property.isEmpty()) {\n-                \/\/ remove double quote marks from beginning\/end of the property\n-                if (property.length() > 1 && property.charAt(0) == '\"' &&\n-                        property.charAt(property.length() - 1) == '\"') {\n-                    property = property.substring(1, property.length() - 1);\n-                }\n-            }\n-\n-            ArrayList<NamedGroup> groupList;\n-            if (property != null && !property.isEmpty()) {\n-                String[] groups = property.split(\",\");\n-                groupList = new ArrayList<>(groups.length);\n-                for (String group : groups) {\n-                    group = group.trim();\n-                    if (!group.isEmpty()) {\n-                        NamedGroup namedGroup = NamedGroup.nameOf(group);\n-                        if (namedGroup != null) {\n-                            if (namedGroup.isAvailable) {\n-                                groupList.add(namedGroup);\n-                            }\n-                        }   \/\/ ignore unknown groups\n-                    }\n-                }\n-\n-                if (groupList.isEmpty()) {\n-                    throw new IllegalArgumentException(\n-                            \"System property jdk.tls.namedGroups(\" +\n-                            property + \") contains no supported named groups\");\n-                }\n-            } else {        \/\/ default groups\n-                NamedGroup[] groups = new NamedGroup[] {\n-\n-                        \/\/ Primary XDH (RFC 7748) curves\n-                        NamedGroup.X25519,\n-\n-                        \/\/ Primary NIST Suite B curves\n-                        NamedGroup.SECP256_R1,\n-                        NamedGroup.SECP384_R1,\n-                        NamedGroup.SECP521_R1,\n-\n-                        \/\/ Secondary XDH curves\n-                        NamedGroup.X448,\n-\n-                        \/\/ FFDHE (RFC 7919)\n-                        NamedGroup.FFDHE_2048,\n-                        NamedGroup.FFDHE_3072,\n-                        NamedGroup.FFDHE_4096,\n-                        NamedGroup.FFDHE_6144,\n-                        NamedGroup.FFDHE_8192,\n-                    };\n-\n-                groupList = new ArrayList<>(groups.length);\n-                for (NamedGroup group : groups) {\n-                    if (group.isAvailable) {\n-                        groupList.add(group);\n-                    }\n-                }\n-\n-                if (groupList.isEmpty() &&\n-                        SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.warning(\"No default named groups\");\n-                }\n-            }\n-\n-            supportedNamedGroups = new NamedGroup[groupList.size()];\n-            int i = 0;\n-            for (NamedGroup namedGroup : groupList) {\n-                supportedNamedGroups[i++] = namedGroup;\n-            }\n-        }\n-\n-        \/\/ Is there any supported group permitted by the constraints?\n-        static boolean isActivatable(\n-                AlgorithmConstraints constraints, NamedGroupSpec type) {\n-\n-            boolean hasFFDHEGroups = false;\n-            for (NamedGroup namedGroup : supportedNamedGroups) {\n-                if (namedGroup.isAvailable && namedGroup.spec == type) {\n-                    if (namedGroup.isPermitted(constraints)) {\n-                        return true;\n-                    }\n-\n-                    if (!hasFFDHEGroups &&\n-                            (type == NamedGroupSpec.NAMED_GROUP_FFDHE)) {\n-                        hasFFDHEGroups = true;\n-                    }\n-                }\n-            }\n-\n-            \/\/ For compatibility, if no FFDHE groups are defined, the non-FFDHE\n-            \/\/ compatible mode (using DHE cipher suite without FFDHE extension)\n-            \/\/ is allowed.\n-            \/\/\n-            \/\/ Note that the constraints checking on DHE parameters will be\n-            \/\/ performed during key exchanging in a handshake.\n-            return !hasFFDHEGroups && type == NamedGroupSpec.NAMED_GROUP_FFDHE;\n-        }\n-\n-        \/\/ Is the named group permitted by the constraints?\n-        static boolean isActivatable(\n-                AlgorithmConstraints constraints, NamedGroup namedGroup) {\n-            if (!namedGroup.isAvailable || !isSupported(namedGroup)) {\n-                return false;\n-            }\n-\n-            return namedGroup.isPermitted(constraints);\n-        }\n-\n-        \/\/ Is the named group supported?\n-        static boolean isSupported(NamedGroup namedGroup) {\n-            for (NamedGroup group : supportedNamedGroups) {\n-                if (namedGroup.id == group.id) {\n-                    return true;\n-                }\n-            }\n-\n-            return false;\n-        }\n-\n-        static NamedGroup getPreferredGroup(\n-                ProtocolVersion negotiatedProtocol,\n-                AlgorithmConstraints constraints, NamedGroupSpec[] types,\n-                List<NamedGroup> requestedNamedGroups) {\n-            for (NamedGroup namedGroup : requestedNamedGroups) {\n-                if ((NamedGroupSpec.arrayContains(types, namedGroup.spec)) &&\n-                        namedGroup.isAvailable(negotiatedProtocol) &&\n-                        isSupported(namedGroup) &&\n-                        namedGroup.isPermitted(constraints)) {\n-                    return namedGroup;\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        static NamedGroup getPreferredGroup(\n-                ProtocolVersion negotiatedProtocol,\n-                AlgorithmConstraints constraints, NamedGroupSpec[] types) {\n-            for (NamedGroup namedGroup : supportedNamedGroups) {\n-                if ((NamedGroupSpec.arrayContains(types, namedGroup.spec)) &&\n-                        namedGroup.isAvailable(negotiatedProtocol) &&\n-                        namedGroup.isPermitted(constraints)) {\n-                    return namedGroup;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n@@ -349,3 +176,12 @@\n-                new ArrayList<>(SupportedGroups.supportedNamedGroups.length);\n-            for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {\n-                if ((!SupportedGroups.enableFFDHE) &&\n+                    new ArrayList<>(chc.sslConfig.namedGroups.length);\n+            for (String name : chc.sslConfig.namedGroups) {\n+                NamedGroup ng = NamedGroup.nameOf(name);\n+                if (ng == null) {\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        SSLLogger.fine(\n+                                \"Ignore unspecified named group: \" + name);\n+                    }\n+                    continue;\n+                }\n+\n+                if ((!SSLConfiguration.enableFFDHE) &&\n@@ -498,3 +334,13 @@\n-                    SupportedGroups.supportedNamedGroups.length);\n-            for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {\n-                if ((!SupportedGroups.enableFFDHE) &&\n+                    shc.sslConfig.namedGroups.length);\n+            for (String name : shc.sslConfig.namedGroups) {\n+                NamedGroup ng = NamedGroup.nameOf(name);\n+                if (ng == null) {\n+                    if (SSLLogger.isOn &&\n+                            SSLLogger.isOn(\"ssl,handshake\")) {\n+                        SSLLogger.fine(\n+                                \"Ignore unspecified named group: \" + name);\n+                    }\n+                    continue;\n+                }\n+\n+                if ((!SSLConfiguration.enableFFDHE) &&\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SupportedGroupsExtension.java","additions":26,"deletions":180,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n-\n@@ -347,1 +345,1 @@\n-                        (!SupportedGroups.isSupported(namedGroup)) ||\n+                        (!NamedGroup.isEnabled(shc.sslConfig, namedGroup)) ||\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -54,1 +55,1 @@\n-            \/\/ Use the new java.io.Console class\n+            \/\/ Only use Console if `in` is the initial System.in\n@@ -56,1 +57,3 @@\n-            if (!isEchoOn && in == System.in && ((con = System.console()) != null)) {\n+            if (!isEchoOn &&\n+                    in == SharedSecrets.getJavaLangAccess().initialSystemIn() &&\n+                    ((con = System.console()) != null)) {\n@@ -58,1 +61,1 @@\n-                \/\/ readPassword returns \"\" if you just print ENTER,\n+                \/\/ readPassword returns \"\" if you just press ENTER with the built-in Console,\n@@ -60,1 +63,1 @@\n-                if (consoleEntered != null && consoleEntered.length == 0) {\n+                if (consoleEntered == null || consoleEntered.length == 0) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Password.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-.TH \"JAVA\" \"1\" \"2023\" \"JDK 20-ea\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2023\" \"JDK 21-ea\" \"JDK Commands\"\n@@ -190,1 +190,1 @@\n-(\\f[V]20\\f[R]) and a limited number of previous releases, detailed in\n+(\\f[V]21\\f[R]) and a limited number of previous releases, detailed in\n@@ -3792,0 +3792,8 @@\n+.SH REMOVED JAVA OPTIONS\n+.PP\n+These \\f[V]java\\f[R] options have been removed in JDK 21 and using them\n+results in an error of:\n+.RS\n+.PP\n+\\f[V]Unrecognized VM option\\f[R] \\f[I]option-name\\f[R]\n+.RE\n@@ -3801,3 +3809,0 @@\n-.SH REMOVED JAVA OPTIONS\n-.PP\n-No documented java options have been removed in JDK 20.\n@@ -3808,0 +3813,3 @@\n+\\f[B]The \\f[VB]java\\f[B] Command, Release 20\\f[R]\n+[https:\/\/docs.oracle.com\/en\/java\/javase\/20\/docs\/specs\/man\/java.html]\n+.IP \\[bu] 2\n","filename":"src\/java.base\/share\/man\/java.1","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -53,3 +53,6 @@\n-    {\"extentLocalCache\",  \"()[\" OBJ,    (void *)&JVM_ExtentLocalCache},\n-    {\"setExtentLocalCache\", \"([\" OBJ \")V\",(void *)&JVM_SetExtentLocalCache},\n-    {\"getNextThreadIdOffset\", \"()J\",     (void *)&JVM_GetNextThreadIdOffset}\n+    {\"scopedValueCache\", \"()[\" OBJ,    (void *)&JVM_ScopedValueCache},\n+    {\"setScopedValueCache\", \"([\" OBJ \")V\",(void *)&JVM_SetScopedValueCache},\n+    {\"getNextThreadIdOffset\", \"()J\",   (void *)&JVM_GetNextThreadIdOffset},\n+    {\"findScopedValueBindings\", \"()\" OBJ, (void *)&JVM_FindScopedValueBindings},\n+    {\"ensureMaterializedForStackWalk\",\n+                         \"(\" OBJ \")V\", (void*)&JVM_EnsureMaterializedForStackWalk_func},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+     *  21: tbd\n@@ -375,1 +376,13 @@\n-    RELEASE_20;\n+    RELEASE_20,\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 21.\n+     *\n+     * @since 21\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/index.html\">\n+     * <cite>The Java Language Specification, Java SE 21 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_21;\n@@ -384,1 +397,1 @@\n-        return RELEASE_20;\n+        return RELEASE_21;\n@@ -399,1 +412,1 @@\n-            valueOf(\"RELEASE_\" + Math.min(20, intVersion)):\n+            valueOf(\"RELEASE_\" + Math.min(21, intVersion)):\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -656,4 +656,2 @@\n-                if (rows.length > 0) {\n-                    for (final int element : rows) {\n-                        if (isSelectableForMode(chooser, (File)fFileList.getValueAt(element, 0))) selectableCount++;\n-                    }\n+                for (final int element : rows) {\n+                    if (isSelectableForMode(chooser, (File) fFileList.getValueAt(element, 0))) selectableCount++;\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileChooserUI.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-                    sprintf(channelName, \"Ch %d\", ch);\n+                    snprintf(channelName, 16, \"Ch %d\", ch);\n","filename":"src\/java.desktop\/macosx\/native\/libjsound\/PLATFORM_API_MacOSX_Ports.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1827,1 +1827,1 @@\n-                                            \" form wrong thread.\" +\n+                                            \" from wrong thread.\" +\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1824,1 +1824,1 @@\n-            throw new IllegalStateException(\"Attempt to clear thread lock form wrong thread. \" +\n+            throw new IllegalStateException(\"Attempt to clear thread lock from wrong thread. \" +\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -289,12 +289,0 @@\n-\n-        if ((c instanceof JCheckBox) && (state & SynthConstants.DISABLED) != 0) {\n-            if (UIManager.getColor(\"CheckBox.disabledText\") != null) {\n-                return UIManager.getColor(\"CheckBox.disabledText\");\n-            }\n-        } else if ((c instanceof JRadioButton) &&\n-                (state & SynthConstants.DISABLED) != 0) {\n-            if (UIManager.getColor(\"RadioButton.disabledText\") != null) {\n-                return UIManager.getColor(\"RadioButton.disabledText\");\n-            }\n-        }\n-\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKStyle.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,4 @@\n-\n+            if (data.length < 3 || (data[1] & 0xFF) != 0x7E && (data[1] & 0xFF) != 0x7F ) {\n+                \/\/ Not enough data to determine SysEx type or SysEx type is not supported\n+                return;\n+            }\n@@ -131,0 +134,3 @@\n+                    if (data.length < 4) {\n+                        return;\n+                    }\n@@ -134,15 +140,21 @@\n-                    case 0x08:  \/\/ MIDI Tuning Standard\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01:  \/\/ BULK TUNING DUMP\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(0,\n-                                    data[5] & 0xFF));\n-                            tuning.load(data);\n-                            break;\n-                        }\n-                        case 0x04:  \/\/ KEY-BASED TUNING DUMP\n-                        case 0x05:  \/\/ SCALE\/OCTAVE TUNING DUMP, 1 byte format\n-                        case 0x06:  \/\/ SCALE\/OCTAVE TUNING DUMP, 2 byte format\n-                        case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (NON REAL-TIME)\n+                        case 0x08:  \/\/ MIDI Tuning Standard\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01:  \/\/ BULK TUNING DUMP\n+                                {\n+                                    if (data.length < 6) {\n+                                        break;\n+                                    }\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n+                                    SoftTuning tuning = synth.getTuning(new Patch(0,\n+                                            data[5] & 0xFF));\n+                                    tuning.load(data);\n+                                    break;\n+                                }\n+                                case 0x04:  \/\/ KEY-BASED TUNING DUMP\n+                                case 0x05:  \/\/ SCALE\/OCTAVE TUNING DUMP, 1 byte format\n+                                case 0x06:  \/\/ SCALE\/OCTAVE TUNING DUMP, 2 byte format\n+                                case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (NON REAL-TIME)\n@@ -150,8 +162,11 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(\n-                                    data[5] & 0xFF, data[6] & 0xFF));\n-                            tuning.load(data);\n-                            break;\n-                        }\n-                        case 0x08:  \/\/ scale\/octave tuning 1-byte form (Non\n+                                {\n+                                    if (data.length < 7) {\n+                                        break;\n+                                    }\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n+                                    SoftTuning tuning = synth.getTuning(new Patch(\n+                                            data[5] & 0xFF, data[6] & 0xFF));\n+                                    tuning.load(data); \/\/ Check inside!\n+                                    break;\n+                                }\n+                                case 0x08:  \/\/ scale\/octave tuning 1-byte form (Non\n@@ -159,1 +174,1 @@\n-                        case 0x09:  \/\/ scale\/octave tuning 2-byte form (Non\n+                                case 0x09:  \/\/ scale\/octave tuning 2-byte form (Non\n@@ -161,47 +176,17 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n-                            SoftTuning tuning = new SoftTuning(data);\n-                            int channelmask = (data[5] & 0xFF) * 16384\n-                                    + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n-                            SoftChannel[] channels = synth.channels;\n-                            for (int i = 0; i < channels.length; i++)\n-                                if ((channelmask & (1 << i)) != 0)\n-                                    channels[i].tuning = tuning;\n-                            break;\n-                        }\n-                        default:\n-                            break;\n-                        }\n-                        break;\n-                    case 0x09:  \/\/ General Midi Message\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01:  \/\/ General Midi 1 On\n-                            synth.setGeneralMidiMode(1);\n-                            reset();\n-                            break;\n-                        case 0x02:  \/\/ General Midi Off\n-                            synth.setGeneralMidiMode(0);\n-                            reset();\n-                            break;\n-                        case 0x03:  \/\/ General MidI Level 2 On\n-                            synth.setGeneralMidiMode(2);\n-                            reset();\n-                            break;\n-                        default:\n-                            break;\n-                        }\n-                        break;\n-                    case 0x0A: \/\/ DLS Message\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01:  \/\/ DLS On\n-                            if (synth.getGeneralMidiMode() == 0)\n-                                synth.setGeneralMidiMode(1);\n-                            synth.voice_allocation_mode = 1;\n-                            reset();\n-                            break;\n-                        case 0x02:  \/\/ DLS Off\n-                            synth.setGeneralMidiMode(0);\n-                            synth.voice_allocation_mode = 0;\n-                            reset();\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n+                                    SoftTuning tuning = new SoftTuning(data);\n+                                    int channelmask = (data[5] & 0xFF) * 16384\n+                                            + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n+                                    SoftChannel[] channels = synth.channels;\n+                                    for (int i = 0; i < channels.length; i++)\n+                                        if ((channelmask & (1 << i)) != 0)\n+                                            channels[i].tuning = tuning;\n+                                    break;\n+                                }\n+                                default:\n+                                    break;\n+                            }\n@@ -209,2 +194,21 @@\n-                        case 0x03:  \/\/ DLS Static Voice Allocation Off\n-                            synth.voice_allocation_mode = 0;\n+                        case 0x09:  \/\/ General Midi Message\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01:  \/\/ General Midi 1 On\n+                                    synth.setGeneralMidiMode(1);\n+                                    reset();\n+                                    break;\n+                                case 0x02:  \/\/ General Midi Off\n+                                    synth.setGeneralMidiMode(0);\n+                                    reset();\n+                                    break;\n+                                case 0x03:  \/\/ General MidI Level 2 On\n+                                    synth.setGeneralMidiMode(2);\n+                                    reset();\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n@@ -212,2 +216,26 @@\n-                        case 0x04:  \/\/ DLS Static Voice Allocation On\n-                            synth.voice_allocation_mode = 1;\n+                        case 0x0A: \/\/ DLS Message\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01:  \/\/ DLS On\n+                                    if (synth.getGeneralMidiMode() == 0)\n+                                        synth.setGeneralMidiMode(1);\n+                                    synth.voice_allocation_mode = 1;\n+                                    reset();\n+                                    break;\n+                                case 0x02:  \/\/ DLS Off\n+                                    synth.setGeneralMidiMode(0);\n+                                    synth.voice_allocation_mode = 0;\n+                                    reset();\n+                                    break;\n+                                case 0x03:  \/\/ DLS Static Voice Allocation Off\n+                                    synth.voice_allocation_mode = 0;\n+                                    break;\n+                                case 0x04:  \/\/ DLS Static Voice Allocation On\n+                                    synth.voice_allocation_mode = 1;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n@@ -215,0 +243,1 @@\n+\n@@ -217,5 +246,0 @@\n-                        }\n-                        break;\n-\n-                    default:\n-                        break;\n@@ -230,0 +254,3 @@\n+                    if (data.length < 4) {\n+                        return;\n+                    }\n@@ -233,29 +260,3 @@\n-                    case 0x04: \/\/ Device Control\n-\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01: \/\/ Master Volume\n-                        case 0x02: \/\/ Master Balane\n-                        case 0x03: \/\/ Master fine tuning\n-                        case 0x04: \/\/ Master coarse tuning\n-                            int val = (data[5] & 0x7F)\n-                                    + ((data[6] & 0x7F) * 128);\n-                            if (subid2 == 0x01)\n-                                setVolume(val);\n-                            else if (subid2 == 0x02)\n-                                setBalance(val);\n-                            else if (subid2 == 0x03)\n-                                setFineTuning(val);\n-                            else if (subid2 == 0x04)\n-                                setCoarseTuning(val);\n-                            break;\n-                        case 0x05: \/\/ Global Parameter Control\n-                            int ix = 5;\n-                            int slotPathLen = (data[ix++] & 0xFF);\n-                            int paramWidth = (data[ix++] & 0xFF);\n-                            int valueWidth = (data[ix++] & 0xFF);\n-                            int[] slotPath = new int[slotPathLen];\n-                            for (int i = 0; i < slotPathLen; i++) {\n-                                int msb = (data[ix++] & 0xFF);\n-                                int lsb = (data[ix++] & 0xFF);\n-                                slotPath[i] = msb * 128 + lsb;\n+                        case 0x04: \/\/ Device Control\n+                            if (data.length < 5) {\n+                                break;\n@@ -263,12 +264,52 @@\n-                            int paramCount = (data.length - 1 - ix)\n-                                    \/ (paramWidth + valueWidth);\n-                            long[] params = new long[paramCount];\n-                            long[] values = new long[paramCount];\n-                            for (int i = 0; i < paramCount; i++) {\n-                                values[i] = 0;\n-                                for (int j = 0; j < paramWidth; j++)\n-                                    params[i] = params[i] * 128\n-                                            + (data[ix++] & 0xFF);\n-                                for (int j = 0; j < valueWidth; j++)\n-                                    values[i] = values[i] * 128\n-                                            + (data[ix++] & 0xFF);\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01: \/\/ Master Volume\n+                                case 0x02: \/\/ Master Balane\n+                                case 0x03: \/\/ Master fine tuning\n+                                case 0x04: \/\/ Master coarse tuning\n+                                    if (data.length < 7) {\n+                                        break;\n+                                    }\n+                                    int val = (data[5] & 0x7F)\n+                                            + ((data[6] & 0x7F) * 128);\n+                                    if (subid2 == 0x01)\n+                                        setVolume(val);\n+                                    else if (subid2 == 0x02)\n+                                        setBalance(val);\n+                                    else if (subid2 == 0x03)\n+                                        setFineTuning(val);\n+                                    else if (subid2 == 0x04)\n+                                        setCoarseTuning(val);\n+                                    break;\n+                                case 0x05: \/\/ Global Parameter Control\n+                                    if (data.length < 6) {\n+                                        break;\n+                                    }\n+                                    int ix = 5;\n+                                    int slotPathLen = (data[ix++] & 0xFF);\n+                                    if (data.length < slotPathLen * 2 + 8) {\n+                                        break;\n+                                    }\n+                                    int paramWidth = (data[ix++] & 0xFF);\n+                                    int valueWidth = (data[ix++] & 0xFF);\n+                                    int[] slotPath = new int[slotPathLen];\n+                                    for (int i = 0; i < slotPathLen; i++) {\n+                                        int msb = (data[ix++] & 0xFF);\n+                                        int lsb = (data[ix++] & 0xFF);\n+                                        slotPath[i] = msb * 128 + lsb;\n+                                    }\n+                                    int paramCount = (data.length - 1 - ix)\n+                                            \/ (paramWidth + valueWidth);\n+                                    if (paramCount < 1) {\n+                                        break;\n+                                    }\n+                                    long[] params = new long[paramCount];\n+                                    long[] values = new long[paramCount];\n+                                    for (int i = 0; i < paramCount; i++) {\n+                                        values[i] = 0;\n+                                        for (int j = 0; j < paramWidth; j++)\n+                                            params[i] = params[i] * 128\n+                                                    + (data[ix++] & 0xFF);\n+                                        for (int j = 0; j < valueWidth; j++)\n+                                            values[i] = values[i] * 128\n+                                                    + (data[ix++] & 0xFF);\n@@ -276,0 +317,5 @@\n+                                    }\n+                                    globalParameterControlChange(slotPath, params, values);\n+                                    break;\n+                                default:\n+                                    break;\n@@ -277,3 +323,0 @@\n-                            globalParameterControlChange(slotPath, params, values);\n-                            break;\n-                        default:\n@@ -281,2 +324,0 @@\n-                        }\n-                        break;\n@@ -284,17 +325,23 @@\n-                    case 0x08:  \/\/ MIDI Tuning Standard\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x02:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(0,\n-                                    data[5] & 0xFF));\n-                            tuning.load(data);\n-                            SoftVoice[] voices = synth.getVoices();\n-                            for (int i = 0; i < voices.length; i++)\n-                                if (voices[i].active)\n-                                    if (voices[i].tuning == tuning)\n-                                        voices[i].updateTuning(tuning);\n-                            break;\n-                        }\n-                        case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n+                        case 0x08:  \/\/ MIDI Tuning Standard\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x02:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n+                                {\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n+                                    if (data.length < 6) {\n+                                        break;\n+                                    }\n+                                    SoftTuning tuning = synth.getTuning(new Patch(0,\n+                                            data[5] & 0xFF));\n+                                    tuning.load(data);\n+                                    SoftVoice[] voices = synth.getVoices();\n+                                    for (int i = 0; i < voices.length; i++)\n+                                        if (voices[i].active)\n+                                            if (voices[i].tuning == tuning)\n+                                                voices[i].updateTuning(tuning);\n+                                    break;\n+                                }\n+                                case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n@@ -302,13 +349,16 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(\n-                                    data[5] & 0xFF, data[6] & 0xFF));\n-                            tuning.load(data);\n-                            SoftVoice[] voices = synth.getVoices();\n-                            for (int i = 0; i < voices.length; i++)\n-                                if (voices[i].active)\n-                                    if (voices[i].tuning == tuning)\n-                                        voices[i].updateTuning(tuning);\n-                            break;\n-                        }\n-                        case 0x08:  \/\/ scale\/octave tuning 1-byte form\n+                                {\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n+                                    if (data.length < 7) {\n+                                        break;\n+                                    }\n+                                    SoftTuning tuning = synth.getTuning(new Patch(\n+                                            data[5] & 0xFF, data[6] & 0xFF));\n+                                    tuning.load(data);\n+                                    SoftVoice[] voices = synth.getVoices();\n+                                    for (int i = 0; i < voices.length; i++)\n+                                        if (voices[i].active)\n+                                            if (voices[i].tuning == tuning)\n+                                                voices[i].updateTuning(tuning);\n+                                    break;\n+                                }\n+                                case 0x08:  \/\/ scale\/octave tuning 1-byte form\n@@ -316,1 +366,1 @@\n-                        case 0x09:  \/\/ scale\/octave tuning 2-byte form\n+                                case 0x09:  \/\/ scale\/octave tuning 2-byte form\n@@ -318,32 +368,21 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n-                            SoftTuning tuning = new SoftTuning(data);\n-                            int channelmask = (data[5] & 0xFF) * 16384\n-                                    + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n-                            SoftChannel[] channels = synth.channels;\n-                            for (int i = 0; i < channels.length; i++)\n-                                if ((channelmask & (1 << i)) != 0)\n-                                    channels[i].tuning = tuning;\n-                            SoftVoice[] voices = synth.getVoices();\n-                            for (int i = 0; i < voices.length; i++)\n-                                if (voices[i].active)\n-                                    if ((channelmask & (1 << (voices[i].channel))) != 0)\n-                                        voices[i].updateTuning(tuning);\n-                            break;\n-                        }\n-                        default:\n-                            break;\n-                        }\n-                        break;\n-                    case 0x09:  \/\/ Control Destination Settings\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01: \/\/ Channel Pressure\n-                        {\n-                            int[] destinations = new int[(data.length - 7) \/ 2];\n-                            int[] ranges = new int[(data.length - 7) \/ 2];\n-                            int ix = 0;\n-                            for (int j = 6; j < data.length - 1; j += 2) {\n-                                destinations[ix] = data[j] & 0xFF;\n-                                ranges[ix] = data[j + 1] & 0xFF;\n-                                ix++;\n+                                {\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    SoftTuning tuning = new SoftTuning(data);\n+                                    int channelmask = (data[5] & 0xFF) * 16384\n+                                            + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n+                                    SoftChannel[] channels = synth.channels;\n+                                    for (int i = 0; i < channels.length; i++)\n+                                        if ((channelmask & (1 << i)) != 0)\n+                                            channels[i].tuning = tuning;\n+                                    SoftVoice[] voices = synth.getVoices();\n+                                    for (int i = 0; i < voices.length; i++)\n+                                        if (voices[i].active)\n+                                            if ((channelmask & (1 << (voices[i].channel))) != 0)\n+                                                voices[i].updateTuning(tuning);\n+                                    break;\n+                                }\n+                                default:\n+                                    break;\n@@ -351,4 +390,0 @@\n-                            int channel = data[5] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            softchannel.mapChannelPressureToDestination(\n-                                    destinations, ranges);\n@@ -356,10 +391,3 @@\n-                        }\n-                        case 0x02: \/\/ Poly Pressure\n-                        {\n-                            int[] destinations = new int[(data.length - 7) \/ 2];\n-                            int[] ranges = new int[(data.length - 7) \/ 2];\n-                            int ix = 0;\n-                            for (int j = 6; j < data.length - 1; j += 2) {\n-                                destinations[ix] = data[j] & 0xFF;\n-                                ranges[ix] = data[j + 1] & 0xFF;\n-                                ix++;\n+                        case 0x09:  \/\/ Control Destination Settings\n+                            if (data.length < 5) {\n+                                break;\n@@ -367,15 +395,62 @@\n-                            int channel = data[5] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            softchannel.mapPolyPressureToDestination(\n-                                    destinations, ranges);\n-                            break;\n-                        }\n-                        case 0x03: \/\/ Control Change\n-                        {\n-                            int[] destinations = new int[(data.length - 7) \/ 2];\n-                            int[] ranges = new int[(data.length - 7) \/ 2];\n-                            int ix = 0;\n-                            for (int j = 7; j < data.length - 1; j += 2) {\n-                                destinations[ix] = data[j] & 0xFF;\n-                                ranges[ix] = data[j + 1] & 0xFF;\n-                                ix++;\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01: \/\/ Channel Pressure\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    int[] destinations = new int[(data.length - 6) \/ 2];\n+                                    int[] ranges = new int[(data.length - 6) \/ 2];\n+                                    int ix = 0;\n+                                    for (int j = 6; j < data.length - 1; j += 2) {\n+                                        destinations[ix] = data[j] & 0xFF;\n+                                        ranges[ix] = data[j + 1] & 0xFF;\n+                                        ix++;\n+                                    }\n+                                    int channel = data[5] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    softchannel.mapChannelPressureToDestination(\n+                                            destinations, ranges);\n+                                    break;\n+                                }\n+                                case 0x02: \/\/ Poly Pressure\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    int[] destinations = new int[(data.length - 6) \/ 2];\n+                                    int[] ranges = new int[(data.length - 6) \/ 2];\n+                                    int ix = 0;\n+                                    for (int j = 6; j < data.length - 1; j += 2) {\n+                                        destinations[ix] = data[j] & 0xFF;\n+                                        ranges[ix] = data[j + 1] & 0xFF;\n+                                        ix++;\n+                                    }\n+                                    int channel = data[5] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    softchannel.mapPolyPressureToDestination(\n+                                            destinations, ranges);\n+                                    break;\n+                                }\n+                                case 0x03: \/\/ Control Change\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    int[] destinations = new int[(data.length - 7) \/ 2];\n+                                    int[] ranges = new int[(data.length - 7) \/ 2];\n+                                    int ix = 0;\n+                                    for (int j = 7; j < data.length - 1; j += 2) {\n+                                        destinations[ix] = data[j] & 0xFF;\n+                                        ranges[ix] = data[j + 1] & 0xFF;\n+                                        ix++;\n+                                    }\n+                                    int channel = data[5] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    int control = data[6] & 0xFF;\n+                                    softchannel.mapControlToDestination(control,\n+                                            destinations, ranges);\n+                                    break;\n+                                }\n+                                default:\n+                                    break;\n@@ -383,8 +458,0 @@\n-                            int channel = data[5] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            int control = data[6] & 0xFF;\n-                            softchannel.mapControlToDestination(control,\n-                                    destinations, ranges);\n-                            break;\n-                        }\n-                        default:\n@@ -392,2 +459,0 @@\n-                        }\n-                        break;\n@@ -395,13 +460,20 @@\n-                    case 0x0A:  \/\/ Key Based Instrument Control\n-                    {\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01: \/\/ Basic Message\n-                            int channel = data[5] & 0xFF;\n-                            int keynumber = data[6] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            for (int j = 7; j < data.length - 1; j += 2) {\n-                                int controlnumber = data[j] & 0xFF;\n-                                int controlvalue = data[j + 1] & 0xFF;\n-                                softchannel.controlChangePerNote(keynumber,\n-                                        controlnumber, controlvalue);\n+                        case 0x0A:  \/\/ Key Based Instrument Control\n+                        {\n+                            if (data.length < 8 || (data[4] & 0xFF) != 0x01) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01: \/\/ Basic Message\n+                                    int channel = data[5] & 0xFF;\n+                                    int keynumber = data[6] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    for (int j = 7; j < data.length - 1; j += 2) {\n+                                        int controlnumber = data[j] & 0xFF;\n+                                        int controlvalue = data[j + 1] & 0xFF;\n+                                        softchannel.controlChangePerNote(keynumber,\n+                                                controlnumber, controlvalue);\n+                                    }\n+                                    break;\n+                                default:\n+                                    break;\n@@ -410,0 +482,1 @@\n+                        }\n@@ -412,5 +485,0 @@\n-                        }\n-                        break;\n-                    }\n-                    default:\n-                        break;\n@@ -420,1 +488,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftMainMixer.java","additions":316,"deletions":249,"binary":false,"changes":565,"status":"modified"},{"patch":"@@ -92,0 +92,4 @@\n+        if (data.length < 2) {\n+            return;\n+        }\n+\n@@ -93,0 +97,4 @@\n+            if (data.length < 4) {\n+                return;\n+            }\n+\n@@ -96,0 +104,3 @@\n+                if (data.length < 5) {\n+                    break;\n+                }\n@@ -103,1 +114,0 @@\n-                    name = new String(data, 6, 16, US_ASCII);\n@@ -105,0 +115,4 @@\n+                    if (data.length < 128 * 3 + r) {\n+                        break;\n+                    }\n+                    name = new String(data, 6, 16, US_ASCII);\n@@ -118,0 +132,3 @@\n+                    if (data.length < 7) {\n+                        break;\n+                    }\n@@ -120,0 +137,3 @@\n+                    if (data.length < ll * 4 + r) {\n+                        break;\n+                    }\n@@ -135,0 +155,3 @@\n+                    if (data.length < 407) {\n+                        break;\n+                    }\n@@ -152,0 +175,3 @@\n+                    if (data.length < 35) {\n+                        break;\n+                    }\n@@ -166,0 +192,3 @@\n+                    if (data.length < 47) {\n+                        break;\n+                    }\n@@ -180,0 +209,3 @@\n+                    if (data.length < 8) {\n+                        break;\n+                    }\n@@ -181,0 +213,3 @@\n+                    if (data.length < ll * 4 + 8) {\n+                        break;\n+                    }\n@@ -196,0 +231,3 @@\n+                    if (data.length < 20) {\n+                        break;\n+                    }\n@@ -207,0 +245,3 @@\n+                    if (data.length < 32) {\n+                        break;\n+                    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftTuning.java","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -468,3 +468,2 @@\n-     * @throws ArrayIndexOutOfBoundsException if {@code componentIdx}\n-     *         is greater than the number of components or\n-     *         less than zero\n+     * @throws ArrayIndexOutOfBoundsException if {@code componentIdx} is greater\n+     *         than or equal to the number of components or less than zero\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorModel.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-    \/** Return value form class method if OK is chosen. *\/\n+    \/** Return value from class method if OK is chosen. *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JOptionPane.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1411,1 +1411,1 @@\n-        if (dir != null && FilePane.usesShellFolder(fc)) {\n+        if (dir != null) {\n@@ -1413,11 +1413,7 @@\n-                ShellFolder shellFolder = ShellFolder.getShellFolder(dir);\n-\n-                if (shellFolder.isLink()) {\n-                    File linkedTo = shellFolder.getLinkLocation();\n-\n-                    \/\/ If linkedTo is null we try to use dir\n-                    if (linkedTo != null) {\n-                        if (fc.isTraversable(linkedTo)) {\n-                            dir = linkedTo;\n-                        } else {\n-                            return;\n+                File linkedTo = null;\n+                if (FilePane.usesShellFolder(fc)) {\n+                    ShellFolder shellFolder = ShellFolder.getShellFolder(dir);\n+                    if (shellFolder.isLink()) {\n+                        linkedTo = shellFolder.getLinkLocation();\n+                        if (linkedTo == null) {\n+                            dir = shellFolder;\n@@ -1425,0 +1421,7 @@\n+                    }\n+                } else if ( fc.getFileSystemView().isLink(dir)){\n+                    linkedTo = fc.getFileSystemView().getLinkLocation(dir);\n+                }\n+                if (linkedTo != null) {\n+                    if (fc.isTraversable(linkedTo)) {\n+                        dir = linkedTo;\n@@ -1426,1 +1429,1 @@\n-                        dir = shellFolder;\n+                        return;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicFileChooserUI.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -782,8 +782,0 @@\n-            } else if (c instanceof JCheckBox) {\n-                if (UIManager.getColor(\"CheckBox.disabledText\") != null) {\n-                    return UIManager.getColor(\"CheckBox.disabledText\");\n-                }\n-            } else if (c instanceof JRadioButton) {\n-                if (UIManager.getColor(\"RadioButton.disabledText\") != null) {\n-                    return UIManager.getColor(\"RadioButton.disabledText\");\n-                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthStyle.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -849,0 +849,17 @@\n+    @SuppressWarnings(\"unchecked\")\n+    public static float getTracking(Map<?, ?> map) {\n+        if (map != null) {\n+            AttributeValues av = null;\n+            if (map instanceof AttributeMap &&\n+                    ((AttributeMap) map).getValues() != null) {\n+                av = ((AttributeMap)map).getValues();\n+            } else if (map.get(TextAttribute.TRACKING) != null) {\n+                av = AttributeValues.fromMap((Map<Attribute, ?>)map);\n+            }\n+            if (av != null) {\n+                return av.tracking;\n+            }\n+        }\n+        return 0;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/AttributeValues.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+  float advTracking;\n+\n@@ -113,0 +115,2 @@\n+\n+    advTracking = font.getSize() * AttributeValues.getTracking(atts);\n@@ -381,1 +385,1 @@\n-    if (charinfo == null || idx >= charinfo.length) {\n+    if (charinfo == null || idx >= charinfo.length || charinfo[idx] == 0) {\n@@ -384,1 +388,1 @@\n-        return charinfo[idx];\n+        return charinfo[idx] + advTracking;\n@@ -480,0 +484,2 @@\n+    final float epsilon = 0.005f;\n+\n@@ -482,0 +488,5 @@\n+\n+    if (advTracking > 0) {\n+      width += advTracking;\n+    }\n+\n@@ -483,1 +494,1 @@\n-    while (width >= 0 && ++start < length) {\n+    while (width >= -epsilon && ++start < length) {\n@@ -489,1 +500,3 @@\n-      width -= adv;\n+      if (adv != 0) {\n+          width -= adv + advTracking;\n+      }\n@@ -505,1 +518,4 @@\n-      a += charinfo[cidx];\n+      float adv = charinfo[cidx];\n+      if (adv != 0) {\n+          a += adv + advTracking;\n+      }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/ExtendedTextSourceLabel.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -200,2 +200,0 @@\n-            Font2D f2d = FontUtilities.getFont2D(font);\n-            FontStrike strike = f2d.getStrike(font, frc);\n@@ -206,0 +204,1 @@\n+                float prevPos = 0;\n@@ -208,2 +207,3 @@\n-                    for (int i = j, n = 0; n < glyphs.length; i += 2) {\n-                        if (strike.getGlyphAdvance(glyphs[n++]) != 0) { \/\/ might be an inadequate test\n+                    for (int i = j; i < positions.length; i += 2) {\n+                        if (i == j || prevPos != positions[i]) {\n+                            prevPos = positions[i];\n@@ -212,0 +212,2 @@\n+                        } else if (prevPos == positions[i]) {\n+                            positions[i] = positions[i - 2];\n@@ -214,1 +216,0 @@\n-                    positions[positions.length-2+j] += delta;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StandardGlyphVector.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1237,1 +1237,0 @@\n-        String respStr = \"\";\n@@ -1244,1 +1243,1 @@\n-            return respStr;\n+            return \"\";\n@@ -1252,7 +1251,1 @@\n-        for (int i=0; i < fields.length; i++) {\n-            if (i == (fields.length - 1)) {\n-                respStr = respStr.concat(fields[i]);\n-            } else {\n-                respStr = respStr.concat(fields[i] + \", \");\n-            }\n-        }\n+        String respStr = String.join(\", \", fields);\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/DescriptorSupport.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1181,0 +1181,7 @@\n+         * @implNote The {@code read} method of the {@code InputStream}\n+         * returned by the default implementation of this method will\n+         * throw an {@code IOException} with the {@linkplain Thread#isInterrupted()\n+         * thread interrupt status set} if the thread is interrupted\n+         * while blocking on read. In that case, the request will also be\n+         * cancelled and the {@code InputStream} will be closed.\n+         *\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpResponse.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1011,0 +1011,1 @@\n+        if (debug.on()) debug.log(\"Close all streams\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -484,1 +484,6 @@\n-                    \/\/ continue\n+                    try {\n+                        close();\n+                    } catch (IOException ignored) {\n+                    }\n+                    Thread.currentThread().interrupt();\n+                    throw new IOException(ex);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseSubscribers.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -276,0 +276,1 @@\n+        assert pendingResponseSubscriber == null;\n@@ -475,2 +476,8 @@\n-            if (cancelled) connection.dropDataFrame((DataFrame) frame);\n-            else receiveDataFrame((DataFrame) frame);\n+            if (cancelled) {\n+                if (debug.on()) {\n+                    debug.log(\"request cancelled or stream closed: dropping data frame\");\n+                }\n+                connection.dropDataFrame((DataFrame) frame);\n+            } else {\n+                receiveDataFrame((DataFrame) frame);\n+            }\n@@ -1286,0 +1293,1 @@\n+\n@@ -1287,1 +1295,3 @@\n-            if (responseSubscriber != null || pendingResponseSubscriber != null)\n+            if (responseSubscriber != null || pendingResponseSubscriber != null) {\n+                if (debug.on())\n+                    debug.log(\"stream %s closing due to %s\", streamid, (Object)errorRef.get());\n@@ -1289,0 +1299,10 @@\n+            } else {\n+                if (debug.on())\n+                    debug.log(\"stream %s closing due to %s before subscriber registered\",\n+                        streamid, (Object)errorRef.get());\n+            }\n+        } else {\n+            if (debug.on()) {\n+                debug.log(\"stream %s already closed due to %s\",\n+                        streamid, (Object)errorRef.get());\n+            }\n@@ -1290,0 +1310,1 @@\n+\n@@ -1333,0 +1354,14 @@\n+        var s = responseSubscriber == null\n+                ? pendingResponseSubscriber\n+                : responseSubscriber;\n+        if (debug.on()) debug.log(\"subscriber is %s\", s);\n+        if (s instanceof Http2StreamResponseSubscriber<?> sw) {\n+            if (debug.on()) debug.log(\"closing response subscriber stream %s\", streamid);\n+            \/\/ if the subscriber has already completed,\n+            \/\/ there is nothing to do...\n+            if (!sw.completed()) {\n+                \/\/ otherwise make sure it will be completed\n+                var cause = errorRef.get();\n+                sw.complete(cause == null ? new IOException(\"stream closed\") : cause);\n+            }\n+        }\n@@ -1557,0 +1592,1 @@\n+\n@@ -1561,0 +1597,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.concurrent.CompletableFuture;\n@@ -179,0 +178,8 @@\n+    \/**\n+     * {@return true if this subscriber has already completed, either normally\n+     * or abnormally}\n+     *\/\n+    public boolean completed() {\n+        return completed.get();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -130,1 +130,6 @@\n-    JDK20(\"20\");\n+    JDK20(\"20\"),\n+\n+    \/**\n+      * 21, tbd\n+      *\/\n+    JDK21(\"21\");\n@@ -182,0 +187,1 @@\n+        case JDK21  -> Target.JDK1_21;\n@@ -315,0 +321,1 @@\n+        case JDK21  -> RELEASE_21;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4207,1 +4207,1 @@\n-        Type site = types.removeWildcards(tree.type);\n+        Type site = types.capture(tree.type);\n@@ -4213,1 +4213,3 @@\n-                                        .map(rc -> types.memberType(site, rc)).collect(List.collector());\n+                                        .map(rc -> types.memberType(site, rc))\n+                                        .map(t -> types.upward(t, types.captures(t)).baseType())\n+                                        .collect(List.collector());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -124,1 +124,2 @@\n-        V64(64, 0);   \/\/ JDK 20\n+        V64(64, 0),   \/\/ JDK 20\n+        V65(65, 0);   \/\/ JDK 21\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,1 +97,4 @@\n-    JDK1_20(\"20\", 64, 0);\n+    JDK1_20(\"20\", 64, 0),\n+\n+    \/** JDK 21. *\/\n+    JDK1_21(\"21\", 65, 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -611,0 +611,9 @@\n+        return parse(filename, content, false);\n+    }\n+\n+    \/** Parse contents of input stream.\n+     *  @param filename     The name of the file from which input stream comes.\n+     *  @param content      The characters to be parsed.\n+     *  @param silent       true if TaskListeners should not be notified\n+     *\/\n+    private JCCompilationUnit parse(JavaFileObject filename, CharSequence content, boolean silent) {\n@@ -617,1 +626,1 @@\n-            if (!taskListener.isEmpty()) {\n+            if (!taskListener.isEmpty() && !silent) {\n@@ -633,1 +642,1 @@\n-        if (content != null && !taskListener.isEmpty()) {\n+        if (content != null && !taskListener.isEmpty() && !silent) {\n@@ -1803,1 +1812,1 @@\n-            JCTree.JCCompilationUnit t = parse(fo, fo.getCharContent(false));\n+            JCTree.JCCompilationUnit t = parse(fo, fo.getCharContent(false), true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-@SupportedSourceVersion(SourceVersion.RELEASE_20)\n+@SupportedSourceVersion(SourceVersion.RELEASE_21)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,1402 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.base\n+header exports java\/io,java\/lang,java\/lang\/annotation,java\/lang\/constant,java\/lang\/foreign,java\/lang\/invoke,java\/lang\/module,java\/lang\/ref,java\/lang\/reflect,java\/lang\/runtime,java\/math,java\/net,java\/net\/spi,java\/nio,java\/nio\/channels,java\/nio\/channels\/spi,java\/nio\/charset,java\/nio\/charset\/spi,java\/nio\/file,java\/nio\/file\/attribute,java\/nio\/file\/spi,java\/security,java\/security\/cert,java\/security\/interfaces,java\/security\/spec,java\/text,java\/text\/spi,java\/time,java\/time\/chrono,java\/time\/format,java\/time\/temporal,java\/time\/zone,java\/util,java\/util\/concurrent,java\/util\/concurrent\/atomic,java\/util\/concurrent\/locks,java\/util\/function,java\/util\/jar,java\/util\/random,java\/util\/regex,java\/util\/spi,java\/util\/stream,java\/util\/zip,javax\/crypto,javax\/crypto\/interfaces,javax\/crypto\/spec,javax\/net,javax\/net\/ssl,javax\/security\/auth,javax\/security\/auth\/callback,javax\/security\/auth\/login,javax\/security\/auth\/spi,javax\/security\/auth\/x500,javax\/security\/cert,jdk\/internal\/event[jdk.jfr],jdk\/internal\/vm\/vector[jdk.incubator.vector] uses java\/lang\/System$LoggerFinder,java\/net\/ContentHandlerFactory,java\/net\/spi\/InetAddressResolverProvider,java\/net\/spi\/URLStreamHandlerProvider,java\/nio\/channels\/spi\/AsynchronousChannelProvider,java\/nio\/channels\/spi\/SelectorProvider,java\/nio\/charset\/spi\/CharsetProvider,java\/nio\/file\/spi\/FileSystemProvider,java\/nio\/file\/spi\/FileTypeDetector,java\/security\/Provider,java\/text\/spi\/BreakIteratorProvider,java\/text\/spi\/CollatorProvider,java\/text\/spi\/DateFormatProvider,java\/text\/spi\/DateFormatSymbolsProvider,java\/text\/spi\/DecimalFormatSymbolsProvider,java\/text\/spi\/NumberFormatProvider,java\/time\/chrono\/AbstractChronology,java\/time\/chrono\/Chronology,java\/time\/zone\/ZoneRulesProvider,java\/util\/random\/RandomGenerator,java\/util\/spi\/CalendarDataProvider,java\/util\/spi\/CalendarNameProvider,java\/util\/spi\/CurrencyNameProvider,java\/util\/spi\/LocaleNameProvider,java\/util\/spi\/ResourceBundleControlProvider,java\/util\/spi\/ResourceBundleProvider,java\/util\/spi\/TimeZoneNameProvider,java\/util\/spi\/ToolProvider,javax\/security\/auth\/spi\/LoginModule,jdk\/internal\/io\/JdkConsoleProvider,jdk\/internal\/logger\/DefaultLoggerFinder,sun\/text\/spi\/JavaTimeDateTimePatternProvider,sun\/util\/locale\/provider\/LocaleDataMetaInfo,sun\/util\/resources\/LocaleData$CommonResourceBundleProvider,sun\/util\/resources\/LocaleData$SupplementaryResourceBundleProvider,sun\/util\/spi\/CalendarProvider provides interface\\u0020;java\/nio\/file\/spi\/FileSystemProvider\\u0020;impls\\u0020;jdk\/internal\/jrtfs\/JrtFileSystemProvider,interface\\u0020;java\/util\/random\/RandomGenerator\\u0020;impls\\u0020;java\/security\/SecureRandom\\u005C;u002C;java\/util\/Random\\u005C;u002C;java\/util\/SplittableRandom target linux-amd64 flags 8000\n+\n+class name java\/io\/BufferedInputStream\n+method name transferTo descriptor (Ljava\/io\/OutputStream;)J thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/Console\n+header extends java\/lang\/Object implements java\/io\/Flushable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+\n+class name java\/io\/PrintStream\n+header extends java\/io\/FilterOutputStream implements java\/lang\/Appendable,java\/io\/Closeable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/io\/PushbackInputStream\n+method name transferTo descriptor (Ljava\/io\/OutputStream;)J thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/SequenceInputStream\n+method name transferTo descriptor (Ljava\/io\/OutputStream;)J thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/lang\/AbstractStringBuilder\n+header extends java\/lang\/Object implements java\/lang\/Appendable,java\/lang\/CharSequence sealed true flags 420\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/Character$UnicodeBlock\n+field name ARABIC_EXTENDED_C descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name DEVANAGARI_EXTENDED_A descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name KAWI descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name KAKTOVIK_NUMERALS descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name CYRILLIC_EXTENDED_D descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name NAG_MUNDARI descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name CJK_UNIFIED_IDEOGRAPHS_EXTENSION_H descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+\n+class name java\/lang\/Character$UnicodeScript\n+field name KAWI descriptor Ljava\/lang\/Character$UnicodeScript; flags 4019\n+field name NAG_MUNDARI descriptor Ljava\/lang\/Character$UnicodeScript; flags 4019\n+\n+class name java\/lang\/Class\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/reflect\/GenericDeclaration,java\/lang\/reflect\/Type,java\/lang\/reflect\/AnnotatedElement,java\/lang\/invoke\/TypeDescriptor$OfField,java\/lang\/constant\/Constable flags 31 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;Ljava\/lang\/reflect\/GenericDeclaration;Ljava\/lang\/reflect\/Type;Ljava\/lang\/reflect\/AnnotatedElement;Ljava\/lang\/invoke\/TypeDescriptor$OfField<Ljava\/lang\/Class<*>;>;Ljava\/lang\/constant\/Constable;\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/Compiler\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/lang\/Deprecated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;MODULE;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;TYPE;})\n+\n+class name java\/lang\/Double\n+-method name isFinite descriptor (D)Z\n+method name isFinite descriptor (D)Z flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n+class name java\/lang\/Float\n+-method name isFinite descriptor (F)Z\n+method name isFinite descriptor (F)Z flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name float16ToFloat descriptor (S)F flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name floatToFloat16 descriptor (F)S flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n+class name java\/lang\/IllegalCallerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/Integer\n+-method name compareUnsigned descriptor (II)I\n+-method name reverse descriptor (I)I\n+method name compareUnsigned descriptor (II)I flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name reverse descriptor (I)I flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n+class name java\/lang\/LayerInstantiationException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/Long\n+-method name compareUnsigned descriptor (JJ)I\n+-method name reverse descriptor (J)J\n+method name compareUnsigned descriptor (JJ)I flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name reverse descriptor (J)J flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n+class name java\/lang\/Module\n+method name isNativeAccessEnabled descriptor ()Z flags 1 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+\n+class name java\/lang\/ModuleLayer$Controller\n+method name enableNativeAccess descriptor (Ljava\/lang\/Module;)Ljava\/lang\/ModuleLayer$Controller; flags 1 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;) runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+class name java\/lang\/NamedPackage\n+header extends java\/lang\/Object flags 20\n+\n+class name java\/lang\/Thread$Builder\n+header extends java\/lang\/Object nestHost java\/lang\/Thread sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;VIRTUAL_THREADS;)\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfPlatform outerClass java\/lang\/Thread$Builder innerClassName OfPlatform flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/lang\/Thread$Builder$OfPlatform\n+header extends java\/lang\/Object implements java\/lang\/Thread$Builder nestHost java\/lang\/Thread sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;VIRTUAL_THREADS;)\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfPlatform outerClass java\/lang\/Thread$Builder innerClassName OfPlatform flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/lang\/Thread$Builder$OfVirtual\n+header extends java\/lang\/Object implements java\/lang\/Thread$Builder nestHost java\/lang\/Thread sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;VIRTUAL_THREADS;)\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/lang\/ThreadDeath\n+header extends java\/lang\/Error flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"20\")\n+\n+class name java\/lang\/constant\/ClassDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfField sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfField<Ljava\/lang\/constant\/ClassDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+method name ofInternalName descriptor (Ljava\/lang\/String;)Ljava\/lang\/constant\/ClassDesc; flags 9\n+\n+class name java\/lang\/constant\/ConstantDesc\n+header extends java\/lang\/Object sealed true flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/constant\/DirectMethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/MethodHandleDesc nestMembers java\/lang\/constant\/DirectMethodHandleDesc$Kind sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodTypeDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfMethod sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfMethod<Ljava\/lang\/constant\/ClassDesc;Ljava\/lang\/constant\/MethodTypeDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfMethod outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfMethod flags 609\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+-class name java\/lang\/foreign\/AbstractLayout\n+\n+-class name java\/lang\/foreign\/Addressable\n+\n+class name java\/lang\/foreign\/Arena\n+header extends java\/lang\/Object implements java\/lang\/foreign\/SegmentAllocator,java\/lang\/AutoCloseable flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+method name allocate descriptor (JJ)Ljava\/lang\/foreign\/MemorySegment; flags 1\n+method name scope descriptor ()Ljava\/lang\/foreign\/SegmentScope; flags 401\n+method name close descriptor ()V flags 401\n+method name isCloseableBy descriptor (Ljava\/lang\/Thread;)Z flags 401\n+method name openConfined descriptor ()Ljava\/lang\/foreign\/Arena; flags 9\n+method name openShared descriptor ()Ljava\/lang\/foreign\/Arena; flags 9\n+\n+class name java\/lang\/foreign\/FunctionDescriptor\n+header extends java\/lang\/Object sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+-method name returnLayout descriptor ()Ljava\/util\/Optional;\n+-method name argumentLayouts descriptor ()Ljava\/util\/List;\n+-method name asVariadic descriptor ([Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/FunctionDescriptor;\n+-method name firstVariadicArgumentIndex descriptor ()I\n+-method name appendArgumentLayouts descriptor ([Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/FunctionDescriptor;\n+-method name insertArgumentLayouts descriptor (I[Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/FunctionDescriptor;\n+-method name changeReturnLayout descriptor (Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/FunctionDescriptor;\n+-method name dropReturnLayout descriptor ()Ljava\/lang\/foreign\/FunctionDescriptor;\n+-method name toString descriptor ()Ljava\/lang\/String;\n+-method name equals descriptor (Ljava\/lang\/Object;)Z\n+-method name hashCode descriptor ()I\n+method name returnLayout descriptor ()Ljava\/util\/Optional; flags 401 signature ()Ljava\/util\/Optional<Ljava\/lang\/foreign\/MemoryLayout;>;\n+method name argumentLayouts descriptor ()Ljava\/util\/List; flags 401 signature ()Ljava\/util\/List<Ljava\/lang\/foreign\/MemoryLayout;>;\n+method name appendArgumentLayouts descriptor ([Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/FunctionDescriptor; flags 481\n+method name insertArgumentLayouts descriptor (I[Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/FunctionDescriptor; flags 481\n+method name changeReturnLayout descriptor (Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/FunctionDescriptor; flags 401\n+method name dropReturnLayout descriptor ()Ljava\/lang\/foreign\/FunctionDescriptor; flags 401\n+method name toMethodType descriptor ()Ljava\/lang\/invoke\/MethodType; flags 401\n+\n+class name java\/lang\/foreign\/GroupLayout\n+header extends java\/lang\/Object implements java\/lang\/foreign\/MemoryLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+-method name memberLayouts descriptor ()Ljava\/util\/List;\n+-method name toString descriptor ()Ljava\/lang\/String;\n+-method name isStruct descriptor ()Z\n+-method name isUnion descriptor ()Z\n+-method name equals descriptor (Ljava\/lang\/Object;)Z\n+-method name hashCode descriptor ()I\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/GroupLayout;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/GroupLayout;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name memberLayouts descriptor ()Ljava\/util\/List; flags 401 signature ()Ljava\/util\/List<Ljava\/lang\/foreign\/MemoryLayout;>;\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/GroupLayout; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/GroupLayout; flags 401\n+\n+class name java\/lang\/foreign\/Linker\n+header extends java\/lang\/Object nestMembers java\/lang\/foreign\/Linker$Option,java\/lang\/foreign\/Linker$Option$CaptureCallState sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/Linker$Option outerClass java\/lang\/foreign\/Linker innerClassName Option flags 609\n+innerclass innerClass java\/lang\/foreign\/Linker$Option$CaptureCallState outerClass java\/lang\/foreign\/Linker$Option innerClassName CaptureCallState flags 609\n+-method name downcallHandle descriptor (Ljava\/lang\/foreign\/Addressable;Ljava\/lang\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle;\n+-method name downcallHandle descriptor (Ljava\/lang\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle;\n+-method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/foreign\/FunctionDescriptor;Ljava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/MemorySegment;\n+-method name downcallType descriptor (Ljava\/lang\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodType;\n+-method name upcallType descriptor (Ljava\/lang\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodType;\n+method name downcallHandle descriptor (Ljava\/lang\/foreign\/MemorySegment;Ljava\/lang\/foreign\/FunctionDescriptor;[Ljava\/lang\/foreign\/Linker$Option;)Ljava\/lang\/invoke\/MethodHandle; flags 81\n+method name downcallHandle descriptor (Ljava\/lang\/foreign\/FunctionDescriptor;[Ljava\/lang\/foreign\/Linker$Option;)Ljava\/lang\/invoke\/MethodHandle; flags 481\n+method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/foreign\/FunctionDescriptor;Ljava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/MemorySegment; flags 401\n+\n+class name java\/lang\/foreign\/Linker$Option\n+header extends java\/lang\/Object nestHost java\/lang\/foreign\/Linker sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/Linker$Option outerClass java\/lang\/foreign\/Linker innerClassName Option flags 609\n+innerclass innerClass java\/lang\/foreign\/Linker$Option$CaptureCallState outerClass java\/lang\/foreign\/Linker$Option innerClassName CaptureCallState flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name firstVariadicArg descriptor (I)Ljava\/lang\/foreign\/Linker$Option; flags 9\n+method name captureCallState descriptor ([Ljava\/lang\/String;)Ljava\/lang\/foreign\/Linker$Option$CaptureCallState; flags 89\n+\n+class name java\/lang\/foreign\/Linker$Option$CaptureCallState\n+header extends java\/lang\/Object implements java\/lang\/foreign\/Linker$Option nestHost java\/lang\/foreign\/Linker sealed true flags 601\n+innerclass innerClass java\/lang\/foreign\/Linker$Option outerClass java\/lang\/foreign\/Linker innerClassName Option flags 609\n+innerclass innerClass java\/lang\/foreign\/Linker$Option$CaptureCallState outerClass java\/lang\/foreign\/Linker$Option innerClassName CaptureCallState flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name layout descriptor ()Ljava\/lang\/foreign\/StructLayout; flags 401\n+method name supported descriptor ()Ljava\/util\/Set; flags 9 signature ()Ljava\/util\/Set<Ljava\/lang\/String;>;\n+\n+-class name java\/lang\/foreign\/MemoryAddress\n+\n+class name java\/lang\/foreign\/MemoryLayout\n+header extends java\/lang\/Object nestMembers java\/lang\/foreign\/MemoryLayout$PathElement sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/MemoryLayout$PathElement outerClass java\/lang\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfBoolean outerClass java\/lang\/foreign\/ValueLayout innerClassName OfBoolean flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfChar outerClass java\/lang\/foreign\/ValueLayout innerClassName OfChar flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name isPadding descriptor ()Z\n+-method name paddingLayout descriptor (J)Ljava\/lang\/foreign\/MemoryLayout;\n+-method name structLayout descriptor ([Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/GroupLayout;\n+-method name unionLayout descriptor ([Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/GroupLayout;\n+method name paddingLayout descriptor (J)Ljava\/lang\/foreign\/PaddingLayout; flags 9\n+method name sequenceLayout descriptor (Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/SequenceLayout; flags 9\n+method name structLayout descriptor ([Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/StructLayout; flags 89\n+method name unionLayout descriptor ([Ljava\/lang\/foreign\/MemoryLayout;)Ljava\/lang\/foreign\/UnionLayout; flags 89\n+\n+class name java\/lang\/foreign\/MemoryLayout$PathElement\n+header extends java\/lang\/Object nestHost java\/lang\/foreign\/MemoryLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/MemoryLayout$PathElement outerClass java\/lang\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/foreign\/MemorySegment\n+header extends java\/lang\/Object sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfChar outerClass java\/lang\/foreign\/ValueLayout innerClassName OfChar flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfBoolean outerClass java\/lang\/foreign\/ValueLayout innerClassName OfBoolean flags 609\n+-method name address descriptor ()Ljava\/lang\/foreign\/MemoryAddress;\n+-method name session descriptor ()Ljava\/lang\/foreign\/MemorySession;\n+-method name mismatch descriptor (Ljava\/lang\/foreign\/MemorySegment;)J\n+-method name ofAddress descriptor (Ljava\/lang\/foreign\/MemoryAddress;JLjava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (Ljava\/lang\/foreign\/MemoryLayout;Ljava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (JLjava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (JJLjava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/MemorySegment;\n+-method name get descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;J)Ljava\/lang\/foreign\/MemoryAddress;\n+-method name set descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;JLjava\/lang\/foreign\/Addressable;)V\n+-method name getAtIndex descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;J)Ljava\/lang\/foreign\/MemoryAddress;\n+-method name setAtIndex descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;JLjava\/lang\/foreign\/Addressable;)V\n+field name NULL descriptor Ljava\/lang\/foreign\/MemorySegment; flags 19\n+method name address descriptor ()J flags 401\n+method name array descriptor ()Ljava\/util\/Optional; flags 401 signature ()Ljava\/util\/Optional<Ljava\/lang\/Object;>;\n+method name scope descriptor ()Ljava\/lang\/foreign\/SegmentScope; flags 401\n+method name mismatch descriptor (Ljava\/lang\/foreign\/MemorySegment;)J flags 1\n+method name ofAddress descriptor (J)Ljava\/lang\/foreign\/MemorySegment; flags 9\n+method name ofAddress descriptor (JJ)Ljava\/lang\/foreign\/MemorySegment; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name ofAddress descriptor (JJLjava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/MemorySegment; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;@Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name ofAddress descriptor (JJLjava\/lang\/foreign\/SegmentScope;Ljava\/lang\/Runnable;)Ljava\/lang\/foreign\/MemorySegment; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name allocateNative descriptor (Ljava\/lang\/foreign\/MemoryLayout;Ljava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JLjava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JJLjava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/MemorySegment; flags 9\n+method name get descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;J)Ljava\/lang\/foreign\/MemorySegment; flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;JLjava\/lang\/foreign\/MemorySegment;)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name getAtIndex descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;J)Ljava\/lang\/foreign\/MemorySegment; flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name setAtIndex descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;JLjava\/lang\/foreign\/MemorySegment;)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name mismatch descriptor (Ljava\/lang\/foreign\/MemorySegment;JJLjava\/lang\/foreign\/MemorySegment;JJ)J flags 9\n+\n+-class name java\/lang\/foreign\/MemorySession\n+\n+class name java\/lang\/foreign\/PaddingLayout\n+header extends java\/lang\/Object implements java\/lang\/foreign\/MemoryLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/PaddingLayout; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/PaddingLayout; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/MemoryLayout; flags 1041\n+\n+class name java\/lang\/foreign\/SegmentAllocator\n+header extends java\/lang\/Object flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;) runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/foreign\/MemoryLayout$PathElement outerClass java\/lang\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfChar outerClass java\/lang\/foreign\/ValueLayout innerClassName OfChar flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name allocate descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;Ljava\/lang\/foreign\/Addressable;)Ljava\/lang\/foreign\/MemorySegment;\n+-method name newNativeArena descriptor (Ljava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/SegmentAllocator;\n+-method name newNativeArena descriptor (JLjava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/SegmentAllocator;\n+-method name newNativeArena descriptor (JJLjava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/SegmentAllocator;\n+-method name implicitAllocator descriptor ()Ljava\/lang\/foreign\/SegmentAllocator;\n+method name allocate descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;Ljava\/lang\/foreign\/MemorySegment;)Ljava\/lang\/foreign\/MemorySegment; flags 1\n+method name slicingAllocator descriptor (Ljava\/lang\/foreign\/MemorySegment;)Ljava\/lang\/foreign\/SegmentAllocator; flags 9\n+method name nativeAllocator descriptor (Ljava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/SegmentAllocator; flags 9\n+\n+class name java\/lang\/foreign\/SegmentScope\n+header extends java\/lang\/Object sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+method name auto descriptor ()Ljava\/lang\/foreign\/SegmentScope; flags 9\n+method name global descriptor ()Ljava\/lang\/foreign\/SegmentScope; flags 9\n+method name isAlive descriptor ()Z flags 401\n+method name isAccessibleBy descriptor (Ljava\/lang\/Thread;)Z flags 401\n+method name whileAlive descriptor (Ljava\/lang\/Runnable;)V flags 401\n+\n+class name java\/lang\/foreign\/SequenceLayout\n+header extends java\/lang\/Object implements java\/lang\/foreign\/MemoryLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+-method name elementLayout descriptor ()Ljava\/lang\/foreign\/MemoryLayout;\n+-method name elementCount descriptor ()J\n+-method name withElementCount descriptor (J)Ljava\/lang\/foreign\/SequenceLayout;\n+-method name reshape descriptor ([J)Ljava\/lang\/foreign\/SequenceLayout;\n+-method name flatten descriptor ()Ljava\/lang\/foreign\/SequenceLayout;\n+-method name toString descriptor ()Ljava\/lang\/String;\n+-method name equals descriptor (Ljava\/lang\/Object;)Z\n+-method name hashCode descriptor ()I\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/SequenceLayout;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/SequenceLayout;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name elementLayout descriptor ()Ljava\/lang\/foreign\/MemoryLayout; flags 401\n+method name elementCount descriptor ()J flags 401\n+method name withElementCount descriptor (J)Ljava\/lang\/foreign\/SequenceLayout; flags 401\n+method name reshape descriptor ([J)Ljava\/lang\/foreign\/SequenceLayout; flags 481\n+method name flatten descriptor ()Ljava\/lang\/foreign\/SequenceLayout; flags 401\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/SequenceLayout; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/SequenceLayout; flags 401\n+\n+class name java\/lang\/foreign\/StructLayout\n+header extends java\/lang\/Object implements java\/lang\/foreign\/GroupLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/StructLayout; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/StructLayout; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/GroupLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/GroupLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/MemoryLayout; flags 1041\n+\n+class name java\/lang\/foreign\/SymbolLookup\n+-method name lookup descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional;\n+-method name libraryLookup descriptor (Ljava\/lang\/String;Ljava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/SymbolLookup;\n+-method name libraryLookup descriptor (Ljava\/nio\/file\/Path;Ljava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/SymbolLookup;\n+method name find descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional; flags 401 signature (Ljava\/lang\/String;)Ljava\/util\/Optional<Ljava\/lang\/foreign\/MemorySegment;>;\n+method name libraryLookup descriptor (Ljava\/lang\/String;Ljava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/SymbolLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name libraryLookup descriptor (Ljava\/nio\/file\/Path;Ljava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/SymbolLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+class name java\/lang\/foreign\/UnionLayout\n+header extends java\/lang\/Object implements java\/lang\/foreign\/GroupLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/UnionLayout; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/UnionLayout; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/GroupLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/GroupLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/MemoryLayout; flags 1041\n+\n+class name java\/lang\/foreign\/VaList\n+header extends java\/lang\/Object nestMembers java\/lang\/foreign\/VaList$Builder sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/VaList$Builder outerClass java\/lang\/foreign\/VaList innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 609\n+-method name session descriptor ()Ljava\/lang\/foreign\/MemorySession;\n+-method name nextVarg descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;)Ljava\/lang\/foreign\/MemoryAddress;\n+-method name address descriptor ()Ljava\/lang\/foreign\/MemoryAddress;\n+-method name ofAddress descriptor (Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/VaList;\n+-method name make descriptor (Ljava\/util\/function\/Consumer;Ljava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/VaList;\n+method name nextVarg descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;)Ljava\/lang\/foreign\/MemorySegment; flags 401\n+method name segment descriptor ()Ljava\/lang\/foreign\/MemorySegment; flags 401\n+method name ofAddress descriptor (JLjava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name make descriptor (Ljava\/util\/function\/Consumer;Ljava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/VaList; flags 9 signature (Ljava\/util\/function\/Consumer<Ljava\/lang\/foreign\/VaList$Builder;>;Ljava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/VaList;\n+\n+class name java\/lang\/foreign\/VaList$Builder\n+header extends java\/lang\/Object nestHost java\/lang\/foreign\/VaList sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/VaList$Builder outerClass java\/lang\/foreign\/VaList innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 609\n+-method name addVarg descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;Ljava\/lang\/foreign\/Addressable;)Ljava\/lang\/foreign\/VaList$Builder;\n+method name addVarg descriptor (Ljava\/lang\/foreign\/ValueLayout$OfAddress;Ljava\/lang\/foreign\/MemorySegment;)Ljava\/lang\/foreign\/VaList$Builder; flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout\n+header extends java\/lang\/Object implements java\/lang\/foreign\/MemoryLayout nestMembers java\/lang\/foreign\/ValueLayout$OfAddress,java\/lang\/foreign\/ValueLayout$OfDouble,java\/lang\/foreign\/ValueLayout$OfLong,java\/lang\/foreign\/ValueLayout$OfFloat,java\/lang\/foreign\/ValueLayout$OfInt,java\/lang\/foreign\/ValueLayout$OfShort,java\/lang\/foreign\/ValueLayout$OfChar,java\/lang\/foreign\/ValueLayout$OfByte,java\/lang\/foreign\/ValueLayout$OfBoolean sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfBoolean outerClass java\/lang\/foreign\/ValueLayout innerClassName OfBoolean flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfChar outerClass java\/lang\/foreign\/ValueLayout innerClassName OfChar flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 609\n+-method name order descriptor ()Ljava\/nio\/ByteOrder;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout;\n+-method name toString descriptor ()Ljava\/lang\/String;\n+-method name equals descriptor (Ljava\/lang\/Object;)Z\n+-method name arrayElementVarHandle descriptor ([I)Ljava\/lang\/invoke\/VarHandle;\n+-method name carrier descriptor ()Ljava\/lang\/Class;\n+-method name hashCode descriptor ()I\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+field name ADDRESS_UNALIGNED descriptor Ljava\/lang\/foreign\/ValueLayout$OfAddress; flags 19\n+field name JAVA_CHAR_UNALIGNED descriptor Ljava\/lang\/foreign\/ValueLayout$OfChar; flags 19\n+field name JAVA_SHORT_UNALIGNED descriptor Ljava\/lang\/foreign\/ValueLayout$OfShort; flags 19\n+field name JAVA_INT_UNALIGNED descriptor Ljava\/lang\/foreign\/ValueLayout$OfInt; flags 19\n+field name JAVA_LONG_UNALIGNED descriptor Ljava\/lang\/foreign\/ValueLayout$OfLong; flags 19\n+field name JAVA_FLOAT_UNALIGNED descriptor Ljava\/lang\/foreign\/ValueLayout$OfFloat; flags 19\n+field name JAVA_DOUBLE_UNALIGNED descriptor Ljava\/lang\/foreign\/ValueLayout$OfDouble; flags 19\n+method name order descriptor ()Ljava\/nio\/ByteOrder; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout; flags 401\n+method name arrayElementVarHandle descriptor ([I)Ljava\/lang\/invoke\/VarHandle; flags 481\n+method name carrier descriptor ()Ljava\/lang\/Class; flags 401 signature ()Ljava\/lang\/Class<*>;\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout; flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout$OfAddress\n+header extends java\/lang\/Object implements java\/lang\/foreign\/ValueLayout nestHost java\/lang\/foreign\/ValueLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 609\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfAddress;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfAddress;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfAddress;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfAddress; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfAddress; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfAddress; flags 401\n+method name asUnbounded descriptor ()Ljava\/lang\/foreign\/ValueLayout$OfAddress; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name isUnbounded descriptor ()Z flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout$OfBoolean\n+header extends java\/lang\/Object implements java\/lang\/foreign\/ValueLayout nestHost java\/lang\/foreign\/ValueLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfBoolean outerClass java\/lang\/foreign\/ValueLayout innerClassName OfBoolean flags 609\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfBoolean;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfBoolean;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfBoolean;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfBoolean; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfBoolean; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfBoolean; flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout$OfByte\n+header extends java\/lang\/Object implements java\/lang\/foreign\/ValueLayout nestHost java\/lang\/foreign\/ValueLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 609\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfByte;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfByte;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfByte;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfByte; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfByte; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfByte; flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout$OfChar\n+header extends java\/lang\/Object implements java\/lang\/foreign\/ValueLayout nestHost java\/lang\/foreign\/ValueLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfChar outerClass java\/lang\/foreign\/ValueLayout innerClassName OfChar flags 609\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfChar;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfChar;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfChar;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfChar; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfChar; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfChar; flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout$OfDouble\n+header extends java\/lang\/Object implements java\/lang\/foreign\/ValueLayout nestHost java\/lang\/foreign\/ValueLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 609\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfDouble;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfDouble;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfDouble;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfDouble; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfDouble; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfDouble; flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout$OfFloat\n+header extends java\/lang\/Object implements java\/lang\/foreign\/ValueLayout nestHost java\/lang\/foreign\/ValueLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 609\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfFloat;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfFloat;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfFloat;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfFloat; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfFloat; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfFloat; flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout$OfInt\n+header extends java\/lang\/Object implements java\/lang\/foreign\/ValueLayout nestHost java\/lang\/foreign\/ValueLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 609\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfInt;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfInt;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfInt;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfInt; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfInt; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfInt; flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout$OfLong\n+header extends java\/lang\/Object implements java\/lang\/foreign\/ValueLayout nestHost java\/lang\/foreign\/ValueLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 609\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfLong;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfLong;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfLong;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfLong; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfLong; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfLong; flags 401\n+\n+class name java\/lang\/foreign\/ValueLayout$OfShort\n+header extends java\/lang\/Object implements java\/lang\/foreign\/ValueLayout nestHost java\/lang\/foreign\/ValueLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 609\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfShort;\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfShort;\n+-method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfShort;\n+-method name isPadding descriptor ()Z\n+-method name bitSize descriptor ()J\n+-method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/AbstractLayout;\n+-method name byteSize descriptor ()J\n+method name withName descriptor (Ljava\/lang\/String;)Ljava\/lang\/foreign\/ValueLayout$OfShort; flags 401\n+method name withBitAlignment descriptor (J)Ljava\/lang\/foreign\/ValueLayout$OfShort; flags 401\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljava\/lang\/foreign\/ValueLayout$OfShort; flags 401\n+\n+class name java\/lang\/invoke\/CallSite\n+header extends java\/lang\/Object sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/LambdaMetafactory\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/MethodHandle\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/invoke\/MethodHandleProxies\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/lang\/invoke\/StringConcatException\n+header extends java\/lang\/Exception flags 21\n+\n+class name java\/lang\/invoke\/VarHandle\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable nestMembers java\/lang\/invoke\/VarHandle$VarHandleDesc,java\/lang\/invoke\/VarHandle$AccessMode sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/VarHandle$AccessMode outerClass java\/lang\/invoke\/VarHandle innerClassName AccessMode flags 4019\n+innerclass innerClass java\/lang\/invoke\/VarHandle$VarHandleDesc outerClass java\/lang\/invoke\/VarHandle innerClassName VarHandleDesc flags 19\n+\n+class name java\/lang\/module\/Configuration\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/module\/FindException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/InvalidModuleDescriptorException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ModuleDescriptor\n+header extends java\/lang\/Object implements java\/lang\/Comparable nestMembers java\/lang\/module\/ModuleDescriptor$Builder,java\/lang\/module\/ModuleDescriptor$Version,java\/lang\/module\/ModuleDescriptor$Provides,java\/lang\/module\/ModuleDescriptor$Opens,java\/lang\/module\/ModuleDescriptor$Opens$Modifier,java\/lang\/module\/ModuleDescriptor$Exports,java\/lang\/module\/ModuleDescriptor$Exports$Modifier,java\/lang\/module\/ModuleDescriptor$Requires,java\/lang\/module\/ModuleDescriptor$Requires$Modifier,java\/lang\/module\/ModuleDescriptor$Modifier flags 21 signature Ljava\/lang\/Object;Ljava\/lang\/Comparable<Ljava\/lang\/module\/ModuleDescriptor;>;\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Version outerClass java\/lang\/module\/ModuleDescriptor innerClassName Version flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Modifier outerClass java\/lang\/module\/ModuleDescriptor innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Builder outerClass java\/lang\/module\/ModuleDescriptor innerClassName Builder flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Provides outerClass java\/lang\/module\/ModuleDescriptor innerClassName Provides flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens outerClass java\/lang\/module\/ModuleDescriptor innerClassName Opens flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports outerClass java\/lang\/module\/ModuleDescriptor innerClassName Exports flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Requires outerClass java\/lang\/module\/ModuleDescriptor innerClassName Requires flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Opens innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Exports innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Requires$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Requires innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/module\/ModuleDescriptor$Exports\n+header extends java\/lang\/Object implements java\/lang\/Comparable nestHost java\/lang\/module\/ModuleDescriptor flags 31 signature Ljava\/lang\/Object;Ljava\/lang\/Comparable<Ljava\/lang\/module\/ModuleDescriptor$Exports;>;\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports outerClass java\/lang\/module\/ModuleDescriptor innerClassName Exports flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Exports innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/module\/ModuleDescriptor$Opens\n+header extends java\/lang\/Object implements java\/lang\/Comparable nestHost java\/lang\/module\/ModuleDescriptor flags 31 signature Ljava\/lang\/Object;Ljava\/lang\/Comparable<Ljava\/lang\/module\/ModuleDescriptor$Opens;>;\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens outerClass java\/lang\/module\/ModuleDescriptor innerClassName Opens flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Opens innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/module\/ModuleDescriptor$Requires\n+header extends java\/lang\/Object implements java\/lang\/Comparable nestHost java\/lang\/module\/ModuleDescriptor flags 31 signature Ljava\/lang\/Object;Ljava\/lang\/Comparable<Ljava\/lang\/module\/ModuleDescriptor$Requires;>;\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Requires outerClass java\/lang\/module\/ModuleDescriptor innerClassName Requires flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Version outerClass java\/lang\/module\/ModuleDescriptor innerClassName Version flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Requires$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Requires innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/module\/ModuleReader\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 601\n+\n+class name java\/lang\/module\/ModuleReference\n+header extends java\/lang\/Object flags 421\n+\n+class name java\/lang\/module\/ResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ResolvedModule\n+header extends java\/lang\/Object flags 31\n+\n+class name java\/lang\/ref\/Reference\n+header extends java\/lang\/Object sealed true flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name java\/lang\/reflect\/AccessFlag\n+header extends java\/lang\/Enum nestMembers java\/lang\/reflect\/AccessFlag$Location flags 4031 signature Ljava\/lang\/Enum<Ljava\/lang\/reflect\/AccessFlag;>;\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+field name PUBLIC descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name PRIVATE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name PROTECTED descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name STATIC descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name FINAL descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name SUPER descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name OPEN descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name TRANSITIVE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name SYNCHRONIZED descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name STATIC_PHASE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name VOLATILE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name BRIDGE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name TRANSIENT descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name VARARGS descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name NATIVE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name INTERFACE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name ABSTRACT descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name STRICT descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name SYNTHETIC descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name ANNOTATION descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name ENUM descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name MANDATED descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name MODULE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+method name values descriptor ()[Ljava\/lang\/reflect\/AccessFlag; flags 9\n+method name valueOf descriptor (Ljava\/lang\/String;)Ljava\/lang\/reflect\/AccessFlag; flags 9\n+method name mask descriptor ()I flags 1\n+method name sourceModifier descriptor ()Z flags 1\n+method name locations descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag$Location;>;\n+method name locations descriptor (Ljava\/lang\/reflect\/ClassFileFormatVersion;)Ljava\/util\/Set; flags 1 signature (Ljava\/lang\/reflect\/ClassFileFormatVersion;)Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag$Location;>;\n+method name maskToAccessFlags descriptor (ILjava\/lang\/reflect\/AccessFlag$Location;)Ljava\/util\/Set; flags 9 signature (ILjava\/lang\/reflect\/AccessFlag$Location;)Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/reflect\/AccessFlag$Location\n+header extends java\/lang\/Enum nestHost java\/lang\/reflect\/AccessFlag flags 4031 signature Ljava\/lang\/Enum<Ljava\/lang\/reflect\/AccessFlag$Location;>;\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+field name CLASS descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name FIELD descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name METHOD descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name INNER_CLASS descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name METHOD_PARAMETER descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name MODULE descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name MODULE_REQUIRES descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name MODULE_EXPORTS descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name MODULE_OPENS descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+method name values descriptor ()[Ljava\/lang\/reflect\/AccessFlag$Location; flags 9\n+method name valueOf descriptor (Ljava\/lang\/String;)Ljava\/lang\/reflect\/AccessFlag$Location; flags 9\n+\n+class name java\/lang\/reflect\/AccessibleObject\n+header extends java\/lang\/Object implements java\/lang\/reflect\/AnnotatedElement flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/lang\/reflect\/AnnotatedElement\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/ClassFileFormatVersion\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Ljava\/lang\/reflect\/ClassFileFormatVersion;>;\n+innerclass innerClass java\/lang\/Runtime$Version outerClass java\/lang\/Runtime innerClassName Version flags 19\n+field name RELEASE_0 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_1 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_2 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_3 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_4 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_5 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_6 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_7 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_8 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_9 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_10 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_11 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_12 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_13 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_14 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_15 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_16 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_17 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_18 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_19 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_20 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+method name values descriptor ()[Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+method name valueOf descriptor (Ljava\/lang\/String;)Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+method name latest descriptor ()Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+method name major descriptor ()I flags 1\n+method name valueOf descriptor (Ljava\/lang\/Runtime$Version;)Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+method name runtimeVersion descriptor ()Ljava\/lang\/Runtime$Version; flags 1\n+method name fromMajor descriptor (I)Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+\n+class name java\/lang\/reflect\/Executable\n+header extends java\/lang\/reflect\/AccessibleObject implements java\/lang\/reflect\/Member,java\/lang\/reflect\/GenericDeclaration sealed true flags 421\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name getParameterCount descriptor ()I\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+method name getParameterCount descriptor ()I flags 401\n+\n+class name java\/lang\/reflect\/Field\n+header extends java\/lang\/reflect\/AccessibleObject implements java\/lang\/reflect\/Member flags 31\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/reflect\/InaccessibleObjectException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/reflect\/Member\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/reflect\/Parameter\n+header extends java\/lang\/Object implements java\/lang\/reflect\/AnnotatedElement flags 31\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/math\/BigDecimal\n+header extends java\/lang\/Number implements java\/lang\/Comparable flags 21 signature Ljava\/lang\/Number;Ljava\/lang\/Comparable<Ljava\/math\/BigDecimal;>;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/net\/DatagramPacket\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/net\/DatagramSocket\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/net\/InetAddress\n+header extends java\/lang\/Object implements java\/io\/Serializable sealed true flags 21\n+innerclass innerClass java\/net\/spi\/InetAddressResolver$LookupPolicy outerClass java\/net\/spi\/InetAddressResolver innerClassName LookupPolicy flags 19\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/net\/spi\/InetAddressResolverProvider$Configuration outerClass java\/net\/spi\/InetAddressResolverProvider innerClassName Configuration flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/net\/SocketImpl\n+header extends java\/lang\/Object implements java\/net\/SocketOptions flags 421\n+\n+class name java\/net\/URL\n+-method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;ILjava\/lang\/String;)V\n+-method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)V\n+-method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;ILjava\/lang\/String;Ljava\/net\/URLStreamHandler;)V\n+-method name <init> descriptor (Ljava\/lang\/String;)V\n+-method name <init> descriptor (Ljava\/net\/URL;Ljava\/lang\/String;)V\n+-method name <init> descriptor (Ljava\/net\/URL;Ljava\/lang\/String;Ljava\/net\/URLStreamHandler;)V\n+method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;ILjava\/lang\/String;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;ILjava\/lang\/String;Ljava\/net\/URLStreamHandler;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/lang\/String;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/net\/URL;Ljava\/lang\/String;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/net\/URL;Ljava\/lang\/String;Ljava\/net\/URLStreamHandler;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name of descriptor (Ljava\/net\/URI;Ljava\/net\/URLStreamHandler;)Ljava\/net\/URL; thrownTypes java\/net\/MalformedURLException flags 9\n+\n+class name java\/net\/spi\/InetAddressResolverProvider$Configuration\n+header extends java\/lang\/Object nestHost java\/net\/spi\/InetAddressResolverProvider sealed true flags 601\n+innerclass innerClass java\/net\/spi\/InetAddressResolverProvider$Configuration outerClass java\/net\/spi\/InetAddressResolverProvider innerClassName Configuration flags 609\n+\n+class name java\/net\/spi\/URLStreamHandlerProvider\n+header extends java\/lang\/Object implements java\/net\/URLStreamHandlerFactory flags 421\n+\n+class name java\/nio\/Buffer\n+header extends java\/lang\/Object sealed true flags 421\n+\n+class name java\/nio\/ByteBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/ByteBuffer;>;\n+\n+class name java\/nio\/CharBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable,java\/lang\/Appendable,java\/lang\/CharSequence,java\/lang\/Readable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/CharBuffer;>;Ljava\/lang\/Appendable;Ljava\/lang\/CharSequence;Ljava\/lang\/Readable;\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/nio\/DoubleBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/DoubleBuffer;>;\n+\n+class name java\/nio\/FloatBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/FloatBuffer;>;\n+\n+class name java\/nio\/IntBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/IntBuffer;>;\n+\n+class name java\/nio\/LongBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/LongBuffer;>;\n+\n+class name java\/nio\/MappedByteBuffer\n+header extends java\/nio\/ByteBuffer sealed true flags 421\n+\n+class name java\/nio\/ShortBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/ShortBuffer;>;\n+\n+class name java\/nio\/channels\/FileChannel\n+-method name map descriptor (Ljava\/nio\/channels\/FileChannel$MapMode;JJLjava\/lang\/foreign\/MemorySession;)Ljava\/lang\/foreign\/MemorySegment;\n+method name map descriptor (Ljava\/nio\/channels\/FileChannel$MapMode;JJLjava\/lang\/foreign\/SegmentScope;)Ljava\/lang\/foreign\/MemorySegment; thrownTypes java\/io\/IOException flags 1 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+\n+class name java\/nio\/file\/spi\/FileSystemProvider\n+method name exists descriptor (Ljava\/nio\/file\/Path;[Ljava\/nio\/file\/LinkOption;)Z flags 81\n+method name readAttributesIfExists descriptor (Ljava\/nio\/file\/Path;Ljava\/lang\/Class;[Ljava\/nio\/file\/LinkOption;)Ljava\/nio\/file\/attribute\/BasicFileAttributes; thrownTypes java\/io\/IOException flags 81 signature <A::Ljava\/nio\/file\/attribute\/BasicFileAttributes;>(Ljava\/nio\/file\/Path;Ljava\/lang\/Class<TA;>;[Ljava\/nio\/file\/LinkOption;)TA;\n+\n+class name java\/security\/Certificate\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/Identity\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/InvalidParameterException\n+method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/Throwable;)V flags 1\n+method name <init> descriptor (Ljava\/lang\/Throwable;)V flags 1\n+\n+class name java\/security\/KeyStore\n+header extends java\/lang\/Object nestMembers java\/security\/KeyStore$Builder,java\/security\/KeyStore$TrustedCertificateEntry,java\/security\/KeyStore$SecretKeyEntry,java\/security\/KeyStore$PrivateKeyEntry,java\/security\/KeyStore$Entry,java\/security\/KeyStore$Entry$Attribute,java\/security\/KeyStore$CallbackHandlerProtection,java\/security\/KeyStore$PasswordProtection,java\/security\/KeyStore$ProtectionParameter,java\/security\/KeyStore$LoadStoreParameter flags 21\n+innerclass innerClass java\/security\/KeyStore$LoadStoreParameter outerClass java\/security\/KeyStore innerClassName LoadStoreParameter flags 609\n+innerclass innerClass java\/security\/KeyStore$ProtectionParameter outerClass java\/security\/KeyStore innerClassName ProtectionParameter flags 609\n+innerclass innerClass java\/security\/KeyStore$Entry outerClass java\/security\/KeyStore innerClassName Entry flags 609\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/security\/KeyStore$Builder outerClass java\/security\/KeyStore innerClassName Builder flags 409\n+innerclass innerClass java\/security\/KeyStore$TrustedCertificateEntry outerClass java\/security\/KeyStore innerClassName TrustedCertificateEntry flags 19\n+innerclass innerClass java\/security\/KeyStore$SecretKeyEntry outerClass java\/security\/KeyStore innerClassName SecretKeyEntry flags 19\n+innerclass innerClass java\/security\/KeyStore$PrivateKeyEntry outerClass java\/security\/KeyStore innerClassName PrivateKeyEntry flags 19\n+innerclass innerClass java\/security\/KeyStore$CallbackHandlerProtection outerClass java\/security\/KeyStore innerClassName CallbackHandlerProtection flags 9\n+innerclass innerClass java\/security\/KeyStore$PasswordProtection outerClass java\/security\/KeyStore innerClassName PasswordProtection flags 9\n+innerclass innerClass java\/security\/KeyStore$Entry$Attribute outerClass java\/security\/KeyStore$Entry innerClassName Attribute flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/ProtectionDomain\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/Provider\n+header extends java\/util\/Properties nestMembers java\/security\/Provider$Service flags 421\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/SecureRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SecureRandom\",isStochastic=Ztrue)\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/SecureRandomParameters\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/security\/Security\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/SignedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/security\/cert\/CertPathBuilder\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/cert\/CertPathValidator\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/cert\/CertStore\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name getDefaultType descriptor ()Ljava\/lang\/String;\n+method name getDefaultType descriptor ()Ljava\/lang\/String; flags 9\n+\n+class name java\/security\/cert\/CertificateRevokedException\n+header extends java\/security\/cert\/CertificateException flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/security\/cert\/URICertStoreParameters\n+header extends java\/lang\/Object implements java\/security\/cert\/CertStoreParameters flags 31\n+\n+class name java\/security\/interfaces\/DSAKeyPairGenerator\n+-method name initialize descriptor (Ljava\/security\/interfaces\/DSAParams;Ljava\/security\/SecureRandom;)V\n+-method name initialize descriptor (IZLjava\/security\/SecureRandom;)V\n+method name initialize descriptor (Ljava\/security\/interfaces\/DSAParams;Ljava\/security\/SecureRandom;)V flags 401\n+method name initialize descriptor (IZLjava\/security\/SecureRandom;)V flags 401\n+\n+class name java\/security\/interfaces\/RSAKey\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/EncodedKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/spec\/MGF1ParameterSpec\n+-field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+-field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+\n+class name java\/security\/spec\/PSSParameterSpec\n+-field name TRAILER_FIELD_BC descriptor I\n+-method name toString descriptor ()Ljava\/lang\/String;\n+field name TRAILER_FIELD_BC descriptor I constantValue 1 flags 19\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/security\/spec\/RSAKeyGenParameterSpec\n+-method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAMultiPrimePrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAPublicKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/text\/DateFormatSymbols\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/text\/RuleBasedCollator\n+header extends java\/text\/Collator flags 21\n+innerclass innerClass java\/text\/Normalizer$Form outerClass java\/text\/Normalizer innerClassName Form flags 4019\n+\n+class name java\/time\/ZoneId\n+header extends java\/lang\/Object implements java\/io\/Serializable sealed true flags 421 runtimeAnnotations @Ljdk\/internal\/ValueBased;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/time\/ZoneOffset\n+header extends java\/time\/ZoneId implements java\/time\/temporal\/TemporalAccessor,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable,java\/io\/Serializable flags 31 signature Ljava\/time\/ZoneId;Ljava\/time\/temporal\/TemporalAccessor;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/ZoneOffset;>;Ljava\/io\/Serializable; runtimeAnnotations @Ljdk\/internal\/ValueBased;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/chrono\/ChronoLocalDate\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDate;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/chrono\/ChronoLocalDateTime\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature <D::Ljava\/time\/chrono\/ChronoLocalDate;>Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDateTime<*>;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/format\/DecimalStyle\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/temporal\/TemporalAdjusters\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Comparator\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/DoubleSummaryStatistics\n+header extends java\/lang\/Object implements java\/util\/function\/DoubleConsumer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/EnumSet\n+header extends java\/util\/AbstractSet implements java\/lang\/Cloneable,java\/io\/Serializable sealed true flags 421 signature <E:Ljava\/lang\/Enum<TE;>;>Ljava\/util\/AbstractSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+\n+class name java\/util\/GregorianCalendar\n+header extends java\/util\/Calendar flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/IdentityHashMap\n+method name remove descriptor (Ljava\/lang\/Object;Ljava\/lang\/Object;)Z flags 1\n+method name replace descriptor (Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/Object;)Z flags 1 signature (TK;TV;TV;)Z\n+\n+class name java\/util\/IllegalFormatException\n+header extends java\/lang\/IllegalArgumentException sealed true flags 21\n+\n+class name java\/util\/Locale$IsoCountryCode\n+header extends java\/lang\/Enum nestHost java\/util\/Locale sealed true flags 4421 signature Ljava\/lang\/Enum<Ljava\/util\/Locale$IsoCountryCode;>;\n+innerclass innerClass java\/util\/Locale$IsoCountryCode outerClass java\/util\/Locale innerClassName IsoCountryCode flags 4409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Observable\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Observer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/TimeZone\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/TreeSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/concurrent\/ConcurrentHashMap$CollectionView\n+header extends java\/lang\/Object implements java\/util\/Collection,java\/io\/Serializable nestHost java\/util\/concurrent\/ConcurrentHashMap sealed true flags 420 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;E:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/Collection<TE;>;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/concurrent\/ConcurrentHashMap$CollectionView outerClass java\/util\/concurrent\/ConcurrentHashMap innerClassName CollectionView flags 408\n+innerclass innerClass java\/util\/concurrent\/ConcurrentHashMap$KeySetView outerClass java\/util\/concurrent\/ConcurrentHashMap innerClassName KeySetView flags 19\n+\n+class name java\/util\/concurrent\/ConcurrentMap\n+header extends java\/lang\/Object implements java\/util\/Map flags 601 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/Map<TK;TV;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ConcurrentSkipListSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/CountedCompleter\n+header extends java\/util\/concurrent\/ForkJoinTask flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/util\/concurrent\/ForkJoinTask<TT;>; classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/util\/concurrent\/ForkJoinPool\n+method name externalSubmit descriptor (Ljava\/util\/concurrent\/ForkJoinTask;)Ljava\/util\/concurrent\/ForkJoinTask; flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/ForkJoinTask<TT;>;)Ljava\/util\/concurrent\/ForkJoinTask<TT;>;\n+\n+class name java\/util\/concurrent\/ForkJoinWorkerThread\n+method name getQueuedTaskCount descriptor ()I flags 1\n+\n+class name java\/util\/concurrent\/atomic\/AtomicBoolean\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReference\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReferenceArray\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/locks\/StampedLock\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name tryWriteLock descriptor ()J\n+-method name writeLockInterruptibly descriptor ()J\n+-method name tryReadLock descriptor ()J\n+-method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J\n+-method name readLockInterruptibly descriptor ()J\n+-method name unlock descriptor (J)V\n+method name tryWriteLock descriptor ()J flags 1\n+method name writeLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name tryReadLock descriptor ()J flags 1\n+method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J thrownTypes java\/lang\/InterruptedException flags 1\n+method name readLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name unlock descriptor (J)V flags 1\n+\n+class name java\/util\/function\/BiConsumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiFunction\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiPredicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BinaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/BiFunction flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/BiFunction<TT;TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Consumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoublePredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Function\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Predicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/UnaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/Function flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/Function<TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/regex\/MatchResult\n+method name start descriptor (Ljava\/lang\/String;)I flags 1\n+method name end descriptor (Ljava\/lang\/String;)I flags 1\n+method name group descriptor (Ljava\/lang\/String;)Ljava\/lang\/String; flags 1\n+method name namedGroups descriptor ()Ljava\/util\/Map; flags 1 signature ()Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/lang\/Integer;>;\n+method name hasMatch descriptor ()Z flags 1\n+\n+class name java\/util\/regex\/Matcher\n+method name namedGroups descriptor ()Ljava\/util\/Map; flags 1 signature ()Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/lang\/Integer;>;\n+method name hasMatch descriptor ()Z flags 1\n+\n+class name java\/util\/regex\/Pattern\n+method name namedGroups descriptor ()Ljava\/util\/Map; flags 1 signature ()Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/lang\/Integer;>;\n+\n+class name java\/util\/spi\/AbstractResourceBundleProvider\n+header extends java\/lang\/Object implements java\/util\/spi\/ResourceBundleProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/spi\/CurrencyNameProvider\n+header extends java\/util\/spi\/LocaleServiceProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+\n+class name java\/util\/spi\/ResourceBundleProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/util\/spi\/ToolProvider\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/zip\/CRC32C\n+header extends java\/lang\/Object implements java\/util\/zip\/Checksum flags 31\n+\n+class name java\/util\/zip\/ZipInputStream\n+method name read descriptor ()I thrownTypes java\/io\/IOException flags 1\n+method name readAllBytes descriptor ()[B thrownTypes java\/io\/IOException flags 1\n+method name readNBytes descriptor (I)[B thrownTypes java\/io\/IOException flags 1\n+method name readNBytes descriptor ([BII)I thrownTypes java\/io\/IOException flags 1\n+method name skipNBytes descriptor (J)V thrownTypes java\/io\/IOException flags 1\n+method name transferTo descriptor (Ljava\/io\/OutputStream;)J thrownTypes java\/io\/IOException flags 1\n+\n+class name javax\/crypto\/AEADBadTagException\n+header extends javax\/crypto\/BadPaddingException flags 21\n+\n+class name javax\/crypto\/BadPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/CipherInputStream\n+header extends java\/io\/FilterInputStream flags 21\n+\n+class name javax\/crypto\/CipherOutputStream\n+header extends java\/io\/FilterOutputStream flags 21\n+\n+class name javax\/crypto\/CipherSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/EncryptedPrivateKeyInfo\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanism\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/IllegalBlockSizeException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/KeyAgreement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyAgreementSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/KeyGenerator\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyGeneratorSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/Mac\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/MacSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/NoSuchPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/NullCipher\n+header extends javax\/crypto\/Cipher flags 21\n+\n+class name javax\/crypto\/SealedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/crypto\/SecretKey\n+header extends java\/lang\/Object implements java\/security\/Key,javax\/security\/auth\/Destroyable flags 601\n+\n+class name javax\/crypto\/SecretKeyFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/SecretKeyFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/ShortBufferException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/interfaces\/DHKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPrivateKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PrivateKey flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPublicKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PublicKey flags 601\n+\n+class name javax\/crypto\/interfaces\/PBEKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 601\n+\n+class name javax\/crypto\/spec\/DESKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DESedeKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHGenParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPrivateKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPublicKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/GCMParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/IvParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/OAEPParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+innerclass innerClass javax\/crypto\/spec\/PSource$PSpecified outerClass javax\/crypto\/spec\/PSource innerClassName PSpecified flags 19\n+\n+class name javax\/crypto\/spec\/PBEKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+-method name clearPassword descriptor ()V\n+-method name getPassword descriptor ()[C\n+method name clearPassword descriptor ()V flags 31\n+method name getPassword descriptor ()[C flags 31\n+\n+class name javax\/crypto\/spec\/PBEParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC2ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC5ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/net\/ssl\/SSLParameters\n+method name getNamedGroups descriptor ()[Ljava\/lang\/String; flags 1\n+method name setNamedGroups descriptor ([Ljava\/lang\/String;)V flags 1\n+\n+class name jdk\/internal\/event\/Event\n+header extends java\/lang\/Object flags 421\n+-method name <init> descriptor ()V\n+-method name begin descriptor ()V\n+-method name end descriptor ()V\n+-method name commit descriptor ()V\n+-method name isEnabled descriptor ()Z\n+-method name shouldCommit descriptor ()Z\n+-method name set descriptor (ILjava\/lang\/Object;)V\n+method name <init> descriptor ()V flags 4\n+method name begin descriptor ()V flags 1\n+method name end descriptor ()V flags 1\n+method name commit descriptor ()V flags 1\n+method name isEnabled descriptor ()Z flags 1\n+method name shouldCommit descriptor ()Z flags 1\n+method name set descriptor (ILjava\/lang\/Object;)V flags 1\n+\n+class name jdk\/internal\/vm\/vector\/VectorSupport\n+-method name indexVector descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\n+method name indexVector descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;E:Ljava\/lang\/Object;S:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies<TE;>;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TE;>;ITV;ITS;Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation<TV;TS;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.base-K.sym.txt","additions":1402,"deletions":0,"binary":false,"changes":1402,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/annotation\/processing\/AbstractProcessor\n+header extends java\/lang\/Object implements javax\/annotation\/processing\/Processor flags 421\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/annotation\/processing\/Generated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;PARAMETER;})\n+\n+class name javax\/lang\/model\/SourceVersion\n+field name RELEASE_20 descriptor Ljavax\/lang\/model\/SourceVersion; flags 4019\n+\n+class name javax\/lang\/model\/element\/Modifier\n+header extends java\/lang\/Enum sealed true flags 4021 signature Ljava\/lang\/Enum<Ljavax\/lang\/model\/element\/Modifier;>;\n+\n+class name javax\/lang\/model\/element\/UnknownAnnotationValueException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownDirectiveException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass javax\/lang\/model\/element\/ModuleElement$Directive outerClass javax\/lang\/model\/element\/ModuleElement innerClassName Directive flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownElementException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypeException\n+header extends javax\/lang\/model\/type\/MirroredTypesException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypesException\n+header extends java\/lang\/RuntimeException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/UnknownTypeException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/AbstractAnnotationValueVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/AbstractElementVisitor14\n+header extends javax\/lang\/model\/util\/AbstractElementVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor14\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor6\n+header extends java\/lang\/Object implements javax\/lang\/model\/type\/TypeVisitor flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/lang\/model\/type\/TypeVisitor<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_6;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor7\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor6 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor6<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_7;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor8\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor7 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor7<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_8;)\n+\n+class name javax\/lang\/model\/util\/ElementKindVisitor14\n+header extends javax\/lang\/model\/util\/ElementKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/ElementScanner14\n+header extends javax\/lang\/model\/util\/ElementScanner9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementScanner9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/Elements\n+method name isCanonicalConstructor descriptor (Ljavax\/lang\/model\/element\/ExecutableElement;)Z flags 1\n+method name isCompactConstructor descriptor (Ljavax\/lang\/model\/element\/ExecutableElement;)Z flags 1\n+\n+class name javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/SimpleAnnotationValueVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/SimpleElementVisitor14\n+header extends javax\/lang\/model\/util\/SimpleElementVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/SimpleTypeVisitor14\n+header extends javax\/lang\/model\/util\/SimpleTypeVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/TypeKindVisitor14\n+header extends javax\/lang\/model\/util\/TypeKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/TypeKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/tools\/SimpleJavaFileObject\n+header extends java\/lang\/Object implements javax\/tools\/JavaFileObject flags 21\n+innerclass innerClass javax\/tools\/JavaFileObject$Kind outerClass javax\/tools\/JavaFileObject innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/tools\/ToolProvider\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.compiler-K.sym.txt","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.datatransfer-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.datatransfer-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,871 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/awt\/AWTKeyStroke\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/AttributeValue\n+header extends java\/lang\/Object flags 420\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/BorderLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/CheckboxGroup\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Color\n+header extends java\/lang\/Object implements java\/awt\/Paint,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/ContainerOrderFocusTraversalPolicy\n+header extends java\/awt\/FocusTraversalPolicy implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Dimension\n+header extends java\/awt\/geom\/Dimension2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/DisplayMode\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Event\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FlowLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FontMetrics\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Graphics\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/GridLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/HeadlessException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Insets\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/MenuShortcut\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/MultipleGradientPaint\n+header extends java\/lang\/Object implements java\/awt\/Paint nestMembers java\/awt\/MultipleGradientPaint$ColorSpaceType,java\/awt\/MultipleGradientPaint$CycleMethod sealed true flags 421\n+innerclass innerClass java\/awt\/MultipleGradientPaint$ColorSpaceType outerClass java\/awt\/MultipleGradientPaint innerClassName ColorSpaceType flags 4019\n+innerclass innerClass java\/awt\/MultipleGradientPaint$CycleMethod outerClass java\/awt\/MultipleGradientPaint innerClassName CycleMethod flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Point\n+header extends java\/awt\/geom\/Point2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Rectangle\n+header extends java\/awt\/geom\/Rectangle2D implements java\/awt\/Shape,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/SystemColor\n+header extends java\/awt\/Color implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/TextComponent\n+header extends java\/awt\/Component implements javax\/accessibility\/Accessible nestMembers java\/awt\/TextComponent$AccessibleAWTTextComponent sealed true flags 21\n+innerclass innerClass java\/awt\/TextComponent$AccessibleAWTTextComponent outerClass java\/awt\/TextComponent innerClassName AccessibleAWTTextComponent flags 4\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/TexturePaint\n+header extends java\/lang\/Object implements java\/awt\/Paint flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/color\/ColorSpace\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/color\/ICC_ColorSpace\n+header extends java\/awt\/color\/ColorSpace flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name java\/awt\/color\/ICC_Profile\n+header extends java\/lang\/Object implements java\/io\/Serializable sealed true flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/desktop\/AboutEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AboutHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/AppEvent\n+header extends java\/util\/EventObject sealed true flags 21\n+\n+class name java\/awt\/desktop\/AppForegroundEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppForegroundListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppHiddenEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppHiddenListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppReopenedEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppReopenedListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/FilesEvent\n+header extends java\/awt\/desktop\/AppEvent sealed true flags 21\n+\n+class name java\/awt\/desktop\/OpenFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/OpenURIEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenURIHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PreferencesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/PreferencesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PrintFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/PrintFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/QuitHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitResponse\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitStrategy\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Ljava\/awt\/desktop\/QuitStrategy;>;\n+\n+class name java\/awt\/desktop\/ScreenSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/ScreenSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemEventListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/SystemSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/UserSessionListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/dnd\/DragGestureEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragGestureRecognizer\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragSource\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDragEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDropEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ActionEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/AdjustmentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ComponentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ContainerEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/HierarchyEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/InputEvent\n+header extends java\/awt\/event\/ComponentEvent sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/InputMethodEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ItemEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/MouseWheelEvent\n+header extends java\/awt\/event\/MouseEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/PaintEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/WindowEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/FontRenderContext\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/awt\/RenderingHints$Key outerClass java\/awt\/RenderingHints innerClassName Key flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/GraphicAttribute\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/ImageGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/NumericShaper$Range\n+header extends java\/lang\/Enum nestHost java\/awt\/font\/NumericShaper sealed true flags 4021 signature Ljava\/lang\/Enum<Ljava\/awt\/font\/NumericShaper$Range;>;\n+innerclass innerClass java\/awt\/font\/NumericShaper$Range outerClass java\/awt\/font\/NumericShaper innerClassName Range flags 4009\n+\n+class name java\/awt\/font\/ShapeGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/TextHitInfo\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/TextMeasurer\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/AffineTransform\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Double outerClass java\/awt\/geom\/Point2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/Area\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/geom\/Path2D\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable nestMembers java\/awt\/geom\/Path2D$Double,java\/awt\/geom\/Path2D$Float sealed true flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Float outerClass java\/awt\/geom\/Path2D innerClassName Float flags 9\n+\n+class name java\/awt\/geom\/RectangularShape\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/image\/AbstractMultiResolutionImage\n+header extends java\/awt\/Image implements java\/awt\/image\/MultiResolutionImage flags 421\n+\n+class name java\/awt\/image\/BandCombineOp\n+header extends java\/lang\/Object implements java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BandedSampleModel\n+header extends java\/awt\/image\/ComponentSampleModel flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BaseMultiResolutionImage\n+header extends java\/awt\/image\/AbstractMultiResolutionImage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BufferedImageFilter\n+header extends java\/awt\/image\/ImageFilter implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ByteLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ColorConvertOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/ComponentColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ComponentSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ConvolveOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/DataBufferUShort\n+header extends java\/awt\/image\/DataBuffer flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/DirectColorModel\n+header extends java\/awt\/image\/PackedColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ImageFilter\n+header extends java\/lang\/Object implements java\/awt\/image\/ImageConsumer,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/IndexColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Kernel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/LookupOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiPixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiResolutionImage\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/image\/PackedColorModel\n+header extends java\/awt\/image\/ColorModel flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Raster\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ReplicateScaleFilter\n+header extends java\/awt\/image\/ImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/RescaleOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SampleModel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ShortLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SinglePixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/print\/Paper\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/beans\/BeanProperty\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;METHOD;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/Beans\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/DefaultPersistenceDelegate\n+header extends java\/beans\/PersistenceDelegate flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Encoder\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/EventSetDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Expression\n+header extends java\/beans\/Statement flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/FeatureDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/beans\/IndexedPropertyDescriptor\n+header extends java\/beans\/PropertyDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/JavaBean\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/PropertyDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/SimpleBeanInfo\n+header extends java\/lang\/Object implements java\/beans\/BeanInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibilityProvider\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/accessibility\/AccessibleBundle\n+header extends java\/lang\/Object flags 421 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/accessibility\/AccessibleRelationSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibleStateSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/metadata\/IIOMetadata\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGHuffmanTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGQTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFDirectory\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFField\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFImageReadParam\n+header extends javax\/imageio\/ImageReadParam flags 31\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTag\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTagSet\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/imageio\/spi\/ImageReaderWriterSpi\n+header extends javax\/imageio\/spi\/IIOServiceProvider flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/DateTimeSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/EnumSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/IntegerSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/standard\/MediaPrintableArea\n+header extends java\/lang\/Object implements javax\/print\/attribute\/DocAttribute,javax\/print\/attribute\/PrintRequestAttribute,javax\/print\/attribute\/PrintJobAttribute flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/event\/PrintEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MetaMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MidiMessage\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/Sequence\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/ShortMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/SysexMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/sampled\/ReverbType\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/sound\/sampled\/spi\/FormatConversionProvider\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/sound\/sampled\/AudioFormat$Encoding outerClass javax\/sound\/sampled\/AudioFormat innerClassName Encoding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/BoxLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DebugGraphics\n+header extends java\/awt\/Graphics flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultBoundedRangeModel\n+header extends java\/lang\/Object implements javax\/swing\/BoundedRangeModel,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultListSelectionModel\n+header extends java\/lang\/Object implements javax\/swing\/ListSelectionModel,java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GrayFilter\n+header extends java\/awt\/image\/RGBImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GroupLayout$Group\n+header extends javax\/swing\/GroupLayout$Spring nestHost javax\/swing\/GroupLayout sealed true flags 421\n+innerclass innerClass javax\/swing\/GroupLayout$Group outerClass javax\/swing\/GroupLayout innerClassName Group flags 401\n+innerclass innerClass javax\/swing\/GroupLayout$Spring outerClass javax\/swing\/GroupLayout innerClassName Spring flags 40a\n+innerclass innerClass javax\/swing\/GroupLayout$ParallelGroup outerClass javax\/swing\/GroupLayout innerClassName ParallelGroup flags 1\n+innerclass innerClass javax\/swing\/GroupLayout$SequentialGroup outerClass javax\/swing\/GroupLayout innerClassName SequentialGroup flags 11\n+\n+class name javax\/swing\/GroupLayout$ParallelGroup\n+header extends javax\/swing\/GroupLayout$Group nestHost javax\/swing\/GroupLayout sealed true flags 21\n+innerclass innerClass javax\/swing\/GroupLayout$ParallelGroup outerClass javax\/swing\/GroupLayout innerClassName ParallelGroup flags 1\n+innerclass innerClass javax\/swing\/GroupLayout$Group outerClass javax\/swing\/GroupLayout innerClassName Group flags 401\n+innerclass innerClass javax\/swing\/GroupLayout$Alignment outerClass javax\/swing\/GroupLayout innerClassName Alignment flags 4019\n+innerclass innerClass javax\/swing\/GroupLayout$Spring outerClass javax\/swing\/GroupLayout innerClassName Spring flags 40a\n+\n+class name javax\/swing\/JList\n+-method name setLayoutOrientation descriptor (I)V\n+method name setLayoutOrientation descriptor (I)V flags 1 runtimeAnnotations @Ljava\/beans\/BeanProperty;(visualUpdate=Ztrue,enumerationValues={\"JList.VERTICAL\"\"JList.HORIZONTAL_WRAP\"\"JList.VERTICAL_WRAP\"},description=\"Defines\\u005C;u0020;the\\u005C;u0020;way\\u005C;u0020;list\\u005C;u0020;cells\\u005C;u0020;are\\u005C;u0020;laid\\u005C;u0020;out.\")\n+\n+class name javax\/swing\/JList$AccessibleJList$AccessibleJListChild\n+-method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction;\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+\n+class name javax\/swing\/JTextPane\n+header extends javax\/swing\/JEditorPane flags 21 runtimeAnnotations @Ljava\/beans\/JavaBean;(description=\"A\\u005C;u0020;text\\u005C;u0020;component\\u005C;u0020;that\\u005C;u0020;can\\u005C;u0020;be\\u005C;u0020;marked\\u005C;u0020;up\\u005C;u0020;with\\u005C;u0020;attributes\\u005C;u0020;that\\u005C;u0020;are\\u005C;u0020;graphically\\u005C;u0020;represented.\")@Ljavax\/swing\/SwingContainer;\n+\n+class name javax\/swing\/LookAndFeel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/text\/JTextComponent$KeyBinding outerClass javax\/swing\/text\/JTextComponent innerClassName KeyBinding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/MenuSelectionManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SizeRequirements\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SortingFocusTraversalPolicy\n+header extends javax\/swing\/InternalFrameFocusTraversalPolicy flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SwingContainer\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/swing\/UIClientPropertyKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/swing\/border\/LineBorder\n+header extends javax\/swing\/border\/AbstractBorder flags 21\n+innerclass innerClass java\/awt\/geom\/RoundRectangle2D$Float outerClass java\/awt\/geom\/RoundRectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Float outerClass java\/awt\/geom\/Path2D innerClassName Float flags 9\n+\n+class name javax\/swing\/event\/EventListenerList\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListDataEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListSelectionEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/TreeModelEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileNameExtensionFilter\n+header extends javax\/swing\/filechooser\/FileFilter flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicArrowButton\n+header extends javax\/swing\/JButton implements javax\/swing\/SwingConstants flags 21\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicButtonUI\n+header extends javax\/swing\/plaf\/ButtonUI flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicPasswordFieldUI\n+header extends javax\/swing\/plaf\/basic\/BasicTextFieldUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicHorizontalLayoutManager\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2 nestHost javax\/swing\/plaf\/basic\/BasicSplitPaneUI sealed true flags 21\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicHorizontalLayoutManager outerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI innerClassName BasicHorizontalLayoutManager flags 1\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicVerticalLayoutManager outerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI innerClassName BasicVerticalLayoutManager flags 1\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarSeparatorUI\n+header extends javax\/swing\/plaf\/basic\/BasicSeparatorUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/metal\/MetalButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalCheckBoxUI\n+header extends javax\/swing\/plaf\/metal\/MetalRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalRadioButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToggleButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicToggleButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToolTipUI\n+header extends javax\/swing\/plaf\/basic\/BasicToolTipUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/multi\/MultiLookAndFeel\n+header extends javax\/swing\/LookAndFeel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthIcon\n+header extends java\/lang\/Object implements javax\/swing\/Icon flags 601\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuItemUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuItemUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthPasswordFieldUI\n+header extends javax\/swing\/plaf\/synth\/SynthTextFieldUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name installDefaults descriptor ()V flags 4\n+\n+class name javax\/swing\/plaf\/synth\/SynthSeparatorUI\n+header extends javax\/swing\/plaf\/SeparatorUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/synth\/SynthStyle\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/UIDefaults$LazyInputMap outerClass javax\/swing\/UIDefaults innerClassName LazyInputMap flags 9\n+innerclass innerClass javax\/swing\/UIDefaults$LazyValue outerClass javax\/swing\/UIDefaults innerClassName LazyValue flags 609\n+\n+class name javax\/swing\/table\/AbstractTableModel\n+header extends java\/lang\/Object implements javax\/swing\/table\/TableModel,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/AbstractWriter\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/BoxView\n+header extends javax\/swing\/text\/CompositeView flags 21\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/CompositeView\n+header extends javax\/swing\/text\/View flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/DateFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/DateFormat$Field outerClass java\/text\/DateFormat innerClassName Field flags 9\n+\n+class name javax\/swing\/text\/DefaultEditorKit\n+field name beginLineUpAction descriptor Ljava\/lang\/String; constantValue caret-begin-line-and-up flags 19\n+field name endLineDownAction descriptor Ljava\/lang\/String; constantValue caret-end-line-and-down flags 19\n+\n+class name javax\/swing\/text\/IconView\n+header extends javax\/swing\/text\/View flags 21\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/LayoutQueue\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/NumberFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/NumberFormat$Field outerClass java\/text\/NumberFormat innerClassName Field flags 9\n+innerclass innerClass javax\/swing\/text\/DocumentFilter$FilterBypass outerClass javax\/swing\/text\/DocumentFilter innerClassName FilterBypass flags 409\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/Segment\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/text\/CharacterIterator,java\/lang\/CharSequence flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/StyleConstants\n+header extends java\/lang\/Object nestMembers javax\/swing\/text\/StyleConstants$FontConstants,javax\/swing\/text\/StyleConstants$ColorConstants,javax\/swing\/text\/StyleConstants$CharacterConstants,javax\/swing\/text\/StyleConstants$ParagraphConstants sealed true flags 21\n+innerclass innerClass javax\/swing\/text\/StyleConstants$CharacterConstants outerClass javax\/swing\/text\/StyleConstants innerClassName CharacterConstants flags 19\n+innerclass innerClass javax\/swing\/text\/StyleConstants$FontConstants outerClass javax\/swing\/text\/StyleConstants innerClassName FontConstants flags 19\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ColorConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ColorConstants flags 19\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ParagraphConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ParagraphConstants flags 19\n+\n+class name javax\/swing\/text\/TabSet\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabStop\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/View\n+header extends java\/lang\/Object implements javax\/swing\/SwingConstants flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$EventType outerClass javax\/swing\/event\/DocumentEvent innerClassName EventType flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/InlineView\n+header extends javax\/swing\/text\/LabelView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ObjectView\n+header extends javax\/swing\/text\/ComponentView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/Option\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/ContentModel\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/DocumentParser\n+header extends javax\/swing\/text\/html\/parser\/Parser flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTMLEditorKit$ParserCallback outerClass javax\/swing\/text\/html\/HTMLEditorKit innerClassName ParserCallback flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/Parser\n+header extends java\/lang\/Object implements javax\/swing\/text\/html\/parser\/DTDConstants flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/TagElement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$UnknownTag outerClass javax\/swing\/text\/html\/HTML innerClassName UnknownTag flags 9\n+\n+class name javax\/swing\/tree\/DefaultTreeModel\n+header extends java\/lang\/Object implements java\/io\/Serializable,javax\/swing\/tree\/TreeModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/swing\/tree\/DefaultTreeSelectionModel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable,javax\/swing\/tree\/TreeSelectionModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/tree\/TreePath\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/AbstractUndoableEdit\n+header extends java\/lang\/Object implements javax\/swing\/undo\/UndoableEdit,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/CompoundEdit\n+header extends javax\/swing\/undo\/AbstractUndoableEdit flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/UndoableEditSupport\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.desktop-K.sym.txt","additions":871,"deletions":0,"binary":false,"changes":871,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.instrument-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.instrument-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.logging-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.logging-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,280 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.management\n+header exports java\/lang\/management,javax\/management,javax\/management\/loading,javax\/management\/modelmbean,javax\/management\/monitor,javax\/management\/openmbean,javax\/management\/relation,javax\/management\/remote,javax\/management\/timer requires name\\u0020;java.base\\u0020;flags\\u0020;8000 uses javax\/management\/remote\/JMXConnectorProvider,javax\/management\/remote\/JMXConnectorServerProvider,sun\/management\/spi\/PlatformMBeanProvider provides interface\\u0020;javax\/security\/auth\/spi\/LoginModule\\u0020;impls\\u0020;com\/sun\/jmx\/remote\/security\/FileLoginModule target linux-amd64 flags 8000 classAnnotations @Ljdk\/internal\/javac\/ParticipatesInPreview;\n+\n+class name java\/lang\/management\/LockInfo\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/ManagementPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MemoryUsage\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MonitorInfo\n+header extends java\/lang\/management\/LockInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/RuntimeMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Attribute\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/AttributeList\n+header extends java\/util\/ArrayList flags 21 signature Ljava\/util\/ArrayList<Ljava\/lang\/Object;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadAttributeValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadBinaryOpValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadStringOperationException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ConstructorParameters\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/management\/ImmutableDescriptor\n+header extends java\/lang\/Object implements javax\/management\/Descriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanAttributeInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanConstructorInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanNotificationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanOperationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanParameterInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerDelegate\n+header extends java\/lang\/Object implements javax\/management\/MBeanServerDelegateMBean,javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanTrustPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Notification\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ObjectInstance\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Query\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StandardEmitterMBean\n+header extends javax\/management\/StandardMBean implements javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StringValueExp\n+header extends java\/lang\/Object implements javax\/management\/ValueExp flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/loading\/DefaultLoaderRepository\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/loading\/MLet\n+header extends java\/net\/URLClassLoader implements javax\/management\/loading\/MLetMBean,javax\/management\/MBeanRegistration,java\/io\/Externalizable flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"20\")\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/loading\/MLetContent\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"20\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/loading\/MLetMBean\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"20\")\n+\n+class name javax\/management\/loading\/PrivateMLet\n+header extends javax\/management\/loading\/MLet implements javax\/management\/loading\/PrivateClassLoader flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"20\")\n+\n+class name javax\/management\/modelmbean\/InvalidTargetObjectTypeException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/XMLParseException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/ArrayType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,java\/io\/Serializable flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/CompositeData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanAttributeInfoSupport\n+header extends javax\/management\/MBeanAttributeInfo implements javax\/management\/openmbean\/OpenMBeanAttributeInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanOperationInfoSupport\n+header extends javax\/management\/MBeanOperationInfo implements javax\/management\/openmbean\/OpenMBeanOperationInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/SimpleType\n+header extends javax\/management\/openmbean\/OpenType flags 31 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/TabularData,java\/util\/Map,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature Ljava\/lang\/Object;Ljavax\/management\/openmbean\/TabularData;Ljava\/util\/Map<Ljava\/lang\/Object;Ljava\/lang\/Object;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/TabularData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RelationNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RelationSupport\n+header extends java\/lang\/Object implements javax\/management\/relation\/RelationSupportMBean,javax\/management\/MBeanRegistration flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/relation\/Role\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RoleUnresolved\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXConnectorServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXServiceURL\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/NotificationResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/TargetedNotification\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.management-K.sym.txt","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.management.rmi-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.management.rmi-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,85 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/naming\/BinaryRefAddr\n+header extends javax\/naming\/RefAddr flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Binding\n+header extends javax\/naming\/NameClassPair flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompositeName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompoundName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/LinkException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NameClassPair\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NamingException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/RefAddr\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Reference\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/AttributeModificationException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/ModificationItem\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/SearchResult\n+header extends javax\/naming\/Binding flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/spi\/DirectoryManager\n+header extends javax\/naming\/spi\/NamingManager flags 21\n+innerclass innerClass javax\/naming\/spi\/DirStateFactory$Result outerClass javax\/naming\/spi\/DirStateFactory innerClassName Result flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/spi\/NamingManager\n+-method name setObjectFactoryBuilder descriptor (Ljavax\/naming\/spi\/ObjectFactoryBuilder;)V\n+method name setObjectFactoryBuilder descriptor (Ljavax\/naming\/spi\/ObjectFactoryBuilder;)V thrownTypes javax\/naming\/NamingException flags 9\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.naming-K.sym.txt","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.rmi-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.rmi-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.scripting-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.scripting-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.security.jgss-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.security.jgss-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.security.sasl-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.security.sasl-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.smartcardio-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.smartcardio-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.sql-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.sql-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,73 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/sql\/rowset\/BaseRowSet\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SQLOutputImpl\n+header extends java\/lang\/Object implements java\/sql\/SQLOutput flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialArray\n+header extends java\/lang\/Object implements java\/sql\/Array,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialBlob\n+header extends java\/lang\/Object implements java\/sql\/Blob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialClob\n+header extends java\/lang\/Object implements java\/sql\/Clob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialDatalink\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialJavaObject\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialRef\n+header extends java\/lang\/Object implements java\/sql\/Ref,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialStruct\n+header extends java\/lang\/Object implements java\/sql\/Struct,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.sql.rowset-K.sym.txt","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.xml-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.xml-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.xml.crypto-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.xml.crypto-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.accessibility-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.accessibility-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.attach-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.attach-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,405 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/source\/doctree\/AuthorTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/BlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/CommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DeprecatedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocCommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocRootTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocTree$Kind\n+field name SPEC descriptor Lcom\/sun\/source\/doctree\/DocTree$Kind; flags 4019\n+\n+class name com\/sun\/source\/doctree\/DocTreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+method name visitSpec descriptor (Lcom\/sun\/source\/doctree\/SpecTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/doctree\/SpecTree;TP;)TR;\n+\n+class name com\/sun\/source\/doctree\/DocTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EndElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EntityTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/TextTree flags 601\n+\n+class name com\/sun\/source\/doctree\/HiddenTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IndexTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InheritDocTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LinkTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ParamTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ReferenceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SeeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialDataTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialFieldTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SinceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SpecTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+method name getURL descriptor ()Lcom\/sun\/source\/doctree\/TextTree; flags 401\n+method name getTitle descriptor ()Ljava\/util\/List; flags 401 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/doctree\/DocTree;>;\n+\n+class name com\/sun\/source\/doctree\/StartElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SummaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/TextTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ThrowsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownBlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownInlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ValueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+method name getFormat descriptor ()Lcom\/sun\/source\/doctree\/TextTree; flags 1\n+\n+class name com\/sun\/source\/doctree\/VersionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotatedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayAccessTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/AssertTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/AssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BinaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BlockTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/BreakTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CatchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CompilationUnitTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/CompoundAssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ConditionalExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ContinueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/DeconstructionPatternTree\n+-method name getVariable descriptor ()Lcom\/sun\/source\/tree\/VariableTree;\n+\n+class name com\/sun\/source\/tree\/DirectiveTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/DoWhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EmptyStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EnhancedForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree nestMembers com\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind flags 601\n+innerclass innerClass com\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind outerClass com\/sun\/source\/tree\/EnhancedForLoopTree innerClassName DeclarationKind flags 4019\n+method name getVariableOrRecordPattern descriptor ()Lcom\/sun\/source\/tree\/Tree; flags 401 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;RECORD_PATTERNS;,reflective=Ztrue)\n+method name getDeclarationKind descriptor ()Lcom\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind; flags 401 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;RECORD_PATTERNS;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind\n+header extends java\/lang\/Enum nestHost com\/sun\/source\/tree\/EnhancedForLoopTree flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind;>; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;RECORD_PATTERNS;,reflective=Ztrue)\n+innerclass innerClass com\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind outerClass com\/sun\/source\/tree\/EnhancedForLoopTree innerClassName DeclarationKind flags 4019\n+field name VARIABLE descriptor Lcom\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind; flags 4019\n+field name PATTERN descriptor Lcom\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind; flags 4019\n+method name values descriptor ()[Lcom\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind; flags 9\n+method name valueOf descriptor (Ljava\/lang\/String;)Lcom\/sun\/source\/tree\/EnhancedForLoopTree$DeclarationKind; flags 9\n+\n+class name com\/sun\/source\/tree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExportsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ImportTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/InstanceOfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree nestMembers com\/sun\/source\/tree\/InstanceOfTree$TestKind flags 601\n+innerclass innerClass com\/sun\/source\/tree\/InstanceOfTree$TestKind outerClass com\/sun\/source\/tree\/InstanceOfTree innerClassName TestKind flags 4019\n+method name getTestKind descriptor ()Lcom\/sun\/source\/tree\/InstanceOfTree$TestKind; flags 401 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;RECORD_PATTERNS;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/InstanceOfTree$TestKind\n+header extends java\/lang\/Enum nestHost com\/sun\/source\/tree\/InstanceOfTree flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/source\/tree\/InstanceOfTree$TestKind;>; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;RECORD_PATTERNS;,reflective=Ztrue)\n+innerclass innerClass com\/sun\/source\/tree\/InstanceOfTree$TestKind outerClass com\/sun\/source\/tree\/InstanceOfTree innerClassName TestKind flags 4019\n+field name TYPE descriptor Lcom\/sun\/source\/tree\/InstanceOfTree$TestKind; flags 4019\n+field name PATTERN descriptor Lcom\/sun\/source\/tree\/InstanceOfTree$TestKind; flags 4019\n+method name values descriptor ()[Lcom\/sun\/source\/tree\/InstanceOfTree$TestKind; flags 9\n+method name valueOf descriptor (Ljava\/lang\/String;)Lcom\/sun\/source\/tree\/InstanceOfTree$TestKind; flags 9\n+\n+class name com\/sun\/source\/tree\/IntersectionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/LabeledStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/LineMap\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MemberSelectTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodInvocationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ModifiersTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/NewArrayTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/NewClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/OpensTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/PackageTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParameterizedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParenthesizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/PatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/PrimitiveTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/RequiresTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ReturnTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Scope\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/StatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/SwitchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/SynchronizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ThrowTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/source\/tree\/TryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeCastTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeParameterTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UnaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/UnionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/VariableTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WildcardTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/util\/DocSourcePositions\n+header extends java\/lang\/Object implements com\/sun\/source\/util\/SourcePositions flags 601\n+\n+class name com\/sun\/source\/util\/DocTreeFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass com\/sun\/source\/doctree\/AttributeTree$ValueKind outerClass com\/sun\/source\/doctree\/AttributeTree innerClassName ValueKind flags 4019\n+method name newSpecTree descriptor (Lcom\/sun\/source\/doctree\/TextTree;Ljava\/util\/List;)Lcom\/sun\/source\/doctree\/SpecTree; flags 401 signature (Lcom\/sun\/source\/doctree\/TextTree;Ljava\/util\/List<+Lcom\/sun\/source\/doctree\/DocTree;>;)Lcom\/sun\/source\/doctree\/SpecTree;\n+method name newValueTree descriptor (Lcom\/sun\/source\/doctree\/TextTree;Lcom\/sun\/source\/doctree\/ReferenceTree;)Lcom\/sun\/source\/doctree\/ValueTree; flags 1\n+\n+class name com\/sun\/source\/util\/DocTreePathScanner\n+header extends com\/sun\/source\/util\/DocTreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/DocTreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTreeScanner\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+method name visitSpec descriptor (Lcom\/sun\/source\/doctree\/SpecTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/doctree\/SpecTree;TP;)TR;\n+\n+class name com\/sun\/source\/util\/DocTrees\n+header extends com\/sun\/source\/util\/Trees flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/source\/util\/JavacTask\n+header extends java\/lang\/Object implements javax\/tools\/JavaCompiler$CompilationTask flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+\n+class name com\/sun\/source\/util\/Plugin\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/SimpleDocTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+method name visitSpec descriptor (Lcom\/sun\/source\/doctree\/SpecTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/doctree\/SpecTree;TP;)TR;\n+\n+class name com\/sun\/source\/util\/SimpleTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/TreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/tree\/TreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/SourcePositions\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TaskListener\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TreePathScanner\n+header extends com\/sun\/source\/util\/TreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/TreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/Trees\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/tools\/javac\/Main\n+header extends java\/lang\/Object flags 21\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.compiler-K.sym.txt","additions":405,"deletions":0,"binary":false,"changes":405,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.dynalink-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.dynalink-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.httpserver-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.httpserver-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,78 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.incubator.concurrent\n+header exports jdk\/incubator\/concurrent requires name\\u0020;java.base\\u0020;flags\\u0020;8000 target linux-amd64 resolution 9 flags 8000 classAnnotations @Ljdk\/internal\/javac\/ParticipatesInPreview;\n+\n+class name jdk\/incubator\/concurrent\/ScopedValue\n+header extends java\/lang\/Object nestMembers jdk\/incubator\/concurrent\/ScopedValue$Carrier flags 31 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+innerclass innerClass jdk\/incubator\/concurrent\/ScopedValue$Carrier outerClass jdk\/incubator\/concurrent\/ScopedValue innerClassName Carrier flags 19\n+method name hashCode descriptor ()I flags 1\n+method name where descriptor (Ljdk\/incubator\/concurrent\/ScopedValue;Ljava\/lang\/Object;)Ljdk\/incubator\/concurrent\/ScopedValue$Carrier; flags 9 signature <T:Ljava\/lang\/Object;>(Ljdk\/incubator\/concurrent\/ScopedValue<TT;>;TT;)Ljdk\/incubator\/concurrent\/ScopedValue$Carrier;\n+method name where descriptor (Ljdk\/incubator\/concurrent\/ScopedValue;Ljava\/lang\/Object;Ljava\/util\/concurrent\/Callable;)Ljava\/lang\/Object; thrownTypes java\/lang\/Exception flags 9 signature <T:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>(Ljdk\/incubator\/concurrent\/ScopedValue<TT;>;TT;Ljava\/util\/concurrent\/Callable<+TR;>;)TR;\n+method name where descriptor (Ljdk\/incubator\/concurrent\/ScopedValue;Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V flags 9 signature <T:Ljava\/lang\/Object;>(Ljdk\/incubator\/concurrent\/ScopedValue<TT;>;TT;Ljava\/lang\/Runnable;)V\n+method name newInstance descriptor ()Ljdk\/incubator\/concurrent\/ScopedValue; flags 9 signature <T:Ljava\/lang\/Object;>()Ljdk\/incubator\/concurrent\/ScopedValue<TT;>;\n+method name get descriptor ()Ljava\/lang\/Object; flags 1 signature ()TT; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name isBound descriptor ()Z flags 1\n+method name orElse descriptor (Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (TT;)TT;\n+method name orElseThrow descriptor (Ljava\/util\/function\/Supplier;)Ljava\/lang\/Object; thrownTypes java\/lang\/Throwable flags 1 signature <X:Ljava\/lang\/Throwable;>(Ljava\/util\/function\/Supplier<+TX;>;)TT;^TX;\n+\n+class name jdk\/incubator\/concurrent\/ScopedValue$Carrier\n+header extends java\/lang\/Object nestHost jdk\/incubator\/concurrent\/ScopedValue flags 31\n+innerclass innerClass jdk\/incubator\/concurrent\/ScopedValue$Carrier outerClass jdk\/incubator\/concurrent\/ScopedValue innerClassName Carrier flags 19\n+method name where descriptor (Ljdk\/incubator\/concurrent\/ScopedValue;Ljava\/lang\/Object;)Ljdk\/incubator\/concurrent\/ScopedValue$Carrier; flags 1 signature <T:Ljava\/lang\/Object;>(Ljdk\/incubator\/concurrent\/ScopedValue<TT;>;TT;)Ljdk\/incubator\/concurrent\/ScopedValue$Carrier;\n+method name get descriptor (Ljdk\/incubator\/concurrent\/ScopedValue;)Ljava\/lang\/Object; flags 1 signature <T:Ljava\/lang\/Object;>(Ljdk\/incubator\/concurrent\/ScopedValue<TT;>;)TT;\n+method name call descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/lang\/Object; thrownTypes java\/lang\/Exception flags 1 signature <R:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/Callable<+TR;>;)TR;\n+method name run descriptor (Ljava\/lang\/Runnable;)V flags 1\n+\n+class name jdk\/incubator\/concurrent\/StructuredTaskScope\n+header extends java\/lang\/Object implements java\/lang\/AutoCloseable nestMembers jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnFailure,jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnSuccess flags 21 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/lang\/AutoCloseable;\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/util\/concurrent\/ConcurrentHashMap$KeySetView outerClass java\/util\/concurrent\/ConcurrentHashMap innerClassName KeySetView flags 19\n+innerclass innerClass java\/util\/concurrent\/Future$State outerClass java\/util\/concurrent\/Future innerClassName State flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+innerclass innerClass jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnFailure outerClass jdk\/incubator\/concurrent\/StructuredTaskScope innerClassName ShutdownOnFailure flags 19\n+innerclass innerClass jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnSuccess outerClass jdk\/incubator\/concurrent\/StructuredTaskScope innerClassName ShutdownOnSuccess flags 19\n+\n+class name jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnFailure\n+header extends jdk\/incubator\/concurrent\/StructuredTaskScope nestHost jdk\/incubator\/concurrent\/StructuredTaskScope flags 31 signature Ljdk\/incubator\/concurrent\/StructuredTaskScope<Ljava\/lang\/Object;>;\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/util\/concurrent\/Future$State outerClass java\/util\/concurrent\/Future innerClassName State flags 4019\n+innerclass innerClass jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnFailure outerClass jdk\/incubator\/concurrent\/StructuredTaskScope innerClassName ShutdownOnFailure flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnSuccess\n+header extends jdk\/incubator\/concurrent\/StructuredTaskScope nestHost jdk\/incubator\/concurrent\/StructuredTaskScope flags 31 signature <T:Ljava\/lang\/Object;>Ljdk\/incubator\/concurrent\/StructuredTaskScope<TT;>;\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/util\/concurrent\/Future$State outerClass java\/util\/concurrent\/Future innerClassName State flags 4019\n+innerclass innerClass jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnSuccess outerClass jdk\/incubator\/concurrent\/StructuredTaskScope innerClassName ShutdownOnSuccess flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.incubator.concurrent-K.sym.txt","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.incubator.vector\n+header exports jdk\/incubator\/vector requires name\\u0020;java.base\\u0020;flags\\u0020;8000 target linux-amd64 resolution 9 flags 8000 classAnnotations @Ljdk\/internal\/javac\/ParticipatesInPreview;\n+\n+class name jdk\/incubator\/vector\/ByteVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Byte;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/vector\/DoubleVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Double;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/vector\/FloatVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Float;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/vector\/IntVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Integer;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/vector\/LongVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Long;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/vector\/ShortVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Short;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.incubator.vector-K.sym.txt","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.jartool\n+header exports com\/sun\/jarsigner,jdk\/security\/jarsigner requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;jdk.internal.opt\\u0020;flags\\u0020;0 provides interface\\u0020;java\/util\/spi\/ToolProvider\\u0020;impls\\u0020;sun\/tools\/jar\/JarToolProvider target linux-amd64 flags 8000\n+\n+class name jdk\/security\/jarsigner\/JarSignerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jartool-K.sym.txt","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.javadoc-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.javadoc-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jconsole-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jconsole-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,395 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/jdi\/AbsentInformationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/Accessible\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ArrayReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ArrayType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/BooleanType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/BooleanValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue flags 601\n+\n+class name com\/sun\/jdi\/Bootstrap\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/jdi\/ByteType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ByteValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ByteValue;>;\n+\n+class name com\/sun\/jdi\/CharType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/CharValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/CharValue;>;\n+\n+class name com\/sun\/jdi\/ClassLoaderReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassNotLoadedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/ClassNotPreparedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ClassObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/DoubleType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/DoubleValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/DoubleValue;>;\n+\n+class name com\/sun\/jdi\/Field\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Field;>;\n+\n+class name com\/sun\/jdi\/FloatType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/FloatValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/FloatValue;>;\n+\n+class name com\/sun\/jdi\/IncompatibleThreadStateException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InconsistentDebugInfoException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/IntegerType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/IntegerValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/IntegerValue;>;\n+\n+class name com\/sun\/jdi\/InterfaceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/InternalException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidCodeIndexException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidLineNumberException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidStackFrameException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidTypeException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InvocationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/JDIPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/jdi\/LocalVariable\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LocalVariable;>;\n+\n+class name com\/sun\/jdi\/Locatable\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/Location\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Location;>;\n+\n+class name com\/sun\/jdi\/LongType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/LongValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LongValue;>;\n+\n+class name com\/sun\/jdi\/Method\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,com\/sun\/jdi\/Locatable,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Lcom\/sun\/jdi\/Locatable;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Method;>;\n+\n+class name com\/sun\/jdi\/Mirror\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ModuleReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/MonitorInfo\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/ObjectCollectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/OpaqueFrameException\n+header extends java\/lang\/RuntimeException sealed true flags 21\n+\n+class name com\/sun\/jdi\/PathSearchingVirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/VirtualMachine flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/ReferenceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type,java\/lang\/Comparable,com\/sun\/jdi\/Accessible flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Type;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ReferenceType;>;Lcom\/sun\/jdi\/Accessible;\n+\n+class name com\/sun\/jdi\/ShortType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ShortValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ShortValue;>;\n+\n+class name com\/sun\/jdi\/StackFrame\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/StringReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadGroupReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/Type\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/TypeComponent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Accessible flags 601\n+\n+class name com\/sun\/jdi\/VMCannotBeModifiedException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+\n+class name com\/sun\/jdi\/VMDisconnectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMMismatchException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMOutOfMemoryException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/Value\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachineManager\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/VoidType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/VoidValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/connect\/AttachingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/IllegalConnectorArgumentsException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/LaunchingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/ListeningConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/Transport\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/connect\/TransportTimeoutException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/VMStartException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/ClosedConnectionException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/Connection\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/jdi\/event\/AccessWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/BreakpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassPrepareEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassUnloadEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/Event\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventIterator\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/EventQueue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventSet\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/util\/Set flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/util\/Set<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/ExceptionEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/LocatableEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodEntryEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodExitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ModificationWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnterEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnteredEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitedEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/StepEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDisconnectEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/WatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/request\/AccessWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/BreakpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassPrepareRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassUnloadRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/DuplicateRequestException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/EventRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/EventRequestManager\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/ExceptionRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/InvalidRequestStateException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/MethodEntryRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MethodExitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ModificationWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnterRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnteredRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitedRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/StepRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadStartRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/VMDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/WatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jdi-K.sym.txt","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jfr\/consumer\/RecordedObject\n+header extends java\/lang\/Object sealed true flags 21\n+\n+class name jdk\/jfr\/consumer\/RecordingStream\n+method name stop descriptor ()Z flags 1\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jfr-K.sym.txt","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.jlink\n+header requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;jdk.internal.opt\\u0020;flags\\u0020;0,name\\u0020;jdk.jdeps\\u0020;flags\\u0020;0 uses jdk\/tools\/jlink\/plugin\/Plugin provides interface\\u0020;java\/util\/spi\/ToolProvider\\u0020;impls\\u0020;jdk\/tools\/jmod\/Main$JmodToolProvider\\u005C;u002C;jdk\/tools\/jlink\/internal\/Main$JlinkToolProvider,interface\\u0020;jdk\/tools\/jlink\/plugin\/Plugin\\u0020;impls\\u0020;jdk\/tools\/jlink\/internal\/plugins\/DefaultStripDebugPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludePlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludeFilesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludeJmodSectionPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/LegalNoticeFilePlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/StripNativeCommandsPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/OrderResourcesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/DefaultCompressPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludeVMPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/IncludeLocalesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/GenerateJLIClassesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ReleaseInfoPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/AddOptionsPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/VendorBugURLPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/VendorVMBugURLPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/VendorVersionPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/CDSPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/SaveJlinkArgfilesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/StripNativeDebugSymbolsPlugin target linux-amd64 flags 8000\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jlink-K.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.jpackage\n+header requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;jdk.internal.opt\\u0020;flags\\u0020;0,name\\u0020;jdk.jlink\\u0020;flags\\u0020;0,name\\u0020;java.desktop\\u0020;flags\\u0020;0 uses jdk\/jpackage\/internal\/Bundler,jdk\/jpackage\/internal\/Bundlers provides interface\\u0020;java\/util\/spi\/ToolProvider\\u0020;impls\\u0020;jdk\/jpackage\/internal\/JPackageToolProvider,interface\\u0020;jdk\/jpackage\/internal\/Bundler\\u0020;impls\\u0020;jdk\/jpackage\/internal\/LinuxAppBundler\\u005C;u002C;jdk\/jpackage\/internal\/LinuxDebBundler\\u005C;u002C;jdk\/jpackage\/internal\/LinuxRpmBundler,interface\\u0020;jdk\/jpackage\/internal\/Bundlers\\u0020;impls\\u0020;jdk\/jpackage\/internal\/BasicBundlers target linux-amd64 flags 8000\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jpackage-K.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jshell\/DeclarationSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/Diag\n+header extends java\/lang\/Object flags 421\n+\n+class name jdk\/jshell\/EvalException\n+header extends jdk\/jshell\/JShellException flags 21\n+\n+class name jdk\/jshell\/ExpressionSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/ImportSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/JShellException\n+header extends java\/lang\/Exception flags 21\n+\n+class name jdk\/jshell\/MethodSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/PersistentSnippet\n+header extends jdk\/jshell\/Snippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/SnippetEvent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$Status outerClass jdk\/jshell\/Snippet innerClassName Status flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/StatementSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/TypeDeclSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/execution\/DirectExecutionControl\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$RunException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName RunException flags 409\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass java\/util\/PrimitiveIterator$OfInt outerClass java\/util\/PrimitiveIterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/Character$UnicodeBlock outerClass java\/lang\/Character innerClassName UnicodeBlock flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ResolutionException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ResolutionException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$UserException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName UserException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ExecutionControlException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ExecutionControlException flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/FailOverExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiDefaultExecutionControl\n+header extends jdk\/jshell\/execution\/JdiExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$RunException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName RunException flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/execution\/LoaderDelegate\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+\n+class name jdk\/jshell\/execution\/LocalExecutionControl\n+header extends jdk\/jshell\/execution\/DirectExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$StoppedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName StoppedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name load descriptor ([Ljdk\/jshell\/spi\/ExecutionControl$ClassBytecodes;)V thrownTypes jdk\/jshell\/spi\/ExecutionControl$ClassInstallException,jdk\/jshell\/spi\/ExecutionControl$NotImplementedException,jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException flags 1\n+\n+class name jdk\/jshell\/execution\/LocalExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/spi\/ExecutionControlProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/ExecutionEnv\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/SPIResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/jshell\/tool\/JavaShellToolBuilder\n+header extends java\/lang\/Object flags 601\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jshell-K.sym.txt","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jsobject-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jsobject-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,46 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/management\/GarbageCollectionNotificationInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/GarbageCollectorMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/GarbageCollectorMXBean flags 601\n+\n+class name com\/sun\/management\/GcInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/OperatingSystemMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/OperatingSystemMXBean flags 601\n+\n+class name com\/sun\/management\/ThreadMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/ThreadMXBean flags 601\n+\n+class name com\/sun\/management\/UnixOperatingSystemMXBean\n+header extends java\/lang\/Object implements com\/sun\/management\/OperatingSystemMXBean flags 601\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.management-K.sym.txt","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/management\/jfr\/RemoteRecordingStream\n+method name stop descriptor ()Z flags 1\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.management.jfr-K.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/net\/NetworkPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.net-K.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.sctp-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.sctp-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.security.auth-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.security.auth-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.security.jgss-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.security.jgss-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.unsupported-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.unsupported-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.xml.dom-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.xml.dom-J.sym.txt","status":"copied"},{"patch":"@@ -32,1 +32,1 @@\n-generate platforms 8:9:A:B:C:D:E:F:G:H:I:J\n+generate platforms 8:9:A:B:C:D:E:F:G:H:I:J:K\n@@ -45,0 +45,1 @@\n+platform version K base J files java.base-K.sym.txt:java.compiler-K.sym.txt:java.datatransfer-K.sym.txt:java.desktop-K.sym.txt:java.instrument-K.sym.txt:java.logging-K.sym.txt:java.management-K.sym.txt:java.management.rmi-K.sym.txt:java.naming-K.sym.txt:java.rmi-K.sym.txt:java.scripting-K.sym.txt:java.security.jgss-K.sym.txt:java.security.sasl-K.sym.txt:java.smartcardio-K.sym.txt:java.sql-K.sym.txt:java.sql.rowset-K.sym.txt:java.xml-K.sym.txt:java.xml.crypto-K.sym.txt:jdk.accessibility-K.sym.txt:jdk.attach-K.sym.txt:jdk.compiler-K.sym.txt:jdk.dynalink-K.sym.txt:jdk.httpserver-K.sym.txt:jdk.incubator.concurrent-K.sym.txt:jdk.incubator.vector-K.sym.txt:jdk.jartool-K.sym.txt:jdk.javadoc-K.sym.txt:jdk.jconsole-K.sym.txt:jdk.jdi-K.sym.txt:jdk.jfr-K.sym.txt:jdk.jlink-K.sym.txt:jdk.jpackage-K.sym.txt:jdk.jshell-K.sym.txt:jdk.jsobject-K.sym.txt:jdk.management-K.sym.txt:jdk.management.jfr-K.sym.txt:jdk.net-K.sym.txt:jdk.sctp-K.sym.txt:jdk.security.auth-K.sym.txt:jdk.security.jgss-K.sym.txt:jdk.unsupported-K.sym.txt:jdk.xml.dom-K.sym.txt\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/symbols","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    private String filename;\n+    private final String filename;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    private ByteArrayOutputStream dataBuffer = new ByteArrayOutputStream();\n+    private final ByteArrayOutputStream dataBuffer = new ByteArrayOutputStream();\n@@ -115,1 +115,1 @@\n-    private ByteArrayOutputStream aadBuffer = new ByteArrayOutputStream();\n+    private final ByteArrayOutputStream aadBuffer = new ByteArrayOutputStream();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1324,1 +1324,1 @@\n-    private SessionKeyRef ref;\n+    private final SessionKeyRef ref;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-    private ByteArrayOutputStream dataBuffer = new ByteArrayOutputStream();\n+    private final ByteArrayOutputStream dataBuffer = new ByteArrayOutputStream();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -628,1 +628,1 @@\n-    private static final PublicKey constructPublicKey(byte[] encodedKey,\n+    private static PublicKey constructPublicKey(byte[] encodedKey,\n@@ -655,1 +655,1 @@\n-    private static final PrivateKey constructPrivateKey(byte[] encodedKey,\n+    private static PrivateKey constructPrivateKey(byte[] encodedKey,\n@@ -682,1 +682,1 @@\n-    private static final SecretKey constructSecretKey(byte[] encodedKey,\n+    private static SecretKey constructSecretKey(byte[] encodedKey,\n@@ -687,1 +687,1 @@\n-    static final Key constructKey(byte[] encoding, String keyAlgorithm,\n+    static Key constructKey(byte[] encoding, String keyAlgorithm,\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSACipher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    private long mechanism;\n+    private final long mechanism;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsRsaPremasterSecretGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    private static Object LOCK = new Object();\n+    private static final Object LOCK = new Object();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Util.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        while ((next = (SessionRef) SessionRef.refQueue.poll())!= null) {\n+        while ((next = (SessionRef) SessionRef.REF_QUEUE.poll())!= null) {\n@@ -153,1 +153,1 @@\n-    static ReferenceQueue<Session> refQueue = new ReferenceQueue<>();\n+    static final ReferenceQueue<Session> REF_QUEUE = new ReferenceQueue<>();\n@@ -155,1 +155,1 @@\n-    private static Set<SessionRef> refList =\n+    private static final Set<SessionRef> REF_LIST =\n@@ -159,2 +159,2 @@\n-    private long id;\n-    private Token token;\n+    private final long id;\n+    private final Token token;\n@@ -163,1 +163,1 @@\n-        super(session, refQueue);\n+        super(session, REF_QUEUE);\n@@ -166,1 +166,1 @@\n-        refList.add(this);\n+        REF_LIST.add(this);\n@@ -170,1 +170,1 @@\n-        refList.remove(this);\n+        REF_LIST.remove(this);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Session.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    private AtomicInteger activeSessions = new AtomicInteger();\n+    private final AtomicInteger activeSessions = new AtomicInteger();\n@@ -91,1 +91,1 @@\n-    private Object maxActiveSessionsLock;\n+    private final Object maxActiveSessionsLock;\n@@ -115,3 +115,3 @@\n-        if (debug != null) {\n-            maxActiveSessionsLock = new Object();\n-        }\n+        this.maxActiveSessionsLock = (debug != null)\n+                ? new Object()\n+                : null;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SessionManager.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-class Token implements Serializable {\n+final class Token implements Serializable {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,838 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.concurrent;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.internal.vm.ScopedValueContainer;\n+import sun.security.action.GetPropertyAction;\n+\n+\/**\n+ * A value that is set once and is then available for reading for a bounded period of\n+ * execution by a thread. A {@code ScopedValue} allows for safely and efficiently sharing\n+ * data for a bounded period of execution without passing the data as method arguments.\n+ *\n+ * <p> {@code ScopedValue} defines the {@link #where(ScopedValue, Object, Runnable)}\n+ * method to set the value of a {@code ScopedValue} for the bouned period of execution by\n+ * a thread of the runnable's {@link Runnable#run() run} method. The unfolding execution of\n+ * the methods executed by {@code run} defines a <b><em>dynamic scope<\/em><\/b>. The scoped\n+ * value is {@linkplain #isBound() bound} while executing in the dynamic scope, it reverts\n+ * to being <em>unbound<\/em> when the {@code run} method completes (normally or with an\n+ * exception). Code executing in the dynamic scope uses the {@code ScopedValue} {@link\n+ * #get() get} method to read its value.\n+ *\n+ * <p> Like a {@linkplain ThreadLocal thread-local variable}, a scoped value has multiple\n+ * incarnations, one per thread. The particular incarnation that is used depends on which\n+ * thread calls its methods.\n+ *\n+ * <p> Consider the following example with a scoped value {@code USERNAME} that is\n+ * <em>bound<\/em> to the value \"{@code duke}\" for the execution, by a thread, of a run\n+ * method that invokes {@code doSomething()}.\n+ * {@snippet lang=java :\n+ *     \/\/ @link substring=\"newInstance\" target=\"#newInstance\" :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *\n+ *     ScopedValue.where(USERNAME, \"duke\", () -> doSomething());\n+ * }\n+ * Code executed directly or indirectly by {@code doSomething()} that invokes {@code\n+ * USERNAME.get()} will read the value \"{@code duke}\". The scoped value is bound while\n+ * executing {@code doSomething()} and becomes unbound when {@code doSomething()}\n+ * completes (normally or with an exception). If one thread were to call {@code\n+ * doSomething()} with {@code USERNAME} bound to \"{@code duke1}\", and another thread\n+ * were to call the method with {@code USERNAME} bound to \"{@code duke2}\", then\n+ * {@code USERNAME.get()} would read the value \"{@code duke1}\" or \"{@code duke2}\",\n+ * depending on which thread is executing.\n+ *\n+ * <p> In addition to the {@code where} method that executes a {@code run} method, {@code\n+ * ScopedValue} defines the {@link #where(ScopedValue, Object, Callable)} method to execute\n+ * a method that returns a result. It also defines the {@link #where(ScopedValue, Object)}\n+ * method for cases where it is useful to accumulate mappings of {@code ScopedValue} to\n+ * value.\n+ *\n+ * <p> A {@code ScopedValue} will typically be declared in a {@code final} and {@code\n+ * static} field. The accessibility of the field will determine which components can\n+ * bind or read its value.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n+ * class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * <h2><a id=\"rebind\">Rebinding<\/a><\/h2>\n+ *\n+ * The {@code ScopedValue} API allows a new binding to be established for <em>nested\n+ * dynamic scopes<\/em>. This is known as <em>rebinding<\/em>. A {@code ScopedValue} that\n+ * is bound to some value may be bound to a new value for the bounded execution of some\n+ * method. The unfolding execution of code executed by that method defines the nested\n+ * dynamic scope. When the method completes (normally or with an exception), the value of\n+ * the {@code ScopedValue} reverts to its previous value.\n+ *\n+ * <p> In the above example, suppose that code executed by {@code doSomething()} binds\n+ * {@code USERNAME} to a new value with:\n+ * {@snippet lang=java :\n+ *     ScopedValue.where(USERNAME, \"duchess\", () -> doMore());\n+ * }\n+ * Code executed directly or indirectly by {@code doMore()} that invokes {@code\n+ * USERNAME.get()} will read the value \"{@code duchess}\". When {@code doMore()} completes\n+ * (normally or with an exception), the value of {@code USERNAME} reverts to\n+ * \"{@code duke}\".\n+ *\n+ * <h2><a id=\"inheritance\">Inheritance<\/a><\/h2>\n+ *\n+ * {@code ScopedValue} supports sharing data across threads. This sharing is limited to\n+ * structured cases where child threads are started and terminate within the bounded\n+ * period of execution by a parent thread. More specifically, when using a {@link\n+ * StructuredTaskScope}, scoped value bindings are <em>captured<\/em> when creating a\n+ * {@code StructuredTaskScope} and inherited by all threads started in that scope with\n+ * the {@link StructuredTaskScope#fork(Callable) fork} method.\n+ *\n+ * <p> In the following example, the {@code ScopedValue} {@code USERNAME} is bound to the\n+ * value \"{@code duke}\" for the execution of a runnable operation. The code in the {@code\n+ * run} method creates a {@code StructuredTaskScope} and forks three child threads. Code\n+ * executed directly or indirectly by these threads running {@code childTask1()},\n+ * {@code childTask2()}, and {@code childTask3()} will read the value \"{@code duke}\".\n+ *\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+\n+ *     ScopedValue.where(USERNAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask1());\n+ *             scope.fork(() -> childTask2());\n+ *             scope.fork(() -> childTask3());\n+ *\n+ *             ...\n+ *          }\n+ *     });\n+ * }\n+ *\n+ * @implNote\n+ * Scoped values are designed to be used in fairly small\n+ * numbers. {@link #get} initially performs a search through enclosing\n+ * scopes to find a scoped value's innermost binding. It\n+ * then caches the result of the search in a small thread-local\n+ * cache. Subsequent invocations of {@link #get} for that scoped value\n+ * will almost always be very fast. However, if a program has many\n+ * scoped values that it uses cyclically, the cache hit rate\n+ * will be low and performance will be poor. This design allows\n+ * scoped-value inheritance by {@link StructuredTaskScope} threads to\n+ * be very fast: in essence, no more than copying a pointer, and\n+ * leaving a scoped-value binding also requires little more than\n+ * updating a pointer.\n+ *\n+ * <p>Because the scoped-value per-thread cache is small, clients\n+ * should minimize the number of bound scoped values in use. For\n+ * example, if it is necessary to pass a number of values in this way,\n+ * it makes sense to create a record class to hold those values, and\n+ * then bind a single {@code ScopedValue} to an instance of that record.\n+ *\n+ * <p>For this incubator release, the reference implementation\n+ * provides some system properties to tune the performance of scoped\n+ * values.\n+ *\n+ * <p>The system property {@code jdk.incubator.concurrent.ScopedValue.cacheSize}\n+ * controls the size of the (per-thread) scoped-value cache. This cache is crucial\n+ * for the performance of scoped values. If it is too small,\n+ * the runtime library will repeatedly need to scan for each\n+ * {@link #get}. If it is too large, memory will be unnecessarily\n+ * consumed. The default scoped-value cache size is 16 entries. It may\n+ * be varied from 2 to 16 entries in size. {@code ScopedValue.cacheSize}\n+ * must be an integer power of 2.\n+ *\n+ * <p>For example, you could use {@code -Djdk.incubator.concurrent.ScopedValue.cacheSize=8}.\n+ *\n+ * <p>The other system property is {@code jdk.preserveScopedValueCache}.\n+ * This property determines whether the per-thread scoped-value\n+ * cache is preserved when a virtual thread is blocked. By default\n+ * this property is set to {@code true}, meaning that every virtual\n+ * thread preserves its scoped-value cache when blocked. Like {@code\n+ * ScopedValue.cacheSize}, this is a space versus speed trade-off: in\n+ * situations where many virtual threads are blocked most of the time,\n+ * setting this property to {@code false} might result in a useful\n+ * memory saving, but each virtual thread's scoped-value cache would\n+ * have to be regenerated after a blocking operation.\n+ *\n+ * @param <T> the type of the object bound to this {@code ScopedValue}\n+ * @since 20\n+ *\/\n+public final class ScopedValue<T> {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private final @Stable int hash;\n+\n+    @Override\n+    public int hashCode() { return hash; }\n+\n+    \/**\n+     * An immutable map from {@code ScopedValue} to values.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+     * or method in this class will cause a {@link NullPointerException} to be thrown.\n+     *\/\n+    static final class Snapshot {\n+        final Snapshot prev;\n+        final Carrier bindings;\n+        final int bitmask;\n+\n+        private static final Object NIL = new Object();\n+\n+        static final Snapshot EMPTY_SNAPSHOT = new Snapshot();\n+\n+        Snapshot(Carrier bindings, Snapshot prev) {\n+            this.prev = prev;\n+            this.bindings = bindings;\n+            this.bitmask = bindings.bitmask | prev.bitmask;\n+        }\n+\n+        protected Snapshot() {\n+            this.prev = null;\n+            this.bindings = null;\n+            this.bitmask = 0;\n+        }\n+\n+        Object find(ScopedValue<?> key) {\n+            int bits = key.bitmask();\n+            for (Snapshot snapshot = this;\n+                 containsAll(snapshot.bitmask, bits);\n+                 snapshot = snapshot.prev) {\n+                for (Carrier carrier = snapshot.bindings;\n+                     carrier != null && containsAll(carrier.bitmask, bits);\n+                     carrier = carrier.prev) {\n+                    if (carrier.getKey() == key) {\n+                        Object value = carrier.get();\n+                        return value;\n+                    }\n+                }\n+            }\n+            return NIL;\n+        }\n+    }\n+\n+    \/**\n+     * A mapping of scoped values, as <em>keys<\/em>, to values.\n+     *\n+     * <p> A {@code Carrier} is used to accumlate mappings so that an operation (a\n+     * {@link Runnable} or {@link Callable}) can be executed with all scoped values in the\n+     * mapping bound to values. The following example runs an operation with {@code k1}\n+     * bound (or rebound) to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"where\" target=\"#where(ScopedValue, Object)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * <p> A {@code Carrier} is immutable and thread-safe. The {@link\n+     * #where(ScopedValue, Object) where} method returns a new {@code Carrier} object,\n+     * it does not mutate an existing mapping.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method in\n+     * this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @since 20\n+     *\/\n+    public static final class Carrier {\n+        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n+        \/\/ hits that slot in the cache.\n+        final int bitmask;\n+        final ScopedValue<?> key;\n+        final Object value;\n+        final Carrier prev;\n+\n+        Carrier(ScopedValue<?> key, Object value, Carrier prev) {\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n+            int bits = key.bitmask();\n+            if (prev != null) {\n+                bits |= prev.bitmask;\n+            }\n+            this.bitmask = bits;\n+        }\n+\n+        \/**\n+         * Add a binding to this map, returning a new Carrier instance.\n+         *\/\n+        private static final <T> Carrier where(ScopedValue<T> key, T value,\n+                                               Carrier prev) {\n+            return new Carrier(key, value, prev);\n+        }\n+\n+        \/**\n+         * Returns a new {@code Carrier} with the mappings from this carrier plus a\n+         * new mapping from {@code key} to {@code value}. If this carrier already has a\n+         * mapping for the scoped value {@code key} then it will map to the new\n+         * {@code value}. The current carrier is immutable, so it is not changed by this\n+         * method.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param value the value, can be {@code null}\n+         * @param <T> the type of the value\n+         * @return a new {@code Carrier} with the mappings from this carrier plus the new mapping\n+         *\/\n+        public <T> Carrier where(ScopedValue<T> key, T value) {\n+            return where(key, value, this);\n+        }\n+\n+        \/*\n+         * Return a new set consisting of a single binding.\n+         *\/\n+        static <T> Carrier of(ScopedValue<T> key, T value) {\n+            return where(key, value, null);\n+        }\n+\n+        final Object get() {\n+            return value;\n+        }\n+\n+        final ScopedValue<?> getKey() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Returns the value of a {@link ScopedValue} in this mapping.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param <T> the type of the value\n+         * @return the value\n+         * @throws NoSuchElementException if the key is not present in this mapping\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T get(ScopedValue<T> key) {\n+            var bits = key.bitmask();\n+            for (Carrier carrier = this;\n+                 carrier != null && containsAll(carrier.bitmask, bits);\n+                 carrier = carrier.prev) {\n+                if (carrier.getKey() == key) {\n+                    Object value = carrier.get();\n+                    return (T)value;\n+                }\n+            }\n+            throw new NoSuchElementException();\n+        }\n+\n+        \/**\n+         * Calls a value-returning operation with each scoped value in this mapping bound\n+         * to its value in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @param <R> the type of the result of the operation\n+         * @return the result\n+         * @throws Exception if {@code op} completes with an exception\n+         * @see ScopedValue#where(ScopedValue, Object, Callable)\n+         *\/\n+        public <R> R call(Callable<? extends R> op) throws Exception {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            return runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Execute the action with a set of ScopedValue bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        @Hidden\n+        @ForceInline\n+        private <R> R runWith(Snapshot newSnapshot, Callable<R> op) throws Exception {\n+            try {\n+                JLA.setScopedValueBindings(newSnapshot);\n+                JLA.ensureMaterializedForStackWalk(newSnapshot);\n+                return ScopedValueContainer.call(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                JLA.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+\n+        \/**\n+         * Runs an operation with each scoped value in this mapping bound to its value\n+         * in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @see ScopedValue#where(ScopedValue, Object, Runnable)\n+         *\/\n+        public void run(Runnable op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Execute the action with a set of {@code ScopedValue} bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        @Hidden\n+        @ForceInline\n+        private void runWith(Snapshot newSnapshot, Runnable op) {\n+            try {\n+                JLA.setScopedValueBindings(newSnapshot);\n+                JLA.ensureMaterializedForStackWalk(newSnapshot);\n+                ScopedValueContainer.run(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                JLA.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new {@code Carrier} with a single mapping of a {@code ScopedValue}\n+     * <em>key<\/em> to a value. The {@code Carrier} can be used to accumlate mappings so\n+     * that an operation can be executed with all scoped values in the mapping bound to\n+     * values. The following example runs an operation with {@code k1} bound (or rebound)\n+     * to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @return a new {@code Carrier} with a single mapping\n+     *\/\n+    public static <T> Carrier where(ScopedValue<T> key, T value) {\n+        return Carrier.of(key, value);\n+    }\n+\n+    \/**\n+     * Calls a value-returning operation with a {@code ScopedValue} bound to a value\n+     * in the current thread. When the operation completes (normally or with an\n+     * exception), the {@code ScopedValue} will revert to being unbound, or revert to\n+     * its previous value when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"call\" target=\"Carrier#call(Callable)\" :\n+     *     ScopedValue.where(key, value).call(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param <R> the result type\n+     * @param op the operation to call\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public static <T, R> R where(ScopedValue<T> key,\n+                                 T value,\n+                                 Callable<? extends R> op) throws Exception {\n+        return where(key, value).call(op);\n+    }\n+\n+    \/**\n+     * Run an operation with a {@code ScopedValue} bound to a value in the current\n+     * thread. When the operation completes (normally or with an exception), the\n+     * {@code ScopedValue} will revert to being unbound, or revert to its previous value\n+     * when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(key, value).run(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param op the operation to call\n+     *\/\n+    public static <T> void where(ScopedValue<T> key, T value, Runnable op) {\n+        where(key, value).run(op);\n+    }\n+\n+    private ScopedValue() {\n+        this.hash = generateKey();\n+    }\n+\n+    \/**\n+     * Creates a scoped value that is initially unbound for all threads.\n+     *\n+     * @param <T> the type of the value\n+     * @return a new {@code ScopedValue}\n+     *\/\n+    public static <T> ScopedValue<T> newInstance() {\n+        return new ScopedValue<T>();\n+    }\n+\n+    \/**\n+     * {@return the value of the scoped value if bound in the current thread}\n+     *\n+     * @throws NoSuchElementException if the scoped value is not bound\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = scopedValueCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private T slowGet() {\n+        var value = findBinding();\n+        if (value == Snapshot.NIL) {\n+            throw new NoSuchElementException();\n+        }\n+        Cache.put(this, value);\n+        return (T)value;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if this scoped value is bound in the current thread}\n+     *\/\n+    public boolean isBound() {\n+        Object[] objects = scopedValueCache();\n+        if (objects != null) {\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+        }\n+        var value = findBinding();\n+        boolean result = (value != Snapshot.NIL);\n+        if (result)  Cache.put(this, value);\n+        return result;\n+    }\n+\n+    \/**\n+     * Return the value of the scoped value or NIL if not bound.\n+     *\/\n+    private Object findBinding() {\n+        Object value = scopedValueBindings().find(this);\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * returns {@code other}.\n+     *\n+     * @param other the value to return if not bound, can be {@code null}\n+     * @return the value of the scoped value if bound, otherwise {@code other}\n+     *\/\n+    public T orElse(T other) {\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            return other;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * throws an exception produced by the exception supplying function.\n+     *\n+     * @param <X> the type of the exception that may be thrown\n+     * @param exceptionSupplier the supplying function that produces the exception to throw\n+     * @return the value of the scoped value if bound in the current thread\n+     * @throws X if the scoped value is not bound in the current thread\n+     *\/\n+    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n+        Objects.requireNonNull(exceptionSupplier);\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    private static Object[] scopedValueCache() {\n+        return JLA.scopedValueCache();\n+    }\n+\n+    private static void setScopedValueCache(Object[] cache) {\n+        JLA.setScopedValueCache(cache);\n+    }\n+\n+    \/\/ Special value to indicate this is a newly-created Thread\n+    \/\/ Note that his must match the declaration in j.l.Thread.\n+    private static final Object NEW_THREAD_BINDINGS = Thread.class;\n+\n+    private static Snapshot scopedValueBindings() {\n+        \/\/ Bindings can be in one of four states:\n+        \/\/\n+        \/\/ 1: class Thread: this is a new Thread instance, and no\n+        \/\/ scoped values have ever been bound in this Thread.\n+        \/\/ 2: EmptySnapshot.SINGLETON: This is effectively an empty binding.\n+        \/\/ 3: A Snapshot instance: this contains one or more scoped value\n+        \/\/ bindings.\n+        \/\/ 4: null: there may be some bindings in this Thread, but we don't know\n+        \/\/ where they are. We must invoke JLA.findScopedValueBindings() to walk\n+        \/\/ the stack to find them.\n+\n+        Object bindings = JLA.scopedValueBindings();\n+        if (bindings == NEW_THREAD_BINDINGS) {\n+            \/\/ This must be a new thread\n+           return Snapshot.EMPTY_SNAPSHOT;\n+        }\n+        if (bindings == null) {\n+            \/\/ Search the stack\n+            bindings = JLA.findScopedValueBindings();\n+            if (bindings == null) {\n+                \/\/ Nothing on the stack.\n+                bindings = Snapshot.EMPTY_SNAPSHOT;\n+            }\n+        }\n+        assert (bindings != null);\n+        JLA.setScopedValueBindings(bindings);\n+        return (Snapshot) bindings;\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n+    \/\/ to different slots in the cache.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        return (nextKey = x);\n+    }\n+\n+    \/**\n+     * Return a bit mask that may be used to determine if this ScopedValue is\n+     * bound in the current context. Each Carrier holds a bit mask which is\n+     * the OR of all the bit masks of the bound ScopedValues.\n+     * @return the bitmask\n+     *\/\n+    int bitmask() {\n+        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+    }\n+\n+    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n+    \/\/ of the bits in targetBits.\n+    static boolean containsAll(int bitmask, int targetBits) {\n+        return (bitmask & targetBits) == targetBits;\n+    }\n+\n+    \/\/ A small fixed-size key-value cache. When a scoped value's get() method\n+    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n+    \/\/ for fast access in future.\n+    private static final class Cache {\n+        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n+        static final int TABLE_SIZE = 1 << INDEX_BITS;\n+        static final int TABLE_MASK = TABLE_SIZE - 1;\n+        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n+\n+        \/\/ The number of elements in the cache array, and a bit mask used to\n+        \/\/ select elements from it.\n+        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+        \/\/ or equal to 2.\n+        private static final int MAX_CACHE_SIZE = 16;\n+\n+        static {\n+            final String propertyName = \"jdk.incubator.concurrent.ScopedValue.cacheSize\";\n+            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n+            var cacheSize = Integer.valueOf(sizeString);\n+            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+            }\n+            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+            }\n+            CACHE_TABLE_SIZE = cacheSize;\n+            SLOT_MASK = cacheSize - 1;\n+        }\n+\n+        static int primaryIndex(ScopedValue<?> key) {\n+            return key.hash & TABLE_MASK;\n+        }\n+\n+        static int secondaryIndex(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        }\n+\n+        private static int primarySlot(ScopedValue<?> key) {\n+            return key.hashCode() & SLOT_MASK;\n+        }\n+\n+        private static int secondarySlot(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static int primarySlot(int hash) {\n+            return hash & SLOT_MASK;\n+        }\n+\n+        static int secondarySlot(int hash) {\n+            return (hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static void put(ScopedValue<?> key, Object value) {\n+            Object[] theCache = scopedValueCache();\n+            if (theCache == null) {\n+                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                setScopedValueCache(theCache);\n+            }\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            int k1 = primarySlot(key);\n+            int k2 = secondarySlot(key);\n+            var usePrimaryIndex = chooseVictim();\n+            int victim = usePrimaryIndex ? k1 : k2;\n+            int other = usePrimaryIndex ? k2 : k1;\n+            setKeyAndObjectAt(victim, key, value);\n+            if (getKey(theCache, other) == key) {\n+                setKeyAndObjectAt(other, key, value);\n+            }\n+        }\n+\n+        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n+            var cache = scopedValueCache();\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static void setKeyAndObjectAt(Object[] cache, int n, Object key, Object value) {\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static Object getKey(Object[] objs, int n) {\n+            return objs[n * 2];\n+        }\n+\n+        private static void setKey(Object[] objs, int n, Object key) {\n+            objs[n * 2] = key;\n+        }\n+\n+        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n+        \/\/ This chooses either the primary or secondary cache slot, but the\n+        \/\/ primary slot is approximately twice as likely to be chosen as the\n+        \/\/ secondary one.\n+        private static boolean chooseVictim() {\n+            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            return (r & 15) >= 5;\n+        }\n+\n+        \/\/ Null a set of cache entries, indicated by the 1-bits given\n+        static void invalidate(int toClearBits) {\n+            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            Object[] objects;\n+            if ((objects = scopedValueCache()) != null) {\n+                for (int bits = toClearBits; bits != 0; ) {\n+                    int index = Integer.numberOfTrailingZeros(bits);\n+                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    bits &= ~1 << index;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ScopedValue.java","additions":838,"deletions":0,"binary":false,"changes":838,"status":"added"},{"patch":"@@ -213,2 +213,2 @@\n- * StructuredTaskScopes form a tree where parent-child relations are established\n- * implicitly when opening a new task scope:\n+ * Task scopes form a tree where parent-child relations are established implicitly when\n+ * opening a new task scope:\n@@ -225,4 +225,39 @@\n- * <p> The tree structure supports confinement checks. The phrase \"threads contained in\n- * the task scope\" in method descriptions means threads started in the task scope or\n- * descendant scopes. {@code StructuredTaskScope} does not define APIs that exposes the\n- * tree structure at this time.\n+ * The <i>descendants<\/i> of a task scope are the child task scopes that it is a parent\n+ * of, plus the descendants of the child task scopes, recursively.\n+ *\n+ * <p> The tree structure supports:\n+ * <ul>\n+ *   <li> Inheritance of {@linkplain ScopedValue scoped values} across threads.\n+ *   <li> Confinement checks. The phrase \"threads contained in the task scope\" in method\n+ *   descriptions means threads started in the task scope or descendant scopes.\n+ * <\/ul>\n+ *\n+ * <p> The following example demonstrates the inheritance of a scoped value. A scoped\n+ * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n+ * is created and its {@code fork} method invoked to start a thread to execute {@code\n+ * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n+ * creating the task scope. The code in {@code childTask} uses the value of the scoped\n+ * value and so reads the value \"{@code duke}\".\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *\n+ *     \/\/ @link substring=\"where\" target=\"ScopedValue#where(ScopedValue, Object, Runnable)\" :\n+ *     ScopedValue.where(USERNAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask());           \/\/ @highlight substring=\"fork\"\n+ *             ...\n+ *          }\n+ *     });\n+ *\n+ *     ...\n+ *\n+ *     String childTask() {\n+ *         \/\/ @link substring=\"get\" target=\"ScopedValue#get()\" :\n+ *         String name = USERNAME.get();   \/\/ \"duke\"\n+ *         ...\n+ *     }\n+ * }\n+ *\n+ * <p> {@code StructuredTaskScope} does not define APIs that exposes the tree structure\n+ * at this time.\n@@ -237,1 +272,1 @@\n- * <a href=\"..\/..\/..\/..\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n@@ -283,0 +318,6 @@\n+     * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n+     * bindings for inheritance by threads created in the task scope. The\n+     * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+     * details how parent-child relations are established implicitly for the purpose of\n+     * inheritance of scoped value bindings.\n+     *\n@@ -370,1 +411,3 @@\n-     * <p> The new thread is created with the task scope's {@link ThreadFactory}.\n+     * <p> The new thread is created with the task scope's {@link ThreadFactory}. It\n+     * inherits the current thread's {@linkplain ScopedValue scoped value} bindings. The\n+     * bindings must match the bindings captured when the task scope was created.\n@@ -373,7 +416,8 @@\n-     * then the {@link #handleComplete(Future) handle} method is invoked to consume the\n-     * completed task. The {@code handleComplete} method is run when the task completes\n-     * with a result or exception. If the {@code Future} {@link Future#cancel(boolean)\n-     * cancel} method is used the cancel a task before the task scope is shut down, then\n-     * the {@code handleComplete} method is run by the thread that invokes {@code cancel}.\n-     * If the task scope shuts down at or around the same time that the task completes or\n-     * is cancelled then the {@code handleComplete} method may or may not be invoked.\n+     * then the {@link #handleComplete(Future) handleComplete} method is invoked to\n+     * consume the completed task. The {@code handleComplete} method is run when the task\n+     * completes with a result or exception. If the {@code Future}'s {@link\n+     * Future#cancel(boolean) cancel} method is used to cancel a task before the task scope\n+     * is shut down, then the {@code handleComplete} method is run by the thread that\n+     * invokes {@code cancel}. If the task scope shuts down at or around the same time\n+     * that the task completes or is cancelled then the {@code handleComplete} method may\n+     * or may not be invoked.\n@@ -398,0 +442,2 @@\n+     * @throws StructureViolationException if the current scoped value bindings are not\n+     * the same as when the task scope was created\n@@ -631,0 +677,6 @@\n+     *\n+     * Similarly, if this method is called to close a task scope while executing with\n+     * {@linkplain ScopedValue scoped value} bindings, and the task scope was created\n+     * before the scoped values were bound, then {@code StructureViolationException} is\n+     * thrown after closing the task scope.\n+     *\n@@ -827,0 +879,6 @@\n+         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n+         * bindings for inheritance by threads created in the task scope. The\n+         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n+         * the class description details how parent-child relations are established\n+         * implicitly for the purpose of inheritance of scoped value bindings.\n+         *\n@@ -1003,0 +1061,6 @@\n+         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n+         * bindings for inheritance by threads created in the task scope. The\n+         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n+         * the class description details how parent-child relations are established\n+         * implicitly for the purpose of inheritance of scoped value bindings.\n+         *\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":79,"deletions":15,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.org.jline;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+\n+import jdk.internal.io.JdkConsole;\n+import jdk.internal.io.JdkConsoleProvider;\n+import jdk.internal.org.jline.reader.EndOfFileException;\n+import jdk.internal.org.jline.reader.LineReader;\n+import jdk.internal.org.jline.reader.LineReaderBuilder;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.TerminalBuilder;\n+\n+\/**\n+ * JdkConsole\/Provider implementations for jline\n+ *\/\n+public class JdkConsoleProviderImpl implements JdkConsoleProvider {\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public JdkConsole console(boolean isTTY, Charset charset) {\n+        return new JdkConsoleImpl(charset);\n+    }\n+\n+    \/**\n+     * An implementation of JdkConsole, which act as a delegate for the\n+     * public Console class.\n+     *\/\n+    private static class JdkConsoleImpl implements JdkConsole {\n+        @Override\n+        public PrintWriter writer() {\n+            return terminal.writer();\n+        }\n+\n+        @Override\n+        public Reader reader() {\n+            return terminal.reader();\n+        }\n+\n+        @Override\n+        public JdkConsole format(String fmt, Object ... args) {\n+            writer().format(fmt, args).flush();\n+            return this;\n+        }\n+\n+        @Override\n+        public JdkConsole printf(String format, Object ... args) {\n+            return format(format, args);\n+        }\n+\n+        @Override\n+        public String readLine(String fmt, Object ... args) {\n+            try {\n+                return jline.readLine(fmt.formatted(args));\n+            } catch (EndOfFileException eofe) {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public String readLine() {\n+            return readLine(\"\");\n+        }\n+\n+        @Override\n+        public char[] readPassword(String fmt, Object ... args) {\n+            try {\n+                return jline.readLine(fmt.formatted(args), '\\0').toCharArray();\n+            } catch (EndOfFileException eofe) {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public char[] readPassword() {\n+            return readPassword(\"\");\n+        }\n+\n+        @Override\n+        public void flush() {\n+            terminal.flush();\n+        }\n+\n+        @Override\n+        public Charset charset() {\n+            return terminal.encoding();\n+        }\n+\n+        private final LineReader jline;\n+        private final Terminal terminal;\n+\n+        public JdkConsoleImpl(Charset charset) {\n+            try {\n+                terminal = TerminalBuilder.builder().encoding(charset).build();\n+                jline = LineReaderBuilder.builder().terminal(terminal).build();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,3 @@\n+    \/\/ Console\n+    provides jdk.internal.io.JdkConsoleProvider with\n+            jdk.internal.org.jline.JdkConsoleProviderImpl;\n","filename":"src\/jdk.internal.le\/share\/classes\/module-info.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -209,58 +209,0 @@\n-    \/**\n-     * Decodes the exception encoded in {@code buffer} and throws it.\n-     *\n-     * @param errorOrBuffer an error code or a native byte buffer containing an exception encoded by\n-     *            {@link #encodeThrowable}. Error code values and their meanings are:\n-     *\n-     *            <pre>\n-     *             0: native memory for the buffer could not be allocated\n-     *            -1: an OutOfMemoryError was thrown while encoding the exception\n-     *            -2: some other throwable was thrown while encoding the exception\n-     *            <\/pre>\n-     *\/\n-    @VMEntryPoint\n-    static void decodeAndThrowThrowable(long errorOrBuffer) throws Throwable {\n-        if (errorOrBuffer >= -2L && errorOrBuffer <= 0) {\n-            String context = String.format(\"while encoding an exception to translate it from %s to %s\",\n-                            IS_IN_NATIVE_IMAGE ? \"HotSpot\" : \"libjvmci\",\n-                            IS_IN_NATIVE_IMAGE ? \"libjvmci\" : \"HotSpot\");\n-            if (errorOrBuffer == 0) {\n-                throw new InternalError(\"native buffer could not be allocated \" + context);\n-            }\n-            if (errorOrBuffer == -1L) {\n-                throw new OutOfMemoryError(\"OutOfMemoryError occurred \" + context);\n-            }\n-            throw new InternalError(\"unexpected problem occurred \" + context);\n-        }\n-        Unsafe unsafe = UnsafeAccess.UNSAFE;\n-        int encodingLength = unsafe.getInt(errorOrBuffer);\n-        byte[] encoding = new byte[encodingLength];\n-        unsafe.copyMemory(null, errorOrBuffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n-        throw TranslatedException.decodeThrowable(encoding);\n-    }\n-\n-    \/**\n-     * If {@code bufferSize} is large enough, encodes {@code throwable} into a byte array and writes\n-     * it to {@code buffer}. The encoding in {@code buffer} can be decoded by\n-     * {@link #decodeAndThrowThrowable}.\n-     *\n-     * @param throwable the exception to encode\n-     * @param buffer a native byte buffer\n-     * @param bufferSize the size of {@code buffer} in bytes\n-     * @return the number of bytes written into {@code buffer} if {@code bufferSize} is large\n-     *         enough, otherwise {@code -N} where {@code N} is the value {@code bufferSize} needs to\n-     *         be to fit the encoding\n-     *\/\n-    @VMEntryPoint\n-    static int encodeThrowable(Throwable throwable, long buffer, int bufferSize) throws Throwable {\n-        byte[] encoding = TranslatedException.encodeThrowable(throwable);\n-        int requiredSize = 4 + encoding.length;\n-        if (bufferSize < requiredSize) {\n-            return -requiredSize;\n-        }\n-        Unsafe unsafe = UnsafeAccess.UNSAFE;\n-        unsafe.putInt(buffer, encoding.length);\n-        unsafe.copyMemory(encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, null, buffer + 4, encoding.length);\n-        return requiredSize;\n-    }\n-\n@@ -1333,1 +1275,1 @@\n-                throw new JVMCIError(Option.ForceTranslateFailure + \" filter does not match \" + FORCE_TRANSLATE_FAILURE_FILTER_RE + \": \" + filter);\n+                throw new IllegalArgumentException(Option.ForceTranslateFailure + \" filter does not match \" + FORCE_TRANSLATE_FAILURE_FILTER_RE + \": \" + filter);\n@@ -1353,1 +1295,1 @@\n-                throw new JVMCIError(\"translation of \" + translatedObject + \" failed due to matching \" + Option.ForceTranslateFailure + \" filter \\\"\" + filter + \"\\\"\");\n+                throw new RuntimeException(\"translation of \" + translatedObject + \" failed due to matching \" + Option.ForceTranslateFailure + \" filter \\\"\" + filter + \"\\\"\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":2,"deletions":60,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1,275 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.vm.ci.hotspot;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.zip.GZIPInputStream;\n-import java.util.zip.GZIPOutputStream;\n-\n-import jdk.vm.ci.common.JVMCIError;\n-\n-\/**\n- * Support for translating exceptions between different runtime heaps.\n- *\/\n-@SuppressWarnings(\"serial\")\n-final class TranslatedException extends Exception {\n-\n-    \/**\n-     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails due to an\n-     * {@link OutOfMemoryError}.\n-     *\/\n-    private static final byte[] FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n-\n-    \/**\n-     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails for any reason\n-     * other than {@link OutOfMemoryError}.\n-     *\/\n-    private static final byte[] FALLBACK_ENCODED_THROWABLE_BYTES;\n-    static {\n-        try {\n-            FALLBACK_ENCODED_THROWABLE_BYTES = encodeThrowable(new TranslatedException(\"error during encoding\", \"<unknown>\"), false);\n-            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES = encodeThrowable(new OutOfMemoryError(), false);\n-        } catch (IOException e) {\n-            throw new JVMCIError(e);\n-        }\n-    }\n-\n-    \/**\n-     * Class name of exception that could not be instantiated.\n-     *\/\n-    private String originalExceptionClassName;\n-\n-    private TranslatedException(String message, String originalExceptionClassName) {\n-        super(message);\n-        this.originalExceptionClassName = originalExceptionClassName;\n-    }\n-\n-    \/**\n-     * No need to record an initial stack trace since it will be manually overwritten.\n-     *\/\n-    @SuppressWarnings(\"sync-override\")\n-    @Override\n-    public Throwable fillInStackTrace() {\n-        return this;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        String s;\n-        if (originalExceptionClassName.equals(TranslatedException.class.getName())) {\n-            s = getClass().getName();\n-        } else {\n-            s = getClass().getName() + \"[\" + originalExceptionClassName + \"]\";\n-        }\n-        String message = getMessage();\n-        return (message != null) ? (s + \": \" + message) : s;\n-    }\n-\n-    \/**\n-     * Prints a stack trace for {@code throwable} and returns {@code true}. Used to print stack\n-     * traces only when assertions are enabled.\n-     *\/\n-    private static boolean printStackTrace(Throwable throwable) {\n-        throwable.printStackTrace();\n-        return true;\n-    }\n-\n-    private static Throwable initCause(Throwable throwable, Throwable cause) {\n-        if (cause != null) {\n-            try {\n-                throwable.initCause(cause);\n-            } catch (IllegalStateException e) {\n-                \/\/ Cause could not be set or overwritten.\n-                assert printStackTrace(e);\n-            }\n-        }\n-        return throwable;\n-    }\n-\n-    private static Throwable create(String className, String message, Throwable cause) {\n-        \/\/ Try create with reflection first.\n-        try {\n-            Class<?> cls = Class.forName(className);\n-            if (cause != null) {\n-                \/\/ Handle known exception types whose cause must be set in the constructor\n-                if (cls == InvocationTargetException.class) {\n-                    return new InvocationTargetException(cause, message);\n-                }\n-                if (cls == ExceptionInInitializerError.class) {\n-                    return new ExceptionInInitializerError(cause);\n-                }\n-            }\n-            if (message == null) {\n-                return initCause((Throwable) cls.getConstructor().newInstance(), cause);\n-            }\n-            return initCause((Throwable) cls.getDeclaredConstructor(String.class).newInstance(message), cause);\n-        } catch (Throwable translationFailure) {\n-            return initCause(new TranslatedException(message, className), cause);\n-        }\n-    }\n-\n-    private static String emptyIfNull(String value) {\n-        return value == null ? \"\" : value;\n-    }\n-\n-    private static String emptyAsNull(String value) {\n-        return value.isEmpty() ? null : value;\n-    }\n-\n-    \/**\n-     * Encodes {@code throwable} including its stack and causes as a {@linkplain GZIPOutputStream\n-     * compressed} byte array that can be decoded by {@link #decodeThrowable}.\n-     *\/\n-    static byte[] encodeThrowable(Throwable throwable) throws Throwable {\n-        try {\n-            return encodeThrowable(throwable, true);\n-        } catch (OutOfMemoryError e) {\n-            return FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n-        } catch (Throwable e) {\n-            return FALLBACK_ENCODED_THROWABLE_BYTES;\n-        }\n-    }\n-\n-    private static byte[] encodeThrowable(Throwable throwable, boolean withCauseAndStack) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (DataOutputStream dos = new DataOutputStream(new GZIPOutputStream(baos))) {\n-            List<Throwable> throwables = new ArrayList<>();\n-            for (Throwable current = throwable; current != null; current = current.getCause()) {\n-                throwables.add(current);\n-                if (!withCauseAndStack) {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Encode from inner most cause outwards\n-            Collections.reverse(throwables);\n-\n-            for (Throwable current : throwables) {\n-                dos.writeUTF(current.getClass().getName());\n-                dos.writeUTF(emptyIfNull(current.getMessage()));\n-                StackTraceElement[] stackTrace = withCauseAndStack ? current.getStackTrace() : null;\n-                if (stackTrace == null) {\n-                    stackTrace = new StackTraceElement[0];\n-                }\n-                dos.writeInt(stackTrace.length);\n-                for (int i = 0; i < stackTrace.length; i++) {\n-                    StackTraceElement frame = stackTrace[i];\n-                    if (frame != null) {\n-                        dos.writeUTF(emptyIfNull(frame.getClassLoaderName()));\n-                        dos.writeUTF(emptyIfNull(frame.getModuleName()));\n-                        dos.writeUTF(emptyIfNull(frame.getModuleVersion()));\n-                        dos.writeUTF(emptyIfNull(frame.getClassName()));\n-                        dos.writeUTF(emptyIfNull(frame.getMethodName()));\n-                        dos.writeUTF(emptyIfNull(frame.getFileName()));\n-                        dos.writeInt(frame.getLineNumber());\n-                    }\n-                }\n-            }\n-        }\n-        return baos.toByteArray();\n-    }\n-\n-    \/**\n-     * Gets the stack of the current thread without the frames between this call and the one just\n-     * below the frame of the first method in {@link CompilerToVM}. The chopped frames are for the\n-     * VM call to {@link HotSpotJVMCIRuntime#decodeAndThrowThrowable}.\n-     *\/\n-    private static StackTraceElement[] getMyStackTrace() {\n-        StackTraceElement[] stack = new Exception().getStackTrace();\n-        for (int i = 0; i < stack.length; i++) {\n-            StackTraceElement e = stack[i];\n-            if (e.getClassName().equals(CompilerToVM.class.getName())) {\n-                return Arrays.copyOfRange(stack, i, stack.length);\n-            }\n-        }\n-        \/\/ This should never happen but since we're in exception handling\n-        \/\/ code, just return a safe value instead raising a nested exception.\n-        return new StackTraceElement[0];\n-    }\n-\n-    \/**\n-     * Decodes {@code encodedThrowable} into a {@link TranslatedException}.\n-     *\n-     * @param encodedThrowable an encoded exception in the format specified by\n-     *            {@link #encodeThrowable}\n-     *\/\n-    static Throwable decodeThrowable(byte[] encodedThrowable) {\n-        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(new ByteArrayInputStream(encodedThrowable)))) {\n-            Throwable cause = null;\n-            Throwable throwable = null;\n-            StackTraceElement[] myStack = getMyStackTrace();\n-            while (dis.available() != 0) {\n-                String exceptionClassName = dis.readUTF();\n-                String exceptionMessage = emptyAsNull(dis.readUTF());\n-                throwable = create(exceptionClassName, exceptionMessage, cause);\n-                int stackTraceDepth = dis.readInt();\n-                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + myStack.length];\n-                int stackTraceIndex = 0;\n-                int myStackIndex = 0;\n-                for (int j = 0; j < stackTraceDepth; j++) {\n-                    String classLoaderName = emptyAsNull(dis.readUTF());\n-                    String moduleName = emptyAsNull(dis.readUTF());\n-                    String moduleVersion = emptyAsNull(dis.readUTF());\n-                    String className = emptyAsNull(dis.readUTF());\n-                    String methodName = emptyAsNull(dis.readUTF());\n-                    String fileName = emptyAsNull(dis.readUTF());\n-                    int lineNumber = dis.readInt();\n-                    StackTraceElement ste = new StackTraceElement(classLoaderName, moduleName, moduleVersion, className, methodName, fileName, lineNumber);\n-\n-                    if (ste.isNativeMethod()) {\n-                        \/\/ Best effort attempt to weave stack traces from two heaps into\n-                        \/\/ a single stack trace using native method frames as stitching points.\n-                        \/\/ This is not 100% reliable as there's no guarantee that native method\n-                        \/\/ frames only exist for calls between HotSpot and libjvmci.\n-                        while (myStackIndex < myStack.length) {\n-                            StackTraceElement suffixSTE = myStack[myStackIndex++];\n-                            if (suffixSTE.isNativeMethod()) {\n-                                break;\n-                            }\n-                            stackTrace[stackTraceIndex++] = suffixSTE;\n-                        }\n-                    }\n-                    stackTrace[stackTraceIndex++] = ste;\n-                }\n-                while (myStackIndex < myStack.length) {\n-                    stackTrace[stackTraceIndex++] = myStack[myStackIndex++];\n-                }\n-                throwable.setStackTrace(stackTrace);\n-                cause = throwable;\n-            }\n-            return throwable;\n-        } catch (Throwable translationFailure) {\n-            assert printStackTrace(translationFailure);\n-            return new TranslatedException(\"Error decoding exception: \" + encodedThrowable, translationFailure.getClass().getName());\n-        }\n-    }\n-}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/TranslatedException.java","additions":0,"deletions":275,"binary":false,"changes":275,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,4 +92,2 @@\n-            if (assumptions.length > 0) {\n-                for (Assumption assumption : assumptions) {\n-                    target.record(assumption);\n-                }\n+            for (Assumption assumption : assumptions) {\n+                target.record(assumption);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/Assumptions.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n@@ -37,0 +34,1 @@\n+import java.util.Properties;\n@@ -45,2 +43,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n@@ -269,70 +265,2 @@\n-     * A Java {@code char} has a maximal UTF8 length of 3.\n-     *\/\n-    private static final int MAX_UNICODE_IN_UTF8_LENGTH = 3;\n-\n-    \/**\n-     * {@link DataOutputStream#writeUTF(String)} only supports values whose UTF8 encoding length is\n-     * less than 65535.\n-     *\/\n-    private static final int MAX_UTF8_PROPERTY_STRING_LENGTH = 65535 \/ MAX_UNICODE_IN_UTF8_LENGTH;\n-\n-    \/**\n-     * Serializes the {@linkplain #getSavedProperties() saved system properties} to a byte array for\n-     * the purpose of {@linkplain #initializeSavedProperties(byte[]) initializing} the initial\n-     * properties in the JVMCI shared library.\n-     *\/\n-    @VMEntryPoint\n-    private static byte[] serializeSavedProperties() throws IOException {\n-        if (IS_IN_NATIVE_IMAGE) {\n-            throw new InternalError(\"Can only serialize saved properties in HotSpot runtime\");\n-        }\n-        return serializeProperties(Services.getSavedProperties());\n-    }\n-\n-    private static byte[] serializeProperties(Map<String, String> props) throws IOException {\n-        \/\/ Compute size of output on the assumption that\n-        \/\/ all system properties have ASCII names and values\n-        int estimate = 4 + 4;\n-        int nonUtf8Props = 0;\n-        for (Map.Entry<String, String> e : props.entrySet()) {\n-            String name = e.getKey();\n-            String value = e.getValue();\n-            estimate += (2 + (name.length())) + (2 + (value.length()));\n-            if (name.length() > MAX_UTF8_PROPERTY_STRING_LENGTH || value.length() > MAX_UTF8_PROPERTY_STRING_LENGTH) {\n-                nonUtf8Props++;\n-            }\n-        }\n-\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream(estimate);\n-        DataOutputStream out = new DataOutputStream(baos);\n-        out.writeInt(props.size() - nonUtf8Props);\n-        out.writeInt(nonUtf8Props);\n-        for (Map.Entry<String, String> e : props.entrySet()) {\n-            String name = e.getKey();\n-            String value = e.getValue();\n-            if (name.length() <= MAX_UTF8_PROPERTY_STRING_LENGTH && value.length() <= MAX_UTF8_PROPERTY_STRING_LENGTH) {\n-                out.writeUTF(name);\n-                out.writeUTF(value);\n-            }\n-        }\n-        if (nonUtf8Props != 0) {\n-            for (Map.Entry<String, String> e : props.entrySet()) {\n-                String name = e.getKey();\n-                String value = e.getValue();\n-                if (name.length() > MAX_UTF8_PROPERTY_STRING_LENGTH || value.length() > MAX_UTF8_PROPERTY_STRING_LENGTH) {\n-                    byte[] utf8Name = name.getBytes(UTF_8);\n-                    byte[] utf8Value = value.getBytes(UTF_8);\n-                    out.writeInt(utf8Name.length);\n-                    out.write(utf8Name);\n-                    out.writeInt(utf8Value.length);\n-                    out.write(utf8Value);\n-                }\n-            }\n-        }\n-        return baos.toByteArray();\n-    }\n-\n-    \/**\n-     * Initialized the {@linkplain #getSavedProperties() saved system properties} in the JVMCI\n-     * shared library from the {@linkplain #serializeSavedProperties() serialized saved properties}\n-     * in the HotSpot runtime.\n+     * Initializes {@link #savedProperties} from the byte array returned by\n+     * {@code jdk.internal.vm.VMSupport.serializeSavedPropertiesToByteArray()}.\n@@ -345,26 +273,5 @@\n-        savedProperties = Collections.unmodifiableMap(deserializeProperties(serializedProperties));\n-    }\n-\n-    private static Map<String, String> deserializeProperties(byte[] serializedProperties) throws IOException {\n-        DataInputStream in = new DataInputStream(new ByteArrayInputStream(serializedProperties));\n-        int utf8Props = in.readInt();\n-        int nonUtf8Props = in.readInt();\n-        Map<String, String> props = new HashMap<>(utf8Props + nonUtf8Props);\n-        int index = 0;\n-        while (in.available() != 0) {\n-            if (index < utf8Props) {\n-                String name = in.readUTF();\n-                String value = in.readUTF();\n-                props.put(name, value);\n-            } else {\n-                int nameLen = in.readInt();\n-                byte[] nameBytes = new byte[nameLen];\n-                in.read(nameBytes);\n-                int valueLen = in.readInt();\n-                byte[] valueBytes = new byte[valueLen];\n-                in.read(valueBytes);\n-                String name = new String(nameBytes, UTF_8);\n-                String value = new String(valueBytes, UTF_8);\n-                props.put(name, value);\n-            }\n-            index++;\n+        Properties props = new Properties();\n+        props.load(new ByteArrayInputStream(serializedProperties));\n+        Map<String, String> map = new HashMap<>(props.size());\n+        for (var e : props.entrySet()) {\n+            map.put((String) e.getKey(), (String) e.getValue());\n@@ -372,1 +279,2 @@\n-        return props;\n+\n+        savedProperties = Collections.unmodifiableMap(map);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.services\/src\/jdk\/vm\/ci\/services\/Services.java","additions":10,"deletions":102,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e.getCause());\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e);\n@@ -244,1 +244,1 @@\n-                        fileObject.getName(), e.getCause());\n+                        fileObject.getName(), e);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -652,1 +652,1 @@\n-                if (ni != null && ni.length > 0) {\n+                if (ni != null) {\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/inspector\/XTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-     * @param when when it is being done {@link Periodic.When}\n+     * @param periodicType when it is being done {@link PeriodicType.When}\n@@ -125,1 +125,1 @@\n-    public native boolean emitEvent(long eventTypeId, long timestamp, long when);\n+    public native boolean emitEvent(long eventTypeId, long timestamp, long periodicType);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,3 @@\n+    enum PeriodicType {\n+        BEGIN_CHUNK, INTERVAL, END_CHUNK\n+    }\n@@ -65,1 +68,1 @@\n-        private void execute() {\n+        private void execute(long timestamp, PeriodicType periodicType) {\n@@ -71,1 +74,1 @@\n-                        emitJVMEvent(type);\n+                        emitJVMEvent(type, timestamp, periodicType);\n@@ -85,1 +88,1 @@\n-        private void emitJVMEvent(PlatformEventType type) {\n+        private void emitJVMEvent(PlatformEventType type, long timestamp, PeriodicType periodicType) {\n@@ -91,1 +94,1 @@\n-                jvm.emitEvent(type.getId(), JVM.counterTime(), 0);\n+                jvm.emitEvent(type.getId(), timestamp, periodicType.ordinal());\n@@ -186,1 +189,1 @@\n-        doChunk(x -> x.isEndChunk());\n+        doChunk(x -> x.isEndChunk(), PeriodicType.END_CHUNK);\n@@ -190,1 +193,1 @@\n-        doChunk(x -> x.isBeginChunk());\n+        doChunk(x -> x.isBeginChunk(), PeriodicType.BEGIN_CHUNK);\n@@ -193,1 +196,2 @@\n-    private static void doChunk(Predicate<PlatformEventType> predicate) {\n+    private static void doChunk(Predicate<PlatformEventType> predicate, PeriodicType type) {\n+        long timestamp = JVM.counterTime();\n@@ -197,1 +201,1 @@\n-                requestHook.execute();\n+                requestHook.execute(timestamp, type);\n@@ -203,1 +207,1 @@\n-        return run_requests(entries);\n+        return run_requests(entries, JVM.counterTime());\n@@ -207,1 +211,1 @@\n-    private static long run_requests(Collection<RequestHook> entries) {\n+    private static long run_requests(Collection<RequestHook> entries, long eventTimestamp) {\n@@ -209,6 +213,3 @@\n-        \/\/ Bug 9000556 - current time millis has rather lame resolution\n-        \/\/ The use of os::elapsed_counter() is deliberate here, we don't\n-        \/\/ want it exchanged for os::ft_elapsed_counter().\n-        \/\/ Keeping direct call os::elapsed_counter() here for reliable\n-        \/\/ real time values in order to decide when registered requestable\n-        \/\/ events are due.\n+        \/\/ The interval for periodic events is typically at least 1 s, so\n+        \/\/ System.currentTimeMillis() is sufficient. JVM.counterTime() lacks\n+        \/\/ unit and has in the past been more unreliable.\n@@ -252,1 +253,1 @@\n-                he.execute();\n+                he.execute(eventTimestamp, PeriodicType.INTERVAL);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RequestEngine.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-            int size = input.readInt();\n+            long size = input.readLong();\n@@ -246,1 +246,1 @@\n-                            input.readInt(); \/\/ size\n+                            input.readLong(); \/\/ size\n@@ -313,1 +313,1 @@\n-            int size = input.readInt(); \/\/ size\n+            long size = input.readLong(); \/\/ size\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-        } else if (Platform.isArmMac()) {\n+        } else if (Platform.isMac()) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.nio.ch.sctp;\n-\n-import java.net.SocketAddress;\n-import java.net.InetAddress;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.spi.SelectorProvider;\n-import com.sun.nio.sctp.Association;\n-import com.sun.nio.sctp.MessageInfo;\n-import com.sun.nio.sctp.NotificationHandler;\n-import com.sun.nio.sctp.SctpChannel;\n-import com.sun.nio.sctp.SctpSocketOption;\n-\n-\/**\n- * Unimplemented.\n- *\/\n-public class SctpChannelImpl extends SctpChannel\n-{\n-    private static final String message = \"SCTP not supported on this platform\";\n-\n-    public SctpChannelImpl(SelectorProvider provider) {\n-        super(provider);\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Association association() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel bind(SocketAddress local)\n-                            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel bindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel unbindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean connect(SocketAddress remote) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean connect(SocketAddress remote, int maxOutStreams,\n-       int maxInStreams) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean isConnectionPending() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean finishConnect() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getAllLocalAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getRemoteAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel shutdown() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> T getOption(SctpSocketOption<T> name)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> SctpChannel setOption(SctpSocketOption<T> name, T value)\n-        throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SctpSocketOption<?>> supportedOptions() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> MessageInfo receive(ByteBuffer dst, T attachment,\n-            NotificationHandler<T> handler) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public int send(ByteBuffer src, MessageInfo messageInfo)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    protected void implConfigureBlocking(boolean block) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public void implCloseSelectableChannel() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-}\n","filename":"src\/jdk.sctp\/aix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.nio.ch.sctp;\n-\n-import java.net.SocketAddress;\n-import java.net.InetAddress;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.spi.SelectorProvider;\n-import com.sun.nio.sctp.Association;\n-import com.sun.nio.sctp.SctpChannel;\n-import com.sun.nio.sctp.MessageInfo;\n-import com.sun.nio.sctp.NotificationHandler;\n-import com.sun.nio.sctp.SctpMultiChannel;\n-import com.sun.nio.sctp.SctpSocketOption;\n-\n-\/**\n- * Unimplemented.\n- *\/\n-public class SctpMultiChannelImpl extends SctpMultiChannel\n-{\n-    private static final String message = \"SCTP not supported on this platform\";\n-\n-    public SctpMultiChannelImpl(SelectorProvider provider) {\n-        super(provider);\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<Association> associations() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel bind(SocketAddress local,\n-            int backlog) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel bindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel unbindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getAllLocalAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getRemoteAddresses\n-            (Association association) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel shutdown(Association association)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> T getOption(SctpSocketOption<T> name,\n-            Association association) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> SctpMultiChannel setOption(SctpSocketOption<T> name,\n-            T value, Association association) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SctpSocketOption<?>> supportedOptions() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> MessageInfo receive(ByteBuffer buffer, T attachment,\n-            NotificationHandler<T> handler) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public int send(ByteBuffer buffer, MessageInfo messageInfo)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel branch(Association association)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    protected void implConfigureBlocking(boolean block) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public void implCloseSelectableChannel() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-}\n","filename":"src\/jdk.sctp\/aix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.nio.ch.sctp;\n-\n-import java.net.SocketAddress;\n-import java.net.InetAddress;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.nio.channels.spi.SelectorProvider;\n-import com.sun.nio.sctp.SctpChannel;\n-import com.sun.nio.sctp.SctpServerChannel;\n-import com.sun.nio.sctp.SctpSocketOption;\n-\n-\/**\n- * Unimplemented.\n- *\/\n-public class SctpServerChannelImpl extends SctpServerChannel\n-{\n-    private static final String message = \"SCTP not supported on this platform\";\n-\n-    public SctpServerChannelImpl(SelectorProvider provider) {\n-        super(provider);\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel accept() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpServerChannel bind(SocketAddress local,\n-            int backlog) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpServerChannel bindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpServerChannel unbindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getAllLocalAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> T getOption(SctpSocketOption<T> name) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> SctpServerChannel setOption(SctpSocketOption<T> name,\n-            T value) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SctpSocketOption<?>> supportedOptions() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    protected void implConfigureBlocking(boolean block) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public void implCloseSelectableChannel() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-}\n","filename":"src\/jdk.sctp\/aix\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.nio.ch.sctp;\n-\n-import java.net.SocketAddress;\n-import java.net.InetAddress;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.spi.SelectorProvider;\n-import com.sun.nio.sctp.Association;\n-import com.sun.nio.sctp.MessageInfo;\n-import com.sun.nio.sctp.NotificationHandler;\n-import com.sun.nio.sctp.SctpChannel;\n-import com.sun.nio.sctp.SctpSocketOption;\n-\n-\/**\n- * Unimplemented.\n- *\/\n-public class SctpChannelImpl extends SctpChannel\n-{\n-    private static final String message = \"SCTP not supported on this platform\";\n-\n-    public SctpChannelImpl(SelectorProvider provider) {\n-        super(provider);\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Association association() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel bind(SocketAddress local)\n-                            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel bindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel unbindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean connect(SocketAddress remote) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean connect(SocketAddress remote, int maxOutStreams,\n-       int maxInStreams) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean isConnectionPending() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean finishConnect() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getAllLocalAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getRemoteAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel shutdown() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> T getOption(SctpSocketOption<T> name)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> SctpChannel setOption(SctpSocketOption<T> name, T value)\n-        throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SctpSocketOption<?>> supportedOptions() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> MessageInfo receive(ByteBuffer dst, T attachment,\n-            NotificationHandler<T> handler) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public int send(ByteBuffer src, MessageInfo messageInfo)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    protected void implConfigureBlocking(boolean block) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public void implCloseSelectableChannel() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-}\n","filename":"src\/jdk.sctp\/macosx\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.nio.ch.sctp;\n-\n-import java.net.SocketAddress;\n-import java.net.InetAddress;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.spi.SelectorProvider;\n-import com.sun.nio.sctp.Association;\n-import com.sun.nio.sctp.SctpChannel;\n-import com.sun.nio.sctp.MessageInfo;\n-import com.sun.nio.sctp.NotificationHandler;\n-import com.sun.nio.sctp.SctpMultiChannel;\n-import com.sun.nio.sctp.SctpSocketOption;\n-\n-\/**\n- * Unimplemented.\n- *\/\n-public class SctpMultiChannelImpl extends SctpMultiChannel\n-{\n-    private static final String message = \"SCTP not supported on this platform\";\n-\n-    public SctpMultiChannelImpl(SelectorProvider provider) {\n-        super(provider);\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<Association> associations() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel bind(SocketAddress local,\n-            int backlog) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel bindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel unbindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getAllLocalAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getRemoteAddresses\n-            (Association association) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel shutdown(Association association)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> T getOption(SctpSocketOption<T> name,\n-            Association association) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> SctpMultiChannel setOption(SctpSocketOption<T> name,\n-            T value, Association association) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SctpSocketOption<?>> supportedOptions() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> MessageInfo receive(ByteBuffer buffer, T attachment,\n-            NotificationHandler<T> handler) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public int send(ByteBuffer buffer, MessageInfo messageInfo)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel branch(Association association)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    protected void implConfigureBlocking(boolean block) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public void implCloseSelectableChannel() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-}\n","filename":"src\/jdk.sctp\/macosx\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.nio.ch.sctp;\n-\n-import java.net.SocketAddress;\n-import java.net.InetAddress;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.nio.channels.spi.SelectorProvider;\n-import com.sun.nio.sctp.SctpChannel;\n-import com.sun.nio.sctp.SctpServerChannel;\n-import com.sun.nio.sctp.SctpSocketOption;\n-\n-\/**\n- * Unimplemented.\n- *\/\n-public class SctpServerChannelImpl extends SctpServerChannel\n-{\n-    private static final String message = \"SCTP not supported on this platform\";\n-\n-    public SctpServerChannelImpl(SelectorProvider provider) {\n-        super(provider);\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel accept() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpServerChannel bind(SocketAddress local,\n-            int backlog) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpServerChannel bindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpServerChannel unbindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getAllLocalAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> T getOption(SctpSocketOption<T> name) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> SctpServerChannel setOption(SctpSocketOption<T> name,\n-            T value) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SctpSocketOption<?>> supportedOptions() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    protected void implConfigureBlocking(boolean block) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public void implCloseSelectableChannel() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-}\n","filename":"src\/jdk.sctp\/macosx\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -39,1 +39,1 @@\n-     * Try to receieve another message or notification.\n+     * Try to receive another message or notification.\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/HandlerResult.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.io.Serial;\n+\n@@ -35,0 +37,1 @@\n+    @Serial\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/IllegalReceiveException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.io.Serial;\n+\n@@ -35,0 +37,1 @@\n+    @Serial\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/IllegalUnbindException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.io.Serial;\n+\n@@ -34,0 +36,1 @@\n+    @Serial\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/InvalidStreamException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class SctpStandardSocketOptions {\n+public final class SctpStandardSocketOptions {\n@@ -44,1 +44,1 @@\n-     * fragmentation will be performed. Instead if a message being sent\n+     * fragmentation will be performed. Instead, if a message being sent\n@@ -51,3 +51,4 @@\n-    public static final SctpSocketOption<Boolean> SCTP_DISABLE_FRAGMENTS = new\n-        SctpStdSocketOption<Boolean>(\"SCTP_DISABLE_FRAGMENTS\", Boolean.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SCTP_DISABLE_FRAGMENTS);\n+    public static final SctpSocketOption<Boolean> SCTP_DISABLE_FRAGMENTS =\n+            new SctpStdSocketOption<>(\"SCTP_DISABLE_FRAGMENTS\",\n+                    Boolean.class,\n+                    SctpStdSocketOption.SCTP_DISABLE_FRAGMENTS);\n@@ -70,3 +71,4 @@\n-    public static final SctpSocketOption<Boolean> SCTP_EXPLICIT_COMPLETE = new\n-        SctpStdSocketOption<Boolean>(\"SCTP_EXPLICIT_COMPLETE\", Boolean.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SCTP_EXPLICIT_COMPLETE);\n+    public static final SctpSocketOption<Boolean> SCTP_EXPLICIT_COMPLETE =\n+            new SctpStdSocketOption<>(\"SCTP_EXPLICIT_COMPLETE\",\n+                    Boolean.class,\n+                    SctpStdSocketOption.SCTP_EXPLICIT_COMPLETE);\n@@ -121,1 +123,1 @@\n-            new SctpStdSocketOption<Integer>(\"SCTP_FRAGMENT_INTERLEAVE\",\n+            new SctpStdSocketOption<>(\"SCTP_FRAGMENT_INTERLEAVE\",\n@@ -123,1 +125,1 @@\n-                  sun.nio.ch.sctp.SctpStdSocketOption.SCTP_FRAGMENT_INTERLEAVE);\n+                  SctpStdSocketOption.SCTP_FRAGMENT_INTERLEAVE);\n@@ -161,2 +163,2 @@\n-        new SctpStdSocketOption<SctpStandardSocketOptions.InitMaxStreams>(\n-        \"SCTP_INIT_MAXSTREAMS\", SctpStandardSocketOptions.InitMaxStreams.class);\n+            new SctpStdSocketOption<>(\"SCTP_INIT_MAXSTREAMS\",\n+                    SctpStandardSocketOptions.InitMaxStreams.class);\n@@ -173,2 +175,3 @@\n-        new SctpStdSocketOption<Boolean>(\"SCTP_NODELAY\", Boolean.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SCTP_NODELAY);\n+            new SctpStdSocketOption<>(\"SCTP_NODELAY\",\n+                    Boolean.class,\n+                    SctpStdSocketOption.SCTP_NODELAY);\n@@ -194,2 +197,2 @@\n-            new SctpStdSocketOption<SocketAddress>\n-            (\"SCTP_PRIMARY_ADDR\", SocketAddress.class);\n+            new SctpStdSocketOption<>(\"SCTP_PRIMARY_ADDR\",\n+                    SocketAddress.class);\n@@ -219,2 +222,2 @@\n-            new SctpStdSocketOption<SocketAddress>\n-            (\"SCTP_SET_PEER_PRIMARY_ADDR\", SocketAddress.class);\n+            new SctpStdSocketOption<>(\"SCTP_SET_PEER_PRIMARY_ADDR\",\n+                    SocketAddress.class);\n@@ -248,2 +251,3 @@\n-        new SctpStdSocketOption<Integer>(\"SO_SNDBUF\", Integer.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SO_SNDBUF);\n+            new SctpStdSocketOption<>(\"SO_SNDBUF\",\n+                    Integer.class,\n+                    SctpStdSocketOption.SO_SNDBUF);\n@@ -275,2 +279,3 @@\n-        new SctpStdSocketOption<Integer>(\"SO_RCVBUF\", Integer.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SO_RCVBUF);\n+            new SctpStdSocketOption<>(\"SO_RCVBUF\",\n+                    Integer.class,\n+                    SctpStdSocketOption.SO_RCVBUF);\n@@ -306,2 +311,3 @@\n-        new SctpStdSocketOption<Integer>(\"SO_LINGER\", Integer.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SO_LINGER);\n+            new SctpStdSocketOption<>(\"SO_LINGER\",\n+                    Integer.class,\n+                    SctpStdSocketOption.SO_LINGER);\n@@ -319,2 +325,2 @@\n-        private int maxInStreams;\n-        private int maxOutStreams;\n+        private final int maxInStreams;\n+        private final int maxOutStreams;\n@@ -381,5 +387,3 @@\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(super.toString()).append(\" [\");\n-            sb.append(\"maxInStreams:\").append(maxInStreams);\n-            sb.append(\"maxOutStreams:\").append(maxOutStreams).append(\"]\");\n-            return sb.toString();\n+            return super.toString() + \" [\" +\n+                    \"maxInStreams:\" + maxInStreams +\n+                    \"maxOutStreams:\" + maxOutStreams + \"]\";\n@@ -401,5 +405,3 @@\n-            if (obj != null && obj instanceof InitMaxStreams) {\n-                InitMaxStreams that = (InitMaxStreams) obj;\n-                if (this.maxInStreams == that.maxInStreams &&\n-                    this.maxOutStreams == that.maxOutStreams)\n-                    return true;\n+            if (obj instanceof InitMaxStreams that) {\n+                return this.maxInStreams == that.maxInStreams &&\n+                        this.maxOutStreams == that.maxOutStreams;\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/SctpStandardSocketOptions.java","additions":38,"deletions":36,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * Typically this is because the association has been shutdown with unsent data\n+ * Typically, this is because the association has been shutdown with unsent data\n@@ -84,1 +84,1 @@\n-     * Returns the stream number that the messge was to be sent on.\n+     * Returns the stream number that the message was to be sent on.\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/SendFailedNotification.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,10 +159,8 @@\n-        StringBuilder sb = new StringBuilder(super.toString());\n-        sb.append( \"[Address: \").append(address)\n-          .append(\", Association: \").append(association)\n-          .append(\", Assoc ID: \").append(assocId)\n-          .append(\", Bytes: \").append(bytes)\n-          .append(\", Stream Number: \").append(streamNumber)\n-          .append(\", Complete: \").append(complete)\n-          .append(\", isUnordered: \").append(unordered)\n-          .append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \"[Address: \" + address +\n+                \", Association: \" + association +\n+                \", Assoc ID: \" + assocId +\n+                \", Bytes: \" + bytes +\n+                \", Stream Number: \" + streamNumber +\n+                \", Complete: \" + complete +\n+                \", isUnordered: \" + unordered +\n+                \"]\";\n","filename":"src\/jdk.sctp\/share\/classes\/sun\/nio\/ch\/sctp\/MessageInfoImpl.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.nio.ch.sctp;\n+\n+import com.sun.nio.sctp.Association;\n+import com.sun.nio.sctp.MessageInfo;\n+import com.sun.nio.sctp.NotificationHandler;\n+import com.sun.nio.sctp.SctpChannel;\n+import com.sun.nio.sctp.SctpSocketOption;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.Set;\n+\n+\/**\n+ * Unimplemented.\n+ *\/\n+public class SctpChannelImpl\n+        extends SctpChannel {\n+\n+    public SctpChannelImpl(SelectorProvider provider) {\n+        super(provider);\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Association association() {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpChannel bind(SocketAddress local) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpChannel bindAddress(InetAddress address) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpChannel unbindAddress(InetAddress address) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public boolean connect(SocketAddress remote) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public boolean connect(SocketAddress remote,\n+                           int maxOutStreams,\n+                           int maxInStreams) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public boolean isConnectionPending() {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public boolean finishConnect() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Set<SocketAddress> getAllLocalAddresses() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Set<SocketAddress> getRemoteAddresses() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpChannel shutdown() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public <T> T getOption(SctpSocketOption<T> name) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public <T> SctpChannel setOption(SctpSocketOption<T> name,\n+                                     T value) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Set<SctpSocketOption<?>> supportedOptions() {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public <T> MessageInfo receive(ByteBuffer dst,\n+                                   T attachment,\n+                                   NotificationHandler<T> handler) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public int send(ByteBuffer src,\n+                    MessageInfo messageInfo) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    protected void implConfigureBlocking(boolean block) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public void implCloseSelectableChannel() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+}\n","filename":"src\/jdk.sctp\/share\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.nio.ch.sctp;\n+\n+import com.sun.nio.sctp.Association;\n+import com.sun.nio.sctp.MessageInfo;\n+import com.sun.nio.sctp.NotificationHandler;\n+import com.sun.nio.sctp.SctpChannel;\n+import com.sun.nio.sctp.SctpMultiChannel;\n+import com.sun.nio.sctp.SctpSocketOption;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.Set;\n+\n+\/**\n+ * Unimplemented.\n+ *\/\n+public class SctpMultiChannelImpl\n+        extends SctpMultiChannel {\n+\n+    public SctpMultiChannelImpl(SelectorProvider provider) {\n+        super(provider);\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Set<Association> associations() {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpMultiChannel bind(SocketAddress local,\n+                                 int backlog) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpMultiChannel bindAddress(InetAddress address) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpMultiChannel unbindAddress(InetAddress address) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Set<SocketAddress> getAllLocalAddresses() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Set<SocketAddress> getRemoteAddresses(Association association) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpMultiChannel shutdown(Association association) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public <T> T getOption(SctpSocketOption<T> name,\n+                           Association association) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public <T> SctpMultiChannel setOption(SctpSocketOption<T> name,\n+                                          T value,\n+                                          Association association) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Set<SctpSocketOption<?>> supportedOptions() {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public <T> MessageInfo receive(ByteBuffer buffer,\n+                                   T attachment,\n+                                   NotificationHandler<T> handler) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public int send(ByteBuffer buffer,\n+                    MessageInfo messageInfo) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpChannel branch(Association association) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    protected void implConfigureBlocking(boolean block) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public void implCloseSelectableChannel() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+}\n","filename":"src\/jdk.sctp\/share\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.nio.ch.sctp;\n+\n+import com.sun.nio.sctp.SctpChannel;\n+import com.sun.nio.sctp.SctpServerChannel;\n+import com.sun.nio.sctp.SctpSocketOption;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.SocketAddress;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.Set;\n+\n+\/**\n+ * Unimplemented.\n+ *\/\n+public class SctpServerChannelImpl\n+        extends SctpServerChannel {\n+\n+    public SctpServerChannelImpl(SelectorProvider provider) {\n+        super(provider);\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpChannel accept() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpServerChannel bind(SocketAddress local,\n+                                  int backlog) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpServerChannel bindAddress(InetAddress address) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public SctpServerChannel unbindAddress(InetAddress address) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Set<SocketAddress> getAllLocalAddresses() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public <T> T getOption(SctpSocketOption<T> name) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public <T> SctpServerChannel setOption(SctpSocketOption<T> name,\n+                                           T value) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public Set<SctpSocketOption<?>> supportedOptions() {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    protected void implConfigureBlocking(boolean block) throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+\n+    @Override\n+    public void implCloseSelectableChannel() throws IOException {\n+        throw UnsupportedUtil.sctpUnsupported();\n+    }\n+}\n","filename":"src\/jdk.sctp\/share\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-public class SctpStdSocketOption<T>\n+public final class SctpStdSocketOption<T>\n@@ -46,1 +46,1 @@\n-    private int constValue;\n+    private final int constValue;\n@@ -49,2 +49,1 @@\n-        this.name = name;\n-        this.type = type;\n+        this(name, type, 0);\n","filename":"src\/jdk.sctp\/share\/classes\/sun\/nio\/ch\/sctp\/SctpStdSocketOption.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch.sctp;\n+\n+\/**\n+ * Utility class used by implementations on platforms <em>not<\/em> supporting SCTP.\n+ * <p>\n+ * This class is not present on the \"unix\" platform because unix can support SCTP.\n+ *\/\n+public final class UnsupportedUtil {\n+\n+    private static final String MESSAGE = \"SCTP not supported on this platform\";\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private UnsupportedUtil() {}\n+\n+    static UnsupportedOperationException sctpUnsupported() {\n+        return new UnsupportedOperationException(MESSAGE);\n+    }\n+\n+}\n","filename":"src\/jdk.sctp\/share\/classes\/sun\/nio\/ch\/sctp\/UnsupportedUtil.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -46,1 +46,1 @@\n-    \/* assocId is used to lookup the association before the notification is\n+    \/* assocId is used to look up the association before the notification is\n@@ -48,4 +48,4 @@\n-    private int assocId;\n-    private AssocChangeEvent event;\n-    private int maxOutStreams;\n-    private int maxInStreams;\n+    private final int assocId;\n+    private final AssocChangeEvent event;\n+    private final int maxOutStreams;\n+    private final int maxInStreams;\n@@ -58,20 +58,9 @@\n-        switch (intEvent) {\n-            case SCTP_COMM_UP :\n-                this.event = AssocChangeEvent.COMM_UP;\n-                break;\n-            case SCTP_COMM_LOST :\n-                this.event = AssocChangeEvent.COMM_LOST;\n-                break;\n-            case SCTP_RESTART :\n-                this.event = AssocChangeEvent.RESTART;\n-                break;\n-            case SCTP_SHUTDOWN :\n-                this.event = AssocChangeEvent.SHUTDOWN;\n-                break;\n-            case SCTP_CANT_START :\n-                this.event = AssocChangeEvent.CANT_START;\n-                break;\n-            default :\n-                throw new AssertionError(\n-                      \"Unknown Association Change Event type: \" + intEvent);\n-        }\n+        this.event = switch (intEvent) {\n+            case SCTP_COMM_UP    -> AssocChangeEvent.COMM_UP;\n+            case SCTP_COMM_LOST  -> AssocChangeEvent.COMM_LOST;\n+            case SCTP_RESTART    -> AssocChangeEvent.RESTART;\n+            case SCTP_SHUTDOWN   -> AssocChangeEvent.SHUTDOWN;\n+            case SCTP_CANT_START -> AssocChangeEvent.CANT_START;\n+            default -> throw new AssertionError(\n+                    \"Unknown Association Change Event type: \" + intEvent);\n+        };\n@@ -115,5 +104,3 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(super.toString()).append(\" [\");\n-        sb.append(\"Association:\").append(association);\n-        sb.append(\", Event: \").append(event).append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \" [\" +\n+                \"Association:\" + association +\n+                \", Event: \" + event + \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/AssociationChange.java","additions":17,"deletions":30,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -41,9 +41,7 @@\n-        StringBuffer sb = new StringBuffer(super.toString());\n-        return sb.append(\"[associationID:\")\n-                 .append(associationID())\n-                 .append(\", maxIn:\")\n-                 .append(maxInboundStreams())\n-                 .append(\", maxOut:\")\n-                 .append(maxOutboundStreams())\n-                 .append(\"]\")\n-                 .toString();\n+        return super.toString() + \"[associationID:\" +\n+                associationID() +\n+                \", maxIn:\" +\n+                maxInboundStreams() +\n+                \", maxOut:\" +\n+                maxOutboundStreams() +\n+                \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/AssociationImpl.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    \/* assocId is used to lookup the association before the notification is\n+    \/* assocId is used to look up the association before the notification is\n@@ -50,3 +50,3 @@\n-    private int assocId;\n-    private SocketAddress address;\n-    private AddressChangeEvent event;\n+    private final int assocId;\n+    private final SocketAddress address;\n+    private final AddressChangeEvent event;\n@@ -56,22 +56,9 @@\n-        switch (intEvent) {\n-            case SCTP_ADDR_AVAILABLE :\n-                this.event = AddressChangeEvent.ADDR_AVAILABLE;\n-                break;\n-            case SCTP_ADDR_UNREACHABLE :\n-                this.event = AddressChangeEvent.ADDR_UNREACHABLE;\n-                break;\n-            case SCTP_ADDR_REMOVED :\n-                this.event = AddressChangeEvent.ADDR_REMOVED;\n-                break;\n-            case SCTP_ADDR_ADDED :\n-                this.event = AddressChangeEvent.ADDR_ADDED;\n-                break;\n-            case SCTP_ADDR_MADE_PRIM :\n-                this.event = AddressChangeEvent.ADDR_MADE_PRIMARY;\n-                break;\n-            case SCTP_ADDR_CONFIRMED :\n-                this.event = AddressChangeEvent.ADDR_CONFIRMED;\n-                break;\n-            default:\n-                throw new AssertionError(\"Unknown event type\");\n-        }\n+        this.event = switch (intEvent) {\n+            case SCTP_ADDR_AVAILABLE   -> AddressChangeEvent.ADDR_AVAILABLE;\n+            case SCTP_ADDR_UNREACHABLE -> AddressChangeEvent.ADDR_UNREACHABLE;\n+            case SCTP_ADDR_REMOVED     -> AddressChangeEvent.ADDR_REMOVED;\n+            case SCTP_ADDR_ADDED       -> AddressChangeEvent.ADDR_ADDED;\n+            case SCTP_ADDR_MADE_PRIM   -> AddressChangeEvent.ADDR_MADE_PRIMARY;\n+            case SCTP_ADDR_CONFIRMED   -> AddressChangeEvent.ADDR_CONFIRMED;\n+            default -> throw new AssertionError(\"Unknown event type\");\n+        };\n@@ -106,1 +93,0 @@\n-        assert event != null;\n@@ -112,6 +98,4 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(super.toString()).append(\" [\");\n-        sb.append(\"Address: \").append(address);\n-        sb.append(\", Association:\").append(association);\n-        sb.append(\", Event: \").append(event).append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \" [\" +\n+                \"Address: \" + address +\n+                \", Association:\" + association +\n+                \", Event: \" + event + \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/PeerAddrChange.java","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        return type() != MESSAGE && type() != NOTHING ? true : false;\n+        return type() != MESSAGE && type() != NOTHING;\n@@ -71,2 +71,2 @@\n-        if (value instanceof MessageInfoImpl)\n-            return (MessageInfoImpl) value;\n+        if (value instanceof MessageInfoImpl messageInfo)\n+            return messageInfo;\n@@ -80,2 +80,2 @@\n-        if (value instanceof SendFailed)\n-            return (SendFailed) value;\n+        if (value instanceof SendFailed sendFailed)\n+            return sendFailed;\n@@ -89,2 +89,2 @@\n-        if (value instanceof AssociationChange)\n-            return (AssociationChange) value;\n+        if (value instanceof AssociationChange associationChanged)\n+            return associationChanged;\n@@ -98,2 +98,2 @@\n-        if (value instanceof PeerAddrChange)\n-            return (PeerAddrChange) value;\n+        if (value instanceof PeerAddrChange peerAddressChanged)\n+            return peerAddressChanged;\n@@ -107,2 +107,2 @@\n-        if (value instanceof Shutdown)\n-            return (Shutdown) value;\n+        if (value instanceof Shutdown shutdown)\n+            return shutdown;\n@@ -118,7 +118,7 @@\n-            case NOTHING:              sb.append(\"NOTHING\");             break;\n-            case MESSAGE:              sb.append(\"MESSAGE\");             break;\n-            case SEND_FAILED:          sb.append(\"SEND FAILED\");         break;\n-            case ASSOCIATION_CHANGED:  sb.append(\"ASSOCIATION CHANGE\");  break;\n-            case PEER_ADDRESS_CHANGED: sb.append(\"PEER ADDRESS CHANGE\"); break;\n-            case SHUTDOWN:             sb.append(\"SHUTDOWN\");            break;\n-            default :                  sb.append(\"Unknown result type\");\n+            case NOTHING              -> sb.append(\"NOTHING\");\n+            case MESSAGE              -> sb.append(\"MESSAGE\");\n+            case SEND_FAILED          -> sb.append(\"SEND FAILED\");\n+            case ASSOCIATION_CHANGED  -> sb.append(\"ASSOCIATION CHANGE\");\n+            case PEER_ADDRESS_CHANGED -> sb.append(\"PEER ADDRESS CHANGE\");\n+            case SHUTDOWN             -> sb.append(\"SHUTDOWN\");\n+            default                   -> sb.append(\"Unknown result type\");\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/ResultContainer.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -86,3 +88,3 @@\n-    \/* IDs of native threads doing send and receivess, for signalling *\/\n-    private volatile long receiverThread = 0;\n-    private volatile long senderThread = 0;\n+    \/* IDs of native threads doing send and receive, for signalling *\/\n+    private volatile long receiverThread;\n+    private volatile long senderThread;\n@@ -97,1 +99,1 @@\n-        new ThreadLocal<Boolean>() {\n+        new ThreadLocal<>() {\n@@ -116,1 +118,1 @@\n-    private ChannelState state = ChannelState.UNINITIALIZED;\n+    private ChannelState state;\n@@ -120,1 +122,1 @@\n-    private HashSet<InetSocketAddress> localAddresses = new HashSet<InetSocketAddress>();\n+    private final Set<InetSocketAddress> localAddresses = new HashSet<>();\n@@ -228,1 +230,1 @@\n-    private SctpChannel bindUnbindAddress(InetAddress address, boolean add)\n+    private void bindUnbindAddress(InetAddress address, boolean add)\n@@ -284,1 +286,0 @@\n-        return this;\n@@ -289,1 +290,1 @@\n-            return port == -1 ? false : true;\n+            return port != -1;\n@@ -699,19 +700,0 @@\n-    private static class DefaultOptionsHolder {\n-        static final Set<SctpSocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SctpSocketOption<?>> defaultOptions() {\n-            HashSet<SctpSocketOption<?>> set = new HashSet<SctpSocketOption<?>>(10);\n-            set.add(SCTP_DISABLE_FRAGMENTS);\n-            set.add(SCTP_EXPLICIT_COMPLETE);\n-            set.add(SCTP_FRAGMENT_INTERLEAVE);\n-            set.add(SCTP_INIT_MAXSTREAMS);\n-            set.add(SCTP_NODELAY);\n-            set.add(SCTP_PRIMARY_ADDR);\n-            set.add(SCTP_SET_PEER_PRIMARY_ADDR);\n-            set.add(SO_SNDBUF);\n-            set.add(SO_RCVBUF);\n-            set.add(SO_LINGER);\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n@@ -720,1 +702,14 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        final class Holder {\n+            static final Set<SctpSocketOption<?>> DEFAULT_OPTIONS = Set.of(\n+                    SCTP_DISABLE_FRAGMENTS,\n+                    SCTP_EXPLICIT_COMPLETE,\n+                    SCTP_FRAGMENT_INTERLEAVE,\n+                    SCTP_INIT_MAXSTREAMS,\n+                    SCTP_NODELAY,\n+                    SCTP_PRIMARY_ADDR,\n+                    SCTP_SET_PEER_PRIMARY_ADDR,\n+                    SO_SNDBUF,\n+                    SO_RCVBUF,\n+                    SO_LINGER);\n+        }\n+        return Holder.DEFAULT_OPTIONS;\n@@ -859,1 +854,1 @@\n-    private InternalNotificationHandler internalNotificationHandler =\n+    private final InternalNotificationHandler internalNotificationHandler =\n@@ -862,2 +857,1 @@\n-    private void handleNotificationInternal(ResultContainer resultContainer)\n-    {\n+    private void handleNotificationInternal(ResultContainer resultContainer) {\n@@ -868,3 +862,2 @@\n-    private class InternalNotificationHandler\n-            extends AbstractNotificationHandler<Object>\n-    {\n+    private final class InternalNotificationHandler\n+            extends AbstractNotificationHandler<Object> {\n@@ -872,4 +865,3 @@\n-        public HandlerResult handleNotification(\n-                AssociationChangeNotification not, Object unused) {\n-            if (not.event().equals(\n-                    AssociationChangeNotification.AssocChangeEvent.COMM_UP) &&\n+        public HandlerResult handleNotification(AssociationChangeNotification not,\n+                                                Object unused) {\n+            if (not.event().equals(AssociationChangeNotification.AssocChangeEvent.COMM_UP) &&\n@@ -885,4 +877,3 @@\n-    private <T> HandlerResult invokeNotificationHandler\n-                                 (ResultContainer resultContainer,\n-                                  NotificationHandler<T> handler,\n-                                  T attachment) {\n+    private <T> HandlerResult invokeNotificationHandler(ResultContainer resultContainer,\n+                                                        NotificationHandler<T> handler,\n+                                                        T attachment) {\n@@ -894,1 +885,1 @@\n-        if (!(handler instanceof AbstractNotificationHandler)) {\n+        if (!(handler instanceof AbstractNotificationHandler<T> absHandler)) {\n@@ -899,20 +890,13 @@\n-        AbstractNotificationHandler<T> absHandler =\n-                (AbstractNotificationHandler<T>)handler;\n-        switch(resultContainer.type()) {\n-            case ASSOCIATION_CHANGED :\n-                return absHandler.handleNotification(\n-                        resultContainer.getAssociationChanged(), attachment);\n-            case PEER_ADDRESS_CHANGED :\n-                return absHandler.handleNotification(\n-                        resultContainer.getPeerAddressChanged(), attachment);\n-            case SEND_FAILED :\n-                return absHandler.handleNotification(\n-                        resultContainer.getSendFailed(), attachment);\n-            case SHUTDOWN :\n-                return absHandler.handleNotification(\n-                        resultContainer.getShutdown(), attachment);\n-            default :\n-                \/* implementation specific handlers *\/\n-                return absHandler.handleNotification(\n-                        resultContainer.notification(), attachment);\n-        }\n+        return switch (resultContainer.type()) {\n+            case ASSOCIATION_CHANGED  -> absHandler.handleNotification(\n+                    resultContainer.getAssociationChanged(), attachment);\n+            case PEER_ADDRESS_CHANGED -> absHandler.handleNotification(\n+                    resultContainer.getPeerAddressChanged(), attachment);\n+            case SEND_FAILED          -> absHandler.handleNotification(\n+                    resultContainer.getSendFailed(), attachment);\n+            case SHUTDOWN             -> absHandler.handleNotification(\n+                    resultContainer.getShutdown(), attachment);\n+            \/* implementation specific handlers *\/\n+            default                   -> absHandler.handleNotification(\n+                    resultContainer.notification(), attachment);\n+        };\n@@ -1116,2 +1100,2 @@\n-        java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<Void>() {\n+        AccessController.doPrivileged(\n+            new PrivilegedAction<>() {\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":50,"deletions":66,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Map;\n@@ -83,2 +84,2 @@\n-    private volatile long receiverThread = 0;\n-    private volatile long senderThread = 0;\n+    private volatile long receiverThread;\n+    private volatile long senderThread;\n@@ -107,1 +108,1 @@\n-    private HashSet<InetSocketAddress> localAddresses = new HashSet<InetSocketAddress>();\n+    private final Set<InetSocketAddress> localAddresses = new HashSet<>();\n@@ -111,5 +112,5 @@\n-    \/* Keeps a map of addresses to association, and visa versa *\/\n-    private HashMap<SocketAddress, Association> addressMap =\n-                         new HashMap<SocketAddress, Association>();\n-    private HashMap<Association, Set<SocketAddress>> associationMap =\n-                         new HashMap<Association, Set<SocketAddress>>();\n+    \/* Keeps a map of addresses to association, and vice versa *\/\n+    private final Map<SocketAddress, Association> addressMap =\n+                         new HashMap<>();\n+    private final Map<Association, Set<SocketAddress>> associationMap =\n+                         new HashMap<>();\n@@ -121,6 +122,1 @@\n-    private final ThreadLocal<Association> associationToRemove =\n-        new ThreadLocal<Association>() {\n-             @Override protected Association initialValue() {\n-                 return null;\n-            }\n-    };\n+    private final ThreadLocal<Association> associationToRemove = new ThreadLocal<>();\n@@ -130,1 +126,1 @@\n-        new ThreadLocal<Boolean>() {\n+        new ThreadLocal<>() {\n@@ -262,1 +258,1 @@\n-            return port == -1 ? false : true;\n+            return port != -1;\n@@ -443,19 +439,0 @@\n-    private static class DefaultOptionsHolder {\n-        static final Set<SctpSocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SctpSocketOption<?>> defaultOptions() {\n-            HashSet<SctpSocketOption<?>> set = new HashSet<SctpSocketOption<?>>(10);\n-            set.add(SCTP_DISABLE_FRAGMENTS);\n-            set.add(SCTP_EXPLICIT_COMPLETE);\n-            set.add(SCTP_FRAGMENT_INTERLEAVE);\n-            set.add(SCTP_INIT_MAXSTREAMS);\n-            set.add(SCTP_NODELAY);\n-            set.add(SCTP_PRIMARY_ADDR);\n-            set.add(SCTP_SET_PEER_PRIMARY_ADDR);\n-            set.add(SO_SNDBUF);\n-            set.add(SO_RCVBUF);\n-            set.add(SO_LINGER);\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n@@ -464,1 +441,15 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        final class Holder {\n+            static final Set<SctpSocketOption<?>> DEFAULT_OPTIONS = Set.of(\n+                    SCTP_DISABLE_FRAGMENTS,\n+                    SCTP_EXPLICIT_COMPLETE,\n+                    SCTP_FRAGMENT_INTERLEAVE,\n+                    SCTP_INIT_MAXSTREAMS,\n+                    SCTP_NODELAY,\n+                    SCTP_PRIMARY_ADDR,\n+                    SCTP_SET_PEER_PRIMARY_ADDR,\n+                    SO_SNDBUF,\n+                    SO_RCVBUF,\n+                    SO_LINGER);\n+\n+        }\n+        return Holder.DEFAULT_OPTIONS;\n@@ -601,1 +592,1 @@\n-    private InternalNotificationHandler internalNotificationHandler =\n+    private final InternalNotificationHandler internalNotificationHandler =\n@@ -610,1 +601,1 @@\n-    private class InternalNotificationHandler\n+    private final class InternalNotificationHandler\n@@ -614,2 +605,2 @@\n-        public HandlerResult handleNotification(\n-                AssociationChangeNotification not, Object unused) {\n+        public HandlerResult handleNotification(AssociationChangeNotification not,\n+                                                Object unused) {\n@@ -620,1 +611,1 @@\n-                case COMM_UP :\n+                case COMM_UP -> {\n@@ -622,1 +613,1 @@\n-                       (sac.assocId(), sac.maxInStreams(), sac.maxOutStreams());\n+                            (sac.assocId(), sac.maxInStreams(), sac.maxOutStreams());\n@@ -624,4 +615,3 @@\n-                    break;\n-                case SHUTDOWN :\n-                case COMM_LOST :\n-                \/\/case RESTART: ???\n+                }\n+                case SHUTDOWN, COMM_LOST ->\n+                    \/\/case RESTART: ???\n@@ -629,1 +619,1 @@\n-                    associationToRemove.set(lookupAssociation(sac.assocId()));\n+                        associationToRemove.set(lookupAssociation(sac.assocId()));\n@@ -635,4 +625,3 @@\n-    private <T> HandlerResult invokeNotificationHandler(\n-                                   ResultContainer resultContainer,\n-                                   NotificationHandler<T> handler,\n-                                   T attachment) {\n+    private <T> HandlerResult invokeNotificationHandler(ResultContainer resultContainer,\n+                                                        NotificationHandler<T> handler,\n+                                                        T attachment) {\n@@ -643,1 +632,1 @@\n-        if (!(handler instanceof AbstractNotificationHandler)) {\n+        if (!(handler instanceof AbstractNotificationHandler<T> absHandler)) {\n@@ -646,24 +635,13 @@\n-            AbstractNotificationHandler<T> absHandler =\n-                    (AbstractNotificationHandler<T>)handler;\n-            switch(resultContainer.type()) {\n-                case ASSOCIATION_CHANGED :\n-                    result = absHandler.handleNotification(\n-                            resultContainer.getAssociationChanged(), attachment);\n-                    break;\n-                case PEER_ADDRESS_CHANGED :\n-                    result = absHandler.handleNotification(\n-                            resultContainer.getPeerAddressChanged(), attachment);\n-                    break;\n-                case SEND_FAILED :\n-                    result = absHandler.handleNotification(\n-                            resultContainer.getSendFailed(), attachment);\n-                    break;\n-                case SHUTDOWN :\n-                    result =  absHandler.handleNotification(\n-                            resultContainer.getShutdown(), attachment);\n-                    break;\n-                default :\n-                    \/* implementation specific handlers *\/\n-                    result =  absHandler.handleNotification(\n-                            resultContainer.notification(), attachment);\n-            }\n+            result = switch (resultContainer.type()) {\n+                case ASSOCIATION_CHANGED  -> absHandler.handleNotification(\n+                        resultContainer.getAssociationChanged(), attachment);\n+                case PEER_ADDRESS_CHANGED -> absHandler.handleNotification(\n+                        resultContainer.getPeerAddressChanged(), attachment);\n+                case SEND_FAILED          -> absHandler.handleNotification(\n+                        resultContainer.getSendFailed(), attachment);\n+                case SHUTDOWN             -> absHandler.handleNotification(\n+                        resultContainer.getShutdown(), attachment);\n+                \/* implementation specific handlers *\/\n+                default                   -> absHandler.handleNotification(\n+                        resultContainer.notification(), attachment);\n+            };\n@@ -757,2 +735,1 @@\n-     * @throws  IllegalArgumentException\n-     *          If the given association is not controlled by this channel\n+     * Checks if the given association is controlled by this channel.\n@@ -760,2 +737,1 @@\n-     * @return  {@code true} if, and only if, the given association is one\n-     *          of the current associations controlled by this channel\n+     * @throws IllegalArgumentException If the given association is not controlled by this channel\n@@ -763,1 +739,1 @@\n-    private boolean checkAssociation(Association messageAssoc) {\n+    private void checkAssociation(Association messageAssoc) {\n@@ -767,1 +743,1 @@\n-                    return true;\n+                    return;\n@@ -970,2 +946,1 @@\n-                Set<SocketAddress> addrs = associationMap.get(association);\n-                return addrs != null ? addrs : Collections.<SocketAddress>emptySet();\n+                return associationMap.getOrDefault(association, Collections.emptySet());\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":59,"deletions":84,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-        HashSet<SocketAddress> set = null;\n+        Set<SocketAddress> set = null;\n@@ -139,1 +139,1 @@\n-            set = new HashSet<SocketAddress>(saa.length);\n+            set = new HashSet<>(saa.length);\n@@ -163,2 +163,0 @@\n-            if (addr == null)\n-                throw new IllegalArgumentException(\"Invalid option value\");\n@@ -260,1 +258,1 @@\n-        setIntOption0(fd, ((SctpStdSocketOption)name).constValue(), arg);\n+        setIntOption0(fd, ((SctpStdSocketOption<?>)name).constValue(), arg);\n@@ -270,1 +268,1 @@\n-        if (!(name instanceof SctpStdSocketOption))\n+        if (!(name instanceof SctpStdSocketOption<?> option))\n@@ -273,2 +271,1 @@\n-        int value = getIntOption0(fd,\n-                ((SctpStdSocketOption)name).constValue());\n+        int value = getIntOption0(fd, option.constValue());\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNet.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * All Notification implemenations MUST implement this interface to provide\n- * access to the native association identidier.\n+ * All Notification implementations MUST implement this interface to provide\n+ * access to the native association identifier.\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNotification.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -51,1 +50,0 @@\n-import sun.nio.ch.Util;\n@@ -64,1 +62,1 @@\n-    private volatile long thread = 0;\n+    private volatile long thread;\n@@ -84,1 +82,1 @@\n-    private HashSet<InetSocketAddress> localAddresses = new HashSet<InetSocketAddress>();\n+    private final HashSet<InetSocketAddress> localAddresses = new HashSet<>();\n@@ -203,1 +201,1 @@\n-            return port == -1 ? false : true;\n+            return port != -1;\n@@ -392,10 +390,0 @@\n-    private static class DefaultOptionsHolder {\n-        static final Set<SctpSocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SctpSocketOption<?>> defaultOptions() {\n-            HashSet<SctpSocketOption<?>> set = new HashSet<SctpSocketOption<?>>(1);\n-            set.add(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS);\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n@@ -404,1 +392,5 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        final class Holder {\n+            static final Set<SctpSocketOption<?>> DEFAULT_OPTIONS =\n+                    Set.of(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS);\n+        }\n+        return Holder.DEFAULT_OPTIONS;\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,5 +41,5 @@\n-    private int assocId;\n-    private SocketAddress address;\n-    private ByteBuffer buffer;\n-    private int errorCode;\n-    private int streamNumber;\n+    private final int assocId;\n+    private final SocketAddress address;\n+    private final ByteBuffer buffer;\n+    private final int errorCode;\n+    private final int streamNumber;\n@@ -100,9 +100,7 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(super.toString()).append(\" [\");\n-        sb.append(\"Association:\").append(association);\n-        sb.append(\", Address: \").append(address);\n-        sb.append(\", buffer: \").append(buffer);\n-        sb.append(\", errorCode: \").append(errorCode);\n-        sb.append(\", streamNumber: \").append(streamNumber);\n-        sb.append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \" [\" +\n+                \"Association:\" + association +\n+                \", Address: \" + address +\n+                \", buffer: \" + buffer +\n+                \", errorCode: \" + errorCode +\n+                \", streamNumber: \" + streamNumber +\n+                \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SendFailed.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    \/* assocId is used to lookup the association before the notification is\n+    \/* assocId is used to look up the association before the notification is\n@@ -39,1 +39,1 @@\n-    private int assocId;\n+    private final int assocId;\n@@ -64,4 +64,2 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(super.toString()).append(\" [\");\n-        sb.append(\"Association:\").append(association).append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \" [\" +\n+                \"Association:\" + association + \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/Shutdown.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.nio.ch.sctp;\n-\n-import java.net.SocketAddress;\n-import java.net.InetAddress;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.spi.SelectorProvider;\n-import com.sun.nio.sctp.Association;\n-import com.sun.nio.sctp.MessageInfo;\n-import com.sun.nio.sctp.NotificationHandler;\n-import com.sun.nio.sctp.SctpChannel;\n-import com.sun.nio.sctp.SctpSocketOption;\n-\n-\/**\n- * Unimplemented.\n- *\/\n-public class SctpChannelImpl extends SctpChannel\n-{\n-    private static final String message = \"SCTP not supported on this platform\";\n-\n-    public SctpChannelImpl(SelectorProvider provider) {\n-        super(provider);\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Association association() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel bind(SocketAddress local)\n-                            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel bindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel unbindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean connect(SocketAddress remote) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean connect(SocketAddress remote, int maxOutStreams,\n-       int maxInStreams) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean isConnectionPending() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public boolean finishConnect() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getAllLocalAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getRemoteAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel shutdown() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> T getOption(SctpSocketOption<T> name)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> SctpChannel setOption(SctpSocketOption<T> name, T value)\n-        throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SctpSocketOption<?>> supportedOptions() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> MessageInfo receive(ByteBuffer dst, T attachment,\n-            NotificationHandler<T> handler) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public int send(ByteBuffer src, MessageInfo messageInfo)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    protected void implConfigureBlocking(boolean block) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public void implCloseSelectableChannel() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-}\n","filename":"src\/jdk.sctp\/windows\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.nio.ch.sctp;\n-\n-import java.net.SocketAddress;\n-import java.net.InetAddress;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.spi.SelectorProvider;\n-import com.sun.nio.sctp.Association;\n-import com.sun.nio.sctp.SctpChannel;\n-import com.sun.nio.sctp.MessageInfo;\n-import com.sun.nio.sctp.NotificationHandler;\n-import com.sun.nio.sctp.SctpMultiChannel;\n-import com.sun.nio.sctp.SctpSocketOption;\n-\n-\/**\n- * Unimplemented.\n- *\/\n-public class SctpMultiChannelImpl extends SctpMultiChannel\n-{\n-    private static final String message = \"SCTP not supported on this platform\";\n-\n-    public SctpMultiChannelImpl(SelectorProvider provider) {\n-        super(provider);\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<Association> associations() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel bind(SocketAddress local,\n-            int backlog) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel bindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel unbindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getAllLocalAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getRemoteAddresses\n-            (Association association) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpMultiChannel shutdown(Association association)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> T getOption(SctpSocketOption<T> name,\n-            Association association) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> SctpMultiChannel setOption(SctpSocketOption<T> name,\n-            T value, Association association) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SctpSocketOption<?>> supportedOptions() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> MessageInfo receive(ByteBuffer buffer, T attachment,\n-            NotificationHandler<T> handler) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public int send(ByteBuffer buffer, MessageInfo messageInfo)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel branch(Association association)\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    protected void implConfigureBlocking(boolean block) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public void implCloseSelectableChannel() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-}\n","filename":"src\/jdk.sctp\/windows\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.nio.ch.sctp;\n-\n-import java.net.SocketAddress;\n-import java.net.InetAddress;\n-import java.io.IOException;\n-import java.util.Set;\n-import java.nio.channels.spi.SelectorProvider;\n-import com.sun.nio.sctp.SctpChannel;\n-import com.sun.nio.sctp.SctpServerChannel;\n-import com.sun.nio.sctp.SctpSocketOption;\n-\n-\/**\n- * Unimplemented.\n- *\/\n-public class SctpServerChannelImpl extends SctpServerChannel\n-{\n-    private static final String message = \"SCTP not supported on this platform\";\n-\n-    public SctpServerChannelImpl(SelectorProvider provider) {\n-        super(provider);\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpChannel accept() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpServerChannel bind(SocketAddress local,\n-            int backlog) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpServerChannel bindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public SctpServerChannel unbindAddress(InetAddress address)\n-         throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SocketAddress> getAllLocalAddresses()\n-            throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> T getOption(SctpSocketOption<T> name) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public <T> SctpServerChannel setOption(SctpSocketOption<T> name,\n-            T value) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public Set<SctpSocketOption<?>> supportedOptions() {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    protected void implConfigureBlocking(boolean block) throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-\n-    @Override\n-    public void implCloseSelectableChannel() throws IOException {\n-        throw new UnsupportedOperationException(message);\n-    }\n-}\n","filename":"src\/jdk.sctp\/windows\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -747,5 +747,3 @@\n-        if (options.length > 0) {\n-            for (OpenOption opt : options) {\n-                if (opt != READ)\n-                    throw new UnsupportedOperationException(\"'\" + opt + \"' not allowed\");\n-            }\n+        for (OpenOption opt : options) {\n+            if (opt != READ)\n+                throw new UnsupportedOperationException(\"'\" + opt + \"' not allowed\");\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n+#include <iostream>\n+#include \"unittest.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class ShenandoahNumberSeqTest: public ::testing::Test {\n+ protected:\n+  HdrSeq seq;\n+};\n+\n+class BasicShenandoahNumberSeqTest: public ShenandoahNumberSeqTest {\n+ protected:\n+  const double err = 0.5;\n+  BasicShenandoahNumberSeqTest() {\n+    seq.add(0);\n+    seq.add(1);\n+    seq.add(10);\n+    for (int i = 0; i < 7; i++) {\n+      seq.add(100);\n+    }\n+    std::cout << \" p0 = \" << seq.percentile(0);\n+    std::cout << \" p10 = \" << seq.percentile(10);\n+    std::cout << \" p20 = \" << seq.percentile(20);\n+    std::cout << \" p30 = \" << seq.percentile(30);\n+    std::cout << \" p50 = \" << seq.percentile(50);\n+    std::cout << \" p80 = \" << seq.percentile(80);\n+    std::cout << \" p90 = \" << seq.percentile(90);\n+    std::cout << \" p100 = \" << seq.percentile(100);\n+  }\n+};\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, maximum_test) {\n+  EXPECT_EQ(seq.maximum(), 100);\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, minimum_test) {\n+  EXPECT_EQ(0, seq.percentile(0));\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, percentile_test) {\n+  EXPECT_NEAR(0, seq.percentile(10), err);\n+  EXPECT_NEAR(1, seq.percentile(20), err);\n+  EXPECT_NEAR(10, seq.percentile(30), err);\n+  EXPECT_NEAR(100, seq.percentile(40), err);\n+  EXPECT_NEAR(100, seq.percentile(50), err);\n+  EXPECT_NEAR(100, seq.percentile(75), err);\n+  EXPECT_NEAR(100, seq.percentile(90), err);\n+  EXPECT_NEAR(100, seq.percentile(100), err);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahNumberSeq.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -144,0 +144,13 @@\n+\n+TEST_VM(NMT, HeaderKeepsIntegrityAfterRevival) {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+  size_t some_size = 16;\n+  void* p = os::malloc(some_size, mtTest);\n+  ASSERT_NOT_NULL(p) << \"Failed to malloc()\";\n+  MallocHeader* hdr = MallocTracker::malloc_header(p);\n+  hdr->mark_block_as_dead();\n+  hdr->revive();\n+  check_expected_malloc_header(p, mtTest, some_size);\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_cornercases.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -267,0 +267,7 @@\n+  check_format(SSIZE_FORMAT,           (ssize_t)-123,     \"-123\");\n+  check_format(SSIZE_FORMAT,           (ssize_t)2147483647, \"2147483647\");\n+  check_format(SSIZE_FORMAT,           (ssize_t)-2147483647, \"-2147483647\");\n+  check_format(SSIZE_PLUS_FORMAT,      (ssize_t)123,      \"+123\");\n+  check_format(SSIZE_PLUS_FORMAT,      (ssize_t)-123,     \"-123\");\n+  check_format(SSIZE_PLUS_FORMAT,      (ssize_t)2147483647, \"+2147483647\");\n+  check_format(SSIZE_PLUS_FORMAT,      (ssize_t)-2147483647, \"-2147483647\");\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalDefinitions.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,2 +48,0 @@\n-compiler\/jvmci\/compilerToVM\/GetFlagValueTest.java 8204459 generic-all\n-compiler\/tiered\/LevelTransitionTest.java 8067651 generic-all\n@@ -83,1 +81,0 @@\n-gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java 8241293,8298073 macosx-x64,macosx-aarch64\n@@ -85,0 +82,1 @@\n+gc\/TestFullGCCount.java 8298296 linux-x64\n@@ -169,0 +167,2 @@\n+vmTestbase\/nsk\/stress\/strace\/strace004.java 8297824 macosx-x64,windows-x64\n+vmTestbase\/nsk\/monitoring\/ThreadMXBean\/ThreadInfo\/Multi\/Multi005\/TestDescription.java 8076494 windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @requires (os.arch != \"x86\" & os.arch != \"i386\") | vm.opt.UseSSE == \"null\" | vm.opt.UseSSE >= 2\n+ * @requires ((os.arch == \"x86\" | os.arch == \"i386\") & (vm.opt.UseSSE == \"null\" | vm.opt.UseSSE >= 2))\n+ *           | (os.arch != \"x86\" & os.arch != \"i386\" & os.arch != \"riscv64\")\n+ *           | (os.arch == \"riscv64\" & vm.opt.UseRVV == true)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAutoVectorization2DArray.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.jvmci\n- * @modules jdk.internal.vm.ci\/jdk.vm.ci.services:+open\n- * @library \/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\n- * @run testng\/othervm\n- *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler\n- *      jdk.vm.ci.hotspot.test.TestServices\n- *\/\n-\n-package jdk.vm.ci.hotspot.test;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import jdk.vm.ci.services.Services;\n-\n-public class TestServices {\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void serializeSavedPropertiesTest() throws Exception {\n-\n-        Field f = Services.class.getDeclaredField(\"MAX_UTF8_PROPERTY_STRING_LENGTH\");\n-        f.setAccessible(true);\n-        int maxUtf8PropertyStringLength = (int) f.get(null);\n-\n-        Method serializeProperties = Services.class.getDeclaredMethod(\"serializeProperties\", Map.class);\n-        Method deserializeProperties = Services.class.getDeclaredMethod(\"deserializeProperties\", byte[].class);\n-        serializeProperties.setAccessible(true);\n-        deserializeProperties.setAccessible(true);\n-\n-        Map<String, String> props = new HashMap<>(Services.getSavedProperties());\n-        String[] names = {\n-                        new String(new char[maxUtf8PropertyStringLength - 100]).replace('\\0', 'x'),\n-                        new String(new char[maxUtf8PropertyStringLength - 1]).replace('\\0', 'x'),\n-                        new String(new char[maxUtf8PropertyStringLength]).replace('\\0', 'y'),\n-                        new String(new char[maxUtf8PropertyStringLength + 1]).replace('\\0', 'z'),\n-                        new String(new char[maxUtf8PropertyStringLength + 100]).replace('\\0', 'z')\n-        };\n-        String[] values = {\n-                        new String(new char[maxUtf8PropertyStringLength - 100]).replace('\\0', '1'),\n-                        new String(new char[maxUtf8PropertyStringLength - 1]).replace('\\0', '1'),\n-                        new String(new char[maxUtf8PropertyStringLength]).replace('\\0', '2'),\n-                        new String(new char[maxUtf8PropertyStringLength + 1]).replace('\\0', '1'),\n-                        new String(new char[maxUtf8PropertyStringLength + 100]).replace('\\0', '3')\n-        };\n-        for (String name : names) {\n-            for (String value : values) {\n-                props.put(name, value);\n-            }\n-        }\n-\n-        byte[] data = (byte[]) serializeProperties.invoke(null, props);\n-\n-        Map<String, String> newProps = (Map<String, String>) deserializeProperties.invoke(null, data);\n-\n-        Assert.assertEquals(props.size(), newProps.size());\n-        for (String name : props.keySet()) {\n-            String expect = props.get(name);\n-            String actual = newProps.get(name);\n-            Assert.assertEquals(expect, actual);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestServices.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.jvmci\n- * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot:+open\n- *          java.base\/jdk.internal.misc\n- * @library \/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\n- * @run testng\/othervm\n- *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler\n- *      jdk.vm.ci.hotspot.test.TestTranslatedException\n- *\/\n-\n-package jdk.vm.ci.hotspot.test;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n-\n-public class TestTranslatedException {\n-    @SuppressWarnings(\"serial\")\n-    public static class Untranslatable extends RuntimeException {\n-        public Untranslatable(String message, Throwable cause) {\n-            super(message, cause);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void encodeDecodeTest() throws Exception {\n-\n-        Class<?> translatedExceptionClass = Class.forName(\"jdk.vm.ci.hotspot.TranslatedException\");\n-\n-        Method encode = translatedExceptionClass.getDeclaredMethod(\"encodeThrowable\", Throwable.class);\n-        Method decode = translatedExceptionClass.getDeclaredMethod(\"decodeThrowable\", byte[].class);\n-        encode.setAccessible(true);\n-        decode.setAccessible(true);\n-\n-        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n-        for (int i = 0; i < 10; i++) {\n-            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n-        }\n-        byte[] encoding = (byte[]) encode.invoke(null, throwable);\n-        Throwable decoded = (Throwable) decode.invoke(null, encoding);\n-        assertThrowableEquals(throwable, decoded);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void encodeDecodeTest2() throws Exception {\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-        int bufferSize = 512;\n-        long buffer = 0L;\n-        while (true) {\n-            buffer = unsafe.allocateMemory(bufferSize);\n-            try {\n-                Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n-                for (int i = 0; i < 10; i++) {\n-                    throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n-                }\n-\n-                Method encode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"encodeThrowable\", Throwable.class, long.class, int.class);\n-                Method decode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"decodeAndThrowThrowable\", long.class);\n-                encode.setAccessible(true);\n-                decode.setAccessible(true);\n-\n-                int res = (Integer) encode.invoke(null, throwable, buffer, bufferSize);\n-\n-                if (res < 0) {\n-                    bufferSize = -res;\n-                } else {\n-                    try {\n-                        decode.invoke(null, buffer);\n-                        throw new AssertionError(\"expected decodeAndThrowThrowable to throw an exception\");\n-                    } catch (InvocationTargetException e) {\n-                        Throwable decoded = e.getCause();\n-                        assertThrowableEquals(throwable, decoded);\n-                    }\n-                    return;\n-                }\n-            } finally {\n-                unsafe.freeMemory(buffer);\n-            }\n-        }\n-    }\n-\n-    private static void assertThrowableEquals(Throwable original, Throwable decoded) {\n-        try {\n-            Assert.assertEquals(original == null, decoded == null);\n-            while (original != null) {\n-                if (Untranslatable.class.equals(original.getClass())) {\n-                    Assert.assertEquals(\"jdk.vm.ci.hotspot.TranslatedException\", decoded.getClass().getName());\n-                    Assert.assertEquals(\"jdk.vm.ci.hotspot.TranslatedException[jdk.vm.ci.hotspot.test.TestTranslatedException$Untranslatable]: test exception\", decoded.toString());\n-                    Assert.assertEquals(\"test exception\", original.getMessage());\n-                } else {\n-                    Assert.assertEquals(original.getClass().getName(), decoded.getClass().getName());\n-                    Assert.assertEquals(original.getMessage(), decoded.getMessage());\n-                }\n-                StackTraceElement[] originalStack = original.getStackTrace();\n-                StackTraceElement[] decodedStack = decoded.getStackTrace();\n-                Assert.assertEquals(originalStack.length, decodedStack.length);\n-                for (int i = 0, n = originalStack.length; i < n; ++i) {\n-                    StackTraceElement originalStackElement = originalStack[i];\n-                    StackTraceElement decodedStackElement = decodedStack[i];\n-                    Assert.assertEquals(originalStackElement.getClassLoaderName(), decodedStackElement.getClassLoaderName());\n-                    Assert.assertEquals(originalStackElement.getModuleName(), decodedStackElement.getModuleName());\n-                    Assert.assertEquals(originalStackElement.getClassName(), decodedStackElement.getClassName());\n-                    Assert.assertEquals(originalStackElement.getMethodName(), decodedStackElement.getMethodName());\n-                    Assert.assertEquals(originalStackElement.getFileName(), decodedStackElement.getFileName());\n-                    Assert.assertEquals(originalStackElement.getLineNumber(), decodedStackElement.getLineNumber());\n-                }\n-                original = original.getCause();\n-                decoded = decoded.getCause();\n-            }\n-        } catch (AssertionError e) {\n-            System.err.println(\"original:[\");\n-            original.printStackTrace(System.err);\n-            System.err.println(\"]\");\n-            System.err.println(\"decoded:[\");\n-            original.printStackTrace(System.err);\n-            System.err.println(\"]\");\n-            throw e;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestTranslatedException.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -1082,0 +1082,10 @@\n+    public static final String VECTOR_CAST_F2HF = PREFIX + \"VECTOR_CAST_F2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_F2HF, \"VectorCastF2HF\");\n+    }\n+\n+    public static final String VECTOR_CAST_HF2F = PREFIX + \"VECTOR_CAST_HF2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_HF2F, \"VectorCastHF2F\");\n+    }\n+\n@@ -1107,0 +1117,5 @@\n+    public static final String VECTOR_TEST = PREFIX + \"VECTOR_TEST\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_TEST, \"VectorTest\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+                    \"UseRVV\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8298353\n+ * @summary C2 fails with assert(opaq->outcnt() == 1 && opaq->in(1) == limit) failed\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation TestBadCountedLoopLimit\n+ *\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestBadCountedLoopLimit {\n+    private static volatile int barrier;\n+    private static int field;\n+\n+    public static void main(String[] args) {\n+        boolean[] flag1 = new boolean[100];\n+        boolean[] flag2 = new boolean[100];\n+        Arrays.fill(flag2, true);\n+        for (int i = 0; i < 20_000; i++) {\n+            test(0, flag1, flag1);\n+            test(0, flag2, flag2);\n+            testHelper(true, 0, 0);\n+            testHelper(false, 0, 0);\n+        }\n+    }\n+\n+    private static int test(int v, boolean[] flag, boolean[] flag2) {\n+        int j = testHelper(flag2[0], 0, 1);\n+        int i = 1;\n+        int limit = 0;\n+        for (;;) {\n+            synchronized (new Object()) {\n+            }\n+            limit = j;\n+            if (i >= 100) {\n+                break;\n+            }\n+\n+            if (flag[i]) {\n+                return limit - 3;\n+            }\n+\n+            j = testHelper(flag2[i], 100, 101);\n+            i *= 2;\n+        };\n+        for (int k = 0; k < limit; k++) {\n+            barrier = 0x42;\n+        }\n+        return j;\n+    }\n+\n+    private static int testHelper(boolean flag2, int x, int x1) {\n+        return flag2 ? x : x1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestBadCountedLoopLimit.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269820\n+ * @summary C2 PhaseIdealLoop::do_unroll get wrong opaque node\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation TestCanonicalLoopEntryOpaqueOrder\n+ *\n+ *\/\n+\n+public class TestCanonicalLoopEntryOpaqueOrder {\n+    static void test() {\n+        int ina8[] = new int[1478];\n+        int in2 = 136;\n+        long lo3 = 0L;\n+        try {\n+            for (int i = 0; i < 34; i++) {\n+                Math.log1p(1);\n+            }\n+        } catch (Exception e) {\n+            in2 = 1;\n+        }\n+\n+        for (int i = 0; i < in2; i++) {\n+            if (in2 > 10) {  \/\/ split if and create wrong opaque order\n+                for (int j = 0; j < in2; j++) {\n+                    lo3 -= 1L;\n+                }\n+            }\n+        }\n+    }\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCanonicalLoopEntryOpaqueOrder.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8290850\n+ * @summary Test cloning of pinned phi input nodes in create_new_if_for_predicate().\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.loopopts.TestCreateNewIfForPredicateCloning::*\n+ *                   compiler.loopopts.TestCreateNewIfForPredicateCloning\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestCreateNewIfForPredicateCloning {\n+    static int iFld, iFld2, iFld3, nonZero = 2, nonZero2 = 3;\n+    static boolean bFld = true, bFld2 = false;\n+    static int[] iArrFld = new int[100];\n+\n+    public static void main(String[] args) {\n+        try {\n+            testUnswitching();\n+            testLoopPredicatation();\n+            testLoopPredicatationComplex();\n+            testUnswitchingWithPredicates();\n+            testUnswitchingWithPredicatesDiv();\n+            testFuzzer1();\n+            testFuzzer2();\n+            testFuzzer3();\n+        } catch (Exception e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test case for the already fixed problem in 8271954: Calling create_new_if_for_predicate in\n+    \/\/ clone_predicate_to_unswitched_loop(). This does not crash anymore. But still use it as sanity test here with the\n+    \/\/ new fix.\n+    static void testUnswitching() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            \/\/\n+            \/\/ 8271954 fixes this when calling create_new_if_for_predicate() in\n+            \/\/ clone_predicate_to_unswitched_loop().\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Similar to testUnswitching() but we are calling create_new_if_for_predicate in Loop Predication for:\n+    \/\/ - Creating hoised range check predicate and skeleton predicate\n+    \/\/ - Creating invariant check predicate\n+    \/\/ which leads to a crash.\n+    static void testLoopPredicatation() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Similar to testLoopPredicatation() but we are adding some computations for x such that we sink more nodes which\n+    \/\/ need to be cloned when calling create_new_if_for_predicate().\n+    static void testLoopPredicatationComplex() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            \/\/ Add some more computations such that more nodes are sunk and therefore more nodes need to be cloned in\n+            \/\/ create_new_if_for_predicate().\n+            double d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Combination of testUnswitching() and testLoopPredicatation(): After creating predicates in loop predication,\n+    \/\/ we perform another round of loop unswitching where we additionally call create_new_if_for_predicate in\n+    \/\/ clone_skeleton_predicate_for_unswitched_loops() which currently leads to a crash.\n+    static void testUnswitchingWithPredicates() {\n+        int x = 3;\n+        if (iArrFld == null) {\n+            \/\/ Makes sure to get rid of null check for iArrFld to only create range check predicate\n+            return;\n+        }\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int z = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Same as testUnswitchingWithPredicates() but with a DivI node which has a control input which needs\n+    \/\/ to be rewired as well.\n+    static void testUnswitchingWithPredicatesDiv() {\n+        int x = 3;\n+        if (iArrFld == null) {\n+            \/\/ Makes sure to get rid of null check for iArrFld to only create range check predicate\n+            return;\n+        }\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            double d = 5.5f + (double) x;\n+            int a = (int)d;\n+            x = (a \/ nonZero) - (a \/ nonZero2);\n+\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int z = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    static void testFuzzer1() {\n+        int x = 0;\n+        int[] iArr = new int[400];\n+        boolean b = true;\n+        long[] lArr = new long[400];\n+        for (long l1 : lArr) {\n+            for (int i = 63; i > 1; i -= 3) {\n+                for (int j = 1; j < 4; j++) {\n+                    if (!b) {\n+                        x -= 5;\n+                    }\n+                }\n+                for (int j = 1; j < 4; j++) {\n+                    if (!b) {\n+                        x = iArr[j];\n+                    }\n+                    if (i == 0) {\n+                        l1 += 5;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testFuzzer2() {\n+        int i, i1, i17 = 6, i18;\n+        short s1;\n+        boolean b2 = true;\n+        float f3;\n+        long lArr[][] = new long[400][];\n+        byte byArrFld[] = new byte[4];\n+        i = 1;\n+        do {\n+            for (i1 = 14; 6 < i1; i1--)\n+                ;\n+            i17 -= i18 = 1;\n+            while (i18 < 4) {\n+                i18 <<= i17 = 2;\n+                switch (i1) {\n+                    case 114:\n+                        s1 = byArrFld[1];\n+                        break;\n+                    case 116:\n+                        lArr[1][i18] = iFld;\n+                        if (b2)\n+                            continue;\n+                    case 118:\n+                        f3 = iFld;\n+                }\n+            }\n+            i++;\n+        } while (i < 10000);\n+    }\n+\n+    static void testFuzzer3() {\n+        int x = 8;\n+        int y = 4;\n+        for (int i : iArrFld) {\n+            x += 2;\n+            if (bFld) {\n+                x = 3;\n+            } else {\n+                y = 2;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+                x = 0;\n+                y += 5;\n+                if (!bFld) {\n+                    iArrFld[1] = 5;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCreateNewIfForPredicateCloning.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+super public class TestOnlyInfiniteLoops\n+{\n+    public Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+    {\n+        aload_0;\n+        invokespecial  Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static Method test_simple:\"(III)I\"\n+    stack 200 locals 10\n+    {\n+    \/\/ Nested infinite loop, where inner loop eventually\n+    \/\/ looses exit to outer loop. Then, the inner loop\n+    \/\/ floats outside the inner loop. The entry from\n+    \/\/ outer to inner loop now becomes an exit for the\n+    \/\/ outer loop, where it now enters the next loop, that\n+    \/\/ used to be the inner loop.\n+        iconst_0;\n+        istore     9;\n+\n+        iload      0;\n+        ifeq LEND; \/\/ skip\n+\n+    LOOP1:\n+        iload      1;\n+        ifeq LOOP1; \/\/ dominates\n+    LOOP2:\n+        \/\/ SKIP: prevent loop-exit from becoming zero-trip guard\n+        iload      2;\n+        ifeq SKIP;\n+        iinc       9, 1;\n+    SKIP:\n+        iload      1;\n+        ifeq LOOP1; \/\/ is dominated\n+        goto LOOP2;\n+\n+    LEND:\n+        iload      9;\n+        ireturn;\n+    }\n+    static Method test_irreducible:\"(IIII)V\"\n+    stack 200 locals 200\n+    {\n+        iload_0;\n+        ifeq LEND; \/\/ skip\n+\n+    L1:\n+        iload      1;\n+        ifgt MERGE;\n+    L2:\n+        iload      2;\n+        ifge MERGE;\n+        goto L1;\n+\n+    MERGE:\n+        nop;\n+    LOOP:\n+        iload      3;\n+        ifle L2;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+    INFTY:\n+        goto INFTY; \/\/ infinite loop\n+\n+    LEND:\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOnlyInfiniteLoops.jasm","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297642\n+ * @compile TestOnlyInfiniteLoops.jasm\n+ * @summary Nested irreducible loops, where the inner loop floats out of the outer\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestOnlyInfiniteLoops::test*\n+ *      -XX:-TieredCompilation -Xcomp\n+ *      TestOnlyInfiniteLoopsMain\n+ *\n+ * @test\n+ * @bug 8297642\n+ * @compile TestOnlyInfiniteLoops.jasm\n+ * @summary Nested irreducible loops, where the inner loop floats out of the outer\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestOnlyInfiniteLoops::test*\n+ *      -XX:-TieredCompilation -Xcomp\n+ *      -XX:PerMethodTrapLimit=0\n+ *      TestOnlyInfiniteLoopsMain\n+*\/\n+\n+public class TestOnlyInfiniteLoopsMain {\n+    public static void main(String[] args) {\n+        TestOnlyInfiniteLoops t = new TestOnlyInfiniteLoops();\n+        System.out.println(\"test_simple\");\n+        t.test_simple(0, 0, 0);\n+        System.out.println(\"test_irreducible\");\n+        t.test_irreducible(0, 0, 0, 0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOnlyInfiniteLoopsMain.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+super public class TestPhaseCFGNeverBranchToGoto\n+{\n+    public Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+    {\n+        aload_0;\n+        invokespecial  Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+    static Method test:\"(III)V\"\n+    stack 200 locals 200\n+    {\n+        iload      2;\n+        ifeq LEND; \/\/ at runtime avoid the infinite-loop\n+\n+        iload      0;\n+        ifeq L20;\n+        goto L10;\n+    L10:\n+        goto L11;\n+    L11:\n+        iinc 0, 1;\n+        iload      1;\n+        ifge L10;\n+        goto L11;\n+    L20:\n+        iload      1;\n+        ifle L21;\n+        goto L10;\n+    L21:\n+        iconst_m1; \/\/ eventually false\n+        ifge L11;\n+        goto L20;\n+\n+    LEND:\n+        return;\n+    }\n+    public static Method main:\"([Ljava\/lang\/String;)V\"\n+    stack 100 locals 100\n+    {\n+        iconst_0;\n+        iconst_m1;\n+        iconst_0;\n+        invokestatic    Method test:\"(III)V\";\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPhaseCFGNeverBranchToGoto.jasm","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296389\n+ * @summary Peeling of Irreducible loop can lead to NeverBranch being visited from either side\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:PerMethodTrapLimit=0\n+ *      -XX:CompileCommand=compileonly,TestPhaseCFGNeverBranchToGotoMain::test\n+ *      TestPhaseCFGNeverBranchToGotoMain\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296389\n+ * @compile TestPhaseCFGNeverBranchToGoto.jasm\n+ * @summary Peeling of Irreducible loop can lead to NeverBranch being visited from either side\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:PerMethodTrapLimit=0\n+ *      -XX:CompileCommand=compileonly,TestPhaseCFGNeverBranchToGoto::test\n+ *      TestPhaseCFGNeverBranchToGoto\n+ *\/\n+\n+\n+public class TestPhaseCFGNeverBranchToGotoMain {\n+    public static void main (String[] args) {\n+        test(false, false);\n+    }\n+\n+    public static void test(boolean flag1, boolean flag2) {\n+        if (flag1) { \/\/ runtime check, avoid infinite loop\n+            int a = 77;\n+            int b = 0;\n+            do { \/\/ empty loop\n+                a--;\n+                b++;\n+            } while (a > 0);\n+            \/\/ a == 0, b == 77 - after first loop-opts phase\n+            int p = 0;\n+            for (int i = 0; i < 4; i++) {\n+                if ((i % 2) == 0) {\n+                    p = 1;\n+                }\n+            }\n+            \/\/ p == 1 - after second loop-opts phase (via unrolling)\n+            \/\/ in first loop-opts phase we have 2x unrolling, 4x after second\n+            int x = 1;\n+            if (flag2) {\n+                x = 3;\n+            } \/\/ have region here, so that NeverBranch does not get removed\n+            do { \/\/ infinite loop\n+                do {\n+                    \/\/ NeverBranch inserted here, during loop-opts 1\n+                    x *= 2;\n+                    if (p == 0) { \/\/ reason for peeling in loop-opts 1\n+                        \/\/ after we know that p == 1, we lose this exit\n+                        break;\n+                    }\n+                    \/\/ once we know that b == 77, we lose exit\n+            } while (b == 77);\n+            \/\/ after we lost both exits above, this loop gets cut off\n+            int y = 5;\n+                do {\n+                    y *= 3;\n+                } while (b == 77);\n+            } while (true);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPhaseCFGNeverBranchToGotoMain.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorMask;\n+\n+\/*\n+ * @test\n+ * @bug 8292289\n+ * @summary Test idealization of VectorTest intrinsics to eliminate\n+ *          the materialization of the result as an int\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*sse4.*\" & (vm.opt.UseSSE == \"null\" | vm.opt.UseSSE > 3))\n+ *           | os.arch == \"aarch64\"\n+ * @run driver compiler.vectorapi.TestVectorTest\n+ *\/\n+public class TestVectorTest {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    @DontInline\n+    public int call() { return 1; }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CMP_I, IRNode.CMOVE_I})\n+    @IR(counts = {IRNode.VECTOR_TEST, \"1\"})\n+    public int branch(long maskLong) {\n+        var mask = VectorMask.fromLong(ByteVector.SPECIES_PREFERRED, maskLong);\n+        return mask.allTrue() ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CMP_I})\n+    @IR(counts = {IRNode.VECTOR_TEST, \"1\", IRNode.CMOVE_I, \"1\"})\n+    public int cmove(long maskLong) {\n+        var mask = VectorMask.fromLong(ByteVector.SPECIES_PREFERRED, maskLong);\n+        return mask.allTrue() ? 1 : 0;\n+    }\n+\n+    @Run(test = {\"branch\", \"cmove\"})\n+    public void run() {\n+        branch(-1);\n+        branch(100);\n+        cmove(-1);\n+        cmove(100);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -37,1 +37,1 @@\n- *           | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ *           | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseRVV == true)\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestAutoVecIntMinMax.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8294588\n+ * @summary Auto-vectorize Float.floatToFloat16, Float.float16ToFloat APIs\n+ * @requires vm.compiler2.enabled\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestFloatConversionsVector\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestFloatConversionsVector {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+  private static float  [] finp;\n+  private static short  [] sout;\n+  private static short  [] sinp;\n+  private static float  [] fout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                 \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.VECTOR_CAST_F2HF, \"> 0\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"f16c\", \"true\"})\n+  public void test_float_float16(short[] sout, float[] finp) {\n+      for (int i = 0; i < finp.length; i++) {\n+          sout[i] = Float.floatToFloat16(finp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_float_float16\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_float_float16() {\n+      finp = new float[ARRLEN];\n+      sout = new short[ARRLEN];\n+\n+      for (int i = 0; i < ARRLEN; i++) {\n+          finp[i] = (float) i * 1.4f;\n+      }\n+\n+      for (int i = 0; i < ITERS; i++) {\n+         test_float_float16(sout, finp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.VECTOR_CAST_HF2F, \"> 0\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"f16c\", \"true\"})\n+  public void test_float16_float(float[] fout, short[] sinp) {\n+      for (int i = 0; i < sinp.length; i++) {\n+          fout[i] = Float.float16ToFloat(sinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_float16_float\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_float16_float() {\n+      sinp = new short[ARRLEN];\n+      fout = new float[ARRLEN];\n+\n+      for (int i = 0; i < ARRLEN; i++) {\n+          sinp[i] = (short)i;\n+      }\n+\n+      for (int i = 0; i < ITERS; i++) {\n+          test_float16_float(fout , sinp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -XX:CompressedClassSpaceSize=48m gc.metaspace.CompressedClassSpaceSizeInJmapHeap\n+ * @run main\/timeout=240 gc.metaspace.CompressedClassSpaceSizeInJmapHeap\n@@ -39,0 +39,1 @@\n+import jdk.test.lib.apps.LingeredApp;\n@@ -52,1 +53,3 @@\n-        String pid = Long.toString(ProcessTools.getProcessId());\n+        LingeredApp theApp = new LingeredApp();\n+        LingeredApp.startApp(theApp, \"-XX:CompressedClassSpaceSize=48m\");\n+        String pid = Long.toString(theApp.getPid());\n@@ -72,0 +75,2 @@\n+\n+        LingeredApp.stopApp(theApp);\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        if (ver != 64) {\n+        if (ver != latestMajor) {\n@@ -84,1 +84,1 @@\n-                \"Expected 0:64, but got \" + got_minor + \":\" + got_major + \" for primitive array\");\n+                \"Expected 0:\" + latestMajor + \", but got \" + got_minor + \":\" + got_major + \" for primitive array\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassFileVersionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-            {\"EnableWaitForParallelLoad\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +28,1 @@\n- * @bug 8269697\n+ * @bug 8269697 8292674\n@@ -29,0 +30,1 @@\n+ * @comment Tests reporting with regular thread and virtual thread.\n@@ -30,0 +32,1 @@\n+ * @enablePreview\n@@ -50,1 +53,1 @@\n-            test();\n+            test(args[0]);\n@@ -52,1 +55,2 @@\n-            runTest();\n+            runTest(false);\n+            runTest(true);\n@@ -56,1 +60,1 @@\n-    private static void runTest() {\n+    private static void runTest(boolean useVThread) {\n@@ -60,0 +64,1 @@\n+        pbArgs.add(\"--enable-preview\");\n@@ -62,1 +67,1 @@\n-        pbArgs.add(\"test\");\n+        pbArgs.add(useVThread ? \"vtest\" : \"test\");\n@@ -69,0 +74,1 @@\n+            analyzer.shouldContain(\"TestPrimitiveArrayCriticalWithBadParam.pin\");\n@@ -75,4 +81,19 @@\n-    private static void test() {\n-        Object[] objs = new Object[10];\n-        for (int i = 0; i < objs.length; i++) {\n-            objs[i] = new MyClass();\n+    private static void test(String mode) {\n+        Runnable r = () -> {\n+            Object[] objs = new Object[10];\n+            for (int i = 0; i < objs.length; i++) {\n+                objs[i] = new MyClass();\n+            }\n+            pin(objs);\n+            System.out.println(\"Object array pinned\");\n+            unpin(objs);\n+        };\n+        if (mode.equals(\"vtest\")) {\n+            Thread t = Thread.ofVirtual().start(r);\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                throw new Error(\"unexpected\", ex);\n+            }\n+        } else {\n+            r.run();\n@@ -80,3 +101,0 @@\n-        pin(objs);\n-        System.out.println(\"Object array pinned\");\n-        unpin(objs);\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestPrimitiveArrayCriticalWithBadParam.java","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-           checkFrames(Thread.currentThread(), false, 9);\n+           checkFrames(Thread.currentThread(), false, 10);\n@@ -82,1 +82,1 @@\n-        checkFrames(vThread1, false, 14);\n+        checkFrames(vThread1, false, 15);\n@@ -88,1 +88,1 @@\n-            checkFrames(Thread.currentThread(), false, 5);\n+            checkFrames(Thread.currentThread(), false, 6);\n@@ -104,1 +104,1 @@\n-        checkFrames(pThread1, false, 5);\n+        checkFrames(pThread1, false, 6);\n@@ -121,1 +121,1 @@\n-    \/\/ Each stack has 2 frames additional to expected depth\n+    \/\/ Each stack has 3 frames additional to expected depth\n@@ -124,1 +124,2 @@\n-    static final int ADDITIONAL_STACK_COUNT = 2;\n+    \/\/ 2: java\/lang\/Thread: runWith()V\n+    static final int ADDITIONAL_STACK_COUNT = 3;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-    {\"Ljava\/lang\/VirtualThread;\", \"run\", \"(Ljava\/lang\/Runnable;)V\"}\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n+    {\"Ljava\/lang\/VirtualThread;\", \"run\", \"(Ljava\/lang\/Runnable;)V\"},\n@@ -47,1 +48,2 @@\n-    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"}\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n+    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceCurrentThreadTest\/libGetStackTraceCurrentThreadTest.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"}\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n+    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"},\n@@ -46,0 +47,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr03\/libgetstacktr03.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -51,0 +52,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr04\/libgetstacktr04.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -51,0 +52,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr05\/libgetstacktr05.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -55,0 +56,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr06\/libgetstacktr06.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -58,0 +59,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr07\/libgetstacktr07.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -59,0 +60,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr08\/libgetstacktr08.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,1 +269,1 @@\n-            breakpointForCommunication();\n+            breakpointForCommunication(debuggeeName);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/threadDeathRequests\/thrdeathreq002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,1 @@\n-            breakpointForCommunication();\n+            breakpointForCommunication(debuggeeName);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/suspendPolicy\/suspendpolicy009.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,68 +29,0 @@\n-\n-java\/lang\/StackWalker\/AcrossThreads.java 8297235 generic-x64\n-java\/math\/BigInteger\/BigIntegerParallelMultiplyTest.java 8297235 generic-x64\n-java\/util\/Arrays\/SetAllTest.java 8297235 generic-x64\n-java\/util\/Arrays\/Sorting.java 8297235 generic-x64\n-java\/util\/Arrays\/largeMemory\/ParallelPrefix.java 8297235 generic-x64\n-java\/util\/BitSet\/stream\/BitSetStreamTest.java 8297235 generic-x64\n-java\/util\/Collection\/IteratorMicroBenchmark.java 8297235 generic-x64\n-java\/util\/Collections\/UnmodifiableMapEntrySet.java 8297235 generic-x64\n-java\/util\/DoubleStreamSums\/CompensatedSums.java 8297235 generic-x64\n-java\/util\/Random\/RandomTest.java 8297235 generic-x64\n-java\/util\/Scanner\/ScannerStreamTest.java 8297235 generic-x64\n-java\/util\/concurrent\/forkjoin\/AsyncShutdownNow.java 8297235 generic-x64\n-java\/util\/concurrent\/forkjoin\/AsyncShutdownNowInvokeAny.java 8297235 generic-x64\n-java\/util\/concurrent\/forkjoin\/AsyncShutdownNowInvokeAnyRace.java 8297235 generic-x64\n-java\/util\/concurrent\/forkjoin\/Integrate.java 8297235 generic-x64\n-java\/util\/concurrent\/forkjoin\/NQueensCS.java 8297235 generic-x64\n-java\/util\/concurrent\/tck\/JSR166TestCase.java 8297235 generic-x64\n-java\/util\/regex\/PatternStreamTest.java 8297235 generic-x64\n-java\/util\/stream\/CustomFJPoolTest.java 8297235 generic-x64\n-java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/DoubleNodeTest.java 8297235 generic-x64\n-java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/FlagOpTest.java 8297235 generic-x64\n-java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/IntNodeTest.java 8297235 generic-x64\n-java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/LongNodeTest.java 8297235 generic-x64\n-java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/NodeTest.java 8297235 generic-x64\n-java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/StreamReuseTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/SplittableRandomTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/CollectAndSummaryStatisticsTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/CollectorsTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ConcatOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/CountTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/DistinctOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/DoublePrimitiveOpsTests.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FilterOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FindAnyOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FindFirstOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FlatMapOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ForEachOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/GroupByOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/InfiniteStreamWithLimitOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IntPrimitiveOpsTests.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IntReduceTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IntSliceOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IntUniqOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IterateTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/LongPrimitiveOpsTests.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/MapOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/MatchOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/MinMaxTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/PrimitiveAverageOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/PrimitiveSumTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/RangeTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ReduceByOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ReduceTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SequentialOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SliceOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SortedOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/StreamBuilderTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/StreamLinkTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/StreamSpliteratorTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/TeeOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ToArrayOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ToListOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/WhileOpStatefulTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/WhileOpTest.java 8297235 generic-x64\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/mapMultiOpTest.java 8297235 generic-x64\n-\n-jdk\/internal\/vm\/Continuation\/Fuzz.java#default 8298058 generic-x64\n","filename":"test\/jdk\/ProblemList-zgc.txt","additions":0,"deletions":68,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -665,0 +665,1 @@\n+javax\/swing\/JRadioButton\/4314194\/bug4314194.java 8298153 linux-all\n@@ -673,0 +674,1 @@\n+javax\/swing\/JFileChooser\/4847375\/bug4847375.java 8293862 windows-x64\n@@ -797,0 +799,1 @@\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-    static volatile long count = 0;\n-    static volatile long number = 0;\n+    static volatile long notificationReceivedCount = 0;\n+    static volatile long numberOfGCMBeans = 0;\n@@ -67,6 +67,6 @@\n-                    if(listenerInvoked.get(source) == null) {\n-                            listenerInvoked.put(((ObjectName)notif.getSource()).getCanonicalName(),gcNotif);\n-                            count++;\n-                            if(count >= number) {\n-                                synchronizer.notify();\n-                            }\n+                    if (listenerInvoked.get(source) == null) {\n+                        listenerInvoked.put(((ObjectName)notif.getSource()).getCanonicalName(), gcNotif);\n+                        notificationReceivedCount++;\n+                        if (notificationReceivedCount >= numberOfGCMBeans) {\n+                            synchronizer.notify();\n+                        }\n@@ -88,4 +88,2 @@\n-        final ObjectName gcMXBeanPattern =\n-                new ObjectName(\"java.lang:type=GarbageCollector,*\");\n-        Set<ObjectName> names =\n-                mbs.queryNames(gcMXBeanPattern, null);\n+        final ObjectName gcMXBeanPattern = new ObjectName(\"java.lang:type=GarbageCollector,*\");\n+        Set<ObjectName> names = mbs.queryNames(gcMXBeanPattern, null);\n@@ -94,1 +92,1 @@\n-        number = names.size();\n+        numberOfGCMBeans = names.size();\n@@ -96,2 +94,2 @@\n-            if(mbs.isInstanceOf(n,\"javax.management.NotificationEmitter\")) {\n-                listenerInvoked.put(n.getCanonicalName(),null);\n+            if (mbs.isInstanceOf(n, \"javax.management.NotificationEmitter\")) {\n+                listenerInvoked.put(n.getCanonicalName(), null);\n@@ -115,1 +113,1 @@\n-            while(count != number) {\n+            while(notificationReceivedCount != numberOfGCMBeans) {\n@@ -129,3 +127,3 @@\n-        System.out.println(\"GC notification for \"+notif.getGcName());\n-        System.out.print(\"Action: \"+notif.getGcAction());\n-        System.out.println(\" Cause: \"+notif.getGcCause());\n+        System.out.println(\"GC notification for \" + notif.getGcName());\n+        System.out.print(\"Action: \" + notif.getGcAction());\n+        System.out.println(\" Cause: \" + notif.getGcCause());\n@@ -139,0 +137,6 @@\n+        \/\/ Check MemoryUsage is present. For all but No GC events, check Eden usage decreases:\n+        boolean doCheckMemoryUsage = true;\n+        if (notif.getGcCause().equals(\"No GC\")) {\n+            System.out.println(\"(skip memory usage check for event with 'No GC' cause)\");\n+            doCheckMemoryUsage = false;\n+        }\n@@ -146,2 +150,1 @@\n-                throw new RuntimeException(\"After Gc Memory does not exist\" +\n-                    \" for \" + poolname);\n+                throw new RuntimeException(\"After Gc Memory does not exist for \" + poolname);\n@@ -153,1 +156,3 @@\n-            checkMemoryUsage(poolname, busage, ausage);\n+            if (doCheckMemoryUsage) {\n+                checkMemoryUsage(poolname, busage, ausage);\n+            }\n@@ -160,2 +165,1 @@\n-                throw new RuntimeException(\"GcInfo does not contain \" +\n-                    \"memory usage for pool \" + p.getName());\n+                throw new RuntimeException(\"GcInfo does not contain memory usage for pool \" + p.getName());\n","filename":"test\/jdk\/com\/sun\/management\/GarbageCollectorMXBean\/GarbageCollectionNotificationContentTest.java","additions":29,"deletions":25,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            + \"Perform the VO action \\\"Show menu\\\" (VO+Shift+m)\\n\\n\"\n+            + \"Perform the VO action \\\"Show menu\\\" (Shift+VO+m)\\n\\n\"\n@@ -70,1 +70,1 @@\n-            + \"Turn screen reader on, and Tab to the label.\\n\\n\"\n+            + \"Turn screen reader on, and Tab to the tree.\\n\\n\"\n","filename":"test\/jdk\/java\/awt\/a11y\/AccessibleActionsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                + \"Use page up and page down arrow buttons to move through the tabs.\\n\\n\"\n+                + \"Use the left and right arrow buttons to move through the tabs.\\n\\n\"\n","filename":"test\/jdk\/java\/awt\/a11y\/AccessibleJTabbedPaneTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-                + \"ON Windows with JAWS, use window virtualization (insert+alt+w and arrows) to read the label text;\\n\"\n-                + \"ON Windows with NVDA, use the browse cursor (insert+num4 or insert+num6) to read the label text;\\n\\n\"\n+                + \"On Windows with JAWS, use JAWS cursor (num_minus and arrows) to read the label text;\\n\"\n+                + \"On Windows with NVDA, use the object navigation (insert+num4 or insert+num6) to read the label text;\\n\\n\"\n","filename":"test\/jdk\/java\/awt\/a11y\/AccessibleTextTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8165943\n+ * @summary LineBreakMeasurer does not measure correctly if TextAttribute.TRACKING is set\n+ * @library ..\/..\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual LineBreakWithTracking\n+ *\/\n+\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.LineBreakMeasurer;\n+import java.awt.font.TextAttribute;\n+import java.awt.font.TextLayout;\n+import java.text.AttributedString;\n+import java.util.Hashtable;\n+import java.lang.reflect.InvocationTargetException;\n+\n+class LineBreakPanel extends JPanel implements ActionListener {\n+\n+  private float textTracking = 0.0f;\n+  private static String fontName = \"Dialog\";\n+  private static String text = \"This is a long line of text that should be broken across multiple lines. \"\n+          + \"Please set the different tracking values to test via menu! This test should pass if \"\n+          + \"these lines are broken to fit the width, and fail otherwise.  It should \"\n+          + \"also format the hebrew (\\u05d0\\u05d1\\u05d2 \\u05d3\\u05d4\\u05d5) and arabic \"\n+          + \"(\\u0627\\u0628\\u062a\\u062c \\u062e\\u0644\\u0627\\u062e) and CJK \"\n+          + \"(\\u4e00\\u4e01\\u4e02\\uac00\\uac01\\uc4fa\\u67b1\\u67b2\\u67b3\\u67b4\\u67b5\\u67b6\\u67b7\"\n+          + \"\\u67b8\\u67b9) text correctly.\";\n+\n+  private LineBreakMeasurer lineMeasurer;\n+\n+  public void actionPerformed(ActionEvent e) {\n+    textTracking = (float)((JRadioButtonMenuItem)e.getSource()).getClientProperty( \"tracking\" );\n+    lineMeasurer = null;\n+    invalidate();\n+    repaint();\n+  }\n+\n+  public void paintComponent(Graphics g) {\n+    super.paintComponent(g);\n+    setBackground(Color.white);\n+\n+    Graphics2D g2d = (Graphics2D)g;\n+\n+    if (lineMeasurer == null) {\n+      Float regular = Float.valueOf(16.0f);\n+      Float big = Float.valueOf(24.0f);\n+\n+      Hashtable map = new Hashtable();\n+      map.put(TextAttribute.SIZE, (float)18.0);\n+      map.put(TextAttribute.TRACKING, (float)textTracking);\n+\n+      AttributedString astr = new AttributedString(text, map);\n+      astr.addAttribute(TextAttribute.SIZE, regular, 0, text.length());\n+      astr.addAttribute(TextAttribute.FAMILY, fontName, 0, text.length());\n+\n+      int ix = text.indexOf(\"broken\");\n+      astr.addAttribute(TextAttribute.SIZE, big, ix, ix + 6);\n+      ix = text.indexOf(\"hebrew\");\n+      astr.addAttribute(TextAttribute.SIZE, big, ix, ix + 6);\n+      ix = text.indexOf(\"arabic\");\n+      astr.addAttribute(TextAttribute.SIZE, big, ix, ix + 6);\n+      ix = text.indexOf(\"CJK\");\n+      astr.addAttribute(TextAttribute.SIZE, big, ix, ix + 3);\n+\n+      FontRenderContext frc = g2d.getFontRenderContext();\n+      lineMeasurer = new LineBreakMeasurer(astr.getIterator(), frc);\n+    }\n+\n+    lineMeasurer.setPosition(0);\n+\n+    float w = (float)getSize().width;\n+    float x = 0, y = 0;\n+    TextLayout layout;\n+    while ((layout = lineMeasurer.nextLayout(w)) != null) {\n+      x = layout.isLeftToRight() ? 0 : w - layout.getAdvance();\n+      y += layout.getAscent();\n+      layout.draw(g2d, x, y);\n+      y += layout.getDescent() + layout.getLeading();\n+    }\n+  }\n+}\n+\n+public class LineBreakWithTracking {\n+\n+  private static final String INSTRUCTIONS = \"\"\"\n+     This manual test verifies that LineBreakMeasurer measures the lines'\n+     breaks correctly taking into account the TextAttribute.TRACKING value.\n+     The test string includes Latin, Arabic, CJK and Hebrew.\n+\n+     You should choose a tracking value from the menu and resize the window.\n+     If the text lines break exactly to the wrapping width:\n+     no room for one more word exists and\n+     the text lines are not too long for given wrapping width, -\n+     then press PASS, otherwise - FAIL.\n+     \"\"\";\n+\n+  public void createGUI(JFrame frame) {\n+\n+    LineBreakPanel panel = new LineBreakPanel();\n+    frame.getContentPane().add(panel, BorderLayout.CENTER);\n+\n+    JMenuBar menuBar = new JMenuBar();\n+\n+    JMenu menu = new JMenu(\"Tracking\");\n+    ButtonGroup btnGroup = new ButtonGroup();\n+    String btnLabels[] = {\"-0.1\", \"0\", \"0.1\", \"0.2\", \"0.3\"};\n+    float val = -0.1f;\n+    for (String label : btnLabels) {\n+      JRadioButtonMenuItem btn = new JRadioButtonMenuItem(label);\n+      btn.putClientProperty( \"tracking\", val );\n+      btn.addActionListener(panel);\n+      btnGroup.add(btn);\n+      menu.add(btn);\n+      val += 0.1f;\n+    }\n+    menuBar.add(menu);\n+\n+    frame.setJMenuBar(menuBar);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n+\n+    JFrame frame = new JFrame(\"LineBreakMeasurer with Tracking\");\n+    frame.setSize(new Dimension(640, 480));\n+\n+    LineBreakWithTracking controller = new LineBreakWithTracking();\n+    controller.createGUI(frame);\n+\n+    PassFailJFrame passFailJFrame = new PassFailJFrame(INSTRUCTIONS);\n+    PassFailJFrame.addTestWindow(frame);\n+    PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+    frame.setVisible(true);\n+    passFailJFrame.awaitAndCheck();\n+  }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/LineBreakMeasurer\/LineBreakWithTracking.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 8165943\n+  @summary LineBreakMeasurer does not measure correctly if TextAttribute.TRACKING is set\n+  @run main\/othervm LineBreakWithTrackingAuto\n+*\/\n+\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.LineBreakMeasurer;\n+import java.awt.font.TextAttribute;\n+import java.awt.font.TextLayout;\n+import java.text.AttributedString;\n+\n+public class LineBreakWithTrackingAuto {\n+\n+  private static final String WORD = \"word\";\n+  private static final String SPACE = \" \";\n+  private static final int NUM_WORDS = 12;\n+  private static final float FONT_SIZE = 24.0f;\n+  private static final float TEXT_TRACKING[] = { -0.1f, 0f, 0.1f, 0.2f, 0.3f };\n+  private static final float EPSILON = 0.005f;\n+\n+\n+  public static void main(String[] args) {\n+    new LineBreakWithTrackingAuto().test();\n+  }\n+\n+  public void test() {\n+\n+    final FontRenderContext frc = new FontRenderContext(null, false, false);\n+\n+    \/\/ construct a paragraph as follows: [SPACE + WORD] + ...\n+    StringBuffer text = new StringBuffer();\n+    for (int i = 0; i < NUM_WORDS; i++) {\n+      text.append(SPACE);\n+      text.append(WORD);\n+    }\n+    AttributedString attrString = new AttributedString(text.toString());\n+    attrString.addAttribute(TextAttribute.SIZE, Float.valueOf(FONT_SIZE));\n+\n+    \/\/ test different tracking values: -0.1f, 0f, 0.1f, 0.2f, 0.3f\n+    for (float textTracking : TEXT_TRACKING) {\n+\n+      final float trackingAdvance = FONT_SIZE * textTracking;\n+      attrString.addAttribute(TextAttribute.TRACKING, textTracking);\n+\n+      LineBreakMeasurer measurer = new LineBreakMeasurer(attrString.getIterator(), frc);\n+\n+      final int sequenceLength = WORD.length() + SPACE.length();\n+      final float sequenceAdvance = getSequenceAdvance(measurer, text.length(), sequenceLength);\n+      final float textAdvance = NUM_WORDS * sequenceAdvance;\n+\n+      \/\/ test different wrapping width starting from the WORD+SPACE to TEXT width\n+      for (float wrappingWidth = sequenceAdvance; wrappingWidth < textAdvance; wrappingWidth += sequenceAdvance \/ sequenceLength) {\n+\n+        measurer.setPosition(0);\n+\n+        \/\/ break a paragraph into lines that fit the given wrapping width\n+        do {\n+          TextLayout layout = measurer.nextLayout(wrappingWidth);\n+          float visAdvance = layout.getVisibleAdvance();\n+\n+          int currPos = measurer.getPosition();\n+          if ((trackingAdvance <= 0 && visAdvance - wrappingWidth > EPSILON)\n+                  || (trackingAdvance > 0 && visAdvance - wrappingWidth > trackingAdvance + EPSILON)) {\n+            throw new Error(\"text line is too long for given wrapping width\");\n+          }\n+\n+          if (currPos < text.length() && visAdvance <= wrappingWidth - sequenceAdvance) {\n+            throw new Error(\"text line is too short for given wrapping width\");\n+          }\n+        } while (measurer.getPosition() != text.length());\n+\n+      }\n+    }\n+  }\n+\n+  private float getSequenceAdvance(LineBreakMeasurer measurer, int textLength, int sequenceLength) {\n+\n+    measurer.setPosition(textLength - sequenceLength);\n+\n+    TextLayout layout = measurer.nextLayout(10000.0f);\n+    if (layout.getCharacterCount() != sequenceLength) {\n+      throw new Error(\"layout length is incorrect\");\n+    }\n+\n+    return layout.getVisibleAdvance();\n+  }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/font\/LineBreakMeasurer\/LineBreakWithTrackingAuto.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.image.ColorModel;\n+\n+\/**\n+ * @test\n+ * @bug 4677581\n+ * @summary checks when the ColorModel#getComponentSize() throws AIOBE\n+ *\/\n+public final class GetComponentSizeAIOBE {\n+\n+    public static void main(String[] args) {\n+        ColorModel cm = ColorModel.getRGBdefault();\n+        for (int i = 0; i < cm.getNumComponents(); ++i) {\n+            cm.getComponentSize(i);\n+        }\n+\n+        testAIOBE(cm, Integer.MIN_VALUE);\n+        testAIOBE(cm, -1);\n+        testAIOBE(cm, cm.getNumComponents());\n+        testAIOBE(cm, cm.getNumComponents() + 1);\n+        testAIOBE(cm, Integer.MAX_VALUE);\n+    }\n+\n+    private static void testAIOBE(ColorModel cm, int componentIdx) {\n+        try {\n+            cm.getComponentSize(componentIdx);\n+            throw new RuntimeException(\"AIOBE is not thrown\");\n+        } catch (ArrayIndexOutOfBoundsException ignore) {\n+            \/\/ expected\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/ColorModel\/GetComponentSizeAIOBE.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8295803\n+ * @summary Tests System.console() returns correct Console (or null) from the expected\n+ *          module.\n+ * @modules java.base\/java.io:+open\n+ * @run main\/othervm ModuleSelectionTest jdk.internal.le\n+ * @run main\/othervm -Djdk.console=jdk.internal.le ModuleSelectionTest jdk.internal.le\n+ * @run main\/othervm -Djdk.console=java.base ModuleSelectionTest java.base\n+ * @run main\/othervm --limit-modules java.base ModuleSelectionTest java.base\n+ *\/\n+\n+import java.io.Console;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class ModuleSelectionTest {\n+    public static void main(String... args) throws Throwable {\n+        var con = System.console();\n+        var pc = Class.forName(\"java.io.ProxyingConsole\");\n+        var jdkc = Class.forName(\"jdk.internal.io.JdkConsole\");\n+        var istty = (boolean)MethodHandles.privateLookupIn(Console.class, MethodHandles.lookup())\n+                .findStatic(Console.class, \"istty\", MethodType.methodType(boolean.class))\n+                .invoke();\n+        var impl = con != null ? MethodHandles.privateLookupIn(pc, MethodHandles.lookup())\n+                .findGetter(pc, \"delegate\", jdkc)\n+                .invoke(con) : null;\n+\n+        var expected = switch (args[0]) {\n+            case \"java.base\" -> istty ? \"java.base\" : \"null\";\n+            default -> args[0];\n+        };\n+        var actual = con == null ? \"null\" : impl.getClass().getModule().getName();\n+\n+        if (!actual.equals(expected)) {\n+            throw new RuntimeException(\"\"\"\n+                Console implementation is not the expected one.\n+                Expected: %s\n+                Actual: %s\n+                \"\"\".formatted(expected, actual));\n+        } else {\n+            System.out.printf(\"%s is the expected implementation. (tty: %s)\\n\", impl, istty);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/ModuleSelectionTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @bug 8295803\n+ * @summary Tests System.console() works with standard input redirection.\n+ * @library \/test\/lib\n+ *\/\n+public class RedirectTest {\n+    public static void main(String... args) throws Throwable {\n+        if (args.length == 0) {\n+            \/\/ no arg will launch the child process that actually perform tests\n+            var pb = ProcessTools.createTestJvm(\"RedirectTest\", \"dummy\");\n+            var input = new File(System.getProperty(\"test.src\", \".\"), \"input.txt\");\n+            pb.redirectInput(input);\n+            var oa = ProcessTools.executeProcess(pb);\n+            var output = oa.asLines();\n+            var expected = Files.readAllLines(input.toPath());\n+            if (!output.equals(expected)) {\n+                throw new RuntimeException(\"\"\"\n+                        Standard out had unexpected strings:\n+                        Actual output: %s\n+                        Expected output: %s\n+                        \"\"\".formatted(output, expected));\n+            }\n+            oa.shouldHaveExitValue(0);\n+        } else {\n+            var con = System.console();\n+            String line;\n+            while ((line = con.readLine()) != null) {\n+                System.out.println(line);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/RedirectTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8295803\n+ * @summary Tests System.console() works with the security manager\n+ * @run main\/othervm\/java.security.policy=test.policy -Djava.security.manager -Djdk.console=jdk.internal.le SecurityManagerTest\n+ *\/\n+public class SecurityManagerTest {\n+    public static void main(String... args) {\n+        System.console();\n+        \/\/ consider it successful if ServiceConfigurationError was not thrown here\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/SecurityManagerTest.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+This is line 1\n+This is line 2\n+This is the last line\n","filename":"test\/jdk\/java\/io\/Console\/input.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+grant {\n+    permission java.io.FilePermission \"<<ALL FILES>>\",\"read,write,delete\";\n+};\n","filename":"test\/jdk\/java\/io\/Console\/test.policy","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import org.testng.annotations.Test;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import static java.lang.String.format;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run testng\/othervm\/timeout=180 TransferTo\n+ * @bug 8297298\n+ * @summary Tests whether java.io.SequenceInputStream.transferTo conforms to the\n+ *          InputStream.transferTo specification\n+ * @key randomness\n+ *\/\n+public class TransferTo {\n+    private static final int MIN_SIZE      = 10_000;\n+    private static final int MAX_SIZE_INCR = 100_000_000 - MIN_SIZE;\n+\n+    private static final int ITERATIONS = 10;\n+\n+    private static final Random RND = RandomFactory.getRandom();\n+\n+    \/*\n+     * Testing API compliance: input stream must throw NullPointerException\n+     * when parameter \"out\" is null.\n+     *\/\n+    @Test\n+    public void testNullPointerException() throws Exception {\n+        \/\/ factory for incoming data provider\n+        InputStreamProvider inputStreamProvider = byteArrayInput();\n+\n+        \/\/ tests empty input stream\n+        assertThrows(NullPointerException.class,\n+                () -> inputStreamProvider.input().transferTo(null));\n+\n+        \/\/ tests single-byte input stream\n+        assertThrows(NullPointerException.class,\n+                () -> inputStreamProvider.input((byte) 1).transferTo(null));\n+\n+        \/\/ tests dual-byte input stream\n+        assertThrows(NullPointerException.class,\n+                () -> inputStreamProvider.input((byte) 1, (byte) 2).transferTo(null));\n+    }\n+\n+    \/*\n+     * Testing API compliance: complete content of input stream must be\n+     * transferred to output stream.\n+     *\/\n+    @Test\n+    public void testStreamContents() throws Exception {\n+        \/\/ factory for incoming data provider\n+        InputStreamProvider inputStreamProvider = byteArrayInput();\n+\n+        \/\/ factory for outgoing data recorder\n+        OutputStreamProvider outputStreamProvider = byteArrayOutput();\n+\n+        \/\/ tests empty input stream\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, new byte[0]);\n+\n+        \/\/ tests input stream with a length between 1k and 4k\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, createRandomBytes(1024, 4096));\n+\n+        \/\/ tests input stream with several data chunks, as 16k is more than a\n+        \/\/ single chunk can hold\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, createRandomBytes(16384, 16384));\n+\n+        \/\/ tests randomly chosen starting positions within source and\n+        \/\/ target stream\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            byte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n+            int posIn = RND.nextInt(inBytes.length);\n+            int posOut = RND.nextInt(MIN_SIZE);\n+            checkTransferredContents(inputStreamProvider,\n+                    outputStreamProvider, inBytes, posIn, posOut);\n+        }\n+\n+        \/\/ tests reading beyond source EOF (must not transfer any bytes)\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, createRandomBytes(4096, 0), 4096, 0);\n+\n+        \/\/ tests writing beyond target EOF (must extend output stream)\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, createRandomBytes(4096, 0), 0, 4096);\n+    }\n+\n+    \/*\n+     * Asserts that the transferred content is correct, i.e., compares the bytes\n+     * actually transferred to those expected. The position of the input and\n+     * output streams before the transfer are zero (BOF).\n+     *\/\n+    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider, byte[] inBytes) throws Exception {\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, inBytes, 0, 0);\n+    }\n+\n+    \/*\n+     * Asserts that the transferred content is correct, i. e. compares the bytes\n+     * actually transferred to those expected. The positions of the input and\n+     * output streams before the transfer are provided by the caller.\n+     *\/\n+    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider, byte[] inBytes, int posIn,\n+            int posOut) throws Exception {\n+        AtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n+        try (InputStream in = inputStreamProvider.input(inBytes);\n+            OutputStream out = outputStreamProvider.output(recorder::set)) {\n+            \/\/ skip bytes until starting position\n+            in.skipNBytes(posIn);\n+            out.write(new byte[posOut]);\n+\n+            long reported = in.transferTo(out);\n+            int count = inBytes.length - posIn;\n+\n+            assertEquals(reported, count,\n+                    format(\"reported %d bytes but should report %d\", reported, count));\n+\n+            byte[] outBytes = recorder.get().get();\n+            assertTrue(Arrays.equals(inBytes, posIn, posIn + count,\n+                    outBytes, posOut, posOut + count),\n+                    format(\"inBytes.length=%d, outBytes.length=%d\", count, outBytes.length));\n+        }\n+    }\n+\n+    \/*\n+     * Creates an array of random size (between min and min + maxRandomAdditive)\n+     * filled with random bytes\n+     *\/\n+    private static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n+        byte[] bytes = new byte[min +\n+                                (maxRandomAdditive == 0 ? 0 : RND.nextInt(maxRandomAdditive))];\n+        RND.nextBytes(bytes);\n+        return bytes;\n+    }\n+\n+    private interface InputStreamProvider {\n+        InputStream input(byte... bytes) throws Exception;\n+    }\n+\n+    private interface OutputStreamProvider {\n+        OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n+    }\n+\n+    private static InputStreamProvider byteArrayInput() {\n+        return bytes -> {\n+            InputStream is1 = new ByteArrayInputStream(bytes, 0, bytes.length \/ 2);\n+            InputStream is2 = new ByteArrayInputStream(bytes, bytes.length \/ 2, bytes.length);\n+            return new SequenceInputStream(is1, is2);\n+        };\n+    }\n+\n+    private static OutputStreamProvider byteArrayOutput() {\n+        return new OutputStreamProvider() {\n+            @Override\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                spy.accept(outputStream::toByteArray);\n+                return outputStream;\n+            }\n+        };\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/SequenceInputStream\/TransferTo.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4533872 4985214 4985217 4993841 5017268 5017280\n+ * @bug 4533872 4985214 4985217 4993841 5017268 5017280 8298033\n@@ -800,1 +800,1 @@\n-                                      Class expectedException) {\n+                                      Class<? extends Exception> expectedException) {\n@@ -805,1 +805,1 @@\n-            if (expectedException.isInstance(e)) {\n+            if (expectedException == e.getClass()) {\n","filename":"test\/jdk\/java\/lang\/Character\/Supplementary.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test Thread.yield submits the virtual thread task to the expected queue\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @run junit\/othervm -Djdk.virtualThreadScheduler.maxPoolSize=1 YieldQueuing\n+ *\/\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class YieldQueuing {\n+\n+    \/**\n+     * Test Thread.yield submits the task for the current virtual thread to a scheduler\n+     * submission queue when there are no tasks in the local queue.\n+     *\/\n+    @Test\n+    void testYieldWithEmptyLocalQueue() throws Exception {\n+        var list = new CopyOnWriteArrayList<String>();\n+\n+        var threadsStarted = new AtomicBoolean();\n+\n+        var threadA = Thread.ofVirtual().unstarted(() -> {\n+            \/\/ pin thread until task for B is in submission queue\n+            while (!threadsStarted.get()) {\n+                Thread.onSpinWait();\n+            }\n+\n+            list.add(\"A\");\n+            Thread.yield();      \/\/ push task for A to submission queue, B should run\n+            list.add(\"A\");\n+        });\n+\n+        var threadB = Thread.ofVirtual().unstarted(() -> {\n+            list.add(\"B\");\n+        });\n+\n+        \/\/ push tasks for A and B to submission queue\n+        threadA.start();\n+        threadB.start();\n+\n+        \/\/ release A\n+        threadsStarted.set(true);\n+\n+        \/\/ wait for result\n+        threadA.join();\n+        threadB.join();\n+        assertEquals(list, List.of(\"A\", \"B\", \"A\"));\n+    }\n+\n+    \/**\n+     * Test Thread.yield submits the task for the current virtual thread to the local\n+     * queue when there are tasks in the local queue.\n+     *\/\n+    @Test\n+    void testYieldWithNonEmptyLocalQueue() throws Exception {\n+        var list = new CopyOnWriteArrayList<String>();\n+\n+        var threadsStarted = new AtomicBoolean();\n+\n+        var threadA = Thread.ofVirtual().unstarted(() -> {\n+            \/\/ pin thread until tasks for B and C are in submission queue\n+            while (!threadsStarted.get()) {\n+                Thread.onSpinWait();\n+            }\n+\n+            list.add(\"A\");\n+            LockSupport.park();   \/\/ B should run\n+            list.add(\"A\");\n+        });\n+\n+        var threadB = Thread.ofVirtual().unstarted(() -> {\n+            list.add(\"B\");\n+            LockSupport.unpark(threadA);  \/\/ push task for A to local queue\n+            Thread.yield();               \/\/ push task for B to local queue, A should run\n+            list.add(\"B\");\n+        });\n+\n+        var threadC = Thread.ofVirtual().unstarted(() -> {\n+            list.add(\"C\");\n+        });\n+\n+        \/\/ push tasks for A, B and C to submission queue\n+        threadA.start();\n+        threadB.start();\n+        threadC.start();\n+\n+        \/\/ release A\n+        threadsStarted.set(true);\n+\n+        \/\/ wait for result\n+        threadA.join();\n+        threadB.join();\n+        threadC.join();\n+        assertEquals(list, List.of(\"A\", \"B\", \"A\", \"B\", \"C\"));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/YieldQueuing.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main YieldALot 500000\n+ * @run main YieldALot 350000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/YieldALot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -753,7 +753,0 @@\n-    @Test\n-    public void testAllowThreadSuspension() {\n-        ThreadGroup group = new ThreadGroup(\"foo\");\n-        assertFalse(group.allowThreadSuspension(false));\n-        assertFalse(group.allowThreadSuspension(true));\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/ThreadGroup\/BasicTests.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8245462 8229822 8254786 8297075 8297149\n+ * @bug 8245462 8229822 8254786 8297075 8297149 8298340\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelRequestTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8294047\n+ * @library \/test\/lib\n+ * @run junit HttpResponseInputStreamInterruptTest\n+ *\/\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class HttpResponseInputStreamInterruptTest {\n+\n+    HttpServer server;\n+    int port;\n+    private final CountDownLatch interruptReadyLatch = new CountDownLatch(2);\n+    private final CountDownLatch interruptDoneLatch = new CountDownLatch(1);\n+    static final String FIRST_MESSAGE = \"Should be received\";\n+    static final String SECOND_MESSAGE = \"Shouldn't be received\";\n+\n+    @BeforeAll\n+    void before() throws Exception {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        InetSocketAddress addr = new InetSocketAddress(loopback, 0);\n+        server = HttpServer.create(addr, 0);\n+        port = server.getAddress().getPort();\n+        Handler handler = new Handler(interruptReadyLatch, interruptDoneLatch);\n+        server.createContext(\"\/HttpResponseInputStreamInterruptTest\/\", handler);\n+        server.start();\n+    }\n+\n+    @AfterAll\n+    void after() throws Exception {\n+        server.stop(0);\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        \/\/ create client and interrupter threads\n+        Thread clientThread = createClientThread(interruptReadyLatch, port);\n+        Thread interrupterThread = new Thread(() -> {\n+            try {\n+                \/\/ wait until the clientThread is just about to read the second message sent by the server\n+                \/\/ then interrupt the thread to cause an error to be thrown\n+                interruptReadyLatch.await();\n+                clientThread.interrupt();\n+                interruptDoneLatch.countDown();\n+            } catch (InterruptedException e) {\n+                System.out.println(\"interrupterThread failed\");\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        \/\/ Start the threads then wait until clientThread completes\n+        clientThread.start();\n+        interrupterThread.start();\n+        clientThread.join();\n+    }\n+\n+    static class Handler implements HttpHandler {\n+\n+        CountDownLatch interruptReadyLatch;\n+        CountDownLatch interruptDoneLatch;\n+\n+        public Handler(CountDownLatch interruptReadyLatch, CountDownLatch interruptDoneLatch) {\n+            this.interruptReadyLatch = interruptReadyLatch;\n+            this.interruptDoneLatch = interruptDoneLatch;\n+        }\n+\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                byte[] workingResponse = FIRST_MESSAGE.getBytes();\n+                byte[] errorResponse = SECOND_MESSAGE.getBytes();\n+                exchange.sendResponseHeaders(200, workingResponse.length + errorResponse.length);\n+\n+                \/\/ write and flush the first message which is expected to be received successfully\n+                os.write(workingResponse);\n+                os.flush();\n+\n+                \/\/ await the interrupt threads completion, then write the second message\n+                interruptReadyLatch.countDown();\n+                interruptDoneLatch.await();\n+                os.write(errorResponse);\n+            } catch (InterruptedException e) {\n+                System.out.println(\"interruptDoneLatch await failed\");\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    static Thread createClientThread(CountDownLatch interruptReadyLatch, int port) {\n+        return new Thread(() -> {\n+            try {\n+                HttpClient client = HttpClient\n+                        .newBuilder()\n+                        .proxy(HttpClient.Builder.NO_PROXY)\n+                        .build();\n+\n+                URI uri = URIBuilder.newBuilder()\n+                        .scheme(\"http\")\n+                        .loopback()\n+                        .port(port)\n+                        .path(\"\/HttpResponseInputStreamInterruptTest\/\")\n+                        .build();\n+\n+                HttpRequest request = HttpRequest\n+                        .newBuilder(uri)\n+                        .GET()\n+                        .build();\n+\n+                \/\/ Send a httpRequest and assert the first response is received as expected\n+                HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());\n+                String firstOutput = new String(response.body().readNBytes(FIRST_MESSAGE.getBytes().length));\n+                assertEquals(firstOutput, FIRST_MESSAGE);\n+\n+                \/\/ countdown on latch, and assert that an IOException is throw due to the interrupt\n+                \/\/ and assert that the cause is a InterruptedException\n+                interruptReadyLatch.countDown();\n+                var thrown = assertThrows(IOException.class, () -> response.body().readAllBytes(), \"expected IOException\");\n+                var cause = thrown.getCause();\n+                assertTrue(cause instanceof InterruptedException, cause + \" is not an InterruptedException\");\n+                var thread = Thread.currentThread();\n+                assertTrue(thread.isInterrupted(), \"Thread \" + thread + \" is not interrupted\");\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                fail();\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpResponseInputStreamInterruptTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-\/*\n- * @test\n- * @bug 8057113\n- * @summary Verify getExtension method\n- * @run testng Extensions\n- *\/\n-public class Extensions {\n-    \/**\n-     * Returns path name string and expected extension pairs.\n-     *\n-     * @return {@code {{\"pathname\", \"extension\"},...}}\n-     *\/\n-    @DataProvider\n-    static Object[][] getProvider() {\n-        Object[][] pairs = {\n-            {\"\",               null},\n-            {\".\",              null},\n-            {\"..\",             \"\"},\n-            {\"...\",            \"\"},\n-            {\"....\",           \"\"},\n-            {\".....\",          \"\"},\n-            {\"aa\",             null},\n-            {\"a.\",             \"\"},\n-            {\".a\",             null},\n-            {\"..a\",            \"a\"},\n-            {\"...a\",           \"a\"},\n-            {\"....a\",          \"a\"},\n-            {\".a.b\",           \"b\"},\n-            {\"...a.b\",         \"b\"},\n-            {\"...a.b.\",        \"\"},\n-            {\"..foo\",          \"foo\"},\n-            {\"foo.\",           \"\"},\n-            {\"test.\",          \"\"},\n-            {\"test..\",         \"\"},\n-            {\"test...\",        \"\"},\n-            {\"test.rb\",        \"rb\"},\n-            {\"a\/b\/d\/test.rb\" , \"rb\"},\n-            {\".a\/b\/d\/test.rb\", \"rb\"},\n-            {\"test\",           null},\n-            {\".profile\",       null},\n-            {\".profile.sh\",    \"sh\"},\n-            {\"foo.tar.gz\",     \"gz\"},\n-            {\"foo.bar.\",       \"\"},\n-            {\"archive.zip\",    \"zip\"},\n-            {\"compress.gzip\",  \"gzip\"},\n-            {\"waitwhat.&$!#%\", \"&$!#%\"},\n-            {\"6.283185307\",    \"283185307\"}\n-        };\n-        return pairs;\n-    }\n-\n-    @Test(dataProvider = \"getProvider\")\n-    public static void get(String pathname, String extension) {\n-        Assert.assertEquals(Path.of(pathname).getExtension(), extension);\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Extensions.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import java.util.Calendar;\n+import java.util.Locale;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.nio.file.Paths;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.io.File;\n+import static java.util.Calendar.WEDNESDAY;\n+\n+\/*\n+ * @test\n+ * @bug 8297684 8269039\n+ * @summary Checking custom CalendarDataProvider with SPI contained in signed jar does\n+ *          not produce NPE.\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.timestamp\n+ *          java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ *          java.base\/sun.security.tools.keytool\n+ *          jdk.jartool\/jdk.security.jarsigner\n+ * @library \/test\/lib\n+ * @library provider\n+ * @build baz.CalendarDataProviderImpl\n+ * @run main\/timeout=600 TestSPISigned\n+ *\/\n+public class TestSPISigned {\n+\n+    private static final String TEST_CLASSES = System.getProperty(\"test.classes\", \".\");\n+    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n+\n+    private static final Path META_INF_DIR = Paths.get(TEST_SRC, \"provider\", \"meta\");\n+    private static final Path PROVIDER_PARENT = Paths.get(TEST_CLASSES, \"..\");\n+    private static final Path PROVIDER_DIR = PROVIDER_PARENT.resolve(\"provider\");\n+    private static final Path MODS_DIR = Paths.get(\"mods\");\n+    private static final Path UNSIGNED_JAR = MODS_DIR.resolve(\"unsigned-with-locale.jar\");\n+    private static final Path SIGNED_JAR = MODS_DIR.resolve(\"signed-with-locale.jar\");\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length == 1) {\n+            String arg = args[0];\n+            if (\"run-test\".equals(arg)) {\n+                System.out.println(\"Debug: Running test\");\n+                String provProp = System.getProperty(\"java.locale.providers\");\n+                if (!\"SPI\".equals(provProp)) {\n+                   throw new RuntimeException(\"Test failed! Expected -Djava.locale.providers=SPI to be set for test run\");\n+                }\n+                doRunTest();\n+            } else {\n+               throw new RuntimeException(\"Test failed! Expected 'run-test' arg for test run\");\n+            }\n+        } else {\n+            \/\/ Set up signed jar with custom calendar data provider\n+            \/\/\n+            \/\/ 1. Create jar with custom CalendarDataProvider\n+            JarUtils.createJarFile(UNSIGNED_JAR, PROVIDER_DIR);\n+            JarUtils.updateJarFile(UNSIGNED_JAR, META_INF_DIR);\n+            \/\/ create signer's keypair\n+            SecurityTools.keytool(\"-genkeypair -keyalg RSA -keystore ks \" +\n+                                  \"-storepass changeit -dname CN=test -alias test\")\n+                     .shouldHaveExitValue(0);\n+            \/\/ sign jar\n+            SecurityTools.jarsigner(\"-keystore ks -storepass changeit \" +\n+                                \"-signedjar \" + SIGNED_JAR + \" \" + UNSIGNED_JAR + \" test\")\n+                     .shouldHaveExitValue(0);\n+            \/\/ run test, which must not throw a NPE\n+            List<String> testRun = new ArrayList<>();\n+            testRun.add(\"-Djava.locale.providers=SPI\");\n+            testRun.add(\"-cp\");\n+            String classPath = System.getProperty(\"java.class.path\");\n+            classPath = classPath + File.pathSeparator + SIGNED_JAR.toAbsolutePath().toString();\n+            testRun.add(classPath);\n+            testRun.add(TestSPISigned.class.getSimpleName());\n+            testRun.add(\"run-test\");\n+            OutputAnalyzer out = ProcessTools.executeTestJvm(testRun);\n+            out.shouldHaveExitValue(0);\n+            out.shouldContain(\"DEBUG: Getting xx language\");\n+        }\n+    }\n+\n+    private static void doRunTest() {\n+        Locale locale = new Locale(\"xx\", \"YY\");\n+        Calendar kcal = Calendar.getInstance(locale);\n+        try {\n+            check(WEDNESDAY, kcal.getFirstDayOfWeek());\n+            check(7, kcal.getMinimalDaysInFirstWeek());\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(\"Test failed with signed jar and \" +\n+                    \" argument java.locale.providers=SPI\", ex);\n+        }\n+    }\n+\n+    private static <T> void check(T expected, T actual) {\n+        Asserts.assertEquals(expected, actual, \"Expected calendar from SPI to be in effect\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/security\/SignedJar\/spi-calendar-provider\/TestSPISigned.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package baz;\n+\n+import static java.util.Calendar.*;\n+import java.util.Locale;\n+import java.util.spi.CalendarDataProvider;\n+\n+public class CalendarDataProviderImpl extends CalendarDataProvider {\n+    private static final Locale[] locales = { new Locale(\"xx\", \"YY\") };\n+\n+    @Override\n+    public int getFirstDayOfWeek(Locale locale) {\n+        return WEDNESDAY;\n+    }\n+\n+    @Override\n+    public int getMinimalDaysInFirstWeek(Locale locale) {\n+        if (locale.getLanguage().equals(\"xx\")) {\n+            System.out.println(\"DEBUG: Getting xx language\");\n+        }\n+        return 7;\n+    }\n+\n+    @Override\n+    public Locale[] getAvailableLocales() {\n+        return locales;\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/SignedJar\/spi-calendar-provider\/provider\/baz\/CalendarDataProviderImpl.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+#\n+#\n+#\n+# fully-qualified name of the java.util.spi.CalendarDataProvider\n+# implementation class\n+#\n+baz.CalendarDataProviderImpl\n","filename":"test\/jdk\/java\/security\/SignedJar\/spi-calendar-provider\/provider\/meta\/META-INF\/services\/java.util.spi.CalendarDataProvider","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8281236\n+ * @summary Check DTLS connection behaviors for named groups configuration\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @build DTLSOverDatagram\n+ * @run main\/othervm DTLSNamedGroups\n+ *\/\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLParameters;\n+import java.security.Security;\n+\n+\/**\n+ * Test DTLS client authentication.\n+ *\/\n+public class DTLSNamedGroups extends DTLSOverDatagram {\n+    \/\/ Make sure default DH(E) key exchange is not used for DTLS v1.2.\n+    private static String[] cipherSuites = new String[] {\n+        \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"\n+    };\n+\n+    private final String[] serverNamedGroups;\n+    private final String[] clientNamedGroups;\n+\n+    public DTLSNamedGroups(String[] serverNamedGroups,\n+                           String[] clientNamedGroups) {\n+        this.serverNamedGroups = serverNamedGroups;\n+        this.clientNamedGroups = clientNamedGroups;\n+    }\n+\n+    @Override\n+    SSLEngine createSSLEngine(boolean isClient) throws Exception {\n+        SSLEngine engine = super.createSSLEngine(isClient);\n+\n+        SSLParameters sslParameters = engine.getSSLParameters();\n+        if (isClient) {\n+            sslParameters.setNamedGroups(clientNamedGroups);\n+            sslParameters.setCipherSuites(cipherSuites);\n+        } else {\n+            sslParameters.setNamedGroups(serverNamedGroups);\n+        }\n+        engine.setSSLParameters(sslParameters);\n+\n+        return engine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(new String[] {\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                new String[] {\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(null,\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                null,\n+                false);\n+        runTest(new String[0],\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                true);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                new String[0],\n+                true);\n+        runTest(new String[] {\n+                        \"secp256NA\"\n+                },\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] serverNamedGroups,\n+                                String[] clientNamedGroups,\n+                                boolean exceptionExpected) throws Exception {\n+        DTLSNamedGroups testCase = new DTLSNamedGroups(\n+                serverNamedGroups, clientNamedGroups);\n+        try {\n+            testCase.runTest(testCase);\n+        } catch (Exception e) {\n+            if (!exceptionExpected) {\n+                throw e;\n+            } else { \/\/ Otherwise, swallow the expected exception and return.\n+                return;\n+            }\n+        }\n+\n+        if (exceptionExpected) {\n+            throw new RuntimeException(\"Unexpected success!\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSNamedGroups.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8281236\n+ * @summary Check TLS connection behaviors for named groups configuration\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm NamedGroups\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLSocket;\n+import java.security.Security;\n+\n+public class NamedGroups extends SSLSocketTemplate {\n+    private final String[] serverNamedGroups;\n+    private final String[] clientNamedGroups;\n+    private final boolean exceptionExpected;\n+\n+    public NamedGroups(String[] serverNamedGroups,\n+                            String[] clientNamedGroups,\n+                            boolean exceptionExpected) {\n+        this.serverNamedGroups = serverNamedGroups;\n+        this.clientNamedGroups = clientNamedGroups;\n+        this.exceptionExpected = exceptionExpected;\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        sslParameters.setNamedGroups(serverNamedGroups);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        SSLParameters sslParameters = socket.getSSLParameters();\n+        sslParameters.setNamedGroups(clientNamedGroups);\n+        socket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) {\n+        try {\n+            super.runServerApplication(socket);\n+        } catch (Exception ex) {\n+            \/\/ Just ignore, let the client handle the failure information.\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n+        try {\n+            super.runClientApplication(sslSocket);\n+        } catch (Exception ex) {\n+            if (!exceptionExpected) {\n+                throw ex;\n+            } else {  \/\/ Otherwise, swallow the exception and return.\n+                return;\n+            }\n+        }\n+\n+        if (exceptionExpected) {\n+            throw new RuntimeException(\"Unexpected success!\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(new String[] {\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                new String[] {\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(null,\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                null,\n+                false);\n+        runTest(new String[0],\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                true);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                new String[0],\n+                true);\n+        runTest(new String[] {\n+                        \"secp256NA\"\n+                },\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] serverNamedGroups,\n+                                String[] clientNamedGroups,\n+                                boolean exceptionExpected) throws Exception {\n+        new NamedGroups(serverNamedGroups,\n+                clientNamedGroups, exceptionExpected).run();\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/NamedGroups.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8281236\n+ * @summary check SSLParameters.setNamedGroups() implementation\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import java.util.Arrays;\n+\n+public class NamedGroupsSpec {\n+    public static void main(String[] args) throws Exception {\n+        runTest(null,             \/\/ null array should be allowed.\n+                false);\n+        runTest(new String[] {    \/\/ empty array should be allowed\n+                    \/\/ blank line\n+                },\n+                false);\n+        runTest(new String[] {    \/\/ multiple elements should be fine\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {    \/\/ no duplicate element should be allowed\n+                        \"x25519\",\n+                        \"x25519\"\n+                },\n+                true);\n+        runTest(new String[] {    \/\/ no null element should be allowed\n+                        null\n+                },\n+                true);\n+        runTest(new String[] {    \/\/ no blank element should be allowed\n+                        \"\"\n+                },\n+                true);\n+        runTest(new String[] {    \/\/ no blank element should be allowed\n+                        \"x25519\",\n+                        \"\"\n+                },\n+                true);\n+        runTest(new String[] {    \/\/ no null element should be allowed.\n+                        \"x25519\",\n+                        null\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] namedGroups,\n+                                boolean exceptionExpected) throws Exception {\n+        SSLParameters sslParams = new SSLParameters();\n+        try {\n+            sslParams.setNamedGroups(namedGroups);\n+        } catch (Exception ex) {\n+            if (!exceptionExpected ||\n+                    !(ex instanceof IllegalArgumentException)) {\n+                throw ex;\n+            } else {  \/\/ Otherwise, swallow the exception and return.\n+                return;\n+            }\n+        }\n+\n+        if (exceptionExpected) {\n+            throw new RuntimeException(\"Unexpected success!\");\n+        }\n+\n+        \/\/ Check if the getNamedGroups() method returns the same elements.\n+        String[] configuredNamedGroups = sslParams.getNamedGroups();\n+        if (!Arrays.equals(namedGroups, configuredNamedGroups)) {\n+            throw new RuntimeException(\n+                    \"SSLParameters.getNamedGroups() method does not return \"\n+                  + \"the same elements as set with setNamedGroups()\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/NamedGroupsSpec.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.sound.sampled.AudioInputStream;\n+import javax.sound.sampled.AudioSystem;\n+import javax.sound.sampled.Clip;\n+import javax.sound.sampled.LineUnavailableException;\n+import javax.sound.sampled.UnsupportedAudioFileException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+\/*\n+ * @test\n+ * @key sound\n+ * @bug 8282578\n+ * @summary AIOOBE in javax.sound.sampled.Clip\n+ * @run main EmptySysExMessageTest\n+ *\/\n+\n+public class EmptySysExMessageTest {\n+    public static void main(String[] args) {\n+        String sep = System.getProperty(\"file.separator\");\n+        String dir = System.getProperty(\"test.src\", \".\");\n+        String name = \"zerosysex.mid\";\n+        try {\n+            readAudioFile(dir + sep + name);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Invalid file \" + name\n+                    + \" caused unexpected exception during read: \"\n+                    + t + System.lineSeparator());\n+        }\n+    }\n+\n+    static void readAudioFile(String name) throws IOException {\n+        File soundFile = new File(name);\n+        Path path = Paths.get(soundFile.getAbsolutePath());\n+        byte[] samples = Files.readAllBytes(path);\n+\n+        try {\n+            AudioInputStream audioInputStream =\n+                    AudioSystem.getAudioInputStream(new ByteArrayInputStream(samples));\n+            try (Clip clip = AudioSystem.getClip()) {\n+                clip.open(audioInputStream);\n+                clip.start();\n+                Thread.sleep(1000);\n+                clip.stop();\n+            }\n+        } catch (UnsupportedAudioFileException\n+                 | LineUnavailableException\n+                 | IOException\n+                 | InterruptedException\n+                 | IllegalArgumentException\n+                 | IllegalStateException\n+                 | SecurityException expected) {\n+            \/\/ Do nothing, these types of exception are expected on invalid file\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/sound\/midi\/SysexMessage\/EmptySysExMessageTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"filename":"test\/jdk\/javax\/sound\/midi\/SysexMessage\/zerosysex.mid","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JFileChooser;\n+import javax.swing.SwingUtilities;\n+import javax.swing.Icon;\n+import javax.swing.WindowConstants;\n+import javax.swing.filechooser.FileSystemView;\n+\n+\/*\n+ * @test\n+ * @bug 8296198\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test to check if the Link to a folder is traversable with custom\n+ * FileSystemView is valid on ValueChanged property listener.\n+ * @run main\/manual CustomFSVLinkTest\n+ *\/\n+public class CustomFSVLinkTest {\n+    static JFrame frame;\n+    static JFileChooser jfc;\n+\n+    static PassFailJFrame passFailJFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            public void run() {\n+                try {\n+                    initialize();\n+                } catch (InterruptedException | InvocationTargetException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    static void initialize() throws InterruptedException, InvocationTargetException {\n+        \/\/Initialize the components\n+        final String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. Create a link to a any valid folder.\n+                2. Navigate to the linked folder through the link created\n+                (From FileChooser).\n+                3. If \"link\" can't be traversed or if its absolute path is null\n+                   click FAIL. If \"link\" can be traversed then click PASS.\n+                \"\"\";\n+        frame = new JFrame(\"JFileChooser Link test\");\n+        jfc = new JFileChooser(new MyFileSystemView());\n+        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS, 5L, 8, 40);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+        jfc.setDialogType(JFileChooser.CUSTOM_DIALOG);\n+\n+        frame.add(jfc, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    private static class MyFileSystemView extends FileSystemView {\n+        FileSystemView delegate;\n+\n+        MyFileSystemView() {\n+            delegate = FileSystemView.getFileSystemView();\n+        }\n+\n+        @Override\n+        public File createNewFolder(File containingDir) throws IOException {\n+            return delegate.createNewFolder(containingDir);\n+        }\n+\n+        @Override\n+        public boolean isRoot(File f) {\n+            return delegate.isRoot(f);\n+        }\n+\n+        @Override\n+        public Boolean isTraversable(File f) {\n+            return delegate.isTraversable(f);\n+        }\n+\n+        @Override\n+        public String getSystemDisplayName(File f) {\n+            return delegate.getSystemDisplayName(f);\n+        }\n+\n+        @Override\n+        public String getSystemTypeDescription(File f) {\n+            return delegate.getSystemTypeDescription(f);\n+        }\n+\n+        @Override\n+        public Icon getSystemIcon(File f) {\n+            return delegate.getSystemIcon(f);\n+        }\n+\n+        @Override\n+        public boolean isParent(File folder, File file) {\n+            return delegate.isParent(folder, file);\n+        }\n+\n+        @Override\n+        public File getChild(File parent, String fileName) {\n+            return delegate.getChild(parent, fileName);\n+        }\n+\n+        @Override\n+        public boolean isFileSystem(File f) {\n+            return delegate.isFileSystem(f);\n+        }\n+\n+        @Override\n+        public boolean isHiddenFile(File f) {\n+            return delegate.isHiddenFile(f);\n+        }\n+\n+        @Override\n+        public boolean isFileSystemRoot(File dir) {\n+            return delegate.isFileSystemRoot(dir);\n+        }\n+\n+        @Override\n+        public boolean isDrive(File dir) {\n+            return delegate.isDrive(dir);\n+        }\n+\n+        @Override\n+        public boolean isFloppyDrive(File dir) {\n+            return delegate.isFloppyDrive(dir);\n+        }\n+\n+        @Override\n+        public boolean isComputerNode(File dir) {\n+            return delegate.isComputerNode(dir);\n+        }\n+\n+        @Override\n+        public File[] getRoots() {\n+            return delegate.getRoots();\n+        }\n+\n+        @Override\n+        public File getHomeDirectory() {\n+            return delegate.getHomeDirectory();\n+        }\n+\n+        @Override\n+        public File getDefaultDirectory() {\n+            return delegate.getDefaultDirectory();\n+        }\n+\n+        @Override\n+        public File createFileObject(File dir, String filename) {\n+            return delegate.createFileObject(dir, filename);\n+        }\n+\n+        @Override\n+        public File createFileObject(String path) {\n+            return delegate.createFileObject(path);\n+        }\n+\n+        @Override\n+        public File[] getFiles(File dir, boolean useFileHiding) {\n+            return delegate.getFiles(dir, useFileHiding);\n+        }\n+\n+        @Override\n+        public File getParentDirectory(File dir) {\n+            return delegate.getParentDirectory(dir);\n+        }\n+\n+        @Override\n+        public File[] getChooserComboBoxFiles() {\n+            return delegate.getChooserComboBoxFiles();\n+        }\n+\n+        @Override\n+        public boolean isLink(File file) {\n+            return delegate.isLink(file);\n+        }\n+\n+        @Override\n+        public File getLinkLocation(File file) throws FileNotFoundException {\n+            return delegate.getLinkLocation(file);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileSystemView\/CustomFSVLinkTest.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4314194 8075916\n+ * @bug 4314194 8075916 8298083\n@@ -43,0 +43,1 @@\n+import javax.swing.plaf.synth.SynthLookAndFeel;\n@@ -45,5 +46,5 @@\n-    private static JFrame frame;\n-    private static JRadioButton radioButton;\n-    private static JCheckBox checkBox;\n-    private static Point point;\n-    private static Rectangle rect;\n+    private static volatile JFrame frame;\n+    private static volatile JRadioButton radioButton;\n+    private static volatile JCheckBox checkBox;\n+    private static volatile Point point;\n+    private static volatile Rectangle rect;\n@@ -90,3 +91,19 @@\n-    private static void createUI() {\n-        UIManager.getDefaults().put(\"CheckBox.disabledText\", checkboxColor);\n-        UIManager.getDefaults().put(\"RadioButton.disabledText\", radioButtonColor);\n+    private static void createUI(String laf) {\n+        if (UIManager.getLookAndFeel() instanceof SynthLookAndFeel) {\n+            \/\/ reset \"basic\" properties\n+            UIManager.getDefaults().put(\"CheckBox.disabledText\", null);\n+            UIManager.getDefaults().put(\"RadioButton.disabledText\", null);\n+            \/\/ set \"synth\" properties\n+            UIManager.getDefaults().put(\"CheckBox[Disabled].textForeground\", checkboxColor);\n+            \/\/ for some reason the RadioButton[Disabled] does not work\n+            \/\/ see https:\/\/bugs.openjdk.org\/browse\/JDK-8298149\n+            \/\/UIManager.getDefaults().put(\"RadioButton[Disabled].textForeground\", radioButtonColor);\n+            UIManager.getDefaults().put(\"RadioButton[Enabled].textForeground\", radioButtonColor);\n+        } else {\n+            \/\/ reset \"synth\" properties\n+            UIManager.getDefaults().put(\"CheckBox[Disabled].textForeground\", null);\n+            UIManager.getDefaults().put(\"RadioButton[Enabled].textForeground\", null);\n+            \/\/ set \"basic\" properties\n+            UIManager.getDefaults().put(\"CheckBox.disabledText\", checkboxColor);\n+            UIManager.getDefaults().put(\"RadioButton.disabledText\", radioButtonColor);\n+        }\n@@ -101,1 +118,1 @@\n-        frame = new JFrame(\"bug4314194\");\n+        frame = new JFrame(laf);\n@@ -125,1 +142,1 @@\n-                SwingUtilities.invokeAndWait(() -> createUI());\n+                SwingUtilities.invokeAndWait(() -> createUI(laf.getName()));\n@@ -144,1 +161,0 @@\n-\n","filename":"test\/jdk\/javax\/swing\/JRadioButton\/4314194\/bug4314194.java","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test ScopedValue with many bindings and rebinings\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @library \/test\/lib\n+ * @key randomness\n+ * @run testng ManyBindings\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.ScopedValue.Carrier;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class ManyBindings {\n+    private static final Random RND = RandomFactory.getRandom();\n+\n+    \/\/ number of scoped values to create\n+    private static final int SCOPED_VALUE_COUNT = 16;\n+\n+    \/\/ recursive depth to test\n+    private static final int MAX_DEPTH = 24;\n+\n+    \/**\n+     * Stress test bindings on platform thread.\n+     *\/\n+    public void testPlatformThread() {\n+        test();\n+    }\n+\n+    \/**\n+     * Stress test bindings on virtual thread.\n+     *\/\n+    public void testVirtualThread() throws Exception {\n+        VThreadRunner.run(() -> test());\n+    }\n+\n+    \/**\n+     * Scoped value and its expected value (or null if not bound).\n+     *\/\n+    record KeyAndValue<T>(ScopedValue<T> key, T value) {\n+        KeyAndValue() {\n+            this(ScopedValue.newInstance(), null);\n+        }\n+    }\n+\n+    \/**\n+     * Stress test bindings on current thread.\n+     *\/\n+    private void test() {\n+        KeyAndValue<Integer>[] array = new KeyAndValue[SCOPED_VALUE_COUNT];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = new KeyAndValue<>();\n+        }\n+        test(array, 1);\n+    }\n+\n+    \/**\n+     * Test that the scoped values in the array have the expected value, then\n+     * recursively call this method with some of the scoped values bound to a\n+     * new value.\n+     *\n+     * @param array the scoped values and their expected value\n+     * @param depth current recurive depth\n+     *\/\n+    private void test(KeyAndValue<Integer>[] array, int depth) {\n+        if (depth > MAX_DEPTH)\n+            return;\n+\n+        \/\/ check that the scoped values have the expected values\n+        check(array);\n+\n+        \/\/ try to pollute the cache\n+        lotsOfReads(array);\n+\n+        \/\/ create a Carrier to bind\/rebind some of the scoped values\n+        int len = array.length;\n+        Carrier carrier = null;\n+\n+        KeyAndValue<Integer>[] newArray = Arrays.copyOf(array, len);\n+        int n = Math.max(1, RND.nextInt(len \/ 2));\n+        while (n > 0) {\n+            int index = RND.nextInt(len);\n+            ScopedValue<Integer> key = array[index].key;\n+            int newValue = RND.nextInt();\n+            if (carrier == null) {\n+                carrier = ScopedValue.where(key, newValue);\n+            } else {\n+                carrier = carrier.where(key, newValue);\n+            }\n+            newArray[index] = new KeyAndValue<>(key, newValue);\n+            n--;\n+        }\n+\n+        \/\/ invoke recursively\n+        carrier.run(() -> {\n+            test(newArray, depth+1);\n+        });\n+\n+        \/\/ check that the scoped values have the origina values\n+        check(array);\n+    }\n+\n+    \/**\n+     * Check that the given scoped values have the expected value.\n+     *\/\n+    private void check(KeyAndValue<Integer>[] array) {\n+        for (int i = 0; i < array.length; i++) {\n+            ScopedValue<Integer> key = array[i].key;\n+            Integer value = array[i].value;\n+            if (value == null) {\n+                assertFalse(key.isBound());\n+            } else {\n+                assertEquals(key.get(), value);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Do lots of reads of the scoped values, to pollute the SV cache.\n+     *\/\n+    private void lotsOfReads(KeyAndValue<Integer>[] array) {\n+        for (int k = 0; k < 1000; k++) {\n+            int index = RND.nextInt(array.length);\n+            Integer value = array[index].value;\n+            if (value != null) {\n+                ScopedValue<Integer> key = array[index].key;\n+                assertEquals(key.get(), value);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ManyBindings.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,442 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ScopedValue API\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @run testng ScopeValueAPI\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class ScopeValueAPI {\n+\n+    @DataProvider\n+    public Object[][] factories() {\n+        return new Object[][] {\n+                { Thread.ofPlatform().factory() },\n+                { Thread.ofVirtual().factory() },\n+        };\n+    }\n+\n+    \/**\n+     * Test that the run method is invoked.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRun(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class Box { static boolean executed; }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue.where(name, \"duke\", () -> { Box.executed = true; });\n+            assertTrue(Box.executed);\n+        });\n+    }\n+\n+    \/**\n+     * Test the run method throwing an exception.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRunThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Runnable op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test that the call method is invoked.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCall(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            String result = ScopedValue.where(name, \"duke\", name::get);\n+            assertEquals(result, \"duke\");\n+        });\n+    }\n+\n+    \/**\n+     * Test the call method throwing an exception.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCallThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Callable<Void> op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test get method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ run\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertEquals(name1.get(), \"duke\");\n+                assertThrows(NoSuchElementException.class, name2::get);\n+\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ call\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertEquals(name1.get(), \"duke\");\n+                assertThrows(NoSuchElementException.class, name2::get);\n+                return null;\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+        });\n+    }\n+\n+    \/**\n+     * Test isBound method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testIsBound(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ run\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+                return null;\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test orElse method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testOrElse(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertTrue(name.orElse(null) == null);\n+            assertEquals(name.orElse(\"default\"), \"default\");\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElse(null), \"duke\");\n+                assertEquals(name.orElse(\"default\"), \"duke\");\n+            });\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElse(null), \"duke\");\n+                assertEquals(name.orElse(\"default\"), \"duke\");\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test orElseThrow method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testOrElseThrow(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException { }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertThrows(FooException.class, () -> name.orElseThrow(FooException::new));\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElseThrow(FooException::new), \"duke\");\n+            });\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElseThrow(FooException::new), \"duke\");\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test two bindings.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testTwoBindings(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\").where(age, 100).run(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                assertEquals((int) age.get(), 100);\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\").where(age, 100).call(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                assertEquals((int) age.get(), 100);\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRebinding(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding from null vaue to another value.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRebindingFromNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), null);\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), null);\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding to null value.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRebindingToNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(name.get() == null);\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(name.get() == null);\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test Carrier.get.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCarrierGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ one scoped value\n+            var carrier1 = ScopedValue.where(name, \"duke\");\n+            assertEquals(carrier1.get(name), \"duke\");\n+            assertThrows(NoSuchElementException.class, () -> carrier1.get(age));\n+\n+            \/\/ two scoped values\n+            var carrier2 = carrier1.where(age, 20);\n+            assertEquals(carrier2.get(name), \"duke\");\n+            assertEquals((int) carrier2.get(age), 20);\n+        });\n+    }\n+\n+    \/**\n+     * Test NullPointerException.\n+     *\/\n+    public void testNullPointerException() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> { }));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> null));\n+\n+        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+\n+        var carrier = ScopedValue.where(name, \"duke\");\n+        assertThrows(NullPointerException.class, () -> carrier.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> carrier.get(null));\n+        assertThrows(NullPointerException.class, () -> carrier.run(null));\n+        assertThrows(NullPointerException.class, () -> carrier.call(null));\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    \/**\n+     * Run the given task in a thread created with the given thread factory.\n+     * @throws Exception if the task throws an exception\n+     *\/\n+    private static void test(ThreadFactory factory, ThrowingRunnable task) throws Exception {\n+        try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+            var future = executor.submit(() -> {\n+                task.run();\n+                return null;\n+            });\n+            try {\n+                future.get();\n+            } catch (ExecutionException ee) {\n+                Throwable cause = ee.getCause();\n+                if (cause instanceof Exception e)\n+                    throw e;\n+                if (cause instanceof Error e)\n+                    throw e;\n+                throw new RuntimeException(cause);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ScopeValueAPI.java","additions":442,"deletions":0,"binary":false,"changes":442,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2021, 2022 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary StressStackOverflow the recovery path for ScopedValue\n+ * @modules jdk.incubator.concurrent\n+ * @compile --enable-preview -source ${jdk.version} StressStackOverflow.java\n+ * @run main\/othervm\/timeout=300 -XX:-TieredCompilation --enable-preview StressStackOverflow\n+ * @run main\/othervm\/timeout=300 -XX:TieredStopAtLevel=1 --enable-preview StressStackOverflow\n+ * @run main\/othervm\/timeout=300 --enable-preview StressStackOverflow\n+ *\/\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadLocalRandom;\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+\n+public class StressStackOverflow {\n+    public static final ScopedValue<Integer> el = ScopedValue.newInstance();\n+\n+    public static final ScopedValue<Integer> inheritedValue = ScopedValue.newInstance();\n+\n+    final ThreadLocalRandom tlr = ThreadLocalRandom.current();\n+    static final TestFailureException testFailureException = new TestFailureException(\"Unexpected value for ScopedValue\");\n+    int ITERS = 1_000_000;\n+\n+    static class TestFailureException extends RuntimeException {\n+        TestFailureException(String s) { super(s); }\n+    }\n+\n+    \/\/ Test the ScopedValue recovery mechanism for stack overflows. We implement both Callable\n+    \/\/ and Runnable interfaces. Which one gets tested depends on the constructor argument.\n+    class DeepRecursion implements Callable, Runnable {\n+\n+        static enum Behaviour {CALL, RUN}\n+        final Behaviour behaviour;\n+\n+        public DeepRecursion(Behaviour behaviour) {\n+            this.behaviour = behaviour;\n+        }\n+\n+        public void run() {\n+            final var last = el.get();\n+            ITERS--;\n+            var nextRandomFloat = tlr.nextFloat();\n+            try {\n+                switch (behaviour) {\n+                    case CALL ->\n+                        ScopedValue.where(el, el.get() + 1).call(() -> fibonacci_pad(20, this));\n+                    case RUN ->\n+                        ScopedValue.where(el, el.get() + 1).run(() -> fibonacci_pad(20, this));\n+                }\n+                if (!last.equals(el.get())) {\n+                    throw testFailureException;\n+                }\n+            } catch (StackOverflowError e) {\n+                if (nextRandomFloat <= 0.1) {\n+                    ScopedValue.where(el, el.get() + 1).run(this);\n+                }\n+            } catch (TestFailureException e) {\n+                throw e;\n+            } catch (Throwable throwable) {\n+                \/\/ StackOverflowErrors cause many different failures. These include\n+                \/\/ StructureViolationExceptions and InvocationTargetExceptions. This test\n+                \/\/ checks that, no matter what the failure mode, scoped values are handled\n+                \/\/ correctly.\n+            } finally {\n+                if (!last.equals(el.get())) {\n+                    throw testFailureException;\n+                }\n+            }\n+\n+            Thread.yield();\n+        }\n+\n+        public Object call() {\n+            run();\n+            return null;\n+        }\n+    }\n+\n+    static final Runnable nop = new Runnable() {\n+        public void run() { }\n+    };\n+\n+    \/\/ Consume some stack.\n+    \/\/\n+\n+    \/\/ The double recursion used here prevents an optimizing JIT from\n+    \/\/ inlining all the recursive calls, which would make it\n+    \/\/ ineffective.\n+    private long fibonacci_pad1(int n, Runnable op) {\n+        if (n <= 1) {\n+            op.run();\n+            return n;\n+        }\n+        return fibonacci_pad1(n - 1, op) + fibonacci_pad1(n - 2, nop);\n+    }\n+\n+    private static final Integer I_42 = 42;\n+\n+    long fibonacci_pad(int n, Runnable op) {\n+        final var last = el.get();\n+        try {\n+            return fibonacci_pad1(tlr.nextInt(n), op);\n+        } catch (StackOverflowError err) {\n+            if (!inheritedValue.get().equals(I_42)) {\n+                throw testFailureException;\n+            }\n+            if (!last.equals(el.get())) {\n+                throw testFailureException;\n+            }\n+            throw err;\n+        }\n+    }\n+\n+    \/\/ Run op in a new thread. Platform or virtual threads are chosen at random.\n+    void runInNewThread(Runnable op) {\n+        var threadFactory\n+                = (tlr.nextBoolean() ? Thread.ofPlatform() : Thread.ofVirtual()).factory();\n+        try (var scope = new StructuredTaskScope<Object>(\"\", threadFactory)) {\n+            var future = scope.fork(() -> {\n+                op.run();\n+                return null;\n+            });\n+            future.get();\n+            scope.join();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public void run() {\n+        try {\n+            ScopedValue.where(inheritedValue, 42).where(el, 0).run(() -> {\n+                try (var scope = new StructuredTaskScope<Object>()) {\n+                    try {\n+                        if (tlr.nextBoolean()) {\n+                            \/\/ Repeatedly test Scoped Values set by ScopedValue::call() and ScopedValue::run()\n+                            final var deepRecursion\n+                                    = new DeepRecursion(tlr.nextBoolean() ? DeepRecursion.Behaviour.CALL : DeepRecursion.Behaviour.RUN);\n+                            deepRecursion.run();\n+                        } else {\n+                            \/\/ Recursively run ourself until we get a stack overflow\n+                            \/\/ Catch the overflow and make sure the recovery path works\n+                            \/\/ for values inherited from a StructuredTaskScope.\n+                            Runnable op = new Runnable() {\n+                                public void run() {\n+                                    try {\n+                                        fibonacci_pad(20, this);\n+                                    } catch (StackOverflowError e) {\n+                                    } catch (TestFailureException e) {\n+                                        throw e;\n+                                    } catch (Throwable throwable) {\n+                                        \/\/ StackOverflowErrors cause many different failures. These include\n+                                        \/\/ StructureViolationExceptions and InvocationTargetExceptions. This test\n+                                        \/\/ checks that, no matter what the failure mode, scoped values are handled\n+                                        \/\/ correctly.\n+                                    } finally {\n+                                        if (!inheritedValue.get().equals(I_42)) {\n+                                            throw testFailureException;\n+                                        }\n+                                    }\n+                                }\n+                            };\n+                            runInNewThread(op);\n+                        }\n+                        scope.join();\n+                    } catch (StructureViolationException structureViolationException) {\n+                        \/\/ Can happen if a stack overflow prevented a StackableScope from\n+                        \/\/ being removed. We can continue.\n+                    } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            });\n+        } catch (StructureViolationException structureViolationException) {\n+            \/\/ Can happen if a stack overflow prevented a StackableScope from\n+            \/\/ being removed. We can continue.\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        var torture = new StressStackOverflow();\n+        while (torture.ITERS > 0) {\n+            torture.run();\n+        }\n+        System.out.println(\"OK\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/StressStackOverflow.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic tests for StructuredTaskScope with scoped values\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @run testng WithScopedValue\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class WithScopedValue {\n+\n+    @DataProvider\n+    public Object[][] factories() {\n+        return new Object[][] {\n+                { Thread.ofPlatform().factory() },\n+                { Thread.ofVirtual().factory() },\n+        };\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a child thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkInheritsScopedValue1(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+                Future<String> future = scope.fork(() -> {\n+                    return name.get(); \/\/ child should read \"x\"\n+                });\n+                scope.join();\n+                return future.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a grandchild thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkInheritsScopedValue2(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Future<String> future1 = scope1.fork(() -> {\n+                    try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                        Future<String> future2 = scope2.fork(() -> {\n+                            return name.get(); \/\/ grandchild should read \"x\"\n+                        });\n+                        scope2.join();\n+                        return future2.resultNow();\n+                    }\n+                });\n+                scope1.join();\n+                return future1.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a rebound scoped value into a grandchild thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkInheritsScopedValue3(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Future<String> future1 = scope1.fork(() -> {\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+\n+                    \/\/ rebind name to \"y\"\n+                    String grandchildValue = ScopedValue.where(name, \"y\", () -> {\n+                        try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                            Future<String> future2 = scope2.fork(() -> {\n+                                return name.get(); \/\/ grandchild should read \"y\"\n+                            });\n+                            scope2.join();\n+                            return future2.resultNow();\n+                        }\n+                    });\n+\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+                    return grandchildValue;\n+                });\n+                scope1.join();\n+                return future1.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"y\");\n+    }\n+\n+    \/**\n+     * Test exiting a dynamic scope with an open task scope.\n+     *\/\n+    public void testStructureViolation1() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            StructuredTaskScope<Object> scope;\n+        }\n+        var box = new Box();\n+        try {\n+            try {\n+                ScopedValue.where(name, \"x\", () -> {\n+                    box.scope = new StructuredTaskScope<Object>();\n+                });\n+                fail();\n+            } catch (StructureViolationException expected) { }\n+\n+            \/\/ underlying flock should be closed, fork should return a cancelled task\n+            StructuredTaskScope<Object> scope = box.scope;\n+            AtomicBoolean ran = new AtomicBoolean();\n+            Future<Object> future = scope.fork(() -> {\n+                ran.set(true);\n+                return null;\n+            });\n+            assertTrue(future.isCancelled());\n+            scope.join();\n+            assertFalse(ran.get());\n+\n+        } finally {\n+            StructuredTaskScope<Object> scope = box.scope;\n+            if (scope != null) {\n+                scope.close();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a StructuredTaskScope while executing in a dynamic scope.\n+     *\/\n+    public void testStructureViolation2() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.where(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class, scope::close);\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is bound after a StructuredTaskScope is created.\n+     *\/\n+    public void testStructureViolation3() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.where(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class,\n+                        () -> scope.fork(() -> \"foo\"));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is re-bound after a StructuredTaskScope is created.\n+     *\/\n+    public void testStructureViolation4() throws Exception {\n+        ScopedValue<String> name1 = ScopedValue.newInstance();\n+        ScopedValue<String> name2 = ScopedValue.newInstance();\n+\n+        \/\/ rebind\n+        ScopedValue.where(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.where(name1, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+\n+        \/\/ new binding\n+        ScopedValue.where(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.where(name2, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ThreadFlock with scoped values\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules jdk.incubator.concurrent\n+ * @run testng WithScopedValue\n+ *\/\n+\n+import jdk.internal.misc.ThreadFlock;\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class WithScopedValue {\n+\n+    @DataProvider(name = \"factories\")\n+    public Object[][] factories() {\n+        var defaultThreadFactory = Executors.defaultThreadFactory();\n+        var virtualThreadFactory = Thread.ofVirtual().factory();\n+        return new Object[][]{\n+                { defaultThreadFactory, },\n+                { virtualThreadFactory, },\n+        };\n+    }\n+\n+    \/**\n+     * Test inheritance of a scoped value.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInheritsScopedValue(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"duke\", () -> {\n+            var result = new AtomicReference<String>();\n+            try (var flock = ThreadFlock.open(null)) {\n+                Thread thread = factory.newThread(() -> {\n+                    \/\/ child\n+                    result.set(name.get());\n+                });\n+                flock.start(thread);\n+            }\n+            return result.get();\n+        });\n+        assertEquals(value, \"duke\");\n+    }\n+\n+    \/**\n+     * Test exiting a dynamic scope with open thread flocks.\n+     *\/\n+    public void testStructureViolation1() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            ThreadFlock flock1;\n+            ThreadFlock flock2;\n+        }\n+        var box = new Box();\n+        try {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                box.flock1 = ThreadFlock.open(null);\n+                box.flock2 = ThreadFlock.open(null);\n+            });\n+            fail();\n+        } catch (StructureViolationException expected) { }\n+        assertTrue(box.flock1.isClosed());\n+        assertTrue(box.flock2.isClosed());\n+    }\n+\n+    \/**\n+     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n+     * flocks. This test closes enclosing flock1.\n+     *\/\n+    public void testStructureViolation2() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\", () -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\", () -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock1.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertTrue(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n+     * flocks. This test closes enclosing flock2.\n+     *\/\n+    public void testStructureViolation3() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\", () -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\", () -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock2.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n+     * flocks. This test closes enclosing flock3.\n+     *\/\n+    public void testStructureViolation4() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\", () -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\", () -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock3.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertFalse(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test start when a scoped value is bound after a thread flock is created.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testStructureViolation5(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock = ThreadFlock.open(null)) {\n+            ScopedValue.where(name, \"duke\", () -> {\n+                Thread thread = factory.newThread(() -> { });\n+                expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test start when a scoped value is re-bound after a thread flock is created.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testStructureViolation6(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        ScopedValue.where(name, \"duke\", () -> {\n+            try (var flock = ThreadFlock.open(null)) {\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    Thread thread = factory.newThread(() -> { });\n+                    expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/WithScopedValue.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.vm\n+ *          java.base\/jdk.internal.misc\n+ * @run testng\/othervm\n+ *      jdk.internal.vm.test.TestTranslatedException\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.VMSupport;\n+\n+public class TestTranslatedException {\n+    @SuppressWarnings(\"serial\")\n+    public static class Untranslatable extends RuntimeException {\n+        public Untranslatable(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void encodeDecodeTest() throws Exception {\n+        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n+        for (int i = 0; i < 10; i++) {\n+            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n+        }\n+        encodeDecode(throwable);\n+    }\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void encodeDecodeTest2() throws Exception {\n+        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n+        for (int i = 0; i < 10; i++) {\n+            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n+        }\n+        encodeDecode(throwable);\n+    }\n+\n+    private void encodeDecode(Throwable throwable) throws Exception {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        int bufferSize = 512;\n+        long buffer = 0L;\n+        while (true) {\n+            buffer = unsafe.allocateMemory(bufferSize);\n+            try {\n+                int res = VMSupport.encodeThrowable(throwable, buffer, bufferSize);\n+                if (res < 0) {\n+                    bufferSize = -res;\n+                } else {\n+                    try {\n+                        VMSupport.decodeAndThrowThrowable(buffer);\n+                        throw new AssertionError(\"expected decodeAndThrowThrowable to throw an exception\");\n+                    } catch (Throwable decoded) {\n+                        assertThrowableEquals(throwable, decoded);\n+                    }\n+                    return;\n+                }\n+            } finally {\n+                unsafe.freeMemory(buffer);\n+            }\n+        }\n+    }\n+\n+    private static void assertThrowableEquals(Throwable original, Throwable decoded) {\n+        try {\n+            Assert.assertEquals(original == null, decoded == null);\n+            while (original != null) {\n+                if (Untranslatable.class.equals(original.getClass())) {\n+                    Assert.assertEquals(decoded.getClass().getName(), \"jdk.internal.vm.TranslatedException\");\n+                    Assert.assertEquals(decoded.toString(), \"jdk.internal.vm.TranslatedException[jdk.internal.vm.test.TestTranslatedException$Untranslatable]: test exception\");\n+                    Assert.assertEquals(original.getMessage(), \"test exception\");\n+                } else {\n+                    Assert.assertEquals(decoded.getClass().getName(), original.getClass().getName());\n+                    Assert.assertEquals(decoded.getMessage(), original.getMessage());\n+                }\n+                StackTraceElement[] originalStack = original.getStackTrace();\n+                StackTraceElement[] decodedStack = decoded.getStackTrace();\n+                Assert.assertEquals(originalStack.length, decodedStack.length);\n+                for (int i = 0, n = originalStack.length; i < n; ++i) {\n+                    StackTraceElement originalStackElement = originalStack[i];\n+                    StackTraceElement decodedStackElement = decodedStack[i];\n+                    Assert.assertEquals(decodedStackElement.getClassLoaderName(), originalStackElement.getClassLoaderName());\n+                    Assert.assertEquals(decodedStackElement.getModuleName(), originalStackElement.getModuleName());\n+                    Assert.assertEquals(decodedStackElement.getClassName(), originalStackElement.getClassName());\n+                    Assert.assertEquals(decodedStackElement.getMethodName(), originalStackElement.getMethodName());\n+                    Assert.assertEquals(decodedStackElement.getFileName(), originalStackElement.getFileName());\n+                    Assert.assertEquals(decodedStackElement.getLineNumber(), originalStackElement.getLineNumber());\n+                }\n+                original = original.getCause();\n+                decoded = decoded.getCause();\n+            }\n+        } catch (AssertionError e) {\n+            System.err.println(\"original:[\");\n+            original.printStackTrace(System.err);\n+            System.err.println(\"]\");\n+            System.err.println(\"decoded:[\");\n+            original.printStackTrace(System.err);\n+            System.err.println(\"]\");\n+            throw e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/TestTranslatedException.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm jdk.jfr.api.consumer.recordingstream.TestClose\n+ * @run main\/othervm -Xlog:jfr+streaming+system=trace jdk.jfr.api.consumer.recordingstream.TestClose\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestClose.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+            Events.assertField(event, \"dynamicCompilerThreadCount\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCompilerConfig.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-            verifyValueDesscriptors(eventType.getFields(), types);\n+            verifyValueDescriptors(eventType.getFields(), types);\n@@ -119,1 +119,1 @@\n-    private static void verifyValueDesscriptors(List<ValueDescriptor> fields, Set<String> visitedTypes) {\n+    private static void verifyValueDescriptors(List<ValueDescriptor> fields, Set<String> visitedTypes) {\n@@ -123,1 +123,1 @@\n-                verifyValueDesscriptors(v.getFields(), visitedTypes);\n+                verifyValueDescriptors(v.getFields(), visitedTypes);\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestEventMetadata.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.opt.NativeMemoryTracking == null\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\n+ *          jdk.management\n+ * @run main\/othervm -XX:NativeMemoryTracking=summary -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents true\n+ * @run main\/othervm -XX:NativeMemoryTracking=off -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents false\n+ *\/\n+public class TestNativeMemoryUsageEvents {\n+    private final static String UsageTotalEvent = EventNames.NativeMemoryUsageTotal;\n+    private final static String UsageEvent = EventNames.NativeMemoryUsage;\n+\n+    private final static int UsagePeriod = 1000;\n+    private final static int K = 1024;\n+\n+    private final static String[] UsageEventTypes = {\n+        \"Java Heap\",\n+        \"Class\",\n+        \"Thread\",\n+        \"Thread Stack\",\n+        \"Code\",\n+        \"GC\",\n+        \"GCCardSet\",\n+        \"Compiler\",\n+        \"JVMCI\",\n+        \"Internal\",\n+        \"Other\",\n+        \"Symbol\",\n+        \"Native Memory Tracking\",\n+        \"Shared class space\",\n+        \"Arena Chunk\",\n+        \"Test\",\n+        \"Tracing\",\n+        \"Logging\",\n+        \"Statistics\",\n+        \"Arguments\",\n+        \"Module\",\n+        \"Safepoint\",\n+        \"Synchronization\",\n+        \"Serviceability\",\n+        \"Metaspace\",\n+        \"String Deduplication\",\n+        \"Object Monitors\"\n+    };\n+\n+    private static ArrayList<byte[]> data = new ArrayList<byte[]>();\n+\n+    private static void generateHeapContents() {\n+        for (int i = 0 ; i < 64; i++) {\n+            for (int j = 0; j < K; j++) {\n+                data.add(new byte[K]);\n+            }\n+        }\n+    }\n+\n+    private static void generateEvents(Recording recording) throws Exception {\n+        \/\/ Enable the two types of events for \"everyChunk\", it will give\n+        \/\/ an event at the beginning of the chunk as well as at the end.\n+        recording.enable(UsageEvent).with(\"period\", \"everyChunk\");\n+        recording.enable(UsageTotalEvent).with(\"period\", \"everyChunk\");\n+\n+        recording.start();\n+\n+        \/\/ Generate data to force heap to grow.\n+        generateHeapContents();\n+\n+        \/\/ To allow the two usage events to share a single NMTUsage snapshot\n+        \/\/ there is an AgeThreshold set to 50ms and if the two events occur\n+        \/\/ within this interval they will use the same snapshot. On fast\n+        \/\/ machines it is possible that the whole heap contents generation\n+        \/\/ take less than 50ms and therefor both beginChunk end endChunk\n+        \/\/ events will use the same NMTUsage snapshot. To avoid this, do\n+        \/\/ a short sleep.\n+        Thread.sleep(100);\n+\n+        recording.stop();\n+    }\n+\n+    private static void verifyExpectedEventTypes(List<RecordedEvent> events) throws Exception {\n+        \/\/ First verify that the number of total usage events is greater than 0.\n+        long numberOfTotal = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageTotalEvent))\n+                .count();\n+\n+        assertGreaterThan(numberOfTotal, 0L, \"Should exist events of type: \" + UsageTotalEvent);\n+\n+        \/\/ Now verify that we got the expected events.\n+        List<String> uniqueEventTypes = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .map(e -> e.getString(\"type\"))\n+                .distinct()\n+                .toList();\n+        for (String type : UsageEventTypes) {\n+            assertTrue(uniqueEventTypes.contains(type), \"Events should include: \" + type);\n+        }\n+    }\n+\n+    private static void verifyHeapGrowth(List<RecordedEvent> events) throws Exception {\n+        List<Long> javaHeapCommitted = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .filter(e -> e.getString(\"type\").equals(\"Java Heap\"))\n+                .map(e -> e.getLong(\"committed\"))\n+                .toList();\n+\n+        \/\/ Verify that the heap has grown between the first and last sample.\n+        long firstSample = javaHeapCommitted.get(0);\n+        long lastSample = javaHeapCommitted.get(javaHeapCommitted.size() - 1);\n+        assertGreaterThan(lastSample, firstSample, \"heap should have grown and NMT should show that\");\n+    }\n+\n+    private static void verifyNoUsageEvents(List<RecordedEvent> events) throws Exception {\n+        Events.hasNotEvent(events, UsageEvent);\n+        Events.hasNotEvent(events, UsageTotalEvent);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ The tests takes a single boolean argument that states wether or not\n+        \/\/ it is run with -XX:NativeMemoryTracking=summary. When tracking is\n+        \/\/ enabled the tests verifies that the correct events are sent and\n+        \/\/ the other way around when turned off.\n+        assertTrue(args.length == 1, \"Must have a single argument\");\n+        boolean nmtEnabled = Boolean.parseBoolean(args[0]);\n+\n+        try (Recording recording = new Recording()) {\n+            generateEvents(recording);\n+\n+            var events = Events.fromRecording(recording);\n+            if (nmtEnabled) {\n+                verifyExpectedEventTypes(events);\n+                verifyHeapGrowth(events);\n+            } else {\n+                verifyNoUsageEvents(events);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeMemoryUsageEvents.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -137,24 +137,0 @@\n-    @Test\n-    public void testCast() throws Throwable {\n-        Class<?>[] types = { Object.class, Serializable.class, String.class, Number.class, Integer.class };\n-        Object[] objects = { new Object(), Boolean.FALSE,      \"hello\",      (Long)12L,    (Integer)6    };\n-        for (Class<?> dst : types) {\n-            MethodHandle caster = ValueConversions.cast().bindTo(dst);\n-            assertEquals(caster.type(), MethodHandles.identity(Object.class).type());\n-            for (Object obj : objects) {\n-                Class<?> src = obj.getClass();\n-                boolean canCast = dst.isAssignableFrom(src);\n-                try {\n-                    Object result = caster.invokeExact(obj);\n-                    if (canCast)\n-                        assertEquals(obj, result);\n-                    else\n-                        assertEquals(\"cast should not have succeeded\", dst, obj);\n-                } catch (ClassCastException ex) {\n-                    if (canCast)\n-                        throw ex;\n-                }\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/sun\/invoke\/util\/ValueConversionsTest.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -183,4 +183,0 @@\n-    public static boolean isArmMac() {\n-        return (isOSX() && \"aarch64\".equals(System.getProperty(\"os.arch\")));\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-            .setExpectedExitCode(testPathArgs.contains(TEST_BAD) || TKit.isArmMac() ? 1 : 0)\n+            .setExpectedExitCode(testPathArgs.contains(TEST_BAD) || TKit.isOSX() ? 1 : 0)\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- *                                      RELEASE_18 RELEASE_19 RELEASE_20\n+ *                                      RELEASE_18 RELEASE_19 RELEASE_20 RELEASE_21\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetSourceVersions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-        TWENTY(\"20\", 64);\n+        TWENTY(\"20\", 64),\n+        TWENTY_ONE(\"21\", 65);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/ClassVersionChecker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -126,1 +126,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -136,1 +136,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -146,1 +146,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -167,1 +167,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -186,1 +186,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -207,1 +207,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -228,1 +228,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -249,1 +249,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8154283 8167320 8171098 8172809 8173068 8173117 8176045 8177311 8241519\n+ * @bug 8154283 8167320 8171098 8172809 8173068 8173117 8176045 8177311 8241519 8297988\n@@ -42,0 +42,1 @@\n+import java.nio.file.FileSystems;\n@@ -68,0 +69,2 @@\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n@@ -72,0 +75,1 @@\n+import java.util.ArrayList;\n@@ -1050,0 +1054,102 @@\n+    @Test \/\/JDK-8297988\n+    public void testExportedNameCheckFromSourceNoEvent(Path base) throws Exception {\n+        \/\/when validating \"exports\", javac may parse source(s) from the package to check their\n+        \/\/package name. The AST produced by this parse are thrown away, so listeners should not\n+        \/\/be notified:\n+        Path src = base.resolve(\"src\");\n+        Path m = src.resolve(\"m\");\n+        tb.writeJavaFiles(m,\n+                          \"\"\"\n+                          module m {\n+                              exports test;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public class Test {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package impl;\n+                          public class Impl {\n+                              void t() {\n+                                  test.Test t;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        record TestCase(Path[] files, String... expectedLog){}\n+        String nameSeparator = FileSystems.getDefault().getSeparator();\n+\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(new Path[] {m.resolve(\"module-info.java\")},\n+                         \"COMPILATION:started:<none>\",\n+                         \"PARSE:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"PARSE:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"ENTER:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"ENTER:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"ANALYZE:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"ANALYZE:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"COMPILATION:finished:<none>\"),\n+            new TestCase(new Path[] {m.resolve(\"module-info.java\"),\n+                                     m.resolve(\"impl\").resolve(\"Impl.java\")},\n+                         \"COMPILATION:started:<none>\",\n+                         \"PARSE:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"PARSE:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"PARSE:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/impl\/Impl.java\",\n+                         \"PARSE:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/impl\/Impl.java\",\n+                         \"ENTER:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"ENTER:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/impl\/Impl.java\",\n+                         \"ENTER:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"ENTER:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/impl\/Impl.java\",\n+                         \"ANALYZE:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"ANALYZE:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/module-info.java\",\n+                         \"ANALYZE:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/impl\/Impl.java\",\n+                         \"PARSE:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/test\/Test.java\",\n+                         \"PARSE:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/test\/Test.java\",\n+                         \"ENTER:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/test\/Test.java\",\n+                         \"ENTER:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/test\/Test.java\",\n+                         \"ANALYZE:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/impl\/Impl.java\",\n+                         \"ANALYZE:started:testExportedNameCheckFromSourceNoEvent\/src\/m\/test\/Test.java\",\n+                         \"ANALYZE:finished:testExportedNameCheckFromSourceNoEvent\/src\/m\/test\/Test.java\",\n+                         \"COMPILATION:finished:<none>\")\n+        };\n+\n+        for (TestCase tc : testCases) {\n+            List<String> log = new ArrayList<>();\n+\n+            new JavacTask(tb)\n+                    .outdir(classes)\n+                    .options(\"--source-path\", m.toString(),\n+                             \"-XDshould-stop.ifNoError=FLOW\")\n+                    .callback(task -> {\n+                        task.addTaskListener(new TaskListener() {\n+                            @Override\n+                            public void started(TaskEvent e) {\n+                                record(e, \"started\");\n+                            }\n+                            @Override\n+                            public void finished(TaskEvent e) {\n+                                record(e, \"finished\");\n+                            }\n+                            private void record(TaskEvent e, String phase) {\n+                                JavaFileObject source = e.getSourceFile();\n+                                String sourceName = source != null ? source.getName()\n+                                                                           .replace(nameSeparator, \"\/\")\n+                                                                   : \"<none>\";\n+                                log.add(e.getKind() + \":\" + phase + \":\" + sourceName);\n+                            }\n+                        });\n+                    })\n+                    .files(tc.files)\n+                    .run()\n+                    .writeAll();\n+\n+            if (!List.of(tc.expectedLog).equals(log)) {\n+                throw new AssertionError(\"Unexpected log, got: \" + log +\n+                                         \", expected: \" + List.of(tc.expectedLog));\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/modules\/EdgeCases.java","additions":107,"deletions":1,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8298184\n@@ -27,0 +28,2 @@\n+ * @compile GenericRecordDeconstructionPattern.java\n+ * @run main GenericRecordDeconstructionPattern\n@@ -49,0 +52,2 @@\n+        assertEquals(1, runIfSuperBound(new Box<>(new StringBuilder())));\n+        assertEquals(1, runIfSuperBound(new Box<>(0)));\n@@ -123,0 +128,5 @@\n+    int runIfSuperBound(I<? super String> b) {\n+        if (b instanceof Box(var v)) return 1;\n+        return -1;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.err.preview.feature.disabled.classfile: Bar.class, 20\n+- compiler.err.preview.feature.disabled.classfile: Bar.class, 21\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.nopreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.preview.feature.use.classfile: Bar.class, 20\n+- compiler.warn.preview.feature.use.classfile: Bar.class, 21\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.preview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-               \"15\", \"16\", \"17\", \"18\", \"19\", \"20\");\n+               \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\");\n@@ -76,1 +76,1 @@\n-    public static final String LATEST_MAJOR_VERSION = \"64.0\";\n+    public static final String LATEST_MAJOR_VERSION = \"65.0\";\n@@ -79,9 +79,9 @@\n-        EIGHT(true,   \"52.0\",  \"8\", Versions::checksrc8),\n-        NINE(true,    \"53.0\",  \"9\", Versions::checksrc9),\n-        TEN(true,     \"54.0\", \"10\", Versions::checksrc10),\n-        ELEVEN(false, \"55.0\", \"11\", Versions::checksrc11),\n-        TWELVE(false, \"56.0\", \"12\", Versions::checksrc12),\n-        THIRTEEN(false, \"57.0\", \"13\", Versions::checksrc13),\n-        FOURTEEN(false, \"58.0\", \"14\", Versions::checksrc14),\n-        FIFTEEN(false,  \"59.0\", \"15\", Versions::checksrc15),\n-        SIXTEEN(false,  \"60.0\", \"16\", Versions::checksrc16),\n+        EIGHT(true,      \"52.0\",  \"8\", Versions::checksrc8),\n+        NINE(true,       \"53.0\",  \"9\", Versions::checksrc9),\n+        TEN(true,        \"54.0\", \"10\", Versions::checksrc10),\n+        ELEVEN(false,    \"55.0\", \"11\", Versions::checksrc11),\n+        TWELVE(false,    \"56.0\", \"12\", Versions::checksrc12),\n+        THIRTEEN(false,  \"57.0\", \"13\", Versions::checksrc13),\n+        FOURTEEN(false,  \"58.0\", \"14\", Versions::checksrc14),\n+        FIFTEEN(false,   \"59.0\", \"15\", Versions::checksrc15),\n+        SIXTEEN(false,   \"60.0\", \"16\", Versions::checksrc16),\n@@ -91,1 +91,2 @@\n-        TWENTY(false,  \"64.0\", \"20\", Versions::checksrc20);\n+        TWENTY(false,    \"64.0\", \"20\", Versions::checksrc20),\n+        TWENTY_ONE(false,\"65.0\", \"21\", Versions::checksrc20);\n","filename":"test\/langtools\/tools\/javac\/versions\/Versions.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -296,0 +296,4 @@\n+                hardenedStatusConfirmed = true;\n+                isHardened = false;\n+                System.out.println(\"Target JDK is adhoc linker-signed, but not hardened.\");\n+            } else if (line.indexOf(\"flags=0x2(adhoc)\") != -1 ) {\n","filename":"test\/lib\/jdk\/test\/lib\/Platform.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+    public static final String NativeMemoryUsage = PREFIX + \"NativeMemoryUsage\";\n+    public static final String NativeMemoryUsageTotal = PREFIX + \"NativeMemoryUsageTotal\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2022, red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesData.*;\n+\n+\/**\n+ * Tests ScopedValue\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations=4, time=1)\n+@Measurement(iterations=10, time=1)\n+@Threads(1)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesExecutorService\",\n+                        \"-Djmh.executor=CUSTOM\",\n+                        \"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--add-modules=jdk.incubator.concurrent\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class ScopedValues {\n+\n+    private static final Integer THE_ANSWER = 42;\n+\n+    \/\/ Test 1: make sure ScopedValue.get() is hoisted out of loops.\n+\n+    @Benchmark\n+    public void thousandAdds_ScopedValue(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.sl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    @Benchmark\n+    public void thousandAdds_ThreadLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.tl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandIsBoundQueries(Blackhole bh) throws Exception {\n+        var result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.sl1.isBound() ? 1 : 0;\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandMaybeGets(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            if (ScopedValuesData.sl1.isBound()) {\n+                result += ScopedValuesData.sl1.get();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Test 2: stress the ScopedValue cache.\n+    \/\/ The idea here is to use a bunch of bound values cyclically, which\n+    \/\/ stresses the ScopedValue cache.\n+\n+    int combine(int n, int i1, int i2, int i3, int i4, int i5, int i6) {\n+        return n + ((i1 ^ i2 >>> 6) + (i3 << 7) + i4 - i5 | i6);\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ScopedValue() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, sl1.get(), sl2.get(), sl3.get(), sl4.get(), sl5.get(), sl6.get());\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ThreadLocal() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Test 3: The cost of bind, then get\n+    \/\/ This is the worst case for ScopedValues because we have to create\n+    \/\/ a binding, link it in, then search the current bindings. In addition, we\n+    \/\/ create a cache entry for the bound value, then we immediately have to\n+    \/\/ destroy it.\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int CreateBindThenGetThenRemove_ScopedValue() throws Exception {\n+        return ScopedValue.where(sl1, THE_ANSWER).call(sl1::get);\n+    }\n+\n+\n+    \/\/ Create a Carrier ahead of time: might be slightly faster\n+    private static final ScopedValue.Carrier HOLD_42 = ScopedValue.where(sl1, 42);\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ScopedValue() throws Exception {\n+        return HOLD_42.call(sl1::get);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return tl1.get();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+        return tl1.get();\n+    }\n+\n+    \/\/ Test 4: The cost of binding, but not using any result\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ScopedValue() throws Exception {\n+        return HOLD_42.call(this::getClass);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return this.getClass();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ Simply set a ThreadLocal so that the caller can see it\n+    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+    }\n+\n+    \/\/ This is the closest I can think of to setNoRemove_ThreadLocal in that it\n+    \/\/ returns a value in a ScopedValue container. The container must already\n+    \/\/ be bound to an AtomicReference for this to work.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ScopedValue() throws Exception {\n+        sl_atomicRef.get().setPlain(THE_ANSWER);\n+    }\n+\n+    \/\/ Test 5: A simple counter\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ScopedValue() {\n+        sl_atomicInt.get().setPlain(\n+                sl_atomicInt.get().getPlain() + 1);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ThreadLocal() {\n+        \/\/ Very slow:\n+        \/\/ tl1.set(tl1.get() + 1);\n+        var ctr = tl_atomicInt.get();\n+        ctr.setPlain(ctr.getPlain() + 1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValues.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+@SuppressWarnings(\"preview\")\n+public class ScopedValuesData {\n+\n+    static final ScopedValue<Integer> sl1 = ScopedValue.newInstance();\n+    static final ThreadLocal<Integer> tl1 = new ThreadLocal<>();\n+\n+    static final ScopedValue<Integer> sl2 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl3 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl4 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl5 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl6 = ScopedValue.newInstance();\n+    static final ScopedValue<AtomicInteger> sl_atomicInt = ScopedValue.newInstance();\n+\n+    static final ScopedValue<Integer> unbound = ScopedValue.newInstance();\n+\n+    static final ScopedValue<AtomicReference<Integer>> sl_atomicRef = ScopedValue.newInstance();\n+\n+    static final ThreadLocal<Integer> tl2 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl3 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl4 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl5 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl6 = new ThreadLocal<>();\n+    static final ThreadLocal<AtomicInteger> tl_atomicInt = new ThreadLocal<>();\n+\n+    static final ScopedValue.Carrier VALUES = ScopedValue\n+            .where(sl1, 42).where(sl2, 2).where(sl3, 3)\n+            .where(sl4, 4).where(sl5, 5).where(sl6, 6);\n+\n+    public static void run(Runnable action) {\n+        try {\n+            tl1.set(42); tl2.set(2); tl3.set(3); tl4.set(4); tl5.set(5); tl6.set(6);\n+            tl1.get();  \/\/ Create the ScopedValue cache as a side effect\n+            tl_atomicInt.set(new AtomicInteger());\n+            VALUES.where(sl_atomicInt, new AtomicInteger())\n+                  .where(sl_atomicRef, new AtomicReference<>())\n+                  .run(action);\n+        } finally {\n+            tl1.remove(); tl2.remove(); tl3.remove(); tl4.remove(); tl5.remove(); tl6.remove();\n+            tl_atomicInt.remove();\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesData.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import java.util.concurrent.*;\n+\n+public class ScopedValuesExecutorService extends ThreadPoolExecutor {\n+    public ScopedValuesExecutorService(int corePoolSize, String prefix) {\n+        super(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),\n+              new AThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n+    }\n+}\n+\n+class AThreadFactory implements ThreadFactory {\n+    public Thread newThread(Runnable action) {\n+        return new Thread() {\n+            public void run() {\n+                ScopedValuesData.run(action);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesExecutorService.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}