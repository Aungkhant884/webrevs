{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit\/othervm SelectWhenRefused\n@@ -34,0 +35,5 @@\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n@@ -36,0 +42,2 @@\n+    static final int MAX_TRIES = 3;\n+    static final String GREETINGS_MESSAGE = \"Greetings from SelectWhenRefused!\";\n@@ -37,1 +45,2 @@\n-    public static void main(String[] args) throws IOException {\n+    @Test\n+    public void test() throws IOException {\n@@ -53,8 +62,5 @@\n-            sendDatagram(dc, refuser);\n-            int n = sel.select(2000);\n-            if (n > 0) {\n-                sel.selectedKeys().clear();\n-                \/\/ BindException will be thrown if another service is using\n-                \/\/ our expected refuser port, cannot run just exit.\n-                DatagramChannel.open().bind(refuser).close();\n-                throw new RuntimeException(\"Unexpected wakeup\");\n+            for (int i = 1; i <= MAX_TRIES; i++) {\n+                if (testNoPUEBeforeConnection(dc, refuser, sel, i)) {\n+                    break; \/\/ test succeeded\n+                }\n+                assertNotEquals(i, MAX_TRIES, \"testNoPUEBeforeConnection: too many retries\");\n@@ -66,9 +72,3 @@\n-                sendDatagram(dc, refuser);\n-                n = sel.select(2000);\n-                if (n > 0) {\n-                    sel.selectedKeys().clear();\n-                    try {\n-                        n = dc.read(ByteBuffer.allocate(100));\n-                        throw new RuntimeException(\"Unexpected datagram received\");\n-                    } catch (PortUnreachableException pue) {\n-                        \/\/ expected\n+                for (int i = 1; i <= MAX_TRIES; i++) {\n+                    if (testPUEOnConnect(dc, refuser, sel, i)) {\n+                        break; \/\/ test passed\n@@ -76,0 +76,1 @@\n+                    assertNotEquals(i, MAX_TRIES, \"testPUEOnConnect: too many retries\");\n@@ -82,4 +83,5 @@\n-            sendDatagram(dc, refuser);\n-            n = sel.select(2000);\n-            if (n > 0) {\n-                throw new RuntimeException(\"Unexpected wakeup after disconnect\");\n+            for (int i = 1; i <= MAX_TRIES; i++) {\n+                if (testNoPUEAfterDisconnect(dc, refuser, sel, i)) {\n+                    break; \/\/ test passed\n+                }\n+                assertNotEquals(i, MAX_TRIES, \"testNoPUEAfterDisconnect: too many retries\");\n@@ -87,2 +89,1 @@\n-\n-        } catch(BindException e) {\n+        } catch (BindException e) {\n@@ -90,0 +91,1 @@\n+            System.out.println(\"Skipping test: refuser port has been reused: \" + e);\n@@ -96,0 +98,107 @@\n+    \/*\n+     * Send a datagram to non existent unconnected UDP end point\n+     * This shouldn't result in an PortUnreachableException\n+     * Handle unexpected read events on the senders DC with\n+     * retry when message received is external and Throw Exception\n+     * on receipt of own message\n+     *\/\n+    static boolean testNoPUEBeforeConnection(DatagramChannel dc,\n+                                             SocketAddress refuser,\n+                                             Selector sel,\n+                                             int retryCount) throws IOException {\n+        sendDatagram(dc, refuser);\n+        int n = sel.select(2000);\n+        if (n > 0) {\n+            boolean mayRetry = checkUnexpectedWakeup(sel.selectedKeys());\n+            boolean tooManyRetries = retryCount >= MAX_TRIES;\n+            sel.selectedKeys().clear();\n+\n+            if (mayRetry && !tooManyRetries) {\n+                return false; \/\/ will retry\n+            }\n+\n+            \/\/ BindException will be thrown if another service is using\n+            \/\/ our expected refuser port, cannot run just exit.\n+            DatagramChannel.open().bind(refuser).close();\n+            throw new RuntimeException(\"Unexpected wakeup\");\n+        }\n+        return true; \/\/ test passed\n+    }\n+\n+    \/*\n+     * Send a datagram to a connected UDP end point\n+     * This should result in an PortUnreachableException\n+     * Handle unexpected read events on the senders DC with\n+     * retry when message received is external and Throw Exception\n+     * on receipt of own message\n+     *\/\n+    static boolean testPUEOnConnect(DatagramChannel dc,\n+                                    SocketAddress refuser,\n+                                    Selector sel,\n+                                    int retryCount) throws IOException {\n+        sendDatagram(dc, refuser);\n+        int n = sel.select(2000);\n+        if (n > 0) {\n+            sel.selectedKeys().clear();\n+\n+            try {\n+                \/\/ Attempt to read from Selected Key\n+                ByteBuffer buf = ByteBuffer.allocate(100);\n+                SocketAddress sa = dc.receive(buf);\n+\n+                if (sa != null) {\n+                    buf.flip();\n+                    byte[] bytes = new byte[buf.remaining()];\n+                    buf.get(bytes);\n+                    String message = new String(bytes);\n+                    System.out.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n+\n+                    \/\/ If any received data contains the message from sendDatagram then throw exception\n+                    if (message.contains(GREETINGS_MESSAGE)) {\n+                        throw new RuntimeException(\"Unexpected datagram received\");\n+                    }\n+                }\n+\n+                boolean mayRetry = retryCount < MAX_TRIES;\n+                if (mayRetry) {\n+                    return false; \/\/ will retry\n+                }\n+\n+                \/\/ BindException will be thrown if another service is using\n+                \/\/ our expected refuser port, cannot run just exit.\n+                DatagramChannel.open().bind(refuser).close();\n+                throw new RuntimeException(\"PortUnreachableException not raised\");\n+            } catch (PortUnreachableException pue) {\n+                System.out.println(\"Got expected PortUnreachableException \" + pue);\n+            }\n+        }\n+        return true; \/\/ test passed\n+    }\n+\n+    \/*\n+     * Send a datagram to a disconnected UDP end point\n+     * This should result in an PortUnreachableException\n+     * Handle unexpected read events on the senders DC with\n+     * retry when message received is external and Throw Exception\n+     * on receipt of own message\n+     *\/\n+    static boolean testNoPUEAfterDisconnect(DatagramChannel dc,\n+                                            SocketAddress refuser,\n+                                            Selector sel,\n+                                            int retryCount) throws IOException {\n+        sendDatagram(dc, refuser);\n+        int n = sel.select(2000);\n+        if (n > 0) {\n+            boolean mayRetry = checkUnexpectedWakeup(sel.selectedKeys());\n+            boolean tooManyRetries = retryCount >= MAX_TRIES;\n+            sel.selectedKeys().clear();\n+\n+            if (mayRetry && !tooManyRetries) {\n+                return false; \/\/ will retry\n+            }\n+\n+            throw new RuntimeException(\"Unexpected wakeup after disconnect\");\n+        }\n+        return true; \/\/ test passed\n+    }\n+\n@@ -97,3 +206,2 @@\n-        throws IOException\n-    {\n-        ByteBuffer bb = ByteBuffer.wrap(\"Greetings!\".getBytes());\n+            throws IOException {\n+        ByteBuffer bb = ByteBuffer.wrap(GREETINGS_MESSAGE.getBytes());\n@@ -102,0 +210,41 @@\n+\n+    \/*\n+     * Attempt to read and Log the data from SelectedKeys,\n+     * If a message can be received, and it came from\n+     * another test return True\n+     *\n+     *\/\n+    static boolean checkUnexpectedWakeup(Set<SelectionKey> selectedKeys) {\n+        System.out.format(\"Received %d keys%n\", selectedKeys.size());\n+\n+        for (SelectionKey key : selectedKeys) {\n+            if (!key.isValid() || !key.isReadable()) {\n+                System.out.println(\"Invalid or unreadable key: \" + key);\n+                continue;\n+            }\n+\n+            try {\n+                System.out.println(\"Attempting to read datagram from key: \" + key);\n+                DatagramChannel datagramChannel = (DatagramChannel) key.channel();\n+                ByteBuffer buf = ByteBuffer.allocate(100);\n+                SocketAddress sa = datagramChannel.receive(buf);\n+\n+                if (sa != null) {\n+                    buf.flip();\n+                    byte[] bytes = new byte[buf.remaining()];\n+                    buf.get(bytes);\n+                    String message = new String(bytes);\n+                    System.out.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n+\n+                    \/\/ If any received data contains the message from sendDatagram then return false\n+                    if (message.contains(GREETINGS_MESSAGE)) {\n+                        return false;\n+                    }\n+                }\n+\n+            } catch (IOException io) {\n+                System.out.println(\"Unable to read from datagram \" + io);\n+            }\n+        }\n+        return true;\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SelectWhenRefused.java","additions":177,"deletions":28,"binary":false,"changes":205,"status":"modified"}]}