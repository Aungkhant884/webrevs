{"files":[{"patch":"@@ -1605,0 +1605,8 @@\n+C2V_VMENTRY_0(int, decodeFieldIndexToCPIndex, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint field_index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  if (field_index < 0 || field_index >= cp->resolved_field_entries_length()) {\n+    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"invalid field index %d\", field_index));\n+  }\n+  return cp->resolved_field_entry_at(field_index)->constant_pool_index();\n+C2V_END\n+\n@@ -3128,0 +3136,1 @@\n+  {CC \"decodeFieldIndexToCPIndex\",                    CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(decodeFieldIndexToCPIndex)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -406,0 +406,13 @@\n+    \/**\n+     * Converts the {@code rawIndex} operand of a rewritten getfield\/putfield\/getstatic\/putstatic instruction\n+     * to an index directly into {@code constantPool}.\n+     *\n+     * @throws IllegalArgumentException if {@code rawIndex} is out of range.\n+     * @return {@code JVM_CONSTANT_FieldRef} constant pool entry index for the invokedynamic\n+     *\/\n+    int decodeFieldIndexToCPIndex(HotSpotConstantPool constantPool, int rawIndex) {\n+        return decodeFieldIndexToCPIndex(constantPool, constantPool.getConstantPoolPointer(), rawIndex);\n+    }\n+\n+    private native int decodeFieldIndexToCPIndex(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex);\n+\n@@ -478,2 +491,2 @@\n-     * Looks up and attempts to resolve the {@code JVM_CONSTANT_Field} entry for at index\n-     * {@code cpi} in {@code constantPool}. For some opcodes, checks are performed that require the\n+     * Looks up and attempts to resolve the {@code JVM_CONSTANT_Field} entry denoted by\n+     * {@code rawIndex}. For some opcodes, checks are performed that require the\n@@ -491,2 +504,1 @@\n-     * The behavior of this method is undefined if {@code cpi} does not denote a\n-     * {@code JVM_CONSTANT_Field} entry.\n+     * The behavior of this method is undefined if {@code rawIndex} is invalid.\n@@ -497,1 +509,1 @@\n-    HotSpotResolvedObjectTypeImpl resolveFieldInPool(HotSpotConstantPool constantPool, int cpi, HotSpotResolvedJavaMethodImpl method, byte opcode, int[] info) {\n+    HotSpotResolvedObjectTypeImpl resolveFieldInPool(HotSpotConstantPool constantPool, int rawIndex, HotSpotResolvedJavaMethodImpl method, byte opcode, int[] info) {\n@@ -499,1 +511,1 @@\n-        return resolveFieldInPool(constantPool, constantPool.getConstantPoolPointer(), cpi, method, methodPointer, opcode, info);\n+        return resolveFieldInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, method, methodPointer, opcode, info);\n@@ -503,1 +515,1 @@\n-                    int cpi, HotSpotResolvedJavaMethodImpl method, long methodPointer, byte opcode, int[] info);\n+                    int rawIndex, HotSpotResolvedJavaMethodImpl method, long methodPointer, byte opcode, int[] info);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -263,8 +263,4 @@\n-            if (opcode == Bytecodes.GETFIELD ||\n-                            opcode == Bytecodes.PUTFIELD ||\n-                            opcode == Bytecodes.GETSTATIC ||\n-                            opcode == Bytecodes.PUTSTATIC ||\n-                            opcode == Bytecodes.INVOKEINTERFACE ||\n-                            opcode == Bytecodes.INVOKEVIRTUAL ||\n-                            opcode == Bytecodes.INVOKESPECIAL ||\n-                            opcode == Bytecodes.INVOKESTATIC) {\n+            if (opcode == Bytecodes.INVOKEINTERFACE ||\n+                opcode == Bytecodes.INVOKEVIRTUAL ||\n+                opcode == Bytecodes.INVOKESPECIAL ||\n+                opcode == Bytecodes.INVOKESTATIC) {\n@@ -751,2 +747,2 @@\n-    public JavaType lookupReferencedType(int cpi, int opcode) {\n-        int index;\n+    public JavaType lookupReferencedType(int rawIndex, int opcode) {\n+        int cpi;\n@@ -762,1 +758,1 @@\n-                index = cpi;\n+                cpi = rawIndex;\n@@ -768,0 +764,2 @@\n+                cpi = getKlassRefIndexAt(rawIndex, opcode);\n+                break;\n@@ -772,2 +770,2 @@\n-                index = rawIndexToConstantPoolCacheIndex(cpi, opcode);\n-                index = getKlassRefIndexAt(index, opcode);\n+                int cpci = rawIndexToConstantPoolCacheIndex(rawIndex, opcode);\n+                cpi = getKlassRefIndexAt(cpci, opcode);\n@@ -779,1 +777,1 @@\n-        final Object type = compilerToVM().lookupKlassInPool(this, index);\n+        final Object type = compilerToVM().lookupKlassInPool(this, cpi);\n@@ -784,3 +782,3 @@\n-    public JavaField lookupField(int cpi, ResolvedJavaMethod method, int opcode) {\n-        final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);\n-        final int nameAndTypeIndex = getNameAndTypeRefIndexAt(index, opcode);\n+    public JavaField lookupField(int rawIndex, ResolvedJavaMethod method, int opcode) {\n+        final int cpi = compilerToVM().decodeFieldIndexToCPIndex(this, rawIndex);\n+        final int nameAndTypeIndex = getNameAndTypeRefIndexAt(rawIndex, opcode);\n@@ -791,1 +789,1 @@\n-        final int holderIndex = getKlassRefIndexAt(index, opcode);\n+        final int holderIndex = getKlassRefIndexAt(rawIndex, opcode);\n@@ -798,1 +796,1 @@\n-                resolvedHolder = compilerToVM().resolveFieldInPool(this, index, (HotSpotResolvedJavaMethodImpl) method, (byte) opcode, info);\n+                resolvedHolder = compilerToVM().resolveFieldInPool(this, rawIndex, (HotSpotResolvedJavaMethodImpl) method, (byte) opcode, info);\n@@ -836,0 +834,6 @@\n+        if (opcode == Bytecodes.GETSTATIC ||\n+            opcode == Bytecodes.PUTSTATIC ||\n+            opcode == Bytecodes.GETFIELD ||\n+            opcode == Bytecodes.PUTFIELD) {\n+            return compilerToVM().decodeFieldIndexToCPIndex(this, rawIndex);\n+        }\n@@ -841,2 +845,2 @@\n-    public void loadReferencedType(int cpi, int opcode) {\n-        loadReferencedType(cpi, opcode, true \/* initialize *\/);\n+    public void loadReferencedType(int rawIndex, int opcode) {\n+        loadReferencedType(rawIndex, opcode, true \/* initialize *\/);\n@@ -847,2 +851,2 @@\n-    public void loadReferencedType(int cpi, int opcode, boolean initialize) {\n-        int index;\n+    public void loadReferencedType(int rawIndex, int opcode, boolean initialize) {\n+        int cpi;\n@@ -858,1 +862,1 @@\n-                index = cpi;\n+                cpi = rawIndex;\n@@ -862,2 +866,2 @@\n-                if (!isInvokedynamicIndex(cpi)) {\n-                    throw new IllegalArgumentException(\"must use invokedynamic index but got \" + cpi);\n+                if (!isInvokedynamicIndex(rawIndex)) {\n+                    throw new IllegalArgumentException(\"must use invokedynamic index but got \" + rawIndex);\n@@ -865,1 +869,1 @@\n-                index = compilerToVM().decodeIndyIndexToCPIndex(this, cpi, true);\n+                cpi = compilerToVM().decodeIndyIndexToCPIndex(this, rawIndex, true);\n@@ -872,0 +876,2 @@\n+                cpi = compilerToVM().decodeFieldIndexToCPIndex(this, rawIndex);\n+                break;\n@@ -877,2 +883,2 @@\n-                index = rawIndexToConstantPoolCacheIndex(cpi, opcode);\n-                index = compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);\n+                int cpci = rawIndexToConstantPoolCacheIndex(rawIndex, opcode);\n+                cpi = compilerToVM().constantPoolRemapInstructionOperandFromCache(this, cpci);\n@@ -885,1 +891,1 @@\n-        final JvmConstant tag = getTagAt(index);\n+        final JvmConstant tag = getTagAt(cpi);\n@@ -887,1 +893,1 @@\n-            assert getTagAt(index - 1) == constants.jvmDouble || getTagAt(index - 1) == constants.jvmLong;\n+            assert getTagAt(cpi - 1) == constants.jvmDouble || getTagAt(cpi - 1) == constants.jvmLong;\n@@ -894,1 +900,1 @@\n-                index = getUncachedKlassRefIndexAt(index);\n+                cpi = getUncachedKlassRefIndexAt(cpi);\n@@ -896,1 +902,1 @@\n-                final JvmConstant klassTag = getTagAt(index);\n+                final JvmConstant klassTag = getTagAt(cpi);\n@@ -902,1 +908,1 @@\n-                final HotSpotResolvedObjectTypeImpl type = compilerToVM().resolveTypeInPool(this, index);\n+                final HotSpotResolvedObjectTypeImpl type = compilerToVM().resolveTypeInPool(this, cpi);\n@@ -908,1 +914,1 @@\n-                        final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);\n+                        final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(rawIndex, opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":41,"deletions":35,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,8 @@\n+ *\n+ * The following convention is used when accessing the ConstantPool with an index:\n+ * <ul>\n+ * <li>rawIndex - index in the bytecode stream after the opcode (could be rewritten for some opcodes)<\/li>\n+ * <li>cpi - the constant pool index (as specified in JVM Spec)<\/li>\n+ * <\/ul>\n+ *\n+ * Some of the methods are currently not using the convention correctly. That will be addressed in JDK-8314172.\n@@ -47,1 +55,1 @@\n-     * @param cpi the index of the constant pool entry that references the type\n+     * @param rawIndex index in the bytecode stream after the {@code opcode} (could be rewritten for some opcodes)\n@@ -50,1 +58,1 @@\n-    void loadReferencedType(int cpi, int opcode);\n+    void loadReferencedType(int rawIndex, int opcode);\n@@ -57,1 +65,1 @@\n-     * @param cpi the index of the constant pool entry that references the type\n+     * @param rawIndex index in the bytecode stream after the {@code opcode} (could be rewritten for some opcodes)\n@@ -62,1 +70,1 @@\n-    default void loadReferencedType(int cpi, int opcode, boolean initialize) {\n+    default void loadReferencedType(int rawIndex, int opcode, boolean initialize) {\n@@ -64,1 +72,1 @@\n-            loadReferencedType(cpi, opcode);\n+            loadReferencedType(rawIndex, opcode);\n@@ -71,2 +79,1 @@\n-     * Looks up the type referenced by the constant pool entry at {@code cpi} as referenced by the\n-     * {@code opcode} bytecode instruction.\n+     * Looks up the type referenced by the {@code rawIndex}.\n@@ -74,2 +81,2 @@\n-     * @param cpi the index of a constant pool entry that references a type\n-     * @param opcode the opcode of the instruction with {@code cpi} as an operand\n+     * @param rawIndex index in the bytecode stream after the {@code opcode} (could be rewritten for some opcodes)\n+     * @param opcode the opcode of the instruction with {@code rawIndex} as an operand\n@@ -78,1 +85,1 @@\n-    JavaType lookupReferencedType(int cpi, int opcode);\n+    JavaType lookupReferencedType(int rawIndex, int opcode);\n@@ -81,1 +88,1 @@\n-     * Looks up a reference to a field. If {@code opcode} is non-negative, then resolution checks\n+     * Looks up a reference to a field. Resolution checks\n@@ -86,3 +93,2 @@\n-     * @param cpi the constant pool index\n-     * @param opcode the opcode of the instruction for which the lookup is being performed or\n-     *            {@code -1}\n+     * @param rawIndex rewritten index in the bytecode stream after the {@code opcode}\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -90,2 +96,1 @@\n-     * @return a reference to the field at {@code cpi} in this pool\n-     * @throws ClassFormatError if the entry at {@code cpi} is not a field\n+     * @return a reference to the field at {@code rawIndex} in this pool\n@@ -93,1 +98,1 @@\n-    JavaField lookupField(int cpi, ResolvedJavaMethod method, int opcode);\n+    JavaField lookupField(int rawIndex, ResolvedJavaMethod method, int opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ConstantPool.java","additions":23,"deletions":18,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.vm.ci.meta.JavaField;\n@@ -47,0 +48,1 @@\n+import jdk.vm.ci.meta.Signature;\n@@ -84,0 +86,1 @@\n+    public static final int GETSTATIC = 178; \/\/ 0xB2\n@@ -111,0 +114,27 @@\n+\n+    static int someStaticField = 1;\n+    static int getStaticField() {\n+        return someStaticField;\n+    }\n+\n+    @Test\n+    public void lookupFieldTest() throws Exception {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        ResolvedJavaType type = metaAccess.lookupJavaType(ConstantPoolTest.class);\n+\n+        String methodName = \"getStaticField\";\n+        Signature methodSig = metaAccess.parseMethodDescriptor(\"()I\");\n+        ResolvedJavaMethod m = type.findMethod(methodName, methodSig);\n+        Assert.assertNotNull(m);\n+\n+        \/\/ Expected:\n+        \/\/ 0: getstatic \"someStaticField\":\"I\";\n+        \/\/ 3: ireturn;\n+        byte[] bytecode = m.getCode();\n+        Assert.assertNotNull(bytecode);\n+        Assert.assertEquals(4, bytecode.length);\n+        Assert.assertEquals(GETSTATIC, beU1(bytecode, 0));\n+        int rawIndex = beU2(bytecode, 1);\n+        JavaField field =  m.getConstantPool().lookupField(rawIndex, m, GETSTATIC);\n+        Assert.assertEquals(\"someStaticField\", field.getName(), \"Wrong field name; rawIndex = \" + rawIndex + \";\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/ConstantPoolTest.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"}]}