{"files":[{"patch":"@@ -3849,0 +3849,1 @@\n+                List<JCExpression> implNames;\n@@ -3851,3 +3852,1 @@\n-                    List<JCExpression> implNames = qualidentList(false);\n-                    accept(SEMI);\n-                    defs.append(toP(F.at(pos).Provides(serviceName, implNames)));\n+                    implNames = qualidentList(false);\n@@ -3856,1 +3855,1 @@\n-                    skip(false, false, false, false);\n+                    implNames = List.nil();\n@@ -3858,0 +3857,2 @@\n+                accept(SEMI);\n+                defs.append(toP(F.at(pos).Provides(serviceName, implNames)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401\n@@ -87,0 +87,1 @@\n+import com.sun.source.tree.ModuleTree;\n@@ -88,0 +89,1 @@\n+import com.sun.tools.javac.api.JavacTaskPool;\n@@ -109,1 +111,5 @@\n-            super(URI.create(\"myfo:\/Test.java\"), JavaFileObject.Kind.SOURCE);\n+            this(\"Test\", text);\n+        }\n+\n+        public MyFileObject(String fileName, String text) {\n+            super(URI.create(\"myfo:\/\" + fileName + \".java\"), JavaFileObject.Kind.SOURCE);\n@@ -1992,0 +1998,68 @@\n+    @Test \/\/JDK-8295401\n+    void testModuleInfoProvidesRecovery() throws IOException {\n+        String code = \"\"\"\n+                      module m {\n+                          $DIRECTIVE\n+                      }\n+                      \"\"\";\n+        record Test(String directive, int prefix, Kind expectedKind) {}\n+        Test[] tests = new Test[] {\n+            new Test(\"uses api.api.API;\", 4, Kind.USES),\n+            new Test(\"opens api.api to other.module;\", 5, Kind.OPENS),\n+            new Test(\"exports api.api to other.module;\", 7, Kind.EXPORTS),\n+            new Test(\"provides java.util.spi.ToolProvider with impl.ToolProvider;\", 8, Kind.PROVIDES),\n+        };\n+        JavacTaskPool pool = new JavacTaskPool(1);\n+        for (Test test : tests) {\n+            String directive = test.directive();\n+            for (int i = test.prefix(); i < directive.length(); i++) {\n+                String replaced = code.replace(\"$DIRECTIVE\", directive.substring(0, i));\n+                pool.getTask(null, null, d -> {}, List.of(), null, List.of(new MyFileObject(replaced)), task -> {\n+                    try {\n+                        CompilationUnitTree cut = task.parse().iterator().next();\n+                        new TreePathScanner<Void, Void>() {\n+                            @Override\n+                            public Void visitModule(ModuleTree node, Void p) {\n+                                assertEquals(\"Unexpected directives size: \" + node.getDirectives().size(),\n+                                             node.getDirectives().size(),\n+                                             1);\n+                                assertEquals(\"Unexpected directive: \" + node.getDirectives().get(0).getKind(),\n+                                             node.getDirectives().get(0).getKind(),\n+                                             test.expectedKind);\n+                                return super.visitModule(node, p);\n+                            }\n+                        }.scan(cut, null);\n+                        return null;\n+                    } catch (IOException ex) {\n+                        throw new IllegalStateException(ex);\n+                    }\n+                });\n+            }\n+        }\n+        String extendedCode = \"\"\"\n+                              module m {\n+                                  provides ;\n+                                  provides java.;\n+                                  provides java.util.spi.ToolProvider with ;\n+                                  provides java.util.spi.ToolProvider with impl.;\n+                              \"\"\";\n+        pool.getTask(null, null, d -> {}, List.of(), null, List.of(new MyFileObject(\"module-info\", extendedCode)), task -> {\n+            try {\n+                CompilationUnitTree cut = task.parse().iterator().next();\n+                task.analyze();\n+                new TreePathScanner<Void, Void>() {\n+                    @Override\n+                    public Void visitModule(ModuleTree node, Void p) {\n+                        assertEquals(\"Unexpected directives size: \" + node.getDirectives().size(),\n+                                     node.getDirectives().size(),\n+                                     4);\n+                        return super.visitModule(node, p);\n+                    }\n+                }.scan(cut, null);\n+                return null;\n+            } catch (IOException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        });\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"}]}