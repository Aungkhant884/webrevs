{"files":[{"patch":"@@ -7542,1 +7542,1 @@\n-            vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n+            vector_length(n) <= 8 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n@@ -7549,19 +7549,3 @@\n-    int vlen_in_bytes = vector_length_in_bytes(this);\n-    if (vlen_in_bytes <= 8) {\n-      \/\/ Multiply each shuffle by two to get byte index\n-      __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n-      __ psllw($vtmp$$XMMRegister, 1);\n-\n-      \/\/ Duplicate to create 2 copies of byte index\n-      __ movdqu($dst$$XMMRegister, $vtmp$$XMMRegister);\n-      __ psllw($dst$$XMMRegister, 8);\n-      __ por($dst$$XMMRegister, $vtmp$$XMMRegister);\n-\n-      \/\/ Add one to get alternate byte index\n-      __ movdqu($vtmp$$XMMRegister, ExternalAddress(vector_short_shufflemask()), $scratch$$Register);\n-      __ paddb($dst$$XMMRegister, $vtmp$$XMMRegister);\n-    } else {\n-      int vlen_enc = vector_length_encoding(this);\n-      \/\/ Multiply each shuffle by two to get byte index\n-      __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-      __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+    \/\/ Multiply each shuffle by two to get byte index\n+    __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n+    __ psllw($vtmp$$XMMRegister, 1);\n@@ -7569,3 +7553,4 @@\n-      \/\/ Duplicate to create 2 copies of byte index\n-      __ vpsllw($dst$$XMMRegister, $vtmp$$XMMRegister,  8, vlen_enc);\n-      __ vpor($dst$$XMMRegister, $dst$$XMMRegister, $vtmp$$XMMRegister, vlen_enc);\n+    \/\/ Duplicate to create 2 copies of byte index\n+    __ movdqu($dst$$XMMRegister, $vtmp$$XMMRegister);\n+    __ psllw($dst$$XMMRegister, 8);\n+    __ por($dst$$XMMRegister, $vtmp$$XMMRegister);\n@@ -7573,3 +7558,26 @@\n-      \/\/ Add one to get alternate byte index\n-      __ vpaddb($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_short_shufflemask()), vlen_enc, $scratch$$Register);\n-    }\n+    \/\/ Add one to get alternate byte index\n+    __ movdqu($vtmp$$XMMRegister, ExternalAddress(vector_short_shufflemask()), $scratch$$Register);\n+    __ paddb($dst$$XMMRegister, $vtmp$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct loadShuffleS_avx(vec dst, vec src, vec vtmp, rRegP scratch) %{\n+  predicate(vector_element_basic_type(n) == T_SHORT &&\n+            vector_length(n) == 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n+  match(Set dst (VectorLoadShuffle src));\n+  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n+  format %{ \"vector_load_shuffle $dst, $src\\t! using $vtmp and $scratch as TEMP\" %}\n+  ins_encode %{\n+    assert(UseAVX >= 2, \"required\");\n+    int vlen_enc = vector_length_encoding(this);\n+    \/\/ Multiply each shuffle by two to get byte index\n+    __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+\n+    \/\/ Duplicate to create 2 copies of byte index\n+    __ vpsllw($dst$$XMMRegister, $vtmp$$XMMRegister,  8, vlen_enc);\n+    __ vpor($dst$$XMMRegister, $dst$$XMMRegister, $vtmp$$XMMRegister, vlen_enc);\n+\n+    \/\/ Add one to get alternate byte index\n+    __ vpaddb($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_short_shufflemask()), vlen_enc, $scratch$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":34,"deletions":26,"binary":false,"changes":60,"status":"modified"}]}