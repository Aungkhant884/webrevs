[{"commit":{"message":"Fix assertion condition\nBetter note while abs should not be used."},"files":[{"filename":"src\/hotspot\/share\/opto\/loopTransform.cpp"}],"sha":"e150ddd82ca6652f737a7e899d20ffa02f7676d2"},{"commit":{"message":"Drop whitespace, again."},"files":[{"filename":"src\/hotspot\/share\/opto\/loopTransform.cpp"}],"sha":"16384c313b684b3a341a4d9f2365776a695800a2"},{"commit":{"message":"Set maximum stride size to be 1 << 2 or max vector size\n\nKeep overflow test if stride can overflow when doubling\nDrop diagnostic flag"},"files":[{"filename":"src\/hotspot\/share\/opto\/loopTransform.cpp"}],"sha":"c5be033d56725aaa476bb2bb1f5019fbfccd1f9b"},{"commit":{"message":"Drop whitespace"},"files":[{"filename":"src\/hotspot\/share\/opto\/loopTransform.cpp"}],"sha":"01cfea1f833fdfc972d82dd17db395df7d1f5283"},{"commit":{"message":"Put back feature switch"},"files":[{"filename":"src\/hotspot\/share\/opto\/loopTransform.cpp"}],"sha":"f286e97f615c0c3b21489e81672262bc3882cdb3"},{"commit":{"message":"Increase stride size to allow unrolling more loops\n\nThis increase allowed stride size for loop unrolling to almost maxium possible\nvalue which is around `max_jint \/  2 - 2`,\nso the value which will prevent overflow when stride is doubled in C2.\n\nThe motivation of this change is discussion and research about unrolling\nvector (SIMD) loops. In such a case stride size depends on elements size\nand machine size of vector for AVX256 and int stride size is 8,\nand loop unroll happens. However short vectors will not cause loop unroll.\n\n```\n    for (int i = 0; i < SPECIES.loopBound(longSize); i += SPECIES.length() \/* 8 for int, 16 for short *\/ ) {\n      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferHeap, i << 1, ByteOrder.nativeOrder());\n      v.intoByteBuffer(dstBufferHeap, i << 1, ByteOrder.nativeOrder());\n    }\n```"},"files":[{"filename":"src\/hotspot\/share\/opto\/loopTransform.cpp"}],"sha":"813bee95100d4ec58067c19276801219d099d6f4"}]