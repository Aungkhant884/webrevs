{"files":[{"patch":"@@ -878,0 +878,2 @@\n+  const int stride_con = cl->stride_con();\n+\n@@ -879,1 +881,5 @@\n-  if (abs(cl->stride_con()) > (1<<2)*future_unroll_cnt) return false;\n+  const int initial_stride_sz = MAX2(1<<2, Matcher::max_vector_size(T_BYTE) \/ 2);\n+  \/\/ Maximum stride size should protect against overflow, when doubling stride unroll_count times\n+  const int max_stride_size = MIN2(max_jint \/ 2 - 2, initial_stride_sz * future_unroll_cnt);\n+  \/\/ No abs() use; abs(min_jint) = 1 (or min_jint)\n+  if (stride_con < -max_stride_size || stride_con > max_stride_size) return false;\n@@ -905,1 +911,0 @@\n-  int stride_con = cl->stride_con();\n@@ -2004,2 +2009,2 @@\n-  assert(old_trip_count > 1 &&\n-      (!adjust_min_trip || stride_p <= (1<<3)*loop_head->unrolled_count()), \"sanity\");\n+  assert(old_trip_count > 1 && (!adjust_min_trip || stride_p <=\n+    MIN2(max_jint \/ 2 - 2, MAX2(1<<3, Matcher::max_vector_size(T_BYTE)) * loop_head->unrolled_count())), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}