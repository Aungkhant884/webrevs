{"files":[{"patch":"@@ -878,0 +878,2 @@\n+  const int stride_con = cl->stride_con();\n+\n@@ -879,1 +881,5 @@\n-  if (abs(cl->stride_con()) > (1<<2)*future_unroll_cnt) return false;\n+  const int initial_stride_sz = MAX2(1<<2, Matcher::max_vector_size(T_BYTE) \/ 2);\n+  \/\/ Maximum stride size should protect against overflow, when doubling stride unroll_count times\n+  const int max_stride_size = MIN2<int>(max_jint \/ 2 - 2, initial_stride_sz * future_unroll_cnt);\n+  \/\/ No abs() use; abs(min_jint) = min_jint\n+  if (stride_con < -max_stride_size || stride_con > max_stride_size) return false;\n@@ -905,1 +911,0 @@\n-  int stride_con = cl->stride_con();\n@@ -2004,2 +2009,2 @@\n-  assert(old_trip_count > 1 &&\n-      (!adjust_min_trip || stride_p <= (1<<3)*loop_head->unrolled_count()), \"sanity\");\n+  assert(old_trip_count > 1 && (!adjust_min_trip || stride_p <=\n+    MIN2<int>(max_jint \/ 2 - 2, MAX2(1<<3, Matcher::max_vector_size(T_BYTE)) * loop_head->unrolled_count())), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\",\n+    \"-Djdk.incubator.vector.VECTOR_ACCESS_OOB_CHECK=1\"})\n+public class TestLoadStoreBytes {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  private byte[] srcArray;\n+\n+  private byte[] dstArray;\n+\n+\n+  private ByteBuffer srcBufferHeap;\n+\n+  private ByteBuffer dstBufferHeap;\n+\n+  private ByteBuffer srcBufferNative;\n+\n+  private ByteBuffer dstBufferNative;\n+\n+\n+  private ResourceScope implicitScope;\n+\n+  private MemorySegment srcSegmentImplicit;\n+\n+  private MemorySegment dstSegmentImplicit;\n+\n+  private ByteBuffer srcBufferSegmentImplicit;\n+\n+  private ByteBuffer dstBufferSegmentImplicit;\n+\n+\n+  private MemoryAddress srcAddress;\n+\n+  private MemoryAddress dstAddress;\n+\n+  byte[] a, b, c;\n+\n+  @Setup\n+  public void setup() {\n+    srcArray = new byte[size];\n+    dstArray = srcArray.clone();\n+    for (int i = 0; i < srcArray.length; i++) {\n+      srcArray[i] = (byte) i;\n+    }\n+\n+\n+    srcBufferHeap = ByteBuffer.allocate(size);\n+    dstBufferHeap = ByteBuffer.allocate(size);\n+\n+    srcBufferNative = ByteBuffer.allocateDirect(size);\n+    dstBufferNative = ByteBuffer.allocateDirect(size);\n+\n+\n+    implicitScope = ResourceScope.newImplicitScope();\n+    srcSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    srcBufferSegmentImplicit = srcSegmentImplicit.asByteBuffer();\n+    dstSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    dstBufferSegmentImplicit = dstSegmentImplicit.asByteBuffer();\n+\n+\n+    srcAddress = CLinker.allocateMemory(size);\n+    dstAddress = CLinker.allocateMemory(size);\n+\n+    a = new byte[size];\n+    b = new byte[size];\n+    c = new byte[size];\n+  }\n+\n+\n+  @Benchmark\n+  public void array() {\n+\/\/    final var srcArray = this.srcArray;\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromArray(SPECIES, srcArray, i);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void array2() {\n+\/\/    final var srcArray = this.srcArray;\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromByteArray(SPECIES, srcArray, i, ByteOrder.nativeOrder());\n+      v.intoByteArray(dstArray, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayScalar() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i ++) {\n+      var v = srcArray[i];\n+      dstArray[i] = v;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd1() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length; i += SPECIES.length()) {\n+      ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+      ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd2() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length\/SPECIES.length(); i++) {\n+      ByteVector av = ByteVector.fromArray(SPECIES, a, (i*SPECIES.length()));\n+      ByteVector bv = ByteVector.fromArray(SPECIES, b, (i*SPECIES.length()));\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, (i*SPECIES.length()));\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayAdd() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromArray(SPECIES, srcArray, i);\n+      v = v.add(v);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferHeap() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferHeap, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferHeap, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferHeapScalar() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n+      var v = srcBufferHeap.get(i);\n+      dstBufferHeap.put(i, v);\n+    }\n+  }\n+\n+  @Benchmark\n+  @CompilerControl(CompilerControl.Mode.PRINT)\n+  public void bufferNative() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferNativeScalar() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n+      var v = srcBufferNative.get(i);\n+      dstBufferNative.put(i, v);\n+    }\n+  }\n+\n+\n+  @Benchmark\n+  public void bufferSegmentImplicit() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  @CompilerControl(CompilerControl.Mode.PRINT)\n+  public void segmentImplicitScalar() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n+      var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+      MemoryAccess.setByteAtOffset(dstSegmentImplicit, i, v);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferSegmentConfined() {\n+    try (final var scope = ResourceScope.newConfinedScope()) {\n+      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+\n+      for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+        var v = ByteVector.fromByteBuffer(SPECIES, srcBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+        v.intoByteBuffer(dstBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+      }\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class TestLoadStoreShort {\n+  private static final VectorSpecies<Short> SPECIES = VectorSpecies.ofLargestShape(short.class);\n+\n+  @Param(\"256\")\n+  private int size;\n+\n+  private int longSize;\n+\n+  private short[] srcArray;\n+\n+  private short[] dstArray;\n+\n+\n+  private ByteBuffer srcBufferHeap;\n+\n+  private ByteBuffer dstBufferHeap;\n+\n+  private ByteBuffer srcBufferNative;\n+\n+  private ByteBuffer dstBufferNative;\n+\n+\n+  private ResourceScope implicitScope;\n+\n+  private MemorySegment srcSegmentImplicit;\n+\n+  private MemorySegment dstSegmentImplicit;\n+\n+  private ByteBuffer srcBufferSegmentImplicit;\n+\n+  private ByteBuffer dstBufferSegmentImplicit;\n+\n+\n+  private MemoryAddress srcAddress;\n+\n+  private MemoryAddress dstAddress;\n+\n+\/\/  private byte[] bigArray = new byte[Integer.MAX_VALUE];\n+\n+  private volatile short[] a, b, c;\n+  @Setup\n+  public void setup() {\n+    var longSize = size \/ Short.BYTES;\n+    srcArray = new short[longSize];\n+    dstArray = srcArray.clone();\n+    for (int i = 0; i < srcArray.length; i++) {\n+      srcArray[i] = (short) i;\n+    }\n+\n+\n+    srcBufferHeap = ByteBuffer.allocate(size);\n+    dstBufferHeap = ByteBuffer.allocate(size);\n+\n+    srcBufferNative = ByteBuffer.allocateDirect(size);\n+    dstBufferNative = ByteBuffer.allocateDirect(size);\n+\n+\n+    implicitScope = ResourceScope.newImplicitScope();\n+    srcSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    srcBufferSegmentImplicit = srcSegmentImplicit.asByteBuffer();\n+    dstSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    dstBufferSegmentImplicit = dstSegmentImplicit.asByteBuffer();\n+\n+\n+    srcAddress = CLinker.allocateMemory(size);\n+    dstAddress = CLinker.allocateMemory(size);\n+\n+    this.longSize = longSize;\n+\n+    a = new short[size];\n+    b = new short[size];\n+    c = new short[size];\n+\n+  }\n+\n+  @TearDown\n+  public void tearDown() {\n+    CLinker.freeMemory(srcAddress);\n+    CLinker.freeMemory(dstAddress);\n+  }\n+\n+  @Benchmark\n+  @CompilerControl(CompilerControl.Mode.PRINT)\n+  public void array() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd1() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length; i += SPECIES.length()) {\n+      ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+      ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd2() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length\/SPECIES.length(); i++) {\n+      ShortVector av = ShortVector.fromArray(SPECIES, a, (i*SPECIES.length()));\n+      ShortVector bv = ShortVector.fromArray(SPECIES, b, (i*SPECIES.length()));\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, (i*SPECIES.length()));\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayAdd() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n+      v = v.add(v);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferHeap() {\n+    for (int i = 0; i < SPECIES.loopBound(longSize); i += SPECIES.length()) {\n+      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferHeap, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferHeap, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferNative() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferNativeAdd() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n+      v = v.add(v);\n+      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferSegmentImplicit() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferSegmentConfined() {\n+    try (final var scope = ResourceScope.newConfinedScope()) {\n+      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+\n+      for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+        var v = ShortVector.fromByteBuffer(SPECIES, srcBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+        v.intoByteBuffer(dstBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+      }\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"}]}