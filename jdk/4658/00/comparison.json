{"files":[{"patch":"@@ -177,0 +177,4 @@\n+  product(bool,  LoopUnrollMaximizeStrideLimit, true, DIAGNOSTIC,           \\\n+          \"Allow large strides in loops during unrolling, allowing more \"   \\\n+          \"loops to be undrolled\")                                          \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -878,2 +878,14 @@\n-  \/\/ Check for initial stride being a small enough constant\n-  if (abs(cl->stride_con()) > (1<<2)*future_unroll_cnt) return false;\n+  const int stride_con = cl->stride_con();\n+\n+  if (LoopUnrollMaximizeStrideLimit) {\n+    \/\/ Prevent orverflow when multiplying stride by 2, in C2, leave some space for +\/- 1\n+    \/\/ Note: min_jint = -max_jint - 1 (mathematically), abs(min_jint) = 1 (reality)\n+    \/\/ Stride gets doubled with every unroll iteration\n+    const int mid = max_jint \/ 2 - 2;\n+\n+    if (stride_con < -mid || stride_con > mid)\n+      return false;\n+  } else {\n+      \/\/ Check for initial stride being a small enough constant\n+      if (abs(cl->stride_con()) > (1<<2)*future_unroll_cnt) return false;\n+  }\n@@ -905,1 +917,0 @@\n-  int stride_con = cl->stride_con();\n@@ -2005,1 +2016,3 @@\n-      (!adjust_min_trip || stride_p <= (1<<3)*loop_head->unrolled_count()), \"sanity\");\n+      (!adjust_min_trip ||\n+      (LoopUnrollMaximizeStrideLimit && stride_p <= max_jint \/ 2 - 2) ||\n+      (!LoopUnrollMaximizeStrideLimit && stride_p <= (1<<3)*loop_head->unrolled_count())), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"}]}