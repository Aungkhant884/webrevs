{"files":[{"patch":"@@ -510,1 +510,1 @@\n-  if (AndIL_shift_and_mask(phase, in(2), in(1), T_INT)) {\n+  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_INT, true)) {\n@@ -556,0 +556,6 @@\n+  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n+  Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n+  if (progress != NULL) {\n+    return progress;\n+  }\n+\n@@ -610,6 +616,0 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n-  if (progress != NULL) {\n-    return progress;\n-  }\n-\n@@ -649,1 +649,1 @@\n-  if (AndIL_shift_and_mask(phase, in(2), in(1), T_LONG)) {\n+  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_LONG, true)) {\n@@ -696,0 +696,6 @@\n+  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n+  Node* progress = AndIL_add_shift_and_mask(phase, T_LONG);\n+  if (progress != NULL) {\n+    return progress;\n+  }\n+\n@@ -732,6 +738,0 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_LONG);\n-  if (progress != NULL) {\n-    return progress;\n-  }\n-\n@@ -1717,5 +1717,14 @@\n-\/\/ Helper method to transform:\n-\/\/ patterns similar to (v << 2) & 3 to 0\n-\/\/ and\n-\/\/ patterns similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-bool MulNode::AndIL_shift_and_mask(PhaseGVN* phase, Node* mask, Node* shift, BasicType bt) {\n+\/\/ Given an expression (AndX shift mask) or (AndX mask shift),\n+\/\/ determine if the AndX must always produce zero, because the\n+\/\/ the shift (x<<N) is bitwise disjoint from the mask #M.\n+\/\/ The X in AndX must be I or L, depending on bt.\n+\/\/ Specifically, the following cases fold to zero,\n+\/\/ when the shift value N is large enough to zero out\n+\/\/ all the set positions of the and-mask M.\n+\/\/   (AndI (LShiftI _ #N) #M) => #0\n+\/\/   (AndL (LShiftL _ #N) #M) => #0\n+\/\/   (AndL (ConvI2L (LShiftI _ #N)) #M) => #0\n+\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n+\/\/ Because the optimization might work for a non-constant\n+\/\/ mask M, we check the AndX for both operand orders.\n+bool MulNode::AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse) {\n@@ -1730,1 +1739,2 @@\n-  if (bt == T_LONG && shift != NULL && shift->Opcode() == Op_ConvI2L) {\n+  BasicType shift_bt = bt;\n+  if (bt == T_LONG && shift->Opcode() == Op_ConvI2L) {\n@@ -1732,2 +1742,2 @@\n-    shift = shift->in(1);\n-    if (shift == NULL) {\n+    Node* val = shift->in(1);\n+    if (val == NULL) {\n@@ -1736,0 +1746,4 @@\n+    if (val->Opcode() == Op_LShiftI) {\n+      shift_bt = T_INT;\n+      shift = val;\n+    }\n@@ -1737,1 +1751,7 @@\n-  if (shift->Opcode() != Op_LShift(bt)) {\n+  if (shift->Opcode() != Op_LShift(shift_bt)) {\n+    if (check_reverse &&\n+        (mask->Opcode() == Op_LShift(bt) ||\n+         (bt == T_LONG && mask->Opcode() == Op_ConvI2L))) {\n+      \/\/ try it the other way around\n+      return AndIL_shift_and_mask_is_always_zero(phase, mask, shift, bt, false);\n+    }\n@@ -1749,1 +1769,1 @@\n-  jint shift_con = shift2_t->is_int()->get_con() & ((bt == T_INT ? BitsPerJavaInteger : BitsPerJavaLong) - 1);\n+  jint shift_con = shift2_t->is_int()->get_con() & ((shift_bt == T_INT ? BitsPerJavaInteger : BitsPerJavaLong) - 1);\n@@ -1757,2 +1777,14 @@\n-\/\/ Helper method to transform:\n-\/\/ patterns similar to (v1 + (v2 << 2)) & 3 to v1 & 3\n+\/\/ Given an expression (AndX (AddX v1 (LShiftX v2 #N)) #M)\n+\/\/ determine if the AndX must always produce (AndX v1 #M),\n+\/\/ because the shift (v2<<N) is bitwise disjoint from the mask #M.\n+\/\/ The X in AndX will be I or L, depending on bt.\n+\/\/ Specifically, the following cases fold,\n+\/\/ when the shift value N is large enough to zero out\n+\/\/ all the set positions of the and-mask M.\n+\/\/   (AndI (AddI v1 (LShiftI _ #N)) #M) => (AndI v1 #M)\n+\/\/   (AndL (AddI v1 (LShiftL _ #N)) #M) => (AndL v1 #M)\n+\/\/   (AndL (AddL v1 (ConvI2L (LShiftI _ #N))) #M) => (AndL v1 #M)\n+\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n+\/\/ Because the optimization might work for a non-constant\n+\/\/ mask M, and because the AddX operands can come in either\n+\/\/ order, we check for every operand order.\n@@ -1760,5 +1792,16 @@\n-  Node* in1 = in(1);\n-  Node* in2 = in(2);\n-  if (in1 != NULL && in2 != NULL && in1->Opcode() == Op_Add(bt)) {\n-    Node* add1 = in1->in(1);\n-    Node* add2 = in1->in(2);\n+  Node* add = in(1);\n+  Node* mask = in(2);\n+  if (add == NULL || mask == NULL) {\n+    return NULL;\n+  }\n+  int addidx = 0;\n+  if (add->Opcode() == Op_Add(bt)) {\n+    addidx = 1;\n+  } else if (mask->Opcode() == Op_Add(bt)) {\n+    mask = add;\n+    addidx = 2;\n+    add = in(addidx);\n+  }\n+  if (addidx > 0) {\n+    Node* add1 = add->in(1);\n+    Node* add2 = add->in(2);\n@@ -1766,2 +1809,2 @@\n-      if (AndIL_shift_and_mask(phase, in2, add1, bt)) {\n-        set_req_X(1, add2, phase);\n+      if (AndIL_shift_and_mask_is_always_zero(phase, add1, mask, bt, false)) {\n+        set_req_X(addidx, add2, phase);\n@@ -1769,2 +1812,2 @@\n-      } else if (AndIL_shift_and_mask(phase, in2, add2, bt)) {\n-        set_req_X(1, add1, phase);\n+      } else if (AndIL_shift_and_mask_is_always_zero(phase, add2, mask, bt, false)) {\n+        set_req_X(addidx, add1, phase);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":78,"deletions":35,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  static bool AndIL_shift_and_mask(PhaseGVN* phase, Node* mask, Node* shift, BasicType bt);\n+  static bool AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n@@ -30,1 +32,1 @@\n- * @bug 8277850\n+ * @bug 8277850 8278949\n@@ -37,0 +39,2 @@\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n@@ -48,0 +52,7 @@\n+    @Check(test = \"shiftMaskInt\")\n+    public static void checkShiftMaskInt(int res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -55,0 +66,52 @@\n+\n+    @Check(test = \"shiftMaskLong\")\n+    public static void checkShiftMaskLong(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    static volatile int barrier;\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @IR(failOn = { IRNode.AND_I, IRNode.LSHIFT_I })\n+    public static int shiftNonConstMaskInt(int i, boolean flag) {\n+        int mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & (i << 2); \/\/ transformed to: return 0;\n+    }\n+\n+    @Check(test = \"shiftNonConstMaskInt\")\n+    public static void checkShiftNonConstMaskInt(int res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @IR(failOn = { IRNode.AND_L, IRNode.LSHIFT_L })\n+    public static long shiftNonConstMaskLong(long i, boolean flag) {\n+        long mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & (i << 2); \/\/ transformed to: return 0;\n+    }\n+\n+    @Check(test = \"shiftNonConstMaskLong\")\n+    public static void checkShiftNonConstMaskLong(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -56,1 +119,0 @@\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -63,0 +125,38 @@\n+    @Run(test = \"addShiftMaskInt\")\n+    public static void addShiftMaskInt_runner() {\n+        int i = RANDOM.nextInt();\n+        int j = RANDOM.nextInt();\n+        int res = addShiftMaskInt(i, j);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I, IRNode.LSHIFT_I })\n+    public static int addSshiftNonConstMaskInt(int i, int j, boolean flag) {\n+        int mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addSshiftNonConstMaskInt\")\n+    public static void addSshiftNonConstMaskInt_runner() {\n+        int i = RANDOM.nextInt();\n+        int j = RANDOM.nextInt();\n+        int res = addSshiftNonConstMaskInt(i, j, true);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addSshiftNonConstMaskInt(i, j, false);\n+        if (res != (j & 1)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -64,1 +164,0 @@\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -71,0 +170,38 @@\n+    @Run(test = \"addShiftMaskLong\")\n+    public static void addShiftMaskLong_runner() {\n+        long i = RANDOM.nextLong();\n+        long j = RANDOM.nextLong();\n+        long res = addShiftMaskLong(i, j);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addSshiftNonConstMaskLong(long i, long j, boolean flag) {\n+        int mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addSshiftNonConstMaskLong\")\n+    public static void addSshiftNonConstMaskLong_runner() {\n+        long i = RANDOM.nextLong();\n+        long j = RANDOM.nextLong();\n+        long res = addSshiftNonConstMaskLong(i, j, true);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addSshiftNonConstMaskLong(i, j, false);\n+        if (res != (j & 1)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -78,0 +215,7 @@\n+    @Check(test = \"addShiftMaskInt2\")\n+    public static void checkAddShiftMaskInt2(int res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -85,0 +229,8 @@\n+    @Check(test = \"addShiftMaskLong2\")\n+    public static void checkAddShiftMaskLong2(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Try to get add inputs swapped compared to other tests\n@@ -86,1 +238,39 @@\n-    @Arguments(Argument.RANDOM_EACH)\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I, IRNode.LSHIFT_I })\n+    public static int addShiftMaskInt3(int i, long j) {\n+        int add1 = (i << 2);\n+        int add2 = (int)j;\n+        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+    }\n+\n+    @Run(test = \"addShiftMaskInt3\")\n+    public static void addShiftMaskInt3_runner() {\n+        int i = RANDOM.nextInt();\n+        int j = RANDOM.nextInt();\n+        int res = addShiftMaskInt3(i, j);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addShiftMaskLong3(long i, float j) {\n+        long add1 = (i << 2);\n+        long add2 = (long)j;\n+        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+    }\n+\n+    @Run(test = \"addShiftMaskLong3\")\n+    public static void addShiftMaskLong3_runner() {\n+        long i = RANDOM.nextLong();\n+        float j = RANDOM.nextFloat();\n+        long res = addShiftMaskLong3(i, j);\n+        if (res != (((long)j) & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH})\n@@ -92,0 +282,28 @@\n+    @Check(test = \"shiftConvMask\")\n+    public static void checkShiftConvMask(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @IR(failOn = { IRNode.AND_L, IRNode.LSHIFT_L })\n+    public static long shiftNotConstConvMask(int i, boolean flag) {\n+        long mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & ((long)(i << 2)); \/\/ transformed to: return 0;\n+    }\n+\n+    @Check(test = \"shiftNotConstConvMask\")\n+    public static void checkShiftNotConstConvMask(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -93,1 +311,0 @@\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -100,0 +317,10 @@\n+    @Run(test = \"addShiftConvMask\")\n+    public static void addShiftConvMask_runner() {\n+        int i = RANDOM.nextInt();\n+        long j = RANDOM.nextLong();\n+        long res = addShiftConvMask(i, j);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -107,0 +334,6 @@\n+    @Check(test = \"addShiftConvMask2\")\n+    public static void checkAddShiftConvMask2(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n@@ -108,1 +341,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java","additions":238,"deletions":6,"binary":false,"changes":244,"status":"modified"}]}