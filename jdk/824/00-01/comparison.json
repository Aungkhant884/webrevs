{"files":[{"patch":"@@ -414,3 +414,0 @@\n-bool G1ArchiveAllocator::_archive_check_enabled = false;\n-G1ArchiveRegionMap G1ArchiveAllocator::_archive_region_map;\n-\n@@ -418,5 +415,1 @@\n-  \/\/ Create the archive allocator, and also enable archive object checking\n-  \/\/ in mark-sweep, since we will be creating archive regions.\n-  G1ArchiveAllocator* result =  new G1ArchiveAllocator(g1h, open);\n-  enable_archive_object_check();\n-  return result;\n+  return new G1ArchiveAllocator(g1h, open);\n@@ -450,3 +443,0 @@\n-  \/\/ Tell mark-sweep that objects in this region are not to be marked.\n-  set_range_archive(MemRegion(_bottom, HeapRegion::GrainWords), _open);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -206,13 +206,0 @@\n-\/\/ G1ArchiveRegionMap is an array used to mark G1 regions as\n-\/\/ archive regions.  This allows a quick check for whether an object\n-\/\/ should not be marked because it is in an archive region.\n-class G1ArchiveRegionMap : public G1BiasedMappedArray<uint8_t> {\n-public:\n-  static const uint8_t NoArchive = 0;\n-  static const uint8_t OpenArchive = 1;\n-  static const uint8_t ClosedArchive = 2;\n-\n-protected:\n-  uint8_t default_value() const { return NoArchive; }\n-};\n-\n@@ -292,23 +279,0 @@\n-\n-  \/\/ Create the _archive_region_map which is used to identify archive objects.\n-  static inline void enable_archive_object_check();\n-\n-  \/\/ Mark regions containing the specified address range as archive\/non-archive.\n-  static inline void set_range_archive(MemRegion range, bool open);\n-  static inline void clear_range_archive(MemRegion range);\n-\n-  \/\/ Check if the object is in closed archive\n-  static inline bool is_closed_archive_object(oop object);\n-  \/\/ Check if the object is either in closed archive or open archive\n-  static inline bool is_archived_object(oop object);\n-\n-private:\n-  static bool _archive_check_enabled;\n-  static G1ArchiveRegionMap  _archive_region_map;\n-\n-  \/\/ Check if an object is in a closed archive region using the _archive_region_map.\n-  static inline bool in_closed_archive_range(oop object);\n-\n-  \/\/ Check if archive object checking is enabled, to avoid calling in_open\/closed_archive_range\n-  \/\/ unnecessarily.\n-  static inline bool archive_check_enabled();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -126,51 +126,0 @@\n-\/\/ Create the maps which is used to identify archive objects.\n-inline void G1ArchiveAllocator::enable_archive_object_check() {\n-  if (_archive_check_enabled) {\n-    return;\n-  }\n-\n-  _archive_check_enabled = true;\n-  _archive_region_map.initialize(G1CollectedHeap::heap()->reserved(),\n-                                 HeapRegion::GrainBytes);\n-}\n-\n-\/\/ Set the regions containing the specified address range as archive.\n-inline void G1ArchiveAllocator::set_range_archive(MemRegion range, bool open) {\n-  assert(_archive_check_enabled, \"archive range check not enabled\");\n-  log_info(gc, cds)(\"Mark %s archive regions in map: [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-                     open ? \"open\" : \"closed\",\n-                     p2i(range.start()),\n-                     p2i(range.last()));\n-  uint8_t const value = open ? G1ArchiveRegionMap::OpenArchive : G1ArchiveRegionMap::ClosedArchive;\n-  _archive_region_map.set_by_address(range, value);\n-}\n-\n-\/\/ Clear the archive regions map containing the specified address range.\n-inline void G1ArchiveAllocator::clear_range_archive(MemRegion range) {\n-  assert(_archive_check_enabled, \"archive range check not enabled\");\n-  log_info(gc, cds)(\"Clear archive regions in map: [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-                    p2i(range.start()),\n-                    p2i(range.last()));\n-  _archive_region_map.set_by_address(range, G1ArchiveRegionMap::NoArchive);\n-}\n-\n-\/\/ Check if an object is in a closed archive region using the _archive_region_map.\n-inline bool G1ArchiveAllocator::in_closed_archive_range(oop object) {\n-  return _archive_region_map.get_by_address(cast_from_oop<HeapWord*>(object)) == G1ArchiveRegionMap::ClosedArchive;\n-}\n-\n-\/\/ Check if archive object checking is enabled, to avoid calling in_open\/closed_archive_range\n-\/\/ unnecessarily.\n-inline bool G1ArchiveAllocator::archive_check_enabled() {\n-  return _archive_check_enabled;\n-}\n-\n-inline bool G1ArchiveAllocator::is_closed_archive_object(oop object) {\n-  return (archive_check_enabled() && in_closed_archive_range(object));\n-}\n-\n-inline bool G1ArchiveAllocator::is_archived_object(oop object) {\n-  return archive_check_enabled() &&\n-         (_archive_region_map.get_by_address(cast_from_oop<HeapWord*>(object)) != G1ArchiveRegionMap::NoArchive);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -573,4 +573,0 @@\n-  \/\/ Enable archive object checking used by G1MarkSweep. We have to let it know\n-  \/\/ about each archive range, so that objects in those ranges aren't marked.\n-  G1ArchiveAllocator::enable_archive_object_check();\n-\n@@ -652,3 +648,0 @@\n-\n-    \/\/ Notify mark-sweep of the archive\n-    G1ArchiveAllocator::set_range_archive(curr_range, open);\n@@ -805,3 +798,0 @@\n-\n-    \/\/ Notify mark-sweep that this is no longer an archive range.\n-    G1ArchiveAllocator::clear_range_archive(ranges[i]);\n@@ -818,2 +808,1 @@\n-  assert(obj != NULL, \"archived obj is NULL\");\n-  assert(G1ArchiveAllocator::is_archived_object(obj), \"must be archived object\");\n+  assert(is_archived_object(obj), \"not an archived obj\");\n@@ -1019,2 +1008,1 @@\n-  tear_down_region_sets(false \/* free_list_only *\/);\n-\n+  hrm()->remove_all_free_regions();\n@@ -1340,1 +1328,1 @@\n-  tear_down_region_sets(true \/* free_list_only *\/);\n+  hrm()->remove_all_free_regions();\n@@ -2408,0 +2396,4 @@\n+bool G1CollectedHeap::is_archived_object(oop object) const {\n+  return object != NULL && heap_region_containing(object)->is_archive();\n+}\n+\n@@ -4577,33 +4569,5 @@\n-class TearDownRegionSetsClosure : public HeapRegionClosure {\n-  HeapRegionSet *_old_set;\n-\n-public:\n-  TearDownRegionSetsClosure(HeapRegionSet* old_set) : _old_set(old_set) { }\n-\n-  bool do_heap_region(HeapRegion* r) {\n-    if (r->is_old()) {\n-      _old_set->remove(r);\n-    } else if(r->is_young()) {\n-      r->uninstall_surv_rate_group();\n-    } else {\n-      \/\/ We ignore free regions, we'll empty the free list afterwards.\n-      \/\/ We ignore humongous and archive regions, we're not tearing down these\n-      \/\/ sets.\n-      assert(r->is_archive() || r->is_free() || r->is_humongous(),\n-             \"it cannot be another type\");\n-    }\n-    return false;\n-  }\n-\n-  ~TearDownRegionSetsClosure() {\n-    assert(_old_set->is_empty(), \"post-condition\");\n-  }\n-};\n-\n-void G1CollectedHeap::tear_down_region_sets(bool free_list_only) {\n-  assert_at_safepoint_on_vm_thread();\n-\n-  if (!free_list_only) {\n-    TearDownRegionSetsClosure cl(&_old_set);\n-    heap_region_iterate(&cl);\n-\n+  \/\/ Remove the given HeapRegion from the appropriate region set.\n+void G1CollectedHeap::prepare_region_for_full_compaction(HeapRegion* hr) {\n+  if (hr->is_old()) {\n+    _old_set.remove(hr);\n+  } else if (hr->is_young()) {\n@@ -4614,0 +4578,7 @@\n+    hr->uninstall_surv_rate_group();\n+  } else {\n+    \/\/ We ignore free regions, we'll empty the free list afterwards.\n+    \/\/ We ignore humongous and archive regions, we're not tearing down these\n+    \/\/ sets.\n+    assert(hr->is_archive() || hr->is_free() || hr->is_humongous(),\n+           \"it cannot be another type\");\n@@ -4615,1 +4586,0 @@\n-  _hrm->remove_all_free_regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":19,"deletions":49,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -180,7 +180,2 @@\n-  \/\/ Tears down the region sets \/ lists so that they are empty and the\n-  \/\/ regions on the heap do not belong to a region set \/ list. The\n-  \/\/ only exception is the humongous set which we leave unaltered. If\n-  \/\/ free_list_only is true, it will only tear down the master free\n-  \/\/ list. It is called before a Full GC (free_list_only == false) or\n-  \/\/ before heap shrinking (free_list_only == true).\n-  void tear_down_region_sets(bool free_list_only);\n+public:\n+  void prepare_region_for_full_compaction(HeapRegion* hr);\n@@ -188,0 +183,1 @@\n+private:\n@@ -191,3 +187,1 @@\n-  \/\/ free_list_only is true, it will only rebuild the master free\n-  \/\/ list. It is called after a Full GC (free_list_only == false) or\n-  \/\/ after heap shrinking (free_list_only == true).\n+  \/\/ free_list_only is true, it will only rebuild the free list.\n@@ -1432,0 +1426,2 @@\n+  virtual bool is_archived_object(oop object) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    _is_alive(heap->concurrent_mark()->next_mark_bitmap()),\n+    _is_alive(this, heap->concurrent_mark()->next_mark_bitmap()),\n@@ -125,1 +125,1 @@\n-    _markers[i] = new G1FullGCMarker(i, _preserved_marks_set.get(i), mark_bitmap());\n+    _markers[i] = new G1FullGCMarker(this, i, _preserved_marks_set.get(i));\n@@ -142,0 +142,13 @@\n+class PrepareRegionsClosure : public HeapRegionClosure {\n+  G1FullCollector* _collector;\n+\n+public:\n+  PrepareRegionsClosure(G1FullCollector* collector) : _collector(collector) { }\n+\n+  bool do_heap_region(HeapRegion* hr) {\n+    G1CollectedHeap::heap()->prepare_region_for_full_compaction(hr);\n+    _collector->update_attribute_table(hr);\n+    return false;\n+  }\n+};\n+\n@@ -154,0 +167,3 @@\n+  PrepareRegionsClosure cl(this);\n+  _heap->heap_region_iterate(&cl);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1FullGCHeapRegionAttr.hpp\"\n@@ -56,38 +57,0 @@\n-\/\/ This table is used to store some per-region attributes needed during collection.\n-class G1FullGCHeapRegionAttrBiasedMappedArray : public G1BiasedMappedArray<uint8_t> {\n-  static const uint8_t Normal = 0;\n-  static const uint8_t Pinned = 1;\n-  static const uint8_t ClosedArchive = 2;\n-\n-  static const uint8_t Invalid = 255;\n-\n-protected:\n-  uint8_t default_value() const { return Invalid; }\n-\n-public:\n-  void set_closed_archive(uint idx) { set_by_index(idx, ClosedArchive); }\n-\n-  bool is_closed_archive(HeapWord* obj) const {\n-    assert(!is_invalid(obj), \"not initialized yet\");\n-    return get_by_address(obj) == ClosedArchive;\n-  }\n-\n-  void set_pinned_or_closed(uint idx) { set_by_index(idx, Pinned); }\n-\n-  bool is_pinned_or_closed(HeapWord* obj) const {\n-    assert(!is_invalid(obj), \"not initialized yet\");\n-    return get_by_address(obj) >= Pinned;\n-  }\n-\n-  void set_normal(uint idx) { set_by_index(idx, Normal); }\n-\n-  bool is_normal(HeapWord* obj) const {\n-    assert(!is_invalid(obj), \"not initialized yet\");\n-    return get_by_address(obj) == Normal;\n-  }\n-\n-  bool is_invalid(HeapWord* obj) const {\n-    return get_by_address(obj) == Invalid;\n-  }\n-};\n-\n@@ -113,1 +76,1 @@\n-  G1FullGCHeapRegionAttrBiasedMappedArray _region_attr_table;\n+  G1FullGCHeapRegionAttr _region_attr_table;\n@@ -138,1 +101,0 @@\n-  bool is_in_invalid(oop obj) const { return _region_attr_table.is_invalid(cast_from_oop<HeapWord*>(obj)); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-  G1AdjustRegionClosure(G1FullCollector* collector, G1CMBitMap* bitmap, uint worker_id) :\n+  G1AdjustRegionClosure(G1FullCollector* collector, uint worker_id) :\n@@ -60,1 +60,1 @@\n-    _bitmap(bitmap),\n+    _bitmap(collector->mark_bitmap()),\n@@ -70,1 +70,1 @@\n-    } else if (!(r->is_closed_archive() || r->is_free())) {\n+    } else if (!r->is_closed_archive() && !r->is_free()) {\n@@ -118,1 +118,1 @@\n-  G1AdjustRegionClosure blk(collector(), collector()->mark_bitmap(), worker_id);\n+  G1AdjustRegionClosure blk(collector(), worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    r->pinned_complete_compaction();\n+    r->reset_pinned_after_full_gc();\n@@ -82,1 +82,1 @@\n-  hr->non_pinned_complete_compaction();\n+  hr->reset_compacted_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1FULLGCHEAPREGIONATTR_HPP\n+#define SHARE_GC_G1_G1FULLGCHEAPREGIONATTR_HPP\n+\n+#include \"gc\/g1\/g1BiasedArray.hpp\"\n+\n+\/\/ This table is used to store some per-region attributes needed during full\n+\/\/ collection.\n+class G1FullGCHeapRegionAttr : public G1BiasedMappedArray<uint8_t> {\n+  static const uint8_t Normal = 0;\n+  static const uint8_t Pinned = 1;\n+  static const uint8_t ClosedArchive = 2;\n+\n+  static const uint8_t Invalid = 255;\n+\n+  bool is_invalid(HeapWord* obj) const {\n+    return get_by_address(obj) == Invalid;\n+  }\n+\n+protected:\n+  uint8_t default_value() const { return Invalid; }\n+\n+public:\n+  void set_closed_archive(uint idx) { set_by_index(idx, ClosedArchive); }\n+\n+  bool is_closed_archive(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) == ClosedArchive;\n+  }\n+\n+  void set_pinned_or_closed(uint idx) { set_by_index(idx, Pinned); }\n+\n+  bool is_pinned_or_closed(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) >= Pinned;\n+  }\n+\n+  void set_normal(uint idx) { set_by_index(idx, Normal); }\n+\n+  bool is_normal(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) == Normal;\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1FULLGCHEAPREGIONATTR_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -33,3 +33,4 @@\n-G1FullGCMarker::G1FullGCMarker(uint worker_id,\n-                               PreservedMarks* preserved_stack,\n-                               G1CMBitMap* bitmap) :\n+G1FullGCMarker::G1FullGCMarker(G1FullCollector* collector,\n+                               uint worker_id,\n+                               PreservedMarks* preserved_stack) :\n+    _collector(collector),\n@@ -37,1 +38,1 @@\n-    _bitmap(bitmap),\n+    _bitmap(collector->mark_bitmap()),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  G1FullCollector*   _collector;\n+\n@@ -75,1 +77,1 @@\n-  G1FullGCMarker(uint worker_id, PreservedMarks* preserved_stack, G1CMBitMap* bitmap);\n+  G1FullGCMarker(G1FullCollector* collector, uint worker_id, PreservedMarks* preserved_stack);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  if (G1ArchiveAllocator::is_closed_archive_object(obj)) {\n+  if (_collector->is_in_closed(obj)) {\n@@ -57,1 +57,1 @@\n-      !G1CollectedHeap::heap()->heap_region_containing(obj)->is_pinned()) {\n+      !_collector->is_in_pinned_or_closed(obj)) {\n@@ -76,1 +76,1 @@\n-      assert(_bitmap->is_marked(obj) || G1ArchiveAllocator::is_closed_archive_object(obj),\n+      assert(_bitmap->is_marked(obj) || _collector->is_in_closed(obj),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1FullCollector.hpp\"\n@@ -35,0 +36,3 @@\n+G1IsAliveClosure::G1IsAliveClosure(G1FullCollector* collector) :\n+  G1IsAliveClosure(collector, collector->mark_bitmap()) { }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+  G1FullCollector* _collector;\n@@ -41,1 +42,3 @@\n-  G1IsAliveClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n+  G1IsAliveClosure(G1FullCollector* collector);\n+  G1IsAliveClosure(G1FullCollector* collector, G1CMBitMap* bitmap) :\n+    _collector(collector), _bitmap(bitmap) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-  return _bitmap->is_marked(p) || G1ArchiveAllocator::is_closed_archive_object(p);\n+  return _bitmap->is_marked(p) || _collector->is_in_closed(p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  G1CalculatePointersClosure closure(collector(), collector()->mark_bitmap(), compaction_point);\n+  G1CalculatePointersClosure closure(collector(), compaction_point);\n@@ -102,1 +102,0 @@\n-                                                                            G1CMBitMap* bitmap,\n@@ -106,1 +105,1 @@\n-    _bitmap(bitmap),\n+    _bitmap(collector->mark_bitmap()),\n@@ -111,1 +110,1 @@\n-  assert(hr->is_humongous(), \"handled elsewhere\");\n+  assert(hr->is_humongous(), \"must be but region %u is %s\", hr->hrm_index(), hr->get_short_type_str());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,0 @@\n-                               G1CMBitMap* bitmap,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  G1IsAliveClosure is_alive(_collector->mark_bitmap());\n+  G1IsAliveClosure is_alive(_collector);\n@@ -85,1 +85,1 @@\n-  G1IsAliveClosure is_alive(_collector->mark_bitmap());\n+  G1IsAliveClosure is_alive(_collector);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCReferenceProcessorExecutor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -243,2 +243,1 @@\n-  VerifyArchiveOopClosure(HeapRegion *hr)\n-    : _hr(hr) { }\n+  VerifyArchiveOopClosure(HeapRegion *hr) : _hr(hr) { }\n@@ -252,1 +251,1 @@\n-      guarantee(obj == NULL || G1ArchiveAllocator::is_archived_object(obj),\n+      guarantee(obj == NULL || G1CollectedHeap::heap()->heap_region_containing(obj)->is_archive(),\n@@ -257,1 +256,1 @@\n-      guarantee(obj == NULL || G1ArchiveAllocator::is_closed_archive_object(obj),\n+      guarantee(obj == NULL || G1CollectedHeap::heap()->heap_region_containing(obj)->is_closed_archive(),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -126,1 +126,3 @@\n-  void reset_after_compaction();\n+  void reset_compaction_top_after_compaction();\n+\n+  void reset_after_full_gc_common();\n@@ -169,5 +171,4 @@\n-  \/\/ Update heap region to be consistent after Full GC compaction for non-pinned\n-  \/\/ regions.\n-  void non_pinned_complete_compaction();\n-  void pinned_complete_compaction();\n-  void complete_compaction_common();\n+  \/\/ Update heap region that has been compacted to be consistent after Full GC.\n+  void reset_compacted_after_full_gc();\n+  \/\/ Update pinned heap region (not compacted) to be consistent after Full GC.\n+  void reset_pinned_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-inline void HeapRegion::reset_after_compaction() {\n+inline void HeapRegion::reset_compaction_top_after_compaction() {\n@@ -189,1 +189,1 @@\n-inline void HeapRegion::non_pinned_complete_compaction() {\n+inline void HeapRegion::reset_compacted_after_full_gc() {\n@@ -192,1 +192,1 @@\n-  reset_after_compaction();\n+  reset_compaction_top_after_compaction();\n@@ -198,1 +198,1 @@\n-  complete_compaction_common();\n+  reset_after_full_gc_common();\n@@ -201,1 +201,1 @@\n-inline void HeapRegion::pinned_complete_compaction() {\n+inline void HeapRegion::reset_pinned_after_full_gc() {\n@@ -214,1 +214,1 @@\n-  complete_compaction_common();\n+  reset_after_full_gc_common();\n@@ -217,1 +217,1 @@\n-inline void HeapRegion::complete_compaction_common() {\n+inline void HeapRegion::reset_after_full_gc_common() {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -519,0 +519,3 @@\n+  \/\/ Is the given object inside a CDS archive area?\n+  virtual bool is_archived_object(oop object) const { return false; }\n+\n@@ -523,1 +526,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"utilities\/copy.hpp\"\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n@@ -31,3 +32,0 @@\n-#if INCLUDE_G1GC\n-#include \"gc\/g1\/g1Allocator.inline.hpp\"\n-#endif\n@@ -38,1 +36,1 @@\n-  return (p == NULL) ? false : G1ArchiveAllocator::is_archived_object(p);\n+  return Universe::heap()->is_archived_object(p);\n","filename":"src\/hotspot\/share\/memory\/heapShared.inline.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}