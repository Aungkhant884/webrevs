{"files":[{"patch":"@@ -302,2 +302,0 @@\n-  \/\/ Check if the object is in open archive\n-  static inline bool is_open_archive_object(oop object);\n@@ -311,1 +309,1 @@\n-  \/\/ Check if an object is in a closed archive region using the _closed_archive_region_map.\n+  \/\/ Check if an object is in a closed archive region using the _archive_region_map.\n@@ -313,2 +311,0 @@\n-  \/\/ Check if an object is in open archive region using the _open_archive_region_map.\n-  static inline bool in_open_archive_range(oop object);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -162,4 +162,0 @@\n-inline bool G1ArchiveAllocator::in_open_archive_range(oop object) {\n-  return _archive_region_map.get_by_address(cast_from_oop<HeapWord*>(object)) == G1ArchiveRegionMap::OpenArchive;\n-}\n-\n@@ -176,4 +172,0 @@\n-inline bool G1ArchiveAllocator::is_open_archive_object(oop object) {\n-  return (archive_check_enabled() && in_open_archive_range(object));\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,20 @@\n+G1BiasedMappedArrayBase::G1BiasedMappedArrayBase() :\n+  _alloc_base(NULL),\n+  _base(NULL),\n+  _length(0),\n+  _biased_base(NULL),\n+  _bias(0),\n+  _shift_by(0) { }\n+\n+G1BiasedMappedArrayBase::~G1BiasedMappedArrayBase() {\n+  if (_alloc_base != NULL) {\n+    FREE_C_HEAP_ARRAY(u_char, _alloc_base);\n+    _alloc_base = NULL;\n+    _base = NULL;\n+    _length = 0;\n+    _biased_base = NULL;\n+    _bias = 0;\n+    _shift_by = 0;\n+  }\n+}\n+\n@@ -33,1 +53,1 @@\n-  return PaddedPrimitiveArray<u_char, mtGC>::create_unfreeable(length * elem_size);\n+  return PaddedPrimitiveArray<u_char, mtGC>::create(length * elem_size, &_alloc_base);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -35,1 +36,1 @@\n-class G1BiasedMappedArrayBase {\n+class G1BiasedMappedArrayBase : public CHeapObj<mtGC> {\n@@ -37,0 +38,3 @@\n+\n+  void* _alloc_base;      \/\/ the address the unpadded array has been allocated to\n+\n@@ -39,0 +43,1 @@\n+\n@@ -47,3 +52,1 @@\n-\n-  G1BiasedMappedArrayBase() : _base(NULL), _length(0), _biased_base(NULL),\n-    _bias(0), _shift_by(0) { }\n+  G1BiasedMappedArrayBase();\n@@ -52,1 +55,1 @@\n-  static address create_new_base_array(size_t length, size_t elem_size);\n+  address create_new_base_array(size_t length, size_t elem_size);\n@@ -93,2 +96,4 @@\n-   \/\/ Return the length of the array in elements.\n-   size_t length() const { return _length; }\n+  virtual ~G1BiasedMappedArrayBase();\n+\n+  \/\/ Return the length of the array in elements.\n+  size_t length() const { return _length; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1076,11 +1076,1 @@\n-  \/\/ Clear the previous marking bitmap, if needed for bitmap verification.\n-  \/\/ Note we cannot do this when we clear the next marking bitmap in\n-  \/\/ G1ConcurrentMark::abort() above since VerifyDuringGC verifies the\n-  \/\/ objects marked during a full GC against the previous bitmap.\n-  \/\/ But we need to clear it before calling check_bitmaps below since\n-  \/\/ the full GC has compacted objects and updated TAMS but not updated\n-  \/\/ the prev bitmap.\n-  if (G1VerifyBitmaps) {\n-    GCTraceTime(Debug, gc) tm(\"Clear Prev Bitmap for Verification\");\n-    _cm->clear_prev_bitmap(workers());\n-  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -57,1 +57,6 @@\n-    guarantee(G1CollectionSetChooser::should_add(cur), \"Region %u should be eligible for addition.\", cur->hrm_index());\n+    \/\/ The first disjunction filters out regions with objects that were explicitly\n+    \/\/ pinned after being added to the collection set candidates. Archive regions\n+    \/\/ should never have been added to the collection set though.\n+    guarantee((cur->is_pinned() && !cur->is_archive()) ||\n+              G1CollectionSetChooser::should_add(cur),\n+              \"Region %u should be eligible for addition.\", cur->hrm_index());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-void G1ConcurrentMark::clear_prev_bitmap(WorkGang* workers) {\n+void G1ConcurrentMark::clear_next_bitmap(WorkGang* workers) {\n@@ -680,1 +680,1 @@\n-  clear_bitmap(_prev_mark_bitmap, workers, false);\n+  clear_bitmap(_next_mark_bitmap, workers, false);\n@@ -1135,0 +1135,2 @@\n+\n+    _g1h->collector_state()->set_clearing_next_bitmap(true);\n@@ -1699,1 +1701,0 @@\n-  _g1h->collector_state()->set_clearing_next_bitmap(true);\n@@ -1978,1 +1979,1 @@\n-    clear_bitmap(_next_mark_bitmap, _g1h->workers(), false);\n+    clear_next_bitmap(_g1h->workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -377,2 +377,0 @@\n-  void swap_mark_bitmaps();\n-\n@@ -542,2 +540,2 @@\n-  \/\/ Clear the previous marking bitmap during safepoint.\n-  void clear_prev_bitmap(WorkGang* workers);\n+  \/\/ Clear the next marking bitmap during safepoint.\n+  void clear_next_bitmap(WorkGang* workers);\n@@ -566,0 +564,2 @@\n+  void swap_mark_bitmaps();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -117,1 +117,2 @@\n-    _is_subject_mutator(heap->ref_processor_stw(), &_always_subject_to_discovery) {\n+    _is_subject_mutator(heap->ref_processor_stw(), &_always_subject_to_discovery),\n+    _region_attr_table() {\n@@ -129,0 +130,1 @@\n+  _region_attr_table.initialize(heap->reserved(), HeapRegion::GrainBytes);\n@@ -187,0 +189,4 @@\n+  _heap->concurrent_mark()->swap_mark_bitmaps();\n+  \/\/ Prepare the bitmap for the next (potentially concurrent) marking.\n+  _heap->concurrent_mark()->clear_next_bitmap(_heap->workers());\n+\n@@ -197,0 +203,13 @@\n+void G1FullCollector::update_attribute_table(HeapRegion* hr) {\n+  if (hr->is_free()) {\n+    return;\n+  }\n+  if (hr->is_closed_archive()) {\n+    _region_attr_table.set_closed_archive(hr->hrm_index());\n+  } else if (hr->is_pinned()) {\n+    _region_attr_table.set_pinned_or_closed(hr->hrm_index());\n+  } else {\n+    _region_attr_table.set_normal(hr->hrm_index());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -55,0 +56,38 @@\n+\/\/ This table is used to store some per-region attributes needed during collection.\n+class G1FullGCHeapRegionAttrBiasedMappedArray : public G1BiasedMappedArray<uint8_t> {\n+  static const uint8_t Normal = 0;\n+  static const uint8_t Pinned = 1;\n+  static const uint8_t ClosedArchive = 2;\n+\n+  static const uint8_t Invalid = 255;\n+\n+protected:\n+  uint8_t default_value() const { return Invalid; }\n+\n+public:\n+  void set_closed_archive(uint idx) { set_by_index(idx, ClosedArchive); }\n+\n+  bool is_closed_archive(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) == ClosedArchive;\n+  }\n+\n+  void set_pinned_or_closed(uint idx) { set_by_index(idx, Pinned); }\n+\n+  bool is_pinned_or_closed(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) >= Pinned;\n+  }\n+\n+  void set_normal(uint idx) { set_by_index(idx, Normal); }\n+\n+  bool is_normal(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) == Normal;\n+  }\n+\n+  bool is_invalid(HeapWord* obj) const {\n+    return get_by_address(obj) == Invalid;\n+  }\n+};\n+\n@@ -74,0 +113,2 @@\n+  G1FullGCHeapRegionAttrBiasedMappedArray _region_attr_table;\n+\n@@ -93,0 +134,6 @@\n+  void update_attribute_table(HeapRegion* hr);\n+\n+  bool is_in_pinned_or_closed(oop obj) const { return _region_attr_table.is_pinned_or_closed(cast_from_oop<HeapWord*>(obj)); }\n+  bool is_in_closed(oop obj) const { return _region_attr_table.is_closed_archive(cast_from_oop<HeapWord*>(obj)); }\n+  bool is_in_invalid(oop obj) const { return _region_attr_table.is_invalid(cast_from_oop<HeapWord*>(obj)); }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  G1FullCollector* _collector;\n@@ -57,1 +58,2 @@\n-  G1AdjustRegionClosure(G1CMBitMap* bitmap, uint worker_id) :\n+  G1AdjustRegionClosure(G1FullCollector* collector, G1CMBitMap* bitmap, uint worker_id) :\n+    _collector(collector),\n@@ -62,1 +64,1 @@\n-    G1AdjustClosure cl;\n+    G1AdjustClosure cl(_collector);\n@@ -64,0 +66,2 @@\n+      \/\/ Special handling for humongous regions to get somewhat better\n+      \/\/ work distribution.\n@@ -66,9 +70,4 @@\n-    } else if (r->is_open_archive()) {\n-      \/\/ Only adjust the open archive regions, the closed ones\n-      \/\/ never change.\n-      G1AdjustLiveClosure adjust(&cl);\n-      r->apply_to_marked_objects(_bitmap, &adjust);\n-      \/\/ Open archive regions will not be compacted and the marking information is\n-      \/\/ no longer needed. Clear it here to avoid having to do it later.\n-      _bitmap->clear_region(r);\n-    } else {\n+    } else if (!(r->is_closed_archive() || r->is_free())) {\n+      \/\/ Closed archive regions never change references and only contain\n+      \/\/ references into other closed regions and are always live. Free\n+      \/\/ regions do not contain objects to iterate. So skip both.\n@@ -88,1 +87,1 @@\n-    _adjust(),\n+    _adjust(collector),\n@@ -119,1 +118,1 @@\n-  G1AdjustRegionClosure blk(collector()->mark_bitmap(), worker_id);\n+  G1AdjustRegionClosure blk(collector(), collector()->mark_bitmap(), worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-class G1ResetHumongousClosure : public HeapRegionClosure {\n+class G1ResetPinnedClosure : public HeapRegionClosure {\n@@ -41,2 +41,1 @@\n-  G1ResetHumongousClosure(G1CMBitMap* bitmap) :\n-      _bitmap(bitmap) { }\n+  G1ResetPinnedClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n@@ -44,13 +43,3 @@\n-  bool do_heap_region(HeapRegion* current) {\n-    if (current->is_humongous()) {\n-      if (current->is_starts_humongous()) {\n-        oop obj = oop(current->bottom());\n-        if (_bitmap->is_marked(obj)) {\n-          \/\/ Clear bitmap and fix mark word.\n-          _bitmap->clear(obj);\n-          obj->init_mark();\n-        } else {\n-          assert(current->is_empty(), \"Should have been cleared in phase 2.\");\n-        }\n-      }\n-      current->reset_humongous_during_compaction();\n+  bool do_heap_region(HeapRegion* r) {\n+    if (!r->is_pinned()) {\n+      return false;\n@@ -58,0 +47,3 @@\n+    assert(!r->is_starts_humongous() || _bitmap->is_marked((oop)r->bottom()),\n+           \"must be, otherwise reclaimed earlier\");\n+    r->pinned_complete_compaction();\n@@ -81,0 +73,1 @@\n+  assert(!hr->is_pinned(), \"Should be no pinned region in compaction queue\");\n@@ -84,4 +77,6 @@\n-  \/\/ Once all objects have been moved the liveness information\n-  \/\/ needs be cleared.\n-  collector()->mark_bitmap()->clear_region(hr);\n-  hr->complete_compaction();\n+  \/\/ Clear the liveness information for this region if necessary i.e. if we actually look at it\n+  \/\/ for bitmap verification. Otherwise it is sufficient that we move the TAMS to bottom().\n+  if (G1VerifyBitmaps) {\n+    collector()->mark_bitmap()->clear_region(hr);\n+  }\n+  hr->non_pinned_complete_compaction();\n@@ -99,1 +94,1 @@\n-  G1ResetHumongousClosure hc(collector()->mark_bitmap());\n+  G1ResetPinnedClosure hc(collector()->mark_bitmap());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n-G1FullGCMarker::G1FullGCMarker(uint worker_id, PreservedMarks* preserved_stack, G1CMBitMap* bitmap) :\n+G1FullGCMarker::G1FullGCMarker(uint worker_id,\n+                               PreservedMarks* preserved_stack,\n+                               G1CMBitMap* bitmap) :\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class G1FullCollector;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1FullCollector.hpp\"\n@@ -41,1 +42,0 @@\n-  \/\/ Not marking closed archive objects.\n@@ -55,1 +55,3 @@\n-      !G1ArchiveAllocator::is_open_archive_object(obj)) {\n+      \/\/ It is not necessary to preserve marks for objects in pinned regions because\n+      \/\/ we do not change their headers (i.e. forward them).\n+      !G1CollectedHeap::heap()->heap_region_containing(obj)->is_pinned()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,1 +78,3 @@\n-  template <class T> static inline void adjust_pointer(T* p);\n+  G1FullCollector* _collector;\n+\n+  template <class T> inline void adjust_pointer(T* p);\n@@ -80,0 +82,1 @@\n+  G1AdjustClosure(G1FullCollector* collector) : _collector(collector) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1FullCollector.hpp\"\n@@ -72,2 +73,3 @@\n-  if (G1ArchiveAllocator::is_archived_object(obj)) {\n-    \/\/ We never forward archive objects.\n+  if (_collector->is_in_pinned_or_closed(obj)) {\n+    \/\/ We never forward objects in pinned regions so there is no need to\n+    \/\/ process them further.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,5 +43,8 @@\n-  if (hr->is_humongous()) {\n-    oop obj = oop(hr->humongous_start_region()->bottom());\n-    if (_bitmap->is_marked(obj)) {\n-      if (hr->is_starts_humongous()) {\n-        obj->forward_to(obj);\n+  if (hr->is_pinned()) {\n+    \/\/ There is no need to iterate and forward objects in pinned regions ie.\n+    \/\/ prepare them for compaction. The adjust pointers phase will skip\n+    \/\/ work for them.\n+    if (hr->is_humongous()) {\n+      oop obj = oop(hr->humongous_start_region()->bottom());\n+      if (!_bitmap->is_marked(obj)) {\n+        free_humongous_region(hr);\n@@ -50,1 +53,1 @@\n-      free_humongous_region(hr);\n+      assert(hr->is_archive(), \"Only archive regions can also be pinned.\");\n@@ -52,1 +55,2 @@\n-  } else if (!hr->is_pinned()) {\n+  } else {\n+    assert(!hr->is_humongous(), \"moving humongous objects not supported.\");\n@@ -59,0 +63,2 @@\n+  _collector->update_attribute_table(hr);\n+\n@@ -81,1 +87,1 @@\n-  G1CalculatePointersClosure closure(collector()->mark_bitmap(), compaction_point);\n+  G1CalculatePointersClosure closure(collector(), collector()->mark_bitmap(), compaction_point);\n@@ -95,1 +101,2 @@\n-G1FullGCPrepareTask::G1CalculatePointersClosure::G1CalculatePointersClosure(G1CMBitMap* bitmap,\n+G1FullGCPrepareTask::G1CalculatePointersClosure::G1CalculatePointersClosure(G1FullCollector* collector,\n+                                                                            G1CMBitMap* bitmap,\n@@ -98,0 +105,1 @@\n+    _collector(collector),\n@@ -103,1 +111,3 @@\n-  FreeRegionList dummy_free_list(\"Dummy Free List for G1MarkSweep\");\n+  assert(hr->is_humongous(), \"handled elsewhere\");\n+\n+  FreeRegionList dummy_free_list(\"Humongous Dummy Free List for G1MarkSweep\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class G1FullCollector;\n@@ -55,0 +56,1 @@\n+    G1FullCollector* _collector;\n@@ -65,1 +67,2 @@\n-    G1CalculatePointersClosure(G1CMBitMap* bitmap,\n+    G1CalculatePointersClosure(G1FullCollector* collector,\n+                               G1CMBitMap* bitmap,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  void reset_after_compaction() { set_top(compaction_top()); }\n+  void reset_after_compaction();\n@@ -168,4 +168,0 @@\n-  \/\/ Update heap region to be consistent after Full GC compaction.\n-  void reset_humongous_during_compaction() {\n-    assert(is_humongous(),\n-           \"should only be called for humongous regions\");\n@@ -173,5 +169,5 @@\n-    zero_marked_bytes();\n-    init_top_at_mark_start();\n-  }\n-  \/\/ Update heap region to be consistent after Full GC compaction.\n-  void complete_compaction();\n+  \/\/ Update heap region to be consistent after Full GC compaction for non-pinned\n+  \/\/ regions.\n+  void non_pinned_complete_compaction();\n+  void pinned_complete_compaction();\n+  void complete_compaction_common();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -184,2 +184,8 @@\n-inline void HeapRegion::complete_compaction() {\n-  \/\/ Reset space and bot after compaction is complete if needed.\n+inline void HeapRegion::reset_after_compaction() {\n+  set_top(compaction_top());\n+  _compaction_top = bottom();\n+}\n+\n+inline void HeapRegion::non_pinned_complete_compaction() {\n+  assert(!is_pinned(), \"must be\");\n+\n@@ -187,0 +193,25 @@\n+  \/\/ After a compaction the mark bitmap in a non-pinned regions is invalid.\n+  \/\/ We treat all objects as being above PTAMS.\n+  zero_marked_bytes();\n+  init_top_at_mark_start();\n+\n+  complete_compaction_common();\n+}\n+\n+inline void HeapRegion::pinned_complete_compaction() {\n+  assert(!is_free(), \"should not have compacted free region\");\n+  assert(is_pinned(), \"must be\");\n+\n+  assert(compaction_top() == bottom(),\n+         \"region %u compaction_top \" PTR_FORMAT \" must not be different from bottom \" PTR_FORMAT,\n+         hrm_index(), p2i(compaction_top()), p2i(bottom()));\n+\n+  _prev_top_at_mark_start = top(); \/\/ Keep existing top and usage.\n+  _prev_marked_bytes = used();\n+  _next_top_at_mark_start = bottom();\n+  _next_marked_bytes = 0;\n+\n+  complete_compaction_common();\n+}\n+\n+inline void HeapRegion::complete_compaction_common() {\n@@ -191,5 +222,0 @@\n-  \/\/ After a compaction the mark bitmap is invalid, so we must\n-  \/\/ treat all objects as being inside the unmarked area.\n-  zero_marked_bytes();\n-  init_top_at_mark_start();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":33,"deletions":7,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+  static T* create(size_t length, void** alloc_base);\n","filename":"src\/hotspot\/share\/memory\/padded.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,0 +85,6 @@\n+  void* temp;\n+  return create(length, &temp);\n+}\n+\n+template <class T, MEMFLAGS flags, size_t alignment>\n+T* PaddedPrimitiveArray<T, flags, alignment>::create(size_t length, void** alloc_base) {\n@@ -90,0 +96,1 @@\n+  *alloc_base = chunk;\n","filename":"src\/hotspot\/share\/memory\/padded.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}