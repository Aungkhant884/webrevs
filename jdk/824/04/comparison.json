{"files":[{"patch":"@@ -401,3 +401,0 @@\n-bool G1ArchiveAllocator::_archive_check_enabled = false;\n-G1ArchiveRegionMap G1ArchiveAllocator::_archive_region_map;\n-\n@@ -405,5 +402,1 @@\n-  \/\/ Create the archive allocator, and also enable archive object checking\n-  \/\/ in mark-sweep, since we will be creating archive regions.\n-  G1ArchiveAllocator* result =  new G1ArchiveAllocator(g1h, open);\n-  enable_archive_object_check();\n-  return result;\n+  return new G1ArchiveAllocator(g1h, open);\n@@ -437,3 +430,0 @@\n-  \/\/ Tell mark-sweep that objects in this region are not to be marked.\n-  set_range_archive(MemRegion(_bottom, HeapRegion::GrainWords), _open);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -195,13 +195,0 @@\n-\/\/ G1ArchiveRegionMap is an array used to mark G1 regions as\n-\/\/ archive regions.  This allows a quick check for whether an object\n-\/\/ should not be marked because it is in an archive region.\n-class G1ArchiveRegionMap : public G1BiasedMappedArray<uint8_t> {\n-public:\n-  static const uint8_t NoArchive = 0;\n-  static const uint8_t OpenArchive = 1;\n-  static const uint8_t ClosedArchive = 2;\n-\n-protected:\n-  uint8_t default_value() const { return NoArchive; }\n-};\n-\n@@ -281,27 +268,0 @@\n-\n-  \/\/ Create the _archive_region_map which is used to identify archive objects.\n-  static inline void enable_archive_object_check();\n-\n-  \/\/ Mark regions containing the specified address range as archive\/non-archive.\n-  static inline void set_range_archive(MemRegion range, bool open);\n-  static inline void clear_range_archive(MemRegion range);\n-\n-  \/\/ Check if the object is in closed archive\n-  static inline bool is_closed_archive_object(oop object);\n-  \/\/ Check if the object is in open archive\n-  static inline bool is_open_archive_object(oop object);\n-  \/\/ Check if the object is either in closed archive or open archive\n-  static inline bool is_archived_object(oop object);\n-\n-private:\n-  static bool _archive_check_enabled;\n-  static G1ArchiveRegionMap  _archive_region_map;\n-\n-  \/\/ Check if an object is in a closed archive region using the _closed_archive_region_map.\n-  static inline bool in_closed_archive_range(oop object);\n-  \/\/ Check if an object is in open archive region using the _open_archive_region_map.\n-  static inline bool in_open_archive_range(oop object);\n-\n-  \/\/ Check if archive object checking is enabled, to avoid calling in_open\/closed_archive_range\n-  \/\/ unnecessarily.\n-  static inline bool archive_check_enabled();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -122,59 +122,0 @@\n-\/\/ Create the maps which is used to identify archive objects.\n-inline void G1ArchiveAllocator::enable_archive_object_check() {\n-  if (_archive_check_enabled) {\n-    return;\n-  }\n-\n-  _archive_check_enabled = true;\n-  _archive_region_map.initialize(G1CollectedHeap::heap()->reserved(),\n-                                 HeapRegion::GrainBytes);\n-}\n-\n-\/\/ Set the regions containing the specified address range as archive.\n-inline void G1ArchiveAllocator::set_range_archive(MemRegion range, bool open) {\n-  assert(_archive_check_enabled, \"archive range check not enabled\");\n-  log_info(gc, cds)(\"Mark %s archive regions in map: [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-                     open ? \"open\" : \"closed\",\n-                     p2i(range.start()),\n-                     p2i(range.last()));\n-  uint8_t const value = open ? G1ArchiveRegionMap::OpenArchive : G1ArchiveRegionMap::ClosedArchive;\n-  _archive_region_map.set_by_address(range, value);\n-}\n-\n-\/\/ Clear the archive regions map containing the specified address range.\n-inline void G1ArchiveAllocator::clear_range_archive(MemRegion range) {\n-  assert(_archive_check_enabled, \"archive range check not enabled\");\n-  log_info(gc, cds)(\"Clear archive regions in map: [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-                    p2i(range.start()),\n-                    p2i(range.last()));\n-  _archive_region_map.set_by_address(range, G1ArchiveRegionMap::NoArchive);\n-}\n-\n-\/\/ Check if an object is in a closed archive region using the _archive_region_map.\n-inline bool G1ArchiveAllocator::in_closed_archive_range(oop object) {\n-  return _archive_region_map.get_by_address(cast_from_oop<HeapWord*>(object)) == G1ArchiveRegionMap::ClosedArchive;\n-}\n-\n-inline bool G1ArchiveAllocator::in_open_archive_range(oop object) {\n-  return _archive_region_map.get_by_address(cast_from_oop<HeapWord*>(object)) == G1ArchiveRegionMap::OpenArchive;\n-}\n-\n-\/\/ Check if archive object checking is enabled, to avoid calling in_open\/closed_archive_range\n-\/\/ unnecessarily.\n-inline bool G1ArchiveAllocator::archive_check_enabled() {\n-  return _archive_check_enabled;\n-}\n-\n-inline bool G1ArchiveAllocator::is_closed_archive_object(oop object) {\n-  return (archive_check_enabled() && in_closed_archive_range(object));\n-}\n-\n-inline bool G1ArchiveAllocator::is_open_archive_object(oop object) {\n-  return (archive_check_enabled() && in_open_archive_range(object));\n-}\n-\n-inline bool G1ArchiveAllocator::is_archived_object(oop object) {\n-  return archive_check_enabled() &&\n-         (_archive_region_map.get_by_address(cast_from_oop<HeapWord*>(object)) != G1ArchiveRegionMap::NoArchive);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":0,"deletions":59,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -573,4 +573,0 @@\n-  \/\/ Enable archive object checking used by G1MarkSweep. We have to let it know\n-  \/\/ about each archive range, so that objects in those ranges aren't marked.\n-  G1ArchiveAllocator::enable_archive_object_check();\n-\n@@ -652,3 +648,0 @@\n-\n-    \/\/ Notify mark-sweep of the archive\n-    G1ArchiveAllocator::set_range_archive(curr_range, open);\n@@ -805,3 +798,0 @@\n-\n-    \/\/ Notify mark-sweep that this is no longer an archive range.\n-    G1ArchiveAllocator::clear_range_archive(ranges[i]);\n@@ -818,2 +808,1 @@\n-  assert(obj != NULL, \"archived obj is NULL\");\n-  assert(G1ArchiveAllocator::is_archived_object(obj), \"must be archived object\");\n+  assert(is_archived_object(obj), \"not an archived obj\");\n@@ -1019,2 +1008,1 @@\n-  tear_down_region_sets(false \/* free_list_only *\/);\n-\n+  hrm()->remove_all_free_regions();\n@@ -1076,11 +1064,1 @@\n-  \/\/ Clear the previous marking bitmap, if needed for bitmap verification.\n-  \/\/ Note we cannot do this when we clear the next marking bitmap in\n-  \/\/ G1ConcurrentMark::abort() above since VerifyDuringGC verifies the\n-  \/\/ objects marked during a full GC against the previous bitmap.\n-  \/\/ But we need to clear it before calling check_bitmaps below since\n-  \/\/ the full GC has compacted objects and updated TAMS but not updated\n-  \/\/ the prev bitmap.\n-  if (G1VerifyBitmaps) {\n-    GCTraceTime(Debug, gc) tm(\"Clear Prev Bitmap for Verification\");\n-    _cm->clear_prev_bitmap(workers());\n-  }\n+\n@@ -1350,1 +1328,1 @@\n-  tear_down_region_sets(true \/* free_list_only *\/);\n+  hrm()->remove_all_free_regions();\n@@ -2398,0 +2376,4 @@\n+bool G1CollectedHeap::is_archived_object(oop object) const {\n+  return object != NULL && heap_region_containing(object)->is_archive();\n+}\n+\n@@ -4568,33 +4550,5 @@\n-class TearDownRegionSetsClosure : public HeapRegionClosure {\n-  HeapRegionSet *_old_set;\n-\n-public:\n-  TearDownRegionSetsClosure(HeapRegionSet* old_set) : _old_set(old_set) { }\n-\n-  bool do_heap_region(HeapRegion* r) {\n-    if (r->is_old()) {\n-      _old_set->remove(r);\n-    } else if(r->is_young()) {\n-      r->uninstall_surv_rate_group();\n-    } else {\n-      \/\/ We ignore free regions, we'll empty the free list afterwards.\n-      \/\/ We ignore humongous and archive regions, we're not tearing down these\n-      \/\/ sets.\n-      assert(r->is_archive() || r->is_free() || r->is_humongous(),\n-             \"it cannot be another type\");\n-    }\n-    return false;\n-  }\n-\n-  ~TearDownRegionSetsClosure() {\n-    assert(_old_set->is_empty(), \"post-condition\");\n-  }\n-};\n-\n-void G1CollectedHeap::tear_down_region_sets(bool free_list_only) {\n-  assert_at_safepoint_on_vm_thread();\n-\n-  if (!free_list_only) {\n-    TearDownRegionSetsClosure cl(&_old_set);\n-    heap_region_iterate(&cl);\n-\n+  \/\/ Remove the given HeapRegion from the appropriate region set.\n+void G1CollectedHeap::prepare_region_for_full_compaction(HeapRegion* hr) {\n+  if (hr->is_old()) {\n+    _old_set.remove(hr);\n+  } else if (hr->is_young()) {\n@@ -4605,0 +4559,7 @@\n+    hr->uninstall_surv_rate_group();\n+  } else {\n+    \/\/ We ignore free regions, we'll empty the free list afterwards.\n+    \/\/ We ignore humongous and archive regions, we're not tearing down these\n+    \/\/ sets.\n+    assert(hr->is_archive() || hr->is_free() || hr->is_humongous(),\n+           \"it cannot be another type\");\n@@ -4606,1 +4567,0 @@\n-  _hrm->remove_all_free_regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":20,"deletions":60,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -180,7 +180,2 @@\n-  \/\/ Tears down the region sets \/ lists so that they are empty and the\n-  \/\/ regions on the heap do not belong to a region set \/ list. The\n-  \/\/ only exception is the humongous set which we leave unaltered. If\n-  \/\/ free_list_only is true, it will only tear down the master free\n-  \/\/ list. It is called before a Full GC (free_list_only == false) or\n-  \/\/ before heap shrinking (free_list_only == true).\n-  void tear_down_region_sets(bool free_list_only);\n+public:\n+  void prepare_region_for_full_compaction(HeapRegion* hr);\n@@ -188,0 +183,1 @@\n+private:\n@@ -191,3 +187,1 @@\n-  \/\/ free_list_only is true, it will only rebuild the master free\n-  \/\/ list. It is called after a Full GC (free_list_only == false) or\n-  \/\/ after heap shrinking (free_list_only == true).\n+  \/\/ free_list_only is true, it will only rebuild the free list.\n@@ -1427,0 +1421,2 @@\n+  virtual bool is_archived_object(oop object) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,6 @@\n-    guarantee(G1CollectionSetChooser::should_add(cur), \"Region %u should be eligible for addition.\", cur->hrm_index());\n+    \/\/ The first disjunction filters out regions with objects that were explicitly\n+    \/\/ pinned after being added to the collection set candidates. Archive regions\n+    \/\/ should never have been added to the collection set though.\n+    guarantee((cur->is_pinned() && !cur->is_archive()) ||\n+              G1CollectionSetChooser::should_add(cur),\n+              \"Region %u should be eligible for addition.\", cur->hrm_index());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-void G1ConcurrentMark::clear_prev_bitmap(WorkGang* workers) {\n+void G1ConcurrentMark::clear_next_bitmap(WorkGang* workers) {\n@@ -680,1 +680,1 @@\n-  clear_bitmap(_prev_mark_bitmap, workers, false);\n+  clear_bitmap(_next_mark_bitmap, workers, false);\n@@ -1135,0 +1135,2 @@\n+\n+    _g1h->collector_state()->set_clearing_next_bitmap(true);\n@@ -1699,1 +1701,0 @@\n-  _g1h->collector_state()->set_clearing_next_bitmap(true);\n@@ -1978,1 +1979,1 @@\n-    clear_bitmap(_next_mark_bitmap, _g1h->workers(), false);\n+    clear_next_bitmap(_g1h->workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -377,2 +377,0 @@\n-  void swap_mark_bitmaps();\n-\n@@ -542,2 +540,2 @@\n-  \/\/ Clear the previous marking bitmap during safepoint.\n-  void clear_prev_bitmap(WorkGang* workers);\n+  \/\/ Clear the next marking bitmap during safepoint.\n+  void clear_next_bitmap(WorkGang* workers);\n@@ -566,0 +564,2 @@\n+  void swap_mark_bitmaps();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1FullCollector.hpp\"\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n@@ -114,1 +114,1 @@\n-    _is_alive(heap->concurrent_mark()->next_mark_bitmap()),\n+    _is_alive(this, heap->concurrent_mark()->next_mark_bitmap()),\n@@ -117,1 +117,2 @@\n-    _is_subject_mutator(heap->ref_processor_stw(), &_always_subject_to_discovery) {\n+    _is_subject_mutator(heap->ref_processor_stw(), &_always_subject_to_discovery),\n+    _region_attr_table() {\n@@ -124,1 +125,1 @@\n-    _markers[i] = new G1FullGCMarker(i, _preserved_marks_set.get(i), mark_bitmap());\n+    _markers[i] = new G1FullGCMarker(this, i, _preserved_marks_set.get(i));\n@@ -129,0 +130,1 @@\n+  _region_attr_table.initialize(heap->reserved(), HeapRegion::GrainBytes);\n@@ -140,0 +142,13 @@\n+class PrepareRegionsClosure : public HeapRegionClosure {\n+  G1FullCollector* _collector;\n+\n+public:\n+  PrepareRegionsClosure(G1FullCollector* collector) : _collector(collector) { }\n+\n+  bool do_heap_region(HeapRegion* hr) {\n+    G1CollectedHeap::heap()->prepare_region_for_full_compaction(hr);\n+    _collector->update_attribute_table(hr);\n+    return false;\n+  }\n+};\n+\n@@ -152,0 +167,3 @@\n+  PrepareRegionsClosure cl(this);\n+  _heap->heap_region_iterate(&cl);\n+\n@@ -187,0 +205,4 @@\n+  _heap->concurrent_mark()->swap_mark_bitmaps();\n+  \/\/ Prepare the bitmap for the next (potentially concurrent) marking.\n+  _heap->concurrent_mark()->clear_next_bitmap(_heap->workers());\n+\n@@ -197,0 +219,13 @@\n+void G1FullCollector::update_attribute_table(HeapRegion* hr) {\n+  if (hr->is_free()) {\n+    return;\n+  }\n+  if (hr->is_closed_archive()) {\n+    _region_attr_table.set_closed_archive(hr->hrm_index());\n+  } else if (hr->is_pinned()) {\n+    _region_attr_table.set_pinned_or_closed(hr->hrm_index());\n+  } else {\n+    _region_attr_table.set_normal(hr->hrm_index());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1FullGCHeapRegionAttr.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -74,0 +76,2 @@\n+  G1FullGCHeapRegionAttr _region_attr_table;\n+\n@@ -93,0 +97,6 @@\n+  void update_attribute_table(HeapRegion* hr);\n+\n+  inline bool is_in_pinned_or_closed(oop obj) const;\n+  inline bool is_in_pinned(oop obj) const;\n+  inline bool is_in_closed(oop obj) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1FULLCOLLECTOR_INLINE_HPP\n+#define SHARE_GC_G1_G1FULLCOLLECTOR_INLINE_HPP\n+\n+#include \"gc\/g1\/g1FullCollector.hpp\"\n+#include \"gc\/g1\/g1FullGCHeapRegionAttr.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+bool G1FullCollector::is_in_pinned_or_closed(oop obj) const {\n+  return _region_attr_table.is_pinned_or_closed(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+bool G1FullCollector::is_in_pinned(oop obj) const {\n+  return _region_attr_table.is_pinned(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+bool G1FullCollector::is_in_closed(oop obj) const {\n+  return _region_attr_table.is_closed_archive(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1FULLCOLLECTOR_INLINE_HPP\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1FullCollector.hpp\"\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n@@ -54,0 +54,1 @@\n+  G1FullCollector* _collector;\n@@ -57,2 +58,3 @@\n-  G1AdjustRegionClosure(G1CMBitMap* bitmap, uint worker_id) :\n-    _bitmap(bitmap),\n+  G1AdjustRegionClosure(G1FullCollector* collector, uint worker_id) :\n+    _collector(collector),\n+    _bitmap(collector->mark_bitmap()),\n@@ -62,1 +64,1 @@\n-    G1AdjustClosure cl;\n+    G1AdjustClosure cl(_collector);\n@@ -64,0 +66,2 @@\n+      \/\/ Special handling for humongous regions to get somewhat better\n+      \/\/ work distribution.\n@@ -66,9 +70,4 @@\n-    } else if (r->is_open_archive()) {\n-      \/\/ Only adjust the open archive regions, the closed ones\n-      \/\/ never change.\n-      G1AdjustLiveClosure adjust(&cl);\n-      r->apply_to_marked_objects(_bitmap, &adjust);\n-      \/\/ Open archive regions will not be compacted and the marking information is\n-      \/\/ no longer needed. Clear it here to avoid having to do it later.\n-      _bitmap->clear_region(r);\n-    } else {\n+    } else if (!r->is_closed_archive() && !r->is_free()) {\n+      \/\/ Closed archive regions never change references and only contain\n+      \/\/ references into other closed regions and are always live. Free\n+      \/\/ regions do not contain objects to iterate. So skip both.\n@@ -88,1 +87,1 @@\n-    _adjust(),\n+    _adjust(collector),\n@@ -119,1 +118,1 @@\n-  G1AdjustRegionClosure blk(collector()->mark_bitmap(), worker_id);\n+  G1AdjustRegionClosure blk(collector(), worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-class G1ResetHumongousClosure : public HeapRegionClosure {\n+class G1ResetPinnedClosure : public HeapRegionClosure {\n@@ -41,2 +41,1 @@\n-  G1ResetHumongousClosure(G1CMBitMap* bitmap) :\n-      _bitmap(bitmap) { }\n+  G1ResetPinnedClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n@@ -44,13 +43,3 @@\n-  bool do_heap_region(HeapRegion* current) {\n-    if (current->is_humongous()) {\n-      if (current->is_starts_humongous()) {\n-        oop obj = oop(current->bottom());\n-        if (_bitmap->is_marked(obj)) {\n-          \/\/ Clear bitmap and fix mark word.\n-          _bitmap->clear(obj);\n-          obj->init_mark();\n-        } else {\n-          assert(current->is_empty(), \"Should have been cleared in phase 2.\");\n-        }\n-      }\n-      current->reset_humongous_during_compaction();\n+  bool do_heap_region(HeapRegion* r) {\n+    if (!r->is_pinned()) {\n+      return false;\n@@ -58,0 +47,3 @@\n+    assert(!r->is_starts_humongous() || _bitmap->is_marked((oop)r->bottom()),\n+           \"must be, otherwise reclaimed earlier\");\n+    r->reset_pinned_after_full_gc();\n@@ -81,0 +73,1 @@\n+  assert(!hr->is_pinned(), \"Should be no pinned region in compaction queue\");\n@@ -84,4 +77,6 @@\n-  \/\/ Once all objects have been moved the liveness information\n-  \/\/ needs be cleared.\n-  collector()->mark_bitmap()->clear_region(hr);\n-  hr->complete_compaction();\n+  \/\/ Clear the liveness information for this region if necessary i.e. if we actually look at it\n+  \/\/ for bitmap verification. Otherwise it is sufficient that we move the TAMS to bottom().\n+  if (G1VerifyBitmaps) {\n+    collector()->mark_bitmap()->clear_region(hr);\n+  }\n+  hr->reset_compacted_after_full_gc();\n@@ -99,1 +94,1 @@\n-  G1ResetHumongousClosure hc(collector()->mark_bitmap());\n+  G1ResetPinnedClosure hc(collector()->mark_bitmap());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1FULLGCHEAPREGIONATTR_HPP\n+#define SHARE_GC_G1_G1FULLGCHEAPREGIONATTR_HPP\n+\n+#include \"gc\/g1\/g1BiasedArray.hpp\"\n+\n+\/\/ This table is used to store some per-region attributes needed during full\n+\/\/ collection.\n+class G1FullGCHeapRegionAttr : public G1BiasedMappedArray<uint8_t> {\n+  static const uint8_t Normal = 0;\n+  static const uint8_t Pinned = 1;\n+  static const uint8_t ClosedArchive = 2;\n+\n+  STATIC_ASSERT(ClosedArchive > Pinned);\n+\n+  static const uint8_t Invalid = 255;\n+\n+  bool is_invalid(HeapWord* obj) const {\n+    return get_by_address(obj) == Invalid;\n+  }\n+\n+protected:\n+  uint8_t default_value() const { return Invalid; }\n+\n+public:\n+  void set_closed_archive(uint idx) { set_by_index(idx, ClosedArchive); }\n+\n+  bool is_closed_archive(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) == ClosedArchive;\n+  }\n+\n+  void set_pinned_or_closed(uint idx) { set_by_index(idx, Pinned); }\n+\n+  bool is_pinned_or_closed(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) >= Pinned;\n+  }\n+\n+  bool is_pinned(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) == Pinned;\n+  }\n+\n+  void set_normal(uint idx) { set_by_index(idx, Normal); }\n+\n+  bool is_normal(HeapWord* obj) const {\n+    assert(!is_invalid(obj), \"not initialized yet\");\n+    return get_by_address(obj) == Normal;\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1FULLGCHEAPREGIONATTR_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -33,1 +33,4 @@\n-G1FullGCMarker::G1FullGCMarker(uint worker_id, PreservedMarks* preserved_stack, G1CMBitMap* bitmap) :\n+G1FullGCMarker::G1FullGCMarker(G1FullCollector* collector,\n+                               uint worker_id,\n+                               PreservedMarks* preserved_stack) :\n+    _collector(collector),\n@@ -35,1 +38,1 @@\n-    _bitmap(bitmap),\n+    _bitmap(collector->mark_bitmap()),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class G1FullCollector;\n@@ -48,0 +49,2 @@\n+  G1FullCollector*   _collector;\n+\n@@ -74,1 +77,1 @@\n-  G1FullGCMarker(uint worker_id, PreservedMarks* preserved_stack, G1CMBitMap* bitmap);\n+  G1FullGCMarker(G1FullCollector* collector, uint worker_id, PreservedMarks* preserved_stack);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n@@ -42,2 +43,1 @@\n-  \/\/ Not marking closed archive objects.\n-  if (G1ArchiveAllocator::is_closed_archive_object(obj)) {\n+  if (_collector->is_in_closed(obj)) {\n@@ -56,1 +56,3 @@\n-      !G1ArchiveAllocator::is_open_archive_object(obj)) {\n+      \/\/ It is not necessary to preserve marks for objects in pinned regions because\n+      \/\/ we do not change their headers (i.e. forward them).\n+      !_collector->is_in_pinned(obj)) {\n@@ -76,1 +78,1 @@\n-      assert(_bitmap->is_marked(obj) || G1ArchiveAllocator::is_closed_archive_object(obj),\n+      assert(_bitmap->is_marked(obj) || _collector->is_in_closed(obj),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1FullCollector.hpp\"\n@@ -35,0 +36,3 @@\n+G1IsAliveClosure::G1IsAliveClosure(G1FullCollector* collector) :\n+  G1IsAliveClosure(collector, collector->mark_bitmap()) { }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+  G1FullCollector* _collector;\n@@ -41,1 +42,3 @@\n-  G1IsAliveClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n+  G1IsAliveClosure(G1FullCollector* collector);\n+  G1IsAliveClosure(G1FullCollector* collector, G1CMBitMap* bitmap) :\n+    _collector(collector), _bitmap(bitmap) { }\n@@ -78,1 +81,3 @@\n-  template <class T> static inline void adjust_pointer(T* p);\n+  G1FullCollector* _collector;\n+\n+  template <class T> inline void adjust_pointer(T* p);\n@@ -80,0 +85,1 @@\n+  G1AdjustClosure(G1FullCollector* collector) : _collector(collector) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n@@ -72,2 +73,3 @@\n-  if (G1ArchiveAllocator::is_archived_object(obj)) {\n-    \/\/ We never forward archive objects.\n+  if (_collector->is_in_pinned_or_closed(obj)) {\n+    \/\/ We never forward objects in pinned regions so there is no need to\n+    \/\/ process them further.\n@@ -97,1 +99,1 @@\n-  return _bitmap->is_marked(p) || G1ArchiveAllocator::is_closed_archive_object(p);\n+  return _bitmap->is_marked(p) || _collector->is_in_closed(p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,5 +43,8 @@\n-  if (hr->is_humongous()) {\n-    oop obj = oop(hr->humongous_start_region()->bottom());\n-    if (_bitmap->is_marked(obj)) {\n-      if (hr->is_starts_humongous()) {\n-        obj->forward_to(obj);\n+  if (hr->is_pinned()) {\n+    \/\/ There is no need to iterate and forward objects in pinned regions ie.\n+    \/\/ prepare them for compaction. The adjust pointers phase will skip\n+    \/\/ work for them.\n+    if (hr->is_humongous()) {\n+      oop obj = oop(hr->humongous_start_region()->bottom());\n+      if (!_bitmap->is_marked(obj)) {\n+        free_humongous_region(hr);\n@@ -50,1 +53,1 @@\n-      free_humongous_region(hr);\n+      assert(hr->is_archive(), \"Only archive regions can also be pinned.\");\n@@ -52,1 +55,2 @@\n-  } else if (!hr->is_pinned()) {\n+  } else {\n+    assert(!hr->is_humongous(), \"moving humongous objects not supported.\");\n@@ -59,0 +63,2 @@\n+  _collector->update_attribute_table(hr);\n+\n@@ -81,1 +87,1 @@\n-  G1CalculatePointersClosure closure(collector()->mark_bitmap(), compaction_point);\n+  G1CalculatePointersClosure closure(collector(), compaction_point);\n@@ -95,1 +101,1 @@\n-G1FullGCPrepareTask::G1CalculatePointersClosure::G1CalculatePointersClosure(G1CMBitMap* bitmap,\n+G1FullGCPrepareTask::G1CalculatePointersClosure::G1CalculatePointersClosure(G1FullCollector* collector,\n@@ -98,1 +104,2 @@\n-    _bitmap(bitmap),\n+    _collector(collector),\n+    _bitmap(collector->mark_bitmap()),\n@@ -103,1 +110,3 @@\n-  FreeRegionList dummy_free_list(\"Dummy Free List for G1MarkSweep\");\n+  assert(hr->is_humongous(), \"must be but region %u is %s\", hr->hrm_index(), hr->get_short_type_str());\n+\n+  FreeRegionList dummy_free_list(\"Humongous Dummy Free List for G1MarkSweep\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+class G1FullCollector;\n@@ -55,0 +56,1 @@\n+    G1FullCollector* _collector;\n@@ -65,1 +67,1 @@\n-    G1CalculatePointersClosure(G1CMBitMap* bitmap,\n+    G1CalculatePointersClosure(G1FullCollector* collector,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  G1IsAliveClosure is_alive(_collector->mark_bitmap());\n+  G1IsAliveClosure is_alive(_collector);\n@@ -85,1 +85,1 @@\n-  G1IsAliveClosure is_alive(_collector->mark_bitmap());\n+  G1IsAliveClosure is_alive(_collector);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCReferenceProcessorExecutor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -243,2 +243,1 @@\n-  VerifyArchiveOopClosure(HeapRegion *hr)\n-    : _hr(hr) { }\n+  VerifyArchiveOopClosure(HeapRegion *hr) : _hr(hr) { }\n@@ -252,1 +251,1 @@\n-      guarantee(obj == NULL || G1ArchiveAllocator::is_archived_object(obj),\n+      guarantee(obj == NULL || G1CollectedHeap::heap()->heap_region_containing(obj)->is_archive(),\n@@ -257,1 +256,1 @@\n-      guarantee(obj == NULL || G1ArchiveAllocator::is_closed_archive_object(obj),\n+      guarantee(obj == NULL || G1CollectedHeap::heap()->heap_region_containing(obj)->is_closed_archive(),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -126,1 +126,3 @@\n-  void reset_after_compaction() { set_top(compaction_top()); }\n+  void reset_compaction_top_after_compaction();\n+\n+  void reset_after_full_gc_common();\n@@ -168,4 +170,0 @@\n-  \/\/ Update heap region to be consistent after Full GC compaction.\n-  void reset_humongous_during_compaction() {\n-    assert(is_humongous(),\n-           \"should only be called for humongous regions\");\n@@ -173,5 +171,4 @@\n-    zero_marked_bytes();\n-    init_top_at_mark_start();\n-  }\n-  \/\/ Update heap region to be consistent after Full GC compaction.\n-  void complete_compaction();\n+  \/\/ Update heap region that has been compacted to be consistent after Full GC.\n+  void reset_compacted_after_full_gc();\n+  \/\/ Update pinned heap region (not compacted) to be consistent after Full GC.\n+  void reset_pinned_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,6 +184,4 @@\n-inline void HeapRegion::complete_compaction() {\n-  \/\/ Reset space and bot after compaction is complete if needed.\n-  reset_after_compaction();\n-  if (is_empty()) {\n-    reset_bot();\n-  }\n+inline void HeapRegion::reset_compaction_top_after_compaction() {\n+  set_top(compaction_top());\n+  _compaction_top = bottom();\n+}\n@@ -191,2 +189,6 @@\n-  \/\/ After a compaction the mark bitmap is invalid, so we must\n-  \/\/ treat all objects as being inside the unmarked area.\n+inline void HeapRegion::reset_compacted_after_full_gc() {\n+  assert(!is_pinned(), \"must be\");\n+\n+  reset_compaction_top_after_compaction();\n+  \/\/ After a compaction the mark bitmap in a non-pinned regions is invalid.\n+  \/\/ We treat all objects as being above PTAMS.\n@@ -196,0 +198,24 @@\n+  reset_after_full_gc_common();\n+}\n+\n+inline void HeapRegion::reset_pinned_after_full_gc() {\n+  assert(!is_free(), \"should not have compacted free region\");\n+  assert(is_pinned(), \"must be\");\n+\n+  assert(compaction_top() == bottom(),\n+         \"region %u compaction_top \" PTR_FORMAT \" must not be different from bottom \" PTR_FORMAT,\n+         hrm_index(), p2i(compaction_top()), p2i(bottom()));\n+\n+  _prev_top_at_mark_start = top(); \/\/ Keep existing top and usage.\n+  _prev_marked_bytes = used();\n+  _next_top_at_mark_start = bottom();\n+  _next_marked_bytes = 0;\n+\n+  reset_after_full_gc_common();\n+}\n+\n+inline void HeapRegion::reset_after_full_gc_common() {\n+  if (is_empty()) {\n+    reset_bot();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -602,0 +602,4 @@\n+bool CollectedHeap::is_archived_object(oop object) const {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -513,0 +513,3 @@\n+  \/\/ Is the given object inside a CDS archive area?\n+  virtual bool is_archived_object(oop object) const;\n+\n@@ -517,1 +520,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"utilities\/copy.hpp\"\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n@@ -31,3 +32,0 @@\n-#if INCLUDE_G1GC\n-#include \"gc\/g1\/g1Allocator.inline.hpp\"\n-#endif\n@@ -38,1 +36,1 @@\n-  return (p == NULL) ? false : G1ArchiveAllocator::is_archived_object(p);\n+  return Universe::heap()->is_archived_object(p);\n","filename":"src\/hotspot\/share\/memory\/heapShared.inline.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}