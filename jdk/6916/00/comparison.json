{"files":[{"patch":"@@ -304,4 +304,1 @@\n-      \/\/ Specialized PLABs for old that handle BOT updates for object allocations.\n-      _alloc_buffers[state][node_index] = (state == G1HeapRegionAttr::Old)\n-                                        ? new G1BotUpdatingPLAB(word_sz)\n-                                        : new PLAB(word_sz);\n+      _alloc_buffers[state][node_index] = new PLAB(word_sz);\n@@ -367,1 +364,0 @@\n-    update_bot_for_direct_allocation(dest, result, word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -148,16 +148,0 @@\n-\/\/ Specialized PLAB for old generation promotions. For old regions the\n-\/\/ BOT needs to be updated and the relevant data to do this efficiently\n-\/\/ is stored in the PLAB.\n-class G1BotUpdatingPLAB : public PLAB {\n-  \/\/ An object spanning this threshold will cause a BOT update.\n-  HeapWord* _next_bot_threshold;\n-  \/\/ The region in which the PLAB resides.\n-  HeapRegion* _region;\n-public:\n-  G1BotUpdatingPLAB(size_t word_sz) : PLAB(word_sz) { }\n-  \/\/ Sets the new PLAB buffer as well as updates the threshold and region.\n-  void set_buf(HeapWord* buf, size_t word_sz) override;\n-  \/\/ Updates the BOT if the last allocation crossed the threshold.\n-  inline void update_bot(size_t word_sz);\n-};\n-\n@@ -184,3 +168,0 @@\n-  \/\/ Helpers to do explicit BOT updates for allocations in old generation regions.\n-  void update_bot_for_direct_allocation(G1HeapRegionAttr attr, HeapWord* addr, size_t size);\n-\n@@ -192,4 +173,0 @@\n-  \/\/ Returns if BOT updates are needed for the given destinaion. Currently we only have\n-  \/\/ two destinations and BOT updates are only needed for the old generation.\n-  inline bool needs_bot_update(G1HeapRegionAttr dest) const;\n-\n@@ -224,3 +201,0 @@\n-  \/\/ Update the BOT for the last PLAB allocation.\n-  inline void update_bot_for_plab_allocation(G1HeapRegionAttr dest, size_t word_sz, uint node_index);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -136,45 +136,0 @@\n-inline bool G1PLABAllocator::needs_bot_update(G1HeapRegionAttr dest) const {\n-  return dest.is_old();\n-}\n-\n-inline void G1PLABAllocator::update_bot_for_direct_allocation(G1HeapRegionAttr attr, HeapWord* addr, size_t size) {\n-  if (!needs_bot_update(attr)) {\n-    return;\n-  }\n-\n-  \/\/ Out of PLAB allocations in an old generation region. Update BOT.\n-  HeapRegion* region = _g1h->heap_region_containing(addr);\n-  region->update_bot_at(addr, size);\n-}\n-\n-inline void G1PLABAllocator::update_bot_for_plab_allocation(G1HeapRegionAttr dest, size_t word_sz, uint node_index) {\n-  assert(needs_bot_update(dest), \"Wrong destination: %s\", dest.get_type_str());\n-  G1BotUpdatingPLAB* plab = static_cast<G1BotUpdatingPLAB*>(alloc_buffer(dest, node_index));\n-  plab->update_bot(word_sz);\n-}\n-\n-inline void G1BotUpdatingPLAB::set_buf(HeapWord* buf, size_t word_sz) {\n-  PLAB::set_buf(buf, word_sz);\n-  \/\/ Update the region and threshold to allow efficient BOT updates.\n-  _region = G1CollectedHeap::heap()->heap_region_containing(buf);\n-  _next_bot_threshold = _region->bot_threshold_for_addr(buf);\n-}\n-\n-inline void G1BotUpdatingPLAB::update_bot(size_t word_sz) {\n-  \/\/ The last object end is at _top, if it did not cross the\n-  \/\/ threshold, there is nothing to do.\n-  if (_top <= _next_bot_threshold) {\n-    return;\n-  }\n-\n-  HeapWord* obj_start = _top - word_sz;\n-  assert(contains(obj_start),\n-         \"Object start outside PLAB. bottom: \" PTR_FORMAT \" object: \" PTR_FORMAT,\n-         p2i(_bottom), p2i(obj_start));\n-  assert(obj_start <= _next_bot_threshold,\n-         \"Object start not below or at threshold. threshold: \" PTR_FORMAT \" object: \" PTR_FORMAT,\n-         p2i(_next_bot_threshold), p2i(obj_start));\n-\n-  _region->update_bot_crossing_threshold(&_next_bot_threshold, obj_start, _top);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -167,2 +167,1 @@\n-  \/\/ Given an address calculate where the next threshold needing an update is.\n-  inline HeapWord* threshold_for_addr(const void* addr);\n+  inline HeapWord* align_up_by_card_size(HeapWord* const addr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-inline HeapWord* G1BlockOffsetTablePart::threshold_for_addr(const void* addr) {\n+inline HeapWord* G1BlockOffsetTablePart::align_up_by_card_size(HeapWord* const addr) const{\n@@ -36,10 +36,1 @@\n-  size_t index = _bot->index_for(addr);\n-  HeapWord* card_boundary = _bot->address_for_index(index);\n-  \/\/ Address at card boundary, use as threshold.\n-  if (card_boundary == addr) {\n-    return card_boundary;\n-  }\n-\n-  \/\/ Calculate next threshold.\n-  HeapWord* threshold = card_boundary + BOTConstants::card_size_in_words();\n-  return threshold;\n+  return align_up(addr, BOTConstants::card_size());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -437,0 +437,6 @@\n+void G1ParScanThreadState::update_bot_after_copying(oop obj, size_t word_sz) {\n+  HeapWord* obj_start = cast_from_oop<HeapWord*>(obj);\n+  HeapRegion* region = _g1h->heap_region_containing(obj_start);\n+  region->update_bot_if_crossing_boundary(obj_start, word_sz);\n+}\n+\n@@ -509,1 +515,1 @@\n-      _plab_allocator->update_bot_for_plab_allocation(dest_attr, word_sz, node_index);\n+      update_bot_after_copying(obj, word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -172,0 +172,2 @@\n+  void update_bot_after_copying(oop obj, size_t word_sz);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -818,1 +818,1 @@\n-    update_bot_at(address, word_size);\n+    update_bot_if_crossing_boundary(address, word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,7 +166,2 @@\n-  \/\/ Update the BOT for the given address if it crosses the next\n-  \/\/ BOT threshold at or after obj_start.\n-  inline void update_bot_at(HeapWord* obj_start, size_t obj_size);\n-  \/\/ Update BOT at the given threshold for the given object. The\n-  \/\/ given object must cross the threshold.\n-  inline void update_bot_crossing_threshold(HeapWord** threshold, HeapWord* obj_start, HeapWord* obj_end);\n-  inline HeapWord* bot_threshold_for_addr(const void* addr);\n+  \/\/ Update BOT if this obj is the first entering a new card (i.e. crossing the card boundary).\n+  inline void update_bot_if_crossing_boundary(HeapWord* obj_start, size_t obj_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -235,12 +235,1 @@\n-inline HeapWord* HeapRegion::bot_threshold_for_addr(const void* addr) {\n-  HeapWord* threshold = _bot_part.threshold_for_addr(addr);\n-  assert(threshold >= addr,\n-         \"threshold must be at or after given address. \" PTR_FORMAT \" >= \" PTR_FORMAT,\n-         p2i(threshold), p2i(addr));\n-  assert(is_old(),\n-         \"Should only calculate BOT threshold for old regions. addr: \" PTR_FORMAT \" region:\" HR_FORMAT,\n-         p2i(addr), HR_FORMAT_PARAMS(this));\n-  return threshold;\n-}\n-\n-inline void HeapRegion::update_bot_crossing_threshold(HeapWord** threshold, HeapWord* obj_start, HeapWord* obj_end) {\n+inline void HeapRegion::update_bot_if_crossing_boundary(HeapWord* obj_start, size_t obj_size) {\n@@ -248,0 +237,3 @@\n+\n+  HeapWord* obj_end   = obj_start + obj_size;\n+\n@@ -249,1 +241,1 @@\n-         \" obj_start \" PTR_FORMAT \" obj_end \" PTR_FORMAT \" threshold \" PTR_FORMAT,\n+         \" obj_start \" PTR_FORMAT \" obj_end \" PTR_FORMAT,\n@@ -251,3 +243,3 @@\n-         p2i(obj_start), p2i(obj_end), p2i(*threshold));\n-  _bot_part.alloc_block_work(threshold, obj_start, obj_end);\n-}\n+         p2i(obj_start), p2i(obj_end));\n+\n+  HeapWord* cur_card_boundary = _bot_part.align_up_by_card_size(obj_start);\n@@ -255,3 +247,2 @@\n-inline void HeapRegion::update_bot_at(HeapWord* obj_start, size_t obj_size) {\n-  HeapWord* threshold = bot_threshold_for_addr(obj_start);\n-  HeapWord* obj_end = obj_start + obj_size;\n+  \/\/ strictly greater-than\n+  bool cross_card_boundary = (obj_end > cur_card_boundary);\n@@ -259,2 +250,2 @@\n-  if (obj_end > threshold) {\n-    update_bot_crossing_threshold(&threshold, obj_start, obj_end);\n+  if (cross_card_boundary) {\n+    _bot_part.alloc_block_work(&cur_card_boundary, obj_start, obj_end);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  virtual void set_buf(HeapWord* buf, size_t new_word_sz) {\n+  void set_buf(HeapWord* buf, size_t new_word_sz) {\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}