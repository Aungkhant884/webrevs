{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -298,90 +298,0 @@\n-\/*\n- * Close or dup2 a file descriptor ensuring that all threads blocked on\n- * the file descriptor are notified via a wakeup signal.\n- *\n- *      fd1 < 0    => close(fd2)\n- *      fd1 >= 0   => dup2(fd1, fd2)\n- *\n- * Returns -1 with errno set if operation fails.\n- *\/\n-static int closefd(int fd1, int fd2) {\n-    int rv, orig_errno;\n-    fdEntry_t *fdEntry = getFdEntry(fd2);\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Lock the fd to hold-off additional I\/O on this fd.\n-     *\/\n-    pthread_mutex_lock(&(fdEntry->lock));\n-\n-    {\n-        \/* On fast machines we see that we enter dup2 before the\n-         * accepting thread had a chance to get and process the signal.\n-         * So in case we woke a thread up, give it some time to cope.\n-         * Also see https:\/\/bugs.openjdk.java.net\/browse\/JDK-8006395 *\/\n-        int num_woken = 0;\n-\n-        \/*\n-         * Send a wakeup signal to all threads blocked on this\n-         * file descriptor.\n-         *\/\n-        threadEntry_t *curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            curr->intr = 1;\n-            pthread_kill( curr->thr, sigWakeup );\n-            num_woken ++;\n-            curr = curr->next;\n-        }\n-\n-        if (num_woken > 0) {\n-          usleep(num_woken * 50);\n-        }\n-\n-        \/*\n-         * And close\/dup the file descriptor\n-         * (restart if interrupted by signal)\n-         *\/\n-        do {\n-            if (fd1 < 0) {\n-                rv = close(fd2);\n-            } else {\n-                rv = dup2(fd1, fd2);\n-            }\n-        } while (rv == -1 && errno == EINTR);\n-    }\n-\n-    \/*\n-     * Unlock without destroying errno\n-     *\/\n-    orig_errno = errno;\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-\n-    return rv;\n-}\n-\n-\/*\n- * Wrapper for dup2 - same semantics as dup2 system call except\n- * that any threads blocked in an I\/O system call on fd2 will be\n- * preempted and return -1\/EBADF;\n- *\/\n-int NET_Dup2(int fd, int fd2) {\n-    if (fd < 0) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-    return closefd(fd, fd2);\n-}\n-\n-\/*\n- * Wrapper for close - same semantics as close system call\n- * except that any threads blocked in an I\/O on fd will be\n- * preempted and the I\/O system call will return -1\/EBADF.\n- *\/\n-int NET_SocketClose(int fd) {\n-    return closefd(-1, fd);\n-}\n-\n@@ -411,25 +321,0 @@\n-int NET_Read(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n-}\n-\n-int NET_NonBlockingRead(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT(s, recv(s, buf, len, MSG_NONBLOCK));\n-}\n-\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-       struct sockaddr *from, socklen_t *fromlen) {\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );\n-}\n-\n-int NET_Send(int s, void *msg, int len, unsigned int flags) {\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n-}\n-\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-       flags, const struct sockaddr *to, int tolen) {\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n-}\n-\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );\n-}\n@@ -494,55 +379,0 @@\n-\n-\/*\n- * Wrapper for poll(s, timeout).\n- * Auto restarts with adjusted timeout if interrupted by\n- * signal other than our wakeup signal.\n- *\/\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {\n-    jlong prevNanoTime = nanoTimeStamp;\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    fdEntry_t *fdEntry = getFdEntry(s);\n-\n-    \/*\n-     * Check that fd hasn't been closed.\n-     *\/\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    for(;;) {\n-        struct pollfd pfd;\n-        int rv;\n-        threadEntry_t self;\n-\n-        \/*\n-         * Poll the fd. If interrupted by our wakeup signal\n-         * errno will be set to EBADF.\n-         *\/\n-        pfd.fd = s;\n-        pfd.events = POLLIN | POLLERR;\n-\n-        startOp(fdEntry, &self);\n-        rv = poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n-        endOp(fdEntry, &self);\n-\n-        \/*\n-         * If interrupted then adjust timeout. If timeout\n-         * has expired return 0 (indicating timeout expired).\n-         *\/\n-        if (rv < 0 && errno == EINTR) {\n-            if (timeout > 0) {\n-                jlong newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= newNanoTime - prevNanoTime;\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    return 0;\n-                }\n-                prevNanoTime = newNanoTime;\n-            } else {\n-                continue; \/\/ timeout is -1, so  loop again.\n-            }\n-        } else {\n-            return rv;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/aix\/native\/libnet\/aix_close.c","additions":1,"deletions":171,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,79 +266,0 @@\n-\/*\n- * Close or dup2 a file descriptor ensuring that all threads blocked on\n- * the file descriptor are notified via a wakeup signal.\n- *\n- *      fd1 < 0    => close(fd2)\n- *      fd1 >= 0   => dup2(fd1, fd2)\n- *\n- * Returns -1 with errno set if operation fails.\n- *\/\n-static int closefd(int fd1, int fd2) {\n-    int rv, orig_errno;\n-    fdEntry_t *fdEntry = getFdEntry(fd2);\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Lock the fd to hold-off additional I\/O on this fd.\n-     *\/\n-    pthread_mutex_lock(&(fdEntry->lock));\n-\n-    {\n-        \/*\n-         * And close\/dup the file descriptor\n-         * (restart if interrupted by signal)\n-         *\/\n-        if (fd1 < 0) {\n-            rv = close(fd2);\n-        } else {\n-            do {\n-                rv = dup2(fd1, fd2);\n-            } while (rv == -1 && errno == EINTR);\n-        }\n-\n-        \/*\n-         * Send a wakeup signal to all threads blocked on this\n-         * file descriptor.\n-         *\/\n-        threadEntry_t *curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            curr->intr = 1;\n-            pthread_kill( curr->thr, WAKEUP_SIGNAL);\n-            curr = curr->next;\n-        }\n-    }\n-\n-    \/*\n-     * Unlock without destroying errno\n-     *\/\n-    orig_errno = errno;\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-\n-    return rv;\n-}\n-\n-\/*\n- * Wrapper for dup2 - same semantics as dup2 system call except\n- * that any threads blocked in an I\/O system call on fd2 will be\n- * preempted and return -1\/EBADF;\n- *\/\n-int NET_Dup2(int fd, int fd2) {\n-    if (fd < 0) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-    return closefd(fd, fd2);\n-}\n-\n-\/*\n- * Wrapper for close - same semantics as close system call\n- * except that any threads blocked in an I\/O on fd will be\n- * preempted and the I\/O system call will return -1\/EBADF.\n- *\/\n-int NET_SocketClose(int fd) {\n-    return closefd(-1, fd);\n-}\n-\n@@ -368,26 +289,0 @@\n-int NET_Read(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n-}\n-\n-int NET_NonBlockingRead(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT) );\n-}\n-\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-       struct sockaddr *from, socklen_t *fromlen) {\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );\n-}\n-\n-int NET_Send(int s, void *msg, int len, unsigned int flags) {\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n-}\n-\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-       flags, const struct sockaddr *to, int tolen) {\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n-}\n-\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );\n-}\n-\n@@ -401,54 +296,0 @@\n-\n-\/*\n- * Wrapper for poll(s, timeout).\n- * Auto restarts with adjusted timeout if interrupted by\n- * signal other than our wakeup signal.\n- *\/\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {\n-    jlong prevNanoTime = nanoTimeStamp;\n-    jlong nanoTimeout = (jlong)timeout * NET_NSEC_PER_MSEC;\n-    fdEntry_t *fdEntry = getFdEntry(s);\n-\n-    \/*\n-     * Check that fd hasn't been closed.\n-     *\/\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    for(;;) {\n-        struct pollfd pfd;\n-        int rv;\n-        threadEntry_t self;\n-\n-        \/*\n-         * Poll the fd. If interrupted by our wakeup signal\n-         * errno will be set to EBADF.\n-         *\/\n-        pfd.fd = s;\n-        pfd.events = POLLIN | POLLERR;\n-\n-        startOp(fdEntry, &self);\n-        rv = poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n-        endOp(fdEntry, &self);\n-        \/*\n-         * If interrupted then adjust timeout. If timeout\n-         * has expired return 0 (indicating timeout expired).\n-         *\/\n-        if (rv < 0 && errno == EINTR) {\n-            if (timeout > 0) {\n-                jlong newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= newNanoTime - prevNanoTime;\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    return 0;\n-                }\n-                prevNanoTime = newNanoTime;\n-            } else {\n-                continue; \/\/ timeout is -1, so  loop again.\n-            }\n-        } else {\n-            return rv;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/linux\/native\/libnet\/linux_close.c","additions":1,"deletions":160,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,80 +269,0 @@\n-\/*\n- * Close or dup2 a file descriptor ensuring that all threads blocked on\n- * the file descriptor are notified via a wakeup signal.\n- *\n- *      fd1 < 0    => close(fd2)\n- *      fd1 >= 0   => dup2(fd1, fd2)\n- *\n- * Returns -1 with errno set if operation fails.\n- *\/\n-static int closefd(int fd1, int fd2) {\n-    int rv, orig_errno;\n-    fdEntry_t *fdEntry = getFdEntry(fd2);\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Lock the fd to hold-off additional I\/O on this fd.\n-     *\/\n-    pthread_mutex_lock(&(fdEntry->lock));\n-\n-    {\n-        \/*\n-         * Send a wakeup signal to all threads blocked on this\n-         * file descriptor.\n-         *\/\n-        threadEntry_t *curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            curr->intr = 1;\n-            pthread_kill( curr->thr, sigWakeup );\n-            curr = curr->next;\n-        }\n-\n-        \/*\n-         * And close\/dup the file descriptor\n-         * (restart if interrupted by signal)\n-         *\/\n-        do {\n-            if (fd1 < 0) {\n-                rv = close(fd2);\n-            } else {\n-                rv = dup2(fd1, fd2);\n-            }\n-        } while (rv == -1 && errno == EINTR);\n-\n-    }\n-\n-    \/*\n-     * Unlock without destroying errno\n-     *\/\n-    orig_errno = errno;\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-\n-    return rv;\n-}\n-\n-\/*\n- * Wrapper for dup2 - same semantics as dup2 system call except\n- * that any threads blocked in an I\/O system call on fd2 will be\n- * preempted and return -1\/EBADF;\n- *\/\n-int NET_Dup2(int fd, int fd2) {\n-    if (fd < 0) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-    return closefd(fd, fd2);\n-}\n-\n-\/*\n- * Wrapper for close - same semantics as close system call\n- * except that any threads blocked in an I\/O on fd will be\n- * preempted and the I\/O system call will return -1\/EBADF.\n- *\/\n-int NET_SocketClose(int fd) {\n-    return closefd(-1, fd);\n-}\n-\n@@ -372,26 +292,0 @@\n-int NET_Read(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n-}\n-\n-int NET_NonBlockingRead(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT));\n-}\n-\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-       struct sockaddr *from, socklen_t *fromlen) {\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );\n-}\n-\n-int NET_Send(int s, void *msg, int len, unsigned int flags) {\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n-}\n-\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-       flags, const struct sockaddr *to, int tolen) {\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n-}\n-\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );\n-}\n-\n@@ -405,91 +299,0 @@\n-\n-\/*\n- * Wrapper for select(s, timeout). We are using select() on Mac OS due to Bug 7131399.\n- * Auto restarts with adjusted timeout if interrupted by\n- * signal other than our wakeup signal.\n- *\/\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {\n-    struct timeval t, *tp = &t;\n-    fd_set fds;\n-    fd_set* fdsp = NULL;\n-    int allocated = 0;\n-    threadEntry_t self;\n-    fdEntry_t *fdEntry = getFdEntry(s);\n-\n-    \/*\n-     * Check that fd hasn't been closed.\n-     *\/\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Pick up current time as may need to adjust timeout\n-     *\/\n-    if (timeout > 0) {\n-        \/* Timed *\/\n-        t.tv_sec = timeout \/ 1000;\n-        t.tv_usec = (timeout % 1000) * 1000;\n-    } else if (timeout < 0) {\n-        \/* Blocking *\/\n-        tp = 0;\n-    } else {\n-        \/* Poll *\/\n-        t.tv_sec = 0;\n-        t.tv_usec = 0;\n-    }\n-\n-    if (s < FD_SETSIZE) {\n-        fdsp = &fds;\n-        FD_ZERO(fdsp);\n-    } else {\n-        int length = (howmany(s+1, NFDBITS)) * sizeof(int);\n-        fdsp = (fd_set *) calloc(1, length);\n-        if (fdsp == NULL) {\n-            return -1;   \/\/ errno will be set to ENOMEM\n-        }\n-        allocated = 1;\n-    }\n-    FD_SET(s, fdsp);\n-\n-    jlong prevNanoTime = nanoTimeStamp;\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    for(;;) {\n-        int rv;\n-\n-        \/*\n-         * call select on the fd. If interrupted by our wakeup signal\n-         * errno will be set to EBADF.\n-         *\/\n-\n-        startOp(fdEntry, &self);\n-        rv = select(s+1, fdsp, 0, 0, tp);\n-        endOp(fdEntry, &self);\n-\n-        \/*\n-         * If interrupted then adjust timeout. If timeout\n-         * has expired return 0 (indicating timeout expired).\n-         *\/\n-        if (rv < 0 && errno == EINTR) {\n-            if (timeout > 0) {\n-                jlong newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= newNanoTime - prevNanoTime;\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    if (allocated != 0)\n-                        free(fdsp);\n-                    return 0;\n-                }\n-                prevNanoTime = newNanoTime;\n-                t.tv_sec = nanoTimeout \/ NET_NSEC_PER_SEC;\n-                t.tv_usec = (nanoTimeout % NET_NSEC_PER_SEC) \/ NET_NSEC_PER_USEC;\n-            } else {\n-                continue; \/\/ timeout is -1, so  loop again.\n-            }\n-        } else {\n-            if (allocated != 0)\n-                free(fdsp);\n-            return rv;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/macosx\/native\/libnet\/bsd_close.c","additions":1,"deletions":198,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,3 +112,0 @@\n-void NET_ThrowCurrent(JNIEnv *env, char *msg);\n-\n-jfieldID NET_GetFileDescriptorID(JNIEnv *env);\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -72,5 +72,0 @@\n-void\n-NET_ThrowCurrent(JNIEnv *env, char *msg) {\n-    NET_ThrowNew(env, errno, msg);\n-}\n-\n@@ -98,9 +93,0 @@\n-\n-jfieldID\n-NET_GetFileDescriptorID(JNIEnv *env)\n-{\n-    jclass cls = (*env)->FindClass(env, \"java\/io\/FileDescriptor\");\n-    CHECK_NULL_RETURN(cls, NULL);\n-    return (*env)->GetFieldID(env, cls, \"fd\", \"I\");\n-}\n-\n@@ -331,7 +317,0 @@\n-void\n-NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass) {\n-    if (sa->sa.sa_family == AF_INET6) {\n-        sa->sa6.sin6_flowinfo = htonl((trafficClass & 0xff) << 20);\n-    }\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,8 +78,0 @@\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong  nanoTimeStamp);\n-int NET_Read(int s, void* buf, size_t len);\n-int NET_NonBlockingRead(int s, void* buf, size_t len);\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-                 struct sockaddr *from, socklen_t *fromlen);\n-int NET_Send(int s, void *msg, int len, unsigned int flags);\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-               flags, const struct sockaddr *to, int tolen);\n@@ -87,3 +79,0 @@\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen);\n-int NET_SocketClose(int s);\n-int NET_Dup2(int oldfd, int newfd);\n@@ -97,1 +86,0 @@\n-void NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass);\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.h","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -196,6 +196,0 @@\n-void\n-NET_ThrowCurrent(JNIEnv *env, char *msg)\n-{\n-    NET_ThrowNew(env, WSAGetLastError(), msg);\n-}\n-\n@@ -208,8 +202,0 @@\n-jfieldID\n-NET_GetFileDescriptorID(JNIEnv *env)\n-{\n-    jclass cls = (*env)->FindClass(env, \"java\/io\/FileDescriptor\");\n-    CHECK_NULL_RETURN(cls, NULL);\n-    return (*env)->GetFieldID(env, cls, \"fd\", \"I\");\n-}\n-\n@@ -475,71 +461,0 @@\n-JNIEXPORT int JNICALL\n-NET_SocketClose(int fd) {\n-    struct linger l = {0, 0};\n-    int ret = 0;\n-    int len = sizeof (l);\n-    if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&l, &len) == 0) {\n-        if (l.l_onoff == 0) {\n-            shutdown(fd, SD_SEND);\n-        }\n-    }\n-    ret = closesocket (fd);\n-    return ret;\n-}\n-\n-JNIEXPORT int JNICALL\n-NET_Timeout(int fd, long timeout) {\n-    int ret;\n-    fd_set tbl;\n-    struct timeval t;\n-    t.tv_sec = timeout \/ 1000;\n-    t.tv_usec = (timeout % 1000) * 1000;\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    ret = select (fd + 1, &tbl, 0, 0, &t);\n-    return ret;\n-}\n-\n-\n-\/*\n- * differs from NET_Timeout() as follows:\n- *\n- * If timeout = -1, it blocks forever.\n- *\n- * returns 1 or 2 depending if only one or both sockets\n- * fire at same time.\n- *\n- * *fdret is (one of) the active fds. If both sockets\n- * fire at same time, *fdret = fd always.\n- *\/\n-JNIEXPORT int JNICALL\n-NET_Timeout2(int fd, int fd1, long timeout, int *fdret) {\n-    int ret;\n-    fd_set tbl;\n-    struct timeval t, *tP = &t;\n-    if (timeout == -1) {\n-        tP = 0;\n-    } else {\n-        t.tv_sec = timeout \/ 1000;\n-        t.tv_usec = (timeout % 1000) * 1000;\n-    }\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    FD_SET(fd1, &tbl);\n-    ret = select (0, &tbl, 0, 0, tP);\n-    switch (ret) {\n-    case 0:\n-        return 0; \/* timeout *\/\n-    case 1:\n-        if (FD_ISSET (fd, &tbl)) {\n-            *fdret= fd;\n-        } else {\n-            *fdret= fd1;\n-        }\n-        return 1;\n-    case 2:\n-        *fdret= fd;\n-        return 2;\n-    }\n-    return -1;\n-}\n-\n@@ -570,189 +485,0 @@\n-\/* Macro, which cleans-up the iv6bind structure,\n- * closes the two sockets (if open),\n- * and returns SOCKET_ERROR. Used in NET_BindV6 only.\n- *\/\n-\n-#define CLOSE_SOCKETS_AND_RETURN do {   \\\n-    if (fd != -1) {                     \\\n-        closesocket (fd);               \\\n-        fd = -1;                        \\\n-    }                                   \\\n-    if (ofd != -1) {                    \\\n-        closesocket (ofd);              \\\n-        ofd = -1;                       \\\n-    }                                   \\\n-    if (close_fd != -1) {               \\\n-        closesocket (close_fd);         \\\n-        close_fd = -1;                  \\\n-    }                                   \\\n-    if (close_ofd != -1) {              \\\n-        closesocket (close_ofd);        \\\n-        close_ofd = -1;                 \\\n-    }                                   \\\n-    b->ipv4_fd = b->ipv6_fd = -1;       \\\n-    return SOCKET_ERROR;                \\\n-} while(0)\n-\n-\/*\n- * if ipv6 is available, call NET_BindV6 to bind to the required address\/port.\n- * Because the same port number may need to be reserved in both v4 and v6 space,\n- * this may require socket(s) to be re-opened. Therefore, all of this information\n- * is passed in and returned through the ipv6bind structure.\n- *\n- * If the request is to bind to a specific address, then this (by definition) means\n- * only bind in either v4 or v6, and this is just the same as normal. ie. a single\n- * call to bind() will suffice. The other socket is closed in this case.\n- *\n- * The more complicated case is when the requested address is ::0 or 0.0.0.0.\n- *\n- * Two further cases:\n- * 2. If the requested port is 0 (ie. any port) then we try to bind in v4 space\n- *    first with a wild-card port argument. We then try to bind in v6 space\n- *    using the returned port number. If this fails, we repeat the process\n- *    until a free port common to both spaces becomes available.\n- *\n- * 3. If the requested port is a specific port, then we just try to get that\n- *    port in both spaces, and if it is not free in both, then the bind fails.\n- *\n- * On failure, sockets are closed and an error returned with CLOSE_SOCKETS_AND_RETURN\n- *\/\n-\n-JNIEXPORT int JNICALL\n-NET_BindV6(struct ipv6bind *b, jboolean exclBind) {\n-    int fd=-1, ofd=-1, rv, len;\n-    \/* need to defer close until new sockets created *\/\n-    int close_fd=-1, close_ofd=-1;\n-    SOCKETADDRESS oaddr; \/* other address to bind *\/\n-    int family = b->addr->sa.sa_family;\n-    int ofamily;\n-    u_short port; \/* requested port parameter *\/\n-    u_short bound_port;\n-\n-    if (family == AF_INET && (b->addr->sa4.sin_addr.s_addr != INADDR_ANY)) {\n-        \/* bind to v4 only *\/\n-        int ret;\n-        ret = NET_WinBind((int)b->ipv4_fd, b->addr,\n-                          sizeof(SOCKETADDRESS), exclBind);\n-        if (ret == SOCKET_ERROR) {\n-            CLOSE_SOCKETS_AND_RETURN;\n-        }\n-        closesocket (b->ipv6_fd);\n-        b->ipv6_fd = -1;\n-        return 0;\n-    }\n-    if (family == AF_INET6 && (!IN6_IS_ADDR_ANY(&b->addr->sa6.sin6_addr))) {\n-        \/* bind to v6 only *\/\n-        int ret;\n-        ret = NET_WinBind((int)b->ipv6_fd, b->addr,\n-                          sizeof(SOCKETADDRESS), exclBind);\n-        if (ret == SOCKET_ERROR) {\n-            CLOSE_SOCKETS_AND_RETURN;\n-        }\n-        closesocket (b->ipv4_fd);\n-        b->ipv4_fd = -1;\n-        return 0;\n-    }\n-\n-    \/* We need to bind on both stacks, with the same port number *\/\n-\n-    memset (&oaddr, 0, sizeof(oaddr));\n-    if (family == AF_INET) {\n-        ofamily = AF_INET6;\n-        fd = (int)b->ipv4_fd;\n-        ofd = (int)b->ipv6_fd;\n-        port = (u_short)GET_PORT (b->addr);\n-        IN6ADDR_SETANY(&oaddr.sa6);\n-        oaddr.sa6.sin6_port = port;\n-    } else {\n-        ofamily = AF_INET;\n-        ofd = (int)b->ipv4_fd;\n-        fd = (int)b->ipv6_fd;\n-        port = (u_short)GET_PORT (b->addr);\n-        oaddr.sa4.sin_family = AF_INET;\n-        oaddr.sa4.sin_port = port;\n-        oaddr.sa4.sin_addr.s_addr = INADDR_ANY;\n-    }\n-\n-    rv = NET_WinBind(fd, b->addr, sizeof(SOCKETADDRESS), exclBind);\n-    if (rv == SOCKET_ERROR) {\n-        CLOSE_SOCKETS_AND_RETURN;\n-    }\n-\n-    \/* get the port and set it in the other address *\/\n-    len = sizeof(SOCKETADDRESS);\n-    if (getsockname(fd, (struct sockaddr *)b->addr, &len) == -1) {\n-        CLOSE_SOCKETS_AND_RETURN;\n-    }\n-    bound_port = GET_PORT (b->addr);\n-    SET_PORT (&oaddr, bound_port);\n-    if ((rv = NET_WinBind(ofd, &oaddr,\n-                          sizeof(SOCKETADDRESS), exclBind)) == SOCKET_ERROR) {\n-        int retries;\n-        int sotype, arglen=sizeof(sotype);\n-\n-        \/* no retries unless, the request was for any free port *\/\n-\n-        if (port != 0) {\n-            CLOSE_SOCKETS_AND_RETURN;\n-        }\n-\n-        getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotype, &arglen);\n-\n-#define SOCK_RETRIES 50\n-        \/* 50 is an arbitrary limit, just to ensure that this\n-         * cannot be an endless loop. Would expect socket creation to\n-         * succeed sooner.\n-         *\/\n-        for (retries = 0; retries < SOCK_RETRIES; retries ++) {\n-            int len;\n-            close_fd = fd; fd = -1;\n-            close_ofd = ofd; ofd = -1;\n-            b->ipv4_fd = SOCKET_ERROR;\n-            b->ipv6_fd = SOCKET_ERROR;\n-\n-            \/* create two new sockets *\/\n-            fd = (int)socket (family, sotype, 0);\n-            if (fd == SOCKET_ERROR) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-            ofd = (int)socket (ofamily, sotype, 0);\n-            if (ofd == SOCKET_ERROR) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-\n-            \/* bind random port on first socket *\/\n-            SET_PORT (&oaddr, 0);\n-            rv = NET_WinBind(ofd, &oaddr, sizeof(SOCKETADDRESS), exclBind);\n-            if (rv == SOCKET_ERROR) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-            \/* close the original pair of sockets before continuing *\/\n-            closesocket (close_fd);\n-            closesocket (close_ofd);\n-            close_fd = close_ofd = -1;\n-\n-            \/* bind new port on second socket *\/\n-            len = sizeof(SOCKETADDRESS);\n-            if (getsockname(ofd, &oaddr.sa, &len) == -1) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-            bound_port = GET_PORT (&oaddr);\n-            SET_PORT (b->addr, bound_port);\n-            rv = NET_WinBind(fd, b->addr, sizeof(SOCKETADDRESS), exclBind);\n-\n-            if (rv != SOCKET_ERROR) {\n-                if (family == AF_INET) {\n-                    b->ipv4_fd = fd;\n-                    b->ipv6_fd = ofd;\n-                } else {\n-                    b->ipv4_fd = ofd;\n-                    b->ipv6_fd = fd;\n-                }\n-                return 0;\n-            }\n-        }\n-        CLOSE_SOCKETS_AND_RETURN;\n-    }\n-    return 0;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":0,"deletions":274,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,0 @@\n-void NET_ThrowCurrent(JNIEnv *env, char *msg);\n-\n@@ -62,10 +60,0 @@\n-\/*\n- * passed to NET_BindV6. Both ipv4_fd and ipv6_fd must be created and unbound\n- * sockets. On return they may refer to different sockets.\n- *\/\n-struct ipv6bind {\n-    SOCKETADDRESS      *addr;\n-    SOCKET              ipv4_fd;\n-    SOCKET              ipv6_fd;\n-};\n-\n@@ -121,4 +109,0 @@\n-JNIEXPORT int JNICALL NET_SocketClose(int fd);\n-\n-JNIEXPORT int JNICALL NET_Timeout(int fd, long timeout);\n-\n@@ -130,15 +114,0 @@\n-\/*\n- * differs from NET_Timeout() as follows:\n- *\n- * If timeout = -1, it blocks forever.\n- *\n- * returns 1 or 2 depending if only one or both sockets\n- * fire at same time.\n- *\n- * *fdret is (one of) the active fds. If both sockets\n- * fire at same time, *fd == fd always.\n- *\/\n-JNIEXPORT int JNICALL NET_Timeout2(int fd, int fd1, long timeout, int *fdret);\n-\n-JNIEXPORT int JNICALL NET_BindV6(struct ipv6bind *b, jboolean exclBind);\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.h","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"}]}