{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -298,90 +298,0 @@\n-\/*\n- * Close or dup2 a file descriptor ensuring that all threads blocked on\n- * the file descriptor are notified via a wakeup signal.\n- *\n- *      fd1 < 0    => close(fd2)\n- *      fd1 >= 0   => dup2(fd1, fd2)\n- *\n- * Returns -1 with errno set if operation fails.\n- *\/\n-static int closefd(int fd1, int fd2) {\n-    int rv, orig_errno;\n-    fdEntry_t *fdEntry = getFdEntry(fd2);\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Lock the fd to hold-off additional I\/O on this fd.\n-     *\/\n-    pthread_mutex_lock(&(fdEntry->lock));\n-\n-    {\n-        \/* On fast machines we see that we enter dup2 before the\n-         * accepting thread had a chance to get and process the signal.\n-         * So in case we woke a thread up, give it some time to cope.\n-         * Also see https:\/\/bugs.openjdk.java.net\/browse\/JDK-8006395 *\/\n-        int num_woken = 0;\n-\n-        \/*\n-         * Send a wakeup signal to all threads blocked on this\n-         * file descriptor.\n-         *\/\n-        threadEntry_t *curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            curr->intr = 1;\n-            pthread_kill( curr->thr, sigWakeup );\n-            num_woken ++;\n-            curr = curr->next;\n-        }\n-\n-        if (num_woken > 0) {\n-          usleep(num_woken * 50);\n-        }\n-\n-        \/*\n-         * And close\/dup the file descriptor\n-         * (restart if interrupted by signal)\n-         *\/\n-        do {\n-            if (fd1 < 0) {\n-                rv = close(fd2);\n-            } else {\n-                rv = dup2(fd1, fd2);\n-            }\n-        } while (rv == -1 && errno == EINTR);\n-    }\n-\n-    \/*\n-     * Unlock without destroying errno\n-     *\/\n-    orig_errno = errno;\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-\n-    return rv;\n-}\n-\n-\/*\n- * Wrapper for dup2 - same semantics as dup2 system call except\n- * that any threads blocked in an I\/O system call on fd2 will be\n- * preempted and return -1\/EBADF;\n- *\/\n-int NET_Dup2(int fd, int fd2) {\n-    if (fd < 0) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-    return closefd(fd, fd2);\n-}\n-\n-\/*\n- * Wrapper for close - same semantics as close system call\n- * except that any threads blocked in an I\/O on fd will be\n- * preempted and the I\/O system call will return -1\/EBADF.\n- *\/\n-int NET_SocketClose(int fd) {\n-    return closefd(-1, fd);\n-}\n-\n@@ -411,25 +321,0 @@\n-int NET_Read(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n-}\n-\n-int NET_NonBlockingRead(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT(s, recv(s, buf, len, MSG_NONBLOCK));\n-}\n-\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-       struct sockaddr *from, socklen_t *fromlen) {\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );\n-}\n-\n-int NET_Send(int s, void *msg, int len, unsigned int flags) {\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n-}\n-\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-       flags, const struct sockaddr *to, int tolen) {\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n-}\n-\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );\n-}\n@@ -494,55 +379,0 @@\n-\n-\/*\n- * Wrapper for poll(s, timeout).\n- * Auto restarts with adjusted timeout if interrupted by\n- * signal other than our wakeup signal.\n- *\/\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {\n-    jlong prevNanoTime = nanoTimeStamp;\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    fdEntry_t *fdEntry = getFdEntry(s);\n-\n-    \/*\n-     * Check that fd hasn't been closed.\n-     *\/\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    for(;;) {\n-        struct pollfd pfd;\n-        int rv;\n-        threadEntry_t self;\n-\n-        \/*\n-         * Poll the fd. If interrupted by our wakeup signal\n-         * errno will be set to EBADF.\n-         *\/\n-        pfd.fd = s;\n-        pfd.events = POLLIN | POLLERR;\n-\n-        startOp(fdEntry, &self);\n-        rv = poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n-        endOp(fdEntry, &self);\n-\n-        \/*\n-         * If interrupted then adjust timeout. If timeout\n-         * has expired return 0 (indicating timeout expired).\n-         *\/\n-        if (rv < 0 && errno == EINTR) {\n-            if (timeout > 0) {\n-                jlong newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= newNanoTime - prevNanoTime;\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    return 0;\n-                }\n-                prevNanoTime = newNanoTime;\n-            } else {\n-                continue; \/\/ timeout is -1, so  loop again.\n-            }\n-        } else {\n-            return rv;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/aix\/native\/libnet\/aix_close.c","additions":1,"deletions":171,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,79 +266,0 @@\n-\/*\n- * Close or dup2 a file descriptor ensuring that all threads blocked on\n- * the file descriptor are notified via a wakeup signal.\n- *\n- *      fd1 < 0    => close(fd2)\n- *      fd1 >= 0   => dup2(fd1, fd2)\n- *\n- * Returns -1 with errno set if operation fails.\n- *\/\n-static int closefd(int fd1, int fd2) {\n-    int rv, orig_errno;\n-    fdEntry_t *fdEntry = getFdEntry(fd2);\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Lock the fd to hold-off additional I\/O on this fd.\n-     *\/\n-    pthread_mutex_lock(&(fdEntry->lock));\n-\n-    {\n-        \/*\n-         * And close\/dup the file descriptor\n-         * (restart if interrupted by signal)\n-         *\/\n-        if (fd1 < 0) {\n-            rv = close(fd2);\n-        } else {\n-            do {\n-                rv = dup2(fd1, fd2);\n-            } while (rv == -1 && errno == EINTR);\n-        }\n-\n-        \/*\n-         * Send a wakeup signal to all threads blocked on this\n-         * file descriptor.\n-         *\/\n-        threadEntry_t *curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            curr->intr = 1;\n-            pthread_kill( curr->thr, WAKEUP_SIGNAL);\n-            curr = curr->next;\n-        }\n-    }\n-\n-    \/*\n-     * Unlock without destroying errno\n-     *\/\n-    orig_errno = errno;\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-\n-    return rv;\n-}\n-\n-\/*\n- * Wrapper for dup2 - same semantics as dup2 system call except\n- * that any threads blocked in an I\/O system call on fd2 will be\n- * preempted and return -1\/EBADF;\n- *\/\n-int NET_Dup2(int fd, int fd2) {\n-    if (fd < 0) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-    return closefd(fd, fd2);\n-}\n-\n-\/*\n- * Wrapper for close - same semantics as close system call\n- * except that any threads blocked in an I\/O on fd will be\n- * preempted and the I\/O system call will return -1\/EBADF.\n- *\/\n-int NET_SocketClose(int fd) {\n-    return closefd(-1, fd);\n-}\n-\n@@ -368,26 +289,0 @@\n-int NET_Read(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n-}\n-\n-int NET_NonBlockingRead(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT) );\n-}\n-\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-       struct sockaddr *from, socklen_t *fromlen) {\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );\n-}\n-\n-int NET_Send(int s, void *msg, int len, unsigned int flags) {\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n-}\n-\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-       flags, const struct sockaddr *to, int tolen) {\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n-}\n-\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );\n-}\n-\n@@ -401,54 +296,0 @@\n-\n-\/*\n- * Wrapper for poll(s, timeout).\n- * Auto restarts with adjusted timeout if interrupted by\n- * signal other than our wakeup signal.\n- *\/\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {\n-    jlong prevNanoTime = nanoTimeStamp;\n-    jlong nanoTimeout = (jlong)timeout * NET_NSEC_PER_MSEC;\n-    fdEntry_t *fdEntry = getFdEntry(s);\n-\n-    \/*\n-     * Check that fd hasn't been closed.\n-     *\/\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    for(;;) {\n-        struct pollfd pfd;\n-        int rv;\n-        threadEntry_t self;\n-\n-        \/*\n-         * Poll the fd. If interrupted by our wakeup signal\n-         * errno will be set to EBADF.\n-         *\/\n-        pfd.fd = s;\n-        pfd.events = POLLIN | POLLERR;\n-\n-        startOp(fdEntry, &self);\n-        rv = poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n-        endOp(fdEntry, &self);\n-        \/*\n-         * If interrupted then adjust timeout. If timeout\n-         * has expired return 0 (indicating timeout expired).\n-         *\/\n-        if (rv < 0 && errno == EINTR) {\n-            if (timeout > 0) {\n-                jlong newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= newNanoTime - prevNanoTime;\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    return 0;\n-                }\n-                prevNanoTime = newNanoTime;\n-            } else {\n-                continue; \/\/ timeout is -1, so  loop again.\n-            }\n-        } else {\n-            return rv;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/linux\/native\/libnet\/linux_close.c","additions":1,"deletions":160,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,80 +269,0 @@\n-\/*\n- * Close or dup2 a file descriptor ensuring that all threads blocked on\n- * the file descriptor are notified via a wakeup signal.\n- *\n- *      fd1 < 0    => close(fd2)\n- *      fd1 >= 0   => dup2(fd1, fd2)\n- *\n- * Returns -1 with errno set if operation fails.\n- *\/\n-static int closefd(int fd1, int fd2) {\n-    int rv, orig_errno;\n-    fdEntry_t *fdEntry = getFdEntry(fd2);\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Lock the fd to hold-off additional I\/O on this fd.\n-     *\/\n-    pthread_mutex_lock(&(fdEntry->lock));\n-\n-    {\n-        \/*\n-         * Send a wakeup signal to all threads blocked on this\n-         * file descriptor.\n-         *\/\n-        threadEntry_t *curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            curr->intr = 1;\n-            pthread_kill( curr->thr, sigWakeup );\n-            curr = curr->next;\n-        }\n-\n-        \/*\n-         * And close\/dup the file descriptor\n-         * (restart if interrupted by signal)\n-         *\/\n-        do {\n-            if (fd1 < 0) {\n-                rv = close(fd2);\n-            } else {\n-                rv = dup2(fd1, fd2);\n-            }\n-        } while (rv == -1 && errno == EINTR);\n-\n-    }\n-\n-    \/*\n-     * Unlock without destroying errno\n-     *\/\n-    orig_errno = errno;\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-\n-    return rv;\n-}\n-\n-\/*\n- * Wrapper for dup2 - same semantics as dup2 system call except\n- * that any threads blocked in an I\/O system call on fd2 will be\n- * preempted and return -1\/EBADF;\n- *\/\n-int NET_Dup2(int fd, int fd2) {\n-    if (fd < 0) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-    return closefd(fd, fd2);\n-}\n-\n-\/*\n- * Wrapper for close - same semantics as close system call\n- * except that any threads blocked in an I\/O on fd will be\n- * preempted and the I\/O system call will return -1\/EBADF.\n- *\/\n-int NET_SocketClose(int fd) {\n-    return closefd(-1, fd);\n-}\n-\n@@ -372,26 +292,0 @@\n-int NET_Read(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n-}\n-\n-int NET_NonBlockingRead(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT));\n-}\n-\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-       struct sockaddr *from, socklen_t *fromlen) {\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );\n-}\n-\n-int NET_Send(int s, void *msg, int len, unsigned int flags) {\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n-}\n-\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-       flags, const struct sockaddr *to, int tolen) {\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n-}\n-\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );\n-}\n-\n@@ -405,91 +299,0 @@\n-\n-\/*\n- * Wrapper for select(s, timeout). We are using select() on Mac OS due to Bug 7131399.\n- * Auto restarts with adjusted timeout if interrupted by\n- * signal other than our wakeup signal.\n- *\/\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {\n-    struct timeval t, *tp = &t;\n-    fd_set fds;\n-    fd_set* fdsp = NULL;\n-    int allocated = 0;\n-    threadEntry_t self;\n-    fdEntry_t *fdEntry = getFdEntry(s);\n-\n-    \/*\n-     * Check that fd hasn't been closed.\n-     *\/\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Pick up current time as may need to adjust timeout\n-     *\/\n-    if (timeout > 0) {\n-        \/* Timed *\/\n-        t.tv_sec = timeout \/ 1000;\n-        t.tv_usec = (timeout % 1000) * 1000;\n-    } else if (timeout < 0) {\n-        \/* Blocking *\/\n-        tp = 0;\n-    } else {\n-        \/* Poll *\/\n-        t.tv_sec = 0;\n-        t.tv_usec = 0;\n-    }\n-\n-    if (s < FD_SETSIZE) {\n-        fdsp = &fds;\n-        FD_ZERO(fdsp);\n-    } else {\n-        int length = (howmany(s+1, NFDBITS)) * sizeof(int);\n-        fdsp = (fd_set *) calloc(1, length);\n-        if (fdsp == NULL) {\n-            return -1;   \/\/ errno will be set to ENOMEM\n-        }\n-        allocated = 1;\n-    }\n-    FD_SET(s, fdsp);\n-\n-    jlong prevNanoTime = nanoTimeStamp;\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    for(;;) {\n-        int rv;\n-\n-        \/*\n-         * call select on the fd. If interrupted by our wakeup signal\n-         * errno will be set to EBADF.\n-         *\/\n-\n-        startOp(fdEntry, &self);\n-        rv = select(s+1, fdsp, 0, 0, tp);\n-        endOp(fdEntry, &self);\n-\n-        \/*\n-         * If interrupted then adjust timeout. If timeout\n-         * has expired return 0 (indicating timeout expired).\n-         *\/\n-        if (rv < 0 && errno == EINTR) {\n-            if (timeout > 0) {\n-                jlong newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= newNanoTime - prevNanoTime;\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    if (allocated != 0)\n-                        free(fdsp);\n-                    return 0;\n-                }\n-                prevNanoTime = newNanoTime;\n-                t.tv_sec = nanoTimeout \/ NET_NSEC_PER_SEC;\n-                t.tv_usec = (nanoTimeout % NET_NSEC_PER_SEC) \/ NET_NSEC_PER_USEC;\n-            } else {\n-                continue; \/\/ timeout is -1, so  loop again.\n-            }\n-        } else {\n-            if (allocated != 0)\n-                free(fdsp);\n-            return rv;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/macosx\/native\/libnet\/bsd_close.c","additions":1,"deletions":198,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,3 +112,0 @@\n-void NET_ThrowCurrent(JNIEnv *env, char *msg);\n-\n-jfieldID NET_GetFileDescriptorID(JNIEnv *env);\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -98,9 +98,0 @@\n-\n-jfieldID\n-NET_GetFileDescriptorID(JNIEnv *env)\n-{\n-    jclass cls = (*env)->FindClass(env, \"java\/io\/FileDescriptor\");\n-    CHECK_NULL_RETURN(cls, NULL);\n-    return (*env)->GetFieldID(env, cls, \"fd\", \"I\");\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,8 +78,0 @@\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong  nanoTimeStamp);\n-int NET_Read(int s, void* buf, size_t len);\n-int NET_NonBlockingRead(int s, void* buf, size_t len);\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-                 struct sockaddr *from, socklen_t *fromlen);\n-int NET_Send(int s, void *msg, int len, unsigned int flags);\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-               flags, const struct sockaddr *to, int tolen);\n@@ -87,3 +79,0 @@\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen);\n-int NET_SocketClose(int s);\n-int NET_Dup2(int oldfd, int newfd);\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.h","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -208,8 +208,0 @@\n-jfieldID\n-NET_GetFileDescriptorID(JNIEnv *env)\n-{\n-    jclass cls = (*env)->FindClass(env, \"java\/io\/FileDescriptor\");\n-    CHECK_NULL_RETURN(cls, NULL);\n-    return (*env)->GetFieldID(env, cls, \"fd\", \"I\");\n-}\n-\n@@ -489,13 +481,0 @@\n-JNIEXPORT int JNICALL\n-NET_Timeout(int fd, long timeout) {\n-    int ret;\n-    fd_set tbl;\n-    struct timeval t;\n-    t.tv_sec = timeout \/ 1000;\n-    t.tv_usec = (timeout % 1000) * 1000;\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    ret = select (fd + 1, &tbl, 0, 0, &t);\n-    return ret;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,0 @@\n-void NET_ThrowCurrent(JNIEnv *env, char *msg);\n-\n@@ -121,4 +119,0 @@\n-JNIEXPORT int JNICALL NET_SocketClose(int fd);\n-\n-JNIEXPORT int JNICALL NET_Timeout(int fd, long timeout);\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.h","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"}]}