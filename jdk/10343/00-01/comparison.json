{"files":[{"patch":"@@ -72,5 +72,0 @@\n-void\n-NET_ThrowCurrent(JNIEnv *env, char *msg) {\n-    NET_ThrowNew(env, errno, msg);\n-}\n-\n@@ -322,7 +317,0 @@\n-void\n-NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass) {\n-    if (sa->sa.sa_family == AF_INET6) {\n-        sa->sa6.sin6_flowinfo = htonl((trafficClass & 0xff) << 20);\n-    }\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-void NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass);\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -196,6 +196,0 @@\n-void\n-NET_ThrowCurrent(JNIEnv *env, char *msg)\n-{\n-    NET_ThrowNew(env, WSAGetLastError(), msg);\n-}\n-\n@@ -467,58 +461,0 @@\n-JNIEXPORT int JNICALL\n-NET_SocketClose(int fd) {\n-    struct linger l = {0, 0};\n-    int ret = 0;\n-    int len = sizeof (l);\n-    if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&l, &len) == 0) {\n-        if (l.l_onoff == 0) {\n-            shutdown(fd, SD_SEND);\n-        }\n-    }\n-    ret = closesocket (fd);\n-    return ret;\n-}\n-\n-\n-\/*\n- * differs from NET_Timeout() as follows:\n- *\n- * If timeout = -1, it blocks forever.\n- *\n- * returns 1 or 2 depending if only one or both sockets\n- * fire at same time.\n- *\n- * *fdret is (one of) the active fds. If both sockets\n- * fire at same time, *fdret = fd always.\n- *\/\n-JNIEXPORT int JNICALL\n-NET_Timeout2(int fd, int fd1, long timeout, int *fdret) {\n-    int ret;\n-    fd_set tbl;\n-    struct timeval t, *tP = &t;\n-    if (timeout == -1) {\n-        tP = 0;\n-    } else {\n-        t.tv_sec = timeout \/ 1000;\n-        t.tv_usec = (timeout % 1000) * 1000;\n-    }\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    FD_SET(fd1, &tbl);\n-    ret = select (0, &tbl, 0, 0, tP);\n-    switch (ret) {\n-    case 0:\n-        return 0; \/* timeout *\/\n-    case 1:\n-        if (FD_ISSET (fd, &tbl)) {\n-            *fdret= fd;\n-        } else {\n-            *fdret= fd1;\n-        }\n-        return 1;\n-    case 2:\n-        *fdret= fd;\n-        return 2;\n-    }\n-    return -1;\n-}\n-\n@@ -549,189 +485,0 @@\n-\/* Macro, which cleans-up the iv6bind structure,\n- * closes the two sockets (if open),\n- * and returns SOCKET_ERROR. Used in NET_BindV6 only.\n- *\/\n-\n-#define CLOSE_SOCKETS_AND_RETURN do {   \\\n-    if (fd != -1) {                     \\\n-        closesocket (fd);               \\\n-        fd = -1;                        \\\n-    }                                   \\\n-    if (ofd != -1) {                    \\\n-        closesocket (ofd);              \\\n-        ofd = -1;                       \\\n-    }                                   \\\n-    if (close_fd != -1) {               \\\n-        closesocket (close_fd);         \\\n-        close_fd = -1;                  \\\n-    }                                   \\\n-    if (close_ofd != -1) {              \\\n-        closesocket (close_ofd);        \\\n-        close_ofd = -1;                 \\\n-    }                                   \\\n-    b->ipv4_fd = b->ipv6_fd = -1;       \\\n-    return SOCKET_ERROR;                \\\n-} while(0)\n-\n-\/*\n- * if ipv6 is available, call NET_BindV6 to bind to the required address\/port.\n- * Because the same port number may need to be reserved in both v4 and v6 space,\n- * this may require socket(s) to be re-opened. Therefore, all of this information\n- * is passed in and returned through the ipv6bind structure.\n- *\n- * If the request is to bind to a specific address, then this (by definition) means\n- * only bind in either v4 or v6, and this is just the same as normal. ie. a single\n- * call to bind() will suffice. The other socket is closed in this case.\n- *\n- * The more complicated case is when the requested address is ::0 or 0.0.0.0.\n- *\n- * Two further cases:\n- * 2. If the requested port is 0 (ie. any port) then we try to bind in v4 space\n- *    first with a wild-card port argument. We then try to bind in v6 space\n- *    using the returned port number. If this fails, we repeat the process\n- *    until a free port common to both spaces becomes available.\n- *\n- * 3. If the requested port is a specific port, then we just try to get that\n- *    port in both spaces, and if it is not free in both, then the bind fails.\n- *\n- * On failure, sockets are closed and an error returned with CLOSE_SOCKETS_AND_RETURN\n- *\/\n-\n-JNIEXPORT int JNICALL\n-NET_BindV6(struct ipv6bind *b, jboolean exclBind) {\n-    int fd=-1, ofd=-1, rv, len;\n-    \/* need to defer close until new sockets created *\/\n-    int close_fd=-1, close_ofd=-1;\n-    SOCKETADDRESS oaddr; \/* other address to bind *\/\n-    int family = b->addr->sa.sa_family;\n-    int ofamily;\n-    u_short port; \/* requested port parameter *\/\n-    u_short bound_port;\n-\n-    if (family == AF_INET && (b->addr->sa4.sin_addr.s_addr != INADDR_ANY)) {\n-        \/* bind to v4 only *\/\n-        int ret;\n-        ret = NET_WinBind((int)b->ipv4_fd, b->addr,\n-                          sizeof(SOCKETADDRESS), exclBind);\n-        if (ret == SOCKET_ERROR) {\n-            CLOSE_SOCKETS_AND_RETURN;\n-        }\n-        closesocket (b->ipv6_fd);\n-        b->ipv6_fd = -1;\n-        return 0;\n-    }\n-    if (family == AF_INET6 && (!IN6_IS_ADDR_ANY(&b->addr->sa6.sin6_addr))) {\n-        \/* bind to v6 only *\/\n-        int ret;\n-        ret = NET_WinBind((int)b->ipv6_fd, b->addr,\n-                          sizeof(SOCKETADDRESS), exclBind);\n-        if (ret == SOCKET_ERROR) {\n-            CLOSE_SOCKETS_AND_RETURN;\n-        }\n-        closesocket (b->ipv4_fd);\n-        b->ipv4_fd = -1;\n-        return 0;\n-    }\n-\n-    \/* We need to bind on both stacks, with the same port number *\/\n-\n-    memset (&oaddr, 0, sizeof(oaddr));\n-    if (family == AF_INET) {\n-        ofamily = AF_INET6;\n-        fd = (int)b->ipv4_fd;\n-        ofd = (int)b->ipv6_fd;\n-        port = (u_short)GET_PORT (b->addr);\n-        IN6ADDR_SETANY(&oaddr.sa6);\n-        oaddr.sa6.sin6_port = port;\n-    } else {\n-        ofamily = AF_INET;\n-        ofd = (int)b->ipv4_fd;\n-        fd = (int)b->ipv6_fd;\n-        port = (u_short)GET_PORT (b->addr);\n-        oaddr.sa4.sin_family = AF_INET;\n-        oaddr.sa4.sin_port = port;\n-        oaddr.sa4.sin_addr.s_addr = INADDR_ANY;\n-    }\n-\n-    rv = NET_WinBind(fd, b->addr, sizeof(SOCKETADDRESS), exclBind);\n-    if (rv == SOCKET_ERROR) {\n-        CLOSE_SOCKETS_AND_RETURN;\n-    }\n-\n-    \/* get the port and set it in the other address *\/\n-    len = sizeof(SOCKETADDRESS);\n-    if (getsockname(fd, (struct sockaddr *)b->addr, &len) == -1) {\n-        CLOSE_SOCKETS_AND_RETURN;\n-    }\n-    bound_port = GET_PORT (b->addr);\n-    SET_PORT (&oaddr, bound_port);\n-    if ((rv = NET_WinBind(ofd, &oaddr,\n-                          sizeof(SOCKETADDRESS), exclBind)) == SOCKET_ERROR) {\n-        int retries;\n-        int sotype, arglen=sizeof(sotype);\n-\n-        \/* no retries unless, the request was for any free port *\/\n-\n-        if (port != 0) {\n-            CLOSE_SOCKETS_AND_RETURN;\n-        }\n-\n-        getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotype, &arglen);\n-\n-#define SOCK_RETRIES 50\n-        \/* 50 is an arbitrary limit, just to ensure that this\n-         * cannot be an endless loop. Would expect socket creation to\n-         * succeed sooner.\n-         *\/\n-        for (retries = 0; retries < SOCK_RETRIES; retries ++) {\n-            int len;\n-            close_fd = fd; fd = -1;\n-            close_ofd = ofd; ofd = -1;\n-            b->ipv4_fd = SOCKET_ERROR;\n-            b->ipv6_fd = SOCKET_ERROR;\n-\n-            \/* create two new sockets *\/\n-            fd = (int)socket (family, sotype, 0);\n-            if (fd == SOCKET_ERROR) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-            ofd = (int)socket (ofamily, sotype, 0);\n-            if (ofd == SOCKET_ERROR) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-\n-            \/* bind random port on first socket *\/\n-            SET_PORT (&oaddr, 0);\n-            rv = NET_WinBind(ofd, &oaddr, sizeof(SOCKETADDRESS), exclBind);\n-            if (rv == SOCKET_ERROR) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-            \/* close the original pair of sockets before continuing *\/\n-            closesocket (close_fd);\n-            closesocket (close_ofd);\n-            close_fd = close_ofd = -1;\n-\n-            \/* bind new port on second socket *\/\n-            len = sizeof(SOCKETADDRESS);\n-            if (getsockname(ofd, &oaddr.sa, &len) == -1) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-            bound_port = GET_PORT (&oaddr);\n-            SET_PORT (b->addr, bound_port);\n-            rv = NET_WinBind(fd, b->addr, sizeof(SOCKETADDRESS), exclBind);\n-\n-            if (rv != SOCKET_ERROR) {\n-                if (family == AF_INET) {\n-                    b->ipv4_fd = fd;\n-                    b->ipv6_fd = ofd;\n-                } else {\n-                    b->ipv4_fd = ofd;\n-                    b->ipv6_fd = fd;\n-                }\n-                return 0;\n-            }\n-        }\n-        CLOSE_SOCKETS_AND_RETURN;\n-    }\n-    return 0;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":0,"deletions":253,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -60,10 +60,0 @@\n-\/*\n- * passed to NET_BindV6. Both ipv4_fd and ipv6_fd must be created and unbound\n- * sockets. On return they may refer to different sockets.\n- *\/\n-struct ipv6bind {\n-    SOCKETADDRESS      *addr;\n-    SOCKET              ipv4_fd;\n-    SOCKET              ipv6_fd;\n-};\n-\n@@ -124,15 +114,0 @@\n-\/*\n- * differs from NET_Timeout() as follows:\n- *\n- * If timeout = -1, it blocks forever.\n- *\n- * returns 1 or 2 depending if only one or both sockets\n- * fire at same time.\n- *\n- * *fdret is (one of) the active fds. If both sockets\n- * fire at same time, *fd == fd always.\n- *\/\n-JNIEXPORT int JNICALL NET_Timeout2(int fd, int fd1, long timeout, int *fdret);\n-\n-JNIEXPORT int JNICALL NET_BindV6(struct ipv6bind *b, jboolean exclBind);\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.h","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"}]}