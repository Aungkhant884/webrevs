{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,2 +65,16 @@\n-    \/\/ cached hash of this module to avoid needing to compute it many times\n-    private byte[] cachedHash;\n+    \/\/ Single-slot cache of this module's hash to avoid needing to compute\n+    \/\/ it many times. If there is a significant number of hash algorithms\n+    \/\/ used in the future, consider extending this cache to full\n+    \/\/ ConcurrentMap<String,byte[]>.\n+    \/\/\n+    \/\/ For correctness under concurrent updates, we need to wrap the fields\n+    \/\/ updated at the same time with the final wrapper.\n+    private CachedHash cachedHash;\n+    private final class CachedHash {\n+        public CachedHash(byte[] hash, String algorithm) {\n+            this.hash = hash;\n+            this.algorithm = algorithm;\n+        }\n+        final byte[] hash;\n+        final String algorithm;\n+    }\n@@ -142,4 +156,6 @@\n-        byte[] result = cachedHash;\n-        if (result != null)\n-            return result;\n-        if (hasher == null)\n+        CachedHash ch = cachedHash;\n+        if (ch != null && ch.algorithm.equals(algorithm)) {\n+            return ch.hash;\n+        }\n+\n+        if (hasher == null) {\n@@ -147,2 +163,4 @@\n-        cachedHash = result = hasher.generate(algorithm);\n-        return result;\n+        }\n+        byte[] hash = hasher.generate(algorithm);\n+        cachedHash = new CachedHash(hash, algorithm);\n+        return hash;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleReferenceImpl.java","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"}]}