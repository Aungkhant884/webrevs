{"files":[{"patch":"@@ -30,0 +30,3 @@\n+\/\/ Not inlined to preserve visibility of ciMetaData vtable symbol. Required by SA.\n+bool ciMetadata::is_classless() const { return false; }\n+\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  virtual bool is_classless() const         { return false; }\n+  virtual bool is_classless() const;\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1259,1 +1259,1 @@\n-  \/\/ If we are profiling parameters, we reserver an area near the end\n+  \/\/ If we are profiling parameters, we reserved an area near the end\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  volatile_nonstatic_field(Klass,              _subklass,                                     Klass*)                                 \\\n+  volatile_nonstatic_field(Klass,              _subklass,                                     Klass*)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import sun.jvm.hotspot.types.Field;\n@@ -47,1 +48,1 @@\n-    origField = type.getAddressField(\"_orig\");\n+    origField = type.getField(\"_orig\");\n@@ -64,1 +65,1 @@\n-  private static AddressField origField;\n+  private static Field origField;\n@@ -109,2 +110,2 @@\n-    byte[] result = new byte[MethodData.sizeofMethodDataOopDesc];\n-    for (int i = 0; i < MethodData.sizeofMethodDataOopDesc; i++) {\n+    byte[] result = new byte[(int)origField.getType().getSize()];\n+    for (int i = 0; i < result.length; i++) {\n@@ -119,1 +120,1 @@\n-    int elements = dataSize() \/ MethodData.cellSize;\n+    int elements = (dataSize() + extraDataSize()) \/ MethodData.cellSize;\n@@ -151,2 +152,1 @@\n-    Address base = getAddress().addOffsetTo(origField.getOffset());\n-    int di = (int)parametersTypeDataDi.getValue(base);\n+    int di = (int)parametersTypeDataDi.getValue(getMetadata().getAddress());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciMethodData.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,3 +84,2 @@\n-  int cellAt(int index) {\n-    \/\/ Cells are intptr_t sized but only contain ints as raw values\n-    return (int)data.getCIntegerAt(offset + cellOffset(index), MethodData.cellSize, false);\n+  long cellAt(int index) {\n+    return data.getCIntegerAt(offset + cellOffset(index), MethodData.cellSize, false);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/DataLayout.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -237,2 +237,2 @@\n-      visitor.doCInt(size, true);\n-    }\n+    visitor.doCInt(size, true);\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/MethodData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  int intptrAt(int index) {\n+  long intptrAt(int index) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ProfileData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    int v = pd.intptrAt(index);\n+    long v = pd.intptrAt(index);\n@@ -56,1 +56,1 @@\n-    int v = pd.intptrAt(index);\n+    long v = pd.intptrAt(index);\n@@ -61,1 +61,1 @@\n-    int v = pd.intptrAt(index);\n+    long v = pd.intptrAt(index);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/TypeEntries.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,2 +68,4 @@\n-        \"-Xcomp\", \"-XX:CICrashAt=1\", \"-XX:+DumpReplayDataOnError\",\n-        \"-XX:+PreferInterpreterNativeStubs\", \"-XX:+PrintCompilation\", REPLAY_FILE_OPTION};\n+        \"-XX:-BackgroundCompilation\", \"-XX:CompileCommand=inline,java.io.PrintStream::*\",\n+        \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:TypeProfileLevel=222\", \/\/ extra profile data as a stress test\n+        \"-XX:CICrashAt=1\", \"-XX:+DumpReplayDataOnError\",\n+        \"-XX:+PreferInterpreterNativeStubs\", REPLAY_FILE_OPTION};\n@@ -71,0 +73,1 @@\n+        \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:TypeProfileLevel=222\",\n@@ -77,2 +80,9 @@\n-            \/\/ Do something because empty methods might not be called\/compiled.\n-            dummy = 42;\n+            for (int i = 0; i < 20_000; i++) {\n+                test(i);\n+            }\n+        }\n+\n+        static void test(int i) {\n+            if ((i % 1000) == 0) {\n+                System.out.println(\"Hello World!\");\n+            }\n@@ -106,1 +116,1 @@\n-        if (generateReplay(needCoreDump)) {\n+        if (generateReplay(needCoreDump, args)) {\n@@ -141,0 +151,1 @@\n+        long pid = -1;\n@@ -146,1 +157,0 @@\n-            options.add(TestMain.class.getName());\n@@ -148,1 +158,4 @@\n-                crashOut = ProcessTools.executeProcess(getTestJvmCommandlineWithPrefix(\n+                \/\/ CiReplayBase$TestMain needs to be quoted because shell eval\n+                options.add(\"-XX:CompileOnly='\" + TestMain.class.getName() + \"::test'\");\n+                options.add(\"'\" + TestMain.class.getName() + \"'\");\n+                var outAndPID= ProcessTools.executeProcessPreservePID(getTestJvmCommandlineWithPrefix(\n@@ -150,0 +163,2 @@\n+                crashOut = outAndPID.output();\n+                pid = outAndPID.pid();\n@@ -151,0 +166,2 @@\n+                options.add(\"-XX:CompileOnly=\" + TestMain.class.getName() + \"::test\");\n+                options.add(TestMain.class.getName());\n@@ -162,1 +179,1 @@\n-            String coreFileLocation = getCoreFileLocation(crashOutputString);\n+            String coreFileLocation = getCoreFileLocation(crashOutputString, pid);\n@@ -254,1 +271,1 @@\n-    private String getCoreFileLocation(String crashOutputString) {\n+    private String getCoreFileLocation(String crashOutputString, long pid) {\n@@ -273,0 +290,1 @@\n+\n@@ -292,0 +310,20 @@\n+        if (Platform.isLinux()) {\n+            \/\/ Maybe a systemd linux system. Try to retrieve core\n+            \/\/ file. It can take a few seconds for the system to\n+            \/\/ process the just produced core file so we may need to\n+            \/\/ retry a few times.\n+            try {\n+                for (int i = 0; i < 10; i++) {\n+                    Thread.sleep(5000);\n+                    OutputAnalyzer out = ProcessTools.executeProcess(\"coredumpctl\", \"dump\",  \"-1\",  \"-o\", coreWithPid, Long.valueOf(pid).toString());\n+                    if (!out.getOutput().contains(\"output may be incomplete\")) {\n+                        break;\n+                    }\n+                }\n+            } catch(Throwable t) {\n+            }\n+            if (new File(coreWithPid).exists()) {\n+                return coreWithPid;\n+            }\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n@@ -44,1 +46,13 @@\n-        new SABase(args).runTest(\/* needCoreDump = *\/ true, args);\n+        SABase base = new SABase(args);\n+        boolean c2 = base.runServer.orElseThrow(() -> new Error(\"runServer must be set\"));\n+        String[] extra = {};\n+        if (Platform.isTieredSupported()) {\n+            if (c2) {\n+                \/\/ Replay produced on first compilation. We want that\n+                \/\/ compilation delayed so profile data is produced.\n+                extra = new String[] {\"-XX:-TieredCompilation\"};\n+            } else {\n+                extra = new String[] {\"-XX:TieredStopAtLevel=1\"};\n+            }\n+        }\n+        base.runTest(\/* needCoreDump = *\/ true, extra);\n@@ -99,0 +113,1 @@\n+        \/\/ other than comment lines, content of 2 files should be identical\n@@ -100,9 +115,31 @@\n-            FileInputStream rep = new FileInputStream(replay);\n-            FileInputStream repCopy = new FileInputStream(REPLAY_FILE_COPY);\n-            byte repBuffer[] = new byte[512];\n-            byte repCopyBuffer[] = new byte[512];\n-            boolean filesNotEqual = false;\n-            while(rep.available() > 0 && !filesNotEqual) {\n-                int count = rep.read(repBuffer);\n-                int count2 = repCopy.read(repCopyBuffer);\n-                filesNotEqual = count != count2 || Arrays.equals(repBuffer, repCopyBuffer);\n+            BufferedReader rep = new BufferedReader(new FileReader(replay));\n+            BufferedReader repCopy = new BufferedReader(new FileReader(REPLAY_FILE_COPY));\n+            boolean failure = false;\n+            while (true) {\n+                String l1;\n+                while ((l1 = rep.readLine()) != null) {\n+                    if (!l1.startsWith(\"#\")) {\n+                        break;\n+                    }\n+                }\n+                String l2;\n+                while ((l2 = repCopy.readLine()) != null) {\n+                    if (!l2.startsWith(\"#\")) {\n+                        break;\n+                    }\n+                }\n+                if (l1 == null || l2 == null) {\n+                    if (l1 != null || l2 != null) {\n+                        System.out.println(\"Warning: replay files are not equal\");\n+                        System.out.println(\"1: \" + l1);\n+                        System.out.println(\"2: \" + l2);\n+                        failure = true;\n+                    }\n+                    break;\n+                }\n+                if (!l1.equals(l2)) {\n+                    System.out.println(\"Warning: replay files are not equal\");\n+                    System.out.println(\"1: \" + l1);\n+                    System.out.println(\"2: \" + l2);\n+                    failure = true;\n+                }\n@@ -110,2 +147,2 @@\n-            if (filesNotEqual) {\n-                System.out.println(\"Warning: replay files are not equal\");\n+            if (failure) {\n+                throw new RuntimeException(\"Warning: replay files are not equal\");\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/SABase.java","additions":49,"deletions":12,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-        new VMBase(args).runTest(\/* needCoreDump = *\/ false, args);\n+        new VMBase(args).runTest(\/* needCoreDump = *\/ false);\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/VMBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -407,0 +407,12 @@\n+    \/**\n+     * Executes a process, waits for it to finish and returns the\n+     * process output and pid.  The process will have exited before\n+     * this method returns.\n+     *\n+     * @param pb The ProcessBuilder to execute.\n+     * @return The {@linkplain OutputAnalyzerAndPID} instance wrapping the process.\n+     *\/\n+    public static OutputAnalyzerAndPID executeProcessPreservePID(ProcessBuilder pb) throws Exception {\n+        return executeProcessPreservePID(pb, null);\n+    }\n+\n@@ -420,0 +432,13 @@\n+    \/**\n+     * Executes a process, pipe some text into its STDIN, waits for it\n+     * to finish and returns the process output and pid. The process\n+     * will have exited before this method returns.\n+     *\n+     * @param pb    The ProcessBuilder to execute.\n+     * @param input The text to pipe into STDIN. Can be null.\n+     * @return The {@linkplain OutputAnalyzerAndPID} instance wrapping the process.\n+     *\/\n+    public static OutputAnalyzerAndPID executeProcessPreservePID(ProcessBuilder pb, String input) throws Exception {\n+        return executeProcessPreservePID(pb, input, null);\n+    }\n+\n@@ -433,0 +458,35 @@\n+        return executeProcessPreservePID(pb, input, cs).output();\n+    }\n+\n+    static public class OutputAnalyzerAndPID {\n+        private OutputAnalyzer output;\n+        private long pid;\n+\n+        OutputAnalyzerAndPID(OutputAnalyzer output, long pid) {\n+            this.output = output;\n+            this.pid = pid;\n+        }\n+\n+        public OutputAnalyzer output() {\n+            return output;\n+        }\n+\n+        public long pid() {\n+            return pid;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Executes a process, pipe some text into its STDIN, waits for it\n+     * to finish and returns the process output and pid. The process\n+     * will have exited before this method returns.\n+     *\n+     * @param pb    The ProcessBuilder to execute.\n+     * @param input The text to pipe into STDIN. Can be null.\n+     * @param cs    The charset used to convert from bytes to chars or null for\n+     *              the default charset.\n+     * @return The {@linkplain OutputAnalyzerAndPID} instance wrapping the process.\n+     *\/\n+    public static OutputAnalyzerAndPID executeProcessPreservePID(ProcessBuilder pb, String input,\n+                                                                 Charset cs) throws Exception {\n@@ -459,1 +519,1 @@\n-            return output;\n+            return new OutputAnalyzerAndPID(output, p.pid());\n@@ -487,0 +547,13 @@\n+    \/**\n+     * Executes a process, waits for it to finish and returns the\n+     * process outputa and pid.\n+     * <p>\n+     * The process will have exited before this method returns.\n+     *\n+     * @param cmds The command line to execute.\n+     * @return The output from the process.\n+     *\/\n+    public static OutputAnalyzerAndPID executeProcessPreservePID(String... cmds) throws Throwable {\n+        return executeProcessPreservePID(new ProcessBuilder(cmds));\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":74,"deletions":1,"binary":false,"changes":75,"status":"modified"}]}