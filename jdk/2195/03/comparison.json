{"files":[{"patch":"@@ -30,0 +30,3 @@\n+\/\/ Not inlined to preserve visibility of ciMetaData vtable symbol. Required by SA.\n+bool ciMetadata::is_classless() const { return false; }\n+\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  virtual bool is_classless() const         { return false; }\n+  virtual bool is_classless() const;\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1259,1 +1259,1 @@\n-  \/\/ If we are profiling parameters, we reserver an area near the end\n+  \/\/ If we are profiling parameters, we reserved an area near the end\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  volatile_nonstatic_field(Klass,              _subklass,                                     Klass*)                                 \\\n+  volatile_nonstatic_field(Klass,              _subklass,                                     Klass*)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import sun.jvm.hotspot.types.Field;\n@@ -47,1 +48,1 @@\n-    origField = type.getAddressField(\"_orig\");\n+    origField = type.getField(\"_orig\");\n@@ -64,1 +65,1 @@\n-  private static AddressField origField;\n+  private static Field origField;\n@@ -109,2 +110,2 @@\n-    byte[] result = new byte[MethodData.sizeofMethodDataOopDesc];\n-    for (int i = 0; i < MethodData.sizeofMethodDataOopDesc; i++) {\n+    byte[] result = new byte[(int)origField.getType().getSize()];\n+    for (int i = 0; i < result.length; i++) {\n@@ -119,1 +120,1 @@\n-    int elements = dataSize() \/ MethodData.cellSize;\n+    int elements = (dataSize() + extraDataSize()) \/ MethodData.cellSize;\n@@ -151,2 +152,1 @@\n-    Address base = getAddress().addOffsetTo(origField.getOffset());\n-    int di = (int)parametersTypeDataDi.getValue(base);\n+    int di = (int)parametersTypeDataDi.getValue(getMetadata().getAddress());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciMethodData.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,3 +84,2 @@\n-  int cellAt(int index) {\n-    \/\/ Cells are intptr_t sized but only contain ints as raw values\n-    return (int)data.getCIntegerAt(offset + cellOffset(index), MethodData.cellSize, false);\n+  long cellAt(int index) {\n+    return data.getCIntegerAt(offset + cellOffset(index), MethodData.cellSize, false);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/DataLayout.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -237,2 +237,2 @@\n-      visitor.doCInt(size, true);\n-    }\n+    visitor.doCInt(size, true);\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/MethodData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  int intptrAt(int index) {\n+  long intptrAt(int index) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ProfileData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    int v = pd.intptrAt(index);\n+    long v = pd.intptrAt(index);\n@@ -56,1 +56,1 @@\n-    int v = pd.intptrAt(index);\n+    long v = pd.intptrAt(index);\n@@ -61,1 +61,1 @@\n-    int v = pd.intptrAt(index);\n+    long v = pd.intptrAt(index);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/TypeEntries.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.test.lib.util.CoreUtils;\n@@ -68,2 +69,4 @@\n-        \"-Xcomp\", \"-XX:CICrashAt=1\", \"-XX:+DumpReplayDataOnError\",\n-        \"-XX:+PreferInterpreterNativeStubs\", \"-XX:+PrintCompilation\", REPLAY_FILE_OPTION};\n+        \"-XX:-BackgroundCompilation\", \"-XX:CompileCommand=inline,java.io.PrintStream::*\",\n+        \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:TypeProfileLevel=222\", \/\/ extra profile data as a stress test\n+        \"-XX:CICrashAt=1\", \"-XX:+DumpReplayDataOnError\",\n+        \"-XX:+PreferInterpreterNativeStubs\", REPLAY_FILE_OPTION};\n@@ -71,0 +74,1 @@\n+        \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:TypeProfileLevel=222\",\n@@ -77,2 +81,9 @@\n-            \/\/ Do something because empty methods might not be called\/compiled.\n-            dummy = 42;\n+            for (int i = 0; i < 20_000; i++) {\n+                test(i);\n+            }\n+        }\n+\n+        static void test(int i) {\n+            if ((i % 1000) == 0) {\n+                System.out.println(\"Hello World!\");\n+            }\n@@ -106,1 +117,1 @@\n-        if (generateReplay(needCoreDump)) {\n+        if (generateReplay(needCoreDump, args)) {\n@@ -146,1 +157,0 @@\n-            options.add(TestMain.class.getName());\n@@ -148,2 +158,6 @@\n-                crashOut = ProcessTools.executeProcess(getTestJvmCommandlineWithPrefix(\n-                        RUN_SHELL_NO_LIMIT, options.toArray(new String[0])));\n+                \/\/ CiReplayBase$TestMain needs to be quoted because of shell eval\n+                options.add(\"-XX:CompileOnly='\" + TestMain.class.getName() + \"::test'\");\n+                options.add(\"'\" + TestMain.class.getName() + \"'\");\n+                crashOut = ProcessTools.executeProcess(\n+                        CoreUtils.addCoreUlimitCommand(\n+                                ProcessTools.createTestJvm(options.toArray(new String[0]))));\n@@ -151,0 +165,2 @@\n+                options.add(\"-XX:CompileOnly=\" + TestMain.class.getName() + \"::test\");\n+                options.add(TestMain.class.getName());\n@@ -162,10 +178,0 @@\n-            String coreFileLocation = getCoreFileLocation(crashOutputString);\n-            if (coreFileLocation == null) {\n-                if (Platform.isOSX()) {\n-                    File coresDir = new File(\"\/cores\");\n-                    if (!coresDir.isDirectory() || !coresDir.canWrite()) {\n-                        return false;\n-                    }\n-                }\n-                throw new Error(\"Couldn't find core file location in: '\" + crashOutputString + \"'\");\n-            }\n@@ -173,1 +179,1 @@\n-                Asserts.assertGT(new File(coreFileLocation).length(), 0L, \"Unexpected core size\");\n+                String coreFileLocation = CoreUtils.getCoreFileLocation(crashOutputString, crashOut.pid());\n@@ -253,42 +259,0 @@\n-    \/\/ lets search few possible locations using process output and return existing location\n-    private String getCoreFileLocation(String crashOutputString) {\n-        Asserts.assertTrue(crashOutputString.contains(LOCATIONS_STRING),\n-                \"Output doesn't contain the location of core file, see crash.out\");\n-        String stringWithLocation = Arrays.stream(crashOutputString.split(\"\\\\r?\\\\n\"))\n-                .filter(str -> str.contains(LOCATIONS_STRING))\n-                .findFirst()\n-                .get();\n-        stringWithLocation = stringWithLocation.substring(stringWithLocation\n-                .indexOf(LOCATIONS_STRING) + LOCATIONS_STRING.length());\n-        String coreWithPid;\n-        if (stringWithLocation.contains(\"or \") && !Platform.isWindows()) {\n-            Matcher m = Pattern.compile(\"or.* ([^ ]+[^\\\\)])\\\\)?\").matcher(stringWithLocation);\n-            if (!m.find()) {\n-                throw new Error(\"Couldn't find path to core inside location string\");\n-            }\n-            coreWithPid = m.group(1);\n-        } else {\n-            coreWithPid = stringWithLocation.trim();\n-        }\n-        if (new File(coreWithPid).exists()) {\n-            return coreWithPid;\n-        }\n-        String justCore = Paths.get(\"core\").toString();\n-        if (new File(justCore).exists()) {\n-            return justCore;\n-        }\n-        Path coreWithPidPath = Paths.get(coreWithPid);\n-        String justFile = coreWithPidPath.getFileName().toString();\n-        if (new File(justFile).exists()) {\n-            return justFile;\n-        }\n-        Path parent = coreWithPidPath.getParent();\n-        if (parent != null) {\n-            String coreWithoutPid = parent.resolve(\"core\").toString();\n-            if (new File(coreWithoutPid).exists()) {\n-                return coreWithoutPid;\n-            }\n-        }\n-        return null;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":25,"deletions":61,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n@@ -44,1 +46,13 @@\n-        new SABase(args).runTest(\/* needCoreDump = *\/ true, args);\n+        SABase base = new SABase(args);\n+        boolean c2 = base.runServer.orElseThrow(() -> new Error(\"runServer must be set\"));\n+        String[] extra = {};\n+        if (Platform.isTieredSupported()) {\n+            if (c2) {\n+                \/\/ Replay produced on first compilation. We want that\n+                \/\/ compilation delayed so profile data is produced.\n+                extra = new String[] {\"-XX:-TieredCompilation\"};\n+            } else {\n+                extra = new String[] {\"-XX:TieredStopAtLevel=1\"};\n+            }\n+        }\n+        base.runTest(\/* needCoreDump = *\/ true, extra);\n@@ -99,0 +113,1 @@\n+        \/\/ other than comment lines, content of 2 files should be identical\n@@ -100,9 +115,31 @@\n-            FileInputStream rep = new FileInputStream(replay);\n-            FileInputStream repCopy = new FileInputStream(REPLAY_FILE_COPY);\n-            byte repBuffer[] = new byte[512];\n-            byte repCopyBuffer[] = new byte[512];\n-            boolean filesNotEqual = false;\n-            while(rep.available() > 0 && !filesNotEqual) {\n-                int count = rep.read(repBuffer);\n-                int count2 = repCopy.read(repCopyBuffer);\n-                filesNotEqual = count != count2 || Arrays.equals(repBuffer, repCopyBuffer);\n+            BufferedReader rep = new BufferedReader(new FileReader(replay));\n+            BufferedReader repCopy = new BufferedReader(new FileReader(REPLAY_FILE_COPY));\n+            boolean failure = false;\n+            while (true) {\n+                String l1;\n+                while ((l1 = rep.readLine()) != null) {\n+                    if (!l1.startsWith(\"#\")) {\n+                        break;\n+                    }\n+                }\n+                String l2;\n+                while ((l2 = repCopy.readLine()) != null) {\n+                    if (!l2.startsWith(\"#\")) {\n+                        break;\n+                    }\n+                }\n+                if (l1 == null || l2 == null) {\n+                    if (l1 != null || l2 != null) {\n+                        System.out.println(\"Warning: replay files are not equal\");\n+                        System.out.println(\"1: \" + l1);\n+                        System.out.println(\"2: \" + l2);\n+                        failure = true;\n+                    }\n+                    break;\n+                }\n+                if (!l1.equals(l2)) {\n+                    System.out.println(\"Warning: replay files are not equal\");\n+                    System.out.println(\"1: \" + l1);\n+                    System.out.println(\"2: \" + l2);\n+                    failure = true;\n+                }\n@@ -110,2 +147,2 @@\n-            if (filesNotEqual) {\n-                System.out.println(\"Warning: replay files are not equal\");\n+            if (failure) {\n+                throw new RuntimeException(\"Warning: replay files are not equal\");\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/SABase.java","additions":49,"deletions":12,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-        new VMBase(args).runTest(\/* needCoreDump = *\/ false, args);\n+        new VMBase(args).runTest(\/* needCoreDump = *\/ false);\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/VMBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                coreFileName = CoreUtils.getCoreFileLocation(crashOutput.getStdout());\n+                coreFileName = CoreUtils.getCoreFileLocation(crashOutput.getStdout(), crashOutput.pid());\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbCDSCore.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                coreFileName = CoreUtils.getCoreFileLocation(theApp.getOutput().getStdout());\n+                coreFileName = CoreUtils.getCoreFileLocation(theApp.getOutput().getStdout(), theApp.getPid());\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-                coreFileName = CoreUtils.getCoreFileLocation(crashOutput);\n+                coreFileName = CoreUtils.getCoreFileLocation(crashOutput, theApp.getPid());\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbPmap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-                coreFileName = CoreUtils.getCoreFileLocation(crashOutput);\n+                coreFileName = CoreUtils.getCoreFileLocation(crashOutput, theApp.getPid());\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbPstack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        OutputAnalyzer output =  ProcessTools.executeProcess(pb);\n+        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n@@ -82,1 +82,1 @@\n-        String coreFileName = CoreUtils.getCoreFileLocation(output.getStdout());\n+        String coreFileName = CoreUtils.getCoreFileLocation(output.getStdout(), output.pid());\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJmapCore.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -569,0 +569,9 @@\n+    \/**\n+     * Get the process' pid\n+     *\n+     * @return pid\n+     *\/\n+    public long pid() {\n+        return buffer.pid();\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -72,0 +72,7 @@\n+  \/**\n+   * Returns the pid if available\n+   *\n+   * @return pid\n+   *\/\n+  public long pid();\n+\n@@ -160,0 +167,5 @@\n+\n+    @Override\n+    public long pid() {\n+      return p.pid();\n+    }\n@@ -187,0 +199,5 @@\n+\n+    @Override\n+    public long pid() {\n+      throw new RuntimeException(\"no process\");\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputBuffer.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    public static String getCoreFileLocation(String crashOutputString) throws IOException {\n+    public static String getCoreFileLocation(String crashOutputString, long pid) throws IOException {\n@@ -127,1 +127,2 @@\n-        \/\/ See if we can figure out the likely reason the core file was not found.\n+        \/\/ See if we can figure out the likely reason the core file was not found. Recover from\n+        \/\/ failure if possible.\n@@ -155,0 +156,24 @@\n+                        if (line.split(\"\\s\", 2)[0].endsWith(\"systemd-coredump\")) {\n+                            \/\/ A systemd linux system. Try to retrieve core\n+                            \/\/ file. It can take a few seconds for the system to\n+                            \/\/ process the just produced core file so we may need to\n+                            \/\/ retry a few times.\n+                            System.out.println(\"Running systemd-coredump: trying coredumpctl command\");\n+                            String core = \"core\";\n+                            try {\n+                                for (int i = 0; i < 10; i++) {\n+                                    Thread.sleep(5000);\n+                                    OutputAnalyzer out = ProcessTools.executeProcess(\"coredumpctl\", \"dump\",  \"-1\",  \"-o\", core, String.valueOf(pid));\n+                                    if (!out.getOutput().contains(\"output may be incomplete\")) {\n+                                        break;\n+                                    }\n+                                }\n+                            } catch(Throwable t) {\n+                            }\n+                            final File coreFile = new File(core);\n+                            if (coreFile.exists()) {\n+                                Asserts.assertGT(coreFile.length(), 0L, \"Unexpected core size\");\n+                                System.out.println(\"coredumpctl succeeded\");\n+                                return core;\n+                            }\n+                        }\n","filename":"test\/lib\/jdk\/test\/lib\/util\/CoreUtils.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"}]}