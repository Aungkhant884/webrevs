{"files":[{"patch":"@@ -34,45 +34,0 @@\n-\/\/ This constructor is used only by SystemDictionaryShared::clone_dumptime_tables().\n-\/\/ See comments there about the need for making a deep copy.\n-DumpTimeClassInfo::DumpTimeClassInfo(const DumpTimeClassInfo& src) {\n-  assert(DynamicDumpSharedSpaces, \"must be\");\n-\n-  _klass = src._klass;\n-  _nest_host = src._nest_host;\n-  _failed_verification = src._failed_verification;\n-  _is_archived_lambda_proxy = src._is_archived_lambda_proxy;\n-  _has_checked_exclusion = src._has_checked_exclusion;\n-  _id = src._id;\n-  _clsfile_size = src._clsfile_size;\n-  _clsfile_crc32 = src._clsfile_crc32;\n-  _excluded = src._excluded;\n-  _is_early_klass = src._is_early_klass;\n-  _verifier_constraints = nullptr;\n-  _verifier_constraint_flags = nullptr;\n-  _loader_constraints = nullptr;\n-\n-  assert(src._enum_klass_static_fields == nullptr, \"This should not happen with dynamic dump.\");\n-  _enum_klass_static_fields = nullptr;\n-\n-  {\n-    int n = src.num_verifier_constraints();\n-    if (n > 0) {\n-      _verifier_constraints = new (mtClass) GrowableArray<DTVerifierConstraint>(n, mtClass);\n-      _verifier_constraint_flags = new (mtClass) GrowableArray<char>(n, mtClass);\n-      for (int i = 0; i < n; i++) {\n-        _verifier_constraints->append(src._verifier_constraints->at(i));\n-        _verifier_constraint_flags->append(src._verifier_constraint_flags->at(i));\n-      }\n-    }\n-  }\n-\n-  {\n-    int n = src.num_loader_constraints();\n-    if (n > 0) {\n-      _loader_constraints = new (mtClass) GrowableArray<DTLoaderConstraint>(n, mtClass);\n-      for (int i = 0; i < n; i++) {\n-        _loader_constraints->append(src._loader_constraints->at(i));\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -148,1 +148,0 @@\n-  DumpTimeClassInfo(const DumpTimeClassInfo& src);\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -120,3 +120,0 @@\n-    \/\/ save dumptime tables\n-    SystemDictionaryShared::clone_dumptime_tables();\n-\n@@ -170,3 +167,0 @@\n-    \/\/ Restore dumptime tables\n-    SystemDictionaryShared::restore_dumptime_tables();\n-\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -475,2 +475,0 @@\n-  static void copy_shared_path_table(ClassLoaderData* loader_data, TRAPS);\n-  static void clone_shared_path_table(TRAPS);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,13 +31,0 @@\n-\/\/ This constructor is used only by SystemDictionaryShared::clone_dumptime_tables().\n-\/\/ See comments there about the need for making a deep copy.\n-DumpTimeLambdaProxyClassInfo::DumpTimeLambdaProxyClassInfo(const DumpTimeLambdaProxyClassInfo& src) {\n-  _proxy_klasses = nullptr;\n-  if (src._proxy_klasses != nullptr && src._proxy_klasses->length() > 0) {\n-    int n = src._proxy_klasses->length();\n-    _proxy_klasses = new (mtClassShared) GrowableArray<InstanceKlass*>(n, mtClassShared);\n-    for (int i = 0; i < n; i++) {\n-      _proxy_klasses->append(src._proxy_klasses->at(i));\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-  DumpTimeLambdaProxyClassInfo(const DumpTimeLambdaProxyClassInfo& src);\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-DumpTimeSharedClassTable* SystemDictionaryShared::_cloned_dumptime_table = nullptr;\n@@ -82,1 +81,0 @@\n-DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_cloned_dumptime_lambda_proxy_class_dictionary = nullptr;\n@@ -1443,81 +1441,0 @@\n-class CloneDumpTimeClassTable: public StackObj {\n-  DumpTimeSharedClassTable* _table;\n-  DumpTimeSharedClassTable* _cloned_table;\n- public:\n-  CloneDumpTimeClassTable(DumpTimeSharedClassTable* table, DumpTimeSharedClassTable* clone) :\n-                      _table(table), _cloned_table(clone) {\n-    assert(_table != nullptr, \"_dumptime_table is nullptr\");\n-    assert(_cloned_table != nullptr, \"_cloned_table is nullptr\");\n-  }\n-  void do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n-    bool created;\n-    _cloned_table->put_if_absent(k, info, &created);\n-    assert(created, \"must be\");\n-  }\n-};\n-\n-class CloneDumpTimeLambdaProxyClassTable: StackObj {\n-  DumpTimeLambdaProxyClassDictionary* _table;\n-  DumpTimeLambdaProxyClassDictionary* _cloned_table;\n- public:\n-  CloneDumpTimeLambdaProxyClassTable(DumpTimeLambdaProxyClassDictionary* table,\n-                                     DumpTimeLambdaProxyClassDictionary* clone) :\n-                      _table(table), _cloned_table(clone) {\n-    assert(_table != nullptr, \"_dumptime_table is nullptr\");\n-    assert(_cloned_table != nullptr, \"_cloned_table is nullptr\");\n-  }\n-\n-  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    assert_lock_strong(DumpTimeTable_lock);\n-    bool created;\n-    \/\/ make copies then store in _clone_table\n-    LambdaProxyClassKey keyCopy = key;\n-    _cloned_table->put_if_absent(keyCopy, info, &created);\n-    assert(created, \"must be\");\n-    ++ _cloned_table->_count;\n-    return true; \/\/ keep on iterating\n-  }\n-};\n-\n-\/\/ When dumping the CDS archive, the ArchiveBuilder will irrecoverably modify the\n-\/\/ _dumptime_table and _dumptime_lambda_proxy_class_dictionary (e.g., metaspace\n-\/\/ pointers are changed to use \"buffer\" addresses.)\n-\/\/\n-\/\/ We save a copy of these tables and restore them after the dumping is finished.\n-\/\/ This makes it possible to repeat the dumping operation (e.g., use\n-\/\/ \"jcmd VM.cds dynamic_dump\" multiple times on the same JVM process).\n-\/\/\n-\/\/ We use the copy constructors to clone the values in these tables. The copy constructors\n-\/\/ must make a deep copy, as internal data structures such as the contents of\n-\/\/ DumpTimeClassInfo::_loader_constraints are also modified by the ArchiveBuilder.\n-\n-void SystemDictionaryShared::clone_dumptime_tables() {\n-  Arguments::assert_is_dumping_archive();\n-  assert_lock_strong(DumpTimeTable_lock);\n-\n-  assert(_cloned_dumptime_table == nullptr, \"_cloned_dumptime_table must be cleaned\");\n-  _cloned_dumptime_table = new (mtClass) DumpTimeSharedClassTable;\n-  CloneDumpTimeClassTable copy_classes(_dumptime_table, _cloned_dumptime_table);\n-  _dumptime_table->iterate_all_live_classes(&copy_classes);\n-  _cloned_dumptime_table->update_counts();\n-\n-  assert(_cloned_dumptime_lambda_proxy_class_dictionary == nullptr,\n-         \"_cloned_dumptime_lambda_proxy_class_dictionary must be cleaned\");\n-  _cloned_dumptime_lambda_proxy_class_dictionary =\n-                                        new (mtClass) DumpTimeLambdaProxyClassDictionary;\n-  CloneDumpTimeLambdaProxyClassTable copy_proxy_classes(_dumptime_lambda_proxy_class_dictionary,\n-                                                        _cloned_dumptime_lambda_proxy_class_dictionary);\n-  _dumptime_lambda_proxy_class_dictionary->iterate(&copy_proxy_classes);\n-}\n-\n-void SystemDictionaryShared::restore_dumptime_tables() {\n-  assert_lock_strong(DumpTimeTable_lock);\n-  delete _dumptime_table;\n-  _dumptime_table = _cloned_dumptime_table;\n-  _cloned_dumptime_table = nullptr;\n-\n-  delete _dumptime_lambda_proxy_class_dictionary;\n-  _dumptime_lambda_proxy_class_dictionary = _cloned_dumptime_lambda_proxy_class_dictionary;\n-  _cloned_dumptime_lambda_proxy_class_dictionary = nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-  static DumpTimeSharedClassTable* _cloned_dumptime_table;\n@@ -169,1 +168,0 @@\n-  static DumpTimeLambdaProxyClassDictionary* _cloned_dumptime_lambda_proxy_class_dictionary;\n@@ -293,9 +291,0 @@\n-  \/\/ For repeatable dumping, we\n-  \/\/   1. clone DumpTimeSharedClassTable, same for DumpTimeLambdaProxyClassDictionary\n-  \/\/      clone SharedClassPathTable\n-  \/\/   2. do dumping\n-  \/\/   3. restore DumpTimeSharedClassTable, DumpTimeLambdaProxyClassDictionary and SharedClassPathTable\n-  \/\/      from cloned versions.\n-  static void clone_dumptime_tables();\n-  static void restore_dumptime_tables();\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"}]}