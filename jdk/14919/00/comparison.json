{"files":[{"patch":"@@ -92,0 +92,7 @@\n+  product(bool, PreventTHPsForThreadStacks, true, EXPERIMENTAL,         \\\n+          \"If true, the JVM will attempt to prevent formation of \"      \\\n+          \"transparent huge pages in thread stacks.\")                   \\\n+                                                                        \\\n+  develop(bool, DelayThreadStartALot, false,                            \\\n+          \"Artificially delay thread starts randomly for testing.\")     \\\n+                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -778,0 +778,4 @@\n+  if (DelayThreadStartALot) {\n+    os::naked_short_sleep(100);\n+  }\n+\n@@ -914,0 +918,23 @@\n+\n+  \/\/ If THPs are unconditionally enabled, the following scenario can lead to huge RSS:\n+  \/\/ - parent thread spawns, in quick succession, multiple child threads\n+  \/\/ - child threads are slow to start\n+  \/\/ - thread stacks of future child threads are adjacent and get merged into one large VMA\n+  \/\/   by the kernel, and subsequently transformed into huge pages by khugepaged\n+  \/\/ - child threads come up, place JVM guard pages, thus splinter the large VMA, splinter\n+  \/\/   the huge pages into many (still paged-in) small pages.\n+  \/\/ The result of that sequence are thread stacks that are fully paged-in even though the\n+  \/\/ threads did not even start yet.\n+  \/\/ We prevent that by letting the glibc allocate a guard page, which causes a VMA with different\n+  \/\/ permission bits to separate two ajacent thread stacks and therefore prevent merging stacks\n+  \/\/ into one VMA.\n+  if (PreventTHPsForThreadStacks) {\n+    guard_size = MAX2(guard_size, os::vm_page_size());\n+    \/\/ Add an additional page to the stack size to reduce its chances of getting huge page aligned\n+    \/\/ so that the stack does not get backed by a transparent huge page.\n+    if (HugePages::thp_pagesize() > 0 &&\n+        is_aligned(stack_size, HugePages::thp_pagesize())) {\n+      stack_size += os::vm_page_size();\n+    }\n+  }\n+\n@@ -934,9 +961,0 @@\n-  \/\/ Add an additional page to the stack size to reduce its chances of getting large page aligned\n-  \/\/ so that the stack does not get backed by a transparent huge page.\n-  size_t default_large_page_size = HugePages::default_static_hugepage_size();\n-  if (default_large_page_size != 0 &&\n-      stack_size >= default_large_page_size &&\n-      is_aligned(stack_size, default_large_page_size)) {\n-    stack_size += os::vm_page_size();\n-  }\n-\n@@ -3743,0 +3761,15 @@\n+  \/\/ If THPs are unconditionally enabled (THP mode \"always\"), khugepaged may attempt to\n+  \/\/ coalesce small pages in thread stacks to huge pages. That costs a lot of memory and\n+  \/\/ is usually unwanted for thread stacks. Therefore we attempt to prevent THP formation in\n+  \/\/ thread stacks unless the user explicitly allowed THP formation by manually disabling\n+  \/\/ -XX:-PreventTHPsForThreadStacks.\n+  if (HugePages::thp_mode() == THPMode::always) {\n+    if (PreventTHPsForThreadStacks) {\n+      log_info(pagesize)(\"JVM will attempt to prevent THPs in thread stacks.\");\n+    } else if (!FLAG_IS_DEFAULT(PreventTHPsForThreadStacks)) {\n+      log_info(pagesize)(\"JVM will *not* prevent THPs in thread stacks. This may cause high RSS.\");\n+    }\n+  } else {\n+    FLAG_SET_ERGO(PreventTHPsForThreadStacks, false); \/\/ not needed\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,242 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=ENABLED\n+ * @bug 8303215 8312182\n+ * @summary On THP=always systems, we prevent THPs from forming within thread stacks\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @requires vm.debug\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver THPsInThreadStackPreventionTest PATCH-ENABLED\n+ *\/\n+\n+\/*\n+ * Note: only run manually, since this test is very costly (>2 GB)! Remove this line to run test.\n+ * @test id=DISABLED\n+ * @bug 8303215 8312182\n+ * @summary On THP=always systems, we prevent THPs from forming within thread stacks (negative test)\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @requires vm.debug\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver THPsInThreadStackPreventionTest  PATCH-DISABLED\n+ *\/\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+\n+public class THPsInThreadStackPreventionTest {\n+\n+    \/\/ We test the mitigation for \"huge rss for THP=always\" introduced with JDK-8312182 and JDK-8302015:\n+    \/\/\n+    \/\/ We start a program that spawns a ton of threads with a stack size close to THP page size. The threads\n+    \/\/ are idle and should not build up a lot of stack. The threads are started with an artificial delay\n+    \/\/ between thread start and stack guardpage creation, which exacerbates the RSS bloat (for explanation\n+    \/\/ please see 8312182).\n+    \/\/\n+    \/\/ We then observe RSS of that program. We expect it to stay below a reasonable maximum. The unpatched\n+    \/\/ version should show an RSS of ~2 GB (paying for the fully paged in thread stacks). The fixed variant should\n+    \/\/ cost only ~200-400 MB.\n+\n+    static final int numThreads = 1000;\n+    static final long threadStackSizeMB = 2; \/\/ must be 2M\n+    static final long heapSizeMB = 64;\n+    static final long basicRSSOverheadMB = heapSizeMB + 150;\n+    \/\/ A successful completion of this test would show not more than X KB per thread stack.\n+    static final long acceptableRSSPerThreadStack = 128 * 1024;\n+    static final long acceptableRSSForAllThreadStacks = numThreads * acceptableRSSPerThreadStack;\n+    static final long acceptableRSSLimitMB = (acceptableRSSForAllThreadStacks \/ (1024 * 1024)) + basicRSSOverheadMB;\n+\n+    private static class TestMain {\n+\n+        static class Sleeper extends Thread {\n+            CyclicBarrier barrier;\n+            public Sleeper(CyclicBarrier barrier) {\n+                this.barrier = barrier;\n+            }\n+            @Override\n+            public void run() {\n+                try {\n+                    barrier.await(); \/\/ wait for all siblings\n+                    barrier.await(); \/\/ wait main thread to print status\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+\n+        public static void main(String[] args) throws BrokenBarrierException, InterruptedException {\n+\n+            \/\/ Fire up 1000 threads with 2M stack size each.\n+            Sleeper[] threads = new Sleeper[numThreads];\n+            CyclicBarrier barrier = new CyclicBarrier(numThreads + 1);\n+\n+            for (int i = 0; i < numThreads; i++) {\n+                threads[i] = new Sleeper(barrier);\n+                threads[i].start();\n+            }\n+\n+            \/\/ Wait for all threads to come up\n+            barrier.await();\n+\n+            \/\/ print status\n+            String file = \"\/proc\/self\/status\";\n+            try (FileReader fr = new FileReader(file);\n+                 BufferedReader reader = new BufferedReader(fr)) {\n+                String line;\n+                while ((line = reader.readLine()) != null) {\n+                    System.out.println(line);\n+                }\n+            } catch (IOException | NumberFormatException e) { \/* ignored *\/ }\n+\n+            \/\/ Signal threads to stop\n+            barrier.await();\n+\n+        }\n+    }\n+\n+    static class ProcSelfStatus {\n+\n+        public long rssMB;\n+        public long swapMB;\n+        public int numLifeThreads;\n+\n+        \/\/ Parse output from \/proc\/self\/status\n+        public static ProcSelfStatus parse(OutputAnalyzer o) {\n+            ProcSelfStatus status = new ProcSelfStatus();\n+            String s = o.firstMatch(\"Threads:\\\\s*(\\\\d+)\", 1);\n+            Objects.requireNonNull(s);\n+            status.numLifeThreads = Integer.parseInt(s);\n+            s = o.firstMatch(\"VmRSS:\\\\s*(\\\\d+) kB\", 1);\n+            Objects.requireNonNull(s);\n+            status.rssMB = Long.parseLong(s) \/ 1024;\n+            s = o.firstMatch(\"VmSwap:\\\\s*(\\\\d+) kB\", 1);\n+            Objects.requireNonNull(s);\n+            status.swapMB = Long.parseLong(s) \/ 1024;\n+            return status;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        HugePageConfiguration config = HugePageConfiguration.readFromOS();\n+        \/\/ This issue is bound to THP=always\n+        if (config.getThpMode() != HugePageConfiguration.THPMode.always) {\n+            throw new SkippedException(\"Test only makes sense in THP \\\"always\\\" mode\");\n+        }\n+\n+        String[] defaultArgs = {\n+            \"-Xlog:pagesize\",\n+            \"-Xmx\" + heapSizeMB + \"m\", \"-Xms\" + heapSizeMB + \"m\", \"-XX:+AlwaysPreTouch\", \/\/ stabilize RSS\n+            \"-Xss\" + threadStackSizeMB + \"m\",\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \/\/ This will delay the child threads before they create guard pages, thereby greatly increasing the\n+            \/\/ chance of large VMA formation + hugepage coalescation; see JDK-8312182\n+            \"-XX:+DelayThreadStartALot\"\n+        };\n+        ArrayList<String> finalargs = new ArrayList<>(Arrays.asList(defaultArgs));\n+\n+        switch (args[0]) {\n+            case \"PATCH-ENABLED\": {\n+                finalargs.add(TestMain.class.getName());\n+                ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs);\n+\n+                OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+                output.shouldHaveExitValue(0);\n+\n+                \/\/ this line indicates the mitigation is active:\n+                output.shouldContain(\"[pagesize] JVM will attempt to prevent THPs in thread stacks.\");\n+\n+                ProcSelfStatus status = ProcSelfStatus.parse(output);\n+                if (status.numLifeThreads < numThreads) {\n+                    throw new RuntimeException(\"Number of live threads lower than expected: \" + status.numLifeThreads + \", expected \" + numThreads);\n+                } else {\n+                    System.out.println(\"Found \" + status.numLifeThreads + \" to be alive. Ok.\");\n+                }\n+\n+                long rssPlusSwapMB = status.swapMB + status.rssMB;\n+\n+                if (rssPlusSwapMB > acceptableRSSLimitMB) {\n+                    throw new RuntimeException(\"RSS+Swap larger than expected: \" + rssPlusSwapMB + \"m, expected at most \" + acceptableRSSLimitMB + \"m\");\n+                } else {\n+                    if (rssPlusSwapMB < heapSizeMB) { \/\/ we pretouch the java heap, so we expect to see at least that:\n+                        throw new RuntimeException(\"RSS+Swap suspiciously low: \" + rssPlusSwapMB + \"m, expected at least \" + heapSizeMB + \"m\");\n+                    }\n+                    System.out.println(\"Okay: RSS+Swap=\" + rssPlusSwapMB + \", within acceptable limit of \" + acceptableRSSLimitMB);\n+                }\n+            }\n+            break;\n+\n+            case \"PATCH-DISABLED\": {\n+\n+                \/\/ Only execute manually! this will allocate ~2gb of memory!\n+\n+                \/\/ explicitly disable the no-THP-workaround:\n+                finalargs.add(\"-XX:+UnlockExperimentalVMOptions\");\n+                finalargs.add(\"-XX:-PreventTHPsForThreadStacks\");\n+\n+                finalargs.add(TestMain.class.getName());\n+                ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs);\n+                OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+                output.shouldHaveExitValue(0);\n+\n+                \/\/ We deliberately switched off mitigation, VM should tell us:\n+                output.shouldContain(\"[pagesize] JVM will *not* prevent THPs in thread stacks. This may cause high RSS.\");\n+\n+                \/\/ Parse output from self\/status\n+                ProcSelfStatus status = ProcSelfStatus.parse(output);\n+                if (status.numLifeThreads < numThreads) {\n+                    throw new RuntimeException(\"Number of live threads lower than expected (\" + status.numLifeThreads + \", expected \" + numThreads +\")\");\n+                } else {\n+                    System.out.println(\"Found \" + status.numLifeThreads + \" to be alive. Ok.\");\n+                }\n+\n+                long rssPlusSwapMB = status.swapMB + status.rssMB;\n+\n+                if (rssPlusSwapMB < acceptableRSSLimitMB) {\n+                    throw new RuntimeException(\"RSS+Swap lower than expected: \" + rssPlusSwapMB + \"m, expected more than \" + acceptableRSSLimitMB + \"m\");\n+                }\n+                break;\n+            }\n+\n+            default: throw new RuntimeException(\"Bad argument: \" + args[0]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/THPsInThreadStackPreventionTest.java","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"}]}