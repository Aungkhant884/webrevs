{"files":[{"patch":"@@ -919,12 +919,0 @@\n-  \/\/ If THPs are unconditionally enabled, the following scenario can lead to huge RSS:\n-  \/\/ - parent thread spawns, in quick succession, multiple child threads\n-  \/\/ - child threads are slow to start\n-  \/\/ - thread stacks of future child threads are adjacent and get merged into one large VMA\n-  \/\/   by the kernel, and subsequently transformed into huge pages by khugepaged\n-  \/\/ - child threads come up, place JVM guard pages, thus splinter the large VMA, splinter\n-  \/\/   the huge pages into many (still paged-in) small pages.\n-  \/\/ The result of that sequence are thread stacks that are fully paged-in even though the\n-  \/\/ threads did not even start yet.\n-  \/\/ We prevent that by letting the glibc allocate a guard page, which causes a VMA with different\n-  \/\/ permission bits to separate two ajacent thread stacks and therefore prevent merging stacks\n-  \/\/ into one VMA.\n@@ -932,3 +920,5 @@\n-    guard_size = MAX2(guard_size, os::vm_page_size());\n-    \/\/ Add an additional page to the stack size to reduce its chances of getting huge page aligned\n-    \/\/ so that the stack does not get backed by a transparent huge page.\n+    \/\/ In addition to the glibc guard page that prevents inter-thread-stack hugepage\n+    \/\/ coalescation (see comment in os::Linux::default_guard_size()), we also make\n+    \/\/ sure the stack size itself is not huge-page-size aligned; that makes it much\n+    \/\/ more likely for thread stack boundaries to be unaligned as well and hence\n+    \/\/ protects thread stacks from being targeted by khugepaged.\n@@ -3098,0 +3088,21 @@\n+\n+  if (PreventTHPsForThreadStacks) {\n+    \/\/ If THPs are unconditionally enabled, the following scenario can lead to huge RSS\n+    \/\/ - parent thread spawns, in quick succession, multiple child threads\n+    \/\/ - child threads are slow to start\n+    \/\/ - thread stacks of future child threads are adjacent and get merged into one large VMA\n+    \/\/   by the kernel, and subsequently transformed into huge pages by khugepaged\n+    \/\/ - child threads come up, place JVM guard pages, thus splinter the large VMA, splinter\n+    \/\/   the huge pages into many (still paged-in) small pages.\n+    \/\/ The result of that sequence are thread stacks that are fully paged-in even though the\n+    \/\/ threads did not even start yet.\n+    \/\/ We prevent that by letting the glibc allocate a guard page, which causes a VMA with different\n+    \/\/ permission bits to separate two ajacent thread stacks and therefore prevent merging stacks\n+    \/\/ into one VMA.\n+    \/\/\n+    \/\/ Yes, this means we have two guard sections - the glibc and the JVM one - per thread. But the\n+    \/\/ cost for that one extra protected page is dwarfed a large win in performance and memory that\n+    \/\/ avoiding interference by khugepaged buys us.\n+    return os::vm_page_size();\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"}]}