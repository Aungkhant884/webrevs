{"files":[{"patch":"@@ -161,28 +161,0 @@\n-\n-    \/\/ -- native methods --\n-\n-    private static native void init();\n-\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * a platform-specific function or system call possibly having kernel\n-     * support.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\n-     * @return 0 on success, UNAVAILABLE if the platform function would block,\n-     *         UNSUPPORTED_CASE if the call does not work with the given\n-     *         parameters, or UNSUPPORTED if direct copying is not supported\n-     *         on this platform\n-     *\/\n-    private static native int directCopy0(int dst, int src,\n-                                          long addressToPollForCancel)\n-        throws UnixException;\n-\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"nio\");\n-        init();\n-    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -71,0 +71,18 @@\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, UNAVAILABLE if the platform function would block,\n+     *         UNSUPPORTED_CASE if the call does not work with the given\n+     *         parameters, or UNSUPPORTED if direct copying is not supported\n+     *         on this platform\n+     *\/\n+    static native int directCopy0(int dst, int src, long addressToPollForCancel)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jlong.h\"\n-\n-#include \"nio.h\"\n-\n-#include <stdlib.h>\n-#include <unistd.h>\n-#include <errno.h>\n-\n-#include <sys\/sendfile.h>\n-#include <fcntl.h>\n-#include <dlfcn.h>\n-\n-#include \"sun_nio_fs_LinuxFileSystem.h\"\n-\n-typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n-                                     unsigned int);\n-static copy_file_range_func* my_copy_file_range_func = NULL;\n-\n-#define RESTARTABLE(_cmd, _result) do { \\\n-  do { \\\n-    _result = _cmd; \\\n-  } while((_result == -1) && (errno == EINTR)); \\\n-} while(0)\n-\n-static void throwUnixException(JNIEnv* env, int errnum) {\n-    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n-        \"(I)V\", errnum);\n-    if (x != NULL) {\n-        (*env)->Throw(env, x);\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_LinuxFileSystem_init\n-    (JNIEnv* env, jclass this)\n-{\n-    my_copy_file_range_func =\n-        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n-}\n-\n-\/\/ Copy all bytes from src to dst, within the kernel if possible,\n-\/\/ and return zero, otherwise return the appropriate status code.\n-\/\/\n-\/\/ Return value\n-\/\/   0 on success\n-\/\/   IOS_UNAVAILABLE if the platform function would block\n-\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n-\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n-\/\/   IOS_THROWN if a Java exception is thrown\n-\/\/\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_LinuxFileSystem_directCopy0\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n-{\n-    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n-\n-    \/\/ Transfer within the kernel\n-    const size_t count = cancel != NULL ?\n-        1048576 :   \/\/ 1 MB to give cancellation a chance\n-        0x7ffff000; \/\/ maximum number of bytes that sendfile() can transfer\n-\n-    ssize_t bytes_sent;\n-    if (my_copy_file_range_func != NULL) {\n-        do {\n-            RESTARTABLE(my_copy_file_range_func(src, NULL, dst, NULL, count, 0),\n-                                                bytes_sent);\n-            if (bytes_sent < 0) {\n-                switch (errno) {\n-                    case EINVAL:\n-                    case ENOSYS:\n-                    case EXDEV:\n-                        \/\/ ignore and try sendfile()\n-                        break;\n-                    default:\n-                        JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n-                        return IOS_THROWN;\n-                }\n-            }\n-            if (cancel != NULL && *cancel != 0) {\n-                throwUnixException(env, ECANCELED);\n-                return IOS_THROWN;\n-            }\n-        } while (bytes_sent > 0);\n-\n-        if (bytes_sent == 0)\n-            return 0;\n-    }\n-\n-    do {\n-        RESTARTABLE(sendfile64(dst, src, NULL, count), bytes_sent);\n-        if (bytes_sent < 0) {\n-            if (errno == EAGAIN)\n-                return IOS_UNAVAILABLE;\n-            if (errno == EINVAL || errno == ENOSYS)\n-                return IOS_UNSUPPORTED_CASE;\n-            throwUnixException(env, errno);\n-            return IOS_THROWN;\n-        }\n-        if (cancel != NULL && *cancel != 0) {\n-            throwUnixException(env, ECANCELED);\n-            return IOS_THROWN;\n-        }\n-    } while (bytes_sent > 0);\n-\n-    return 0;\n-}\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxFileSystem.c","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"nio.h\"\n+\n@@ -38,0 +40,2 @@\n+#include <sys\/sendfile.h>\n+\n@@ -45,0 +49,10 @@\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n@@ -66,0 +80,3 @@\n+\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n@@ -153,0 +170,67 @@\n+\n+\/\/ Copy all bytes from src to dst, within the kernel if possible,\n+\/\/ and return zero, otherwise return the appropriate status code.\n+\/\/\n+\/\/ Return value\n+\/\/   0 on success\n+\/\/   IOS_UNAVAILABLE if the platform function would block\n+\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n+\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n+\/\/   IOS_THROWN if a Java exception is thrown\n+\/\/\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxNativeDispatcher_directCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n+{\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    \/\/ Transfer within the kernel\n+    const size_t count = cancel != NULL ?\n+        1048576 :   \/\/ 1 MB to give cancellation a chance\n+        0x7ffff000; \/\/ maximum number of bytes that sendfile() can transfer\n+\n+    ssize_t bytes_sent;\n+    if (my_copy_file_range_func != NULL) {\n+        do {\n+            RESTARTABLE(my_copy_file_range_func(src, NULL, dst, NULL, count, 0),\n+                                                bytes_sent);\n+            if (bytes_sent < 0) {\n+                switch (errno) {\n+                    case EINVAL:\n+                    case ENOSYS:\n+                    case EXDEV:\n+                        \/\/ ignore and try sendfile()\n+                        break;\n+                    default:\n+                        JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                        return IOS_THROWN;\n+                }\n+            }\n+            if (cancel != NULL && *cancel != 0) {\n+                throwUnixException(env, ECANCELED);\n+                return IOS_THROWN;\n+            }\n+        } while (bytes_sent > 0);\n+\n+        if (bytes_sent == 0)\n+            return 0;\n+    }\n+\n+    do {\n+        RESTARTABLE(sendfile64(dst, src, NULL, count), bytes_sent);\n+        if (bytes_sent < 0) {\n+            if (errno == EAGAIN)\n+                return IOS_UNAVAILABLE;\n+            if (errno == EINVAL || errno == ENOSYS)\n+                return IOS_UNSUPPORTED_CASE;\n+            throwUnixException(env, errno);\n+            return IOS_THROWN;\n+        }\n+        if (cancel != NULL && *cancel != 0) {\n+            throwUnixException(env, ECANCELED);\n+            return IOS_THROWN;\n+        }\n+    } while (bytes_sent > 0);\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"}]}