{"files":[{"patch":"@@ -141,7 +141,0 @@\n-\n-\/\/ For a ParmNode, all immediate inputs and outputs are considered relevant\n-\/\/ both in compact and standard representation.\n-void ParmNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n@@ -1376,13 +1369,0 @@\n-\n-\/\/ The related nodes of a SafepointNode are all data inputs, excluding the\n-\/\/ control boundary, as well as all outputs till level 2 (to include projection\n-\/\/ nodes and targets). In compact mode, just include inputs till level 1 and\n-\/\/ outputs as before.\n-void SafePointNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 1, false, false);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n@@ -1958,10 +1938,0 @@\n-\n-\/\/ The related set of lock nodes includes the control boundary.\n-void AbstractLockNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-      this->collect_nodes(in_rel, 1, false, false);\n-    } else {\n-      this->collect_nodes_in_all_data(in_rel, true);\n-    }\n-    this->collect_nodes(out_rel, -2, false, false);\n-}\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -503,1 +502,0 @@\n-  virtual void           related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -1083,1 +1081,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2584,8 +2584,0 @@\n-void PhiNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  \/\/ For a PhiNode, the set of related nodes includes all inputs till level 2,\n-  \/\/ and all outputs till level 1. In compact mode, inputs till level 1 are\n-  \/\/ collected.\n-  this->collect_nodes(in_rel, compact ? 1 : 2, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-\n@@ -2616,11 +2608,0 @@\n-#ifndef PRODUCT\n-\/\/-----------------------------related-----------------------------------------\n-\/\/ The related nodes of a GotoNode are all inputs at level 1, as well as the\n-\/\/ outputs at level 1. This is regardless of compact mode.\n-void GotoNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-#endif\n-\n-\n@@ -2632,11 +2613,0 @@\n-#ifndef PRODUCT\n-\/\/-----------------------------related-----------------------------------------\n-\/\/ The related nodes of a JumpNode are all inputs at level 1, as well as the\n-\/\/ outputs at level 2 (to include actual jump targets beyond projection nodes).\n-\/\/ This is regardless of compact mode.\n-void JumpNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n-#endif\n-\n@@ -2703,6 +2673,0 @@\n-\n-void JumpProjNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  \/\/ The related nodes of a JumpProjNode are its inputs and outputs at level 1.\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -227,1 +227,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -253,4 +252,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -409,1 +404,0 @@\n-  virtual void related(GrowableArray <Node *> *in_rel, GrowableArray <Node *> *out_rel, bool compact) const;\n@@ -435,5 +429,0 @@\n-\n-#ifndef PRODUCT\n-public:\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -507,3 +496,0 @@\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -535,1 +521,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1743,15 +1743,0 @@\n-\/\/-------------------------------related---------------------------------------\n-\/\/ An IfProjNode's related node set consists of its input (an IfNode) including\n-\/\/ the IfNode's condition, plus all of its outputs at level 1. In compact mode,\n-\/\/ the restrictions for IfNode apply (see IfNode::rel).\n-void IfProjNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  Node* ifNode = this->in(0);\n-  in_rel->append(ifNode);\n-  if (compact) {\n-    ifNode->collect_nodes(in_rel, 3, false, true);\n-  } else {\n-    ifNode->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-\n@@ -1762,15 +1747,0 @@\n-\n-\/\/-------------------------------related---------------------------------------\n-\/\/ For an IfNode, the set of related output nodes is just the output nodes till\n-\/\/ depth 2, i.e, the IfTrue\/IfFalse projection nodes plus the nodes they refer.\n-\/\/ The related input nodes contain no control nodes, but all data nodes\n-\/\/ pertaining to the condition. In compact mode, the input nodes are collected\n-\/\/ up to a depth of 3.\n-void IfNode::related(GrowableArray <Node *> *in_rel, GrowableArray <Node *> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 3, false, true);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-        block->get_node(i)->fast_dump();\n+        block->get_node(i)->dump();\n@@ -1214,1 +1214,1 @@\n-      block->get_node(i)->fast_dump();\n+      block->get_node(i)->dump();\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -527,1 +527,1 @@\n-  Node* find_old_node(Node* new_node) {\n+  Node* find_old_node(const Node* new_node) {\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,15 +465,0 @@\n-\n-#ifndef PRODUCT\n-\/\/----------------------------BinaryNode---------------------------------------\n-\/\/ The set of related nodes for a BinaryNode is all data inputs and all outputs\n-\/\/ till level 2 (i.e., one beyond the associated CMoveNode). In compact mode,\n-\/\/ it's the inputs till level 1 and the outputs till level 2.\n-void BinaryNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 1, false, true);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -163,4 +163,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -335,1 +335,0 @@\n-  , _indent(0)\n@@ -356,1 +355,0 @@\n-  , _indent(0)\n@@ -370,1 +368,0 @@\n-  , _indent(0)\n@@ -386,1 +383,0 @@\n-  , _indent(0)\n@@ -404,1 +400,0 @@\n-  , _indent(0)\n@@ -424,1 +419,0 @@\n-  , _indent(0)\n@@ -447,1 +441,0 @@\n-  , _indent(0)\n@@ -472,1 +465,0 @@\n-  , _indent(0)\n@@ -1651,1 +1643,1 @@\n-int node_idx_cmp(Node** n1, Node** n2) {\n+int node_idx_cmp(const Node** n1, const Node** n2) {\n@@ -1655,1 +1647,1 @@\n-Node* find_node_by_name(Node* start, const char* name) {\n+void find_node_by_name(Node* start, const char* name) {\n@@ -1657,3 +1649,2 @@\n-  Node* result = nullptr;\n-  GrowableArray<Node*> ns;\n-  auto callback = [&] (Node* n) {\n+  GrowableArray<const Node*> ns;\n+  auto callback = [&] (const Node* n) {\n@@ -1662,1 +1653,0 @@\n-      result = n;\n@@ -1670,1 +1660,0 @@\n-  return result;\n@@ -1673,1 +1662,1 @@\n-Node* find_node_by_dump(Node* start, const char* pattern) {\n+void find_node_by_dump(Node* start, const char* pattern) {\n@@ -1675,3 +1664,2 @@\n-  Node* result = nullptr;\n-  GrowableArray<Node*> ns;\n-  auto callback = [&] (Node* n) {\n+  GrowableArray<const Node*> ns;\n+  auto callback = [&] (const Node* n) {\n@@ -1682,1 +1670,0 @@\n-      result = n;\n@@ -1690,1 +1677,0 @@\n-  return result;\n@@ -1696,1 +1682,1 @@\n-Node* find_node_by_name(const char* name) {\n+void find_node_by_name(const char* name) {\n@@ -1698,1 +1684,1 @@\n-  return find_node_by_name(root, name);\n+  find_node_by_name(root, name);\n@@ -1704,1 +1690,1 @@\n-Node* find_old_node_by_name(const char* name) {\n+void find_old_node_by_name(const char* name) {\n@@ -1706,1 +1692,1 @@\n-  return find_node_by_name(root, name);\n+  find_node_by_name(root, name);\n@@ -1712,1 +1698,1 @@\n-Node* find_node_by_dump(const char* pattern) {\n+void find_node_by_dump(const char* pattern) {\n@@ -1714,1 +1700,1 @@\n-  return find_node_by_dump(root, pattern);\n+  find_node_by_dump(root, pattern);\n@@ -1720,1 +1706,1 @@\n-Node* find_old_node_by_dump(const char* pattern) {\n+void find_old_node_by_dump(const char* pattern) {\n@@ -1722,1 +1708,1 @@\n-  return find_node_by_dump(root, pattern);\n+  find_node_by_dump(root, pattern);\n@@ -1775,1 +1761,1 @@\n-  PrintBFS(Node* start, const int max_distance, Node* target, const char* options)\n+  PrintBFS(const Node* start, const int max_distance, const Node* target, const char* options)\n@@ -1792,1 +1778,1 @@\n-  Node* _start;\n+  const Node* _start;\n@@ -1794,1 +1780,1 @@\n-  Node* _target;\n+  const Node* _target;\n@@ -1824,0 +1810,1 @@\n+  bool _dump_only = false;\n@@ -1828,1 +1815,1 @@\n-  static bool filter_category(Node* n, Filter& filter); \/\/ filter node category against options\n+  static bool filter_category(const Node* n, Filter& filter); \/\/ filter node category against options\n@@ -1842,4 +1829,4 @@\n-  static Node* old_node(Node* n); \/\/ mach node -> prior IR node\n-  static void print_node_idx(Node* n); \/\/ to tty\n-  static void print_block_id(Block* b); \/\/ to tty\n-  static void print_node_block(Node* n); \/\/ to tty: _pre_order, head idx, _idom, _dom_depth\n+  static Node* old_node(const Node* n); \/\/ mach node -> prior IR node\n+  static void print_node_idx(const Node* n); \/\/ to tty\n+  static void print_block_id(const Block* b); \/\/ to tty\n+  static void print_node_block(const Node* n); \/\/ to tty: _pre_order, head idx, _idom, _dom_depth\n@@ -1848,2 +1835,2 @@\n-  Node_List _worklist; \/\/ BFS queue\n-  void maybe_traverse(Node* src, Node* dst);\n+  GrowableArray<const Node*> _worklist; \/\/ BFS queue\n+  void maybe_traverse(const Node* src, const Node* dst);\n@@ -1855,1 +1842,1 @@\n-    Info(Node* node, int distance)\n+    Info(const Node* node, int distance)\n@@ -1857,1 +1844,1 @@\n-    Node* node() { return _node; };\n+    const Node* node() const { return _node; };\n@@ -1861,1 +1848,1 @@\n-    Node_List edge_bwd; \/\/ pointing toward _start\n+    GrowableArray<const Node*> edge_bwd; \/\/ pointing toward _start\n@@ -1865,1 +1852,1 @@\n-    Node* _node;\n+    const Node* _node;\n@@ -1881,1 +1868,1 @@\n-  void make_info(Node* node, const int distance) {\n+  void make_info(const Node* node, const int distance) {\n@@ -1884,1 +1871,1 @@\n-    _info_uid.Insert(node, (void*)uid);\n+    _info_uid.Insert((void*)node, (void*)uid);\n@@ -1890,1 +1877,1 @@\n-  GrowableArray<Node*> _print_list;\n+  GrowableArray<const Node*> _print_list;\n@@ -1894,1 +1881,1 @@\n-  void print_node(Node* n);\n+  void print_node(const Node* n);\n@@ -1919,3 +1906,3 @@\n-  uint pos = 0;\n-  while (pos < _worklist.size()) {\n-    Node* n = _worklist.at(pos++); \/\/ next node to traverse\n+  int pos = 0;\n+  while (pos < _worklist.length()) {\n+    const Node* n = _worklist.at(pos++); \/\/ next node to traverse\n@@ -1961,2 +1948,2 @@\n-  for (uint i = 0; i < _worklist.size(); i++) {\n-    Node* n = _worklist.at(i);\n+  for (int i = 0; i < _worklist.length(); i++) {\n+    const Node* n = _worklist.at(i);\n@@ -1970,2 +1957,2 @@\n-  uint pos = 0;\n-  Node_List backtrace;\n+  int pos = 0;\n+  GrowableArray<const Node*> backtrace;\n@@ -1976,2 +1963,2 @@\n-  while (pos < backtrace.size()) {\n-    Node* n = backtrace.at(pos++);\n+  while (pos < backtrace.length()) {\n+    const Node* n = backtrace.at(pos++);\n@@ -1979,1 +1966,1 @@\n-    for (uint i = 0; i < info->edge_bwd.size(); i++) {\n+    for (int i = 0; i < info->edge_bwd.length(); i++) {\n@@ -1981,1 +1968,1 @@\n-      Node* back = info->edge_bwd.at(i);\n+      const Node* back = info->edge_bwd.at(i);\n@@ -1997,1 +1984,1 @@\n-  Node* current = _target;\n+  const Node* current = _target;\n@@ -2013,2 +2000,2 @@\n-    for (int i = _worklist.size() - 1; i >= 0; i--) {\n-      Node* n = _worklist.at(i);\n+    for (int i = _worklist.length() - 1; i >= 0; i--) {\n+      const Node* n = _worklist.at(i);\n@@ -2022,2 +2009,2 @@\n-    for (uint i = 0; i < _worklist.size(); i++) {\n-      Node* n = _worklist.at(i);\n+    for (int i = 0; i < _worklist.length(); i++) {\n+      const Node* n = _worklist.at(i);\n@@ -2040,1 +2027,1 @@\n-      Node* n = _print_list.at(i);\n+      const Node* n = _print_list.at(i);\n@@ -2084,0 +2071,1 @@\n+  tty->print(\"      $: dump only, no header, no other columns\\n\");\n@@ -2087,0 +2075,3 @@\n+  tty->print(\"Note: the categories can be overlapping. For example a mixed node\\n\");\n+  tty->print(\"      can contain control and memory output. Some from the other\\n\");\n+  tty->print(\"      category are also control (Halt, Return, etc).\\n\");\n@@ -2191,0 +2182,3 @@\n+      case '$':\n+        _dump_only = true;\n+        break;\n@@ -2215,1 +2209,1 @@\n-bool PrintBFS::filter_category(Node* n, Filter& filter) {\n+bool PrintBFS::filter_category(const Node* n, Filter& filter) {\n@@ -2217,17 +2211,14 @@\n-  switch (t->category()) {\n-    case Type::Category::Data:\n-      return filter._data;\n-    case Type::Category::Memory:\n-      return filter._memory;\n-    case Type::Category::Mixed:\n-      return filter._mixed;\n-    case Type::Category::Control:\n-      return filter._control;\n-    case Type::Category::Other:\n-      return filter._other;\n-    case Type::Category::Undef:\n-      n->dump();\n-      assert(false, \"category undef ??\");\n-    default:\n-      n->dump();\n-      assert(false, \"not covered\");\n+  if (filter._data && t->has_category(Type::Category::Data)) {\n+    return true;\n+  }\n+  if (filter._memory && t->has_category(Type::Category::Memory)) {\n+    return true;\n+  }\n+  if (filter._mixed && t->has_category(Type::Category::Mixed)) {\n+    return true;\n+  }\n+  if (filter._control && (t->has_category(Type::Category::Control) || n->is_CFG())) {\n+    return true;\n+  }\n+  if (filter._other && t->has_category(Type::Category::Other)) {\n+    return true;\n@@ -2282,1 +2273,1 @@\n-Node* PrintBFS::old_node(Node* n) {\n+Node* PrintBFS::old_node(const Node* n) {\n@@ -2291,1 +2282,1 @@\n-void PrintBFS::print_node_idx(Node* n) {\n+void PrintBFS::print_node_idx(const Node* n) {\n@@ -2304,1 +2295,1 @@\n-void PrintBFS::print_block_id(Block* b) {\n+void PrintBFS::print_block_id(const Block* b) {\n@@ -2311,1 +2302,1 @@\n-void PrintBFS::print_node_block(Node* n) {\n+void PrintBFS::print_node_block(const Node* n) {\n@@ -2334,1 +2325,1 @@\n-void PrintBFS::maybe_traverse(Node* src, Node* dst) {\n+void PrintBFS::maybe_traverse(const Node* src, const Node* dst) {\n@@ -2356,0 +2347,3 @@\n+  if (_dump_only) {\n+    return; \/\/ no header in dump only mode\n+  }\n@@ -2370,1 +2364,5 @@\n-void PrintBFS::print_node(Node* n) {\n+void PrintBFS::print_node(const Node* n) {\n+  if (_dump_only) {\n+    n->dump(\"\\n\", false, tty, &_dcc);\n+    return;\n+  }\n@@ -2393,1 +2391,1 @@\n-void Node::dump_bfs(const int max_distance, Node* target, const char* options) {\n+void Node::dump_bfs(const int max_distance, Node* target, const char* options) const {\n@@ -2399,1 +2397,1 @@\n-void Node::dump_bfs(const int max_distance) {\n+void Node::dump_bfs(const int max_distance) const {\n@@ -2526,4 +2524,0 @@\n-  if (_indent > 0) {\n-    st->print(\"%*s\", (_indent << 1), \"  \");\n-  }\n-\n@@ -2606,0 +2600,5 @@\n+\/\/ call from debugger: dump node to tty with newline\n+void Node::dump() const {\n+  dump(\"\\n\");\n+}\n+\n@@ -2657,67 +2656,0 @@\n-\/\/----------------------------collect_nodes_i----------------------------------\n-\/\/ Collects nodes from an Ideal graph, starting from a given start node and\n-\/\/ moving in a given direction until a certain depth (distance from the start\n-\/\/ node) is reached. Duplicates are ignored.\n-\/\/ Arguments:\n-\/\/   queue:         the nodes are collected into this array.\n-\/\/   start:         the node at which to start collecting.\n-\/\/   direction:     if this is a positive number, collect input nodes; if it is\n-\/\/                  a negative number, collect output nodes.\n-\/\/   depth:         collect nodes up to this distance from the start node.\n-\/\/   include_start: whether to include the start node in the result collection.\n-\/\/   only_ctrl:     whether to regard control edges only during traversal.\n-\/\/   only_data:     whether to regard data edges only during traversal.\n-static void collect_nodes_i(GrowableArray<Node*>* queue, const Node* start, int direction, uint depth, bool include_start, bool only_ctrl, bool only_data) {\n-  bool indent = depth <= PrintIdealIndentThreshold;\n-  Node* s = (Node*) start; \/\/ remove const\n-  queue->append(s);\n-  int begin = 0;\n-  int end = 0;\n-\n-  s->set_indent(0);\n-  for(uint i = 0; i < depth; i++) {\n-    end = queue->length();\n-    for(int j = begin; j < end; j++) {\n-      Node* tp  = queue->at(j);\n-      uint limit = direction > 0 ? tp->len() : tp->outcnt();\n-      for(uint k = 0; k < limit; k++) {\n-        Node* n = direction > 0 ? tp->in(k) : tp->raw_out(k);\n-\n-        if (not_a_node(n))  continue;\n-        \/\/ do not recurse through top or the root (would reach unrelated stuff)\n-        if (n->is_Root() || n->is_top()) continue;\n-        if (only_ctrl && !n->is_CFG()) continue;\n-        if (only_data && n->is_CFG()) continue;\n-        bool in_queue = queue->contains(n);\n-        if (!in_queue) {\n-          queue->append(n);\n-          n->set_indent(indent ? (i + 1) : 0);\n-        }\n-      }\n-    }\n-    begin = end;\n-  }\n-  if (!include_start) {\n-    queue->remove(s);\n-  }\n-}\n-\n-\/\/------------------------------dump_nodes-------------------------------------\n-static void dump_nodes(const Node* start, int d, bool only_ctrl) {\n-  if (not_a_node(start)) return;\n-\n-  GrowableArray <Node *> queue(Compile::current()->live_nodes());\n-  collect_nodes_i(&queue, start, d, (uint) ABS(d), true, only_ctrl, false);\n-\n-  int end = queue.length();\n-  if (d > 0) {\n-    for(int j = end-1; j >= 0; j--) {\n-      queue.at(j)->dump();\n-    }\n-  } else {\n-    for(int j = 0; j < end; j++) {\n-      queue.at(j)->dump();\n-    }\n-  }\n-}\n-\n@@ -2725,0 +2657,1 @@\n+\/\/ call from debugger: dump Node's inputs (or outputs if d negative)\n@@ -2726,1 +2659,1 @@\n-  dump_nodes(this, d, false);\n+  dump_bfs(abs(d), nullptr, (d > 0) ? \"+$\" : \"-$\");\n@@ -2730,1 +2663,1 @@\n-\/\/ Dump a Node's control history to depth\n+\/\/ call from debugger: dump Node's control inputs (or outputs if d negative)\n@@ -2732,1 +2665,1 @@\n-  dump_nodes(this, d, true);\n+  dump_bfs(abs(d), nullptr, (d > 0) ? \"+$c\" : \"-$c\");\n@@ -2755,195 +2688,0 @@\n-\/\/----------------------------dump_related-------------------------------------\n-\/\/ Dump a Node's related nodes - the notion of \"related\" depends on the Node at\n-\/\/ hand and is determined by the implementation of the virtual method rel.\n-void Node::dump_related() const {\n-  Compile* C = Compile::current();\n-  GrowableArray <Node *> in_rel(C->unique());\n-  GrowableArray <Node *> out_rel(C->unique());\n-  this->related(&in_rel, &out_rel, false);\n-  for (int i = in_rel.length() - 1; i >= 0; i--) {\n-    in_rel.at(i)->dump();\n-  }\n-  this->dump(\"\\n\", true);\n-  for (int i = 0; i < out_rel.length(); i++) {\n-    out_rel.at(i)->dump();\n-  }\n-}\n-\n-\/\/----------------------------dump_related-------------------------------------\n-\/\/ Dump a Node's related nodes up to a given depth (distance from the start\n-\/\/ node).\n-\/\/ Arguments:\n-\/\/   d_in:  depth for input nodes.\n-\/\/   d_out: depth for output nodes (note: this also is a positive number).\n-void Node::dump_related(uint d_in, uint d_out) const {\n-  Compile* C = Compile::current();\n-  GrowableArray <Node *> in_rel(C->unique());\n-  GrowableArray <Node *> out_rel(C->unique());\n-\n-  \/\/ call collect_nodes_i directly\n-  collect_nodes_i(&in_rel, this, 1, d_in, false, false, false);\n-  collect_nodes_i(&out_rel, this, -1, d_out, false, false, false);\n-\n-  for (int i = in_rel.length() - 1; i >= 0; i--) {\n-    in_rel.at(i)->dump();\n-  }\n-  this->dump(\"\\n\", true);\n-  for (int i = 0; i < out_rel.length(); i++) {\n-    out_rel.at(i)->dump();\n-  }\n-}\n-\n-\/\/------------------------dump_related_compact---------------------------------\n-\/\/ Dump a Node's related nodes in compact representation. The notion of\n-\/\/ \"related\" depends on the Node at hand and is determined by the implementation\n-\/\/ of the virtual method rel.\n-void Node::dump_related_compact() const {\n-  Compile* C = Compile::current();\n-  GrowableArray <Node *> in_rel(C->unique());\n-  GrowableArray <Node *> out_rel(C->unique());\n-  this->related(&in_rel, &out_rel, true);\n-  int n_in = in_rel.length();\n-  int n_out = out_rel.length();\n-\n-  this->dump_comp(n_in == 0 ? \"\\n\" : \"  \");\n-  for (int i = 0; i < n_in; i++) {\n-    in_rel.at(i)->dump_comp(i == n_in - 1 ? \"\\n\" : \"  \");\n-  }\n-  for (int i = 0; i < n_out; i++) {\n-    out_rel.at(i)->dump_comp(i == n_out - 1 ? \"\\n\" : \"  \");\n-  }\n-}\n-\n-\/\/------------------------------related----------------------------------------\n-\/\/ Collect a Node's related nodes. The default behaviour just collects the\n-\/\/ inputs and outputs at depth 1, including both control and data flow edges,\n-\/\/ regardless of whether the presentation is compact or not. For data nodes,\n-\/\/ the default is to collect all data inputs (till level 1 if compact), and\n-\/\/ outputs till level 1.\n-void Node::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (this->is_CFG()) {\n-    collect_nodes_i(in_rel, this, 1, 1, false, false, false);\n-    collect_nodes_i(out_rel, this, -1, 1, false, false, false);\n-  } else {\n-    if (compact) {\n-      this->collect_nodes(in_rel, 1, false, true);\n-    } else {\n-      this->collect_nodes_in_all_data(in_rel, false);\n-    }\n-    this->collect_nodes(out_rel, -1, false, false);\n-  }\n-}\n-\n-\/\/---------------------------collect_nodes-------------------------------------\n-\/\/ An entry point to the low-level node collection facility, to start from a\n-\/\/ given node in the graph. The start node is by default not included in the\n-\/\/ result.\n-\/\/ Arguments:\n-\/\/   ns:   collect the nodes into this data structure.\n-\/\/   d:    the depth (distance from start node) to which nodes should be\n-\/\/         collected. A value >0 indicates input nodes, a value <0, output\n-\/\/         nodes.\n-\/\/   ctrl: include only control nodes.\n-\/\/   data: include only data nodes.\n-void Node::collect_nodes(GrowableArray<Node*> *ns, int d, bool ctrl, bool data) const {\n-  if (ctrl && data) {\n-    \/\/ ignore nonsensical combination\n-    return;\n-  }\n-  collect_nodes_i(ns, this, d, (uint) ABS(d), false, ctrl, data);\n-}\n-\n-\/\/--------------------------collect_nodes_in-----------------------------------\n-static void collect_nodes_in(Node* start, GrowableArray<Node*> *ns, bool primary_is_data, bool collect_secondary) {\n-  \/\/ The maximum depth is determined using a BFS that visits all primary (data\n-  \/\/ or control) inputs and increments the depth at each level.\n-  uint d_in = 0;\n-  GrowableArray<Node*> nodes(Compile::current()->unique());\n-  nodes.push(start);\n-  int nodes_at_current_level = 1;\n-  int n_idx = 0;\n-  while (nodes_at_current_level > 0) {\n-    \/\/ Add all primary inputs reachable from the current level to the list, and\n-    \/\/ increase the depth if there were any.\n-    int nodes_at_next_level = 0;\n-    bool nodes_added = false;\n-    while (nodes_at_current_level > 0) {\n-      nodes_at_current_level--;\n-      Node* current = nodes.at(n_idx++);\n-      for (uint i = 0; i < current->len(); i++) {\n-        Node* n = current->in(i);\n-        if (not_a_node(n)) {\n-          continue;\n-        }\n-        if ((primary_is_data && n->is_CFG()) || (!primary_is_data && !n->is_CFG())) {\n-          continue;\n-        }\n-        if (!nodes.contains(n)) {\n-          nodes.push(n);\n-          nodes_added = true;\n-          nodes_at_next_level++;\n-        }\n-      }\n-    }\n-    if (nodes_added) {\n-      d_in++;\n-    }\n-    nodes_at_current_level = nodes_at_next_level;\n-  }\n-  start->collect_nodes(ns, d_in, !primary_is_data, primary_is_data);\n-  if (collect_secondary) {\n-    \/\/ Now, iterate over the secondary nodes in ns and add the respective\n-    \/\/ boundary reachable from them.\n-    GrowableArray<Node*> sns(Compile::current()->unique());\n-    for (GrowableArrayIterator<Node*> it = ns->begin(); it != ns->end(); ++it) {\n-      Node* n = *it;\n-      n->collect_nodes(&sns, 1, primary_is_data, !primary_is_data);\n-      for (GrowableArrayIterator<Node*> d = sns.begin(); d != sns.end(); ++d) {\n-        ns->append_if_missing(*d);\n-      }\n-      sns.clear();\n-    }\n-  }\n-}\n-\n-\/\/---------------------collect_nodes_in_all_data-------------------------------\n-\/\/ Collect the entire data input graph. Include the control boundary if\n-\/\/ requested.\n-\/\/ Arguments:\n-\/\/   ns:   collect the nodes into this data structure.\n-\/\/   ctrl: if true, include the control boundary.\n-void Node::collect_nodes_in_all_data(GrowableArray<Node*> *ns, bool ctrl) const {\n-  collect_nodes_in((Node*) this, ns, true, ctrl);\n-}\n-\n-\/\/--------------------------collect_nodes_in_all_ctrl--------------------------\n-\/\/ Collect the entire control input graph. Include the data boundary if\n-\/\/ requested.\n-\/\/   ns:   collect the nodes into this data structure.\n-\/\/   data: if true, include the control boundary.\n-void Node::collect_nodes_in_all_ctrl(GrowableArray<Node*> *ns, bool data) const {\n-  collect_nodes_in((Node*) this, ns, false, data);\n-}\n-\n-\/\/------------------collect_nodes_out_all_ctrl_boundary------------------------\n-\/\/ Collect the entire output graph until hitting control node boundaries, and\n-\/\/ include those.\n-void Node::collect_nodes_out_all_ctrl_boundary(GrowableArray<Node*> *ns) const {\n-  \/\/ Perform a BFS and stop at control nodes.\n-  GrowableArray<Node*> nodes(Compile::current()->unique());\n-  nodes.push((Node*) this);\n-  while (nodes.length() > 0) {\n-    Node* current = nodes.pop();\n-    if (not_a_node(current)) {\n-      continue;\n-    }\n-    ns->append_if_missing(current);\n-    if (!current->is_CFG()) {\n-      for (DUIterator i = current->outs(); current->has_out(i); i++) {\n-        nodes.push(current->out(i));\n-      }\n-    }\n-  }\n-  ns->remove((Node*) this);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":97,"deletions":359,"binary":false,"changes":456,"status":"modified"},{"patch":"@@ -1190,3 +1190,0 @@\n- private:\n-  int _indent;\n-\n@@ -1194,5 +1191,0 @@\n-  void set_indent(int indent) { _indent = indent; }\n-\n- private:\n-  static bool add_to_worklist(Node* n, Node_List* worklist, Arena* old_arena, VectorSet* old_space, VectorSet* new_space);\n-public:\n@@ -1201,2 +1193,2 @@\n-  void dump_bfs(const int max_distance, Node* target, const char* options); \/\/ Print BFS traversal\n-  void dump_bfs(const int max_distance); \/\/ dump_bfs(max_distance, nullptr, nullptr)\n+  void dump_bfs(const int max_distance, Node* target, const char* options) const; \/\/ Print BFS traversal\n+  void dump_bfs(const int max_distance) const; \/\/ dump_bfs(max_distance, nullptr, nullptr)\n@@ -1204,1 +1196,1 @@\n-  public:\n+   public:\n@@ -1211,1 +1203,1 @@\n-  void dump() const { dump(\"\\n\"); }  \/\/ Print this node.\n+  void dump() const; \/\/ print node with newline\n@@ -1218,0 +1210,1 @@\n+ private:\n@@ -1221,0 +1214,1 @@\n+ public:\n@@ -1224,16 +1218,0 @@\n-  void dump_related() const;             \/\/ Print related nodes (depends on node at hand).\n-  \/\/ Print related nodes up to given depths for input and output nodes.\n-  void dump_related(uint d_in, uint d_out) const;\n-  void dump_related_compact() const;     \/\/ Print related nodes in compact representation.\n-  \/\/ Collect related nodes.\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-  \/\/ Collect nodes starting from this node, explicitly including\/excluding control and data links.\n-  void collect_nodes(GrowableArray<Node*> *ns, int d, bool ctrl, bool data) const;\n-\n-  \/\/ Node collectors, to be used in implementations of Node::rel().\n-  \/\/ Collect the entire data input graph. Include control inputs if requested.\n-  void collect_nodes_in_all_data(GrowableArray<Node*> *ns, bool ctrl) const;\n-  \/\/ Collect the entire control input graph. Include data inputs if requested.\n-  void collect_nodes_in_all_ctrl(GrowableArray<Node*> *ns, bool data) const;\n-  \/\/ Collect the entire output graph until hitting and including control nodes.\n-  void collect_nodes_out_all_ctrl_boundary(GrowableArray<Node*> *ns) const;\n@@ -1248,13 +1226,1 @@\n-  \/\/ RegMask Print Functions\n-  void dump_in_regmask(int idx) { in_RegMask(idx).dump(); }\n-  void dump_out_regmask() { out_RegMask().dump(); }\n-  static bool in_dump() { return Compile::current()->_in_dump_cnt > 0; }\n-  void fast_dump() const {\n-    tty->print(\"%4d: %-17s\", _idx, Name());\n-    for (uint i = 0; i < len(); i++)\n-      if (in(i))\n-        tty->print(\" %4d\", in(i)->_idx);\n-      else\n-        tty->print(\" NULL\");\n-    tty->print(\"\\n\");\n-  }\n+  static bool in_dump() { return Compile::current()->_in_dump_cnt > 0; } \/\/ check if we are in a dump call\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":7,"deletions":41,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -94,15 +94,0 @@\n-\n-#ifndef PRODUCT\n-\/\/-----------------------------related-----------------------------------------\n-\/\/ Include all control inputs in the related set, and also the input data\n-\/\/ boundary. In compact mode, include all inputs till level 2. Also include\n-\/\/ all outputs at level 1.\n-void HaltNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 2, false, false);\n-  } else {\n-    this->collect_nodes_in_all_ctrl(in_rel, true);\n-  }\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/opto\/rootnode.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,4 +71,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n","filename":"src\/hotspot\/share\/opto\/rootnode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -631,32 +631,0 @@\n-#ifndef PRODUCT\n-\/\/----------------------------related------------------------------------------\n-\/\/ Related nodes of comparison nodes include all data inputs (until hitting a\n-\/\/ control boundary) as well as all outputs until and including control nodes\n-\/\/ as well as their projections. In compact mode, data inputs till depth 1 and\n-\/\/ all outputs till depth 1 are considered.\n-void CmpNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 1, false, true);\n-    this->collect_nodes(out_rel, -1, false, false);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-    this->collect_nodes_out_all_ctrl_boundary(out_rel);\n-    \/\/ Now, find all control nodes in out_rel, and include their projections\n-    \/\/ and projection targets (if any) in the result.\n-    GrowableArray<Node*> proj(Compile::current()->unique());\n-    for (GrowableArrayIterator<Node*> it = out_rel->begin(); it != out_rel->end(); ++it) {\n-      Node* n = *it;\n-      if (n->is_CFG() && !n->is_Proj()) {\n-        \/\/ Assume projections and projection targets are found at levels 1 and 2.\n-        n->collect_nodes(&proj, -2, false, false);\n-        for (GrowableArrayIterator<Node*> p = proj.begin(); p != proj.end(); ++p) {\n-          out_rel->append_if_missing(*p);\n-        }\n-        proj.clear();\n-      }\n-    }\n-  }\n-}\n-\n-#endif\n-\n@@ -1796,14 +1764,0 @@\n-\n-\/\/-------------------------------related---------------------------------------\n-\/\/ A BoolNode's related nodes are all of its data inputs, and all of its\n-\/\/ outputs until control nodes are hit, which are included. In compact\n-\/\/ representation, inputs till level 3 and immediate outputs are included.\n-void BoolNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 3, false, true);\n-    this->collect_nodes(out_rel, -1, false, false);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-    this->collect_nodes_out_all_ctrl_boundary(out_rel);\n-  }\n-}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -146,7 +146,0 @@\n-\n-#ifndef PRODUCT\n-  \/\/ CmpNode and subclasses include all data inputs (until hitting a control\n-  \/\/ boundary) in their related node set, as well as all outputs until and\n-  \/\/ including eventual control nodes and their projections.\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -364,1 +357,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1153,0 +1153,15 @@\n+\n+bool Type::has_category(Type::Category cat) const {\n+  if (category() == cat) {\n+    return true;\n+  }\n+  if (category() == Category::Mixed) {\n+    const TypeTuple* tuple = is_tuple();\n+    for (uint i = 0; i < tuple->cnt(); i++) {\n+      if (tuple->field_at(i)->has_category(cat)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -389,0 +389,2 @@\n+  \/\/ Check recursively in tuples.\n+  bool has_category(Category cat) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}