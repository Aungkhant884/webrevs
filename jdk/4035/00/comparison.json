{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,1 +291,1 @@\n-  bool cmpi_folds(PhaseIterGVN* igvn, bool fold_ne = false);\n+  bool cmp_folds(PhaseIterGVN* igvn);\n@@ -302,1 +302,3 @@\n-  bool fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);\n+  bool get_base_comparing_value(Node* dom_if, PhaseIterGVN* igvn, jint& this_adj_val, jint& dom_adj_val);\n+  bool fold_dominated_if(ProjNode* proj, PhaseIterGVN* igvn);\n+  bool fold_to_unsigned(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-        const CmpNode* cmp  = bol->in(1)->as_Cmp();\n+        const CmpNode* cmp = bol->in(1)->as_Cmp();\n@@ -615,0 +615,2 @@\n+            const TypeInt* val_t = gvn->type(val)->isa_int();\n+            bool is_unsigned = (cmp->Opcode() == Op_CmpU);\n@@ -618,0 +620,1 @@\n+              assert(!is_unsigned, \"unsigned comparison is not supported\");\n@@ -619,1 +622,0 @@\n-              const TypeInt* val_t = gvn->type(val)->isa_int();\n@@ -631,0 +633,1 @@\n+              assert(!is_unsigned, \"unsigned comparison is not supported\");\n@@ -633,1 +636,0 @@\n-              lo = TypeInt::INT->_lo;\n@@ -637,0 +639,18 @@\n+              if (!is_unsigned) {\n+                lo = TypeInt::INT->_lo;\n+              } else {\n+                if (hi < 0) {\n+                  hi = TypeInt::INT->_hi - hi;\n+                }\n+                if (lo >= 0) {\n+                  lo = 0;\n+                } else {\n+                  jint tmp = TypeInt::INT->_hi - lo;\n+                  if (hi < tmp) {\n+                    lo = hi;\n+                    hi = tmp;\n+                  } else {\n+                    lo = tmp;\n+                  }\n+                }\n+              }\n@@ -639,1 +659,18 @@\n-              lo = TypeInt::INT->_lo;\n+              if (!is_unsigned) {\n+                lo = TypeInt::INT->_lo;\n+              } else {\n+                if (hi < 0) {\n+                  hi = TypeInt::INT->_hi - hi;\n+                }\n+                if (lo >= 0) {\n+                  lo = 0;\n+                } else {\n+                  jint tmp = TypeInt::INT->_hi - lo;\n+                  if (hi < tmp) {\n+                    lo = hi;\n+                    hi = tmp;\n+                  } else {\n+                    lo = tmp;\n+                  }\n+                }\n+              }\n@@ -642,1 +679,5 @@\n-              if (lo != max_jint) {\n+              if (is_unsigned && (val_t == NULL || val_t->_lo < 0)) {\n+                lo = TypeInt::INT->_lo;\n+              } else if (is_unsigned && lo < 0) {\n+                lo = TypeInt::INT->_hi - lo;\n+              } else if (lo != max_jint) {\n@@ -648,1 +689,5 @@\n-              \/\/ lo unchanged\n+              if (is_unsigned && (val_t == NULL || val_t->_lo < 0)) {\n+                lo = TypeInt::INT->_lo;\n+              } else if (is_unsigned && lo < 0) {\n+                lo = TypeInt::INT->_hi - lo;\n+              }\n@@ -652,0 +697,1 @@\n+              ShouldNotReachHere();\n@@ -654,2 +700,1 @@\n-            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n-            return rtn_t;\n+            return TypeInt::make(lo, hi, cmp2_t->_widen);\n@@ -703,1 +748,1 @@\n-bool IfNode::cmpi_folds(PhaseIterGVN* igvn, bool fold_ne) {\n+bool IfNode::cmp_folds(PhaseIterGVN* igvn) {\n@@ -707,1 +752,2 @@\n-    in(1)->in(1)->Opcode() == Op_CmpI &&\n+    (in(1)->in(1)->Opcode() == Op_CmpI ||\n+     in(1)->in(1)->Opcode() == Op_CmpU) &&\n@@ -712,1 +758,1 @@\n-     (fold_ne && in(1)->as_Bool()->_test._test == BoolTest::ne));\n+     in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -722,2 +768,1 @@\n-    ctrl->in(0)->as_If()->cmpi_folds(igvn, true) &&\n-    \/\/ Must compare same value\n+    ctrl->in(0)->as_If()->cmp_folds(igvn) &&\n@@ -725,1 +770,1 @@\n-    ctrl->in(0)->in(1)->in(1)->in(1) == in(1)->in(1)->in(1);\n+    in(1)->in(1)->in(1) != NULL;\n@@ -840,0 +885,86 @@\n+\/\/ There might be an AddINode (marked with *) with a constant increment\n+\/\/ in-between the CmpNodes and the common value we compare.\n+\/\/ Check for the following cases and return true if a common value is\n+\/\/ compared. Also save the constant value that is added to infer\n+\/\/ the type of the common value we compare.\n+\/\/\n+\/\/   Variant 1         Variant 2         Variant 3           Variant 4\n+\/\/\n+\/\/    res_val           res_val             res_val          res_val\n+\/\/    \/   \\             \/    \\              \/    \\           \/     \\\n+\/\/ dom_cmp \\           \/   this_val*   dom_val*   \\     dom_val*  this_val*\n+\/\/        this_cmp    \/       \\            \/       \\        |        \\\n+\/\/                  dom_cmp    \\        dom_cmp     \\     dom_cmp     \\\n+\/\/                          this_cmp            this_cmp           this_cmp\n+bool IfNode::get_base_comparing_value (Node* dom_if, PhaseIterGVN* igvn, jint& this_adj_val, jint& dom_adj_val) {\n+  assert(dom_if->in(1)->in(1)->is_Cmp() && in(1)->in(1)->is_Cmp(), \"compare expected\");\n+  Node* dom_val = dom_if->in(1)->in(1)->in(1);\n+  Node* this_val = in(1)->in(1)->in(1);\n+  assert(dom_val != NULL && this_val != NULL, \"sanity\");\n+  if (this_val == dom_val) {\n+    \/\/ Variant 1\n+    return true;\n+  } else if (this_val->is_Add() && this_val->in(1) == dom_val) {\n+    const TypeInt* val_t = igvn->type(this_val->in(2))->isa_int();\n+    if (val_t != NULL && val_t->is_con()) {\n+      \/\/ Variant 2\n+      this_adj_val = val_t->get_con();\n+      return true;\n+    }\n+  } else if (dom_val->is_Add() && this_val == dom_val->in(1)) {\n+    const TypeInt* val_t = igvn->type(dom_val->in(2))->isa_int();\n+    if (val_t != NULL && val_t->is_con()) {\n+      \/\/ Variant 3\n+      dom_adj_val = val_t->get_con();\n+      return true;\n+    }\n+  } else if (this_val->is_Add() && dom_val->is_Add() && this_val->in(1) != NULL && this_val->in(1) == dom_val->in(1)) {\n+    const TypeInt* domval_t = igvn->type(dom_val->in(2))->isa_int();\n+    const TypeInt* thisval_t = igvn->type(this_val->in(2))->isa_int();\n+    if (thisval_t != NULL && domval_t != NULL && thisval_t->is_con() && domval_t->is_con()) {\n+      \/\/ Variant 4\n+      this_adj_val = thisval_t->get_con();\n+      dom_adj_val = domval_t->get_con();\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Check if dominating if determines the result of this if\n+bool IfNode::fold_dominated_if(ProjNode* proj, PhaseIterGVN* igvn) {\n+  Node* this_val = in(1)->in(1)->in(1);\n+  Node* dom_if = proj->in(0)->as_If();\n+  Node* dom_val = dom_if->in(1)->in(1)->in(1);\n+  jint this_adj_val = 0;\n+  jint dom_adj_val = 0;\n+\n+  \/\/ Must compare same value\n+  if (get_base_comparing_value(dom_if, igvn, this_adj_val, dom_adj_val)) {\n+    const TypeInt* failtype = filtered_int_type(igvn, dom_val, proj);\n+    if (failtype != NULL) {\n+      if (dom_adj_val != 0) {\n+        \/\/ To account for the AddINode, subtract the constant increment from the type\n+        failtype = dom_val->as_Add()->add_ring(failtype, TypeInt::make(-dom_adj_val))->is_int();\n+      }\n+      for (int i = 0; i < 2; ++i) {\n+        const TypeInt* type = filtered_int_type(igvn, this_val, proj_out(i));\n+        if (type != NULL) {\n+          if (this_adj_val != 0) {\n+            \/\/ To account for the AddINode, subtract the constant increment from the type\n+            type = this_val->as_Add()->add_ring(type, TypeInt::make(-this_adj_val))->is_int();\n+          }\n+          type = failtype->join(type)->is_int();\n+          if (type->empty()) {\n+            \/\/ Replace Bool with constant\n+            igvn->_worklist.push(in(1));\n+            igvn->replace_input_of(this, 1, igvn->intcon(proj_out(1-i)->_con));\n+            return true;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -841,1 +972,1 @@\n-bool IfNode::fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {\n+bool IfNode::fold_to_unsigned(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {\n@@ -850,3 +981,1 @@\n-\n-  const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);\n-  const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);\n+  assert(this_cmp->Opcode() == Op_CmpI && dom_iff->in(1)->in(1)->Opcode() == Op_CmpI, \"Unexpected CmpNode\");\n@@ -857,0 +986,6 @@\n+  if (lo_test == BoolTest::ne || hi_test == BoolTest::ne) {\n+    return false;\n+  }\n+\n+  const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);\n+  const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);\n@@ -884,1 +1019,1 @@\n-      hi_type->_hi == max_jint && lo_type->_lo == min_jint && lo_test != BoolTest::ne) {\n+      hi_type->_hi == max_jint && lo_type->_lo == min_jint) {\n@@ -929,1 +1064,1 @@\n-             lo_type->_hi == max_jint && hi_type->_lo == min_jint && lo_test != BoolTest::ne) {\n+             lo_type->_hi == max_jint && hi_type->_lo == min_jint) {\n@@ -987,14 +1122,0 @@\n-    const TypeInt* failtype = filtered_int_type(igvn, n, proj);\n-    if (failtype != NULL) {\n-      const TypeInt* type2 = filtered_int_type(igvn, n, fail);\n-      if (type2 != NULL) {\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->_lo > failtype->_hi) {\n-          \/\/ previous if determines the result of this if so\n-          \/\/ replace Bool with constant\n-          igvn->_worklist.push(in(1));\n-          igvn->replace_input_of(this, 1, igvn->intcon(success->_con));\n-          return true;\n-        }\n-      }\n-    }\n@@ -1264,1 +1385,1 @@\n-  if (cmpi_folds(igvn)) {\n+  if (cmp_folds(igvn)) {\n@@ -1266,9 +1387,6 @@\n-    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {\n-      \/\/ A integer comparison immediately dominated by another integer\n-      \/\/ comparison\n-      ProjNode* success = NULL;\n-      ProjNode* fail = NULL;\n-      ProjNode* dom_cmp = ctrl->as_Proj();\n-      if (has_shared_region(dom_cmp, success, fail) &&\n-          \/\/ Next call modifies graph so must be last\n-          fold_compares_helper(dom_cmp, success, fail, igvn)) {\n+    Node* cmp = in(1)->in(1);\n+    Node* val = cmp->in(1);\n+    \/\/ An integer comparison immediately dominated by another integer comparison\n+    if (is_ctrl_folds(ctrl, igvn)) {\n+      ProjNode* proj = ctrl->as_Proj();\n+      if (fold_dominated_if(proj, igvn)) {\n@@ -1277,4 +1395,15 @@\n-      if (has_only_uncommon_traps(dom_cmp, success, fail, igvn) &&\n-          \/\/ Next call modifies graph so must be last\n-          fold_compares_helper(dom_cmp, success, fail, igvn)) {\n-        return merge_uncommon_traps(dom_cmp, success, fail, igvn);\n+      Node* dom_cmp = ctrl->in(0)->in(1)->in(1);\n+      Node* dom_val = dom_cmp->in(1);\n+      if (cmp->Opcode() == Op_CmpI && dom_cmp->Opcode() == Op_CmpI && val == dom_val && ctrl->outcnt() == 1) {\n+        ProjNode* success = NULL;\n+        ProjNode* fail = NULL;\n+        if (has_shared_region(proj, success, fail) &&\n+            \/\/ Next call modifies graph so must be last\n+            fold_to_unsigned(proj, success, fail, igvn)) {\n+          return this;\n+        }\n+        if (has_only_uncommon_traps(proj, success, fail, igvn) &&\n+            \/\/ Next call modifies graph so must be last\n+            fold_to_unsigned(proj, success, fail, igvn)) {\n+          return merge_uncommon_traps(proj, success, fail, igvn);\n+        }\n@@ -1282,3 +1411,3 @@\n-      return NULL;\n-    } else if (ctrl->in(0) != NULL &&\n-               ctrl->in(0)->in(0) != NULL) {\n+    }\n+    if (ctrl->in(0) != NULL &&\n+        ctrl->in(0)->in(0) != NULL) {\n@@ -1288,2 +1417,2 @@\n-      ProjNode* dom_cmp = dom->isa_Proj();\n-      ProjNode* other_cmp = ctrl->isa_Proj();\n+      ProjNode* dom_proj = dom->isa_Proj();\n+      ProjNode* other_proj = ctrl->isa_Proj();\n@@ -1293,7 +1422,14 @@\n-      if (is_ctrl_folds(dom, igvn) &&\n-          has_only_uncommon_traps(dom_cmp, success, fail, igvn) &&\n-          is_side_effect_free_test(other_cmp, igvn) &&\n-          \/\/ Next call modifies graph so must be last\n-          fold_compares_helper(dom_cmp, success, fail, igvn)) {\n-        reroute_side_effect_free_unc(other_cmp, dom_cmp, igvn);\n-        return merge_uncommon_traps(dom_cmp, success, fail, igvn);\n+      if (is_ctrl_folds(dom, igvn)) {\n+        if (fold_dominated_if(dom_proj, igvn)) {\n+            return this;\n+        }\n+        Node* dom_cmp = dom->in(0)->in(1)->in(1);\n+        Node* dom_val = dom_cmp->in(1);\n+        if (cmp->Opcode() == Op_CmpI && dom_cmp->Opcode() == Op_CmpI && val == dom_val &&\n+            has_only_uncommon_traps(dom_proj, success, fail, igvn) &&\n+            is_side_effect_free_test(other_proj, igvn) &&\n+            \/\/ Next call modifies graph so must be last\n+            fold_to_unsigned(dom_proj, success, fail, igvn)) {\n+          reroute_side_effect_free_unc(other_proj, dom_proj, igvn);\n+          return merge_uncommon_traps(dom_proj, success, fail, igvn);\n+        }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":196,"deletions":60,"binary":false,"changes":256,"status":"modified"}]}