{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+\/\/ ENABLE_IF_SDEFN(Condition...)\n@@ -39,2 +40,8 @@\n-\/\/ This macro can be used in a function template parameter list to control\n-\/\/ the presence of that overload via SFINAE.\n+\/\/ The ENABLE_IF macro can be used in a function template parameter list to\n+\/\/ control the presence of that overload via SFINAE.\n+\/\/\n+\/\/ When the declaration and definition of a function template are separate,\n+\/\/ only the declaration can use ENABLE_IF in the template parameter list.\n+\/\/ The definition should instead use ENABLE_IF_SDEFN with an _equivalent_\n+\/\/ (C++14 14.4 and 14.5.6.1) Condition for the corresponding template\n+\/\/ parameter.  (\"SDEFN\" is short for \"SEPARATE_DEFINITION\".)\n@@ -88,0 +95,8 @@\n+\/\/ One of those details is that a function template definition that is\n+\/\/ separate from its declaration cannot have a default value.  Thus,\n+\/\/ ENABLE_IF can't be used in such a definition.  But the type expression in\n+\/\/ the separate definition must be equivalent (C++14 14.4 and 14.5.6.1) to\n+\/\/ that in the declation.  The ENABLE_IF_SDEFN macro provides the common\n+\/\/ code for the separate definition that must match the corresponding\n+\/\/ declaration code at the token level.\n+\/\/\n@@ -98,6 +113,23 @@\n-\/\/ exclusion.  A solution is to add a preceding dummy type template\n-\/\/ parameter defaulting to 'int' and use that as the result type for\n-\/\/ enable_if_t, thereby making it dependent.  This situation is sufficiently\n-\/\/ rare that no additional macro support is provided for it; just use the\n-\/\/ underlying enable_if_t directly.  (There is an automatic macro-based\n-\/\/ solution, but it involves the __COUNTER__ extension.)\n+\/\/ exclusion.  This situation is sufficiently rare that no additional\n+\/\/ macro support is provided for it.  (One solution is to add a new\n+\/\/ type parameter defaulted to the type being checked in Condition, and\n+\/\/ use that new parameter instead in Condition.  There is an automatic\n+\/\/ macro-based solution, but it involves the __COUNTER__ extension.)\n+\/\/\n+\/\/ Some references suggest a different approach to using a template\n+\/\/ parameter for SFINAE. An anonymous type parameter with a default type\n+\/\/ that uses std::enable_if can also be used in some cases, i.e.\n+\/\/\n+\/\/   typename = std::enable_if_t<CONDITION>\n+\/\/\n+\/\/ However, this doesn't work when there are overloads that need to be\n+\/\/ selected amongst via SFINAE. Two signatures that differ only in a\n+\/\/ template parameter default are not distinct overloads, they are multiple\n+\/\/ definitions of the same function.\n+\/\/\n+\/\/ Some versions of gcc permit ENABLE_IF to be used in some separate\n+\/\/ definitions.  Other toolchains reject such usage.\n+\/\/\n+\/\/ The expansion of ENABLE_IF doesn't use ENABLE_IF_SDEFN (or both use a\n+\/\/ common helper) because of issues with the Visual Studio preprocessor's\n+\/\/ handling of variadic macros.\n@@ -108,0 +140,3 @@\n+#define ENABLE_IF_SDEFN(...) \\\n+  std::enable_if_t<bool(__VA_ARGS__), int>\n+\n","filename":"src\/hotspot\/share\/metaprogramming\/enableIf.hpp","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n@@ -29,0 +29,2 @@\n+#include <type_traits>\n+#include \"unittest.hpp\"\n@@ -30,1 +32,1 @@\n-class EnableIfTest {\n+class EnableIfTest: AllStatic {\n@@ -45,0 +47,48 @@\n+\n+template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+static T sub1(T x) { return x - 1; }\n+\n+TEST(TestEnableIf, one_decl_and_def) {\n+  EXPECT_EQ(15, sub1(16));\n+}\n+\n+template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+static T sub2(T x);\n+\n+template<typename T, ENABLE_IF_SDEFN(std::is_integral<T>::value)>\n+T sub2(T x) { return x - 2; }\n+\n+TEST(TestEnableIf, separate_decl_and_def) {\n+  EXPECT_EQ(14, sub2(16));\n+}\n+\n+template<typename T>\n+struct TestEnableIfNested {\n+  template<typename U, ENABLE_IF(std::is_integral<U>::value)>\n+  static U sub1(U x);\n+};\n+\n+template<typename T>\n+template<typename U, ENABLE_IF_SDEFN(std::is_integral<U>::value)>\n+U TestEnableIfNested<T>::sub1(U x) { return x - 1; }\n+\n+TEST(TestEnableIf, nested_separate_decl_and_def) {\n+  EXPECT_EQ(15, TestEnableIfNested<void>::sub1(16));\n+}\n+\n+\/\/ Demonstrate workaround for non-dependent condition.\n+template<typename T>\n+struct TestEnableIfNonDependent {\n+  \/\/ Dependent is used to make the ENABLE_IF condition dependent on\n+  \/\/ the type parameters for this function.\n+  template<typename Dependent = T, ENABLE_IF(std::is_same<int, Dependent>::value)>\n+  static T value() { return T{}; }\n+  static int instantiate() { return 5; }\n+};\n+\n+TEST(TestEnableIf, non_dependent) {\n+  EXPECT_EQ(int{}, TestEnableIfNonDependent<int>::value());\n+  \/\/ This fails to compile if the ENABLE_IF for value() directly uses\n+  \/\/ T rather than indirectly via Dependent.\n+  EXPECT_EQ(5, TestEnableIfNonDependent<void>::instantiate());\n+}\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_enableIf.cpp","additions":53,"deletions":3,"binary":false,"changes":56,"status":"modified"}]}