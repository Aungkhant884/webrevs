{"files":[{"patch":"@@ -3225,0 +3225,103 @@\n+        return split(regex, limit, false);\n+    }\n+\n+    \/**\n+     * Splits this string around matches of the given regular expression and\n+     * returns both the strings and the matching delimiters.\n+     *\n+     * <p> The array returned by this method contains each substring of this\n+     * string that is terminated by another substring that matches the given\n+     * expression or is terminated by the end of the string.\n+     * Each substring is immediately followed by the subsequence (the delimiter)\n+     * that matches the given expression, <em>except<\/em> for the last\n+     * substring, which is not followed by anything.\n+     * The substrings in the array and the delimiters are in the order in which\n+     * they occur in the input.\n+     * If the expression does not match any part of the input then the resulting\n+     * array has just one element, namely this string.\n+     *\n+     * <p> When there is a positive-width match at the beginning of this\n+     * string then an empty leading substring is included at the beginning\n+     * of the resulting array. A zero-width match at the beginning however\n+     * never produces such empty leading substring nor the empty delimiter.\n+     *\n+     * <p> The {@code limit} parameter controls the number of times the\n+     * pattern is applied and therefore affects the length of the resulting\n+     * array.\n+     * <ul>\n+     *    <li> If the <i>limit<\/i> is positive then the pattern will be applied\n+     *    at most <i>limit<\/i>&nbsp;-&nbsp;1 times, the array's length will be\n+     *    no greater than 2 &centerdot; <i>limit<\/i> - 1, and the array's last\n+     *    entry will contain all input beyond the last matched delimiter.<\/li>\n+     *\n+     *    <li> If the <i>limit<\/i> is zero then the pattern will be applied as\n+     *    many times as possible, the array can have any length, and trailing\n+     *    empty strings will be discarded.<\/li>\n+     *\n+     *    <li> If the <i>limit<\/i> is negative then the pattern will be applied\n+     *    as many times as possible and the array can have any length.<\/li>\n+     * <\/ul>\n+     *\n+     * <p> The input {@code \"boo:::and::foo\"}, for example, yields the following\n+     * results with these parameters:\n+     *\n+     * <table class=\"plain\" style=\"margin-left:2em;\">\n+     * <caption style=\"display:none\">Split example showing regex, limit, and result<\/caption>\n+     * <thead>\n+     * <tr>\n+     *     <th scope=\"col\">Regex<\/th>\n+     *     <th scope=\"col\">Limit<\/th>\n+     *     <th scope=\"col\">Result<\/th>\n+     * <\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr><th scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\">:+<\/th>\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">2<\/th>\n+     *     <td>{@code { \"boo\", \":::\", \"and::foo\" }}<\/td><\/tr>\n+     * <tr><!-- : -->\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">5<\/th>\n+     *     <td>{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}<\/td><\/tr>\n+     * <tr><!-- : -->\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">-1<\/th>\n+     *     <td>{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}<\/td><\/tr>\n+     * <tr><th scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\">o<\/th>\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">5<\/th>\n+     *     <td>{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}<\/td><\/tr>\n+     * <tr><!-- o -->\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">-1<\/th>\n+     *     <td>{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}<\/td><\/tr>\n+     * <tr><!-- o -->\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">0<\/th>\n+     *     <td>{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}<\/td><\/tr>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * @apiNote An invocation of this method of the form\n+     * <i>str.<\/i>{@code splitWithDelimiters(}<i>regex<\/i>{@code ,}&nbsp;<i>n<\/i>{@code )}\n+     * yields the same result as the expression\n+     *\n+     * <blockquote>\n+     * <code>\n+     * {@link java.util.regex.Pattern}.{@link\n+     * java.util.regex.Pattern#compile(String) compile}(<i>regex<\/i>).{@link\n+     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(<i>str<\/i>,&nbsp;<i>n<\/i>)\n+     * <\/code>\n+     * <\/blockquote>\n+     *\n+     * @param  regex\n+     *         the delimiting regular expression\n+     *\n+     * @param  limit\n+     *         the result threshold, as described above\n+     *\n+     * @return  the array of strings computed by splitting this string\n+     *          around matches of the given regular expression, alternating\n+     *          substrings and matching delimiters\n+     *\n+     * @since   21\n+     *\/\n+    public String[] splitWithDelimiters(String regex, int limit) {\n+        return split(regex, limit, true);\n+    }\n+\n+    private String[] split(String regex, int limit, boolean withDelimiters) {\n@@ -3233,8 +3336,8 @@\n-             \".$|()[{^?*+\\\\\".indexOf(ch = regex.charAt(0)) == -1) ||\n-             (regex.length() == 2 &&\n-              regex.charAt(0) == '\\\\' &&\n-              (((ch = regex.charAt(1))-'0')|('9'-ch)) < 0 &&\n-              ((ch-'a')|('z'-ch)) < 0 &&\n-              ((ch-'A')|('Z'-ch)) < 0)) &&\n-            (ch < Character.MIN_HIGH_SURROGATE ||\n-             ch > Character.MAX_LOW_SURROGATE))\n+                \".$|()[{^?*+\\\\\".indexOf(ch = regex.charAt(0)) == -1) ||\n+                (regex.length() == 2 &&\n+                        regex.charAt(0) == '\\\\' &&\n+                        (((ch = regex.charAt(1))-'0')|('9'-ch)) < 0 &&\n+                        ((ch-'a')|('z'-ch)) < 0 &&\n+                        ((ch-'A')|('Z'-ch)) < 0)) &&\n+                (ch < Character.MIN_HIGH_SURROGATE ||\n+                        ch > Character.MAX_LOW_SURROGATE))\n@@ -3247,1 +3350,1 @@\n-            return split(ch, limit);\n+            return split(ch, limit, withDelimiters);\n@@ -3249,1 +3352,4 @@\n-        return Pattern.compile(regex).split(this, limit);\n+        Pattern pattern = Pattern.compile(regex);\n+        return withDelimiters\n+                ? pattern.splitWithDelimiters(this, limit)\n+                : pattern.split(this, limit);\n@@ -3252,1 +3358,2 @@\n-    private String[] split(char ch, int limit) {\n+    private String[] split(char ch, int limit, boolean withDelimiters) {\n+        int matchCount = 0;\n@@ -3258,1 +3365,1 @@\n-            if (!limited || list.size() < limit - 1) {\n+            if (!limited || matchCount < limit - 1) {\n@@ -3260,0 +3367,3 @@\n+                if (withDelimiters) {\n+                    list.add(String.valueOf(ch));\n+                }\n@@ -3261,0 +3371,1 @@\n+                ++matchCount;\n@@ -3266,0 +3377,1 @@\n+                ++matchCount;\n@@ -3271,1 +3383,1 @@\n-            return new String[]{this};\n+            return new String[] {this};\n@@ -3274,1 +3386,1 @@\n-        if (!limited || list.size() < limit)\n+        if (!limited || matchCount < limit)\n@@ -3331,1 +3443,1 @@\n-        return split(regex, 0);\n+        return split(regex, 0, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":127,"deletions":15,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -1296,0 +1296,94 @@\n+        return split(input, limit, false);\n+    }\n+\n+    \/**\n+     * Splits the given input sequence around matches of this pattern and\n+     * returns both the strings and the matching delimiters.\n+     *\n+     * <p> The array returned by this method contains each substring of the\n+     * input sequence that is terminated by another subsequence that matches\n+     * this pattern or is terminated by the end of the input sequence.\n+     * Each substring is immediately followed by the subsequence (the delimiter)\n+     * that matches this pattern, <em>except<\/em> for the last substring, which\n+     * is not followed by anything.\n+     * The substrings in the array and the delimiters are in the order in which\n+     * they occur in the input.\n+     * If this pattern does not match any subsequence of the input then the\n+     * resulting array has just one element, namely the input sequence in string\n+     * form.\n+     *\n+     * <p> When there is a positive-width match at the beginning of the input\n+     * sequence then an empty leading substring is included at the beginning\n+     * of the resulting array.\n+     * A zero-width match at the beginning however never produces such empty\n+     * leading substring nor the empty delimiter.\n+     *\n+     * <p> The {@code limit} parameter controls the number of times the\n+     * pattern is applied and therefore affects the length of the resulting\n+     * array.\n+     * <ul>\n+     *    <li> If the <i>limit<\/i> is positive then the pattern will be applied\n+     *    at most <i>limit<\/i> - 1 times, the array's length will be\n+     *    no greater than 2 &centerdot; <i>limit<\/i> - 1, and the array's last\n+     *    entry will contain all input beyond the last matched delimiter.<\/li>\n+     *\n+     *    <li> If the <i>limit<\/i> is zero then the pattern will be applied as\n+     *    many times as possible, the array can have any length, and trailing\n+     *    empty strings, whether substrings or delimiters, will be discarded.<\/li>\n+     *\n+     *    <li> If the <i>limit<\/i> is negative then the pattern will be applied\n+     *    as many times as possible and the array can have any length.<\/li>\n+     * <\/ul>\n+     *\n+     * <p> The input {@code \"boo:::and::foo\"}, for example, yields the following\n+     * results with these parameters:\n+     *\n+     * <table class=\"plain\" style=\"margin-left:2em;\">\n+     * <caption style=\"display:none\">Split example showing regex, limit, and result<\/caption>\n+     * <thead>\n+     * <tr>\n+     *     <th scope=\"col\">Regex<\/th>\n+     *     <th scope=\"col\">Limit<\/th>\n+     *     <th scope=\"col\">Result<\/th>\n+     * <\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr><th scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\">:+<\/th>\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">2<\/th>\n+     *     <td>{@code { \"boo\", \":::\", \"and::foo\" }}<\/td><\/tr>\n+     * <tr><!-- : -->\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">5<\/th>\n+     *     <td>{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}<\/td><\/tr>\n+     * <tr><!-- : -->\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">-1<\/th>\n+     *     <td>{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}<\/td><\/tr>\n+     * <tr><th scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\">o<\/th>\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">5<\/th>\n+     *     <td>{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}<\/td><\/tr>\n+     * <tr><!-- o -->\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">-1<\/th>\n+     *     <td>{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}<\/td><\/tr>\n+     * <tr><!-- o -->\n+     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">0<\/th>\n+     *     <td>{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}<\/td><\/tr>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * @param  input\n+     *         The character sequence to be split\n+     *\n+     * @param  limit\n+     *         The result threshold, as described above\n+     *\n+     * @return  The array of strings computed by splitting the input\n+     *          around matches of this pattern, alternating\n+     *          substrings and matching delimiters\n+     *\n+     * @since   21\n+     *\/\n+    public String[] splitWithDelimiters(CharSequence input, int limit) {\n+        return split(input, limit, true);\n+    }\n+\n+    private String[] split(CharSequence input, int limit, boolean withDelimiters) {\n+        int matchCount = 0;\n@@ -1303,1 +1397,1 @@\n-            if (!matchLimited || matchList.size() < limit - 1) {\n+            if (!matchLimited || matchCount < limit - 1) {\n@@ -1312,3 +1406,6 @@\n-            } else if (matchList.size() == limit - 1) { \/\/ last one\n-                String match = input.subSequence(index,\n-                                                 input.length()).toString();\n+                if (withDelimiters) {\n+                    matchList.add(input.subSequence(m.start(), index).toString());\n+                }\n+                ++matchCount;\n+            } else if (matchCount == limit - 1) { \/\/ last one\n+                String match = input.subSequence(index, input.length()).toString();\n@@ -1317,0 +1414,1 @@\n+                ++matchCount;\n@@ -1325,1 +1423,1 @@\n-        if (!matchLimited || matchList.size() < limit)\n+        if (!matchLimited || matchCount < limit)\n@@ -1330,2 +1428,2 @@\n-        if (limit == 0)\n-            while (resultSize > 0 && matchList.get(resultSize-1).isEmpty())\n+        if (limit == 0) {\n+            while (resultSize > 0 && matchList.get(resultSize-1).isEmpty()) {\n@@ -1333,0 +1431,2 @@\n+            }\n+        }\n@@ -1372,1 +1472,1 @@\n-        return split(input, 0);\n+        return split(input, 0, false);\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":108,"deletions":8,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8305486\n+ * @summary Tests to exercise the split functionality added in the issue.\n+ * @run junit SplitWithDelimitersTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Arrays;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+public class SplitWithDelimitersTest {\n+\n+    private static String[] dropOddIndexed(String[] a, int limit) {\n+        String[] r = new String[(a.length + 1) \/ 2];\n+        for (int i = 0; i < a.length; i += 2) {\n+            r[i \/ 2] = a[i];\n+        }\n+        int len = r.length;\n+        if (limit == 0) {\n+            \/* Also drop trailing empty strings *\/\n+            for (; len > 0 && r[len - 1].isEmpty(); --len);  \/\/ empty body\n+        }\n+        return len < r.length ? Arrays.copyOf(r, len) : r;\n+    }\n+\n+    static Arguments[] testSplit() {\n+        return new Arguments[] {\n+                arguments(new String[] {\"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\"},\n+                        \"boo:::and::foo\", \"o\", 5),\n+                arguments(new String[] {\"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"o\"},\n+                        \"boo:::and::foo\", \"o\", 4),\n+                arguments(new String[] {\"b\", \"o\", \"\", \"o\", \":::and::foo\"},\n+                        \"boo:::and::foo\", \"o\", 3),\n+                arguments(new String[] {\"b\", \"o\", \"o:::and::foo\"},\n+                        \"boo:::and::foo\", \"o\", 2),\n+                arguments(new String[] {\"boo:::and::foo\"},\n+                        \"boo:::and::foo\", \"o\", 1),\n+                arguments(new String[] {\"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\"},\n+                        \"boo:::and::foo\", \"o\", 0),\n+                arguments(new String[] {\"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\"},\n+                        \"boo:::and::foo\", \"o\", -1),\n+\n+                arguments(new String[] {\"boo\", \":::\", \"and\", \"::\", \"foo\"},\n+                        \"boo:::and::foo\", \":+\", 3),\n+                arguments(new String[] {\"boo\", \":::\", \"and::foo\"},\n+                        \"boo:::and::foo\", \":+\", 2),\n+                arguments(new String[] {\"boo:::and::foo\"},\n+                        \"boo:::and::foo\", \":+\", 1),\n+                arguments(new String[] {\"boo\", \":::\", \"and\", \"::\", \"foo\"},\n+                        \"boo:::and::foo\", \":+\", 0),\n+                arguments(new String[] {\"boo\", \":::\", \"and\", \"::\", \"foo\"},\n+                        \"boo:::and::foo\", \":+\", -1),\n+\n+                arguments(new String[] {\"b\", \"\", \"b\", \"\", \"\"},\n+                        \"bb\", \"a*|b*\", 3),\n+                arguments(new String[] {\"b\", \"\", \"b\"},\n+                        \"bb\", \"a*|b*\", 2),\n+                arguments(new String[] {\"bb\"},\n+                        \"bb\", \"a*|b*\", 1),\n+                arguments(new String[] {\"b\", \"\", \"b\"},\n+                        \"bb\", \"a*|b*\", 0),\n+                arguments(new String[] {\"b\", \"\", \"b\", \"\", \"\"},\n+                        \"bb\", \"a*|b*\", -1),\n+\n+                arguments(new String[] {\"\", \"bb\", \"\", \"\", \"\"},\n+                        \"bb\", \"b*|a*\", 3),\n+                arguments(new String[] {\"\", \"bb\", \"\"},\n+                        \"bb\", \"b*|a*\", 2),\n+                arguments(new String[] {\"bb\"},\n+                        \"bb\", \"b*|a*\", 1),\n+                arguments(new String[] {\"\", \"bb\"},\n+                        \"bb\", \"b*|a*\", 0),\n+                arguments(new String[] {\"\", \"bb\", \"\", \"\", \"\"},\n+                        \"bb\", \"b*|a*\", -1),\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testSplit(String[] expected, String target, String regex, int limit) {\n+        String[] computedWith = target.splitWithDelimiters(regex, limit);\n+        assertArrayEquals(expected, computedWith);\n+        String[] computedWithout = target.split(regex, limit);\n+        assertArrayEquals(dropOddIndexed(expected, limit), computedWithout);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/regex\/SplitWithDelimitersTest.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"}]}