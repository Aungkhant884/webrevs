{"files":[{"patch":"@@ -0,0 +1,818 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.provider;\n+\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+import sun.security.x509.X509Key;\n+\n+import java.io.*;\n+import java.security.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+\n+\/*\n+ * This class implements the Hierarchical Signature System using the\n+ * Leighton-Micali Signatures (HSS\/LMS) as described in RFC 8554 and\n+ *  NIST Special publication 800-208.\n+ *\/\n+public final class HSS extends SignatureSpi {\n+    private HSSPublicKey pubKey;\n+    private ByteArrayOutputStream messageStream;\n+\n+    @Override\n+    @Deprecated\n+    protected void engineSetParameter(String param, Object value) {\n+        throw new InvalidParameterException(\"No settable parameters exist for HSS\/LMS\");\n+    }\n+\n+    @Override\n+    @Deprecated\n+    protected AlgorithmParameters engineGetParameter(String param) {\n+        throw new InvalidParameterException(\"No parameters exist for HSS\/LMS\");\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        throw new InvalidKeyException(\"HSS\/LMS signing is not supported\");\n+    }\n+\n+    \/\/ This will never be called because engineInitSign unconditionally\n+    \/\/ throws an exception\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        throw new SignatureException(\"HSS\/LMS signing is not supported\");\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        HSSPublicKey pub;\n+        if (publicKey instanceof HSSPublicKey p) {\n+            pub = p;\n+        } else {\n+            KeyFactoryImpl factory = new HSS.KeyFactoryImpl();\n+            Key pk = factory.engineTranslateKey(publicKey);\n+            pub = (HSSPublicKey) pk;\n+        }\n+        pubKey = pub;\n+        messageStream = new ByteArrayOutputStream();\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte data) {\n+        messageStream.write(data);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] data, int off, int len) {\n+        messageStream.write(data, off, len);\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] signature)\n+            throws SignatureException {\n+\n+        boolean result = true;\n+        try {\n+            HSSSignature sig = new HSSSignature(signature, pubKey);\n+            LMSPublicKey lmsPubKey = pubKey.lmsPublicKey;\n+            for (int i = 0; i < sig.Nspk; i++) {\n+                byte[] keyArr = sig.pubList[i].keyArray();\n+                result &= LMSUtils.lmsVerify(lmsPubKey, sig.siglist[i], keyArr);\n+                lmsPubKey = sig.pubList[i];\n+            }\n+\n+            result &= LMSUtils.lmsVerify(\n+                    lmsPubKey, sig.siglist[sig.Nspk], messageStream.toByteArray());\n+        } finally {\n+            messageStream.reset();\n+        }\n+        return result;\n+    }\n+\n+    static class LMSPublicKey {\n+        final int type;\n+        final int otsType;\n+        final LMSParams lmsParams;\n+        private final byte[] I;\n+        private final byte[] T1;\n+\n+        LMSPublicKey(byte[] keyArray, int offset, boolean checkExactLength)\n+                throws InvalidKeyException {\n+            int inLen = keyArray.length - offset;\n+            if (inLen < 8) {\n+                throw new InvalidKeyException(\"LMS public key is too short\");\n+            }\n+            type = LMSUtils.fourBytesToInt(keyArray, offset);\n+            otsType = LMSUtils.fourBytesToInt(keyArray, offset + 4);\n+            LMOTSParams lmotsParams;\n+\n+            try {\n+                lmsParams = LMSParams.of(type);\n+                lmotsParams = LMOTSParams.of(otsType);\n+            } catch (IllegalArgumentException e) {\n+                throw new InvalidKeyException(e.getMessage());\n+            }\n+\n+            int m = lmsParams.m;\n+            if ((inLen < (24 + m)) || (checkExactLength && (inLen != (24 + m))) ||\n+                    !lmsParams.hasSameHash(lmotsParams)) {\n+                throw new InvalidKeyException(\"Wrong LMS public Key length\");\n+            }\n+\n+            I = Arrays.copyOfRange(keyArray, offset + 8, offset + 8 + 16);\n+            T1 = Arrays.copyOfRange(keyArray, offset + 24, offset + 24 + m);\n+        }\n+\n+        void getI(byte[] arr, int pos) {\n+            System.arraycopy(I, 0, arr, pos, 16);\n+        }\n+\n+        boolean isT1(byte[] arr, int pos) {\n+            int m = lmsParams.m;\n+            int diff = 0;\n+            for (int i = 0; i < m; i++) {\n+                diff |= (T1[i] ^ arr[pos + i]);\n+            }\n+            return (diff == 0);\n+        }\n+\n+        byte[] keyArray() {\n+            byte[] result = new byte[keyArrayLength()];\n+            LMSUtils.intToFourBytes(type, result, 0);\n+            LMSUtils.intToFourBytes(otsType, result, 4);\n+            System.arraycopy(I, 0, result, 8, 16);\n+            System.arraycopy(T1, 0, result, 24, lmsParams.m);\n+            return result;\n+        }\n+\n+        int keyArrayLength() {\n+            return 24 + lmsParams.m;\n+        }\n+    }\n+\n+    static class LMSUtils {\n+        final static int LMS_RESERVED = 0;\n+        final static int LMS_SHA256_M32_H5 = 5;\n+        final static int LMS_SHA256_M32_H10 = 6;\n+        final static int LMS_SHA256_M32_H15 = 7;\n+        final static int LMS_SHA256_M32_H20 = 8;\n+        final static int LMS_SHA256_M32_H25 = 9;\n+\n+        static String lmsType(int type) {\n+            String typeStr;\n+            switch (type) {\n+                case LMS_RESERVED: typeStr = \"LMS_RESERVED\"; break;\n+                case LMS_SHA256_M32_H5: typeStr = \"LMS_SHA256_M32_H5\"; break;\n+                case LMS_SHA256_M32_H10: typeStr = \"LMS_SHA256_M32_H10\"; break;\n+                case LMS_SHA256_M32_H15: typeStr = \"LMS_SHA256_M32_H15\"; break;\n+                case LMS_SHA256_M32_H20: typeStr = \"LMS_SHA256_M32_H20\"; break;\n+                case LMS_SHA256_M32_H25: typeStr = \"LMS_SHA256_M32_H25\"; break;\n+                default: typeStr = \"unrecognized\";\n+            }\n+            return typeStr;\n+        }\n+\n+        final static int LMOTS_RESERVED = 0;\n+        final static int LMOTS_SHA256_N32_W1 = 1;\n+        final static int LMOTS_SHA256_N32_W2 = 2;\n+        final static int LMOTS_SHA256_N32_W4 = 3;\n+        final static int LMOTS_SHA256_N32_W8 = 4;\n+\n+        static String lmotsType(int type) {\n+            String typeStr;\n+            switch (type) {\n+                case LMOTS_RESERVED: typeStr = \"LMOTS_RESERVED\"; break;\n+                case LMOTS_SHA256_N32_W1: typeStr = \"LMOTS_SHA256_N32_W1\"; break;\n+                case LMOTS_SHA256_N32_W2: typeStr = \"LMOTS_SHA256_N32_W2\"; break;\n+                case LMOTS_SHA256_N32_W4: typeStr = \"LMOTS_SHA256_N32_W4\"; break;\n+                case LMOTS_SHA256_N32_W8: typeStr = \"LMOTS_SHA256_N32_W8\"; break;\n+                default: typeStr = \"unrecognized\";\n+            }\n+            return typeStr;\n+        }\n+\n+\n+        static int fourBytesToInt(byte[] arr, int i) {\n+            return ((arr[i] & 0xff) << 24) |\n+                    ((arr[i + 1] & 0xff) << 16) |\n+                    ((arr[i + 2] & 0xff) << 8) |\n+                    (arr[i + 3] & 0xff);\n+        }\n+\n+        static void intToFourBytes(int i, byte[] arr, int pos) {\n+            arr[pos] = (byte) (i >> 24);\n+            arr[pos + 1] = (byte) (i >> 16);\n+            arr[pos + 2] = (byte) (i >> 8);\n+            arr[pos + 3] = (byte) i;\n+        }\n+        static boolean lmsVerify(\n+                LMSPublicKey lmsPublicKey, LMSignature sig, byte[] message)\n+                throws SignatureException {\n+\n+            if ((sig.sigOtsType != lmsPublicKey.otsType) ||\n+                    (sig.sigLmType != lmsPublicKey.type)) {\n+                return false;\n+            }\n+            LMOTSignature lmotSig = sig.lmotSig;\n+            LMOTSParams lmotsParams = lmotSig.lmotsParams;\n+            int q = sig.q;\n+            int m = lmsPublicKey.lmsParams.m;\n+            int hashAlg_m = lmsPublicKey.lmsParams.hashAlg_m;\n+            int n = lmotsParams.n;\n+\n+            try {\n+                byte[] otsPkCandidate =\n+                        lmotsParams.lmotsPubKeyCandidate(sig, message, lmsPublicKey);\n+                int nodeNum = lmsPublicKey.lmsParams.twoPowh + q;\n+                int tmp0MsgLen = 22 + n;\n+                int tmpLoopMsgLen = 22 + m + hashAlg_m;\n+                byte[] tmpMsg = new byte[Integer.max(tmp0MsgLen, tmpLoopMsgLen)];\n+                lmsPublicKey.getI(tmpMsg, 0);\n+                MessageDigest md =\n+                        MessageDigest.getInstance(lmsPublicKey.lmsParams.hashAlgStr);\n+                LMSUtils.intToFourBytes(nodeNum, tmpMsg, 16);\n+                tmpMsg[20] = (byte) 0x82; \/\/ D_LEAF = 0x8282\n+                tmpMsg[21] = (byte) 0x82;\n+                System.arraycopy(otsPkCandidate, 0, tmpMsg, 22, n);\n+                md.update(tmpMsg, 0, tmp0MsgLen);\n+                if ((nodeNum & 1) == 1) {\n+                    md.digest(tmpMsg, 22 + m, hashAlg_m);\n+                } else {\n+                    md.digest(tmpMsg, 22, hashAlg_m);\n+                }\n+                tmpMsg[20] = (byte) 0x83; \/\/ D_INTR = 0x8383\n+                tmpMsg[21] = (byte) 0x83;\n+\n+                int i = 0;\n+                while (nodeNum > 1) {\n+                    LMSUtils.intToFourBytes(nodeNum \/ 2, tmpMsg, 16);\n+\n+                    if ((nodeNum & 1) == 1) {\n+                        sig.getPath(i, tmpMsg, 22);\n+                    } else {\n+                        sig.getPath(i, tmpMsg, 22 + m);\n+                    }\n+                    md.update(tmpMsg, 0, 22 + 2 * m);\n+                    nodeNum \/= 2;\n+                    if ((nodeNum & 1) == 1) {\n+                        md.digest(tmpMsg, 22 + m, hashAlg_m);\n+                    } else {\n+                        md.digest(tmpMsg, 22, hashAlg_m);\n+                    }\n+                    i++;\n+                }\n+                return lmsPublicKey.isT1(tmpMsg, 22 + m);\n+            } catch (NoSuchAlgorithmException | DigestException e) {\n+                throw new ProviderException(e);\n+            }\n+        }\n+    }\n+\n+    static class LMOTSignature {\n+        final int otSigType;\n+        final LMOTSParams lmotsParams;\n+        private final int n;\n+        private final int p;\n+        private final byte[] C;\n+        private final byte[][] y;\n+\n+        LMOTSignature(byte[] sigArray, LMOTSParams lmotsParams)\n+                throws InvalidParameterException {\n+            int inLen = sigArray.length;\n+            if (inLen < 4) {\n+                throw new InvalidParameterException(\"OTS signature is too short\");\n+            }\n+            otSigType = lmotsParams.lmotSigType;\n+            this.lmotsParams = lmotsParams;\n+            n = lmotsParams.n;\n+            p = lmotsParams.p;\n+            if (inLen != (4 + n * (p + 1))) {\n+                throw new InvalidParameterException(\"OTS signature has incorrect length\");\n+            }\n+            C = Arrays.copyOfRange(sigArray, 4, 4 + n);\n+            int pStart = 4 + n;\n+            y = new byte[p][n];\n+            for (int i = 0; i < p; i++) {\n+                y[i] = Arrays.copyOfRange(sigArray, pStart, pStart + n);\n+                pStart += n;\n+            }\n+        }\n+\n+        void getC(byte[] arr, int pos) {\n+            System.arraycopy(C, 0, arr, pos, n);\n+        }\n+\n+        void getY(int i, byte[] arr, int pos) {\n+            System.arraycopy(y[i], 0, arr, pos, n);\n+        }\n+    }\n+\n+    static class LMSParams {\n+        final int m; \/\/ the number of bytes used from the hash output\n+        final int hashAlg_m = 32; \/\/ output length of the LMS tree hash function\n+        final int h; \/\/ height of the LMS tree\n+        final int twoPowh;\n+        final String hashAlgStr;\n+\n+        LMSParams(int type, int m, int h, String hashAlgStr) {\n+            this.m = m;\n+            this.h = h;\n+            this.hashAlgStr = hashAlgStr;\n+            twoPowh = 1 << h;\n+        }\n+\n+        static LMSParams of(int type) {\n+            int m;\n+            int h;\n+            String hashAlgStr;\n+            switch (type) {\n+                case LMSUtils.LMS_SHA256_M32_H5:\n+                    m = 32;\n+                    h = 5;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H10:\n+                    m = 32;\n+                    h = 10;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H15:\n+                    m = 32;\n+                    h = 15;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H20:\n+                    m = 32;\n+                    h = 20;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H25:\n+                    m = 32;\n+                    h = 25;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported or bad LMS type\");\n+            }\n+\n+            return new LMSParams(type, m, h, hashAlgStr);\n+        }\n+\n+        boolean hasSameHash(LMSParams other) {\n+            return (other.hashAlgStr.equals(hashAlgStr)) && (other.m == m);\n+        }\n+\n+        boolean hasSameHash(LMOTSParams lmotsParams) {\n+            return lmotsParams.hashAlgName.equals(hashAlgStr) &&\n+                    (lmotsParams.n == m);\n+        }\n+    }\n+\n+    static class LMSignature {\n+        final int sigLmType;\n+        final int sigOtsType;\n+        final private byte[] qArr;\n+        final int q; \/\/ serial number of the LMS key being used for this signature\n+        final LMOTSignature lmotSig;\n+        final int n; \/\/ output length of the hash function used in the OTS\n+        final int p; \/\/ number of hash chains in the signature\n+        final int m; \/\/ output length of the hash fubction used in the Merkle tree\n+        final int h; \/\/ height of the Merkle tree\n+        final byte[][] path;\n+        final byte[] sigArr;\n+\n+        LMSignature(byte[] sigArray, int offset, boolean checkExactLen)\n+                throws SignatureException {\n+            int inLen = sigArray.length - offset;\n+            if (inLen < 8) {\n+                throw new SignatureException(\"LMS signature is too short\");\n+            }\n+\n+            LMOTSParams lmotsParams;\n+                q = LMSUtils.fourBytesToInt(sigArray, offset);\n+                qArr = Arrays.copyOfRange(sigArray, offset, offset + 4);\n+                sigOtsType = LMSUtils.fourBytesToInt(sigArray, offset + 4);\n+            try {\n+                lmotsParams = LMOTSParams.of(sigOtsType);\n+            } catch (IllegalArgumentException e) {\n+                throw new SignatureException(e);\n+            }\n+\n+            n = lmotsParams.n;\n+            p = lmotsParams.p;\n+\n+            if (inLen < (12 + n * (p + 1))) {\n+                throw new SignatureException(\"LMS signature is too short\");\n+            }\n+\n+            int otsSigLen = 4 + n * (p + 1);\n+            byte[] otSigArr = Arrays.copyOfRange(\n+                            sigArray, offset + 4, offset + 4 + otsSigLen);\n+            lmotSig = new LMOTSignature(otSigArr, lmotsParams);\n+\n+            int sigTypePos = offset + 4 + otsSigLen;\n+            sigLmType = LMSUtils.fourBytesToInt(sigArray, sigTypePos);\n+\n+            LMSParams lmsParams;\n+            try {\n+                lmsParams = LMSParams.of(sigLmType);\n+            } catch (IllegalArgumentException e) {\n+                throw new SignatureException(e);\n+            }\n+            m = lmsParams.m;\n+            h = lmsParams.h;\n+\n+            int sigArrLen = (12 + n * (p + 1) + m * h);\n+            if ((q >= (1 << h)) ||\n+                    (inLen < sigArrLen) ||\n+                    (checkExactLen && (inLen != sigArrLen))) {\n+                throw new SignatureException(\"LMS signature length is incorrect\");\n+            }\n+\n+            sigArr = Arrays.copyOfRange(sigArray, offset, offset + sigArrLen);\n+\n+            int pStart = offset + 12 + n * (p + 1);\n+            path = new byte[h][m];\n+            for (int i = 0; i < h; i++) {\n+                path[i] = Arrays.copyOfRange(sigArray, pStart, pStart + m);\n+                pStart += m;\n+            }\n+        }\n+\n+        int sigArrayLength() {\n+            return 12 + n * (p + 1) + m * h;\n+        }\n+\n+        void getQArr(byte[] arr, int pos) {\n+            System.arraycopy(qArr, 0, arr, pos, 4);\n+        }\n+\n+        void getPath(int i, byte[] arr, int pos) {\n+            System.arraycopy(path[i], 0, arr, pos, m);\n+        }\n+    }\n+\n+    static class LMOTSParams {\n+        final int lmotSigType;\n+        final int n; \/\/ the number of bytes used from the hash output\n+        final int hashAlg_n = 32; \/\/ the output length of the hash function\n+        final int w;\n+        final int twoPowWMinus1;\n+        final int ls;\n+        final int p;\n+        final String hashAlgName;\n+\n+        \/\/ The initial buffer image for the lmotsPubKeyCandidate() function.\n+        \/\/ In that function a clone of this buffer is fed into the\n+        \/\/ hash function as input to the implDigestFixedLengthPreprocessed()\n+        \/\/ function (which is basically an allocation and padding computation\n+        \/\/ free digest() function, so we can avoid the update()-digest()\n+        \/\/ sequence) which is parametrized so that the digest output is copied\n+        \/\/ back into the buffer. This way, we avoid memory allocations and some\n+        \/\/ computations that would have to be done otherwise.\n+        final byte[] hashBuf;\n+        \/\/ Precomputed block for SHA256 when the message size is 55 bytes\n+        \/\/ (i.e. when SHA256 is used)\n+        private final static byte[] hashbufSha256_32 = {\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, (byte) 0x80,\n+                0, 0, 0, 0, 0, 0, 1, (byte) 0xb8\n+        };\n+\n+        private LMOTSParams(\n+                int lmotSigType, int hLen, int w,\n+                int ls, int p, String hashAlgName) {\n+            this.lmotSigType = lmotSigType;\n+            this.n = hLen;\n+            this.w = w;\n+            this.ls = ls;\n+            this.p = p;\n+            twoPowWMinus1 = (1 << w) - 1;\n+            this.hashAlgName = hashAlgName;\n+            hashBuf = hashbufSha256_32;\n+        }\n+\n+        static LMOTSParams of(int lmotsType) {\n+            LMOTSParams params;\n+            switch (lmotsType) {\n+                case LMSUtils.LMOTS_SHA256_N32_W1:\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 1, 7, 265, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N32_W2:\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 2, 6, 133, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N32_W4:\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 4, 4, 67, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N32_W8:\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 8, 0, 34, \"SHA-256\");\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\n+                            \"Unsupported or bad OTS Algorithm Identifier.\");\n+            }\n+            return params;\n+        }\n+\n+        int coef(byte[] S, int i) {\n+            return (twoPowWMinus1 &\n+                    (S[i * w \/ 8] >> (8 - (w * (i % (8 \/ w)) + w))));\n+        }\n+\n+        private void addCksm(byte[] S) {\n+            int len = n;\n+            int sum = 0;\n+            int numSlices = len * 8 \/ w;\n+            for (int i = 0; i < numSlices; i++) {\n+                sum += twoPowWMinus1 - coef(S, i);\n+            }\n+            sum = sum << ls;\n+            S[len] = (byte) (sum >> 8);\n+            S[len + 1] = (byte) (sum & 0xff);\n+        }\n+\n+        void digestFixedLengthPreprocessed(\n+                SHA2.SHA256 sha256, byte[] input, int inLen,\n+                byte[] output, int outOffset, int outLen) {\n+            sha256.implDigestFixedLengthPreprocessed(\n+                    input, inLen, output, outOffset, outLen);\n+        }\n+\n+        byte[] lmotsPubKeyCandidate(\n+                LMSignature lmSig, byte[] message, LMSPublicKey pKey)\n+                throws SignatureException {\n+            LMOTSignature lmOtSig = lmSig.lmotSig;\n+            if (lmOtSig.otSigType != pKey.otsType) {\n+                throw new SignatureException(\n+                        \"OTS public key type and OTS signature type do not match\");\n+            }\n+\n+            byte[] preQ = new byte[22 + hashAlg_n];\n+            pKey.getI(preQ, 0);\n+            lmSig.getQArr(preQ, 16);\n+            preQ[20] = (byte) 0x81; \/\/ D_MSG = 0x8181\n+            preQ[21] = (byte) 0x81;\n+            lmOtSig.getC(preQ, 22);\n+            MessageDigest md;\n+            try {\n+                md = MessageDigest.getInstance(hashAlgName);\n+            } catch (NoSuchAlgorithmException e) { \/\/ This should not happen\n+                throw new ProviderException(\"Digest implementation not found\", e);\n+            }\n+            byte[] result;\n+            try {\n+                md.update(preQ, 0, 22 + n);\n+                md.update(message);\n+                byte[] QWithChecksum = new byte[hashAlg_n + 2];\n+                md.digest(QWithChecksum, 0, hashAlg_n);\n+                \/\/ the MessageDigest object has now been reset\n+                addCksm(QWithChecksum);\n+\n+                byte[] preCandidate = new byte[22 + (p - 1) * n + hashAlg_n];\n+                pKey.getI(preCandidate, 0);\n+                lmSig.getQArr(preCandidate, 16);\n+                preCandidate[20] = (byte) 0x80; \/\/ D_PBLC = 0x8080\n+                preCandidate[21] = (byte) 0x80;\n+\n+                byte[] preZi = hashBuf.clone();\n+                SHA2.SHA256 sha256 = new SHA2.SHA256();\n+                pKey.getI(preZi, 0);\n+                lmSig.getQArr(preZi, 16);\n+\n+                int twoPowWMinus2 = twoPowWMinus1 - 1;\n+                for (int i = 0; i < p; i++) {\n+                    int a = coef(QWithChecksum, i);\n+                    if (a == twoPowWMinus1) {\n+                        lmOtSig.getY(i, preCandidate, 22 + i * n);\n+                    } else {\n+                        preZi[20] = (byte) (i >> 8);\n+                        preZi[21] = (byte) i;\n+                        lmOtSig.getY(i, preZi, 23);\n+                    }\n+\n+                    for (int j = a; j < twoPowWMinus1; j++) {\n+                        preZi[22] = (byte) j;\n+                        if (j < twoPowWMinus2) {\n+                            digestFixedLengthPreprocessed(\n+                                    sha256, preZi, 64, preZi, 23, n);\n+                        } else {\n+                            digestFixedLengthPreprocessed(\n+                                    sha256, preZi, 64, preCandidate, 22 + i * n, n);\n+                        }\n+                    }\n+                }\n+                md.update(preCandidate, 0, 22 + p * n);\n+\n+                result = md.digest();\n+            } catch (DigestException e) { \/\/ This should not happen\n+                throw new ProviderException(\"Digest failed\", e);\n+            }\n+            if (n != hashAlg_n) {\n+                result = Arrays.copyOfRange(result, 0, n);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static class KeyFactoryImpl extends KeyFactorySpi {\n+        @Override\n+        protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+                throws InvalidKeySpecException {\n+            if (keySpec instanceof X509EncodedKeySpec x) {\n+                try {\n+                    X509EncodedKeySpec x509Spec = (X509EncodedKeySpec)keySpec;\n+                    return new HSSPublicKey(\n+                            x509Spec.getEncoded(), true);\n+                } catch (InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(e);\n+                }\n+            } else if (keySpec instanceof RawKeySpec x) {\n+                try {\n+                    return new HSSPublicKey(x.getKeyArr(), false);\n+                } catch (InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(e);\n+                }\n+            }\n+            throw new InvalidKeySpecException(\"Unrecognized KeySpec\");\n+        }\n+\n+        @Override\n+        protected PrivateKey engineGeneratePrivate(KeySpec keySpec)\n+                throws InvalidKeySpecException {\n+            throw new InvalidKeySpecException(\n+                    \"Private key generation is not supported\");\n+        }\n+\n+        @Override\n+        protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec)\n+                throws InvalidKeySpecException {\n+            if (key == null) {\n+                throw new InvalidKeySpecException(\"key should not be null\");\n+            }\n+            if (key.getFormat().equals(\"X.509\") &&\n+                    key.getAlgorithm().equalsIgnoreCase(\"HSS\/LMS\")) {\n+                if (keySpec.isAssignableFrom(X509EncodedKeySpec.class)) {\n+                    return keySpec.cast(new X509EncodedKeySpec(key.getEncoded()));\n+                }\n+                throw new InvalidKeySpecException(\"keySpec is not an X509 one\");\n+            }\n+            throw new InvalidKeySpecException(\"Wrong key format or key algorithm\");\n+        }\n+\n+        @Override\n+        protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+            if (key == null) {\n+                throw  new InvalidKeyException(\"key cannot be null\");\n+            }\n+            PublicKey pKey;\n+            try {\n+                \/\/ Check if key originates from this factory\n+                if (key instanceof HSSPublicKey) {\n+                    return key;\n+                }\n+                \/\/ Convert key to spec\n+                X509EncodedKeySpec x509EncodedKeySpec\n+                        = engineGetKeySpec(key, X509EncodedKeySpec.class);\n+                \/\/ Create key from spec, and return it\n+                pKey = engineGeneratePublic(x509EncodedKeySpec);\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(e);\n+            }\n+            return pKey;\n+        }\n+    }\n+\n+    static class HSSPublicKey extends X509Key implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = 21;\n+        private transient int L;\n+        private transient LMSPublicKey lmsPublicKey;\n+\n+        HSSPublicKey(byte[] keyArray, boolean x509Encoded)\n+                throws InvalidKeyException {\n+            if (x509Encoded) {\n+                decode(keyArray);\n+            } else {\n+                int inLen = keyArray.length;\n+                if (inLen < 4) {\n+                    throw new InvalidKeyException(\"HSS public key too short\");\n+                }\n+                L = LMSUtils.fourBytesToInt(keyArray, 0);\n+                lmsPublicKey =\n+                        new LMSPublicKey(\n+                                Arrays.copyOfRange(keyArray, 4, keyArray.length),\n+                                0, true);\n+                algid = new AlgorithmId(ObjectIdentifier.of(KnownOIDs.HSSLMS));\n+                byte[] derEncodedKeyarray =\n+                        new DerOutputStream()\n+                                .putOctetString(keyArray)\n+                                .toByteArray();\n+                this.setKey(new BitArray(\n+                        8 * derEncodedKeyarray.length, derEncodedKeyarray));\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            HexDumpEncoder encoder = new HexDumpEncoder();\n+\n+            return \"HSS\/LMS public key, number of layers: \" + L +\n+                    \", LMS type: \" + LMSUtils.lmsType(lmsPublicKey.type) +\n+                    \",\\nOTS type: \" + LMSUtils.lmotsType(lmsPublicKey.otsType) +\n+                    \", byte array representation:\\n\" +\n+                    encoder.encode(getKey().toByteArray());\n+        }\n+\n+        \/**\n+         * Parse the key. Called by X509Key.\n+         *\/\n+        @Override\n+        protected void parseKeyBits() throws InvalidKeyException {\n+            byte[] keyArray = getKey().toByteArray();\n+            L = LMSUtils.fourBytesToInt(keyArray, 2);\n+            lmsPublicKey = new LMSPublicKey(keyArray, 6, true);\n+        }\n+\n+        @java.io.Serial\n+        protected Object writeReplace() throws java.io.ObjectStreamException {\n+            return new KeyRep(KeyRep.Type.PUBLIC,\n+                    getAlgorithm(),\n+                    getFormat(),\n+                    getEncoded());\n+        }\n+    }\n+\n+    static class HSSSignature {\n+        private final int Nspk;\n+        private final LMSignature[] siglist;\n+        private final LMSPublicKey[] pubList;\n+\n+        HSSSignature(byte[] sigArr, HSSPublicKey pubKey)\n+                throws SignatureException {\n+            if (sigArr.length < 4) {\n+                throw new SignatureException(\"HSS signature is too short\");\n+            }\n+            Nspk = LMSUtils.fourBytesToInt(sigArr, 0);\n+            if (Nspk + 1 != pubKey.L) {\n+                throw new SignatureException(\n+                        \"HSS signature and public key have different tree heights\");\n+            }\n+            siglist = new LMSignature[Nspk + 1];\n+            pubList = new LMSPublicKey[Nspk];\n+            int index = 4;\n+            try {\n+                for (int i = 0; i < Nspk; i++) {\n+                    siglist[i] = new LMSignature(sigArr, index, false);\n+                    index += siglist[i].sigArrayLength();\n+                    pubList[i] = new LMSPublicKey(sigArr, index, false);\n+                    if (!pubKey\n+                            .lmsPublicKey\n+                            .lmsParams\n+                            .hasSameHash(pubList[i].lmsParams)) {\n+                        throw new SignatureException(\n+                                \"Digest algorithm in public key and Signature do not match\");\n+                    }\n+                    index += pubList[i].keyArrayLength();\n+                }\n+                siglist[Nspk] = new LMSignature(sigArr, index, true);\n+            } catch (InvalidKeyException e) {\n+                throw new SignatureException(\"Invalid key in HSS signature\", e);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/HSS.java","additions":818,"deletions":0,"binary":false,"changes":818,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+    private static final int BLOCKSIZE = 64;\n@@ -84,1 +85,1 @@\n-        super(name, digestLength, 64);\n+        super(name, digestLength, BLOCKSIZE);\n@@ -118,0 +119,11 @@\n+\n+    protected void implDigestFixedLengthPreprocessed(\n+            byte[] input, int inLen, byte[] output, int outOffset, int outLen) {\n+        implReset();\n+\n+        for (int ofs = 0; ofs < inLen; ofs += BLOCKSIZE) {\n+            implCompress0(input, ofs);\n+        }\n+        i2bBig(state, 0, output, outOffset, outLen);\n+    }\n+\n@@ -132,1 +144,1 @@\n-        Preconditions.checkFromIndexSize(ofs, 64, buf.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkFromIndexSize(ofs, BLOCKSIZE, buf.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA2.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,0 +188,4 @@\n+\n+        attrs.clear();\n+        attrs.put(\"ImplementedIn\", \"Software\");\n+        addWithAlias(p, \"Signature\", \"HSS\/LMS\", \"sun.security.provider.HSS\", attrs);\n@@ -217,0 +221,2 @@\n+        addWithAlias(p, \"KeyFactory\", \"HSS\/LMS\",\n+                \"sun.security.provider.HSS$KeyFactoryImpl\", attrs);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,0 +242,1 @@\n+    HSSLMS(\"1.2.840.113549.1.9.16.3.17\", \"HSS\/LMS\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.spec.KeySpec;\n+\/\/12345678901234567890123456789012345678901234567890123456789012345678901234567890\n+\n+\/**\n+ * This is a KeySpec that is used to specify a key by its byte array implementation.\n+ * It is intended to be used in testing algorithms where the algorithm specification\n+ * describes the key in this form.\n+ *\/\n+public class RawKeySpec implements KeySpec {\n+    private final byte[] keyArr;\n+    \/**\n+     * The sole constructor.\n+     * @param key contains the key as a byte array\n+     *\/\n+    public RawKeySpec(byte[] key) {\n+        keyArr = key.clone();\n+    }\n+\n+    \/**\n+     * Getter function.\n+     * @return a copy of the key bits\n+     *\/\n+    public byte[] getKeyArr() {\n+        return keyArr.clone();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/RawKeySpec.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"}]}