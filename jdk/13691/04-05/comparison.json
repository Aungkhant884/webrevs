{"files":[{"patch":"@@ -38,1 +38,5 @@\n-public class HSS extends SignatureSpi {\n+\/*\n+ * This class implements the Hierarchical Signature System using the\n+ * Leighton-Micali Signatures (LMS) as described in RFC 8554 and NIST Special publication 800-208\n+ *\/\n+public final class HSS extends SignatureSpi {\n@@ -44,1 +48,1 @@\n-        throw new UnsupportedOperationException();\n+        throw new InvalidParameterException(\"No settable parameters exist for HSS\/LMS\");\n@@ -49,1 +53,1 @@\n-        throw new UnsupportedOperationException();\n+        throw new InvalidParameterException(\"No parameters exist for HSS\/LMS\");\n@@ -53,1 +57,1 @@\n-        throw new InvalidKeyException(\"Signing is not supported\");\n+        throw new InvalidKeyException(\"HSS\/LMS signing is not supported\");\n@@ -56,0 +60,1 @@\n+    \/\/ This will never be called because engineInitSign unconditionally throws an exception\n@@ -57,1 +62,1 @@\n-        throw new UnsupportedOperationException();\n+        throw new SignatureException(\"HSS\/LMS signing is not supported\");\n@@ -83,1 +88,1 @@\n-            HSSSignature sig = new HSSSignature(signature, pubKey.L, pubKey.getDigestAlgorithm());\n+            HSSSignature sig = new HSSSignature(signature, pubKey);\n@@ -95,1 +100,1 @@\n-            return false;\n+            throw new SignatureException(e);\n@@ -174,1 +179,1 @@\n-                throw new InvalidKeyException(\"Invalid LMS public key\");\n+                throw new InvalidKeyException(\"LMS public key is too short\");\n@@ -190,1 +195,1 @@\n-                throw new InvalidKeyException(\"Invalid LMS public Key\");\n+                throw new InvalidKeyException(\"Wrong LMS public Key length\");\n@@ -295,1 +300,1 @@\n-                throw new InvalidParameterException(\"Invalid LMS signature\");\n+                throw new InvalidParameterException(\"OTS signature is too short\");\n@@ -301,1 +306,1 @@\n-                throw new InvalidParameterException(\"Invalid LMS signature\");\n+                throw new InvalidParameterException(\"OTS signature has incorrect length\");\n@@ -356,81 +361,0 @@\n-\n-\/*\n-                case LMSUtils.LMS_SHAKE_M32_H5:\n-                    m = 32;\n-                    h = 5;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n-                case LMSUtils.LMS_SHAKE_M32_H10:\n-                    m = 32;\n-                    h = 10;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n-                case LMSUtils.LMS_SHAKE_M32_H15:\n-                    m = 32;\n-                    h = 15;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n-                case LMSUtils.LMS_SHAKE_M32_H20:\n-                    m = 32;\n-                    h = 20;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n-                case LMSUtils.LMS_SHAKE_M32_H25:\n-                    m = 32;\n-                    h = 25;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n-\n-                case LMSUtils.LMS_SHA256_M24_H5:\n-                    m = 24;\n-                    h = 5;\n-                    hashAlgStr = \"SHA-256\";\n-                    break;\n-                case LMSUtils.LMS_SHA256_M24_H10:\n-                    m = 24;\n-                    h = 10;\n-                    hashAlgStr = \"SHA-256\";\n-                    break;\n-                case LMSUtils.LMS_SHA256_M24_H15:\n-                    m = 24;\n-                    h = 15;\n-                    hashAlgStr = \"SHA-256\";\n-                    break;\n-                case LMSUtils.LMS_SHA256_M24_H20:\n-                    m = 24;\n-                    h = 20;\n-                    hashAlgStr = \"SHA-256\";\n-                    break;\n-                case LMSUtils.LMS_SHA256_M24_H25:\n-                    m = 24;\n-                    h = 25;\n-                    hashAlgStr = \"SHA-256\";\n-                    break;\n-\n-                case LMSUtils.LMS_SHAKE_M24_H5:\n-                    m = 24;\n-                    h = 5;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n-                case LMSUtils.LMS_SHAKE_M24_H10:\n-                    m = 24;\n-                    h = 10;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n-                case LMSUtils.LMS_SHAKE_M24_H15:\n-                    m = 24;\n-                    h = 15;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n-                case LMSUtils.LMS_SHAKE_M24_H20:\n-                    m = 24;\n-                    h = 20;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n-                case LMSUtils.LMS_SHAKE_M24_H25:\n-                    m = 24;\n-                    h = 25;\n-                    hashAlgStr = \"SHAKE256\";\n-                    break;\n- *\/\n-\n@@ -459,1 +383,1 @@\n-        public LMSignature(byte[] sigArray, int offset, boolean checkExactLen) throws InvalidParameterException {\n+        public LMSignature(byte[] sigArray, int offset, boolean checkExactLen) throws SignatureException {\n@@ -462,1 +386,1 @@\n-                throw new InvalidParameterException(\"Invalid LMS signature\");\n+                throw new SignatureException(\"LMS signature is too short\");\n@@ -464,4 +388,9 @@\n-            q = LMSUtils.fourBytesToInt(sigArray, offset);\n-            qArr = Arrays.copyOfRange(sigArray, offset, offset + 4);\n-            sigOtsType = LMSUtils.fourBytesToInt(sigArray, offset + 4);\n-            LMOTSParams lmotsParams = LMOTSParams.of(sigOtsType);\n+            LMOTSParams lmotsParams;\n+            try {\n+                q = LMSUtils.fourBytesToInt(sigArray, offset);\n+                qArr = Arrays.copyOfRange(sigArray, offset, offset + 4);\n+                sigOtsType = LMSUtils.fourBytesToInt(sigArray, offset + 4);\n+                lmotsParams = LMOTSParams.of(sigOtsType);\n+            } catch (IllegalArgumentException e) {\n+                throw new SignatureException(e);\n+            }\n@@ -473,1 +402,1 @@\n-                throw new InvalidParameterException(\"Invalid LMS signature\");\n+                throw new SignatureException(\"LMS signature is too short\");\n@@ -482,1 +411,6 @@\n-            LMParams lmParams = new LMParams(sigLmType);\n+            LMParams lmParams;\n+            try {\n+                lmParams = new LMParams(sigLmType);\n+            } catch (IllegalArgumentException e) {\n+                throw new SignatureException(e);\n+            }\n@@ -488,1 +422,1 @@\n-                throw new InvalidParameterException(\"Invalid LMS signature\");\n+                throw new InvalidParameterException(\"LMS signature length is incorrect\");\n@@ -590,40 +524,0 @@\n-\/*\n-                case LMSUtils.LMOTS_SHA256_N24_W1:\n-                    params = new LMOTSParams(lmotsType, 24, 1, 8, 200, \"SHA-256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHA256_N24_W2:\n-                    params = new LMOTSParams(lmotsType, 24, 2, 6, 101, \"SHA-256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHA256_N24_W4:\n-                    params = new LMOTSParams(lmotsType, 32, 4, 4, 51, \"SHA-256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHA256_N24_W8:\n-                    params = new LMOTSParams(lmotsType, 24, 8, 0, 26, \"SHA-256\");\n-                    break;\n-\n-                case LMSUtils.LMOTS_SHAKE_N32_W1:\n-                    params = new LMOTSParams(lmotsType, 32, 1, 7, 265, \"SHAKE256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHAKE_N32_W2:\n-                    params = new LMOTSParams(lmotsType, 32, 2, 6, 133, \"SHAKE256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHAKE_N32_W4:\n-                    params = new LMOTSParams(lmotsType, 32, 4, 4, 67, \"SHAKE256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHAKE_N32_W8:\n-                    params = new LMOTSParams(lmotsType, 32, 8, 0, 34, \"SHAKE256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHAKE_N24_W1:\n-                    params = new LMOTSParams(lmotsType, 24, 1, 8, 200, \"SHAKE256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHAKE_N24_W2:\n-                    params = new LMOTSParams(lmotsType, 24, 2, 6, 101, \"SHAKE256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHAKE_N24_W4:\n-                    params = new LMOTSParams(lmotsType, 24, 4, 4, 51, \"SHAKE256\");\n-                    break;\n-                case LMSUtils.LMOTS_SHAKE_N24_W8:\n-                    params = new LMOTSParams(lmotsType, 24, 8, 0, 26, \"SHAKE256\");\n-                    break;\n- *\/\n-\n@@ -659,1 +553,1 @@\n-                throws NoSuchAlgorithmException, DigestException {\n+                throws SignatureException {\n@@ -662,1 +556,1 @@\n-                throw new IllegalArgumentException(\"OTS public key type and OTS signature type do not match\");\n+                throw new SignatureException(\"OTS public key type and OTS signature type do not match\");\n@@ -671,32 +565,29 @@\n-            MessageDigest md = MessageDigest.getInstance(hashAlgName);\n-            md.update(preQ, 0, 22 + n);\n-            md.update(message);\n-            byte[] QWithChecksum = new byte[hashAlg_n + 2];\n-            md.digest(QWithChecksum, 0, hashAlg_n); \/\/ digest resets the MessageDigest object\n-            addCksm(QWithChecksum);\n-\n-            byte[] preCandidate = new byte[22 + (p - 1) * n + hashAlg_n];\n-            pKey.getI(preCandidate, 0);\n-            lmSig.getQArr(preCandidate, 16);\n-            preCandidate[20] = (byte) 0x80; \/\/ D_PBLC = 0x8080\n-            preCandidate[21] = (byte) 0x80;\n-\n-            byte[] preZi = hashBuf;\n-            pKey.getI(preZi, 0);\n-            lmSig.getQArr(preZi, 16);\n-\n-            int twoPowWMinus2 = twoPowWMinus1 - 1;\n-            for (int i = 0; i < p; i++) {\n-                int a = coef(QWithChecksum, i);\n-                if (a == twoPowWMinus1) {\n-                    lmOtSig.getY(i, preCandidate, 22 + i * n);\n-                } else {\n-                    preZi[20] = (byte) (i >> 8);\n-                    preZi[21] = (byte) i;\n-                    lmOtSig.getY(i, preZi, 23);\n-                }\n-\n-                for (int j = a; j < twoPowWMinus1; j++) {\n-                    preZi[22] = (byte) j;\n-                    if (j < twoPowWMinus2) {\n-                        digestFixedLengthPreprocessed(preZi, 64, preZi, 23, n);\n+            MessageDigest md;\n+            try {\n+                md = MessageDigest.getInstance(hashAlgName);\n+            } catch (NoSuchAlgorithmException e) { \/\/ This should not happen\n+                throw new ProviderException(\"Digest implementation not found\", e);\n+            }\n+            byte[] result = new byte[md.getDigestLength()];\n+            try {\n+                md.update(preQ, 0, 22 + n);\n+                md.update(message);\n+                byte[] QWithChecksum = new byte[hashAlg_n + 2];\n+                md.digest(QWithChecksum, 0, hashAlg_n); \/\/ digest resets the MessageDigest object\n+                addCksm(QWithChecksum);\n+\n+                byte[] preCandidate = new byte[22 + (p - 1) * n + hashAlg_n];\n+                pKey.getI(preCandidate, 0);\n+                lmSig.getQArr(preCandidate, 16);\n+                preCandidate[20] = (byte) 0x80; \/\/ D_PBLC = 0x8080\n+                preCandidate[21] = (byte) 0x80;\n+\n+                byte[] preZi = hashBuf;\n+                pKey.getI(preZi, 0);\n+                lmSig.getQArr(preZi, 16);\n+\n+                int twoPowWMinus2 = twoPowWMinus1 - 1;\n+                for (int i = 0; i < p; i++) {\n+                    int a = coef(QWithChecksum, i);\n+                    if (a == twoPowWMinus1) {\n+                        lmOtSig.getY(i, preCandidate, 22 + i * n);\n@@ -704,1 +595,12 @@\n-                        digestFixedLengthPreprocessed(preZi, 64, preCandidate, 22 + i * n, n);\n+                        preZi[20] = (byte) (i >> 8);\n+                        preZi[21] = (byte) i;\n+                        lmOtSig.getY(i, preZi, 23);\n+                    }\n+\n+                    for (int j = a; j < twoPowWMinus1; j++) {\n+                        preZi[22] = (byte) j;\n+                        if (j < twoPowWMinus2) {\n+                            digestFixedLengthPreprocessed(preZi, 64, preZi, 23, n);\n+                        } else {\n+                            digestFixedLengthPreprocessed(preZi, 64, preCandidate, 22 + i * n, n);\n+                        }\n@@ -707,2 +609,1 @@\n-            }\n-            md.update(preCandidate, 0, 22 + p * n);\n+                md.update(preCandidate, 0, 22 + p * n);\n@@ -710,1 +611,4 @@\n-            byte[] result = md.digest();\n+                result = md.digest();\n+            } catch (DigestException e) { \/\/ This should not happen\n+                throw new ProviderException(\"Digest failed\", e);\n+            }\n@@ -736,1 +640,1 @@\n-            throw new InvalidKeySpecException();\n+            throw new InvalidKeySpecException(\"Unrecognized KeySpec\");\n@@ -746,1 +650,4 @@\n-            if (key.getFormat().equals(\"X.509\") && key.getAlgorithm().equals(\"HSS\/LMS\")) {\n+            if (key.equals(null)) {\n+                throw new InvalidKeySpecException(\"key should not be null\");\n+            }\n+            if (key.getFormat().equals(\"X.509\") && key.getAlgorithm().equalsIgnoreCase(\"HSS\/LMS\")) {\n@@ -750,0 +657,1 @@\n+                throw new InvalidKeySpecException(\"keySpec is not an X509 one\");\n@@ -751,1 +659,1 @@\n-            throw new InvalidKeySpecException();\n+            throw new InvalidKeySpecException(\"Wrong key format or key algorithm\");\n@@ -774,1 +682,1 @@\n-    public static class HSSPublicKey extends X509Key implements Length {\n+    static class HSSPublicKey extends X509Key implements Length {\n@@ -784,1 +692,1 @@\n-                throw new InvalidKeyException(\"Invalid HSS public key\");\n+                throw new InvalidKeyException(\"HSS public key too short\");\n@@ -807,1 +715,1 @@\n-        HSSSignature(byte[] sigArr, int pubKeyL, String pubKeyHashAlg) throws SignatureException {\n+        HSSSignature(byte[] sigArr, HSSPublicKey pubKey) throws SignatureException {\n@@ -812,1 +720,1 @@\n-            if (Nspk + 1 != pubKeyL) {\n+            if (Nspk + 1 != pubKey.L) {\n@@ -823,2 +731,3 @@\n-                    if (!pubList[i].getDigestAlgorithm().equals(pubKeyHashAlg)) {\n-                        throw new SignatureException(\"Bad HSS signature\");\n+                    if (!pubList[i].getDigestAlgorithm().equals(pubKey.getDigestAlgorithm()) ||\n+                            (pubList[i].lmParams.m != pubKey.lmsPublicKey.lmParams.m)) {\n+                        throw new SignatureException(\"Digest algorithm in public key and Signature do not match\");\n@@ -829,2 +738,2 @@\n-            } catch (Exception E) {\n-                throw new SignatureException(\"Bad HSS signature\");\n+            } catch (InvalidKeyException e) {\n+                throw new SignatureException(\"Bad HSS signature\", e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/HSS.java","additions":99,"deletions":190,"binary":false,"changes":289,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,6 @@\n-public class RawKeySpec  implements KeySpec {\n-    final private byte[] keyArr;\n+\/**\n+ * This is a KeySpec that is used to specify a key by its byte array implementation.\n+ * It is intended to be used in testing algorithms where the algorithm specification describes the key in this form.\n+ *\/\n+public class RawKeySpec implements KeySpec {\n+    private final byte[] keyArr;\n@@ -33,1 +37,1 @@\n-     * The sole constructor\n+     * The sole constructor.\n@@ -41,1 +45,1 @@\n-     * Getter function\n+     * Getter function.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/RawKeySpec.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    \/\/ effective key length of the key in bits, e.g. 56 for a DES key\n+    \/\/ effective key length of the key, e.g. 56 for a DES key\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}