{"files":[{"patch":"@@ -87,74 +87,12 @@\n-        try {\n-            HSSSignature sig = new HSSSignature(signature, pubKey);\n-            LMSPublicKey lmsPubKey = pubKey.lmsPublicKey;\n-            boolean result = true;\n-            for (int i = 0; i < sig.Nspk; i++) {\n-                byte[] keyArr = sig.pubList[i].keyArray();\n-                result &= lmsVerify(lmsPubKey, sig.siglist[i], keyArr);\n-                lmsPubKey = sig.pubList[i];\n-            }\n-\n-            result &= lmsVerify(lmsPubKey, sig.siglist[sig.Nspk], messageStream.toByteArray());\n-            return result;\n-        } catch (Exception e) {\n-            throw new SignatureException(e);\n-        } finally {\n-            messageStream.reset();\n-        }\n-    }\n-\n-    protected boolean lmsVerify(LMSPublicKey lmsPublicKey, LMSignature sig, byte[] message) throws SignatureException {\n-\n-        if ((sig.sigOtsType != lmsPublicKey.otsType) || (sig.sigLmType != lmsPublicKey.type)) {\n-            return false;\n-        }\n-        LMOTSignature lmotSig = sig.lmotSig;\n-        LMOTSParams lmotsParams = lmotSig.lmotsParams;\n-        int q = sig.q;\n-        int m = lmsPublicKey.lmParams.m;\n-        int hashAlg_m = lmsPublicKey.lmParams.hashAlg_m;\n-        int n = lmotsParams.n;\n-\n-        try {\n-            byte[] otsPkCandidate = lmotsParams.lmotsPubKeyCandidate(sig, message, lmsPublicKey);\n-            int nodeNum = lmsPublicKey.lmParams.twoPowh + q;\n-            int tmp0MsgLen = 22 + n;\n-            int tmpLoopMsgLen = 22 + m + hashAlg_m;\n-            byte[] tmpMsg = new byte[Integer.max(tmp0MsgLen, tmpLoopMsgLen)];\n-            lmsPublicKey.getI(tmpMsg, 0);\n-            MessageDigest md = MessageDigest.getInstance(lmsPublicKey.lmParams.hashAlgStr);\n-            LMSUtils.intToFourBytes(nodeNum, tmpMsg, 16);\n-            tmpMsg[20] = (byte) 0x82; \/\/ D_LEAF = 0x8282\n-            tmpMsg[21] = (byte) 0x82;\n-            System.arraycopy(otsPkCandidate, 0, tmpMsg, 22, n);\n-            md.update(tmpMsg, 0, tmp0MsgLen);\n-            if ((nodeNum & 1) == 1) {\n-                md.digest(tmpMsg, 22 + m, hashAlg_m);\n-            } else {\n-                md.digest(tmpMsg, 22, hashAlg_m);\n-            }\n-            tmpMsg[20] = (byte) 0x83; \/\/ D_INTR = 0x8383\n-            tmpMsg[21] = (byte) 0x83;\n-\n-            int i = 0;\n-            while (nodeNum > 1) {\n-                LMSUtils.intToFourBytes(nodeNum \/ 2, tmpMsg, 16);\n-\n-                if ((nodeNum & 1) == 1) {\n-                    sig.getPath(i, tmpMsg, 22);\n-                } else {\n-                    sig.getPath(i, tmpMsg, 22 + m);\n-                }\n-                md.update(tmpMsg, 0, 22 + 2 * m);\n-                nodeNum \/= 2;\n-                if ((nodeNum & 1) == 1) {\n-                    md.digest(tmpMsg, 22 + m, hashAlg_m);\n-                } else {\n-                    md.digest(tmpMsg, 22, hashAlg_m);\n-                }\n-                i++;\n-            }\n-            return lmsPublicKey.isT1(tmpMsg, 22 + m);\n-        } catch (Exception e) {\n-            throw new SignatureException(e);\n-        }\n+        HSSSignature sig = new HSSSignature(signature, pubKey);\n+        LMSPublicKey lmsPubKey = pubKey.lmsPublicKey;\n+        boolean result = true;\n+        for (int i = 0; i < sig.Nspk; i++) {\n+            byte[] keyArr = sig.pubList[i].keyArray();\n+            result &= LMSUtils.lmsVerify(lmsPubKey, sig.siglist[i], keyArr);\n+            lmsPubKey = sig.pubList[i];\n+        }\n+\n+        result &= LMSUtils.lmsVerify(lmsPubKey, sig.siglist[sig.Nspk], messageStream.toByteArray());\n+        messageStream.reset();\n+        return result;\n@@ -168,1 +106,1 @@\n-        final transient LMParams lmParams;\n+        final transient LMSParams lmsParams;\n@@ -178,1 +116,1 @@\n-            if (inLen < 8)\n+            if (inLen < 8) {\n@@ -180,0 +118,1 @@\n+            }\n@@ -185,1 +124,1 @@\n-                lmParams = new LMParams(type);\n+                lmsParams = LMSParams.of(type);\n@@ -191,1 +130,1 @@\n-            int m = lmParams.m;\n+            int m = lmsParams.m;\n@@ -193,2 +132,1 @@\n-                    !lmotsParams.hashAlgName.equals(lmParams.hashAlgStr) ||\n-                    (lmParams.m != lmotsParams.n)) {\n+                    !lmsParams.hasSameHash(lmotsParams)) {\n@@ -202,1 +140,1 @@\n-        public void getI(byte[] arr, int pos) {\n+        void getI(byte[] arr, int pos) {\n@@ -206,2 +144,2 @@\n-        public boolean isT1(byte[] arr, int pos) {\n-            int m = lmParams.m;\n+        boolean isT1(byte[] arr, int pos) {\n+            int m = lmsParams.m;\n@@ -215,1 +153,1 @@\n-        public byte[] keyArray() {\n+        byte[] keyArray() {\n@@ -220,1 +158,1 @@\n-            System.arraycopy(T1, 0, result, 24, lmParams.m);\n+            System.arraycopy(T1, 0, result, 24, lmsParams.m);\n@@ -224,6 +162,2 @@\n-        public int keyArrayLength() {\n-            return 24 + lmParams.m;\n-        }\n-\n-        public String getDigestAlgorithm() {\n-            return lmParams.hashAlgStr;\n+        int keyArrayLength() {\n+            return 24 + lmsParams.m;\n@@ -234,41 +168,14 @@\n-        public final static int LMS_RESERVED = 0;\n-        public final static int LMS_SHA256_M32_H5 = 5;\n-        public final static int LMS_SHA256_M32_H10 = 6;\n-        public final static int LMS_SHA256_M32_H15 = 7;\n-        public final static int LMS_SHA256_M32_H20 = 8;\n-        public final static int LMS_SHA256_M32_H25 = 9;\n-        public final static int LMS_SHA256_M24_H5 = 10;\n-        public final static int LMS_SHA256_M24_H10 = 11;\n-        public final static int LMS_SHA256_M24_H15 = 12;\n-        public final static int LMS_SHA256_M24_H20 = 13;\n-        public final static int LMS_SHA256_M24_H25 = 14;\n-        public final static int LMS_SHAKE_M32_H5 = 15;\n-        public final static int LMS_SHAKE_M32_H10 = 16;\n-        public final static int LMS_SHAKE_M32_H15 = 17;\n-        public final static int LMS_SHAKE_M32_H20 = 18;\n-        public final static int LMS_SHAKE_M32_H25 = 19;\n-        public final static int LMS_SHAKE_M24_H5 = 20;\n-        public final static int LMS_SHAKE_M24_H10 = 21;\n-        public final static int LMS_SHAKE_M24_H15 = 22;\n-        public final static int LMS_SHAKE_M24_H20 = 23;\n-        public final static int LMS_SHAKE_M24_H25 = 24;\n-\n-        public final static int LMOTS_RESERVED = 0;\n-        public final static int LMOTS_SHA256_N32_W1 = 1;\n-        public final static int LMOTS_SHA256_N32_W2 = 2;\n-        public final static int LMOTS_SHA256_N32_W4 = 3;\n-        public final static int LMOTS_SHA256_N32_W8 = 4;\n-        public final static int LMOTS_SHA256_N24_W1 = 5;\n-        public final static int LMOTS_SHA256_N24_W2 = 6;\n-        public final static int LMOTS_SHA256_N24_W4 = 7;\n-        public final static int LMOTS_SHA256_N24_W8 = 8;\n-        public final static int LMOTS_SHAKE_N32_W1 = 9;\n-        public final static int LMOTS_SHAKE_N32_W2 = 10;\n-        public final static int LMOTS_SHAKE_N32_W4 = 11;\n-        public final static int LMOTS_SHAKE_N32_W8 = 12;\n-        public final static int LMOTS_SHAKE_N24_W1 = 13;\n-        public final static int LMOTS_SHAKE_N24_W2 = 14;\n-        public final static int LMOTS_SHAKE_N24_W4 = 15;\n-        public final static int LMOTS_SHAKE_N24_W8 = 16;\n-\n-        public static int fourBytesToInt(byte[] arr, int i) {\n+        final static int LMS_RESERVED = 0;\n+        final static int LMS_SHA256_M32_H5 = 5;\n+        final static int LMS_SHA256_M32_H10 = 6;\n+        final static int LMS_SHA256_M32_H15 = 7;\n+        final static int LMS_SHA256_M32_H20 = 8;\n+        final static int LMS_SHA256_M32_H25 = 9;\n+\n+        final static int LMOTS_RESERVED = 0;\n+        final static int LMOTS_SHA256_N32_W1 = 1;\n+        final static int LMOTS_SHA256_N32_W2 = 2;\n+        final static int LMOTS_SHA256_N32_W4 = 3;\n+        final static int LMOTS_SHA256_N32_W8 = 4;\n+\n+        static int fourBytesToInt(byte[] arr, int i) {\n@@ -281,1 +188,1 @@\n-        public static void intToFourBytes(int i, byte[] arr, int pos) {\n+        static void intToFourBytes(int i, byte[] arr, int pos) {\n@@ -287,0 +194,56 @@\n+        static boolean lmsVerify(LMSPublicKey lmsPublicKey, LMSignature sig, byte[] message) throws SignatureException {\n+\n+            if ((sig.sigOtsType != lmsPublicKey.otsType) || (sig.sigLmType != lmsPublicKey.type)) {\n+                return false;\n+            }\n+            LMOTSignature lmotSig = sig.lmotSig;\n+            LMOTSParams lmotsParams = lmotSig.lmotsParams;\n+            int q = sig.q;\n+            int m = lmsPublicKey.lmsParams.m;\n+            int hashAlg_m = lmsPublicKey.lmsParams.hashAlg_m;\n+            int n = lmotsParams.n;\n+\n+            try {\n+                byte[] otsPkCandidate = lmotsParams.lmotsPubKeyCandidate(sig, message, lmsPublicKey);\n+                int nodeNum = lmsPublicKey.lmsParams.twoPowh + q;\n+                int tmp0MsgLen = 22 + n;\n+                int tmpLoopMsgLen = 22 + m + hashAlg_m;\n+                byte[] tmpMsg = new byte[Integer.max(tmp0MsgLen, tmpLoopMsgLen)];\n+                lmsPublicKey.getI(tmpMsg, 0);\n+                MessageDigest md = MessageDigest.getInstance(lmsPublicKey.lmsParams.hashAlgStr);\n+                LMSUtils.intToFourBytes(nodeNum, tmpMsg, 16);\n+                tmpMsg[20] = (byte) 0x82; \/\/ D_LEAF = 0x8282\n+                tmpMsg[21] = (byte) 0x82;\n+                System.arraycopy(otsPkCandidate, 0, tmpMsg, 22, n);\n+                md.update(tmpMsg, 0, tmp0MsgLen);\n+                if ((nodeNum & 1) == 1) {\n+                    md.digest(tmpMsg, 22 + m, hashAlg_m);\n+                } else {\n+                    md.digest(tmpMsg, 22, hashAlg_m);\n+                }\n+                tmpMsg[20] = (byte) 0x83; \/\/ D_INTR = 0x8383\n+                tmpMsg[21] = (byte) 0x83;\n+\n+                int i = 0;\n+                while (nodeNum > 1) {\n+                    LMSUtils.intToFourBytes(nodeNum \/ 2, tmpMsg, 16);\n+\n+                    if ((nodeNum & 1) == 1) {\n+                        sig.getPath(i, tmpMsg, 22);\n+                    } else {\n+                        sig.getPath(i, tmpMsg, 22 + m);\n+                    }\n+                    md.update(tmpMsg, 0, 22 + 2 * m);\n+                    nodeNum \/= 2;\n+                    if ((nodeNum & 1) == 1) {\n+                        md.digest(tmpMsg, 22 + m, hashAlg_m);\n+                    } else {\n+                        md.digest(tmpMsg, 22, hashAlg_m);\n+                    }\n+                    i++;\n+                }\n+                return lmsPublicKey.isT1(tmpMsg, 22 + m);\n+            } catch (NoSuchAlgorithmException | DigestException e) {\n+                throw new ProviderException(e);\n+            }\n+        }\n@@ -299,1 +262,1 @@\n-            if (inLen < 4)\n+            if (inLen < 4) {\n@@ -301,0 +264,1 @@\n+            }\n@@ -305,1 +269,1 @@\n-            if (inLen != (4 + n * (p + 1)))\n+            if (inLen != (4 + n * (p + 1))) {\n@@ -307,0 +271,1 @@\n+            }\n@@ -316,1 +281,1 @@\n-        public void getC(byte[] arr, int pos) {\n+        void getC(byte[] arr, int pos) {\n@@ -320,1 +285,1 @@\n-        public void getY(int i, byte[] arr, int pos) {\n+        void getY(int i, byte[] arr, int pos) {\n@@ -325,1 +290,1 @@\n-    static class LMParams {\n+    static class LMSParams {\n@@ -333,1 +298,1 @@\n-        LMParams(int type) {\n+        LMSParams(int type, int m, int h, String hashAlgStr) {\n@@ -335,0 +300,10 @@\n+            this.m = m;\n+            this.h = h;\n+            this.hashAlgStr = hashAlgStr;\n+            twoPowh = 1 << h;\n+        }\n+\n+        static LMSParams of(int type) {\n+            int m;\n+            int h;\n+            String hashAlgStr;\n@@ -365,1 +340,1 @@\n-            twoPowh = 1 << h;\n+            return new LMSParams(type, m, h, hashAlgStr);\n@@ -368,0 +343,7 @@\n+        boolean hasSameHash(LMSParams other) {\n+            return (other.hashAlgStr.equals(hashAlgStr)) && (other.m == m);\n+        }\n+\n+        boolean hasSameHash(LMOTSParams lmotsParams) {\n+            return (lmotsParams.hashAlgName.equals(hashAlgStr)) && (lmotsParams.n == m);\n+        }\n@@ -383,1 +365,1 @@\n-        public LMSignature(byte[] sigArray, int offset, boolean checkExactLen) throws SignatureException {\n+        LMSignature(byte[] sigArray, int offset, boolean checkExactLen) throws SignatureException {\n@@ -385,1 +367,1 @@\n-            if (inLen < 8)\n+            if (inLen < 8) {\n@@ -387,0 +369,1 @@\n+            }\n@@ -401,1 +384,1 @@\n-            if (inLen < (12 + n * (p + 1)))\n+            if (inLen < (12 + n * (p + 1))) {\n@@ -403,0 +386,1 @@\n+            }\n@@ -411,1 +395,1 @@\n-            LMParams lmParams;\n+            LMSParams lmsParams;\n@@ -413,1 +397,1 @@\n-                lmParams = new LMParams(sigLmType);\n+                lmsParams = LMSParams.of(sigLmType);\n@@ -417,2 +401,2 @@\n-            m = lmParams.m;\n-            h = lmParams.h;\n+            m = lmsParams.m;\n+            h = lmsParams.h;\n@@ -421,1 +405,1 @@\n-            if ((q >= (1 << h)) || (inLen < sigArrLen) || (checkExactLen && (inLen != sigArrLen)))\n+            if ((q >= (1 << h)) || (inLen < sigArrLen) || (checkExactLen && (inLen != sigArrLen))) {\n@@ -423,0 +407,1 @@\n+            }\n@@ -438,1 +423,1 @@\n-        public void getQArr(byte[] arr, int pos) {\n+        void getQArr(byte[] arr, int pos) {\n@@ -442,1 +427,1 @@\n-        public void getPath(int i, byte[] arr, int pos) {\n+        void getPath(int i, byte[] arr, int pos) {\n@@ -463,13 +448,0 @@\n-\n-        \/\/ Precomputed block for SHA256 when the message size is 47 bytes (i.e. when SHA256-192 is used)\n-        final byte[] hashbufSha256_24 = {\n-                0, 0, 0, 0, 0, 0, 0, 0,\n-                0, 0, 0, 0, 0, 0, 0, 0,\n-                0, 0, 0, 0, 0, 0, 0, 0,\n-                0, 0, 0, 0, 0, 0, 0, 0,\n-                0, 0, 0, 0, 0, 0, 0, 0,\n-                0, 0, 0, 0, 0, 0, 0, (byte) 0x80,\n-                0, 0, 0, 0, 0, 0, 0, 0,\n-                0, 0, 0, 0, 0, 0, 1, 0x78\n-        };\n-\n@@ -477,1 +449,1 @@\n-        final byte[] hashbufSha256_32 = {\n+        final static byte[] hashbufSha256_32 = {\n@@ -498,6 +470,2 @@\n-            if (this.n == 24) {\n-                hashBuf = hashbufSha256_24;\n-            } else {\n-                hashBuf = hashbufSha256_32;\n-            }\n-            if (Objects.equals(hashAlgName, \"SHA-256\"))\n+            hashBuf = hashbufSha256_32;\n+            if (Objects.equals(hashAlgName, \"SHA-256\")) {\n@@ -505,1 +473,1 @@\n-            else\n+            } else {\n@@ -507,0 +475,1 @@\n+            }\n@@ -530,1 +499,1 @@\n-        public int coef(byte[] S, int i) {\n+        int coef(byte[] S, int i) {\n@@ -546,1 +515,1 @@\n-        public void digestFixedLengthPreprocessed(\n+        void digestFixedLengthPreprocessed(\n@@ -552,1 +521,1 @@\n-        public byte[] lmotsPubKeyCandidate(LMSignature lmSig, byte[] message, LMSPublicKey pKey)\n+        byte[] lmotsPubKeyCandidate(LMSignature lmSig, byte[] message, LMSPublicKey pKey)\n@@ -585,1 +554,1 @@\n-                byte[] preZi = hashBuf;\n+                byte[] preZi = hashBuf.clone();\n@@ -650,1 +619,1 @@\n-            if (key.equals(null)) {\n+            if (key == null) {\n@@ -664,0 +633,3 @@\n+            if (key == null) {\n+                throw  new InvalidKeyException(\"key cannot be null\");\n+            }\n@@ -675,2 +647,2 @@\n-            } catch (Exception e) {\n-                throw new InvalidKeyException();\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(e);\n@@ -691,1 +663,1 @@\n-            if (inLen < 4)\n+            if (inLen < 4) {\n@@ -693,0 +665,1 @@\n+            }\n@@ -699,4 +672,0 @@\n-        public String getDigestAlgorithm() {\n-            return lmsPublicKey.getDigestAlgorithm();\n-        }\n-\n@@ -731,2 +700,1 @@\n-                    if (!pubList[i].getDigestAlgorithm().equals(pubKey.getDigestAlgorithm()) ||\n-                            (pubList[i].lmParams.m != pubKey.lmsPublicKey.lmParams.m)) {\n+                    if (!pubKey.lmsPublicKey.lmsParams.hasSameHash(pubList[i].lmsParams)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/HSS.java","additions":153,"deletions":185,"binary":false,"changes":338,"status":"modified"}]}