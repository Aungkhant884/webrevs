{"files":[{"patch":"@@ -0,0 +1,830 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+import sun.security.x509.X509Key;\n+\n+import java.io.*;\n+import java.security.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class HSS extends SignatureSpi {\n+    private HSSPublicKey pubKey;\n+    private ByteArrayOutputStream messageStream;\n+\n+    @Deprecated\n+    protected void engineSetParameter(String param, Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Deprecated\n+    protected AlgorithmParameters engineGetParameter(String param) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException {\n+        throw new InvalidKeyException(\"Signing is not supported\");\n+    }\n+\n+    protected byte[] engineSign() throws SignatureException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException {\n+        if (!(publicKey instanceof HSSPublicKey pub)) {\n+            throw new InvalidKeyException(\"Not an HSS public key: \");\n+        }\n+        pubKey = pub;\n+        messageStream = new ByteArrayOutputStream();\n+    }\n+\n+    protected void engineUpdate(byte data) {\n+        messageStream.write(data);\n+    }\n+\n+    protected void engineUpdate(byte[] data, int off, int len) {\n+        messageStream.write(data, off, len);\n+    }\n+\n+    protected boolean engineVerify(byte[] signature) throws SignatureException {\n+        try {\n+            HSSSignature sig = new HSSSignature(signature, pubKey.L, pubKey.getDigestAlgorithm());\n+            LMSPublicKey lmsPubKey = pubKey.lmsPublicKey;\n+            boolean result = true;\n+            for (int i = 0; i < sig.Nspk; i++) {\n+                byte[] keyArr = sig.pubList[i].keyArray();\n+                result &= lmsVerify(lmsPubKey, sig.siglist[i], keyArr);\n+                lmsPubKey = sig.pubList[i];\n+            }\n+\n+            result &= lmsVerify(lmsPubKey, sig.siglist[sig.Nspk], messageStream.toByteArray());\n+            messageStream.reset();\n+            return result;\n+        } catch (Exception e) {\n+            messageStream.reset();\n+            return false;\n+        }\n+    }\n+\n+    protected boolean lmsVerify(LMSPublicKey lmsPublicKey, LMSignature sig, byte[] message) throws SignatureException {\n+\n+        if ((sig.sigOtsType != lmsPublicKey.otsType) || (sig.sigLmType != lmsPublicKey.type)) {\n+            return false;\n+        }\n+        LMOTSignature lmotSig = sig.lmotSig;\n+        LMOTSParams lmotsParams = lmotSig.lmotsParams;\n+        int q = sig.q;\n+        int m = lmsPublicKey.lmParams.m;\n+        int hashAlg_m = lmsPublicKey.lmParams.hashAlg_m;\n+        int n = lmotsParams.n;\n+\n+        try {\n+            byte[] otsPkCandidate = lmotsParams.lmotsPubKeyCandidate(sig, message, lmsPublicKey);\n+            int nodeNum = lmsPublicKey.lmParams.twoPowh + q;\n+            int tmp0MsgLen = 22 + n;\n+            int tmpLoopMsgLen = 22 + m + hashAlg_m;\n+            byte[] tmpMsg = new byte[Integer.max(tmp0MsgLen, tmpLoopMsgLen)];\n+            lmsPublicKey.getI(tmpMsg, 0);\n+            MessageDigest md = MessageDigest.getInstance(lmsPublicKey.lmParams.hashAlgStr);\n+            LMSUtils.intToFourBytes(nodeNum, tmpMsg, 16);\n+            tmpMsg[20] = (byte) 0x82; \/\/ D_LEAF = 0x8282\n+            tmpMsg[21] = (byte) 0x82;\n+            System.arraycopy(otsPkCandidate, 0, tmpMsg, 22, n);\n+            md.update(tmpMsg, 0, tmp0MsgLen);\n+            if ((nodeNum & 1) == 1) {\n+                md.digest(tmpMsg, 22 + m, hashAlg_m);\n+            } else {\n+                md.digest(tmpMsg, 22, hashAlg_m);\n+            }\n+            tmpMsg[20] = (byte) 0x83; \/\/ D_INTR = 0x8383\n+            tmpMsg[21] = (byte) 0x83;\n+\n+            int i = 0;\n+            while (nodeNum > 1) {\n+                LMSUtils.intToFourBytes(nodeNum \/ 2, tmpMsg, 16);\n+\n+                if ((nodeNum & 1) == 1) {\n+                    sig.getPath(i, tmpMsg, 22);\n+                } else {\n+                    sig.getPath(i, tmpMsg, 22 + m);\n+                }\n+                md.update(tmpMsg, 0, 22 + 2 * m);\n+                nodeNum \/= 2;\n+                if ((nodeNum & 1) == 1) {\n+                    md.digest(tmpMsg, 22 + m, hashAlg_m);\n+                } else {\n+                    md.digest(tmpMsg, 22, hashAlg_m);\n+                }\n+                i++;\n+            }\n+            return lmsPublicKey.isT1(tmpMsg, 22 + m);\n+        } catch (Exception e) {\n+            throw new SignatureException(e);\n+        }\n+    }\n+\n+    static class LMSPublicKey implements Serializable {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 21L;\n+        final int type;\n+        final int otsType;\n+        final transient LMParams lmParams;\n+        private final byte[] I;\n+        private final byte[] T1;\n+\n+        public static LMSPublicKey of(byte[] keyArray) throws InvalidKeyException {\n+            return new LMSPublicKey(keyArray, 0, true);\n+        }\n+\n+        public LMSPublicKey(byte[] keyArray, int offset, boolean checkExactLength) throws InvalidKeyException {\n+            int inLen = keyArray.length - offset;\n+            if (inLen < 8)\n+                throw new InvalidKeyException(\"Invalid LMS public key\");\n+            type = LMSUtils.fourBytesToInt(keyArray, offset);\n+            otsType = LMSUtils.fourBytesToInt(keyArray, offset + 4);\n+            LMOTSParams lmotsParams;\n+\n+            try {\n+                lmParams = new LMParams(type);\n+                lmotsParams = LMOTSParams.of(otsType);\n+            } catch (IllegalArgumentException e) {\n+                throw new InvalidKeyException(e.getMessage());\n+            }\n+\n+            int m = lmParams.m;\n+            if ((inLen < (24 + m)) || (checkExactLength && (inLen != (24 + m))) ||\n+                    !lmotsParams.hashAlgName.equals(lmParams.hashAlgStr) ||\n+                    (lmParams.m != lmotsParams.n)) {\n+                throw new InvalidKeyException(\"Invalid LMS public Key\");\n+            }\n+\n+            I = Arrays.copyOfRange(keyArray, offset + 8, offset + 8 + 16);\n+            T1 = Arrays.copyOfRange(keyArray, offset + 24, offset + 24 + m);\n+        }\n+\n+        public void getI(byte[] arr, int pos) {\n+            System.arraycopy(I, 0, arr, pos, 16);\n+        }\n+\n+        public boolean isT1(byte[] arr, int pos) {\n+            int m = lmParams.m;\n+            int diff = 0;\n+            for (int i = 0; i < m; i++) {\n+                diff |= (T1[i] ^ arr[pos + i]);\n+            }\n+            return (diff == 0);\n+        }\n+\n+        public byte[] keyArray() {\n+            byte[] result = new byte[keyArrayLength()];\n+            LMSUtils.intToFourBytes(type, result, 0);\n+            LMSUtils.intToFourBytes(otsType, result, 4);\n+            System.arraycopy(I, 0, result, 8, 16);\n+            System.arraycopy(T1, 0, result, 24, lmParams.m);\n+            return result;\n+        }\n+\n+        public int keyArrayLength() {\n+            return 24 + lmParams.m;\n+        }\n+\n+        public String getDigestAlgorithm() {\n+            return lmParams.hashAlgStr;\n+        }\n+    }\n+\n+    static class LMSUtils {\n+        public final static int LMS_RESERVED = 0;\n+        public final static int LMS_SHA256_M32_H5 = 5;\n+        public final static int LMS_SHA256_M32_H10 = 6;\n+        public final static int LMS_SHA256_M32_H15 = 7;\n+        public final static int LMS_SHA256_M32_H20 = 8;\n+        public final static int LMS_SHA256_M32_H25 = 9;\n+        public final static int LMS_SHA256_M24_H5 = 10;\n+        public final static int LMS_SHA256_M24_H10 = 11;\n+        public final static int LMS_SHA256_M24_H15 = 12;\n+        public final static int LMS_SHA256_M24_H20 = 13;\n+        public final static int LMS_SHA256_M24_H25 = 14;\n+        public final static int LMS_SHAKE_M32_H5 = 15;\n+        public final static int LMS_SHAKE_M32_H10 = 16;\n+        public final static int LMS_SHAKE_M32_H15 = 17;\n+        public final static int LMS_SHAKE_M32_H20 = 18;\n+        public final static int LMS_SHAKE_M32_H25 = 19;\n+        public final static int LMS_SHAKE_M24_H5 = 20;\n+        public final static int LMS_SHAKE_M24_H10 = 21;\n+        public final static int LMS_SHAKE_M24_H15 = 22;\n+        public final static int LMS_SHAKE_M24_H20 = 23;\n+        public final static int LMS_SHAKE_M24_H25 = 24;\n+\n+        public final static int LMOTS_RESERVED = 0;\n+        public final static int LMOTS_SHA256_N32_W1 = 1;\n+        public final static int LMOTS_SHA256_N32_W2 = 2;\n+        public final static int LMOTS_SHA256_N32_W4 = 3;\n+        public final static int LMOTS_SHA256_N32_W8 = 4;\n+        public final static int LMOTS_SHA256_N24_W1 = 5;\n+        public final static int LMOTS_SHA256_N24_W2 = 6;\n+        public final static int LMOTS_SHA256_N24_W4 = 7;\n+        public final static int LMOTS_SHA256_N24_W8 = 8;\n+        public final static int LMOTS_SHAKE_N32_W1 = 9;\n+        public final static int LMOTS_SHAKE_N32_W2 = 10;\n+        public final static int LMOTS_SHAKE_N32_W4 = 11;\n+        public final static int LMOTS_SHAKE_N32_W8 = 12;\n+        public final static int LMOTS_SHAKE_N24_W1 = 13;\n+        public final static int LMOTS_SHAKE_N24_W2 = 14;\n+        public final static int LMOTS_SHAKE_N24_W4 = 15;\n+        public final static int LMOTS_SHAKE_N24_W8 = 16;\n+\n+        public static int fourBytesToInt(byte[] arr, int i) {\n+            return ((arr[i] & 0xff) << 24) |\n+                    ((arr[i + 1] & 0xff) << 16) |\n+                    ((arr[i + 2] & 0xff) << 8) |\n+                    (arr[i + 3] & 0xff);\n+        }\n+\n+        public static void intToFourBytes(int i, byte[] arr, int pos) {\n+            arr[pos] = (byte) (i >> 24);\n+            arr[pos + 1] = (byte) (i >> 16);\n+            arr[pos + 2] = (byte) (i >> 8);\n+            arr[pos + 3] = (byte) i;\n+        }\n+    }\n+\n+    static class LMOTSignature {\n+        final int otSigType;\n+        final LMOTSParams lmotsParams;\n+        final int n;\n+        final int p;\n+        private final byte[] C;\n+        private final byte[][] y;\n+\n+        LMOTSignature(byte[] sigArray, LMOTSParams lmotsParams) throws InvalidParameterException {\n+            int inLen = sigArray.length;\n+            if (inLen < 4)\n+                throw new InvalidParameterException(\"Invalid LMS signature\");\n+            otSigType = lmotsParams.lmotSigType;\n+            this.lmotsParams = lmotsParams;\n+            n = lmotsParams.n;\n+            p = lmotsParams.p;\n+            if (inLen != (4 + n * (p + 1)))\n+                throw new InvalidParameterException(\"Invalid LMS signature\");\n+            C = Arrays.copyOfRange(sigArray, 4, 4 + n);\n+            int pStart = 4 + n;\n+            y = new byte[p][n];\n+            for (int i = 0; i < p; i++) {\n+                y[i] = Arrays.copyOfRange(sigArray, pStart, pStart + n);\n+                pStart += n;\n+            }\n+        }\n+\n+        public void getC(byte[] arr, int pos) {\n+            System.arraycopy(C, 0, arr, pos, n);\n+        }\n+\n+        public void getY(int i, byte[] arr, int pos) {\n+            System.arraycopy(y[i], 0, arr, pos, n);\n+        }\n+    }\n+\n+    static class LMParams {\n+        final int type;\n+        final int m; \/\/ the number of bytes used from the hash output\n+        final int hashAlg_m = 32; \/\/ output length of the hash function used for the LMS tree\n+        final int h; \/\/ height of the LMS tree\n+        final int twoPowh;\n+        final String hashAlgStr;\n+\n+        LMParams(int type) {\n+            this.type = type;\n+            switch (type) {\n+                case LMSUtils.LMS_SHA256_M32_H5:\n+                    m = 32;\n+                    h = 5;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H10:\n+                    m = 32;\n+                    h = 10;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H15:\n+                    m = 32;\n+                    h = 15;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H20:\n+                    m = 32;\n+                    h = 20;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H25:\n+                    m = 32;\n+                    h = 25;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+\n+\/*\n+                case LMSUtils.LMS_SHAKE_M32_H5:\n+                    m = 32;\n+                    h = 5;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+                case LMSUtils.LMS_SHAKE_M32_H10:\n+                    m = 32;\n+                    h = 10;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+                case LMSUtils.LMS_SHAKE_M32_H15:\n+                    m = 32;\n+                    h = 15;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+                case LMSUtils.LMS_SHAKE_M32_H20:\n+                    m = 32;\n+                    h = 20;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+                case LMSUtils.LMS_SHAKE_M32_H25:\n+                    m = 32;\n+                    h = 25;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+\n+                case LMSUtils.LMS_SHA256_M24_H5:\n+                    m = 24;\n+                    h = 5;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M24_H10:\n+                    m = 24;\n+                    h = 10;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M24_H15:\n+                    m = 24;\n+                    h = 15;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M24_H20:\n+                    m = 24;\n+                    h = 20;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M24_H25:\n+                    m = 24;\n+                    h = 25;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+\n+                case LMSUtils.LMS_SHAKE_M24_H5:\n+                    m = 24;\n+                    h = 5;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+                case LMSUtils.LMS_SHAKE_M24_H10:\n+                    m = 24;\n+                    h = 10;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+                case LMSUtils.LMS_SHAKE_M24_H15:\n+                    m = 24;\n+                    h = 15;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+                case LMSUtils.LMS_SHAKE_M24_H20:\n+                    m = 24;\n+                    h = 20;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+                case LMSUtils.LMS_SHAKE_M24_H25:\n+                    m = 24;\n+                    h = 25;\n+                    hashAlgStr = \"SHAKE256\";\n+                    break;\n+ *\/\n+\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported or bad LMS type\");\n+            }\n+\n+            twoPowh = 1 << h;\n+        }\n+\n+    }\n+\n+    static class LMSignature {\n+        final int sigLmType;\n+        final int sigOtsType;\n+        final private byte[] qArr;\n+        final int q; \/\/ serial number of the LMS key being used for this signature\n+        final LMOTSignature lmotSig;\n+        final int n; \/\/ output length of the hash function used in the one time signature\n+        final int p; \/\/ number of hash chains in the signature\n+        final int m; \/\/ output length of the hash fubction used in the Merkle tree\n+        final int h; \/\/ height of the Merkle tree\n+        final byte[][] path;\n+        final byte[] sigArr;\n+\n+        public LMSignature(byte[] sigArray, int offset, boolean checkExactLen) throws InvalidParameterException {\n+            int inLen = sigArray.length - offset;\n+            if (inLen < 8)\n+                throw new InvalidParameterException(\"Invalid LMS signature\");\n+\n+            q = LMSUtils.fourBytesToInt(sigArray, offset);\n+            qArr = Arrays.copyOfRange(sigArray, offset, offset + 4);\n+            sigOtsType = LMSUtils.fourBytesToInt(sigArray, offset + 4);\n+            LMOTSParams lmotsParams = LMOTSParams.of(sigOtsType);\n+\n+            n = lmotsParams.n;\n+            p = lmotsParams.p;\n+\n+            if (inLen < (12 + n * (p + 1)))\n+                throw new InvalidParameterException(\"Invalid LMS signature\");\n+\n+            int otsSigLen = 4 + n * (p + 1);\n+            byte[] otSigArr = Arrays.copyOfRange(sigArray, offset + 4, offset + 4 + otsSigLen);\n+            lmotSig = new LMOTSignature(otSigArr, lmotsParams);\n+\n+            int sigTypePos = offset + 4 + otsSigLen;\n+            sigLmType = LMSUtils.fourBytesToInt(sigArray, sigTypePos);\n+\n+            LMParams lmParams = new LMParams(sigLmType);\n+            m = lmParams.m;\n+            h = lmParams.h;\n+\n+            int sigArrLen = (12 + n * (p + 1) + m * h);\n+            if ((q >= (1 << h)) || (inLen < sigArrLen) || (checkExactLen && (inLen != sigArrLen)))\n+                throw new InvalidParameterException(\"Invalid LMS signature\");\n+\n+            sigArr = Arrays.copyOfRange(sigArray, offset, offset + sigArrLen);\n+\n+            int pStart = offset + 12 + n * (p + 1);\n+            path = new byte[h][m];\n+            for (int i = 0; i < h; i++) {\n+                path[i] = Arrays.copyOfRange(sigArray, pStart, pStart + m);\n+                pStart += m;\n+            }\n+        }\n+\n+        int sigArrayLength() {\n+            return 12 + n * (p + 1) + m * h;\n+        }\n+\n+        public void getQArr(byte[] arr, int pos) {\n+            System.arraycopy(qArr, 0, arr, pos, 4);\n+        }\n+\n+        public void getPath(int i, byte[] arr, int pos) {\n+            System.arraycopy(path[i], 0, arr, pos, m);\n+        }\n+    }\n+\n+    static class LMOTSParams {\n+        final int lmotSigType;\n+        final int n; \/\/ the number of bytes used from the hash output\n+        final int hashAlg_n = 32; \/\/ the output length of the hash function\n+        final int w;\n+        final int twoPowWMinus1;\n+        final int ls;\n+        final int p;\n+        final String hashAlgName;\n+\n+        \/\/ The buffer for the lmotsPubKeyCandidate() function. In that function this buffer is fed into the\n+        \/\/ hash function as input to the implDigestFixedLengthPreprocessed() function (which is\n+        \/\/ basically an allocation and padding computation free digest() function, so we can avoid the\n+        \/\/ update()-digest() sequence) which is parametrized so that the digest output is copied back into this buffer.\n+        \/\/ This way, we avoid memory allocations and some computations that would have to be done otherwise.\n+        final byte[] hashBuf;\n+\n+        \/\/ Precomputed block for SHA256 when the message size is 47 bytes (i.e. when SHA256-192 is used)\n+        final byte[] hashbufSha256_24 = {\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, (byte) 0x80,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 1, 0x78\n+        };\n+\n+        \/\/ Precomputed block for SHA256 when the message size is 55 bytes (i.e. when SHA256 is used)\n+        final byte[] hashbufSha256_32 = {\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, (byte) 0x80,\n+                0, 0, 0, 0, 0, 0, 1, (byte) 0xb8\n+        };\n+\n+        final SHA2.SHA256 sha256Fix;\n+\n+        private LMOTSParams(int lmotSigType, int hLen, int w, int ls, int p, String hashAlgName) {\n+            this.lmotSigType = lmotSigType;\n+            this.n = hLen;\n+            this.w = w;\n+            this.ls = ls;\n+            this.p = p;\n+            twoPowWMinus1 = (1 << w) - 1;\n+            this.hashAlgName = hashAlgName;\n+            if (this.n == 24) {\n+                hashBuf = hashbufSha256_24;\n+            } else {\n+                hashBuf = hashbufSha256_32;\n+            }\n+            if (Objects.equals(hashAlgName, \"SHA-256\"))\n+                sha256Fix = new SHA2.SHA256();\n+            else\n+                sha256Fix = null;\n+        }\n+\n+        static LMOTSParams of(int lmotsType) {\n+            LMOTSParams params;\n+            switch (lmotsType) {\n+                case LMSUtils.LMOTS_SHA256_N32_W1:\n+                    params = new LMOTSParams(lmotsType, 32, 1, 7, 265, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N32_W2:\n+                    params = new LMOTSParams(lmotsType, 32, 2, 6, 133, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N32_W4:\n+                    params = new LMOTSParams(lmotsType, 32, 4, 4, 67, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N32_W8:\n+                    params = new LMOTSParams(lmotsType, 32, 8, 0, 34, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N24_W1:\n+                    params = new LMOTSParams(lmotsType, 24, 1, 8, 200, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N24_W2:\n+                    params = new LMOTSParams(lmotsType, 24, 2, 6, 101, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N24_W4:\n+                    params = new LMOTSParams(lmotsType, 32, 4, 4, 51, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N24_W8:\n+                    params = new LMOTSParams(lmotsType, 24, 8, 0, 26, \"SHA-256\");\n+                    break;\n+\n+\/*\n+                case LMSUtils.LMOTS_SHAKE_N32_W1:\n+                    params = new LMOTSParams(lmotsType, 32, 1, 7, 265, \"SHAKE256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHAKE_N32_W2:\n+                    params = new LMOTSParams(lmotsType, 32, 2, 6, 133, \"SHAKE256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHAKE_N32_W4:\n+                    params = new LMOTSParams(lmotsType, 32, 4, 4, 67, \"SHAKE256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHAKE_N32_W8:\n+                    params = new LMOTSParams(lmotsType, 32, 8, 0, 34, \"SHAKE256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHAKE_N24_W1:\n+                    params = new LMOTSParams(lmotsType, 24, 1, 8, 200, \"SHAKE256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHAKE_N24_W2:\n+                    params = new LMOTSParams(lmotsType, 24, 2, 6, 101, \"SHAKE256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHAKE_N24_W4:\n+                    params = new LMOTSParams(lmotsType, 24, 4, 4, 51, \"SHAKE256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHAKE_N24_W8:\n+                    params = new LMOTSParams(lmotsType, 24, 8, 0, 26, \"SHAKE256\");\n+                    break;\n+ *\/\n+\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported or bad OTS Algorithm Identifier.\");\n+            }\n+            return params;\n+        }\n+\n+        public int coef(byte[] S, int i) {\n+            return (twoPowWMinus1 & (S[i * w \/ 8] >> (8 - (w * (i % (8 \/ w)) + w))));\n+        }\n+\n+        private void addCksm(byte[] S) {\n+            int len = n;\n+            int sum = 0;\n+            int numSlices = len * 8 \/ w;\n+            for (int i = 0; i < numSlices; i++) {\n+                sum += twoPowWMinus1 - coef(S, i);\n+            }\n+            sum = sum << ls;\n+            S[len] = (byte) (sum >> 8);\n+            S[len + 1] = (byte) (sum & 0xff);\n+        }\n+\n+        public void digestFixedLengthPreprocessed(\n+                byte[] input, int inLen, byte[] output, int outOffset, int outLen) {\n+            if (sha256Fix != null) {\n+                sha256Fix.implDigestFixedLengthPreprocessed(input, inLen, output, outOffset, outLen);\n+            }\n+        }\n+        public byte[] lmotsPubKeyCandidate(LMSignature lmSig, byte[] message, LMSPublicKey pKey)\n+                throws NoSuchAlgorithmException, DigestException {\n+            LMOTSignature lmOtSig = lmSig.lmotSig;\n+            if (lmOtSig.otSigType != pKey.otsType) {\n+                throw new IllegalArgumentException(\"OTS public key type and OTS signature type do not match\");\n+            }\n+\n+            byte[] preQ = new byte[22 + hashAlg_n];\n+            pKey.getI(preQ, 0);\n+            lmSig.getQArr(preQ, 16);\n+            preQ[20] = (byte) 0x81; \/\/ D_MSG = 0x8181\n+            preQ[21] = (byte) 0x81;\n+            lmOtSig.getC(preQ, 22);\n+            MessageDigest md = MessageDigest.getInstance(hashAlgName);\n+            md.update(preQ, 0, 22 + n);\n+            md.update(message);\n+            byte[] QWithChecksum = new byte[hashAlg_n + 2];\n+            md.digest(QWithChecksum, 0, hashAlg_n); \/\/ digest resets the MessageDigest object\n+            addCksm(QWithChecksum);\n+\n+            byte[] preCandidate = new byte[22 + (p - 1) * n + hashAlg_n];\n+            pKey.getI(preCandidate, 0);\n+            lmSig.getQArr(preCandidate, 16);\n+            preCandidate[20] = (byte) 0x80; \/\/ D_PBLC = 0x8080\n+            preCandidate[21] = (byte) 0x80;\n+\n+            byte[] preZi = hashBuf;\n+            pKey.getI(preZi, 0);\n+            lmSig.getQArr(preZi, 16);\n+\n+            int twoPowWMinus2 = twoPowWMinus1 - 1;\n+            for (int i = 0; i < p; i++) {\n+                int a = coef(QWithChecksum, i);\n+                if (a == twoPowWMinus1) {\n+                    lmOtSig.getY(i, preCandidate, 22 + i * n);\n+                } else {\n+                    preZi[20] = (byte) (i >> 8);\n+                    preZi[21] = (byte) i;\n+                    lmOtSig.getY(i, preZi, 23);\n+                }\n+\n+                for (int j = a; j < twoPowWMinus1; j++) {\n+                    preZi[22] = (byte) j;\n+                    if (j < twoPowWMinus2) {\n+                        digestFixedLengthPreprocessed(preZi, 64, preZi, 23, n);\n+                    } else {\n+                        digestFixedLengthPreprocessed(preZi, 64, preCandidate, 22 + i * n, n);\n+                    }\n+                }\n+            }\n+            md.update(preCandidate, 0, 22 + p * n);\n+\n+            byte[] result = md.digest();\n+            if (n != hashAlg_n) {\n+                result = Arrays.copyOfRange(result, 0, n);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static class KeyFactoryImpl extends KeyFactorySpi {\n+        @Override\n+        protected PublicKey engineGeneratePublic(KeySpec keySpec) throws InvalidKeySpecException {\n+            if (keySpec instanceof X509EncodedKeySpec x) {\n+                try {\n+                    var val = new DerValue(new ByteArrayInputStream(x.getEncoded()));\n+                    val.data.getDerValue();\n+                    return new HSSPublicKey(new DerValue(val.data.getBitString()).getOctetString());\n+                } catch (IOException | InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(e);\n+                }\n+            } else if (keySpec instanceof RawKeySpec x) {\n+                try {\n+                    return new HSSPublicKey(x.getKeyArr());\n+                } catch (InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(e);\n+                }\n+            }\n+            throw new InvalidKeySpecException();\n+        }\n+\n+        @Override\n+        protected PrivateKey engineGeneratePrivate(KeySpec keySpec) throws InvalidKeySpecException {\n+            throw new InvalidKeySpecException(\"Private key generation is not supported\");\n+        }\n+\n+        @Override\n+        protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec) throws InvalidKeySpecException {\n+            if (key.getFormat().equals(\"X.509\") && key.getAlgorithm().equals(\"HSS\/LMS\")) {\n+                if (keySpec.isAssignableFrom(X509EncodedKeySpec.class)) {\n+                    return keySpec.cast(new X509EncodedKeySpec(key.getEncoded()));\n+                }\n+            }\n+            throw new InvalidKeySpecException();\n+        }\n+\n+        @Override\n+        protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+            PublicKey pKey;\n+            try {\n+                \/\/ Check if key originates from this factory\n+                if (key instanceof HSSPublicKey) {\n+                    return key;\n+                }\n+                \/\/ Convert key to spec\n+                X509EncodedKeySpec x509EncodedKeySpec\n+                        = engineGetKeySpec(key, X509EncodedKeySpec.class);\n+                \/\/ Create key from spec, and return it\n+                pKey = engineGeneratePublic(x509EncodedKeySpec);\n+            } catch (Exception e) {\n+                throw new InvalidKeyException();\n+            }\n+            return pKey;\n+        }\n+    }\n+\n+    public static class HSSPublicKey extends X509Key implements Length {\n+        @Serial\n+        private static final long serialVersionUID = 21;\n+        final int L;\n+        final LMSPublicKey lmsPublicKey;\n+\n+        @SuppressWarnings(\"deprecation\")\n+        public HSSPublicKey(byte[] keyArray) throws InvalidKeyException {\n+            int inLen = keyArray.length;\n+            if (inLen < 4)\n+                throw new InvalidKeyException(\"Invalid HSS public key\");\n+            L = LMSUtils.fourBytesToInt(keyArray, 0);\n+            lmsPublicKey = LMSPublicKey.of(Arrays.copyOfRange(keyArray, 4, keyArray.length));\n+            algid = new AlgorithmId(ObjectIdentifier.of(KnownOIDs.HSSLMS));\n+            key = new DerOutputStream().putOctetString(keyArray).toByteArray();\n+        }\n+\n+        public String getDigestAlgorithm() {\n+            return lmsPublicKey.getDigestAlgorithm();\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"deprecation\")\n+        public int length() {\n+            return key.length * 8; \/\/ length in bits\n+        }\n+    }\n+\n+    static class HSSSignature {\n+        final int Nspk;\n+        final LMSignature[] siglist;\n+        final LMSPublicKey[] pubList;\n+\n+        HSSSignature(byte[] sigArr, int pubKeyL, String pubKeyHashAlg) throws SignatureException {\n+            if (sigArr.length < 4) {\n+                throw new SignatureException(\"Bad HSS signature\");\n+            }\n+            Nspk = LMSUtils.fourBytesToInt(sigArr, 0);\n+            if (Nspk + 1 != pubKeyL) {\n+                throw new SignatureException(\"Bad HSS signature\");\n+            }\n+            siglist = new LMSignature[Nspk + 1];\n+            pubList = new LMSPublicKey[Nspk];\n+            int index = 4;\n+            try {\n+                for (int i = 0; i < Nspk; i++) {\n+                    siglist[i] = new LMSignature(sigArr, index, false);\n+                    index += siglist[i].sigArrayLength();\n+                    pubList[i] = new LMSPublicKey(sigArr, index, false);\n+                    if (!pubList[i].getDigestAlgorithm().equals(pubKeyHashAlg)) {\n+                        throw new SignatureException(\"Bad HSS signature\");\n+                    }\n+                    index += pubList[i].keyArrayLength();\n+                }\n+                siglist[Nspk] = new LMSignature(sigArr, index, true);\n+            } catch (Exception E) {\n+                throw new SignatureException(\"Bad HSS signature\");\n+            }\n+        }\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/HSS.java","additions":830,"deletions":0,"binary":false,"changes":830,"status":"added"},{"patch":"@@ -51,0 +51,1 @@\n+    private static final int BLOCKSIZE = 64;\n@@ -84,1 +85,1 @@\n-        super(name, digestLength, 64);\n+        super(name, digestLength, BLOCKSIZE);\n@@ -118,0 +119,11 @@\n+\n+    protected void implDigestFixedLengthPreprocessed(\n+            byte[] input, int inLen, byte[] output, int outOffset, int outLen) {\n+        implReset();\n+\n+        for (int ofs = 0; ofs < inLen; ofs += BLOCKSIZE) {\n+            implCompress0(input, ofs);\n+        }\n+        i2bBig(state, 0, output, outOffset, outLen);\n+    }\n+\n@@ -132,1 +144,1 @@\n-        Preconditions.checkFromIndexSize(ofs, 64, buf.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkFromIndexSize(ofs, BLOCKSIZE, buf.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA2.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -188,0 +188,4 @@\n+\n+        attrs.clear();\n+        attrs.put(\"ImplementedIn\", \"Software\");\n+        addWithAlias(p, \"Signature\", \"HSS\/LMS\", \"sun.security.provider.HSS\", attrs);\n@@ -217,0 +221,1 @@\n+        addWithAlias(p, \"KeyFactory\", \"HSS\/LMS\", \"sun.security.provider.HSS$KeyFactoryImpl\", attrs);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+    HSSLMS(\"1.2.840.113549.1.9.16.3.17\", \"HSS\/LMS\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.spec.KeySpec;\n+\n+public class RawKeySpec  implements KeySpec {\n+    final private byte[] keyArr;\n+    \/**\n+     * The sole constructor\n+     * @param key contains the key as a byte array\n+     *\/\n+    public RawKeySpec(byte[] key) {\n+        keyArr = key.clone();\n+    }\n+\n+    \/**\n+     * Getter function\n+     * @return a copy of the key bits\n+     *\/\n+    public byte[] getKeyArr() {\n+        return keyArr.clone();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/RawKeySpec.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -88,1 +88,1 @@\n-    \/\/ effective key length of the key, e.g. 56 for a DES key\n+    \/\/ effective key length of the key in bits, e.g. 56 for a DES key\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}