{"files":[{"patch":"@@ -25,1 +25,0 @@\n-\n@@ -39,1 +38,2 @@\n- * Leighton-Micali Signatures (LMS) as described in RFC 8554 and NIST Special publication 800-208.\n+ * Leighton-Micali Signatures (HSS\/LMS) as described in RFC 8554 and\n+ *  NIST Special publication 800-208.\n@@ -58,1 +58,2 @@\n-    protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException {\n+    protected void engineInitSign(PrivateKey privateKey)\n+            throws InvalidKeyException {\n@@ -62,1 +63,2 @@\n-    \/\/ This will never be called because engineInitSign unconditionally throws an exception\n+    \/\/ This will never be called because engineInitSign unconditionally\n+    \/\/ throws an exception\n@@ -69,1 +71,2 @@\n-    protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException {\n+    protected void engineInitVerify(PublicKey publicKey)\n+            throws InvalidKeyException {\n@@ -93,3 +96,3 @@\n-    protected boolean engineVerify(byte[] signature) throws SignatureException {\n-        HSSSignature sig = new HSSSignature(signature, pubKey);\n-        LMSPublicKey lmsPubKey = pubKey.lmsPublicKey;\n+    protected boolean engineVerify(byte[] signature)\n+            throws SignatureException {\n+\n@@ -98,0 +101,2 @@\n+            HSSSignature sig = new HSSSignature(signature, pubKey);\n+            LMSPublicKey lmsPubKey = pubKey.lmsPublicKey;\n@@ -104,1 +109,2 @@\n-            result &= LMSUtils.lmsVerify(lmsPubKey, sig.siglist[sig.Nspk], messageStream.toByteArray());\n+            result &= LMSUtils.lmsVerify(\n+                    lmsPubKey, sig.siglist[sig.Nspk], messageStream.toByteArray());\n@@ -118,1 +124,2 @@\n-        LMSPublicKey(byte[] keyArray, int offset, boolean checkExactLength) throws InvalidKeyException {\n+        LMSPublicKey(byte[] keyArray, int offset, boolean checkExactLength)\n+                throws InvalidKeyException {\n@@ -226,1 +233,3 @@\n-        static boolean lmsVerify(LMSPublicKey lmsPublicKey, LMSignature sig, byte[] message) throws SignatureException {\n+        static boolean lmsVerify(\n+                LMSPublicKey lmsPublicKey, LMSignature sig, byte[] message)\n+                throws SignatureException {\n@@ -228,1 +237,2 @@\n-            if ((sig.sigOtsType != lmsPublicKey.otsType) || (sig.sigLmType != lmsPublicKey.type)) {\n+            if ((sig.sigOtsType != lmsPublicKey.otsType) ||\n+                    (sig.sigLmType != lmsPublicKey.type)) {\n@@ -239,1 +249,2 @@\n-                byte[] otsPkCandidate = lmotsParams.lmotsPubKeyCandidate(sig, message, lmsPublicKey);\n+                byte[] otsPkCandidate =\n+                        lmotsParams.lmotsPubKeyCandidate(sig, message, lmsPublicKey);\n@@ -245,1 +256,2 @@\n-                MessageDigest md = MessageDigest.getInstance(lmsPublicKey.lmsParams.hashAlgStr);\n+                MessageDigest md =\n+                        MessageDigest.getInstance(lmsPublicKey.lmsParams.hashAlgStr);\n@@ -292,1 +304,2 @@\n-        LMOTSignature(byte[] sigArray, LMOTSParams lmotsParams) throws InvalidParameterException {\n+        LMOTSignature(byte[] sigArray, LMOTSParams lmotsParams)\n+                throws InvalidParameterException {\n@@ -324,1 +337,1 @@\n-        final int hashAlg_m = 32; \/\/ output length of the hash function used for the LMS tree\n+        final int hashAlg_m = 32; \/\/ output length of the LMS tree hash function\n@@ -378,1 +391,2 @@\n-            return (lmotsParams.hashAlgName.equals(hashAlgStr)) && (lmotsParams.n == m);\n+            return lmotsParams.hashAlgName.equals(hashAlgStr) &&\n+                    (lmotsParams.n == m);\n@@ -388,1 +402,1 @@\n-        final int n; \/\/ output length of the hash function used in the one time signature\n+        final int n; \/\/ output length of the hash function used in the OTS\n@@ -395,1 +409,2 @@\n-        LMSignature(byte[] sigArray, int offset, boolean checkExactLen) throws SignatureException {\n+        LMSignature(byte[] sigArray, int offset, boolean checkExactLen)\n+                throws SignatureException {\n@@ -419,1 +434,2 @@\n-            byte[] otSigArr = Arrays.copyOfRange(sigArray, offset + 4, offset + 4 + otsSigLen);\n+            byte[] otSigArr = Arrays.copyOfRange(\n+                            sigArray, offset + 4, offset + 4 + otsSigLen);\n@@ -435,1 +451,3 @@\n-            if ((q >= (1 << h)) || (inLen < sigArrLen) || (checkExactLen && (inLen != sigArrLen))) {\n+            if ((q >= (1 << h)) ||\n+                    (inLen < sigArrLen) ||\n+                    (checkExactLen && (inLen != sigArrLen))) {\n@@ -471,0 +489,1 @@\n+\/\/12345678901234567890123456789012345678901234567890123456789012345678901234567890\n@@ -473,5 +492,7 @@\n-        \/\/ In that function a clone of this buffer is fed into the hash function as input to the\n-        \/\/ implDigestFixedLengthPreprocessed() function (which is basically an allocation and\n-        \/\/ padding computation free digest() function, so we can avoid the update()-digest() sequence)\n-        \/\/ which is parametrized so that the digest output is copied back into the buffer.\n-        \/\/ This way, we avoid memory allocations and some computations that would have to be done otherwise.\n+        \/\/ In that function a clone of this buffer is fed into the\n+        \/\/ hash function as input to the implDigestFixedLengthPreprocessed()\n+        \/\/ function (which is basically an allocation and padding computation\n+        \/\/ free digest() function, so we can avoid the update()-digest()\n+        \/\/ sequence) which is parametrized so that the digest output is copied\n+        \/\/ back into the buffer. This way, we avoid memory allocations and some\n+        \/\/ computations that would have to be done otherwise.\n@@ -479,1 +500,2 @@\n-        \/\/ Precomputed block for SHA256 when the message size is 55 bytes (i.e. when SHA256 is used)\n+        \/\/ Precomputed block for SHA256 when the message size is 55 bytes\n+        \/\/ (i.e. when SHA256 is used)\n@@ -491,1 +513,3 @@\n-        private LMOTSParams(int lmotSigType, int hLen, int w, int ls, int p, String hashAlgName) {\n+        private LMOTSParams(\n+                int lmotSigType, int hLen, int w,\n+                int ls, int p, String hashAlgName) {\n@@ -506,1 +530,2 @@\n-                    params = new LMOTSParams(lmotsType, 32, 1, 7, 265, \"SHA-256\");\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 1, 7, 265, \"SHA-256\");\n@@ -509,1 +534,2 @@\n-                    params = new LMOTSParams(lmotsType, 32, 2, 6, 133, \"SHA-256\");\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 2, 6, 133, \"SHA-256\");\n@@ -512,1 +538,2 @@\n-                    params = new LMOTSParams(lmotsType, 32, 4, 4, 67, \"SHA-256\");\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 4, 4, 67, \"SHA-256\");\n@@ -515,1 +542,2 @@\n-                    params = new LMOTSParams(lmotsType, 32, 8, 0, 34, \"SHA-256\");\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 8, 0, 34, \"SHA-256\");\n@@ -518,1 +546,2 @@\n-                    throw new IllegalArgumentException(\"Unsupported or bad OTS Algorithm Identifier.\");\n+                    throw new IllegalArgumentException(\n+                            \"Unsupported or bad OTS Algorithm Identifier.\");\n@@ -524,1 +553,2 @@\n-            return (twoPowWMinus1 & (S[i * w \/ 8] >> (8 - (w * (i % (8 \/ w)) + w))));\n+            return (twoPowWMinus1 &\n+                    (S[i * w \/ 8] >> (8 - (w * (i % (8 \/ w)) + w))));\n@@ -540,2 +570,4 @@\n-                SHA2.SHA256 sha256, byte[] input, int inLen, byte[] output, int outOffset, int outLen) {\n-            sha256.implDigestFixedLengthPreprocessed(input, inLen, output, outOffset, outLen);\n+                SHA2.SHA256 sha256, byte[] input, int inLen,\n+                byte[] output, int outOffset, int outLen) {\n+            sha256.implDigestFixedLengthPreprocessed(\n+                    input, inLen, output, outOffset, outLen);\n@@ -544,1 +576,2 @@\n-        byte[] lmotsPubKeyCandidate(LMSignature lmSig, byte[] message, LMSPublicKey pKey)\n+        byte[] lmotsPubKeyCandidate(\n+                LMSignature lmSig, byte[] message, LMSPublicKey pKey)\n@@ -548,1 +581,2 @@\n-                throw new SignatureException(\"OTS public key type and OTS signature type do not match\");\n+                throw new SignatureException(\n+                        \"OTS public key type and OTS signature type do not match\");\n@@ -568,1 +602,2 @@\n-                md.digest(QWithChecksum, 0, hashAlg_n); \/\/ digest resets the MessageDigest object\n+                md.digest(QWithChecksum, 0, hashAlg_n);\n+                \/\/ the MessageDigest object has now been reset\n@@ -596,1 +631,2 @@\n-                            digestFixedLengthPreprocessed(sha256, preZi, 64, preZi, 23, n);\n+                            digestFixedLengthPreprocessed(\n+                                    sha256, preZi, 64, preZi, 23, n);\n@@ -598,1 +634,2 @@\n-                            digestFixedLengthPreprocessed(sha256, preZi, 64, preCandidate, 22 + i * n, n);\n+                            digestFixedLengthPreprocessed(\n+                                    sha256, preZi, 64, preCandidate, 22 + i * n, n);\n@@ -617,1 +654,2 @@\n-        protected PublicKey engineGeneratePublic(KeySpec keySpec) throws InvalidKeySpecException {\n+        protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+                throws InvalidKeySpecException {\n@@ -621,1 +659,2 @@\n-                    return new HSSPublicKey(x509Spec.getEncoded(), true);\n+                    return new HSSPublicKey(\n+                            x509Spec.getEncoded(), true);\n@@ -636,2 +675,4 @@\n-        protected PrivateKey engineGeneratePrivate(KeySpec keySpec) throws InvalidKeySpecException {\n-            throw new InvalidKeySpecException(\"Private key generation is not supported\");\n+        protected PrivateKey engineGeneratePrivate(KeySpec keySpec)\n+                throws InvalidKeySpecException {\n+            throw new InvalidKeySpecException(\n+                    \"Private key generation is not supported\");\n@@ -641,1 +682,2 @@\n-        protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec) throws InvalidKeySpecException {\n+        protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec)\n+                throws InvalidKeySpecException {\n@@ -645,1 +687,2 @@\n-            if (key.getFormat().equals(\"X.509\") && key.getAlgorithm().equalsIgnoreCase(\"HSS\/LMS\")) {\n+            if (key.getFormat().equals(\"X.509\") &&\n+                    key.getAlgorithm().equalsIgnoreCase(\"HSS\/LMS\")) {\n@@ -683,1 +726,2 @@\n-        HSSPublicKey(byte[] keyArray, boolean x509Encoded) throws InvalidKeyException {\n+        HSSPublicKey(byte[] keyArray, boolean x509Encoded)\n+                throws InvalidKeyException {\n@@ -692,1 +736,4 @@\n-                lmsPublicKey = new LMSPublicKey(Arrays.copyOfRange(keyArray, 4, keyArray.length), 0, true);\n+                lmsPublicKey =\n+                        new LMSPublicKey(\n+                                Arrays.copyOfRange(keyArray, 4, keyArray.length),\n+                                0, true);\n@@ -694,2 +741,6 @@\n-                byte[] derEncodedKeyarray = new DerOutputStream().putOctetString(keyArray).toByteArray();\n-                this.setKey(new BitArray(8 * derEncodedKeyarray.length, derEncodedKeyarray));\n+                byte[] derEncodedKeyarray =\n+                        new DerOutputStream()\n+                                .putOctetString(keyArray)\n+                                .toByteArray();\n+                this.setKey(new BitArray(\n+                        8 * derEncodedKeyarray.length, derEncodedKeyarray));\n@@ -734,1 +785,2 @@\n-        HSSSignature(byte[] sigArr, HSSPublicKey pubKey) throws SignatureException {\n+        HSSSignature(byte[] sigArr, HSSPublicKey pubKey)\n+                throws SignatureException {\n@@ -740,1 +792,2 @@\n-                throw new SignatureException(\"HSS signature and public key have different tree heights\");\n+                throw new SignatureException(\n+                        \"HSS signature and public key have different tree heights\");\n@@ -750,2 +803,6 @@\n-                    if (!pubKey.lmsPublicKey.lmsParams.hasSameHash(pubList[i].lmsParams)) {\n-                        throw new SignatureException(\"Digest algorithm in public key and Signature do not match\");\n+                    if (!pubKey\n+                            .lmsPublicKey\n+                            .lmsParams\n+                            .hasSameHash(pubList[i].lmsParams)) {\n+                        throw new SignatureException(\n+                                \"Digest algorithm in public key and Signature do not match\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/HSS.java","additions":112,"deletions":55,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -221,1 +221,2 @@\n-        addWithAlias(p, \"KeyFactory\", \"HSS\/LMS\", \"sun.security.provider.HSS$KeyFactoryImpl\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"HSS\/LMS\",\n+                \"sun.security.provider.HSS$KeyFactoryImpl\", attrs);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\/\/12345678901234567890123456789012345678901234567890123456789012345678901234567890\n@@ -32,1 +33,2 @@\n- * It is intended to be used in testing algorithms where the algorithm specification describes the key in this form.\n+ * It is intended to be used in testing algorithms where the algorithm specification\n+ * describes the key in this form.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/RawKeySpec.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}