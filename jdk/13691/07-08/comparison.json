{"files":[{"patch":"@@ -36,1 +36,0 @@\n-import java.util.Objects;\n@@ -46,0 +45,1 @@\n+    @Override\n@@ -51,0 +51,1 @@\n+    @Override\n@@ -90,5 +91,6 @@\n-        for (int i = 0; i < sig.Nspk; i++) {\n-            byte[] keyArr = sig.pubList[i].keyArray();\n-            result &= LMSUtils.lmsVerify(lmsPubKey, sig.siglist[i], keyArr);\n-            lmsPubKey = sig.pubList[i];\n-        }\n+        try {\n+            for (int i = 0; i < sig.Nspk; i++) {\n+                byte[] keyArr = sig.pubList[i].keyArray();\n+                result &= LMSUtils.lmsVerify(lmsPubKey, sig.siglist[i], keyArr);\n+                lmsPubKey = sig.pubList[i];\n+            }\n@@ -96,2 +98,4 @@\n-        result &= LMSUtils.lmsVerify(lmsPubKey, sig.siglist[sig.Nspk], messageStream.toByteArray());\n-        messageStream.reset();\n+            result &= LMSUtils.lmsVerify(lmsPubKey, sig.siglist[sig.Nspk], messageStream.toByteArray());\n+        } finally {\n+            messageStream.reset();\n+        }\n@@ -101,3 +105,1 @@\n-    static class LMSPublicKey implements Serializable {\n-        @java.io.Serial\n-        private static final long serialVersionUID = 21L;\n+    static class LMSPublicKey {\n@@ -106,1 +108,1 @@\n-        final transient LMSParams lmsParams;\n+        final LMSParams lmsParams;\n@@ -110,5 +112,1 @@\n-        public static LMSPublicKey of(byte[] keyArray) throws InvalidKeyException {\n-            return new LMSPublicKey(keyArray, 0, true);\n-        }\n-\n-        public LMSPublicKey(byte[] keyArray, int offset, boolean checkExactLength) throws InvalidKeyException {\n+        LMSPublicKey(byte[] keyArray, int offset, boolean checkExactLength) throws InvalidKeyException {\n@@ -175,0 +173,14 @@\n+        static String lmsType(int type) {\n+            String typeStr;\n+            switch (type) {\n+                case LMS_RESERVED: typeStr = \"LMS_RESERVED\"; break;\n+                case LMS_SHA256_M32_H5: typeStr = \"LMS_SHA256_M32_H5\"; break;\n+                case LMS_SHA256_M32_H10: typeStr = \"LMS_SHA256_M32_H10\"; break;\n+                case LMS_SHA256_M32_H15: typeStr = \"LMS_SHA256_M32_H15\"; break;\n+                case LMS_SHA256_M32_H20: typeStr = \"LMS_SHA256_M32_H20\"; break;\n+                case LMS_SHA256_M32_H25: typeStr = \"LMS_SHA256_M32_H25\"; break;\n+                default: typeStr = \"unrecognized\";\n+            }\n+            return typeStr;\n+        }\n+\n@@ -181,0 +193,14 @@\n+        static String lmotsType(int type) {\n+            String typeStr;\n+            switch (type) {\n+                case LMOTS_RESERVED: typeStr = \"LMOTS_RESERVED\"; break;\n+                case LMOTS_SHA256_N32_W1: typeStr = \"LMOTS_SHA256_N32_W1\"; break;\n+                case LMOTS_SHA256_N32_W2: typeStr = \"LMOTS_SHA256_N32_W2\"; break;\n+                case LMOTS_SHA256_N32_W4: typeStr = \"LMOTS_SHA256_N32_W4\"; break;\n+                case LMOTS_SHA256_N32_W8: typeStr = \"LMOTS_SHA256_N32_W8\"; break;\n+                default: typeStr = \"unrecognized\";\n+            }\n+            return typeStr;\n+        }\n+\n+\n@@ -255,2 +281,2 @@\n-        final int n;\n-        final int p;\n+        private final int n;\n+        private final int p;\n@@ -291,1 +317,0 @@\n-        final int type;\n@@ -299,1 +324,0 @@\n-            this.type = type;\n@@ -372,1 +396,0 @@\n-            try {\n@@ -376,0 +399,1 @@\n+            try {\n@@ -442,4 +466,5 @@\n-        \/\/ The buffer for the lmotsPubKeyCandidate() function. In that function this buffer is fed into the\n-        \/\/ hash function as input to the implDigestFixedLengthPreprocessed() function (which is\n-        \/\/ basically an allocation and padding computation free digest() function, so we can avoid the\n-        \/\/ update()-digest() sequence) which is parametrized so that the digest output is copied back into this buffer.\n+        \/\/ The initial buffer image for the lmotsPubKeyCandidate() function.\n+        \/\/ In that function a clone of this buffer is fed into the hash function as input to the\n+        \/\/ implDigestFixedLengthPreprocessed() function (which is basically an allocation and\n+        \/\/ padding computation free digest() function, so we can avoid the update()-digest() sequence)\n+        \/\/ which is parametrized so that the digest output is copied back into the buffer.\n@@ -449,1 +474,1 @@\n-        final static byte[] hashbufSha256_32 = {\n+        private final static byte[] hashbufSha256_32 = {\n@@ -460,2 +485,0 @@\n-        final SHA2.SHA256 sha256Fix;\n-\n@@ -471,5 +494,0 @@\n-            if (Objects.equals(hashAlgName, \"SHA-256\")) {\n-                sha256Fix = new SHA2.SHA256();\n-            } else {\n-                sha256Fix = null;\n-            }\n@@ -516,4 +534,2 @@\n-                byte[] input, int inLen, byte[] output, int outOffset, int outLen) {\n-            if (sha256Fix != null) {\n-                sha256Fix.implDigestFixedLengthPreprocessed(input, inLen, output, outOffset, outLen);\n-            }\n+                SHA2.SHA256 sha256, byte[] input, int inLen, byte[] output, int outOffset, int outLen) {\n+            sha256.implDigestFixedLengthPreprocessed(input, inLen, output, outOffset, outLen);\n@@ -521,0 +537,1 @@\n+\n@@ -540,1 +557,1 @@\n-            byte[] result = new byte[md.getDigestLength()];\n+            byte[] result;\n@@ -555,0 +572,1 @@\n+                SHA2.SHA256 sha256 = new SHA2.SHA256();\n@@ -572,1 +590,1 @@\n-                            digestFixedLengthPreprocessed(preZi, 64, preZi, 23, n);\n+                            digestFixedLengthPreprocessed(sha256, preZi, 64, preZi, 23, n);\n@@ -574,1 +592,1 @@\n-                            digestFixedLengthPreprocessed(preZi, 64, preCandidate, 22 + i * n, n);\n+                            digestFixedLengthPreprocessed(sha256, preZi, 64, preCandidate, 22 + i * n, n);\n@@ -654,1 +672,1 @@\n-    static class HSSPublicKey extends X509Key implements Length {\n+    static class HSSPublicKey extends X509Key implements Serializable {\n@@ -657,2 +675,2 @@\n-        final int L;\n-        final LMSPublicKey lmsPublicKey;\n+        private int L;\n+        private transient LMSPublicKey lmsPublicKey;\n@@ -660,1 +678,0 @@\n-        @SuppressWarnings(\"deprecation\")\n@@ -667,1 +684,1 @@\n-            lmsPublicKey = LMSPublicKey.of(Arrays.copyOfRange(keyArray, 4, keyArray.length));\n+            lmsPublicKey = new LMSPublicKey(Arrays.copyOfRange(keyArray, 4, keyArray.length), 0, true);\n@@ -669,1 +686,2 @@\n-            key = new DerOutputStream().putOctetString(keyArray).toByteArray();\n+            byte[] derEncodedKeyarray = new DerOutputStream().putOctetString(keyArray).toByteArray();\n+            this.setKey(new BitArray(8 * derEncodedKeyarray.length, derEncodedKeyarray));\n@@ -673,3 +691,26 @@\n-        @SuppressWarnings(\"deprecation\")\n-        public int length() {\n-            return key.length * 8; \/\/ length in bits\n+        public String toString() {\n+            HexDumpEncoder  encoder = new HexDumpEncoder();\n+\n+            return \"HSS\/LMS public key, number of layers: \" + L +\n+                    \", LMS type: \" + LMSUtils.lmsType(lmsPublicKey.type) +\n+                    \",\\nOTS type: \" + LMSUtils.lmotsType(lmsPublicKey.otsType) +\n+                    \", byte array representation:\\n\" +\n+                    encoder.encode(getKey().toByteArray());\n+        }\n+\n+        \/**\n+         * Parse the key. Called by X509Key.\n+         *\/\n+        protected void parseKeyBits() throws InvalidKeyException {\n+            byte[] keyArray = getKey().toByteArray();\n+            L = LMSUtils.fourBytesToInt(keyArray, 0);\n+            lmsPublicKey = new LMSPublicKey(keyArray, 0, true);\n+        }\n+\n+\n+        @java.io.Serial\n+        protected Object writeReplace() throws java.io.ObjectStreamException {\n+            return new KeyRep(KeyRep.Type.PUBLIC,\n+                    getAlgorithm(),\n+                    getFormat(),\n+                    getEncoded());\n@@ -680,3 +721,3 @@\n-        final int Nspk;\n-        final LMSignature[] siglist;\n-        final LMSPublicKey[] pubList;\n+        private final int Nspk;\n+        private final LMSignature[] siglist;\n+        private final LMSPublicKey[] pubList;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/HSS.java","additions":94,"deletions":53,"binary":false,"changes":147,"status":"modified"}]}