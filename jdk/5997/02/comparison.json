{"files":[{"patch":"@@ -373,0 +373,1 @@\n+  assert(!AutoCreateSharedArchive, \"Should not call this function, instead call dump(TRAPS)\");\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+    _full_path = Arguments::GetSharedArchivePath();\n@@ -179,0 +180,7 @@\n+    _full_path = Arguments::GetSharedDynamicArchivePath();\n+    if (AutoCreateSharedArchive) {\n+      if (!validate_archive()) {\n+        \/\/ regenerate shared archive at exit\n+        DynamicDumpSharedSpaces = true;\n+      }\n+    }\n@@ -192,0 +200,16 @@\n+  if (_file_open) {\n+    os::close(_fd);\n+  }\n+}\n+\n+\/\/ Do preliminary validation on archive. More checks are in initialization.\n+bool FileMapInfo::validate_archive() {\n+  if (!os::file_exists(_full_path)) {\n+    return false;\n+  }\n+  \/\/ validate header info\n+  if (!check_archive(_full_path, _is_static)) {\n+    return false;\n+  }\n+\n+  return true;\n@@ -1086,1 +1110,1 @@\n-  bool read_base_archive_name(char** target) {\n+  char* read_base_archive_name() {\n@@ -1090,1 +1114,1 @@\n-    *target = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n+    char* base_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n@@ -1092,1 +1116,1 @@\n-    size_t n = os::read(_fd, *target, (unsigned int)name_size);\n+    size_t n = os::read(_fd, base_name, (unsigned int)name_size);\n@@ -1095,2 +1119,2 @@\n-      FREE_C_HEAP_ARRAY(char, *target);\n-      return false;\n+      FREE_C_HEAP_ARRAY(char, base_name);\n+      return nullptr;\n@@ -1098,4 +1122,4 @@\n-    if (!os::file_exists(*target)) {\n-      log_info(cds)(\"Base archive %s does not exist\", *target);\n-      FREE_C_HEAP_ARRAY(char, *target);\n-      return false;\n+    if (*(base_name + name_size - 1) != '\\0' || strlen(base_name) != name_size - 1) {\n+      log_info(cds)(\"Base archive name is damaged\");\n+      FREE_C_HEAP_ARRAY(char, base_name);\n+      return nullptr;\n@@ -1103,1 +1127,6 @@\n-    return true;\n+    if (!os::file_exists(base_name)) {\n+      log_info(cds)(\"Base archive %s does not exist\", base_name);\n+      FREE_C_HEAP_ARRAY(char, base_name);\n+      return nullptr;\n+    }\n+    return base_name;\n@@ -1129,1 +1158,3 @@\n-      vm_exit_during_initialization(\"Not a top shared archive\", archive_name);\n+      if (!AutoCreateSharedArchive) {\n+        vm_exit_during_initialization(\"Not a top shared archive\", archive_name);\n+      }\n@@ -1135,10 +1166,18 @@\n-    if (path_offset + name_size != header_size) {\n-      log_info(cds)(\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\");\n-      log_info(cds)(\"  _base_archive_name_size   = \" UINT32_FORMAT, name_size);\n-      log_info(cds)(\"  _base_archive_path_offset = \" UINT32_FORMAT, path_offset);\n-      log_info(cds)(\"  _header_size              = \" UINT32_FORMAT, header_size);\n-      return false;\n-    }\n-    char* base_name = NULL;\n-    if (!file_helper.read_base_archive_name(&base_name)) {\n-      return false;\n+    if (name_size != 0 && path_offset != 0) {\n+      if (path_offset + name_size != header_size) {\n+        log_info(cds)(\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\");\n+        log_info(cds)(\"  _base_archive_name_size   = \" UINT32_FORMAT, name_size);\n+        log_info(cds)(\"  _base_archive_path_offset = \" UINT32_FORMAT, path_offset);\n+        log_info(cds)(\"  _header_size              = \" UINT32_FORMAT, header_size);\n+        return false;\n+      }\n+      char* base_name = file_helper.read_base_archive_name();\n+      if (base_name == nullptr) {\n+        return false;\n+      }\n+      FREE_C_HEAP_ARRAY(char, base_name);\n+    } else {\n+      if (name_size != 0 || path_offset != 0) {\n+        log_info(cds)(\"_base_archive_name_size and _base_archive_path_offset must be 0 at same time\");\n+        return false;\n+      }\n@@ -1146,1 +1185,0 @@\n-    FREE_C_HEAP_ARRAY(char, base_name);\n@@ -1173,2 +1211,2 @@\n-    if (!file_helper.read_base_archive_name(base_archive_name)) {\n-      *base_archive_name = NULL;\n+    *base_archive_name = file_helper.read_base_archive_name();\n+    if (*base_archive_name == nullptr) {\n@@ -2300,7 +2338,10 @@\n-  if (!open_for_read()) {\n-    return false;\n-  }\n-  if (!init_from_file(_fd)) {\n-    return false;\n-  }\n-  if (!validate_header()) {\n+  \/\/ AutoCreateSharedArchive\n+  if (!open_for_read() || !init_from_file(_fd) || !validate_header()) {\n+    if (_is_static) {\n+      FileMapInfo::fail_continue(\"Initialize static archive failed.\");\n+    } else {\n+      FileMapInfo::fail_continue(\"Initialize dynamic archive failed.\");\n+      if (AutoCreateSharedArchive) {\n+        DynamicDumpSharedSpaces = true;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":72,"deletions":31,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -447,0 +447,1 @@\n+  bool  validate_archive() NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3133,0 +3133,11 @@\n+  if (AutoCreateSharedArchive) {\n+    if (SharedArchiveFile == NULL) {\n+      log_info(cds)(\"-XX:+AutoCreateSharedArchive must work with a valid SharedArchiveFile\");\n+      return JNI_ERR;\n+    }\n+    if (ArchiveClassesAtExit != NULL) {\n+      log_info(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n+      return JNI_ERR;\n+    }\n+  }\n+\n@@ -3510,0 +3521,1 @@\n+\n@@ -3527,0 +3539,1 @@\n+\n@@ -3541,0 +3554,5 @@\n+        \/\/ +AutoCreateSharedArchive, regenerate the dynamic archive base on default archive.\n+        if (AutoCreateSharedArchive && !os::file_exists(SharedArchivePath)) {\n+          SharedDynamicArchivePath = temp_archive_path;\n+          SharedArchivePath = get_default_shared_archive_path();\n+        }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1828,0 +1828,3 @@\n+  product(bool, AutoCreateSharedArchive, false,                             \\\n+          \"Create shared archive at exit if cds mapping failed\")            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -142,1 +142,2 @@\n-                             \"Header checksum verification failed\",\n+                             \"Base archive name is damaged\",\n+                             \"Error occurred during initialization of VM\",\n@@ -155,3 +156,3 @@\n-               new String[] {\"Base archive \" + baseArchiveName,\n-                             \" does not exist\",\n-                             \"Header checksum verification failed\"});\n+               new String[] {\"Base archive name is damaged\",\n+                             \"Error occurred during initialization of VM\",\n+                             \"Unable to use shared archive\"});\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -97,0 +97,13 @@\n+    \/**\n+     * Excute a JVM to dump a base archive by\n+     *  -Xshare:dump -XX:SharedArchiveFile=baseArchiveName\n+     *\/\n+    public static Result dumpBaseArchive(String baseArchiveName, String... cmdLineSuffix)\n+        throws Exception\n+    {\n+        OutputAnalyzer output = TestCommon.dumpBaseArchive(baseArchiveName, cmdLineSuffix);\n+        CDSOptions opts = new CDSOptions();\n+        opts.setXShareMode(\"dump\");\n+        return new Result(opts, output);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveTestBase.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,329 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261455\n+ * @summary test -XX:+AutoCreateSharedArchive feature\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build Hello\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar TestAutoCreateSharedArchive\n+ *\/\n+\n+\/*\n+ * -XX:SharedArchiveFile can be specified in two styles:\n+ *\n+ *  (A) Test with default base archive -XX:+SharedArchiveFile=<archive>\n+ *  (B) Test with the base archive is specified: -XX:SharedArchiveFile=<base>:<file>\n+ *  all the following if not explained explicitly, run with flag -XX:+AutoCreateSharedArchive\n+ *\n+ * 10 Case (A)\n+ *\n+ * 10.1 run with non-existing archive should automatically create dynamic archive\n+ *      If the JDK's default CDS archive cannot be loaded, print out warning, run continue without shared archive\n+ *      and no shared archive created at exit.\n+ * 10.2 run with the created dynamic archive should pass.\n+ * 10.3 run with the created dynamic archive and -XX:+AutoCreateSharedArchive should pass and no shared archive created at exit.\n+ *\n+ * 11 run with damaged magic should not regenerate dynamic archive.\n+ *    Bad magic of the shared archive leads the archive open as static that will not find base archive. With base archive not shared,\n+ *    at exit, no shared archive (top) will be generated.\n+ * 12 run with a bad versioned archive should create dynamic archive.\n+ *    A bad version of the archive still makes the archive open as dynamic so a new archive but failed to share, but base archive\n+ *    is shared, so the top archive  will be generated at exit.\n+ * 13 run with a bad jvm_ident archive should create dynamic archive\n+ *    The reason as 12.\n+ * 14 Read base archive from top archive failed\n+ *    If stored base archive name is not correct, it will lead the archive opened as static and no shared in runtime,\n+ *    also no shared archive created at exit.\n+ *\n+ * 20 (case B)\n+ *\n+ * 20.1 dump base archive which will be used for dumping top archive.\n+ * 20.2 dump top archive based on base archive obtained in 20.1.\n+ * 20.3 run -XX:SharedArchiveFile=<base>:<top> to verify the archives.\n+ *\n+ * 21 if version of top archive is not correct (not the current version), the archive cannot be shared and will be\n+ *    regenerated at exit.\n+ * 22 if base archive is not with correct version, both base and top archives will not be shared.\n+ *    At exit, there is no shared archive created automatically.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.cds.CDSArchiveUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class TestAutoCreateSharedArchive extends DynamicArchiveTestBase {\n+    private static final String BASE_NAME = CDSTestUtils.getOutputFileName(\"base.jsa\");\n+    private static final String TOP_NAME  = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+    private static final String mainAppClass = \"Hello\";\n+    private static final String HELLO_SOURCE = \"Hello source: shared objects file (top)\";\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(TestAutoCreateSharedArchive::testAutoCreateSharedArchive);\n+    }\n+\n+    public static void checkFileExists(String fileName) throws Exception {\n+        File file = new File(fileName);\n+        if (!file.exists()) {\n+             throw new IOException(\"Archive \" + file.getName() + \" is not autamatically created!\");\n+        }\n+    }\n+\n+    public static String startNewArchive(String testName) {\n+        String newArchiveName = TestCommon.getNewArchiveName(testName);\n+        TestCommon.setCurrentArchiveName(newArchiveName);\n+        return newArchiveName;\n+    }\n+\n+    public static void print(String message) {\n+        System.out.println(message);\n+    }\n+\n+    private static void testAutoCreateSharedArchive() throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"hello.jar\");\n+\n+        File archiveFile = new File(TOP_NAME);\n+        if (archiveFile.exists()) {\n+          archiveFile.delete();\n+        }\n+\n+        \/\/ The list numbers try to match JDK-8272331 (CSR for JDK-8261455) test items but not exactly matched.\n+\n+        \/\/ 10 non-existing archive should automatically create dynamic archive based on default shared archive\n+        \/\/ if base archive loaded.\n+        print(\"10 Test with default base shared archive\");\n+        print(\"10.1 run with non-existing archive should automatically create dynamic archive\");\n+        run(TOP_NAME,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(\"Dumping shared data to file:\")\n+                      .shouldContain(TOP_NAME);\n+                });\n+        checkFileExists(TOP_NAME);\n+\n+        \/\/ 10.2 run with the created dynamic archive should pass\n+        print(\"10.2 run with the created dynamic archive should pass\");\n+        run(TOP_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+\n+        \/\/ 10.3 run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\n+        print(\"10.3 run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\");\n+        run(TOP_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldNotContain(\"Dumping shared data to file\")\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+\n+\n+         \/\/ 11 run with damaged magic should not regenerate dynamic archive\n+         \/\/    The bad magic will make the archive be opened as static archive\n+         \/\/    and failed, no shared for base archive either.\n+         print(\"11 run with damaged magic should not regenerate dynamic archive\");\n+         String modMagic = startNewArchive(\"modify-magic\");\n+         File copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modMagic);\n+         CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic(), 0x1234);\n+\n+         run(modMagic,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                output.shouldNotContain(\"Dumping shared data to file\");\n+                });\n+\n+        \/\/ 12 run with a bad versioned archive should create dynamic archive\n+        print(\"12 run with a bad versioned archive should create dynamic archive\");\n+        archiveFile = new File(TOP_NAME);\n+        String modVersion = startNewArchive(\"modify-version\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modVersion);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0x00000000);\n+\n+        run(modVersion,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                });\n+        checkFileExists(modVersion);\n+\n+        \/\/ 13 run with a bad jvm_indent archive should create dynamic archive\n+        print(\"13 run with a bad jvm_ident archive should create dynamic archive\");\n+        archiveFile = new File(TOP_NAME);\n+        String modJvmIdent = startNewArchive(\"modify-jvmident\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modJvmIdent);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetJvmIdent(), 0x00000000);\n+\n+        run(modJvmIdent,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                });\n+        checkFileExists(modJvmIdent);\n+\n+         \/\/ 14 read base archive from top archive failed\n+         \/\/    the failure will cause the archive be opened as static\n+         \/\/    so no shared both for base and top\n+         print(\"14 read base archive from top archive failed\");\n+         String modBaseName = startNewArchive(\"modify-basename\");\n+         copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modBaseName);\n+         int nameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n+         int offset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+         StringBuilder sb = new StringBuilder();\n+         for (int i = 0; i < nameSize - 4; i++) {\n+             sb.append('Z');\n+         }\n+         sb.append(\".jsa\");\n+         sb.append('\\0');\n+         String newName = sb.toString();\n+         CDSArchiveUtils.writeData(copiedJsa, offset, newName.getBytes());\n+\n+         run(modBaseName,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                output.shouldNotContain(\"Dumping shared data to file\");\n+                });\n+\n+         \/\/ 20 Testing with -XX:SharedArchiveFile=top:base\n+         print(\"20 Testing with -XX:SharedArchiveFile=top:base\");\n+         \/\/ 20.1 dump base archive and top archive\n+         print(\"20.1 dump base archive \" + BASE_NAME);\n+         dumpBaseArchive(BASE_NAME, \"-Xlog:cds\")\n+             .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+             });\n+         checkFileExists(BASE_NAME);\n+\n+         \/\/ 20.2 dump top based on base\n+         print(\"20.2 dump top based on base\");\n+         dump2(BASE_NAME, TOP_NAME,\n+               \"-Xlog:cds\",\n+               \"-cp\", appJar, mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldHaveExitValue(0)\n+                       .shouldContain(\"Dumping shared data to file:\")\n+                       .shouldContain(TOP_NAME);\n+             });\n+\n+         \/\/ 20.3 run with base and top\n+         print(\"20.3 run with base and top\");\n+         run2(BASE_NAME, TOP_NAME,\n+              \"-Xlog:cds\",\n+              \"-Xlog:cds+dynamic=info\",\n+              \"-Xlog:class+load\",\n+              \"-cp\", appJar,\n+              mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldHaveExitValue(0)\n+                       .shouldContain(HELLO_SOURCE);\n+             });\n+\n+\n+         File topFile = new File(TOP_NAME);\n+         \/\/ 21 top version is not correct, regenerate top\n+         print(\"21 top version is not correct, regenerate top\");\n+         String modHeader = startNewArchive(\"modify-header\");\n+         copiedJsa = CDSArchiveUtils.copyArchiveFile(topFile, modHeader);\n+         CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0xff);\n+         run2(BASE_NAME, modHeader,\n+              \"-Xshare:auto\",\n+              \"-XX:+AutoCreateSharedArchive\",\n+              \"-Xlog:cds\",\n+              \"-Xlog:cds+dynamic=info\",\n+              \"-cp\", appJar,\n+              mainAppClass)\n+              .assertNormalExit(output -> {\n+                  output.shouldHaveExitValue(0)\n+                        .shouldContain(\"Dumping shared data to file:\")\n+                        .shouldContain(modHeader)\n+                        .shouldContain(\"Regenerate MethodHandle Holder classes\");\n+              });\n+         \/\/ 22 screw up base archive, will not generate top\n+         print(\"22 screw up base archive, will not generate top\");\n+         File baseFile = new File(BASE_NAME);\n+         String modBase = startNewArchive(\"modify-base\");\n+         copiedJsa = CDSArchiveUtils.copyArchiveFile(baseFile, modBase);\n+         CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0xff);\n+         run2(modBase, TOP_NAME,\n+              \"-Xshare:auto\",\n+              \"-XX:+AutoCreateSharedArchive\",\n+              \"-Xlog:cds\",\n+              \"-Xlog:cds+dynamic=info\",\n+              \"-cp\", appJar,\n+              mainAppClass)\n+              .assertNormalExit(output -> {\n+                  output.shouldContain(\"The shared archive file has the wrong version\")\n+                        .shouldContain(\"Initialize static archive failed\")\n+                        .shouldContain(\"Unable to map shared spaces\")\n+                        .shouldContain(\"Hello World\")\n+                        .shouldNotContain(\"Dumping shared data to file:\");\n+              });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -41,0 +41,7 @@\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.BasicFileAttributeView;\n+import java.nio.file.attribute.FileTime;\n+\n@@ -64,0 +71,6 @@\n+    static FileTime getLastModifiedTimeFor(String fileName) throws IOException {\n+        Path p = Paths.get(fileName);\n+        BasicFileAttributes bfa = Files.getFileAttributeView(p, BasicFileAttributeView.class).readAttributes();\n+        return bfa.lastModifiedTime();\n+    }\n+\n@@ -106,4 +119,2 @@\n-        app.stopApp();\n-        \/\/ cannot dynamically dump twice, restart\n-        app = createLingeredApp(\"-cp\", allJars, \"-XX:+RecordDynamicDumpInfo\");\n-        pid = app.getPid();\n+        FileTime time0 = getLastModifiedTimeFor(localFileName);\n+        \/\/ do dynamic dump again, but set dir not writable, the process will exit.\n@@ -113,2 +124,1 @@\n-        app.stopApp();\n-        \/\/ MyDynamicDump.jsa should exist\n+        \/\/ MyDynamicDump.jsa should exist but not modified.\n@@ -116,0 +126,7 @@\n+        FileTime time1 = getLastModifiedTimeFor(localFileName);\n+        if (time1.compareTo(time0) != 0) {\n+            throw new RuntimeException(\"A new archive file created, it should not be created\");\n+        }\n+        if (app.getProcess().isAlive()) {\n+            app.stopApp();\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestFileSafety.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"}]}