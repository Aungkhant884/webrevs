{"files":[{"patch":"@@ -370,7 +370,6 @@\n-void DynamicArchive::dump(const char* archive_name, TRAPS) {\n-  assert((UseSharedSpaces && RecordDynamicDumpInfo) || AutoCreateSharedArchive, \"already checked in arguments.cpp?\");\n-\n-  HandleMark hm(THREAD);\n-  Arguments::set_dynamic_archive_path(archive_name);\n-  if (!AutoCreateSharedArchive) {\n-    \/\/ When dump at exit, prepare_for_dynamic_dumping already called.\n+ void DynamicArchive::dump(const char* archive_name, TRAPS) {\n+  assert(UseSharedSpaces && RecordDynamicDumpInfo, \"already checked in arguments.cpp?\");\n+  assert(ArchiveClassesAtExit == nullptr, \"already checked in arguments.cpp?\");\n+  assert(!AutoCreateSharedArchive, \"Should not call this function, instead call dump(TRAPS)\");\n+  ArchiveClassesAtExit = archive_name;\n+  if (Arguments::init_shared_archive_paths()) {\n@@ -378,0 +377,7 @@\n+    if (DynamicDumpSharedSpaces) {\n+      dump(CHECK);\n+    }\n+  } else {\n+    ArchiveClassesAtExit = nullptr;\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+              \"Could not setup SharedDynamicArchivePath\");\n@@ -379,2 +385,5 @@\n-  if (DynamicDumpSharedSpaces) {\n-    dump(CHECK);\n+  \/\/ prevent do dynamic dump at exit.\n+  ArchiveClassesAtExit = nullptr;\n+  if (!Arguments::init_shared_archive_paths()) {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+              \"Could not restore SharedDynamicArchivePath\");\n@@ -382,4 +391,0 @@\n-  \/\/ Nullify SharedDynamicArchive to prevent dump at exit.\n-  \/\/ Set DynamicDumpSharedSpaces to false will cause verification fail after dump.\n-  \/\/ Note this will issue warning in dump(TRAPS) below at exit if warning enabled.\n-  Arguments::set_dynamic_archive_path(nullptr);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-  if (DynamicDumpSharedSpaces && Arguments::GetSharedDynamicArchivePath() != nullptr) {\n+  if (DynamicDumpSharedSpaces) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3505,11 +3505,0 @@\n-void Arguments::set_dynamic_archive_path(const char* archive_name) {\n-  assert(UseSharedSpaces, \"Base archive must be shared\");\n-  if (SharedDynamicArchivePath != archive_name) {\n-    if (SharedDynamicArchivePath != nullptr) {\n-      os::free(SharedDynamicArchivePath);\n-    }\n-    SharedDynamicArchivePath = (archive_name != nullptr ? os::strdup_check_oom(archive_name, mtArguments)\n-                                                        : nullptr);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -622,1 +622,0 @@\n-  static void  set_dynamic_archive_path(const char* archive_name) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -506,10 +506,1 @@\n-    if (AutoCreateSharedArchive) {\n-      \/\/ for case base:top, or top only\n-      const char* archive = Arguments::GetSharedDynamicArchivePath();\n-      if (archive == nullptr) {\n-        archive = Arguments::GetSharedArchivePath();\n-      }\n-      DynamicArchive::dump(archive, thread);\n-    } else {\n-      DynamicArchive::dump(thread);\n-    }\n+    DynamicArchive::dump(thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @bug 8261455\n@@ -37,0 +38,39 @@\n+\/*\n+ * -XX:SharedArchiveFile can be specified in two styles:\n+ *\n+ *  (A) Test with default base archive -XX:+SharedArchiveFile=<archive>\n+ *  (B) Test with the base archive is specified: -XX:SharedArchiveFile=<base>:<file>\n+ *  all the following if not explained explicitly, run with flag -XX:+AutoCreateSharedArchive\n+ *\n+ * 10 Case (A)\n+ *\n+ * 10.1 run with non-existing archive should automatically create dynamic archive\n+ *      If the JDK's default CDS archive cannot be loaded, print out warning, run continue without shared archive\n+ *      and no shared archive created at exit.\n+ * 10.2 run with the created dynamic archive should pass.\n+ * 10.3 run with the created dynamic archive and -XX:+AutoCreateSharedArchive should pass and no shared archive created at exit.\n+ *\n+ * 11 run with damaged magic should not regenerate dynamic archive.\n+ *    Bad magic of the shared archive leads the archive open as static that will not find base archive. With base archive not shared,\n+ *    at exit, no shared archive (top) will be generated.\n+ * 12 run with a bad versioned archive should create dynamic archive.\n+ *    A bad version of the archive still makes the archive open as dynamic so a new archive but failed to share, but base archive\n+ *    is shared, so the top archive  will be generated at exit.\n+ * 13 run with a bad jvm_ident archive should create dynamic archive\n+ *    The reason as 12.\n+ * 14 Read base archive from top archive failed\n+ *    If stored base archive name is not correct, it will lead the archive opened as static and no shared in runtime,\n+ *    also no shared archive created at exit.\n+ *\n+ * 20 (case B)\n+ *\n+ * 20.1 dump base archive which will be used for dumping top archive.\n+ * 20.2 dump top archive based on base archive obtained in 20.1.\n+ * 20.3 run -XX:SharedArchiveFile=<base>:<top> to verify the archives.\n+ *\n+ * 21 if version of top archive is not correct (not the current version), the archive cannot be shared and will be\n+ *    regenerated at exit.\n+ * 22 if base archive is not with correct version, both base and top archives will not be shared.\n+ *    At exit, there is no shared archive created automatically.\n+ *\/\n+\n@@ -80,2 +120,6 @@\n-        \/\/ 0. run with non-existing archive should automatically create dynamic archive\n-        print(\"0. run with non-existing archive should automatically create dynamic archive\");\n+        \/\/ The list numbers try to match JDK-8272331 (CSR for JDK-8261455) test items but not exactly matched.\n+\n+        \/\/ 10 non-existing archive should automatically create dynamic archive based on default shared archive\n+        \/\/ if base archive loaded.\n+        print(\"10 Test with default base shared archive\");\n+        print(\"10.1 run with non-existing archive should automatically create dynamic archive\");\n@@ -95,2 +139,2 @@\n-        \/\/ 1. run with the created dynamic archive should pass\n-        print(\"1. run with the created dynamic archive should pass\");\n+        \/\/ 10.2 run with the created dynamic archive should pass\n+        print(\"10.2 run with the created dynamic archive should pass\");\n@@ -107,2 +151,2 @@\n-        \/\/ 2. run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\n-        print(\"2. run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\");\n+        \/\/ 10.3 run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\n+        print(\"10.3 run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\");\n@@ -118,0 +162,1 @@\n+                      .shouldNotContain(\"Dumping shared data to file\")\n@@ -121,6 +166,0 @@\n-        \/\/ 3. run with a bad versioned archive should create dynamic archive\n-        print(\"3. run with a bad versioned archive should create dynamic archive\");\n-        archiveFile = new File(TOP_NAME);\n-        String modVersion = startNewArchive(\"modify-version\");\n-        File copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modVersion);\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0x00000000);\n@@ -128,1 +167,9 @@\n-        run(modVersion,\n+         \/\/ 11 run with damaged magic should not regenerate dynamic archive\n+         \/\/    The bad magic will make the archive be opened as static archive\n+         \/\/    and failed, no shared for base archive either.\n+         print(\"11 run with damaged magic should not regenerate dynamic archive\");\n+         String modMagic = startNewArchive(\"modify-magic\");\n+         File copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modMagic);\n+         CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic(), 0x1234);\n+\n+         run(modMagic,\n@@ -137,0 +184,1 @@\n+                output.shouldNotContain(\"Dumping shared data to file\");\n@@ -138,1 +186,0 @@\n-        checkFileExists(modVersion);\n@@ -140,2 +187,7 @@\n-        \/\/ 4. run with the new created archive should pass\n-        print(\"4. run with the new created archive should pass\");\n+        \/\/ 12 run with a bad versioned archive should create dynamic archive\n+        print(\"12 run with a bad versioned archive should create dynamic archive\");\n+        archiveFile = new File(TOP_NAME);\n+        String modVersion = startNewArchive(\"modify-version\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modVersion);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0x00000000);\n+\n@@ -143,0 +195,2 @@\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n@@ -144,1 +198,1 @@\n-            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=info\",\n@@ -148,2 +202,1 @@\n-                output.shouldHaveExitValue(0)\n-                      .shouldContain(HELLO_SOURCE);\n+                output.shouldHaveExitValue(0);\n@@ -151,0 +204,1 @@\n+        checkFileExists(modVersion);\n@@ -152,7 +206,6 @@\n-         \/\/ 5. run with damaged magic should not regenerate dynamic archive\n-         \/\/    The bad magic will make the archive be opened as static archive\n-         \/\/    and failed, no shared for base archive either.\n-         print(\"5. run with damaged magic should not regenerate dynamic archive\");\n-         String modMagic = startNewArchive(\"modify-magic\");\n-         copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modMagic);\n-         CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic(), 0x1234);\n+        \/\/ 13 run with a bad jvm_indent archive should create dynamic archive\n+        print(\"13 run with a bad jvm_ident archive should create dynamic archive\");\n+        archiveFile = new File(TOP_NAME);\n+        String modJvmIdent = startNewArchive(\"modify-jvmident\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modJvmIdent);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetJvmIdent(), 0x00000000);\n@@ -160,1 +213,1 @@\n-         run(modMagic,\n+        run(modJvmIdent,\n@@ -169,1 +222,0 @@\n-                output.shouldNotContain(\"Dumping shared data to file\");\n@@ -171,0 +223,1 @@\n+        checkFileExists(modJvmIdent);\n@@ -172,1 +225,1 @@\n-         \/\/ 6. read base archive from top archive failed\n+         \/\/ 14 read base archive from top archive failed\n@@ -174,2 +227,2 @@\n-         \/\/    so no shared both for static and dynamic\n-         print(\"6. read base archive from top archive failed\");\n+         \/\/    so no shared both for base and top\n+         print(\"14 read base archive from top archive failed\");\n@@ -201,2 +254,4 @@\n-         \/\/ 7. dump base archive and top archive\n-         print(\"7. dump base archive \" + BASE_NAME);\n+         \/\/ 20 Testing with -XX:SharedArchiveFile=top:base\n+         print(\"20 Testing with -XX:SharedArchiveFile=top:base\");\n+         \/\/ 20.1 dump base archive and top archive\n+         print(\"20.1 dump base archive \" + BASE_NAME);\n@@ -209,2 +264,2 @@\n-         \/\/ 8. dump top based on base\n-         print(\"8. dump top based on base\");\n+         \/\/ 20.2 dump top based on base\n+         print(\"20.2 dump top based on base\");\n@@ -220,2 +275,2 @@\n-         \/\/ 9. run with base and top\"\n-         print(\"9. run with base and top\");\n+         \/\/ 20.3 run with base and top\n+         print(\"20.3 run with base and top\");\n@@ -235,2 +290,2 @@\n-         \/\/ 10. damaged top, regenerate top\n-         print(\"10. damaged top, regenerate top\");\n+         \/\/ 21 top version is not correct, regenerate top\n+         print(\"21 top version is not correct, regenerate top\");\n@@ -253,2 +308,2 @@\n-         \/\/ 11. screw up base archive, will not generate top\n-         print(\"11. screw up base archive, will not generate top\");\n+         \/\/ 22 screw up base archive, will not generate top\n+         print(\"22 screw up base archive, will not generate top\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java","additions":96,"deletions":41,"binary":false,"changes":137,"status":"modified"}]}