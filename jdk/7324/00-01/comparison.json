{"files":[{"patch":"@@ -1523,0 +1523,1 @@\n+  static unsigned int instr_len(unsigned char  len_bits);\n@@ -1810,3 +1811,0 @@\n-  inline void emit_data(int x);\n-\n-\/\/ private:\n@@ -1817,2 +1815,1 @@\n-\n- public:\n+  inline void emit_data(int x);\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,6 +47,2 @@\n-      if (((intptr_t)pos & 0x03) == 0) {\n-        *(unsigned int*)(pos)     = (unsigned int)x;\n-      } else {\n-        *(unsigned short*)(pos)   = (unsigned short)(x>>16);\n-        *(unsigned short*)(pos+2) = (unsigned short)x;\n-      }\n+      \/\/ May be unaligned store. Only slightly less efficient.\n+      *(unsigned int*)(pos)       = (unsigned int)x;\n@@ -55,0 +51,1 @@\n+      \/\/ Have to split anyway, so we can arrange for aligned stores.\n@@ -63,1 +60,1 @@\n-    default: \/\/ This is to make the compiler happy. Can never occur.\n+    default:\n@@ -1391,3 +1388,4 @@\n-\/\/ Instruction must start at passed address.\n-inline unsigned int Assembler::instr_len(unsigned char *instr) {\n-  switch ((*instr) >> 6) {\n+\/\/ Instruction len bits must be stored right-justified in argument.\n+inline unsigned int Assembler::instr_len(unsigned char len_bits) {\n+  assert(len_bits < 4, \"bad instruction len %d\", len_bits);\n+  switch (len_bits) {\n@@ -1399,2 +1397,1 @@\n-      \/\/ Control can't reach here.\n-      \/\/ The switch expression examines just the leftmost two bytes\n+      \/\/ len_bits contains, right-justified, only the leftmost two bits\n@@ -1402,1 +1399,0 @@\n-      \/\/ Having a default clause makes the compiler happy.\n@@ -1408,0 +1404,5 @@\n+\/\/ Instruction must start at passed address.\n+inline unsigned int Assembler::instr_len(unsigned char *instr) {\n+  return instr_len((unsigned char)((*instr) >> 6));\n+}\n+\n@@ -1410,1 +1411,6 @@\n-  int len_bits = instr >> (48-2);\n+  \/\/ An instruction is 2, 4, or 6 bytes in length.\n+  \/\/ The instruction length in encoded in the leftmost two bits of the instruction.\n+  \/\/  len = 6: len_bits = [46..47]\n+  \/\/  len = 4: len_bits = [30..31]\n+  \/\/  len = 2: len_bits = [14..15]\n+  unsigned char len_bits = instr >> (48-2);\n@@ -1413,14 +1419,1 @@\n-  assert(len_bits < 4, \"bad instruction %ld\", instr);\n-  switch (len_bits) {\n-    case 0: return 2;\n-    case 1: \/\/ fallthru\n-    case 2: return 4;\n-    case 3: return 6;\n-    default:\n-      \/\/ Control can't reach here.\n-      \/\/ The switch expression examines just the leftmost two bytes\n-      \/\/ of the main opcode. So the range of values is just [0..3].\n-      \/\/ Having a default clause makes the compiler happy.\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n+  return instr_len(len_bits);\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"}]}