{"files":[{"patch":"@@ -127,3 +127,16 @@\n-\/\/ SPEC bits(M*N) Replicate(bits(M) x, integer N);\n-\/\/ this is just an educated guess\n-\n+\/\/ SPEC\n+\/\/\n+\/\/ bits(M*N) Replicate(bits(M) B, integer N);\n+\/\/\n+\/\/ given bit string B of width M (M > 0) and count N (N > 0)\n+\/\/ concatenate N copies of B to generate a bit string of width N * M\n+\/\/ (N * M <= 64)\n+\/\/\n+\/\/ inputs\n+\/\/ bits : bit string to be replicated starting from bit 0\n+\/\/ nbits : width of the bit string string passed in bits\n+\/\/ count : number of copies of bit string to be concatenated\n+\/\/\n+\/\/ result\n+\/\/ a bit string containing count copies of input bit string\n+\/\/\n@@ -151,3 +164,67 @@\n-\/\/ this function writes the supplied bimm reference and returns a\n-\/\/ boolean to indicate success (1) or fail (0) because an illegal\n-\/\/ encoding must be treated as an UNALLOC instruction\n+\/\/ construct a 64 bit immediate value for a logical immediate operation\n+\/\/\n+\/\/ SPEC:\n+\/\/\n+\/\/ {(0,_), (1, uint64)} = expandLogicalImmediate(immN, immr, imms)\n+\/\/\n+\/\/ For valid combinations of immN, immr and imms, this function\n+\/\/ replicates a derived bit string, whose width is a power of 2, into\n+\/\/ a 64 bit result and returns 1.\n+\/\/\n+\/\/ for invalid combinations it fails and returns 0\n+\/\/\n+\/\/ - immN and imms together define\n+\/\/\n+\/\/    1) the size, 2^k, of the bit string to be replicated (0 < k <= 6)\n+\/\/\n+\/\/    2) the number of bits, p, to set in the string (0 < p < 2^k)\n+\/\/\n+\/\/ - immr defines a right rotation on the bit string determined by\n+\/\/   immN and imms\n+\/\/\n+\/\/ bit field construction:\n+\/\/\n+\/\/ create a bit string of width 2^k\n+\/\/\n+\/\/ set the bottom p bits to 1\n+\/\/\n+\/\/ rotate the bit string right by immr bits\n+\/\/\n+\/\/ replicate the 2^k bit string into 64 bits\n+\/\/\n+\/\/ derivation of k and p and validity checks:\n+\/\/\n+\/\/ when immN is 1 then k == 6 and immr\/imms are masked to 6 bit\n+\/\/ integers\n+\/\/\n+\/\/ when immN is 0 then k is the index of the first 0 bit in imms and\n+\/\/ immr\/imms are masked to k-bit integers (i.e. any leading 1s and the\n+\/\/ first 0 in imms determine dead bits of imms\/immr)\n+\/\/\n+\/\/ if (pre-masking) immr >= 2^k then fail and return 0 (this is a\n+\/\/ uniqueness constraint that ensures each output bit string is only\n+\/\/ generated by one valid combination of immN, imms and immr).\n+\/\/\n+\/\/ if k == 0 then fail and return 0. Note that this means that\n+\/\/ 2^k > 1 or equivalently 2^k - 1 > 0\n+\/\/\n+\/\/ If imms == all 1s (modulo 2^k) then fail and return 0. Note that\n+\/\/ this means that 0 <= imms < 2^k - 1\n+\/\/\n+\/\/ set p = imms + 1. Consequently, 0 < p < 2^k which is the condition\n+\/\/ that an all 0s or all 1s bit pattern is never generated.\n+\/\/\n+\/\/ example output:\n+\/\/\n+\/\/   11001111_11001111_11001111_11001111_11001111_11001111_11001111_11001111\n+\/\/\n+\/\/ which corresponds to the inputs\n+\/\/\n+\/\/   immN = 0, imms = 110101, immr = 000010\n+\/\/\n+\/\/ For these inputs k = 3,  2^k = 8, p = 6, rotation = 2\n+\/\/\n+\/\/ implementation note:\n+\/\/\n+\/\/ For historical reasons the implementation of this function is much\n+\/\/ more convoluted than is really necessary.\n@@ -155,1 +232,0 @@\n-\/\/ construct a 32 bit immediate value for a logical immediate operation\n","filename":"src\/hotspot\/cpu\/aarch64\/immediate_aarch64.cpp","additions":83,"deletions":7,"binary":false,"changes":90,"status":"modified"}]}