{"files":[{"patch":"@@ -327,2 +327,5 @@\n-        if (!hasGenericInformation()) {\n-            return getSharedParameterTypes();\n+        if (hasGenericInformation()) {\n+            var genericParameterTypes = getGenericInfo().getParameterTypes();\n+            if (genericParameterTypes.length == matchedParameterCount()) {\n+                return matchParameters(genericParameterTypes, e -> e, false);\n+            }\n@@ -330,4 +333,2 @@\n-        var genericParameterTypes = getGenericInfo().getParameterTypes();\n-        var attempt = mapParameters(genericParameterTypes, e -> e, false);\n-        \/\/ attempt == null -> MethodParameters and Signature disagreement, happens on old compiler\n-        return attempt != null ? attempt : getSharedParameterTypes();\n+\n+        return getSharedParameterTypes();\n@@ -429,0 +430,2 @@\n+        \/\/ mappings is declaration in source index -> formal index\n+        \/\/ empty if there's no mandated\/synthetic params, i.e. 1-on-1 mapping\n@@ -433,3 +436,0 @@\n-    private static final Type[] INVALID_ANNOTATED_TYPE_BASE = new Type[0];\n-    private transient @Stable Type[] annotatedTypeBase;\n-\n@@ -437,1 +437,2 @@\n-     * Return an array of explicit-only parameter types that type annotations can build on.\n+     * Returns the number of explicit parameters we anticipate from MethodParameters\n+     * attribute.\n@@ -439,33 +440,3 @@\n-    private Type[] sharedAnnotatedTypeBase() {\n-        var annotatedTypeBase = this.annotatedTypeBase;\n-        if (annotatedTypeBase != null) {\n-            return annotatedTypeBase;\n-        }\n-\n-        if (!hasGenericInformation()) {\n-            return this.annotatedTypeBase = computeExplicitParameterTypes();\n-        }\n-\n-        if (getAllGenericParameterTypes() == getSharedParameterTypes()) {\n-            \/\/ Signature and MethodParameters information in disagreement\n-            return this.annotatedTypeBase = INVALID_ANNOTATED_TYPE_BASE;\n-        }\n-\n-        return this.annotatedTypeBase = getGenericInfo().getParameterTypes();\n-    }\n-\n-    \/\/ Computes the explicit parameter types. Useful when there is no Signature\n-    \/\/ but synthetic or mandated parameters are present in MethodParameters\n-    private Class<?>[] computeExplicitParameterTypes() {\n-        int[] mappings = parameterData().mappings;\n-        var sharedParamTypes = getSharedParameterTypes();\n-        if (mappings.length == 0) {\n-            return sharedParamTypes;\n-        }\n-\n-        var explicitParameterTypes = new Class<?>[mappings.length];\n-        for (int i = 0; i < mappings.length; i++) {\n-            explicitParameterTypes[i] = sharedParamTypes[mappings[i]];\n-        }\n-\n-        return explicitParameterTypes;\n+    int matchedParameterCount() {\n+        final int[] mappings = parameterData().mappings;\n+        return mappings.length == 0 ? getParameterCount() : mappings.length;\n@@ -476,2 +447,2 @@\n-     * using information from MethodParameters attribute. Returns null if parameter\n-     * mapping failed due to lack of MethodParameters or conflict with MethodParameters.\n+     * using information from MethodParameters attribute. Guard calls checks to\n+     * {@code matchedParameterCount() == explicit.length}.\n@@ -483,1 +454,1 @@\n-     * @return information about all parameters, null if parameter mapping failed.\n+     * @return information about all parameters\n@@ -485,21 +456,4 @@\n-    <T> T[] mapParameters(final T[] explicit, Function<Class<?>, T> implicitMapper, boolean freshCopy) {\n-        \/\/ declaration in source index -> formal index\n-        \/\/ empty if there's no mandated\/synthetic params, i.e. 1-on-1 mapping\n-        final int[] mappings = parameterData().mappings;\n-        final Class<?>[] allParams = getSharedParameterTypes();\n-        final int totalLength = allParams.length;\n-\n-        if (!hasRealParameterData()) {\n-            \/\/ no real parameter data, but can still safely return if length is compatible\n-            return explicit.length == totalLength ? (freshCopy ? explicit.clone() : explicit) : null;\n-        }\n-\n-        final int mappingsLength = mappings == ParameterData.TRIVIAL_MAPPINGS ? totalLength : mappings.length;\n-\n-        if (explicit.length != mappingsLength) {\n-            \/\/ Parameter mapping invalid, no way to match up the indexes.\n-            return null;\n-        }\n-\n-        \/\/ Parameter mapping is valid\n-        if (mappingsLength == totalLength) {\n+    <T> T[] matchParameters(final T[] explicit, Function<Class<?>, T> implicitMapper, boolean freshCopy) {\n+        final int matchedCount = matchedParameterCount();\n+        assert matchedCount == explicit.length;\n+        if (matchedCount == getParameterCount()) {\n@@ -510,0 +464,5 @@\n+        \/\/ perform shifting\n+        final int[] mappings = parameterData().mappings;\n+        final Class<?>[] allParams = getSharedParameterTypes();\n+        final int fullCount = allParams.length;\n+\n@@ -511,1 +470,1 @@\n-        final T[] out = (T[]) Array.newInstance(explicit.getClass().componentType(), totalLength);\n+        final T[] out = (T[]) Array.newInstance(explicit.getClass().componentType(), fullCount);\n@@ -513,1 +472,1 @@\n-        for (int i = 0; i < mappingsLength; i++) {\n+        for (int i = 0; i < matchedCount; i++) {\n@@ -523,1 +482,1 @@\n-        while (j < totalLength) {\n+        while (j < fullCount) {\n@@ -653,3 +612,2 @@\n-        var attempt = mapParameters(result, e -> AnnotationParser.getEmptyAnnotationArray(), false);\n-        if (attempt != null) {\n-            return attempt;\n+        if (result.length == matchedParameterCount()) {\n+            return matchParameters(result, e -> AnnotationParser.getEmptyAnnotationArray(), false);\n@@ -838,1 +796,1 @@\n-        var annotatedTypeBase = sharedAnnotatedTypeBase();\n+        var annotatedTypeBase = annotatedParameterTypesBase();\n@@ -840,0 +798,1 @@\n+            assert annotatedTypeBase.length == matchedParameterCount();\n@@ -848,5 +807,1 @@\n-            var attempt = mapParameters(unmapped, AnnotatedTypeFactory::simple, false);\n-            if (attempt != null)\n-                return attempt;\n-            assert false : \"annotated type base should have been validated\";\n-            \/\/ Fallback to old routine\n+            return matchParameters(unmapped, AnnotatedTypeFactory::simple, false);\n@@ -864,0 +819,45 @@\n+    private static final Type[] INVALID_ANNOTATED_TYPE_BASE = new Type[0];\n+    private transient @Stable Type[] annotatedParameterTypesBase;\n+\n+    \/**\n+     * Return an array of explicit-only parameter types that type annotations can build on.\n+     *\/\n+    private Type[] annotatedParameterTypesBase() {\n+        var annotatedTypeBase = this.annotatedParameterTypesBase;\n+        if (annotatedTypeBase != null) {\n+            return annotatedTypeBase;\n+        }\n+\n+        if (!hasRealParameterData()) {\n+            \/\/ Cannot assume anything without MethodParameters\n+            return this.annotatedParameterTypesBase = INVALID_ANNOTATED_TYPE_BASE;\n+        }\n+\n+        if (!hasGenericInformation()) {\n+            return this.annotatedParameterTypesBase = computeExplicitParameterTypes();\n+        }\n+\n+        var genericInfoParams = getGenericInfo().getParameterTypes();\n+        return this.annotatedParameterTypesBase = genericInfoParams.length == matchedParameterCount()\n+                ? genericInfoParams : INVALID_ANNOTATED_TYPE_BASE;\n+    }\n+\n+    \/**\n+     * Computes the explicit parameter types. Useful when there is no Signature\n+     * but synthetic or mandated parameters are present in MethodParameters.\n+     *\/\n+    private Class<?>[] computeExplicitParameterTypes() {\n+        int[] mappings = parameterData().mappings;\n+        var sharedParamTypes = getSharedParameterTypes();\n+        if (mappings.length == 0) {\n+            return sharedParamTypes;\n+        }\n+\n+        var explicitParameterTypes = new Class<?>[mappings.length];\n+        for (int i = 0; i < mappings.length; i++) {\n+            explicitParameterTypes[i] = sharedParamTypes[mappings[i]];\n+        }\n+\n+        return explicitParameterTypes;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":79,"deletions":79,"binary":false,"changes":158,"status":"modified"}]}