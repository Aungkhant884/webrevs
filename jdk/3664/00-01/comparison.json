{"files":[{"patch":"@@ -377,10 +377,2 @@\n-                        synchronized (sessionCache) {\n-                            s = sessionCache.get(requestedId.identity);\n-\n-                            if (s != null && canRejoin(clientHello, shc, s)) {\n-                                \/\/ The session can't be resumed again---remove it from cache\n-                                sessionCache.remove(s.getSessionId());\n-                            } else {\n-                                s = null;\n-                            }\n-                        }\n+                        s = sessionCache.consumeRejoinableSession(\n+                                clientHello, shc, requestedId.identity);\n@@ -396,1 +388,1 @@\n-                                if (!canRejoin(clientHello, shc, s)) {\n+                                if (!s.canRejoin(clientHello, shc)) {\n@@ -438,86 +430,0 @@\n-    private static boolean canRejoin(ClientHelloMessage clientHello,\n-        ServerHandshakeContext shc, SSLSessionImpl s) {\n-\n-        boolean result = s.isRejoinable() && (s.getPreSharedKey() != null);\n-\n-        \/\/ Check protocol version\n-        if (result && s.getProtocolVersion() != shc.negotiatedProtocol) {\n-            if (SSLLogger.isOn &&\n-                SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n-\n-                SSLLogger.finest(\"Can't resume, incorrect protocol version\");\n-            }\n-            result = false;\n-        }\n-\n-        \/\/ Make sure that the server handshake context's localSupportedSignAlgs\n-        \/\/ field is populated.  This is particularly important when\n-        \/\/ client authentication was used in an initial session and it is\n-        \/\/ now being resumed.\n-        if (shc.localSupportedSignAlgs == null) {\n-            shc.localSupportedSignAlgs =\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints, shc.activeProtocols);\n-        }\n-\n-        \/\/ Validate the required client authentication.\n-        if (result &&\n-            (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED)) {\n-            try {\n-                s.getPeerPrincipal();\n-            } catch (SSLPeerUnverifiedException e) {\n-                if (SSLLogger.isOn &&\n-                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n-                    SSLLogger.finest(\n-                        \"Can't resume, \" +\n-                        \"client authentication is required\");\n-                }\n-                result = false;\n-            }\n-\n-            \/\/ Make sure the list of supported signature algorithms matches\n-            Collection<SignatureScheme> sessionSigAlgs =\n-                s.getLocalSupportedSignatureSchemes();\n-            if (result &&\n-                !shc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {\n-\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\"Can't resume. Session uses different \" +\n-                        \"signature algorithms\");\n-                }\n-                result = false;\n-            }\n-        }\n-\n-        \/\/ ensure that the endpoint identification algorithm matches the\n-        \/\/ one in the session\n-        String identityAlg = shc.sslConfig.identificationProtocol;\n-        if (result && identityAlg != null) {\n-            String sessionIdentityAlg = s.getIdentificationProtocol();\n-            if (!identityAlg.equalsIgnoreCase(sessionIdentityAlg)) {\n-                if (SSLLogger.isOn &&\n-                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n-\n-                    SSLLogger.finest(\"Can't resume, endpoint id\" +\n-                        \" algorithm does not match, requested: \" +\n-                        identityAlg + \", cached: \" + sessionIdentityAlg);\n-                }\n-                result = false;\n-            }\n-        }\n-\n-        \/\/ Ensure cipher suite can be negotiated\n-        if (result && (!shc.isNegotiable(s.getSuite()) ||\n-            !clientHello.cipherSuites.contains(s.getSuite()))) {\n-            if (SSLLogger.isOn &&\n-                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n-                SSLLogger.finest(\n-                    \"Can't resume, unavailable session cipher suite\");\n-            }\n-            result = false;\n-        }\n-\n-        return result;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":3,"deletions":97,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -65,0 +66,2 @@\n+    private final ReentrantLock sessionCacheLock = new ReentrantLock();\n+\n@@ -98,0 +101,7 @@\n+        sessionCacheLock.lock();\n+        try {\n+            return getSession(new SessionId(sessionId));\n+        } finally {\n+            sessionCacheLock.unlock();\n+        }\n+    }\n@@ -99,1 +109,2 @@\n-        SSLSessionImpl sess = sessionCache.get(new SessionId(sessionId));\n+    private SSLSessionImpl getSession(SessionId sessionId) {\n+        SSLSessionImpl sess = sessionCache.get(sessionId);\n@@ -103,1 +114,0 @@\n-\n@@ -106,1 +116,0 @@\n-\n@@ -220,0 +229,15 @@\n+    \/\/ extract cached session if it is rejoinable\n+    SSLSessionImpl consumeRejoinableSession(ClientHello.ClientHelloMessage clientHello,\n+                                  ServerHandshakeContext shc, byte[] id) {\n+        sessionCacheLock.lock();\n+        try {\n+            SSLSessionImpl s = getSession(new SessionId(id));\n+            if (s != null && s.canRejoin(clientHello, shc)) {\n+                remove(s);\n+            }\n+            return s;\n+        } finally {\n+            sessionCacheLock.unlock();\n+        }\n+    }\n+\n@@ -222,5 +246,8 @@\n-        SSLSessionImpl s = sessionCache.get(key);\n-        if (s != null) {\n-            sessionCache.remove(key);\n-            sessionHostPortCache.remove(\n-                    getKey(s.getPeerHost(), s.getPeerPort()));\n+        sessionCacheLock.lock();\n+        try {\n+            SSLSessionImpl s = sessionCache.get(key);\n+            if (s != null) {\n+                remove(s);\n+            }\n+        } finally {\n+            sessionCacheLock.unlock();\n@@ -230,0 +257,7 @@\n+    \/\/ remove a cached SSLSession\n+    private void remove(SSLSessionImpl s) {\n+        sessionCache.remove(s.getSessionId());\n+        sessionHostPortCache.remove(\n+                getKey(s.getPeerHost(), s.getPeerPort()));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":42,"deletions":8,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;\n+\n@@ -1523,0 +1525,87 @@\n+\n+    boolean canRejoin(ClientHello.ClientHelloMessage clientHello,\n+                                     ServerHandshakeContext shc) {\n+\n+        boolean result = isRejoinable() && (getPreSharedKey() != null);\n+\n+        \/\/ Check protocol version\n+        if (result && getProtocolVersion() != shc.negotiatedProtocol) {\n+            if (SSLLogger.isOn &&\n+                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+\n+                SSLLogger.finest(\"Can't resume, incorrect protocol version\");\n+            }\n+            result = false;\n+        }\n+\n+        \/\/ Make sure that the server handshake context's localSupportedSignAlgs\n+        \/\/ field is populated.  This is particularly important when\n+        \/\/ client authentication was used in an initial session and it is\n+        \/\/ now being resumed.\n+        if (shc.localSupportedSignAlgs == null) {\n+            shc.localSupportedSignAlgs =\n+                    SignatureScheme.getSupportedAlgorithms(\n+                            shc.sslConfig,\n+                            shc.algorithmConstraints, shc.activeProtocols);\n+        }\n+\n+        \/\/ Validate the required client authentication.\n+        if (result &&\n+                (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED)) {\n+            try {\n+                getPeerPrincipal();\n+            } catch (SSLPeerUnverifiedException e) {\n+                if (SSLLogger.isOn &&\n+                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                    SSLLogger.finest(\n+                            \"Can't resume, \" +\n+                                    \"client authentication is required\");\n+                }\n+                result = false;\n+            }\n+\n+            \/\/ Make sure the list of supported signature algorithms matches\n+            Collection<SignatureScheme> sessionSigAlgs =\n+                    getLocalSupportedSignatureSchemes();\n+            if (result &&\n+                    !shc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Can't resume. Session uses different \" +\n+                            \"signature algorithms\");\n+                }\n+                result = false;\n+            }\n+        }\n+\n+        \/\/ ensure that the endpoint identification algorithm matches the\n+        \/\/ one in the session\n+        String identityAlg = shc.sslConfig.identificationProtocol;\n+        if (result && identityAlg != null) {\n+            String sessionIdentityAlg = getIdentificationProtocol();\n+            if (!identityAlg.equalsIgnoreCase(sessionIdentityAlg)) {\n+                if (SSLLogger.isOn &&\n+                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+\n+                    SSLLogger.finest(\"Can't resume, endpoint id\" +\n+                            \" algorithm does not match, requested: \" +\n+                            identityAlg + \", cached: \" + sessionIdentityAlg);\n+                }\n+                result = false;\n+            }\n+        }\n+\n+        \/\/ Ensure cipher suite can be negotiated\n+        if (result && (!shc.isNegotiable(getSuite()) ||\n+                !clientHello.cipherSuites.contains(getSuite()))) {\n+            if (SSLLogger.isOn &&\n+                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                SSLLogger.finest(\n+                        \"Can't resume, unavailable session cipher suite\");\n+            }\n+            result = false;\n+        }\n+\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"}]}