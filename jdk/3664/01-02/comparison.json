{"files":[{"patch":"@@ -372,0 +372,1 @@\n+                SSLSessionImpl s = null;\n@@ -374,1 +375,0 @@\n-                    SSLSessionImpl s = null;\n@@ -377,5 +377,6 @@\n-                        s = sessionCache.consumeRejoinableSession(\n-                                clientHello, shc, requestedId.identity);\n-                    } else if (requestedId.identity.length > SessionId.MAX_LENGTH &&\n-                                sessionCache.statelessEnabled()) {\n-                        \/\/ Identity is a stateless ticket\n+                        s = sessionCache.pull(requestedId.identity);\n+                    }\n+                    \/\/ See if the identity is a stateless ticket\n+                    if (s == null &&\n+                            requestedId.identity.length > SessionId.MAX_LENGTH &&\n+                            sessionCache.statelessEnabled()) {\n@@ -383,1 +384,1 @@\n-                                new SessionTicketSpec(shc, requestedId.identity).\n+                            new SessionTicketSpec(shc, requestedId.identity).\n@@ -388,3 +389,0 @@\n-                                if (!s.canRejoin(clientHello, shc)) {\n-                                    s = null;\n-                                }\n@@ -403,1 +401,2 @@\n-                    if (s != null) {\n+\n+                    if (s != null && canRejoin(clientHello, shc, s)) {\n@@ -430,0 +429,86 @@\n+    private static boolean canRejoin(ClientHelloMessage clientHello,\n+        ServerHandshakeContext shc, SSLSessionImpl s) {\n+\n+        boolean result = s.isRejoinable() && (s.getPreSharedKey() != null);\n+\n+        \/\/ Check protocol version\n+        if (result && s.getProtocolVersion() != shc.negotiatedProtocol) {\n+            if (SSLLogger.isOn &&\n+                SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+\n+                SSLLogger.finest(\"Can't resume, incorrect protocol version\");\n+            }\n+            result = false;\n+        }\n+\n+        \/\/ Make sure that the server handshake context's localSupportedSignAlgs\n+        \/\/ field is populated.  This is particularly important when\n+        \/\/ client authentication was used in an initial session and it is\n+        \/\/ now being resumed.\n+        if (shc.localSupportedSignAlgs == null) {\n+            shc.localSupportedSignAlgs =\n+                    SignatureScheme.getSupportedAlgorithms(\n+                            shc.sslConfig,\n+                            shc.algorithmConstraints, shc.activeProtocols);\n+        }\n+\n+        \/\/ Validate the required client authentication.\n+        if (result &&\n+            (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED)) {\n+            try {\n+                s.getPeerPrincipal();\n+            } catch (SSLPeerUnverifiedException e) {\n+                if (SSLLogger.isOn &&\n+                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                    SSLLogger.finest(\n+                        \"Can't resume, \" +\n+                        \"client authentication is required\");\n+                }\n+                result = false;\n+            }\n+\n+            \/\/ Make sure the list of supported signature algorithms matches\n+            Collection<SignatureScheme> sessionSigAlgs =\n+                s.getLocalSupportedSignatureSchemes();\n+            if (result &&\n+                !shc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Can't resume. Session uses different \" +\n+                        \"signature algorithms\");\n+                }\n+                result = false;\n+            }\n+        }\n+\n+        \/\/ ensure that the endpoint identification algorithm matches the\n+        \/\/ one in the session\n+        String identityAlg = shc.sslConfig.identificationProtocol;\n+        if (result && identityAlg != null) {\n+            String sessionIdentityAlg = s.getIdentificationProtocol();\n+            if (!identityAlg.equalsIgnoreCase(sessionIdentityAlg)) {\n+                if (SSLLogger.isOn &&\n+                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+\n+                    SSLLogger.finest(\"Can't resume, endpoint id\" +\n+                        \" algorithm does not match, requested: \" +\n+                        identityAlg + \", cached: \" + sessionIdentityAlg);\n+                }\n+                result = false;\n+            }\n+        }\n+\n+        \/\/ Ensure cipher suite can be negotiated\n+        if (result && (!shc.isNegotiable(s.getSuite()) ||\n+            !clientHello.cipherSuites.contains(s.getSuite()))) {\n+            if (SSLLogger.isOn &&\n+                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                SSLLogger.finest(\n+                    \"Can't resume, unavailable session cipher suite\");\n+            }\n+            result = false;\n+        }\n+\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":96,"deletions":11,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -66,2 +65,0 @@\n-    private final ReentrantLock sessionCacheLock = new ReentrantLock();\n-\n@@ -101,7 +98,0 @@\n-        sessionCacheLock.lock();\n-        try {\n-            return getSession(new SessionId(sessionId));\n-        } finally {\n-            sessionCacheLock.unlock();\n-        }\n-    }\n@@ -109,2 +99,1 @@\n-    private SSLSessionImpl getSession(SessionId sessionId) {\n-        SSLSessionImpl sess = sessionCache.get(sessionId);\n+        SSLSessionImpl sess = sessionCache.get(new SessionId(sessionId));\n@@ -114,0 +103,1 @@\n+\n@@ -116,0 +106,1 @@\n+\n@@ -187,0 +178,8 @@\n+    \/\/ package-private method, find and remove session from cache\n+    \/\/ return found session\n+    SSLSessionImpl pull(byte[] id) {\n+        if (id != null)\n+            return sessionCache.pull(new SessionId(id));\n+        return null;\n+    }\n+\n@@ -229,15 +228,0 @@\n-    \/\/ extract cached session if it is rejoinable\n-    SSLSessionImpl consumeRejoinableSession(ClientHello.ClientHelloMessage clientHello,\n-                                  ServerHandshakeContext shc, byte[] id) {\n-        sessionCacheLock.lock();\n-        try {\n-            SSLSessionImpl s = getSession(new SessionId(id));\n-            if (s != null && s.canRejoin(clientHello, shc)) {\n-                remove(s);\n-            }\n-            return s;\n-        } finally {\n-            sessionCacheLock.unlock();\n-        }\n-    }\n-\n@@ -246,8 +230,5 @@\n-        sessionCacheLock.lock();\n-        try {\n-            SSLSessionImpl s = sessionCache.get(key);\n-            if (s != null) {\n-                remove(s);\n-            }\n-        } finally {\n-            sessionCacheLock.unlock();\n+        SSLSessionImpl s = sessionCache.get(key);\n+        if (s != null) {\n+            sessionCache.remove(key);\n+            sessionHostPortCache.remove(\n+                    getKey(s.getPeerHost(), s.getPeerPort()));\n@@ -257,7 +238,0 @@\n-    \/\/ remove a cached SSLSession\n-    private void remove(SSLSessionImpl s) {\n-        sessionCache.remove(s.getSessionId());\n-        sessionHostPortCache.remove(\n-                getKey(s.getPeerHost(), s.getPeerPort()));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":16,"deletions":42,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;\n-\n@@ -1525,87 +1523,0 @@\n-\n-    boolean canRejoin(ClientHello.ClientHelloMessage clientHello,\n-                                     ServerHandshakeContext shc) {\n-\n-        boolean result = isRejoinable() && (getPreSharedKey() != null);\n-\n-        \/\/ Check protocol version\n-        if (result && getProtocolVersion() != shc.negotiatedProtocol) {\n-            if (SSLLogger.isOn &&\n-                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n-\n-                SSLLogger.finest(\"Can't resume, incorrect protocol version\");\n-            }\n-            result = false;\n-        }\n-\n-        \/\/ Make sure that the server handshake context's localSupportedSignAlgs\n-        \/\/ field is populated.  This is particularly important when\n-        \/\/ client authentication was used in an initial session and it is\n-        \/\/ now being resumed.\n-        if (shc.localSupportedSignAlgs == null) {\n-            shc.localSupportedSignAlgs =\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints, shc.activeProtocols);\n-        }\n-\n-        \/\/ Validate the required client authentication.\n-        if (result &&\n-                (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED)) {\n-            try {\n-                getPeerPrincipal();\n-            } catch (SSLPeerUnverifiedException e) {\n-                if (SSLLogger.isOn &&\n-                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n-                    SSLLogger.finest(\n-                            \"Can't resume, \" +\n-                                    \"client authentication is required\");\n-                }\n-                result = false;\n-            }\n-\n-            \/\/ Make sure the list of supported signature algorithms matches\n-            Collection<SignatureScheme> sessionSigAlgs =\n-                    getLocalSupportedSignatureSchemes();\n-            if (result &&\n-                    !shc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {\n-\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\"Can't resume. Session uses different \" +\n-                            \"signature algorithms\");\n-                }\n-                result = false;\n-            }\n-        }\n-\n-        \/\/ ensure that the endpoint identification algorithm matches the\n-        \/\/ one in the session\n-        String identityAlg = shc.sslConfig.identificationProtocol;\n-        if (result && identityAlg != null) {\n-            String sessionIdentityAlg = getIdentificationProtocol();\n-            if (!identityAlg.equalsIgnoreCase(sessionIdentityAlg)) {\n-                if (SSLLogger.isOn &&\n-                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n-\n-                    SSLLogger.finest(\"Can't resume, endpoint id\" +\n-                            \" algorithm does not match, requested: \" +\n-                            identityAlg + \", cached: \" + sessionIdentityAlg);\n-                }\n-                result = false;\n-            }\n-        }\n-\n-        \/\/ Ensure cipher suite can be negotiated\n-        if (result && (!shc.isNegotiable(getSuite()) ||\n-                !clientHello.cipherSuites.contains(getSuite()))) {\n-            if (SSLLogger.isOn &&\n-                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n-                SSLLogger.finest(\n-                        \"Can't resume, unavailable session cipher suite\");\n-            }\n-            result = false;\n-        }\n-\n-        return result;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -103,0 +103,5 @@\n+    \/**\n+     * Pull an entry from the cache.\n+     *\/\n+    public abstract V pull(Object key);\n+\n@@ -227,0 +232,4 @@\n+    public V pull(Object key) {\n+        return null;\n+    }\n+\n@@ -415,0 +424,20 @@\n+    public synchronized V pull(Object key) {\n+        emptyQueue();\n+        CacheEntry<K,V> entry = cacheMap.remove(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        V value;\n+        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+        if (entry.isValid(time)) {\n+            value = entry.getValue();\n+        } else {\n+            if (DEBUG) {\n+                System.out.println(\"Ignoring expired entry\");\n+            }\n+            value = null;\n+        }\n+        entry.invalidate();\n+        return value;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}