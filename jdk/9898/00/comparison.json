{"files":[{"patch":"@@ -2368,0 +2368,2 @@\n+  bool is_dependent = dependent_on_last_mem(last_mem, pk);\n+\n@@ -2374,4 +2376,4 @@\n-        \/\/ A later store depends on this load, pick the memory state of the first load. This can happen, for example,\n-        \/\/ if a load pack has interleaving stores that are part of a store pack which, however, is removed at the pack\n-        \/\/ filtering stage. This leaves us with only a load pack for which we cannot take the memory state of the\n-        \/\/ last load as the remaining unvectorized stores could interfere since they have a dependency to the loads.\n+        \/\/ A later unvectorized store depends on this load, pick the memory state of the first load. This can happen,\n+        \/\/ for example, if a load pack has interleaving stores that are part of a store pack which, however, is removed\n+        \/\/ at the pack filtering stage. This leaves us with only a load pack for which we cannot take the memory state\n+        \/\/ of the last load as the remaining unvectorized stores could interfere since they have a dependency to the loads.\n@@ -2380,0 +2382,5 @@\n+        if(my_pack(current) != NULL && is_dependent) {\n+          \/\/ For vectorized store pack, when the load pack depends on\n+          \/\/ last_mem, we still take the memory state of the last load.\n+          continue;\n+        }\n@@ -2425,0 +2432,16 @@\n+\/\/ Determine if the load pack is dependent on the last_mem.\n+bool SuperWord::dependent_on_last_mem(Node* last_mem, Node_List* pk) {\n+  if (!last_mem->is_Mem() || !in_bb(last_mem)) {\n+    return false;\n+  }\n+\n+  for (uint i = 0; i < pk->size(); i++) {\n+    Node* ld = pk->at(i);\n+    if (ld->in(MemNode::Memory) == last_mem && !independent(last_mem, ld)) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -552,0 +552,2 @@\n+  \/\/ Determine if the load pack is dependent on the last_mem.\n+  bool dependent_on_last_mem(Node* last_mem, Node_List* pk);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test\n+ * @requires vm.compiler2.enabled\n+ * @bug 8290910\n+ * @summary Test which needs to select the memory state of the last load in a load pack in SuperWord::co_locate_pack.\n+ *\n+ * @run main\/othervm -Xcomp -Xbatch -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestPickLastMemoryState::*\n+ *                   compiler.loopopts.superword.TestPickLastMemoryState\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestPickLastMemoryState {\n+    static final int N = 400;\n+    static long lArrFld[] = new long[N];\n+    static long iMeth_check_sum;\n+    static long[] golden_sum = {22154, 44050, 66167, 88359, 110684, 132686, 154755, 176703, 198872, 220874};\n+\n+    static void iMeth() {\n+        int i1 , i2 = -222, iArr[] = new int[N];\n+        init(iArr, 212);\n+        \/\/ For the following loop, statement 1 can be vectorized but statement 2 can't. When\n+        \/\/ finding the memory state for the LoadI pack, we cannot pick the memory state from\n+        \/\/ the first load as the LoadI vector operation must load the memory after iArr writes\n+        \/\/ 'iArr[i1 + 1] - (i2++)' to 'iArr[i1 + 1]'. We must take the memory state of the last\n+        \/\/ load where we have assigned new values ('iArr[i1 + 1] - (i2++)') to the iArr array.\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1] += lArrFld[i1]++; \/\/ statement 1\n+            iArr[i1 + 1] -= (i2++); \/\/ statement 2\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    static long checkSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += (a[j] \/ (j + 1) + a[j] % (j + 1));\n+        }\n+        return sum;\n+    }\n+\n+    static void reset() {\n+        for (int i = 0; i < N; i++) {\n+            lArrFld[i] = 0;\n+        }\n+        iMeth_check_sum = 0;\n+    }\n+\n+    static void test() {\n+        for (int i = 0; i < 10; i++) {\n+            iMeth();\n+            if (iMeth_check_sum != golden_sum[i]) {\n+                throw new RuntimeException(\"iMeth wrong result at \" + i + \": \" + iMeth_check_sum);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 5_000; i++) {\n+            reset();\n+            test();\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestPickLastMemoryState.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}