{"files":[{"patch":"@@ -2366,1 +2366,2 @@\n-  Node* last_mem  = find_last_mem_state(pk, first_mem);\n+  bool is_dependent = false;\n+  Node* last_mem  = find_last_mem_state(pk, first_mem, is_dependent);\n@@ -2374,4 +2375,4 @@\n-        \/\/ A later store depends on this load, pick the memory state of the first load. This can happen, for example,\n-        \/\/ if a load pack has interleaving stores that are part of a store pack which, however, is removed at the pack\n-        \/\/ filtering stage. This leaves us with only a load pack for which we cannot take the memory state of the\n-        \/\/ last load as the remaining unvectorized stores could interfere since they have a dependency to the loads.\n+        \/\/ A later unvectorized store depends on this load, pick the memory state of the first load. This can happen,\n+        \/\/ for example, if a load pack has interleaving stores that are part of a store pack which, however, is removed\n+        \/\/ at the pack filtering stage. This leaves us with only a load pack for which we cannot take the memory state\n+        \/\/ of the last load as the remaining unvectorized stores could interfere since they have a dependency to the loads.\n@@ -2380,0 +2381,6 @@\n+        if (my_pack(current) != NULL && is_dependent) {\n+          \/\/ For vectorized store pack, when the load pack depends on\n+          \/\/ some memory operations locating after first_mem, we still\n+          \/\/ take the memory state of the last load.\n+          continue;\n+        }\n@@ -2410,2 +2417,4 @@\n-\/\/ the load we started from is the last load.\n-Node* SuperWord::find_last_mem_state(Node_List* pk, Node* first_mem) {\n+\/\/ the load we started from is the last load. At the same time, the\n+\/\/ function also helps determine if some loads in the pack depend on\n+\/\/ early memory operations which locate after first_mem.\n+Node* SuperWord::find_last_mem_state(Node_List* pk, Node* first_mem, bool &is_dependent) {\n@@ -2417,0 +2426,2 @@\n+      \/\/ Determine if the load pack is dependent on some memory operations locating after first_mem.\n+      is_dependent |= !independent(current, ld);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -551,1 +551,1 @@\n-  Node* find_last_mem_state(Node_List* pk, Node* first_mem);\n+  Node* find_last_mem_state(Node_List* pk, Node* first_mem, bool &is_dependent);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test\n+ * @requires vm.compiler2.enabled\n+ * @bug 8290910 8293216\n+ * @summary Test which needs to select the memory state of the last load in a load pack in SuperWord::co_locate_pack.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=compiler\/loopopts\/superword\/TestPickLastMemoryState\n+ *                   -Xbatch -XX:MaxVectorSize=16 compiler.loopopts.superword.TestPickLastMemoryState\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=compiler\/loopopts\/superword\/TestPickLastMemoryState\n+ *                   -Xbatch -XX:MaxVectorSize=32 compiler.loopopts.superword.TestPickLastMemoryState\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=compiler\/loopopts\/superword\/TestPickLastMemoryState\n+ *                   -Xbatch compiler.loopopts.superword.TestPickLastMemoryState\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestPickLastMemoryState {\n+    static final int N = 400;\n+    static final int M = 32;\n+    static long lArrFld[] = new long[N];\n+    static long iMeth_check_sum;\n+    static float a[] = new float[M];\n+\n+    static void f() {\n+        int b[] = new int[M];\n+        for (int h = 1; h < 32; h++) {\n+            a[h] = b[h - 1]--;\n+            b[h]--;\n+        }\n+        boolean c[] = new boolean[M];\n+    }\n+\n+    static void test0() throws Exception {\n+        f();\n+        double s = checkSum(a);\n+        System.out.println(s);\n+        if (s < -31 || s > -29) {\n+            throw new Exception(\"expected s: -30, actual s: \" + s);\n+        }\n+    }\n+\n+    static void test1() {\n+        int i1 , i2 = -222, iArr[] = new int[N];\n+        init(iArr, 212);\n+        \/\/ For the following loop, statement 1 can be vectorized but statement 2 can't. When\n+        \/\/ finding the memory state for the LoadI pack, we cannot pick the memory state from\n+        \/\/ the first load as the LoadI vector operation must load the memory after iArr writes\n+        \/\/ 'iArr[i1 + 1] - (i2++)' to 'iArr[i1 + 1]'. We must take the memory state of the last\n+        \/\/ load where we have assigned new values ('iArr[i1 + 1] - (i2++)') to the iArr array.\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1] += lArrFld[i1]++; \/\/ statement 1\n+            iArr[i1 + 1] -= (i2++); \/\/ statement 2\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test2() {\n+        int i1 , i2 = -222, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1] += lArrFld[i1]++;\n+            iArr[i1 + 2] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test3() {\n+        int i1 , i2 = -222, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1-2] += lArrFld[i1]++;\n+            iArr[i1] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test4() {\n+        int i1 , i2 = -222, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1-3] += lArrFld[i1]++;\n+            iArr[i1] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test5() {\n+        int i1 , i2 = -222, i3 = -100, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1] += lArrFld[i1]++;\n+            iArr[i1+2] -= (i3++);\n+            iArr[i1+16] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test6() {\n+        int i1 , i2 = -222, i3 = -100, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1] += lArrFld[i1]++;\n+            iArr[i1+1] -= (i3++);\n+            iArr[i1+32] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    static long checkSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += (a[j] \/ (j + 1) + a[j] % (j + 1));\n+        }\n+        return sum;\n+    }\n+\n+    static double checkSum(float[] a) {\n+        double sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += a[j];\n+        }\n+        return sum;\n+    }\n+\n+    static void reset() {\n+        for (int i = 0; i < N; i++) {\n+            lArrFld[i] = 0;\n+        }\n+        iMeth_check_sum = 0;\n+    }\n+\n+    public static void main(String[] strArr)  throws Exception {\n+        test0();\n+        test0();\n+        for (int i = 0; i < 5_000; i++) {\n+            reset();\n+            test1();\n+            if (iMeth_check_sum != 22154) {\n+                throw new RuntimeException(\"iMeth wrong result at test1: \" + iMeth_check_sum);\n+            }\n+            test2();\n+            if (iMeth_check_sum != 44246) {\n+                throw new RuntimeException(\"iMeth wrong result at test2: \" + iMeth_check_sum);\n+            }\n+            test3();\n+            if (iMeth_check_sum != 66171) {\n+                throw new RuntimeException(\"iMeth wrong result at test3: \" + iMeth_check_sum);\n+            }\n+            test4();\n+            if (iMeth_check_sum != 88309) {\n+                throw new RuntimeException(\"iMeth wrong result at test4: \" + iMeth_check_sum);\n+            }\n+            test5();\n+            if (iMeth_check_sum != 109251) {\n+                throw new RuntimeException(\"iMeth wrong result at test5: \" + iMeth_check_sum);\n+            }\n+            test6();\n+            if (iMeth_check_sum != 130073) {\n+                throw new RuntimeException(\"iMeth wrong result at test6: \" + iMeth_check_sum);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestPickLastMemoryState.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"}]}