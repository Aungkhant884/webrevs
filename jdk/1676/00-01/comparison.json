{"files":[{"patch":"@@ -307,0 +307,1 @@\n+<li><p>Range-based <code>for<\/code> loops (<a href=\"http:\/\/www.open-std.org\/JTC1\/SC22\/WG21\/docs\/papers\/2009\/n2930.html\">n2930<\/a>) (<a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/range-for\">range-for<\/a>)<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -753,0 +753,4 @@\n+* Range-based `for` loops\n+([n2930](http:\/\/www.open-std.org\/JTC1\/SC22\/WG21\/docs\/papers\/2009\/n2930.html))\n+([range-for](https:\/\/en.cppreference.com\/w\/cpp\/language\/range-for))\n+\n","filename":"doc\/hotspot-style.md","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+    LIBJSIG_CFLAGS += -DHOTSPOT_VM_DISTRO='\"$(HOTSPOT_VM_DISTRO)\"'\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2374,13 +2374,0 @@\n-static inline jint replicate4_imm(int con, int width) {\n-  \/\/ Load a constant of \"width\" (in bytes) and replicate it to fill 32bit.\n-  assert(width == 1 || width == 2, \"only byte or short types here\");\n-  int bit_width = width * 8;\n-  jint val = con;\n-  val &= (1 << bit_width) - 1;  \/\/ mask off sign bits\n-  while(bit_width < 32) {\n-    val |= (val << bit_width);\n-    bit_width <<= 1;\n-  }\n-  return val;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -497,1 +497,1 @@\n-  if (!Inline) {\n+  if (!Inline || !IncrementalInline) {\n@@ -499,0 +499,2 @@\n+    IncrementalInlineMH = false;\n+    IncrementalInlineVirtual = false;\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -289,0 +289,5 @@\n+  if (option == CompileCommand::Blackhole && !UnlockDiagnosticVMOptions) {\n+    warning(\"Blackhole compile option is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions\");\n+    return;\n+  }\n+\n@@ -413,7 +418,2 @@\n-  if (check_predicate(CompileCommand::Blackhole, method)) {\n-    if (method->result_type() == T_VOID) {\n-      return true;\n-    } else {\n-      warning(\"blackhole compile command only works for methods with void type: %s\",\n-              method->name_and_sig_as_C_string());\n-    }\n+  if (!check_predicate(CompileCommand::Blackhole, method)) {\n+    return false;\n@@ -421,1 +421,7 @@\n-  return false;\n+  guarantee(UnlockDiagnosticVMOptions, \"Checked during initial parsing\");\n+  if (method->result_type() != T_VOID) {\n+    warning(\"Blackhole compile option only works for methods with void type: %s\",\n+            method->name_and_sig_as_C_string());\n+    return false;\n+  }\n+  return true;\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -716,0 +716,6 @@\n+  product(bool, IncrementalInlineMH, true, DIAGNOSTIC,                      \\\n+          \"do post parse inlining of method handle calls\")                  \\\n+                                                                            \\\n+  product(bool, IncrementalInlineVirtual, true, DIAGNOSTIC,                 \\\n+          \"do post parse inlining of virtual calls\")                        \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -124,0 +124,3 @@\n+protected:\n+  void set_call_node(CallStaticJavaNode* call) { _call_node = call; }\n+\n@@ -132,1 +135,6 @@\n-  CallStaticJavaNode* call_node() const { return _call_node; }\n+  virtual CallNode* call_node() const { return _call_node; }\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    DirectCallGenerator* dcg = new DirectCallGenerator(method(), _separate_io_proj);\n+    dcg->set_call_node(call->as_CallStaticJava());\n+    return dcg;\n+  }\n@@ -182,0 +190,6 @@\n+  bool _separate_io_proj;\n+  CallDynamicJavaNode* _call_node;\n+\n+protected:\n+  void set_call_node(CallDynamicJavaNode* call) { _call_node = call; }\n+\n@@ -183,2 +197,2 @@\n-  VirtualCallGenerator(ciMethod* method, int vtable_index)\n-    : CallGenerator(method), _vtable_index(vtable_index)\n+  VirtualCallGenerator(ciMethod* method, int vtable_index, bool separate_io_proj)\n+    : CallGenerator(method), _vtable_index(vtable_index), _separate_io_proj(separate_io_proj), _call_node(NULL)\n@@ -191,0 +205,9 @@\n+\n+  virtual CallNode* call_node() const { return _call_node; }\n+  int vtable_index() const { return _vtable_index; }\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    VirtualCallGenerator* cg = new VirtualCallGenerator(method(), _vtable_index, _separate_io_proj);\n+    cg->set_call_node(call->as_CallDynamicJava());\n+    return cg;\n+  }\n@@ -253,0 +276,2 @@\n+  _call_node = call;  \/\/ Save the call node in case we need it later\n+\n@@ -254,2 +279,2 @@\n-  kit.set_edges_for_java_call(call);\n-  Node* ret = kit.set_results_for_java_call(call);\n+  kit.set_edges_for_java_call(call, false \/*must_throw*\/, _separate_io_proj);\n+  Node* ret = kit.set_results_for_java_call(call, _separate_io_proj);\n@@ -288,1 +313,1 @@\n-  return new VirtualCallGenerator(m, vtable_index);\n+  return new VirtualCallGenerator(m, vtable_index, false \/*separate_io_projs*\/);\n@@ -299,1 +324,3 @@\n-  virtual bool do_late_inline_check(JVMState* jvms) { return true; }\n+  virtual bool do_late_inline_check(Compile* C, JVMState* jvms) { return true; }\n+  virtual CallGenerator* inline_cg() const { return _inline_cg; }\n+  virtual bool is_pure_call() const { return _is_pure_call; }\n@@ -344,0 +371,45 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineCallGenerator* cg = new LateInlineCallGenerator(method(), _inline_cg, _is_pure_call);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n+};\n+\n+CallGenerator* CallGenerator::for_late_inline(ciMethod* method, CallGenerator* inline_cg) {\n+  return new LateInlineCallGenerator(method, inline_cg);\n+}\n+\n+class LateInlineMHCallGenerator : public LateInlineCallGenerator {\n+  ciMethod* _caller;\n+  bool _input_not_const;\n+\n+  virtual bool do_late_inline_check(Compile* C, JVMState* jvms);\n+\n+ public:\n+  LateInlineMHCallGenerator(ciMethod* caller, ciMethod* callee, bool input_not_const) :\n+    LateInlineCallGenerator(callee, NULL), _caller(caller), _input_not_const(input_not_const) {}\n+\n+  virtual bool is_mh_late_inline() const { return true; }\n+\n+  \/\/ Convert the CallStaticJava into an inline\n+  virtual void do_late_inline();\n+\n+  virtual JVMState* generate(JVMState* jvms) {\n+    JVMState* new_jvms = LateInlineCallGenerator::generate(jvms);\n+\n+    Compile* C = Compile::current();\n+    if (_input_not_const) {\n+      \/\/ inlining won't be possible so no need to enqueue right now.\n+      call_node()->set_generator(this);\n+    } else {\n+      C->add_late_inline(this);\n+    }\n+    return new_jvms;\n+  }\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineMHCallGenerator* cg = new LateInlineMHCallGenerator(_caller, method(), _input_not_const);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -346,0 +418,126 @@\n+bool LateInlineMHCallGenerator::do_late_inline_check(Compile* C, JVMState* jvms) {\n+  \/\/ Even if inlining is not allowed, a virtual call can be strength-reduced to a direct call.\n+  bool allow_inline = C->inlining_incrementally();\n+  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, _input_not_const);\n+  assert(!_input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n+\n+  if (cg != NULL) {\n+    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline, \"we're doing late inlining\");\n+    _inline_cg = cg;\n+    C->dec_number_of_mh_late_inlines();\n+    return true;\n+  } else {\n+    \/\/ Method handle call which has a constant appendix argument should be either inlined or replaced with a direct call\n+    \/\/ unless there's a signature mismatch between caller and callee. If the failure occurs, there's not much to be improved later,\n+    \/\/ so don't reinstall the generator to avoid pushing the generator between IGVN and incremental inlining indefinitely.\n+    return false;\n+  }\n+}\n+\n+CallGenerator* CallGenerator::for_mh_late_inline(ciMethod* caller, ciMethod* callee, bool input_not_const) {\n+  assert(IncrementalInlineMH, \"required\");\n+  Compile::current()->inc_number_of_mh_late_inlines();\n+  CallGenerator* cg = new LateInlineMHCallGenerator(caller, callee, input_not_const);\n+  return cg;\n+}\n+\n+\/\/ Allow inlining decisions to be delayed\n+class LateInlineVirtualCallGenerator : public VirtualCallGenerator {\n+ private:\n+  jlong          _unique_id;   \/\/ unique id for log compilation\n+  CallGenerator* _inline_cg;\n+  ciMethod*      _callee;\n+  bool           _is_pure_call;\n+  float          _prof_factor;\n+\n+ protected:\n+  virtual bool do_late_inline_check(Compile* C, JVMState* jvms);\n+  virtual CallGenerator* inline_cg() const { return _inline_cg; }\n+  virtual bool is_pure_call() const { return _is_pure_call; }\n+\n+ public:\n+  LateInlineVirtualCallGenerator(ciMethod* method, int vtable_index, float prof_factor)\n+  : VirtualCallGenerator(method, vtable_index, true \/*separate_io_projs*\/),\n+    _unique_id(0), _inline_cg(NULL), _callee(NULL), _is_pure_call(false), _prof_factor(prof_factor) {}\n+\n+  virtual bool is_late_inline() const { return true; }\n+\n+  virtual bool is_virtual_late_inline() const { return true; }\n+\n+  \/\/ Convert the CallDynamicJava into an inline\n+  virtual void do_late_inline();\n+\n+  virtual void set_callee_method(ciMethod* m) {\n+    assert(_callee == NULL, \"repeated inlining attempt\");\n+    _callee = m;\n+  }\n+\n+  virtual JVMState* generate(JVMState* jvms) {\n+    \/\/ Emit the CallDynamicJava and request separate projections so\n+    \/\/ that the late inlining logic can distinguish between fall\n+    \/\/ through and exceptional uses of the memory and io projections\n+    \/\/ as is done for allocations and macro expansion.\n+    JVMState* new_jvms = VirtualCallGenerator::generate(jvms);\n+    if (call_node() != NULL) {\n+      call_node()->set_generator(this);\n+    }\n+    return new_jvms;\n+  }\n+\n+  virtual void print_inlining_late(const char* msg) {\n+    CallNode* call = call_node();\n+    Compile* C = Compile::current();\n+    C->print_inlining_assert_ready();\n+    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), msg);\n+    C->print_inlining_move_to(this);\n+    C->print_inlining_update_delayed(this);\n+  }\n+\n+  virtual void set_unique_id(jlong id) {\n+    _unique_id = id;\n+  }\n+\n+  virtual jlong unique_id() const {\n+    return _unique_id;\n+  }\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineVirtualCallGenerator* cg = new LateInlineVirtualCallGenerator(method(), vtable_index(), _prof_factor);\n+    cg->set_call_node(call->as_CallDynamicJava());\n+    return cg;\n+  }\n+};\n+\n+bool LateInlineVirtualCallGenerator::do_late_inline_check(Compile* C, JVMState* jvms) {\n+  \/\/ Method handle linker case is handled in CallDynamicJavaNode::Ideal().\n+  \/\/ Unless inlining is performed, _override_symbolic_info bit will be set in DirectCallGenerator::generate().\n+\n+  \/\/ Even if inlining is not allowed, a virtual call can be strength-reduced to a direct call.\n+  bool allow_inline = C->inlining_incrementally();\n+  CallGenerator* cg = C->call_generator(_callee,\n+                                        vtable_index(),\n+                                        false \/*call_does_dispatch*\/,\n+                                        jvms,\n+                                        allow_inline,\n+                                        _prof_factor,\n+                                        NULL \/*speculative_receiver_type*\/,\n+                                        true \/*allow_intrinsics*\/);\n+\n+  if (cg != NULL) {\n+    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline, \"we're doing late inlining\");\n+    _inline_cg = cg;\n+    return true;\n+  } else {\n+    \/\/ Virtual call which provably doesn't dispatch should be either inlined or replaced with a direct call.\n+    assert(false, \"no progress\");\n+    return false;\n+  }\n+}\n+\n+CallGenerator* CallGenerator::for_late_inline_virtual(ciMethod* m, int vtable_index, float prof_factor) {\n+  assert(IncrementalInlineVirtual, \"required\");\n+  assert(!m->is_static(), \"for_virtual_call mismatch\");\n+  assert(!m->is_method_handle_intrinsic(), \"should be a direct call\");\n+  return new LateInlineVirtualCallGenerator(m, vtable_index, prof_factor);\n+}\n+\n@@ -347,0 +545,15 @@\n+  CallGenerator::do_late_inline_helper();\n+}\n+\n+void LateInlineMHCallGenerator::do_late_inline() {\n+  CallGenerator::do_late_inline_helper();\n+}\n+\n+void LateInlineVirtualCallGenerator::do_late_inline() {\n+  assert(_callee != NULL, \"required\"); \/\/ set up in CallDynamicJavaNode::Ideal\n+  CallGenerator::do_late_inline_helper();\n+}\n+\n+void CallGenerator::do_late_inline_helper() {\n+  assert(is_late_inline(), \"only late inline allowed\");\n+\n@@ -348,1 +561,1 @@\n-  CallStaticJavaNode* call = call_node();\n+  CallNode* call = call_node();\n@@ -376,6 +589,6 @@\n-  if (callprojs.fallthrough_catchproj == call->in(0) ||\n-      callprojs.catchall_catchproj == call->in(0) ||\n-      callprojs.fallthrough_memproj == call->in(TypeFunc::Memory) ||\n-      callprojs.catchall_memproj == call->in(TypeFunc::Memory) ||\n-      callprojs.fallthrough_ioproj == call->in(TypeFunc::I_O) ||\n-      callprojs.catchall_ioproj == call->in(TypeFunc::I_O) ||\n+  if ((callprojs.fallthrough_catchproj == call->in(0)) ||\n+      (callprojs.catchall_catchproj    == call->in(0)) ||\n+      (callprojs.fallthrough_memproj   == call->in(TypeFunc::Memory)) ||\n+      (callprojs.catchall_memproj      == call->in(TypeFunc::Memory)) ||\n+      (callprojs.fallthrough_ioproj    == call->in(TypeFunc::I_O)) ||\n+      (callprojs.catchall_ioproj       == call->in(TypeFunc::I_O)) ||\n@@ -383,1 +596,1 @@\n-      (callprojs.exobj != NULL && call->find_edge(callprojs.exobj) != -1)) {\n+      (callprojs.exobj   != NULL && call->find_edge(callprojs.exobj) != -1)) {\n@@ -394,1 +607,1 @@\n-  if (_is_pure_call && result_not_used) {\n+  if (is_pure_call() && result_not_used) {\n@@ -437,3 +650,2 @@\n-    \/\/ This check is done here because for_method_handle_inline() method\n-    \/\/ needs jvms for inlined state.\n-    if (!do_late_inline_check(jvms)) {\n+    \/\/ JVMState is ready, so time to perform some checks and prepare for inlining attempt.\n+    if (!do_late_inline_check(C, jvms)) {\n@@ -441,0 +653,1 @@\n+      C->print_inlining_update_delayed(this);\n@@ -452,0 +665,7 @@\n+    \/\/ Virtual call involves a receiver null check which can be made implicit.\n+    if (is_virtual_late_inline()) {\n+      GraphKit kit(jvms);\n+      kit.null_check_receiver();\n+      jvms = kit.transfer_exceptions_into_jvms();\n+    }\n+\n@@ -453,1 +673,1 @@\n-    JVMState* new_jvms = _inline_cg->generate(jvms);\n+    JVMState* new_jvms = inline_cg()->generate(jvms);\n@@ -467,1 +687,4 @@\n-    C->env()->notice_inlined_method(_inline_cg->method());\n+    if (inline_cg()->is_inline()) {\n+      C->set_has_loops(C->has_loops() || inline_cg()->method()->has_loops());\n+      C->env()->notice_inlined_method(inline_cg()->method());\n+    }\n@@ -474,60 +697,0 @@\n-\n-CallGenerator* CallGenerator::for_late_inline(ciMethod* method, CallGenerator* inline_cg) {\n-  return new LateInlineCallGenerator(method, inline_cg);\n-}\n-\n-class LateInlineMHCallGenerator : public LateInlineCallGenerator {\n-  ciMethod* _caller;\n-  int _attempt;\n-  bool _input_not_const;\n-\n-  virtual bool do_late_inline_check(JVMState* jvms);\n-  virtual bool already_attempted() const { return _attempt > 0; }\n-\n- public:\n-  LateInlineMHCallGenerator(ciMethod* caller, ciMethod* callee, bool input_not_const) :\n-    LateInlineCallGenerator(callee, NULL), _caller(caller), _attempt(0), _input_not_const(input_not_const) {}\n-\n-  virtual bool is_mh_late_inline() const { return true; }\n-\n-  virtual JVMState* generate(JVMState* jvms) {\n-    JVMState* new_jvms = LateInlineCallGenerator::generate(jvms);\n-\n-    Compile* C = Compile::current();\n-    if (_input_not_const) {\n-      \/\/ inlining won't be possible so no need to enqueue right now.\n-      call_node()->set_generator(this);\n-    } else {\n-      C->add_late_inline(this);\n-    }\n-    return new_jvms;\n-  }\n-};\n-\n-bool LateInlineMHCallGenerator::do_late_inline_check(JVMState* jvms) {\n-\n-  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), _input_not_const);\n-\n-  Compile::current()->print_inlining_update_delayed(this);\n-\n-  if (!_input_not_const) {\n-    _attempt++;\n-  }\n-\n-  if (cg != NULL && cg->is_inline()) {\n-    assert(!cg->is_late_inline(), \"we're doing late inlining\");\n-    _inline_cg = cg;\n-    Compile::current()->dec_number_of_mh_late_inlines();\n-    return true;\n-  }\n-\n-  call_node()->set_generator(this);\n-  return false;\n-}\n-\n-CallGenerator* CallGenerator::for_mh_late_inline(ciMethod* caller, ciMethod* callee, bool input_not_const) {\n-  Compile::current()->inc_number_of_mh_late_inlines();\n-  CallGenerator* cg = new LateInlineMHCallGenerator(caller, callee, input_not_const);\n-  return cg;\n-}\n-\n@@ -552,0 +715,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineStringCallGenerator* cg = new LateInlineStringCallGenerator(method(), _inline_cg);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -574,0 +743,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineBoxingCallGenerator* cg = new LateInlineBoxingCallGenerator(method(), _inline_cg);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -596,0 +771,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineVectorReboxingCallGenerator* cg = new LateInlineVectorReboxingCallGenerator(method(), _inline_cg);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -853,1 +1034,1 @@\n-CallGenerator* CallGenerator::for_method_handle_call(JVMState* jvms, ciMethod* caller, ciMethod* callee) {\n+CallGenerator* CallGenerator::for_method_handle_call(JVMState* jvms, ciMethod* caller, ciMethod* callee, bool allow_inline) {\n@@ -856,1 +1037,1 @@\n-  CallGenerator* cg = CallGenerator::for_method_handle_inline(jvms, caller, callee, input_not_const);\n+  CallGenerator* cg = CallGenerator::for_method_handle_inline(jvms, caller, callee, allow_inline, input_not_const);\n@@ -869,1 +1050,1 @@\n-  if (IncrementalInline && call_site_count > 0 &&\n+  if (IncrementalInlineMH && call_site_count > 0 &&\n@@ -903,1 +1084,1 @@\n-CallGenerator* CallGenerator::for_method_handle_inline(JVMState* jvms, ciMethod* caller, ciMethod* callee, bool& input_not_const) {\n+CallGenerator* CallGenerator::for_method_handle_inline(JVMState* jvms, ciMethod* caller, ciMethod* callee, bool allow_inline, bool& input_not_const) {\n@@ -909,0 +1090,3 @@\n+  if (StressMethodHandleLinkerInlining) {\n+    allow_inline = false;\n+  }\n@@ -929,1 +1113,1 @@\n-                                              true \/* allow_inline *\/,\n+                                              allow_inline,\n@@ -1005,1 +1189,1 @@\n-          target = C->optimize_virtual_call(caller, jvms->bci(), klass, klass,\n+          target = C->optimize_virtual_call(caller, klass, klass,\n@@ -1014,1 +1198,1 @@\n-                                              !StressMethodHandleLinkerInlining \/* allow_inline *\/,\n+                                              allow_inline,\n@@ -1029,0 +1213,1 @@\n+        input_not_const = false;\n@@ -1063,1 +1248,1 @@\n-  virtual bool      is_inlined()   const    { return true; }\n+  virtual bool      is_inline()    const    { return true; }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":274,"deletions":89,"binary":false,"changes":363,"status":"modified"},{"patch":"@@ -45,0 +45,6 @@\n+  void do_late_inline_helper();\n+\n+  virtual bool           do_late_inline_check(Compile* C, JVMState* jvms) { ShouldNotReachHere(); return false; }\n+  virtual CallGenerator* inline_cg()    const                             { ShouldNotReachHere(); return NULL;  }\n+  virtual bool           is_pure_call() const                             { ShouldNotReachHere(); return false; }\n+\n@@ -68,1 +74,1 @@\n-  virtual bool      is_late_inline() const      { return false; }\n+  virtual bool      is_late_inline() const         { return false; }\n@@ -70,5 +76,3 @@\n-  virtual bool      is_mh_late_inline() const   { return false; }\n-  virtual bool      is_string_late_inline() const{ return false; }\n-\n-  \/\/ for method handle calls: have we tried inlinining the call already?\n-  virtual bool      already_attempted() const   { ShouldNotReachHere(); return false; }\n+  virtual bool      is_mh_late_inline() const      { return false; }\n+  virtual bool      is_string_late_inline() const  { return false; }\n+  virtual bool      is_virtual_late_inline() const { return false; }\n@@ -79,1 +83,2 @@\n-  virtual CallStaticJavaNode* call_node() const { ShouldNotReachHere(); return NULL; }\n+  virtual CallNode* call_node() const { return NULL; }\n+  virtual CallGenerator* with_call_node(CallNode* call)  { return this; }\n@@ -84,0 +89,2 @@\n+  virtual void set_callee_method(ciMethod* callee) { ShouldNotReachHere(); }\n+\n@@ -87,0 +94,6 @@\n+  \/\/ Allocate CallGenerators only in Compile arena since some of them are referenced from CallNodes.\n+  void* operator new(size_t size) throw() {\n+    Compile* C = Compile::current();\n+    return ResourceObj::operator new(size, C->comp_arena());\n+  }\n+\n@@ -122,2 +135,2 @@\n-  static CallGenerator* for_method_handle_call(  JVMState* jvms, ciMethod* caller, ciMethod* callee);\n-  static CallGenerator* for_method_handle_inline(JVMState* jvms, ciMethod* caller, ciMethod* callee, bool& input_not_const);\n+  static CallGenerator* for_method_handle_call(  JVMState* jvms, ciMethod* caller, ciMethod* callee, bool allow_inline);\n+  static CallGenerator* for_method_handle_inline(JVMState* jvms, ciMethod* caller, ciMethod* callee, bool allow_inline, bool& input_not_const);\n@@ -137,0 +150,2 @@\n+  static CallGenerator* for_late_inline_virtual(ciMethod* m, int vtable_index, float expected_uses);\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-  for (JVMState* p = this; p->_caller != NULL; p = p->_caller) {\n+  for (JVMState* p = this; p != NULL; p = p->_caller) {\n@@ -945,1 +945,3 @@\n-Node *CallNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* CallNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+#ifdef ASSERT\n+  \/\/ Validate attached generator\n@@ -947,16 +949,3 @@\n-  if (can_reshape && cg != NULL && cg->is_mh_late_inline() && !cg->already_attempted()) {\n-    \/\/ Check whether this MH handle call becomes a candidate for inlining\n-    ciMethod* callee = cg->method();\n-    vmIntrinsics::ID iid = callee->intrinsic_id();\n-    if (iid == vmIntrinsics::_invokeBasic) {\n-      if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n-        phase->C->prepend_late_inline(cg);\n-        set_generator(NULL);\n-      }\n-    } else {\n-      assert(callee->has_member_arg(), \"wrong type of call?\");\n-      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n-        phase->C->prepend_late_inline(cg);\n-        set_generator(NULL);\n-      }\n-    }\n+  if (cg != NULL) {\n+    assert(is_CallStaticJava()  && cg->is_mh_late_inline() ||\n+           is_CallDynamicJava() && cg->is_virtual_late_inline(), \"mismatch\");\n@@ -964,0 +953,1 @@\n+#endif \/\/ ASSERT\n@@ -982,1 +972,1 @@\n-void CallJavaNode::copy_call_debug_info(PhaseIterGVN* phase, SafePointNode *sfpt) {\n+void CallJavaNode::copy_call_debug_info(PhaseIterGVN* phase, SafePointNode* sfpt) {\n@@ -1037,1 +1027,1 @@\n-void CallJavaNode::dump_spec(outputStream *st) const {\n+void CallJavaNode::dump_spec(outputStream* st) const {\n@@ -1058,0 +1048,26 @@\n+Node* CallStaticJavaNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  CallGenerator* cg = generator();\n+  if (can_reshape && cg != NULL) {\n+    assert(IncrementalInlineMH, \"required\");\n+    assert(cg->call_node() == this, \"mismatch\");\n+    assert(cg->is_mh_late_inline(), \"not virtual\");\n+\n+    \/\/ Check whether this MH handle call becomes a candidate for inlining.\n+    ciMethod* callee = cg->method();\n+    vmIntrinsics::ID iid = callee->intrinsic_id();\n+    if (iid == vmIntrinsics::_invokeBasic) {\n+      if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n+        phase->C->prepend_late_inline(cg);\n+        set_generator(NULL);\n+      }\n+    } else {\n+      assert(callee->has_member_arg(), \"wrong type of call?\");\n+      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n+        phase->C->prepend_late_inline(cg);\n+        set_generator(NULL);\n+      }\n+    }\n+  }\n+  return CallNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1114,0 +1130,42 @@\n+\n+Node* CallDynamicJavaNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  CallGenerator* cg = generator();\n+  if (can_reshape && cg != NULL) {\n+    assert(IncrementalInlineVirtual, \"required\");\n+    assert(cg->call_node() == this, \"mismatch\");\n+    assert(cg->is_virtual_late_inline(), \"not virtual\");\n+\n+    \/\/ Recover symbolic info for method resolution.\n+    ciMethod* caller = jvms()->method();\n+    ciBytecodeStream iter(caller);\n+    iter.force_bci(jvms()->bci());\n+\n+    bool             not_used1;\n+    ciSignature*     not_used2;\n+    ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+    ciKlass*         holder       = iter.get_declared_method_holder();\n+    if (orig_callee->is_method_handle_intrinsic()) {\n+      assert(_override_symbolic_info, \"required\");\n+      orig_callee = method();\n+      holder = method()->holder();\n+    }\n+\n+    ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+\n+    Node* receiver_node = in(TypeFunc::Parms);\n+    const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+\n+    int  not_used3;\n+    bool call_does_dispatch;\n+    ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                       call_does_dispatch, not_used3);  \/\/ out-parameters\n+    if (!call_does_dispatch) {\n+      \/\/ Register for late inlining.\n+      cg->set_callee_method(callee);\n+      phase->C->prepend_late_inline(cg); \/\/ MH late inlining prepends to the list, so do the same\n+      set_generator(NULL);\n+    }\n+  }\n+  return CallNode::Ideal(phase, can_reshape);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":78,"deletions":20,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-  bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase);\n+  bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseTransform* phase);\n@@ -576,5 +576,5 @@\n-  const TypeFunc *_tf;        \/\/ Function type\n-  address      _entry_point;  \/\/ Address of method being called\n-  float        _cnt;          \/\/ Estimate of number of times called\n-  CallGenerator* _generator;  \/\/ corresponding CallGenerator for some late inline calls\n-  const char *_name;           \/\/ Printable name, if _method is NULL\n+  const TypeFunc* _tf;          \/\/ Function type\n+  address         _entry_point; \/\/ Address of method being called\n+  float           _cnt;         \/\/ Estimate of number of times called\n+  CallGenerator*  _generator;   \/\/ corresponding CallGenerator for some late inline calls\n+  const char*     _name;        \/\/ Printable name, if _method is NULL\n@@ -603,1 +603,1 @@\n-  virtual const Type *bottom_type() const;\n+  virtual const Type* bottom_type() const;\n@@ -605,1 +605,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -607,1 +607,1 @@\n-  virtual bool        cmp( const Node &n ) const;\n+  virtual bool        cmp(const Node &n) const;\n@@ -609,2 +609,2 @@\n-  virtual void        calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;\n-  virtual Node       *match( const ProjNode *proj, const Matcher *m );\n+  virtual void        calling_convention(BasicType* sig_bt, VMRegPair* parm_regs, uint argcnt) const;\n+  virtual Node*       match(const ProjNode* proj, const Matcher* m);\n@@ -626,1 +626,1 @@\n-  virtual bool        may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase);\n+  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseTransform* phase);\n@@ -628,1 +628,1 @@\n-  bool                has_non_debug_use(Node *n);\n+  bool                has_non_debug_use(Node* n);\n@@ -632,1 +632,1 @@\n-  Node *result_cast();\n+  Node* result_cast();\n@@ -635,1 +635,1 @@\n-    const TypeTuple *r = tf()->range();\n+    const TypeTuple* r = tf()->range();\n@@ -649,1 +649,1 @@\n-  virtual void copy_call_debug_info(PhaseIterGVN* phase, SafePointNode *sfpt) {}\n+  virtual void copy_call_debug_info(PhaseIterGVN* phase, SafePointNode* sfpt) {}\n@@ -652,2 +652,2 @@\n-  virtual void        dump_req(outputStream *st = tty) const;\n-  virtual void        dump_spec(outputStream *st) const;\n+  virtual void        dump_req(outputStream* st = tty) const;\n+  virtual void        dump_spec(outputStream* st) const;\n@@ -739,1 +739,1 @@\n-  \/\/ Later inlining modifies the JVMState, so we need to clone it\n+  \/\/ Late inlining modifies the JVMState, so we need to clone it\n@@ -749,0 +749,2 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+\n@@ -765,0 +767,9 @@\n+  \/\/ Late inlining modifies the JVMState, so we need to clone it\n+  \/\/ when the call node is cloned.\n+  virtual void clone_jvms(Compile* C) {\n+    if ((jvms() != NULL) && IncrementalInlineVirtual) {\n+      set_jvms(jvms()->clone_deep(C));\n+      jvms()->set_map_deep(this);\n+    }\n+  }\n+\n@@ -767,0 +778,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":31,"deletions":19,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1108,1 +1108,1 @@\n-              return TypeInteger::make(MIN2(lo->lo_as_long(), hi->lo_as_long()), hi->hi_as_long(), 3, l->bt());\n+              return TypeInteger::make(MIN2(lo->lo_as_long(), hi->lo_as_long()), hi->hi_as_long(), 3, l->bt())->filter_speculative(_type);\n@@ -1110,1 +1110,1 @@\n-              return TypeInteger::make(lo->lo_as_long(), MAX2(lo->hi_as_long(), hi->hi_as_long()), 3, l->bt());\n+              return TypeInteger::make(lo->lo_as_long(), MAX2(lo->hi_as_long(), hi->hi_as_long()), 3, l->bt())->filter_speculative(_type);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -342,3 +342,6 @@\n-    CallNode* call = cg->call_node();\n-    if (shift > 0) {\n-      inlines->at_put(i-shift, cg);\n+    if (useful.member(cg->call_node())) {\n+      if (shift > 0) {\n+        inlines->at_put(i - shift, cg);\n+      }\n+    } else {\n+      shift++; \/\/ skip over the dead element\n@@ -346,2 +349,14 @@\n-    if (!useful.member(call)) {\n-      shift++;\n+  }\n+  if (shift > 0) {\n+    inlines->trunc_to(inlines->length() - shift); \/\/ remove last elements from compacted array\n+  }\n+}\n+\n+void Compile::remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Node* dead) {\n+  assert(dead != NULL && dead->is_Call(), \"sanity\");\n+  int found = 0;\n+  for (int i = 0; i < inlines->length(); i++) {\n+    if (inlines->at(i)->call_node() == dead) {\n+      inlines->remove_at(i);\n+      found++;\n+      NOT_DEBUG( break; ) \/\/ elements are unique, so exit early\n@@ -350,1 +365,1 @@\n-  inlines->trunc_to(inlines->length()-shift);\n+  assert(found <= 1, \"not unique\");\n@@ -357,1 +372,1 @@\n-      node_list.remove_if_existing(n);\n+      node_list.delete_at(i); \/\/ replaces i-th with last element which is known to be useful (already processed)\n@@ -362,0 +377,30 @@\n+void Compile::remove_useless_node(Node* dead) {\n+  remove_modified_node(dead);\n+\n+  \/\/ Constant node that has no out-edges and has only one in-edge from\n+  \/\/ root is usually dead. However, sometimes reshaping walk makes\n+  \/\/ it reachable by adding use edges. So, we will NOT count Con nodes\n+  \/\/ as dead to be conservative about the dead node count at any\n+  \/\/ given time.\n+  if (!dead->is_Con()) {\n+    record_dead_node(dead->_idx);\n+  }\n+  if (dead->is_macro()) {\n+    remove_macro_node(dead);\n+  }\n+  if (dead->is_expensive()) {\n+    remove_expensive_node(dead);\n+  }\n+  if (dead->for_post_loop_opts_igvn()) {\n+    remove_from_post_loop_opts_igvn(dead);\n+  }\n+  if (dead->is_Call()) {\n+    remove_useless_late_inlines(                &_late_inlines, dead);\n+    remove_useless_late_inlines(         &_string_late_inlines, dead);\n+    remove_useless_late_inlines(         &_boxing_late_inlines, dead);\n+    remove_useless_late_inlines(&_vector_reboxing_late_inlines, dead);\n+  }\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  bs->unregister_potential_barrier_node(dead);\n+}\n+\n@@ -397,3 +442,3 @@\n-  remove_useless_late_inlines(&_string_late_inlines, useful);\n-  remove_useless_late_inlines(&_boxing_late_inlines, useful);\n-  remove_useless_late_inlines(&_late_inlines, useful);\n+  remove_useless_late_inlines(                &_late_inlines, useful);\n+  remove_useless_late_inlines(         &_string_late_inlines, useful);\n+  remove_useless_late_inlines(         &_boxing_late_inlines, useful);\n@@ -1863,0 +1908,1 @@\n+\n@@ -1865,3 +1911,2 @@\n-  int i = 0;\n-  for (; i <_late_inlines.length() && !inlining_progress(); i++) {\n-    CallGenerator* cg = _late_inlines.at(i);\n+\n+  for (int i = 0; i < _late_inlines.length(); i++) {\n@@ -1869,6 +1914,16 @@\n-    cg->do_late_inline();\n-    if (failing())  return false;\n-  }\n-  int j = 0;\n-  for (; i < _late_inlines.length(); i++, j++) {\n-    _late_inlines.at_put(j, _late_inlines.at(i));\n+    CallGenerator* cg = _late_inlines.at(i);\n+    bool does_dispatch = cg->is_virtual_late_inline() || cg->is_mh_late_inline();\n+    if (inlining_incrementally() || does_dispatch) { \/\/ a call can be either inlined or strength-reduced to a direct call\n+      cg->do_late_inline();\n+      assert(_late_inlines.at(i) == cg, \"no insertions before current position allowed\");\n+      if (failing()) {\n+        return false;\n+      } else if (inlining_progress()) {\n+        _late_inlines_pos = i+1; \/\/ restore the position in case new elements were inserted\n+        print_method(PHASE_INCREMENTAL_INLINE_STEP, cg->call_node(), 3);\n+        break; \/\/ process one call site at a time\n+      }\n+    } else {\n+      \/\/ Ignore late inline direct calls when inlining is not allowed.\n+      \/\/ They are left in the late inline list when node budget is exhausted until the list is fully drained.\n+    }\n@@ -1876,2 +1931,5 @@\n-  _late_inlines.trunc_to(j);\n-  assert(inlining_progress() || _late_inlines.length() == 0, \"\");\n+  \/\/ Remove processed elements.\n+  _late_inlines.remove_till(_late_inlines_pos);\n+  _late_inlines_pos = 0;\n+\n+  assert(inlining_progress() || _late_inlines.length() == 0, \"no progress\");\n@@ -1899,0 +1957,1 @@\n+  print_method(PHASE_INCREMENTAL_INLINE_CLEANUP, 3);\n@@ -1922,0 +1981,12 @@\n+        bool do_print_inlining = print_inlining() || print_intrinsics();\n+        if (do_print_inlining || log() != NULL) {\n+          \/\/ Print inlining message for candidates that we couldn't inline for lack of space.\n+          for (int i = 0; i < _late_inlines.length(); i++) {\n+            CallGenerator* cg = _late_inlines.at(i);\n+            const char* msg = \"live nodes > LiveNodeCountInliningCutoff\";\n+            if (do_print_inlining) {\n+              cg->print_inlining_late(msg);\n+            }\n+            log_late_inline_failure(cg, msg);\n+          }\n+        }\n@@ -1932,1 +2003,0 @@\n-\n@@ -1940,0 +2010,4 @@\n+\n+    if (_late_inlines.length() == 0) {\n+      break; \/\/ no more progress\n+    }\n@@ -1958,0 +2032,21 @@\n+void Compile::process_late_inline_calls_no_inline(PhaseIterGVN& igvn) {\n+  \/\/ \"inlining_incrementally() == false\" is used to signal that no inlining is allowed\n+  \/\/ (see LateInlineVirtualCallGenerator::do_late_inline_check() for details).\n+  \/\/ Tracking and verification of modified nodes is disabled by setting \"_modified_nodes == NULL\"\n+  \/\/ as if \"inlining_incrementally() == true\" were set.\n+  assert(inlining_incrementally() == false, \"not allowed\");\n+  assert(_modified_nodes == NULL, \"not allowed\");\n+  assert(_late_inlines.length() > 0, \"sanity\");\n+\n+  while (_late_inlines.length() > 0) {\n+    for_igvn()->clear();\n+    initial_gvn()->replace_with(&igvn);\n+\n+    while (inline_incrementally_one()) {\n+      assert(!failing(), \"inconsistent\");\n+    }\n+    if (failing())  return;\n+\n+    inline_incrementally_cleanup(igvn);\n+  }\n+}\n@@ -2238,0 +2333,1 @@\n+\n@@ -2239,0 +2335,8 @@\n+\n+  assert(_late_inlines.length() == 0 || IncrementalInlineMH || IncrementalInlineVirtual, \"not empty\");\n+\n+  if (_late_inlines.length() > 0) {\n+    \/\/ More opportunities to optimize virtual and MH calls.\n+    \/\/ Though it's maybe too late to perform inlining, strength-reducing them to direct calls is still an option.\n+    process_late_inline_calls_no_inline(igvn);\n+  }\n@@ -2242,0 +2346,1 @@\n+\n@@ -2257,2 +2362,0 @@\n-    PhaseGVN* gvn = C->initial_gvn();\n-\n@@ -3264,3 +3367,4 @@\n-    if (OptimizeStringConcat) {\n-      ProjNode* p = n->as_Proj();\n-      if (p->_is_io_use) {\n+    if (OptimizeStringConcat || IncrementalInline) {\n+      ProjNode* proj = n->as_Proj();\n+      if (proj->_is_io_use) {\n+        assert(proj->_con == TypeFunc::I_O || proj->_con == TypeFunc::Memory, \"\");\n@@ -3270,13 +3374,4 @@\n-        \/\/ the original one.\n-        Node* proj = NULL;\n-        \/\/ Replace with just one\n-        for (SimpleDUIterator i(p->in(0)); i.has_next(); i.next()) {\n-          Node *use = i.get();\n-          if (use->is_Proj() && p != use && use->as_Proj()->_con == p->_con) {\n-            proj = use;\n-            break;\n-          }\n-        }\n-        assert(proj != NULL || p->_con == TypeFunc::I_O, \"io may be dropped at an infinite loop\");\n-        if (proj != NULL) {\n-          p->subsume_by(proj, this);\n+        \/\/ the original one. Merge them.\n+        Node* non_io_proj = proj->in(0)->as_Multi()->proj_out_or_null(proj->_con, false \/*is_io_use*\/);\n+        if (non_io_proj  != NULL) {\n+          proj->subsume_by(non_io_proj , this);\n@@ -4144,6 +4239,1 @@\n-    if (!cg->is_late_inline()) {\n-      if (print_inlining_current().cg() != NULL) {\n-        print_inlining_push();\n-      }\n-      print_inlining_commit();\n-    } else {\n+    if (cg->is_late_inline()) {\n@@ -4157,0 +4247,5 @@\n+    } else {\n+      if (print_inlining_current().cg() != NULL) {\n+        print_inlining_push();\n+      }\n+      print_inlining_commit();\n@@ -4164,1 +4259,1 @@\n-  if (print_inlining()) {\n+  if (print_inlining() || print_intrinsics()) {\n@@ -4176,1 +4271,1 @@\n-  if (print_inlining()) {\n+  if (print_inlining() || print_intrinsics()) {\n@@ -4191,16 +4286,2 @@\n-  bool do_print_inlining = print_inlining() || print_intrinsics();\n-  if (do_print_inlining || log() != NULL) {\n-    \/\/ Print inlining message for candidates that we couldn't inline\n-    \/\/ for lack of space\n-    for (int i = 0; i < _late_inlines.length(); i++) {\n-      CallGenerator* cg = _late_inlines.at(i);\n-      if (!cg->is_mh_late_inline()) {\n-        const char* msg = \"live nodes > LiveNodeCountInliningCutoff\";\n-        if (do_print_inlining) {\n-          cg->print_inlining_late(msg);\n-        }\n-        log_late_inline_failure(cg, msg);\n-      }\n-    }\n-  }\n-  if (do_print_inlining) {\n+  assert(_late_inlines.length() == 0, \"not drained yet\");\n+  if (print_inlining() || print_intrinsics()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":145,"deletions":64,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -867,1 +867,1 @@\n-  ciMethod* optimize_virtual_call(ciMethod* caller, int bci, ciInstanceKlass* klass,\n+  ciMethod* optimize_virtual_call(ciMethod* caller, ciInstanceKlass* klass,\n@@ -872,1 +872,1 @@\n-  ciMethod* optimize_inlining(ciMethod* caller, int bci, ciInstanceKlass* klass,\n+  ciMethod* optimize_inlining(ciMethod* caller, ciInstanceKlass* klass,\n@@ -914,0 +914,2 @@\n+  void              remove_useless_node(Node* dead);\n+\n@@ -944,1 +946,0 @@\n-  void remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Unique_Node_List &useful);\n@@ -947,0 +948,3 @@\n+  void remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Unique_Node_List &useful);\n+  void remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Node* dead);\n+\n@@ -977,0 +981,2 @@\n+  void process_late_inline_calls_no_inline(PhaseIterGVN& igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-    CallGenerator* cg = CallGenerator::for_method_handle_call(jvms, caller, callee);\n+    CallGenerator* cg = CallGenerator::for_method_handle_call(jvms, caller, callee, allow_inline);\n@@ -277,1 +277,2 @@\n-            miss_cg = CallGenerator::for_virtual_call(callee, vtable_index);\n+            miss_cg = (IncrementalInlineVirtual ? CallGenerator::for_late_inline_virtual(callee, vtable_index, prof_factor)\n+                                                : CallGenerator::for_virtual_call(callee, vtable_index));\n@@ -344,2 +345,1 @@\n-    }\n-  }\n+    } \/\/ call_does_dispatch && bytecode == Bytecodes::_invokeinterface\n@@ -347,6 +347,7 @@\n-  \/\/ Nothing claimed the intrinsic, we go with straight-forward inlining\n-  \/\/ for already discovered intrinsic.\n-  if (allow_inline && allow_intrinsics && cg_intrinsic != NULL) {\n-    assert(cg_intrinsic->does_virtual_dispatch(), \"sanity\");\n-    return cg_intrinsic;\n-  }\n+    \/\/ Nothing claimed the intrinsic, we go with straight-forward inlining\n+    \/\/ for already discovered intrinsic.\n+    if (allow_intrinsics && cg_intrinsic != NULL) {\n+      assert(cg_intrinsic->does_virtual_dispatch(), \"sanity\");\n+      return cg_intrinsic;\n+    }\n+  } \/\/ allow_inline\n@@ -362,1 +363,5 @@\n-    return CallGenerator::for_virtual_call(callee, vtable_index);\n+    if (IncrementalInlineVirtual && allow_inline) {\n+      return CallGenerator::for_late_inline_virtual(callee, vtable_index, prof_factor); \/\/ attempt to inline through virtual call later\n+    } else {\n+      return CallGenerator::for_virtual_call(callee, vtable_index);\n+    }\n@@ -563,1 +568,1 @@\n-    callee = C->optimize_virtual_call(method(), bci(), klass, holder, orig_callee,\n+    callee = C->optimize_virtual_call(method(), klass, holder, orig_callee,\n@@ -1072,1 +1077,1 @@\n-ciMethod* Compile::optimize_virtual_call(ciMethod* caller, int bci, ciInstanceKlass* klass,\n+ciMethod* Compile::optimize_virtual_call(ciMethod* caller, ciInstanceKlass* klass,\n@@ -1082,1 +1087,1 @@\n-  ciMethod* optimized_virtual_method = optimize_inlining(caller, bci, klass, callee,\n+  ciMethod* optimized_virtual_method = optimize_inlining(caller, klass, callee,\n@@ -1097,1 +1102,1 @@\n-ciMethod* Compile::optimize_inlining(ciMethod* caller, int bci, ciInstanceKlass* klass,\n+ciMethod* Compile::optimize_inlining(ciMethod* caller, ciInstanceKlass* klass,\n@@ -1188,5 +1193,0 @@\n-      if (PrintOpto) {\n-        tty->print(\"  Calling method via exact type @%d --- \", bci);\n-        exact_method->print_name();\n-        tty->cr();\n-      }\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -230,3 +230,2 @@\n-\/\/ Clones skeleton predicates starting at 'old_predicate_proj' to\n-\/\/ 'new_predicate_proj' and rewires the control edges of data nodes in\n-\/\/ the loop from the old predicates to the new cloned predicates.\n+\/\/ Clones skeleton predicates starting at 'old_predicate_proj' by following its control inputs and rewires the control edges of in the loop from\n+\/\/ the old predicates to the new cloned predicates.\n@@ -234,1 +233,1 @@\n-                                                                  ProjNode* old_predicate_proj, ProjNode* iffast, ProjNode* ifslow) {\n+                                                                  ProjNode* old_predicate_proj, ProjNode* iffast_pred, ProjNode* ifslow_pred) {\n@@ -236,0 +235,1 @@\n+  assert(iffast_pred->in(0)->is_If() && ifslow_pred->in(0)->is_If(), \"sanity check\");\n@@ -241,2 +241,0 @@\n-  Node* current_proj = old_predicate_proj;\n-  Node* prev_proj = current_proj;\n@@ -259,2 +257,3 @@\n-  \/\/ Process in reverse order such that 'create_new_if_for_predicate' can be used and the original order is maintained\n-  for (int i = list.size()-1; i >= 0; i--) {\n+  \/\/ Process in reverse order such that 'create_new_if_for_predicate' can be used in 'clone_skeleton_predicate_for_unswitched_loops'\n+  \/\/ and the original order is maintained.\n+  for (int i = list.size() - 1; i >= 0; i--) {\n@@ -267,3 +266,4 @@\n-    \/\/ cloned_proj is the same type of projection as the original predicate projection (IfTrue or IfFalse)\n-    ProjNode* fast_proj = create_new_if_for_predicate(iffast, NULL, reason, iff->Opcode(), predicate_proj->is_IfTrue());\n-    ProjNode* slow_proj = create_new_if_for_predicate(ifslow, NULL, reason, iff->Opcode(), predicate_proj->is_IfTrue());\n+    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, iffast_pred, loop);\n+    assert(skeleton_predicate_has_opaque(fast_proj->in(0)->as_If()), \"must find skeleton predicate for fast loop\");\n+    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, ifslow_pred, loop);\n+    assert(skeleton_predicate_has_opaque(slow_proj->in(0)->as_If()), \"must find skeleton predicate for slow loop\");\n@@ -271,6 +271,3 @@\n-    \/\/ Replace bool input by input from original predicate\n-    _igvn.replace_input_of(fast_proj->in(0), 1, iff->in(1));\n-    _igvn.replace_input_of(slow_proj->in(0), 1, iff->in(1));\n-\n-    for (DUIterator i = predicate->outs(); predicate->has_out(i); i++) {\n-      Node* fast_node = predicate->out(i);\n+    \/\/ Update control dependent data nodes.\n+    for (DUIterator j = predicate->outs(); predicate->has_out(j); j++) {\n+      Node* fast_node = predicate->out(j);\n@@ -283,1 +280,1 @@\n-        --i;\n+        --j;\n@@ -286,2 +283,1 @@\n-    \/\/ Have to delay updates to the slow loop so uses of predicate are\n-    \/\/ not modified while we iterate on them.\n+    \/\/ Have to delay updates to the slow loop so uses of predicate are not modified while we iterate on them.\n@@ -295,0 +291,14 @@\n+\/\/ Clone a skeleton predicate for an unswitched loop. OpaqueLoopInit and OpaqueLoopStride nodes are cloned and uncommon\n+\/\/ traps are kept for the predicate (a Halt node is used later when creating pre\/main\/post loops and copying this cloned\n+\/\/ predicate again).\n+ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj,\n+                                                                    Deoptimization::DeoptReason reason, ProjNode* output_proj,\n+                                                                    IdealLoopTree* loop) {\n+  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, predicate, uncommon_proj, output_proj, loop);\n+  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(), predicate->is_IfTrue());\n+  _igvn.replace_input_of(proj->in(0), 1, bol);\n+  _igvn.replace_input_of(output_proj->in(0), 0, proj);\n+  set_idom(output_proj->in(0), proj, dom_depth(proj));\n+  return proj;\n+}\n+\n@@ -297,1 +307,1 @@\n-void PhaseIdealLoop::clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast, ProjNode*& ifslow) {\n+void PhaseIdealLoop::clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred) {\n@@ -321,3 +331,3 @@\n-    iffast = clone_predicate_to_unswitched_loop(predicate_proj, iffast, Deoptimization::Reason_predicate);\n-    ifslow = clone_predicate_to_unswitched_loop(predicate_proj, ifslow, Deoptimization::Reason_predicate);\n-    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, predicate_proj, iffast, ifslow);\n+    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate);\n+    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, predicate_proj, iffast_pred, ifslow_pred);\n@@ -325,2 +335,2 @@\n-    check_created_predicate_for_unswitching(iffast);\n-    check_created_predicate_for_unswitching(ifslow);\n+    check_created_predicate_for_unswitching(iffast_pred);\n+    check_created_predicate_for_unswitching(ifslow_pred);\n@@ -330,3 +340,3 @@\n-    iffast = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast, Deoptimization::Reason_profile_predicate);\n-    ifslow = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow, Deoptimization::Reason_profile_predicate);\n-    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_profile_predicate, profile_predicate_proj, iffast, ifslow);\n+    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred, Deoptimization::Reason_profile_predicate);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred, Deoptimization::Reason_profile_predicate);\n+    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_profile_predicate, profile_predicate_proj, iffast_pred, ifslow_pred);\n@@ -334,2 +344,2 @@\n-    check_created_predicate_for_unswitching(iffast);\n-    check_created_predicate_for_unswitching(ifslow);\n+    check_created_predicate_for_unswitching(iffast_pred);\n+    check_created_predicate_for_unswitching(ifslow_pred);\n@@ -341,2 +351,2 @@\n-    iffast = clone_predicate_to_unswitched_loop(limit_check_proj, iffast, Deoptimization::Reason_loop_limit_check);\n-    ifslow = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow, Deoptimization::Reason_loop_limit_check);\n+    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred, Deoptimization::Reason_loop_limit_check);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred, Deoptimization::Reason_loop_limit_check);\n@@ -344,2 +354,2 @@\n-    check_created_predicate_for_unswitching(iffast);\n-    check_created_predicate_for_unswitching(ifslow);\n+    check_created_predicate_for_unswitching(iffast_pred);\n+    check_created_predicate_for_unswitching(ifslow_pred);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1259,1 +1259,1 @@\n-        prev_proj = clone_skeleton_predicate(iff, opaque_init, NULL, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_loop(iff, opaque_init, NULL, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n@@ -1262,1 +1262,1 @@\n-        prev_proj = clone_skeleton_predicate(iff, init, stride, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, stride, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n@@ -1336,2 +1336,5 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                               Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj) {\n+\/\/ Clone the skeleton predicate bool for a main or unswitched loop:\n+\/\/ Main loop: Set new_init and new_stride nodes as new inputs.\n+\/\/ Unswitched loop: new_init and new_stride are both NULL. Clone OpaqueLoopInit and OpaqueLoopStride instead.\n+Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n+                                                    Node* control, IdealLoopTree* outer_loop) {\n@@ -1342,0 +1345,2 @@\n+  bool is_unswitched_loop = new_init == NULL && new_stride == NULL;\n+  assert(new_init != NULL || is_unswitched_loop, \"new_init must be set when new_stride is non-null\");\n@@ -1353,2 +1358,2 @@\n-        to_clone.push(m, 1);\n-        continue;\n+      to_clone.push(m, 1);\n+      continue;\n@@ -1359,1 +1364,1 @@\n-        register_new_node(n, current_proj);\n+        register_new_node(n, control);\n@@ -1362,0 +1367,4 @@\n+        if (is_unswitched_loop && m->_idx < current && new_init == NULL) {\n+          new_init = m->clone();\n+          register_new_node(new_init, control);\n+        }\n@@ -1365,0 +1374,4 @@\n+        if (is_unswitched_loop && m->_idx < current && new_stride == NULL) {\n+          new_stride = m->clone();\n+          register_new_node(new_stride, control);\n+        }\n@@ -1371,1 +1384,1 @@\n-    for (;;) {\n+    while (true) {\n@@ -1389,1 +1402,1 @@\n-          register_new_node(next, current_proj);\n+          register_new_node(next, control);\n@@ -1397,0 +1410,3 @@\n+  assert(!is_unswitched_loop || new_init != NULL, \"new_init must always be found and cloned\");\n+  return result;\n+}\n@@ -1398,0 +1414,5 @@\n+\/\/ Clone a skeleton predicate for the main loop. new_init and new_stride are set as new inputs. Since the predicates cannot fail at runtime,\n+\/\/ Halt nodes are inserted instead of uncommon traps.\n+Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n+                                                             Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, predicate, uncommon_proj, control, outer_loop);\n@@ -1404,1 +1425,1 @@\n-  Node *frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n+  Node* frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n@@ -1409,1 +1430,1 @@\n-  new_iff->set_req(0, prev_proj);\n+  new_iff->set_req(0, input_proj);\n@@ -1411,1 +1432,1 @@\n-  register_control(new_iff, outer_loop->_parent, prev_proj);\n+  register_control(new_iff, outer_loop->_parent, input_proj);\n@@ -1907,1 +1928,1 @@\n-        prev_proj = clone_skeleton_predicate(iff, init, max_value, entry, proj, ctrl, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, max_value, entry, proj, ctrl, outer_loop, prev_proj);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -913,2 +913,4 @@\n-  Node* clone_skeleton_predicate(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                 Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj);\n+  Node* clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n+                                               IdealLoopTree* outer_loop, Node* input_proj);\n+  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n+                                      IdealLoopTree* outer_loop);\n@@ -1560,1 +1562,1 @@\n-  void clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast, ProjNode*& ifslow);\n+  void clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred);\n@@ -1563,1 +1565,3 @@\n-                                      ProjNode* old_predicate_proj, ProjNode* iffast, ProjNode* ifslow);\n+                                                    ProjNode* old_predicate_proj, ProjNode* iffast_pred, ProjNode* ifslow_pred);\n+  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj, Deoptimization::DeoptReason reason,\n+                                                          ProjNode* output_proj, IdealLoopTree* loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,0 +66,10 @@\n+ProjNode* MultiNode::proj_out_or_null(uint which_proj, bool is_io_use) const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    ProjNode* proj = fast_out(i)->isa_Proj();\n+    if (proj != NULL && (proj->_con == which_proj) && (proj->_is_io_use == is_io_use)) {\n+      return proj;\n+    }\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-\n+  ProjNode* proj_out_or_null(uint which_proj, bool is_io_use) const;\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/callGenerator.hpp\"\n@@ -557,1 +558,0 @@\n-  \/\/ cloning CallNode may need to clone JVMState\n@@ -559,0 +559,1 @@\n+    \/\/ cloning CallNode may need to clone JVMState\n@@ -560,0 +561,6 @@\n+    \/\/ CallGenerator is linked to the original node.\n+    CallGenerator* cg = n->as_Call()->generator();\n+    if (cg != NULL) {\n+      CallGenerator* cloned_cg = cg->with_call_node(n->as_Call());\n+      n->as_Call()->set_generator(cloned_cg);\n+    }\n@@ -1406,12 +1413,0 @@\n-      if (dead->is_macro()) {\n-        igvn->C->remove_macro_node(dead);\n-      }\n-      if (dead->is_expensive()) {\n-        igvn->C->remove_expensive_node(dead);\n-      }\n-      if (dead->for_post_loop_opts_igvn()) {\n-        igvn->C->remove_from_post_loop_opts_igvn(dead);\n-      }\n-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-      bs->unregister_potential_barrier_node(dead);\n-      igvn->C->record_dead_node(dead->_idx);\n@@ -1440,1 +1435,1 @@\n-      igvn->C->remove_modified_node(dead);\n+      igvn->C->remove_useless_node(dead);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1120,4 +1120,6 @@\n-  while (modified_list->size()) {\n-    Node* n = modified_list->pop();\n-    n->dump();\n-    assert(false, \"VerifyIterativeGVN: new modified node was added\");\n+  if (modified_list != NULL) {\n+    while (modified_list->size() > 0) {\n+      Node* n = modified_list->pop();\n+      n->dump();\n+      assert(false, \"VerifyIterativeGVN: new modified node was added\");\n+    }\n@@ -1412,20 +1414,1 @@\n-      C->remove_modified_node(dead);\n-      \/\/ Constant node that has no out-edges and has only one in-edge from\n-      \/\/ root is usually dead. However, sometimes reshaping walk makes\n-      \/\/ it reachable by adding use edges. So, we will NOT count Con nodes\n-      \/\/ as dead to be conservative about the dead node count at any\n-      \/\/ given time.\n-      if (!dead->is_Con()) {\n-        C->record_dead_node(dead->_idx);\n-      }\n-      if (dead->is_macro()) {\n-        C->remove_macro_node(dead);\n-      }\n-      if (dead->is_expensive()) {\n-        C->remove_expensive_node(dead);\n-      }\n-      if (dead->for_post_loop_opts_igvn()) {\n-        C->remove_from_post_loop_opts_igvn(dead);\n-      }\n-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-      bs->unregister_potential_barrier_node(dead);\n+      C->remove_useless_node(dead);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  PHASE_INCREMENTAL_INLINE_CLEANUP,\n@@ -114,0 +115,1 @@\n+      case PHASE_INCREMENTAL_INLINE_CLEANUP: return \"Incremental Inline Cleanup\";\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1331,1 +1331,1 @@\n-  if (d1 + 1 == d2) {\n+  if (d2 > d1) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -255,0 +255,8 @@\n+  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n+  void remove_till(int idx) {\n+    for (int i = 0, j = idx; j < length(); i++, j++) {\n+      at_put(i, at(j));\n+    }\n+    trunc_to(length() - idx);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,1 @@\n-        return nonce.clone();\n+        return (nonce != null) ? nonce.clone() : null;\n@@ -229,0 +229,5 @@\n+            \/\/ In a pre-initialized state or any state without a nonce value\n+            \/\/ this call should cause a random nonce to be generated, but\n+            \/\/ not attached to the object.\n+            byte[] nonceData = (initialized || nonce != null) ? nonce :\n+                    createRandomNonce(null);\n@@ -233,1 +238,1 @@\n-                        DerValue.tag_OctetString, nonce).toByteArray()));\n+                        DerValue.tag_OctetString, nonceData).toByteArray()));\n@@ -507,1 +512,1 @@\n-    private byte[] createRandomNonce(SecureRandom random) {\n+    private static byte[] createRandomNonce(SecureRandom random) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -173,5 +173,4 @@\n-        try {\n-            String p = toAbsolutePath().path;\n-            if (!p.startsWith(\"\/modules\") || p.contains(\"..\")) {\n-                throw new IOError(new RuntimeException(p + \" cannot be represented as URI\"));\n-            }\n+        String p = toAbsolutePath().path;\n+        if (!p.startsWith(\"\/modules\") || p.contains(\"..\")) {\n+            throw new IOError(new RuntimeException(p + \" cannot be represented as URI\"));\n+        }\n@@ -179,7 +178,3 @@\n-            p = p.substring(\"\/modules\".length());\n-            if (p.isEmpty()) {\n-                p = \"\/\";\n-            }\n-            return new URI(\"jrt\", p, null);\n-        } catch (URISyntaxException ex) {\n-            throw new AssertionError(ex);\n+        p = p.substring(\"\/modules\".length());\n+        if (p.isEmpty()) {\n+            p = \"\/\";\n@@ -187,0 +182,1 @@\n+        return toUri(p);\n@@ -828,0 +824,131 @@\n+\n+    \/\/ adopted from sun.nio.fs.UnixUriUtils\n+    private static URI toUri(String str) {\n+        char[] path = str.toCharArray();\n+        assert path[0] == '\/';\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(path[0]);\n+        for (int i = 1; i < path.length; i++) {\n+            char c = (char)(path[i] & 0xff);\n+            if (match(c, L_PATH, H_PATH)) {\n+                sb.append(c);\n+            } else {\n+                sb.append('%');\n+                sb.append(hexDigits[(c >> 4) & 0x0f]);\n+                sb.append(hexDigits[(c) & 0x0f]);\n+            }\n+        }\n+\n+        try {\n+            return new URI(\"jrt:\" + sb.toString());\n+        } catch (URISyntaxException x) {\n+            throw new AssertionError(x);  \/\/ should not happen\n+        }\n+    }\n+\n+    \/\/ The following is copied from java.net.URI\n+\n+    \/\/ Compute the low-order mask for the characters in the given string\n+    private static long lowMask(String chars) {\n+        int n = chars.length();\n+        long m = 0;\n+        for (int i = 0; i < n; i++) {\n+            char c = chars.charAt(i);\n+            if (c < 64)\n+                m |= (1L << c);\n+        }\n+        return m;\n+    }\n+\n+    \/\/ Compute the high-order mask for the characters in the given string\n+    private static long highMask(String chars) {\n+        int n = chars.length();\n+        long m = 0;\n+        for (int i = 0; i < n; i++) {\n+            char c = chars.charAt(i);\n+            if ((c >= 64) && (c < 128))\n+                m |= (1L << (c - 64));\n+        }\n+        return m;\n+    }\n+\n+    \/\/ Compute a low-order mask for the characters\n+    \/\/ between first and last, inclusive\n+    private static long lowMask(char first, char last) {\n+        long m = 0;\n+        int f = Math.max(Math.min(first, 63), 0);\n+        int l = Math.max(Math.min(last, 63), 0);\n+        for (int i = f; i <= l; i++)\n+            m |= 1L << i;\n+        return m;\n+    }\n+\n+    \/\/ Compute a high-order mask for the characters\n+    \/\/ between first and last, inclusive\n+    private static long highMask(char first, char last) {\n+        long m = 0;\n+        int f = Math.max(Math.min(first, 127), 64) - 64;\n+        int l = Math.max(Math.min(last, 127), 64) - 64;\n+        for (int i = f; i <= l; i++)\n+            m |= 1L << i;\n+        return m;\n+    }\n+\n+    \/\/ Tell whether the given character is permitted by the given mask pair\n+    private static boolean match(char c, long lowMask, long highMask) {\n+        if (c < 64)\n+            return ((1L << c) & lowMask) != 0;\n+        if (c < 128)\n+            return ((1L << (c - 64)) & highMask) != 0;\n+        return false;\n+    }\n+\n+    \/\/ digit    = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" |\n+    \/\/            \"8\" | \"9\"\n+    private static final long L_DIGIT = lowMask('0', '9');\n+    private static final long H_DIGIT = 0L;\n+\n+    \/\/ upalpha  = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" |\n+    \/\/            \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" |\n+    \/\/            \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"\n+    private static final long L_UPALPHA = 0L;\n+    private static final long H_UPALPHA = highMask('A', 'Z');\n+\n+    \/\/ lowalpha = \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" |\n+    \/\/            \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" |\n+    \/\/            \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\"\n+    private static final long L_LOWALPHA = 0L;\n+    private static final long H_LOWALPHA = highMask('a', 'z');\n+\n+    \/\/ alpha         = lowalpha | upalpha\n+    private static final long L_ALPHA = L_LOWALPHA | L_UPALPHA;\n+    private static final long H_ALPHA = H_LOWALPHA | H_UPALPHA;\n+\n+    \/\/ alphanum      = alpha | digit\n+    private static final long L_ALPHANUM = L_DIGIT | L_ALPHA;\n+    private static final long H_ALPHANUM = H_DIGIT | H_ALPHA;\n+\n+    \/\/ mark          = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" |\n+    \/\/                 \"(\" | \")\"\n+    private static final long L_MARK = lowMask(\"-_.!~*'()\");\n+    private static final long H_MARK = highMask(\"-_.!~*'()\");\n+\n+    \/\/ unreserved    = alphanum | mark\n+    private static final long L_UNRESERVED = L_ALPHANUM | L_MARK;\n+    private static final long H_UNRESERVED = H_ALPHANUM | H_MARK;\n+\n+    \/\/ pchar         = unreserved | escaped |\n+    \/\/                 \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"\n+    private static final long L_PCHAR\n+        = L_UNRESERVED | lowMask(\":@&=+$,\");\n+    private static final long H_PCHAR\n+        = H_UNRESERVED | highMask(\":@&=+$,\");\n+\n+   \/\/ All valid path characters\n+   private static final long L_PATH = L_PCHAR | lowMask(\";\/\");\n+   private static final long H_PATH = H_PCHAR | highMask(\";\/\");\n+\n+   private static final char[] hexDigits = {\n+        '0', '1', '2', '3', '4', '5', '6', '7',\n+        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n+    };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtPath.java","additions":139,"deletions":12,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+ * Use of signal() and sigset() is now deprecated as these old API's should\n+ * not be used - sigaction is the only truly supported API.\n@@ -102,0 +104,4 @@\n+    \/\/ Deprecation warning first time through\n+    printf(HOTSPOT_VM_DISTRO \" VM warning: the use of signal() and sigset() \"\n+           \"for signal chaining was deprecated in version 16.0 and will \"\n+           \"be removed in a future release. Use sigaction() instead.\\n\");\n","filename":"src\/java.base\/unix\/native\/libjsig\/jsig.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-     * @jls 3.10.7 The Null Literal\n+     * @jls 3.10.8 The Null Literal\n@@ -413,1 +413,1 @@\n-     * @jls 3.10.7 The Null Literal\n+     * @jls 3.10.8 The Null Literal\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-     * @jls 15.28 Constant Expression\n+     * @jls 15.29 Constant Expressions\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2558,1 +2558,1 @@\n-            endPosTable.storeEnd(clazzid1, tree.getEndPosition(endPosTable));\n+            endPosTable.storeEnd(clazzid1, clazzid.getEndPosition(endPosTable));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1330,0 +1330,8 @@\n+                        if (token.pos <= endPosTable.errorEndPos &&\n+                            token.kind == MONKEYS_AT) {\n+                            \/\/error recovery, case like:\n+                            \/\/int i = expr.<missing-ident>\n+                            \/\/@Deprecated\n+                            if (typeArgs != null) illegal();\n+                            return toP(t);\n+                        }\n@@ -1537,0 +1545,7 @@\n+                    if (token.pos <= endPosTable.errorEndPos &&\n+                        token.kind == MONKEYS_AT) {\n+                        \/\/error recovery, case like:\n+                        \/\/int i = expr.<missing-ident>\n+                        \/\/@Deprecated\n+                        break;\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * Defines the experimental foreign memory access API.\n+ * Defines an API for accessing foreign memory and calling foreign functions, directly from Java.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+     * <p>\n+     * It's possible to index into a nested field by using {@code \".\"} (for\n+     * instance {@code \"thread.group.parent.name}\").\n@@ -85,1 +88,6 @@\n-        return cache.get(name);\n+        ValueDescriptor result = cache.get(name);\n+        if (result == null) {\n+            \/\/ Cache doesn't contain subfields\n+            result = platformEventType.getField(name);\n+        }\n+        return result;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventType.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -192,0 +192,3 @@\n+     * <p>\n+     * It's possible to index into a nested field by using {@code \".\"} (for\n+     * instance {@code \"thread.group.parent.name}\").\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedObject.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -194,0 +194,20 @@\n+    public ValueDescriptor getField(String name) {\n+        int dotIndex = name.indexOf(\".\");\n+        if (dotIndex > 0) {\n+            String pre = name.substring(0, dotIndex);\n+            String post = name.substring(dotIndex + 1);\n+            ValueDescriptor subField = getField(pre);\n+            if (subField != null) {\n+                Type type = PrivateAccess.getInstance().getType(subField);\n+                return type.getField(post);\n+            }\n+        } else {\n+            for (ValueDescriptor v : getFields()) {\n+                if (name.equals(v.getName())) {\n+                    return v;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Type.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -641,1 +641,1 @@\n-            throw new Error(msg, e);\n+            throw new InternalError(msg, e);\n@@ -643,1 +643,1 @@\n-            throw new Error(msg);\n+            throw new InternalError(msg);\n","filename":"src\/utils\/LogCompilation\/src\/main\/java\/com\/sun\/hotspot\/tools\/compiler\/LogParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build compiler.blackhole.BlackholeTarget\n+ * @run driver compiler.blackhole.BlackholeDiagnosticUnlockTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeDiagnosticUnlockTest {\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    public static void driver() throws IOException {\n+       final String msg = \"Blackhole compile option is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions\";\n+\n+       if (!Platform.isDebugBuild()) { \/\/ UnlockDiagnosticVMOptions is true in debug\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-Xbatch\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\",\n+               \"compiler.blackhole.BlackholeDiagnosticUnlockTest\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldContain(msg);\n+       }\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-XX:-PrintWarnings\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\",\n+               \"compiler.blackhole.BlackholeDiagnosticUnlockTest\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldNotContain(msg);\n+       }\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-XX:+UnlockDiagnosticVMOptions\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\",\n+               \"compiler.blackhole.BlackholeDiagnosticUnlockTest\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldNotContain(msg);\n+       }\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_1(c);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeDiagnosticUnlockTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @build compiler.blackhole.BlackholeTarget\n- * @run driver compiler.blackhole.BlackholeNonVoidWarning\n- *\/\n-\n-package compiler.blackhole;\n-\n-import java.io.IOException;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class BlackholeNonVoidWarning {\n-\n-    private static final int CYCLES = 1_000_000;\n-    private static final int TRIES = 10;\n-\n-    public static void main(String[] args) throws IOException {\n-        if (args.length == 0) {\n-            driver();\n-        } else {\n-            runner();\n-        }\n-    }\n-\n-    public static void driver() throws IOException {\n-       final String msg = \"blackhole compile command only works for methods with void type: compiler.blackhole.BlackholeTarget.bh_sr_int(I)I\";\n-\n-       {\n-           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-               \"-Xmx128m\",\n-               \"-Xbatch\",\n-               \"-XX:CompileCommand=quiet\",\n-               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n-               \"compiler.blackhole.BlackholeNonVoidWarning\",\n-               \"run\"\n-           );\n-           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-           output.shouldHaveExitValue(0);\n-           output.shouldContain(msg);\n-       }\n-\n-       {\n-           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-               \"-Xmx128m\",\n-               \"-XX:-PrintWarnings\",\n-               \"-XX:CompileCommand=quiet\",\n-               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n-               \"compiler.blackhole.BlackholeNonVoidWarning\",\n-               \"run\"\n-           );\n-           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-           output.shouldHaveExitValue(0);\n-           output.shouldNotContain(msg);\n-       }\n-    }\n-\n-    public static void runner() {\n-        for (int t = 0; t < TRIES; t++) {\n-            run();\n-        }\n-    }\n-\n-    public static void run() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (BlackholeTarget.bh_sr_int(c) != 0) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonVoidWarning.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build compiler.blackhole.BlackholeTarget\n+ * @run driver compiler.blackhole.BlackholeNonVoidWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonVoidWarningTest {\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    public static void driver() throws IOException {\n+       final String msg = \"Blackhole compile option only works for methods with void type: compiler.blackhole.BlackholeTarget.bh_sr_int(I)I\";\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-Xbatch\",\n+               \"-XX:+UnlockDiagnosticVMOptions\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n+               \"compiler.blackhole.BlackholeNonVoidWarningTest\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldContain(msg);\n+       }\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-XX:-PrintWarnings\",\n+               \"-XX:+UnlockDiagnosticVMOptions\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n+               \"compiler.blackhole.BlackholeNonVoidWarningTest\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldNotContain(msg);\n+       }\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonVoidWarningTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires os.arch!=\"x86\" & os.arch!=\"i386\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHA512IntrinsicsOptionOnSupportedCPU.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253644\n+ * @summary Test the complete cloning of skeleton predicates to unswitched loops as done when cloning them to the main loop.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.loopopts.TestUnswitchCloneSkeletonPredicates::*\n+ *                   compiler.loopopts.TestUnswitchCloneSkeletonPredicates\n+ * @run main\/othervm -Xcomp -XX:-PartialPeelLoop -XX:CompileCommand=compileonly,compiler.loopopts.TestUnswitchCloneSkeletonPredicates::*\n+ *                   compiler.loopopts.TestUnswitchCloneSkeletonPredicates\n+ * @run main\/othervm -XX:-PartialPeelLoop compiler.loopopts.TestUnswitchCloneSkeletonPredicates\n+ *\/\n+package compiler.loopopts;\n+\n+public class TestUnswitchCloneSkeletonPredicates {\n+\n+    static int x = 0;\n+    static int y = 20;\n+    static int intArr[] = new int[21000];\n+    static int idx = 0;\n+    static boolean bFld = true;\n+    static int iFld = 20;\n+    static int iFld2 = 0 ;\n+    static int iArrFld[] = new int[50];\n+    static float fArrFld[] = new float[50];\n+\n+\n+    \/\/ Only triggers with -XX:-PartialPeelLoop\n+    \/*\n+     * The inner loop is unswitched on (1) which creates a fast and a slow loop that both have (1) removed and instead\n+     * (1) is executed before the loop at (3). With the SplitIf optimization we find that (3) dominates (2) in both loops.\n+     *\n+     * As a result, we can remove (2) from both loops. This, however, has an influence on how the loop tree is built.\n+     * Before the SplitIf optimization, the loop tree looks like this:\n+     * Loop: N0\/N0  has_sfpt\n+     *   Loop: N338\/N314  limit_check profile_predicated predicated counted [0,100),+1 (2 iters)  has_sfpt\n+     *     Loop: N459\/N458  profile_predicated predicated counted [0,10000),+1 (5271 iters)  has_sfpt (slow loop)\n+     *     Loop: N343\/N267  profile_predicated predicated counted [0,10000),+1 (5271 iters)  has_sfpt (fast loop)\n+     *\n+     * Both unswitched loop have a copy of the skeleton predicate If node that share the same Opaque4 node with its inputs.\n+     * The inner loop is never exited normally due to always returning on (4). This means that the branch that exits the\n+     * loop on the loop limit check is never taken and has an uncommon trap. Nevertheless, the loop building algorithm still\n+     * identifies the fast and the slow loop as children of N338 because of the condition (2) over which the loop is left.\n+     * However, after the above mentioned SplitIf optimization the condition (2) is removed from both loops. As a result,\n+     * the slow loops (N459) is always exited immediately (x == 100 holds) because the break is executed on the first\n+     * iteration of the loop. The loop can be removed (but these nodes are still part of the parent loop N338). The fast loop\n+     * (N343), however, is now never exited normally and always returns on the 9800th iteration over (4). The normal loop exit\n+     * over the loop limit check is never taken (uncommon trap). Due to the last loop exit (2) being removed, N343 is no longer\n+     * recognized as a child loop of N338 due to not having a backedge to the parent loop. The loop tree looks like this:\n+     * Loop: N0\/N0  has_sfpt\n+     *   Loop: N338\/N314  limit_check profile_predicated predicated counted [0,100),+1 (2 iters)  has_sfpt\n+     *   Loop: N343\/N267  profile_predicated predicated counted [0,10000),+1 (5274 iters)  has_sfpt\n+     *\n+     * As a next step, the original parent loop N338 is peeled. The fast and the slow loop still both share skeleton Opaque4 bool\n+     * nodes with all its inputs nodes up to and including the OpaqueLoopInit\/Stride nodes. These skeleton predicates are still there\n+     * even though the slow loop N459 could have been removed (the Opaque4 nodes are only removed after loop opts). Let's look at one\n+     * of the skeleton If nodes for the fast loop that uses such a Opaque4 node. The skeleton 'If' is no longer part of the original\n+     * parent loop and is therefore not peeled. But now we need some phi nodes to select the correct nodes either from the peeled\n+     * iteration or from N338 for this skeleton If of the fast loop. This is done in PhaseIdealLoop::clone_iff() which creates\n+     * a new Opaque4 node together with new Bool and Cmp nodes and then inserts some phi nodes to do the selection.\n+     *\n+     * When afterwards creating pre\/main\/post loops for the fast loop (N343) that is no child anymore, we find these phi nodes on the\n+     * path to the OpaqueLoopInit\/Stride nodes which lets the assertion PhaseIdealLoop::skeleton_predicate_has_opaque() fail. These\n+     * phi nodes on the path to the OpaqueLoopInit\/Stride nodes are unexpected.\n+     *\n+     * The solution to this problem is to clone the skeleton predicates completely, including clones of all nodes up to and including\n+     * the OpaqueLoopInit\/Stride nodes (similar to what is done when copying skeleton predicates to the main loop) instead of just\n+     * sharing Opaque4 nodes.\n+     *\/\n+    public static int test1() {\n+      int i = 0;\n+      while (i < 100) {\n+          int j = 0;\n+          \/\/ (3) <new unswitch condition>\n+          while (j < 10000)  {\n+              if (x == 100) { \/\/ (1) Loop is unswitched on this condition -> condition shared with (2)\n+                  y = 34;\n+              }\n+\n+              intArr[idx] = 34;\n+              intArr[2*j + 35] = 45;\n+\n+              if (x == 100) { \/\/ (2)\n+                  y = 35;\n+                  break;\n+              }\n+              if (j == 9800) { \/\/ (4)\n+                  return 2;\n+              }\n+              j++;\n+          }\n+          i++;\n+          intArr[i] = 45;\n+      }\n+      return y;\n+    }\n+\n+    \/\/ Only triggers with -XX:-PartialPeelLoop\n+    public static int test2() {\n+      int i = 0;\n+      while (i < 100) {\n+          int j = 0;\n+          while (j < 10000)  {\n+              if (x == 100) {\n+                  y = 34;\n+              }\n+\n+              intArr[2*j + 35] = 45;\n+\n+              if (x == 100) {\n+                  y = 35;\n+                  break;\n+              }\n+              if (j == 9800) {\n+                  return 2;\n+              }\n+              j++;\n+          }\n+          i++;\n+          intArr[i] = 45;\n+      }\n+      return y;\n+    }\n+\n+    \/\/ Only triggers with -XX:-PartialPeelLoop\n+    public static int test3() {\n+      int i = 0;\n+      while (i < 100) {\n+          int j = 0;\n+          while (j < 10000)  {\n+              if (x == 100) {\n+                  y = 34;\n+              }\n+\n+              intArr[idx] = 34;\n+              intArr[2*j + 35] = 45;\n+\n+              if (x == 100) {\n+                  y = 35;\n+                  break;\n+              }\n+              if (j == 9800) {\n+                  return 2;\n+              }\n+              j++;\n+          }\n+          i++;\n+      }\n+      return y;\n+}\n+\n+    \/\/ Test that has two loop headers for a single loop (limitation of type flow, see JDK-8255663)\n+    \/\/ which also triggers the assertion failure of this bug.\n+    public static void test4() {\n+        int unused = 500; \/\/ Required, even though unused\n+        boolean b = true;\n+        int i = 1;\n+        while (++i < 35) {\n+            iArrFld[i] = 6;\n+            switch (iFld2) {\n+            case 40:\n+                if (b) {\n+                    continue;\n+                }\n+                b = false;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that has two loop headers for a single loop (limitation of type flow, see JDK-8255663)\n+    \/\/ which also triggers the assertion failure of this bug. Only triggers with -XX:-PartialPeelLoop.\n+    public static void test5() {\n+        int j = 50;\n+        int i = 1;\n+        while (++i < 40) {\n+            j = 5;\n+            do {\n+                fArrFld[i] = 46;\n+                iFld = 5;\n+                if (bFld) break;\n+            } while (++j < 5);\n+            j = 2;\n+            do {\n+                try {\n+                    iFld = 56;\n+                } catch (ArithmeticException a_e) {}\n+                if (bFld) break;\n+            } while (++j < 2);\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 5000; i++) {\n+            test1();\n+            test2();\n+            test3();\n+            x++;\n+            x = x % 106;\n+        }\n+        test4();\n+        test5();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestUnswitchCloneSkeletonPredicates.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8153029\n+ * @bug 8153029 8257769\n@@ -45,0 +45,4 @@\n+import java.security.InvalidKeyException;\n+import java.security.MessageDigest;\n+import java.security.spec.InvalidParameterSpecException;\n+import javax.crypto.spec.IvParameterSpec;\n@@ -235,0 +239,105 @@\n+        \/\/ The next set of tests cover cases where ChaCha20-Poly1305 cipher\n+        \/\/ objects have the getParameters() call executed after instantiation\n+        \/\/ but before initialization.\n+        System.out.println(\"*** Test: getParameters before init\");\n+        cc20p1305 = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+        AlgorithmParameters algParams = cc20p1305.getParameters();\n+        byte[] preInitNonce = getNonceFromParams(algParams);\n+        \/\/ A second pre-init getParameters() call should return a new set of\n+        \/\/ random parameters.\n+        AlgorithmParameters algParamsTwo = cc20p1305.getParameters();\n+        byte[] secondNonce = getNonceFromParams(algParamsTwo);\n+        if (MessageDigest.isEqual(preInitNonce, secondNonce)) {\n+            throw new RuntimeException(\"Unexpected nonce match between \" +\n+                    \"two pre-init getParameters() calls\");\n+        }\n+\n+        \/\/ Next we will initialize the Cipher object using a form of init\n+        \/\/ that doesn't take AlgorithmParameters or AlgorithmParameterSpec.\n+        \/\/ The nonce created using the pre-init getParameters() call should\n+        \/\/ be overwritten by a freshly generated set of random parameters.\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+        AlgorithmParameters postInitAps = cc20p1305.getParameters();\n+        byte[] postInitNonce = getNonceFromParams(postInitAps);\n+        if (MessageDigest.isEqual(preInitNonce, postInitNonce)) {\n+            throw new RuntimeException(\"Unexpected nonce match between \" +\n+                    \"pre and post-init getParameters() calls\");\n+        }\n+        System.out.println(\"Test Passed\");\n+\n+        \/\/ After an initialization, subsequent calls to getParameters() should\n+        \/\/ return the same parameter value until the next initialization takes\n+        \/\/ place.\n+        System.out.println(\"*** Test: getParameters after init\");\n+        AlgorithmParameters postInitApsTwo = cc20p1305.getParameters();\n+        byte[] postInitNonceTwo = getNonceFromParams(postInitApsTwo);\n+        if (!MessageDigest.isEqual(postInitNonce, postInitNonceTwo)) {\n+            throw new RuntimeException(\"Unexpected nonce mismatch between \" +\n+                    \"two post-init getParameters() calls\");\n+        }\n+        System.out.println(\"Test Passed\");\n+\n+        \/\/ Test reinitialization use cases.\n+        \/\/ First test: instantiate, init(no param), encrypt.  Get params\n+        \/\/ and attempt to reinit with same parameters.  Should fail.\n+        System.out.println(\"*** Test: Init w\/ random nonce, init 2nd time\");\n+        cc20p1305 = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+        algParams = cc20p1305.getParameters();\n+        preInitNonce = getNonceFromParams(algParams);\n+        \/\/ Perform a simple encryption operation\n+        cc20p1305.doFinal(aeadTestList.get(0).input);\n+        try {\n+            \/\/ Now try to reinitialize using the same parameters\n+            cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY, algParams);\n+            throw new RuntimeException(\"Illegal key\/nonce reuse\");\n+        } catch (InvalidKeyException ike) {\n+            System.out.println(\"Caught expected exception: \" + ike);\n+        }\n+\n+        \/\/ Test the reinit guard using an AlgorithmParameterSpec with the\n+        \/\/ Same nonce value.  This should also be a failure.\n+        try {\n+            cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY,\n+                    new IvParameterSpec(preInitNonce));\n+            throw new RuntimeException(\"Illegal key\/nonce reuse\");\n+        } catch (InvalidKeyException ike) {\n+            System.out.println(\"Caught expected exception: \" + ike);\n+        }\n+\n+        \/\/ Try one more time, this time providing a new 12-byte nonce, which\n+        \/\/ should be allowed even if the key is the same.\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY,\n+                new IvParameterSpec(NONCE_OCTET_STR_12, 2, 12));\n+        System.out.println(\"Test Passed\");\n+\n+        \/\/ Reinit test: instantiate, init(no param), getParam, encrypt,\n+        \/\/ then init(no param).  Should work and the parameters should be\n+        \/\/ different after each init.\n+        cc20p1305 = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+        byte[] paramInitOne = getNonceFromParams(cc20p1305.getParameters());\n+        \/\/ Perform a simple encryption operation\n+        cc20p1305.doFinal(aeadTestList.get(0).input);\n+        \/\/ reinit (no params)\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+        byte[] paramInitTwo = getNonceFromParams(cc20p1305.getParameters());\n+        if (MessageDigest.isEqual(paramInitOne, paramInitTwo)) {\n+            throw new RuntimeException(\"Unexpected nonce match between \" +\n+                    \"pre and post-init getParameters() calls\");\n+        }\n+        System.out.println(\"Test Passed\");\n+\n+        \/\/ Reinit test: instantiate, init(no param), doFinal, then doFinal\n+        \/\/ again without intervening init.  Should fail due to no-reuse\n+        \/\/ protections.\n+        try {\n+            cc20p1305 = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+            cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+            cc20p1305.doFinal(aeadTestList.get(0).input);\n+            cc20p1305.doFinal(aeadTestList.get(0).input);\n+            throw new RuntimeException(\"Illegal key\/nonce reuse\");\n+        } catch (IllegalStateException ise) {\n+            System.out.println(\"Caught expected exception: \" + ise);\n+        }\n+\n@@ -377,0 +486,5 @@\n+    private static byte[] getNonceFromParams(AlgorithmParameters params)\n+            throws InvalidParameterSpecException {\n+        return params.getParameterSpec(IvParameterSpec.class).getIV();\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/ChaCha20Poly1305ParamTest.java","additions":116,"deletions":2,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8242258\n+ * @summary (jrtfs) Path::toUri throws AssertionError for malformed input\n+ * @run testng UriTests\n+ *\/\n+\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.net.URI;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+public class UriTests {\n+    private FileSystem theFileSystem;\n+\n+    @BeforeClass\n+    public void setup() {\n+       theFileSystem = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    }\n+\n+    @DataProvider(name = \"problemStrings\")\n+    private Object[][] problemStrings() {\n+        return new Object[][] {\n+            { \"[\", \"jrt:\/%5B\" },\n+            { \"]\", \"jrt:\/%5D\" },\n+            { \"{\", \"jrt:\/%7B\" },\n+            { \"}\", \"jrt:\/%7D\" },\n+            { \"`\", \"jrt:\/%60\" },\n+            { \"%\", \"jrt:\/%25\" },\n+            { \" xyz\", \"jrt:\/%20xyz\" },\n+            { \"xyz \", \"jrt:\/xyz%20\" },\n+            { \"xy z\", \"jrt:\/xy%20z\" },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"problemStrings\")\n+    public void testPathToURI(String pathSuffix, String uriStr) {\n+        URI uri = theFileSystem.getPath(\"\/modules\/\" + pathSuffix).toUri();\n+        assertEquals(uri.toString(), uriStr);\n+    }\n+\n+    @Test(dataProvider = \"problemStrings\")\n+    public void testURIToPath(String pathSuffix, String uriStr) {\n+        Path path = theFileSystem.provider().getPath(URI.create(uriStr));\n+        assertEquals(path.toString(), \"\/modules\/\" + pathSuffix);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/UriTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-        Asserts.assertNotNull(v, \"getFiled(myByte) was null\");\n+        Asserts.assertNotNull(v, \"getField(myByte) was null\");\n@@ -51,1 +51,1 @@\n-        Asserts.assertNotNull(v, \"getFiled(myInt) was null\");\n+        Asserts.assertNotNull(v, \"getField(myInt) was null\");\n@@ -54,0 +54,4 @@\n+        v = type.getField(\"eventThread.group.name\");\n+        Asserts.assertNotNull(v, \"getField(eventThread.group.name) was null\");\n+        Asserts.assertEquals(v.getTypeName(), \"java.lang.String\", \"eventThread.group.name was not type java.lang.String\");\n+\n@@ -63,0 +67,1 @@\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/eventtype\/TestGetField.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @bug 8256818\n+ * @bug 8256818 8257670\n@@ -37,1 +37,1 @@\n- * @run main\/othervm SSLSocketLeak\n+ * @run main\/manual SSLSocketLeak\n@@ -39,0 +39,1 @@\n+\/\/ Note: this test is not reliable, run it manually.\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketLeak.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SafeVarargsNotApplicableToRecordAccessors.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149\n@@ -87,0 +87,1 @@\n+import java.util.Objects;\n@@ -1614,0 +1615,79 @@\n+    @Test\n+    void testAtRecovery() throws IOException {\n+        \/\/verify the errors and AST form produced for member selects which are\n+        \/\/missing the selected member name and are followed by an annotation:\n+        String code = \"\"\"\n+                      package t;\n+                      class Test {\n+                          int i1 = \"\".\n+                          @Deprecated\n+                          void t1() {\n+                          }\n+                          int i2 = String.\n+                          @Deprecated\n+                          void t2() {\n+                          }\n+                      }\n+                      \"\"\";\n+        StringWriter out = new StringWriter();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(out, fm, null, List.of(\"-XDrawDiagnostics\"),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        String ast = ct.parse().iterator().next().toString().replaceAll(\"\\\\R\", \"\\n\");\n+        String expected = \"\"\"\n+                          package t;\n+                          \\n\\\n+                          class Test {\n+                              int i1 = \"\".<error>;\n+                              \\n\\\n+                              @Deprecated\n+                              void t1() {\n+                              }\n+                              int i2 = String.<error>;\n+                              \\n\\\n+                              @Deprecated\n+                              void t2() {\n+                              }\n+                          } \"\"\";\n+        assertEquals(\"Unexpected AST, got:\\n\" + ast, expected, ast);\n+        assertEquals(\"Unexpected errors, got:\\n\" + out.toString(),\n+                     out.toString().replaceAll(\"\\\\R\", \"\\n\"),\n+                     \"\"\"\n+                     Test.java:3:17: compiler.err.expected: token.identifier\n+                     Test.java:7:21: compiler.err.expected: token.identifier\n+                     \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8256411\n+    void testBasedAnonymous() throws IOException {\n+        String code = \"\"\"\n+                      package t;\n+                      class Test {\n+                          class I {}\n+                          static Object I = new Test().new I() {};\n+                      }\n+                      \"\"\";\n+        StringWriter out = new StringWriter();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(out, fm, null, null,\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        Trees trees = Trees.instance(ct);\n+        SourcePositions sp = trees.getSourcePositions();\n+        ct.analyze();\n+        List<String> span = new ArrayList<>();\n+        new TreeScanner<Void, Void>() {\n+            public Void visitClass(ClassTree ct, Void v) {\n+                if (ct.getExtendsClause() != null) {\n+                    int start = (int) sp.getStartPosition(cut,\n+                                                           ct.getExtendsClause());\n+                    int end   = (int) sp.getEndPosition(cut,\n+                                                        ct.getExtendsClause());\n+                    span.add(code.substring(start, end));\n+                }\n+                return super.visitClass(ct, v);\n+            }\n+        }.scan(cut, null);\n+        if (!Objects.equals(span, Arrays.asList(\"I\"))) {\n+            throw new AssertionError(\"Unexpected span: \" + span);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -130,2 +130,2 @@\n-        compile(JavaSource.createJavaSource(\"Object o = new A().new B(); class A { }\",\n-                \"B()\"));\n+        compile(JavaSource.createJavaSource(\"Object o = new A().new BT(); class A { }\",\n+                \"BT\"));\n","filename":"test\/langtools\/tools\/javac\/positions\/TreeEndPosTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}