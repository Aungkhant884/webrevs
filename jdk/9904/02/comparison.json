{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/placeholders.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -36,1 +38,17 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+\/\/ Implementation Classes for Loader Constraints\n+\n+class LoaderConstraint : public CHeapObj<mtClass> {\n+  InstanceKlass*         _klass;\n+  \/\/ Loader constraints enforce correct linking behavior.\n+  \/\/ Thus, it really operates on ClassLoaderData which represents linking domain,\n+  \/\/ not class loaders.\n+  GrowableArray<ClassLoaderData*>*  _loaders;                \/\/ initiating loaders\n+ public:\n+  LoaderConstraint(InstanceKlass* klass, oop class_loader1, oop class_loader2) :\n+     _klass(klass) {\n+    _loaders = new (ResourceObj::C_HEAP, mtClass) GrowableArray<ClassLoaderData*>(10, mtClass);\n+    add_loader(class_loader1);\n+    add_loader(class_loader2);\n+  }\n@@ -38,3 +56,1 @@\n-void LoaderConstraintEntry::set_loader(int i, oop p) {\n-  set_loader_data(i, ClassLoaderData::class_loader_data(p));\n-}\n+  ~LoaderConstraint() { delete _loaders; }\n@@ -42,2 +58,2 @@\n-LoaderConstraintTable::LoaderConstraintTable(int table_size)\n-  : Hashtable<InstanceKlass*, mtClass>(table_size, sizeof(LoaderConstraintEntry)) {};\n+  InstanceKlass* klass() const     { return _klass; }\n+  void set_klass(InstanceKlass* k) { _klass = k; }\n@@ -45,0 +61,1 @@\n+  void extend_loader_constraint(Symbol* class_name, Handle loader, InstanceKlass* klass);\n@@ -46,11 +63,28 @@\n-LoaderConstraintEntry* LoaderConstraintTable::new_entry(\n-                                 unsigned int hash, Symbol* name,\n-                                 InstanceKlass* klass, int num_loaders,\n-                                 int max_loaders) {\n-  LoaderConstraintEntry* entry;\n-  entry = (LoaderConstraintEntry*)Hashtable<InstanceKlass*, mtClass>::new_entry(hash, klass);\n-  entry->set_name(name);\n-  entry->set_num_loaders(num_loaders);\n-  entry->set_max_loaders(max_loaders);\n-  return entry;\n-}\n+  int num_loaders() const { return _loaders->length(); }\n+  ClassLoaderData* loader_data(int i) { return _loaders->at(i); }\n+  void add_loader_data(ClassLoaderData* p) { _loaders->push(p); }\n+\n+  void remove_loader_at(int n) {\n+    assert(_loaders->at(n)->is_unloading(), \"should be unloading\");\n+    _loaders->remove_at(n);\n+  }\n+\n+  \/\/ convenience\n+  void add_loader(oop p) {\n+    _loaders->push(ClassLoaderData::class_loader_data(p));\n+  }\n+};\n+\n+class LoaderConstraintEntry {                        \/\/ copied into hashtable as value\n+ private:\n+  GrowableArray<LoaderConstraint*>*  _constraints;   \/\/ loader constraints for this class name.\n+\n+ public:\n+  LoaderConstraintEntry() : _constraints(nullptr) {}\n+  LoaderConstraintEntry(const LoaderConstraintEntry&) = delete;\n+  LoaderConstraintEntry& operator=(const LoaderConstraintEntry&) = delete;\n+\n+  void initialize(LoaderConstraint* constraint) {\n+    _constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<LoaderConstraint*>(5, mtClass);\n+    _constraints->push(constraint);\n+  }\n@@ -58,4 +92,37 @@\n-void LoaderConstraintTable::free_entry(LoaderConstraintEntry *entry) {\n-  \/\/ decrement name refcount before freeing\n-  entry->name()->decrement_refcount();\n-  BasicHashtable<mtClass>::free_entry(entry);\n+  ~LoaderConstraintEntry() {\n+    delete _constraints;\n+  }\n+\n+  int num_constraints() const { return _constraints->length(); }\n+  LoaderConstraint* constraint_at(int i) const { return _constraints->at(i); }\n+\n+  void add_constraint(LoaderConstraint* new_constraint) {\n+    _constraints->push(new_constraint);\n+  }\n+\n+  void remove_constraint(LoaderConstraint* constraint) {\n+    _constraints->remove(constraint);\n+    delete constraint;\n+  }\n+};\n+\n+\n+ResourceHashtable<Symbol*, LoaderConstraintEntry, 107, ResourceObj::C_HEAP, mtClass> _loader_constraint_table;\n+\n+void LoaderConstraint::extend_loader_constraint(Symbol* class_name,\n+                                                Handle loader,\n+                                                InstanceKlass* klass) {\n+  add_loader(loader());\n+  LogTarget(Info, class, loader, constraints) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    lt.print(\"extending constraint for name %s by adding loader: %s %s\",\n+               class_name->as_C_string(),\n+               ClassLoaderData::class_loader_data(loader())->loader_name_and_id(),\n+               _klass == NULL ? \" and setting class object\" : \"\");\n+  }\n+  if (_klass == NULL) {\n+    set_klass(klass);\n+  } else {\n+    assert(klass == NULL || _klass == klass, \"constraints corrupted\");\n+  }\n@@ -68,1 +135,1 @@\n-LoaderConstraintEntry** LoaderConstraintTable::find_loader_constraint(\n+LoaderConstraint* LoaderConstraintTable::find_loader_constraint(\n@@ -70,0 +137,1 @@\n+\n@@ -71,3 +139,5 @@\n-  unsigned int hash = compute_hash(name);\n-  int index = hash_to_index(hash);\n-  LoaderConstraintEntry** pp = bucket_addr(index);\n+  LoaderConstraintEntry* entry = _loader_constraint_table.get(name);\n+  if (entry == nullptr) {\n+    return nullptr;\n+  }\n+\n@@ -76,11 +146,8 @@\n-  while (*pp) {\n-    LoaderConstraintEntry* p = *pp;\n-    if (p->hash() == hash) {\n-      if (p->name() == name) {\n-        for (int i = p->num_loaders() - 1; i >= 0; i--) {\n-          if (p->loader_data(i) == loader_data &&\n-              \/\/ skip unloaded klasses\n-              (p->klass() == NULL ||\n-               p->klass()->is_loader_alive())) {\n-            return pp;\n-          }\n+  for (int i = 0; i < entry->num_constraints(); i++) {\n+    LoaderConstraint* p = entry->constraint_at(i);\n+    for (int i = p->num_loaders() - 1; i >= 0; i--) {\n+        if (p->loader_data(i) == loader_data &&\n+            \/\/ skip unloaded klasses\n+            (p->klass() == nullptr ||\n+             p->klass()->is_loader_alive())) {\n+          return p;\n@@ -88,1 +155,0 @@\n-      }\n@@ -90,1 +156,0 @@\n-    pp = p->next_addr();\n@@ -92,1 +157,1 @@\n-  return pp;\n+  return nullptr;\n@@ -95,0 +160,18 @@\n+\/\/ Either add it to an existing entry in the table or make a new one.\n+void LoaderConstraintTable::add_loader_constraint(Symbol* name, InstanceKlass* klass, oop class_loader1, oop class_loader2) {\n+  assert_lock_strong(SystemDictionary_lock);\n+  LoaderConstraint* constraint = new LoaderConstraint(klass, class_loader1, class_loader2);\n+\n+  \/\/ The klass may be null if it hasn't been loaded yet, for instance while checking\n+  \/\/ a parameter name to a method call.  We impose this constraint that the\n+  \/\/ class that is eventually loaded must match between these two loaders.\n+  bool created;\n+  LoaderConstraintEntry* entry = _loader_constraint_table.put_if_absent(name, &created);\n+  if (created) {\n+    \/\/ Increment the key refcount when putting in the table.\n+    name->increment_refcount();\n+    entry->initialize(constraint);\n+  } else {\n+    entry->add_constraint(constraint);\n+  }\n+}\n@@ -96,8 +179,7 @@\n-void LoaderConstraintTable::purge_loader_constraints() {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  LogTarget(Info, class, loader, constraints) lt;\n-  \/\/ Remove unloaded entries from constraint table\n-  for (int index = 0; index < table_size(); index++) {\n-    LoaderConstraintEntry** p = bucket_addr(index);\n-    while(*p) {\n-      LoaderConstraintEntry* probe = *p;\n+class PurgeUnloadedConstraints : public StackObj {\n+ public:\n+  bool do_entry(Symbol*& name, LoaderConstraintEntry& entry) {\n+    LogTarget(Info, class, loader, constraints) lt;\n+    int len = entry.num_constraints();\n+    for (int i = len - 1; i >= 0; i--) {\n+      LoaderConstraint* probe = entry.constraint_at(i);\n@@ -113,1 +195,1 @@\n-                     probe->name()->as_C_string());\n+                     name->as_C_string());\n@@ -120,0 +202,1 @@\n+\n@@ -121,2 +204,1 @@\n-      int n = 0;\n-      while (n < probe->num_loaders()) {\n+      for (int n = probe->num_loaders() - 1; n >= 0; n--) {\n@@ -128,2 +210,1 @@\n-                     probe->name()->as_C_string()\n-                     );\n+                     name->as_C_string());\n@@ -131,6 +212,1 @@\n-\n-          \/\/ Compact array\n-          int num = probe->num_loaders() - 1;\n-          probe->set_num_loaders(num);\n-          probe->set_loader_data(n, probe->loader_data(num));\n-          probe->set_loader_data(num, NULL);\n+          probe->remove_loader_at(n);\n@@ -146,5 +222,1 @@\n-\n-          continue;  \/\/ current element replaced, so restart without\n-                     \/\/ incrementing n\n-          }\n-        n++;\n+        }\n@@ -154,5 +226,5 @@\n-            if (lt.is_enabled()) {\n-              ResourceMark rm;\n-              lt.print(\"purging complete constraint for name %s\",\n-                         probe->name()->as_C_string());\n-            }\n+        if (lt.is_enabled()) {\n+          ResourceMark rm;\n+          lt.print(\"purging complete constraint for name %s\",\n+                   name->as_C_string());\n+        }\n@@ -160,4 +232,1 @@\n-        \/\/ Purge entry\n-        *p = probe->next();\n-        FREE_C_HEAP_ARRAY(oop, probe->loaders());\n-        free_entry(probe);\n+        entry.remove_constraint(probe);\n@@ -170,2 +239,0 @@\n-        \/\/ Go to next entry\n-        p = probe->next_addr();\n@@ -174,0 +241,7 @@\n+    if (entry.num_constraints() == 0) {\n+      \/\/ decrement name refcount before freeing\n+      name->decrement_refcount();\n+      return true;\n+    }\n+    \/\/ Don't unlink this entry\n+    return false;\n@@ -175,0 +249,7 @@\n+};\n+\n+void LoaderConstraintTable::purge_loader_constraints() {\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  \/\/ Remove unloaded entries from constraint table\n+  PurgeUnloadedConstraints purge;\n+  _loader_constraint_table.unlink(&purge);\n@@ -210,2 +291,2 @@\n-  LoaderConstraintEntry** pp1 = find_loader_constraint(class_name, class_loader1);\n-  if (*pp1 != NULL && (*pp1)->klass() != NULL) {\n+  LoaderConstraint* pp1 = find_loader_constraint(class_name, class_loader1);\n+  if (pp1 != NULL && pp1->klass() != NULL) {\n@@ -213,1 +294,1 @@\n-      if (klass != (*pp1)->klass()) {\n+      if (klass != pp1->klass()) {\n@@ -221,1 +302,1 @@\n-      klass = (*pp1)->klass();\n+      klass = pp1->klass();\n@@ -225,2 +306,2 @@\n-  LoaderConstraintEntry** pp2 = find_loader_constraint(class_name, class_loader2);\n-  if (*pp2 != NULL && (*pp2)->klass() != NULL) {\n+  LoaderConstraint* pp2 = find_loader_constraint(class_name, class_loader2);\n+  if (pp2 != NULL && pp2->klass() != NULL) {\n@@ -228,1 +309,1 @@\n-      if (klass != (*pp2)->klass()) {\n+      if (klass != pp2->klass()) {\n@@ -236,1 +317,1 @@\n-      klass = (*pp2)->klass();\n+      klass = pp2->klass();\n@@ -240,9 +321,1 @@\n-  if (*pp1 == NULL && *pp2 == NULL) {\n-    unsigned int hash = compute_hash(class_name);\n-    int index = hash_to_index(hash);\n-    LoaderConstraintEntry* p;\n-    p = new_entry(hash, class_name, klass, 2, 2);\n-    p->set_loaders(NEW_C_HEAP_ARRAY(ClassLoaderData*, 2, mtClass));\n-    p->set_loader(0, class_loader1());\n-    p->set_loader(1, class_loader2());\n-    Hashtable<InstanceKlass*, mtClass>::add_entry(index, p);\n+  if (pp1 == NULL && pp2 == NULL) {\n@@ -250,0 +323,1 @@\n+    add_loader_constraint(class_name, klass, class_loader1(), class_loader2());\n@@ -259,1 +333,1 @@\n-  } else if (*pp1 == *pp2) {\n+  } else if (pp1 == pp2) {\n@@ -261,2 +335,2 @@\n-    if ((*pp1)->klass() == NULL) {\n-      (*pp1)->set_klass(klass);\n+    if (pp1->klass() == NULL) {\n+      pp1->set_klass(klass);\n@@ -272,1 +346,1 @@\n-      assert((*pp1)->klass() == klass, \"loader constraints corrupted\");\n+      assert(pp1->klass() == klass, \"loader constraints corrupted\");\n@@ -274,4 +348,4 @@\n-  } else if (*pp1 == NULL) {\n-    extend_loader_constraint(*pp2, class_loader1, klass);\n-  } else if (*pp2 == NULL) {\n-    extend_loader_constraint(*pp1, class_loader2, klass);\n+  } else if (pp1 == NULL) {\n+    pp2->extend_loader_constraint(class_name, class_loader1, klass);\n+  } else if (pp2 == NULL) {\n+    pp1->extend_loader_constraint(class_name, class_loader2, klass);\n@@ -279,1 +353,1 @@\n-    merge_loader_constraints(pp1, pp2, klass);\n+    merge_loader_constraints(class_name, pp1, pp2, klass);\n@@ -285,1 +359,0 @@\n-\n@@ -292,1 +365,1 @@\n-  LoaderConstraintEntry* p = *(find_loader_constraint(name, loader));\n+  LoaderConstraint* p = find_loader_constraint(name, loader);\n@@ -319,1 +392,1 @@\n-  LoaderConstraintEntry *p = *(find_loader_constraint(name, loader));\n+  LoaderConstraint *p = find_loader_constraint(name, loader);\n@@ -334,16 +407,3 @@\n-void LoaderConstraintTable::ensure_loader_constraint_capacity(\n-                                                     LoaderConstraintEntry *p,\n-                                                    int nfree) {\n-    if (p->max_loaders() - p->num_loaders() < nfree) {\n-        int n = nfree + p->num_loaders();\n-        ClassLoaderData** new_loaders = NEW_C_HEAP_ARRAY(ClassLoaderData*, n, mtClass);\n-        memcpy(new_loaders, p->loaders(), sizeof(ClassLoaderData*) * p->num_loaders());\n-        p->set_max_loaders(n);\n-        FREE_C_HEAP_ARRAY(ClassLoaderData*, p->loaders());\n-        p->set_loaders(new_loaders);\n-    }\n-}\n-\n-\n-void LoaderConstraintTable::extend_loader_constraint(LoaderConstraintEntry* p,\n-                                                     Handle loader,\n+void LoaderConstraintTable::merge_loader_constraints(Symbol* class_name,\n+                                                     LoaderConstraint* p1,\n+                                                     LoaderConstraint* p2,\n@@ -351,20 +411,0 @@\n-  ensure_loader_constraint_capacity(p, 1);\n-  int num = p->num_loaders();\n-  p->set_loader(num, loader());\n-  p->set_num_loaders(num + 1);\n-  LogTarget(Info, class, loader, constraints) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    lt.print(\"extending constraint for name %s by adding loader[%d]: %s %s\",\n-               p->name()->as_C_string(),\n-               num,\n-               ClassLoaderData::class_loader_data(loader())->loader_name_and_id(),\n-               (p->klass() == NULL ? \" and setting class object\" : \"\")\n-               );\n-  }\n-  if (p->klass() == NULL) {\n-    p->set_klass(klass);\n-  } else {\n-    assert(klass == NULL || p->klass() == klass, \"constraints corrupted\");\n-  }\n-}\n@@ -372,0 +412,3 @@\n+  \/\/ Copy into the shorter of the constraints.\n+  LoaderConstraint* dest = p1->num_loaders() <= p2->num_loaders() ? p1 : p2;\n+  LoaderConstraint* src = dest == p1 ? p2 : p1;\n@@ -373,20 +416,3 @@\n-void LoaderConstraintTable::merge_loader_constraints(\n-                                                   LoaderConstraintEntry** pp1,\n-                                                   LoaderConstraintEntry** pp2,\n-                                                   InstanceKlass* klass) {\n-  \/\/ make sure *pp1 has higher capacity\n-  if ((*pp1)->max_loaders() < (*pp2)->max_loaders()) {\n-    LoaderConstraintEntry** tmp = pp2;\n-    pp2 = pp1;\n-    pp1 = tmp;\n-  }\n-\n-  LoaderConstraintEntry* p1 = *pp1;\n-  LoaderConstraintEntry* p2 = *pp2;\n-\n-  ensure_loader_constraint_capacity(p1, p2->num_loaders());\n-\n-  for (int i = 0; i < p2->num_loaders(); i++) {\n-    int num = p1->num_loaders();\n-    p1->set_loader_data(num, p2->loader_data(i));\n-    p1->set_num_loaders(num + 1);\n+  for (int i = 0; i < src->num_loaders(); i++) {\n+    \/\/ do we care about duplicates???\n+    dest->add_loader_data(src->loader_data(i));\n@@ -398,3 +424,1 @@\n-    lt.print(\"merged constraints for name %s, new loader list:\",\n-                  p1->name()->as_C_string()\n-                  );\n+    lt.print(\"merged constraints for name %s, new loader list:\", class_name->as_C_string());\n@@ -402,3 +426,2 @@\n-    for (int i = 0; i < p1->num_loaders(); i++) {\n-      lt.print(\"    [%d]: %s\", i,\n-                    p1->loader_data(i)->loader_name_and_id());\n+    for (int i = 0; i < dest->num_loaders(); i++) {\n+      lt.print(\"    [%d]: %s\", i, dest->loader_data(i)->loader_name_and_id());\n@@ -406,1 +429,1 @@\n-    if (p1->klass() == NULL) {\n+    if (dest->klass() == NULL) {\n@@ -411,2 +434,2 @@\n-  \/\/ p1->klass() will hold NULL if klass, p2->klass(), and old\n-  \/\/ p1->klass() are all NULL.  In addition, all three must have\n+  \/\/ dest->klass() will hold NULL if klass, src->klass(), and old\n+  \/\/ dest->klass() are all NULL.  In addition, all three must have\n@@ -416,2 +439,2 @@\n-  if (p2->klass() != NULL) {\n-    assert(p2->klass() == klass, \"constraints corrupted\");\n+  if (src->klass() != NULL) {\n+    assert(src->klass() == klass, \"constraints corrupted\");\n@@ -419,2 +442,2 @@\n-  if (p1->klass() == NULL) {\n-    p1->set_klass(klass);\n+  if (dest->klass() == NULL) {\n+    dest->set_klass(klass);\n@@ -422,1 +445,1 @@\n-    assert(p1->klass() == klass, \"constraints corrupted\");\n+    assert(dest->klass() == klass, \"constraints corrupted\");\n@@ -425,4 +448,3 @@\n-  *pp2 = p2->next();\n-  FREE_C_HEAP_ARRAY(oop, p2->loaders());\n-  free_entry(p2);\n-  return;\n+  \/\/ Remove src from entry\n+  LoaderConstraintEntry* entry = _loader_constraint_table.get(class_name);\n+  entry->remove_constraint(src);\n@@ -431,1 +453,0 @@\n-\n@@ -433,5 +454,5 @@\n-  Thread *thread = Thread::current();\n-  for (int cindex = 0; cindex < table_size(); cindex++) {\n-    for (LoaderConstraintEntry* probe = bucket(cindex);\n-                                probe != NULL;\n-                                probe = probe->next()) {\n+  auto check = [&] (Symbol*& key, LoaderConstraintEntry& entry) {\n+    \/\/ foreach constraint in entry, check the klass is in the dictionary or placeholder table.\n+    int len = entry.num_constraints();\n+    for (int i = 0; i < len; i++) {\n+      LoaderConstraint* probe = entry.constraint_at(i);\n@@ -440,1 +461,1 @@\n-        guarantee(ik->name() == probe->name(), \"name should match\");\n+        guarantee(ik->name() == key, \"name should match\");\n@@ -465,1 +486,18 @@\n-  }\n+  };\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  _loader_constraint_table.iterate_all(check);\n+}\n+\n+void LoaderConstraintTable::print_table_statistics(outputStream* st) {\n+  auto size = [&] (Symbol*& key, LoaderConstraintEntry& entry) {\n+    \/\/ sizeof entry is included in the size of the hashtable node\n+    int sum = 0;\n+    int len = entry.num_constraints();\n+    for (int i = 0; i < len; i++) {\n+      LoaderConstraint* probe = entry.constraint_at(i);\n+      sum += sizeof(*probe) + (probe->num_loaders() * sizeof(ClassLoaderData*));\n+    }\n+    return sum;\n+  };\n+  TableStatistics ts = _loader_constraint_table.statistics_calculate(size);\n+  ts.print(st, \"LoaderConstraintTable\");\n@@ -469,11 +507,6 @@\n-void LoaderConstraintTable::print_on(outputStream* st) const {\n-  ResourceMark rm;\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  st->print_cr(\"Java loader constraints (table_size=%d, constraints=%d)\",\n-               table_size(), number_of_entries());\n-  for (int cindex = 0; cindex < table_size(); cindex++) {\n-    for (LoaderConstraintEntry* probe = bucket(cindex);\n-                                probe != NULL;\n-                                probe = probe->next()) {\n-      st->print(\"%4d: \", cindex);\n-      st->print(\"Symbol: %s loaders:\", probe->name()->as_C_string());\n+void LoaderConstraintTable::print_on(outputStream* st) {\n+  auto printer = [&] (Symbol*& key, LoaderConstraintEntry& entry) {\n+    int len = entry.num_constraints();\n+    for (int i = 0; i < len; i++) {\n+      LoaderConstraint* probe = entry.constraint_at(i);\n+      st->print(\"Symbol: %s loaders:\", key->as_C_string());\n@@ -487,1 +520,6 @@\n-  }\n+  };\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  ResourceMark rm;\n+  st->print_cr(\"Java loader constraints (table_size=%d, constraints=%d)\",\n+               _loader_constraint_table.table_size(), _loader_constraint_table.number_of_entries());\n+  _loader_constraint_table.iterate_all(printer);\n@@ -490,1 +528,1 @@\n-void LoaderConstraintTable::print() const { print_on(tty); }\n+void LoaderConstraintTable::print() { print_on(tty); }\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":236,"deletions":198,"binary":false,"changes":434,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-#include \"classfile\/placeholders.hpp\"\n-#include \"utilities\/hashtable.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/handles.hpp\"\n@@ -32,0 +32,1 @@\n+class LoaderConstraint;\n@@ -33,0 +34,1 @@\n+class PlaceholderTable;\n@@ -35,1 +37,1 @@\n-class LoaderConstraintTable : public Hashtable<InstanceKlass*, mtClass> {\n+class LoaderConstraintTable : public AllStatic {\n@@ -38,2 +40,1 @@\n-  LoaderConstraintEntry** find_loader_constraint(Symbol* name,\n-                                                 Handle loader);\n+  static LoaderConstraint* find_loader_constraint(Symbol* name, Handle loader);\n@@ -41,8 +42,1 @@\n-public:\n-\n-  LoaderConstraintTable(int table_size);\n-\n-  LoaderConstraintEntry* new_entry(unsigned int hash, Symbol* name,\n-                                   InstanceKlass* klass, int num_loaders,\n-                                   int max_loaders);\n-  void free_entry(LoaderConstraintEntry *entry);\n+  static void add_loader_constraint(Symbol* name, InstanceKlass* klass, oop class_loader1, oop class_loader2);\n@@ -50,7 +44,3 @@\n-  LoaderConstraintEntry* bucket(int i) const {\n-    return (LoaderConstraintEntry*)Hashtable<InstanceKlass*, mtClass>::bucket(i);\n-  }\n-\n-  LoaderConstraintEntry** bucket_addr(int i) {\n-    return (LoaderConstraintEntry**)Hashtable<InstanceKlass*, mtClass>::bucket_addr(i);\n-  }\n+  static void merge_loader_constraints(Symbol* class_name, LoaderConstraint* pp1,\n+                                       LoaderConstraint* pp2, InstanceKlass* klass);\n+public:\n@@ -59,2 +49,2 @@\n-  bool add_entry(Symbol* name, InstanceKlass* klass1, Handle loader1,\n-                                    InstanceKlass* klass2, Handle loader2);\n+  static bool add_entry(Symbol* name, InstanceKlass* klass1, Handle loader1,\n+                        InstanceKlass* klass2, Handle loader2);\n@@ -68,1 +58,1 @@\n-  InstanceKlass* find_constrained_klass(Symbol* name, Handle loader);\n+  static InstanceKlass* find_constrained_klass(Symbol* name, Handle loader);\n@@ -71,0 +61,1 @@\n+  static bool check_or_update(InstanceKlass* k, Handle loader, Symbol* name);\n@@ -72,56 +63,1 @@\n-  void ensure_loader_constraint_capacity(LoaderConstraintEntry *p, int nfree);\n-  void extend_loader_constraint(LoaderConstraintEntry* p, Handle loader,\n-                                InstanceKlass* klass);\n-  void merge_loader_constraints(LoaderConstraintEntry** pp1,\n-                                LoaderConstraintEntry** pp2, InstanceKlass* klass);\n-\n-  bool check_or_update(InstanceKlass* k, Handle loader, Symbol* name);\n-\n-  void purge_loader_constraints();\n-\n-  void verify();\n-  void print() const;\n-  void print_on(outputStream* st) const;\n-};\n-\n-class LoaderConstraintEntry : public HashtableEntry<InstanceKlass*, mtClass> {\n-private:\n-  Symbol*                _name;                   \/\/ class name\n-  int                    _num_loaders;\n-  int                    _max_loaders;\n-  \/\/ Loader constraints enforce correct linking behavior.\n-  \/\/ Thus, it really operates on ClassLoaderData which represents linking domain,\n-  \/\/ not class loaders.\n-  ClassLoaderData**              _loaders;                \/\/ initiating loaders\n-\n-public:\n-\n-  InstanceKlass* klass() { return literal(); }\n-  InstanceKlass** klass_addr() { return literal_addr(); }\n-  void set_klass(InstanceKlass* k) { set_literal(k); }\n-\n-  LoaderConstraintEntry* next() {\n-    return (LoaderConstraintEntry*)HashtableEntry<InstanceKlass*, mtClass>::next();\n-  }\n-\n-  LoaderConstraintEntry** next_addr() {\n-    return (LoaderConstraintEntry**)HashtableEntry<InstanceKlass*, mtClass>::next_addr();\n-  }\n-  void set_next(LoaderConstraintEntry* next) {\n-    HashtableEntry<InstanceKlass*, mtClass>::set_next(next);\n-  }\n-\n-  Symbol* name() { return _name; }\n-  void set_name(Symbol* name) {\n-    _name = name;\n-    if (name != NULL) name->increment_refcount();\n-  }\n-\n-  int num_loaders() { return _num_loaders; }\n-  void set_num_loaders(int i) { _num_loaders = i; }\n-\n-  int max_loaders() { return _max_loaders; }\n-  void set_max_loaders(int i) { _max_loaders = i; }\n-\n-  ClassLoaderData** loaders() { return _loaders; }\n-  void set_loaders(ClassLoaderData** loaders) { _loaders = loaders; }\n+  static void purge_loader_constraints();\n@@ -129,4 +65,4 @@\n-  ClassLoaderData* loader_data(int i) { return _loaders[i]; }\n-  void set_loader_data(int i, ClassLoaderData* p) { _loaders[i] = p; }\n-  \/\/ convenience\n-  void set_loader(int i, oop p);\n+  static void print_table_statistics(outputStream* st);\n+  static void verify();\n+  static void print();\n+  static void print_on(outputStream* st);\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.hpp","additions":19,"deletions":83,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -129,5 +129,0 @@\n-\/\/ Constraints on class loaders\n-const int _loader_constraint_size = 107;                     \/\/ number of entries in constraint table\n-static LoaderConstraintTable*  _loader_constraints;\n-static LoaderConstraintTable* constraints() { return _loader_constraints; }\n-\n@@ -1665,1 +1660,1 @@\n-      constraints()->purge_loader_constraints();\n+      LoaderConstraintTable::purge_loader_constraints();\n@@ -1717,1 +1712,0 @@\n-  _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);\n@@ -1772,1 +1766,1 @@\n-      if (constraints()->check_or_update(k, class_loader, name) == false) {\n+      if (LoaderConstraintTable::check_or_update(k, class_loader, name) == false) {\n@@ -1777,1 +1771,1 @@\n-        Klass *existing_klass = constraints()->find_constrained_klass(name, class_loader);\n+        Klass *existing_klass = LoaderConstraintTable::find_constrained_klass(name, class_loader);\n@@ -1848,1 +1842,1 @@\n-      klass = constraints()->find_constrained_klass(ss.as_symbol(), class_loader);\n+      klass = LoaderConstraintTable::find_constrained_klass(ss.as_symbol(), class_loader);\n@@ -1857,1 +1851,1 @@\n-    klass = constraints()->find_constrained_klass(class_name, class_loader);\n+    klass = LoaderConstraintTable::find_constrained_klass(class_name, class_loader);\n@@ -1899,1 +1893,1 @@\n-    bool result = constraints()->add_entry(constraint_name, klass1, class_loader1,\n+    bool result = LoaderConstraintTable::add_entry(constraint_name, klass1, class_loader1,\n@@ -2485,1 +2479,1 @@\n-  constraints()->print_on(st);\n+  LoaderConstraintTable::print_on(st);\n@@ -2495,2 +2489,0 @@\n-  guarantee(constraints() != NULL,\n-            \"Verify of loader constraints failed\");\n@@ -2504,2 +2496,1 @@\n-  guarantee(constraints() != NULL, \"Verify of loader constraints failed\");\n-  constraints()->verify();\n+  LoaderConstraintTable::verify();\n@@ -2517,1 +2508,1 @@\n-    constraints()->print_table_statistics(st, \"LoaderConstraints Table\");\n+    LoaderConstraintTable::print_table_statistics(st);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+            \"-Xlog:class+loader+constraints\",\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/loadLibraryTest\/LoadLibraryTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}