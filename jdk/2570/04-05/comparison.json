{"files":[{"patch":"@@ -39,1 +39,0 @@\n-\n@@ -555,1 +554,1 @@\n-Node* ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node *ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1324,0 +1324,12 @@\n+\/\/ the helper function to work out the offset based on ac. src_adr is cached.\n+Node* PhaseMacroExpand::get_offset_adr_from_ac(ArrayCopyNode* ac, Node*& src_adr, Node* offset) {\n+  if (src_adr == nullptr) {\n+    Node* src = ac->in(ArrayCopyNode::Src);\n+    src_adr = ConvI2X(ac->in(ArrayCopyNode::SrcPos));\n+    src_adr = basic_plus_adr(src, src, src_adr);\n+  }\n+\n+  return (offset == nullptr) ? src_adr\n+                             : basic_plus_adr(src_adr->in(AddPNode::Base), src_adr, offset);\n+}\n+\n@@ -1363,13 +1375,0 @@\n-          } else if (n->Opcode() == Op_StrEquals) {\n-            assert(offset_const == arrayOopDesc::base_offset_in_bytes(T_BYTE), \"offset equals to the base_offset\");\n-            if (src_adr == nullptr) {\n-              src_adr = ConvI2X(ac->in(ArrayCopyNode::SrcPos));\n-              src_adr = basic_plus_adr(src->in(1), src, src_adr);\n-            }\n-            Node* dst_adr = basic_plus_adr(src_adr->in(1), src_adr, offset);\n-            if (n->in(2) == use) { \/\/ str1\n-              _igvn.replace_input_of(n, 2, dst_adr);\n-            }\n-            if (n->in(3) == use) { \/\/ str2\n-              _igvn.replace_input_of(n, 3, dst_adr);\n-            }\n@@ -1378,8 +1377,2 @@\n-          } else {\n-            assert(n->Opcode() == Op_LoadUB || n->Opcode() == Op_LoadB, \"unknow code shape\");\n-\n-            if (src_adr == nullptr) {\n-              src_adr = ConvI2X(ac->in(ArrayCopyNode::SrcPos));\n-              src_adr = basic_plus_adr(src, src, src_adr);\n-            }\n-            Node* dst_adr = basic_plus_adr(src_adr->in(AddPNode::Base), src_adr, offset);\n+          } else if (n->Opcode() == Op_LoadUB || n->Opcode() == Op_LoadB) {\n+            Node* dst_adr = get_offset_adr_from_ac(ac, src_adr, offset);\n@@ -1389,0 +1382,16 @@\n+          } else {\n+#ifndef PRODUCT\n+            if (offset_const != arrayOopDesc::base_offset_in_bytes(T_BYTE)) {\n+              tty->print_cr(\"something wrong here in process_users_of_string_allocation!\");\n+              n->dump(1);\n+            }\n+#endif\n+            assert(offset_const == arrayOopDesc::base_offset_in_bytes(T_BYTE),\n+                   \"unknow code shape. must use AddP with the fixec offset\");\n+            \/\/ n should be a subclass of StrIntrinsicNode, eg. Op_StrEquals\n+            Node* dst_adr = get_offset_adr_from_ac(ac, src_adr, offset);\n+            for (uint k = 0; k < n->req(); ++k) {\n+              if (n->in(k) == use) {\n+                _igvn.replace_input_of(n, k, dst_adr);\n+              }\n+            }\n@@ -1399,4 +1408,0 @@\n-          if (src_adr == nullptr) {\n-            src_adr = ConvI2X(ac->in(ArrayCopyNode::SrcPos));\n-            src_adr = basic_plus_adr(src, src, src_adr);\n-          }\n@@ -1404,1 +1409,1 @@\n-          _igvn.replace_input_of(use, AddPNode::Address, src_adr);\n+          _igvn.replace_input_of(use, AddPNode::Address, get_offset_adr_from_ac(ac, src_adr));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":31,"deletions":26,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+  Node* get_offset_adr_from_ac(ArrayCopyNode* ac, Node*& src_adr, Node* offset = nullptr);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary verify that -XX:+OptimizeTempArray removes String.substring()\n+ * @summary verify that -XX:+OptimizeTempArray removes AllocateArray\n@@ -100,0 +100,1 @@\n+                    \"-XX:MaxInlineSize=200\", \/\/ force to inline j.l.String::substring and ava.util.Arrays::copyOfRange\n@@ -121,0 +122,1 @@\n+                    \"-XX:MaxInlineSize=200\", \/\/ force to inline j.l.String::substring and ava.util.Arrays::copyOfRange\n@@ -136,0 +138,1 @@\n+                    \"-XX:MaxInlineSize=200\", \/\/ force to inline j.l.String::substring and ava.util.Arrays::copyOfRange\n@@ -145,1 +148,5 @@\n-        oa.shouldContain(\"ScObj0 java\/lang\/String={ [hash :0]=#0, [coder :1]=#0, [hashIsZero :2]=#0, [value :3]=#ScObj1 }\");\n+        \/\/ -Xcomp may generate uncommon traps because of 'unloaded'. only check scObj0 if the test has\n+        \/\/ really restored j.l.String in deoptimization.\n+        if (oa.firstMatch(\"^reassign fields for object of type java\/lang\/String\") != null) {\n+            oa.shouldContain(\"ScObj0 java\/lang\/String={ [hash :0]=#0, [coder :1]=#0, [hashIsZero :2]=#0, [value :3]=#ScObj1 }\");\n+        }\n@@ -148,1 +155,0 @@\n-\n@@ -150,1 +156,1 @@\n-        String x = s.substring(1);\n+        String x = s.substring(1, 4);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestOptimizeSubstring.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}