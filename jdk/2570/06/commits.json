[{"commit":{"message":"Merge branch 'master' into optimize_substring"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp"},{"filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp"},{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/callnode.hpp"},{"filename":"src\/hotspot\/share\/opto\/compile.cpp"},{"filename":"src\/hotspot\/share\/opto\/compile.hpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp"}],"sha":"800ddc9dec4e3bc71f45bd0e4d650ed57d4fd199"},{"commit":{"message":"eliminate AllocateArray node early.\n\nThis patch eliminates AllocateArray in process_users_of_string_allocation(),\nso can_eliminate_allocation() and scalar_replacement() don't need any code change.\n\nBecause OptimizeTempArray assumes that the string object must be scalar replaced,\nwe don't need to generate ObjectValue for AllocateArray. all safepoints must be\nintercepted at string object's scalar_replacement."},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.hpp"}],"sha":"fcccdee5c91697ef92f84c3d0f327a84e974264e"},{"commit":{"message":"Handle more StrIntrinsic nodes which use AllocateArray of String.\n\nThere are a few subclasses of StrIntrinsicNode. They may be users of\nj.l.String::value, eg StrEqualsNode and StrCompNode etc. This patch\ntreats them as general nodes.\n\nThis patch fixes TestOptimizeSubstring.java failure with -Xcomp.\nThe test methods were not properly inlined or pruned in presence of -Xcomp.\nThis patch provides more fine-grained control to make sure those methods are compiled more reliablely."},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.hpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestOptimizeSubstring.java"}],"sha":"94626e87cea669a94f02ed6737a5845d0a2a59a9"},{"commit":{"message":"[SIM-JVM-526] fix a crash in scalar replacement\n\nEven though field_val is the value field of j.l.String, the code shape has be changed\nby StringOpt for the more efficient string concatenantion. The array is generated from\njdk.internal.misc.Unsafe::allocateUninitializedArray instead of AllocateArray node.\n\nThis patch checks stricter before genenerating the special SafePointScalarObjectNode node.\n\nThis bug is triggered in the following 2 tests with '-ea -esa -XX:CompileThreshold=100':\ncompiler\/codecache\/stress\/RandomAllocationTest.java\ncompiler\/codecache\/stress\/UnexpectedDeoptimizationTest.java"},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"6bd99e8a0a39613667bc9e945e0d8bd55ac4c4c1"},{"commit":{"message":"fix a typo introduced in prior change.\n\nThis fixes the crashing case reported on github's PR."},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"672bf3c1c650211582dc605bb20ad4c9f0ca5479"},{"commit":{"message":"[SIM-JVM-522] improve second AddP nodes and ArrayCopy node.\n\nIt is possible that an AddP node which only has second AddP Nodes as uses.\nIn this case, we cannot eliminate its uses. replace its base and address\nwith the source of ac.\n\nIt is possible that there is a ArrayCopy but res is not its source.\ntreat it as a CallStaticJavaNode."},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"ea660ee6b500f650c515bed47443f0be68112788"},{"commit":{"message":"[SIM-JVM-509] Check the source of ArrayCopy is from java.lang.String::value.\n\nbefore we figure out how to determine the byte array is stable, we only accept j.l.String::value\nfor the time being because the field is annotated stable."},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"9218d43b1a4c82a198e33634ab3f496469bf5f9d"},{"commit":{"message":"Merge branch 'master' into optimize_substring"},"files":[{"filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp"},{"filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp"}],"sha":"9bf0b26bf6d4fa0269c780d5f626677db026a385"},{"commit":{"message":"Merge branch 'master' into optimize_substring"},"files":[],"sha":"359cdc97a71a0ef1dd05eea62b29a59ef3c8d569"},{"commit":{"message":"Merge branch 'master' into optimize_substring"},"files":[{"filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp"}],"sha":"21693dddded6d85bde9ecfb2e980f6f60fbd1f24"},{"commit":{"message":"fix regression for x86-32\n\nif LP64 is off, the offset of AddP must be I instead of L.\nx86 also doesn't emit encodeP\/storeN. it use storeP instead."},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestOptimizeSubstring.java"}],"sha":"fd9ca4b830afc8e9ea571a43cd54fc5a490eb295"},{"commit":{"message":"add a statistical counter for OptimizeTempArray.\n\n-XX:+PrintOptoStatistics shows it"},"files":[{"filename":"src\/hotspot\/share\/opto\/compile.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.hpp"}],"sha":"804a3e38398511e9d8986c912f180845d9693258"},{"commit":{"message":"[SIM-JVM-450] support deoptimization v2\n\nbecause the src oop of scobj may be another scobj, deoptimization sort\nall objects in topological order.\n\nseparate creation of dst oop and reassignment of it."},"files":[{"filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp"},{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp"},{"filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp"}],"sha":"ab6c912102c0510a5fa8b5471190a2b269277d94"},{"commit":{"message":"add a unit test for deoptimization"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestOptimizeSubstring.java"}],"sha":"4541a5cc7dd2c7cf59591aa277037314ac9dbd17"},{"commit":{"message":"[SIM-JVM-450] support deoptimization part2\n\nif OptimizeTempArray eliminates an AllocateArrayNode, scalar replacement will\ncreate a nested SafePointScalarObjectNode for the field value:byte[] of j.l.String.\nwe use the nested sobj and an ObjectValue an envelope. it consists of 3 fields:\n1. src 2. src_positio 3. length.\n\ndeoptimizaton recognizes this ad-hoc ObjectValue and re-allocate an arrayOop\nfor the String object."},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp"}],"sha":"b5d1bb3771d98f6829989bd8c6f5d906ae9a45c2"},{"commit":{"message":"enable OptimizeTempArray by default"},"files":[{"filename":"src\/hotspot\/share\/opto\/c2_globals.hpp"}],"sha":"d75f0ae67e7489d9a4af968f0cdf06c4f0b664d3"},{"commit":{"message":"Merge branch 'master' into optimize_substring"},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/c2_globals.hpp"},{"filename":"src\/hotspot\/share\/opto\/callnode.hpp"},{"filename":"src\/hotspot\/share\/opto\/compile.hpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"7ae0c281dfa5099910c29e20f64d3c21f0869572"},{"commit":{"message":"Revert \"8260198: TypeInstPtr::dump2() emits multiple lines if Verbose is set\"\n\nThis reverts commit a49e34688d7d7c9d3c0d9c824d33f359613c2fc1."},"files":[],"sha":"91abf69bd3c825df1461158263c1c8d1e9cf69ab"},{"commit":{"message":"Revert \"add a new bucket afterea_late_inlines\"\n\nafterea_late_inlines bucket is not useful. revert it and its relevant changes"},"files":[{"filename":"src\/hotspot\/share\/opto\/c2_globals.hpp"},{"filename":"src\/hotspot\/share\/opto\/callnode.hpp"},{"filename":"src\/hotspot\/share\/opto\/compile.hpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"5644424ab15edde7d02ab03d15750b4080caa88c"},{"commit":{"message":"[SIM-JVM-450] support deoptimization"},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"7ccdb57a2ed57cea25ca6d92379bb22df69f6a09"},{"commit":{"message":"[SIM-487] Check all store and phi nodes of encodeP\n\nThis make sure we only eliminate AllocateArray that we can handle."},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.hpp"}],"sha":"49fd46bed9a34577188cc8bc20acb9235ecc7a16"},{"commit":{"message":"handle the second AddP of user of AllocateArray\n\nthe 2nd Addp is an AddP Node which shares the same base with other AddPs.\nOnly update its Base to new source node because the Address Node will\nbe handled anyway."},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"0db7952d457888ae8a9efdd569db06664df511f6"},{"commit":{"message":"[SIM-JVM-482]  handle code shape of cascading arraycopy\n\nit is possible that a few AllocateArray\/Arraycopy nodes cascade. we\nneed to find the AllocateNode which is the instance of AllocateArray.\nOnly eliminate the last one AllocateArray\/ArrayCopy.\n\nwe make use instance id of TypeOopPtr. if AllocateNode is scalar\nreplaceable, EA marks it a unique iid."},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"b90b7e9fa273863d1a930883b9a1b7bb387c741f"},{"commit":{"message":"support Op_StrEquals as an use of AllocateArray"},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"366eb93fb366ad9721b86a23f0e6af97c922bc56"},{"commit":{"message":"keep LoadB and LoadUB. update their inputs\n\nProhibit from applying this optimization if the object itself isn't\nscalar replaceble.\n\nbecause the oop isnot created if we optimize out the AllocateArray, I\njust assign a null for the field value:byte[]. need to handle it batter.\nthat's need to decouple Allocate and AllocateArray."},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"9a39f5bd3e7b9b2abd5763bfc1e45f0590a5cd4a"},{"commit":{"message":"[SIM-JVM-450]: handle deoptimization non-escaped frozen array"},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.hpp"}],"sha":"e53d540b701a4b077b05927e4060258addfe192a"},{"commit":{"message":"[SIM-JVM-479] handle G1's post-write barrier when eliminating both Allocate and AllocateArray\n\nFor java.lang.String, G1GC needs to generates a post-write barrier for the field value: byte[].\nI observe 2 allocation nodes.\n1. Allocate Node for the j.l.String\n2. AllocateArrayNode for value:byte[]\n\nWhen OptimizeTempArray is on, C2 may eliminate both 2 nodes. ie. PhseMacroExpand may invoke\n\"eliminate_allocate_node\" for 2 nodes respectively.\n\nThe post-write barrier generated by G1GC refers the results of allocate nodes.\nCurrently, it doesn't support to invoke `G1BarrierSetC2::eliminate_gc_barrier` for 2 nodes respectively.\n\nplease note that I sort all macro nodes. As a result, I guarantee that Allocate Elimination always comes\nafter AllocationArrayNode. When AllocateNode invokes `PhaseMacroExpand::eliminate_allocate_node`,\nit still sees CastP2X.\n\nThis patch takes away the sibling CastP2X to prevent the 2nd eliminate_gc_barrier."},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp"}],"sha":"17bae1c6e9a1e5455ad47b7681de50278e1eb355"},{"commit":{"message":"can_eliminate_allocation is true for the obsolete AllocateArray"},"files":[{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.hpp"}],"sha":"f07ab454e27192b89e478ccbd02bb215ba8795f8"},{"commit":{"message":"move the logic from ArrayCopyNode::ideal to PhaseMacroExpansion\n\ntimelines:\n1. EA\n2. IGVN\n3. ME: eliminate_strcpy_node\n4. ME: eliminate_allocate_node"},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp"},{"filename":"src\/hotspot\/share\/opto\/compile.hpp"},{"filename":"src\/hotspot\/share\/opto\/escape.hpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"},{"filename":"src\/hotspot\/share\/opto\/macro.hpp"}],"sha":"2496dff28cacc1c535397d42845cdd198a33fe3d"},{"commit":{"message":"handle uses of AllocateArrayNode\n\nreformat the diagram of transformation"},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp"}],"sha":"4fe3e3bcfb52e6a59526f5e151650b5c9f513ae2"},{"commit":{"message":"Accept more code shapes\n\nSrc could be a CheckCastPP.\nuses of projmem of ArrayCopy could have duplicates nodes. this should only happen for MergeMem\nit's also possible that use is a ReturnNode."},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"}],"sha":"fd22818dcda7e404d397aed31ec0fd18fe5882e1"},{"commit":{"message":"accept src of ArrayCopy is ConP.\n\nIt will allow code such as s = \"hello\".substring(1) to trigger TempArray opto.\n\nTODO: I actually haven't finished it. I am hesitating to rewire the pointer to the constant string\nI am not sure where the pointer points to and what's the lifecycle of pointee."},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp"}],"sha":"6d224d1b42f248eb8ce18560c2aad5340deff423"},{"commit":{"message":"add an unittest and  a micro benchmark"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestOptimizeSubstring.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/SubstringStartsWith.java"}],"sha":"dea551f85d32778af688d373a6b6e4aaf414f072"},{"commit":{"message":"add all ArrayCopy nodes to the worklist in EA.\n\nwe rely on igvn after EA to identify Temporary Array pattern."},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"}],"sha":"7af8cfc213ca52ba025e165c3b9ed37a497e6a0a"},{"commit":{"message":"delete ArrayCopy in its own ideal(). It happens earlier than eliminate_allocate_node"},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"}],"sha":"adcfc7d5223690995ccb193e75de679ce83e7c50"},{"commit":{"message":"add a flag to control this optimization."},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/c2_globals.hpp"}],"sha":"9dfea7a0010667f50474c655faafe866ab0fe6fa"},{"commit":{"message":"broken"},"files":[],"sha":"caee9711db65ba52eaee410228d8dd45b88fbb12"},{"commit":{"message":"fix random crash because of is_Mem() assertion\n\ncp.fallthrough_memproj may have an use of PhiNode or SafePointNode."},"files":[],"sha":"7ac53151434969c75f800e5cac7ba2c0e6ced663"},{"commit":{"message":"disable OptimizeSubstring by defualt"},"files":[{"filename":"src\/hotspot\/share\/opto\/c2_globals.hpp"}],"sha":"67f4ad1fecf2f9882b284455b8bee3babb36992e"},{"commit":{"message":"SIM-JVM-449: debug sun.nio.fs.UnixFileSystemProvider::isHidden\n\ncp.fallthrough_memproj may have more than one use. they must be either\nMemNode(Load\/Store) or MergeMemNode."},"files":[],"sha":"10226bf4b9d1f06fe925651153d67c715b4961fd"},{"commit":{"message":"8260198: TypeInstPtr::dump2() emits multiple lines if Verbose is set\n\nAdd a flag _suppress_cr to outputStream. outstream objects won't emit any CR if it's set.\nCorrect TypeInstPtr::dump2 to make sure it only emits klass name once.\nRemove the comment because Klass::oop_print_on() has emitted the address of oop.\n\nBefore:\n689  ConP  ===  0  [[ 821 ]]   Oop:java\/lang\/Stringjava.lang.String\n{0x000000010159d7c8} - klass: public final synchronized 'java\/lang\/String'\n - string: \"a\"\n :Constant:exact *\n\nAfter:\n689  ConP  ===  0  [[ 821 ]]   Oop:java.lang.String {0x000000010159d7c8} - klass: public final synchronized 'java\/lang\/String' - string: \"a\":Constant:exact *"},"files":[],"sha":"a49e34688d7d7c9d3c0d9c824d33f359613c2fc1"},{"commit":{"message":"tmp"},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/callnode.hpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"784619fe51c03818ce25d551b1dd0dd74ef8bdd8"},{"commit":{"message":"identify the pattern of temporary String in ArrayCopy.\n\nwe need to check 3 nodes to draw the conclusion, we check them bottom-up.\n1. Allocate node for the object of j.l.String.\n2. AllocateArray node for the byte buffer of 1\n3. ArrayCopy node for 1 and 2\n\nArrayCopy type must be [B and it's tightly coupled with AllocateArray.\nif AllocateArray escapes, we check its Allocate Object see if its type is KlassPtr\nand klass is j.l.String.\n\nwe determine it is the temporary String pattern if the escapement of the associated\nJavaObject(either 1 or 2) is NoEscape."},"files":[{"filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp"},{"filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp"},{"filename":"src\/hotspot\/share\/opto\/escape.hpp"}],"sha":"80496b0583dca24dc17b9955b0a02888d7dba1aa"},{"commit":{"message":"Allows EA to calculate escapeness information for String.substring\n\nThis patch also dumps CallStaticJava. OptimizeSubstring is introduced to\ncontrol if String.substring is late inlined or not."},"files":[{"filename":"src\/hotspot\/share\/opto\/c2_globals.hpp"},{"filename":"src\/hotspot\/share\/opto\/compile.hpp"}],"sha":"c4112da388552f6dda73f95727cd86e932d85165"},{"commit":{"message":"add a new bucket afterea_late_inlines\n\nIt's a set of methods which participate escape analysis computation.\nThe results will be written to LateInlineAfterEACallGenerator. the methods\ninline lately after EA but before MacroElimination\n\nCurrently, only java.lang.String.substring(int,int) belongs to afterea_late_inlines"},"files":[{"filename":"src\/hotspot\/share\/opto\/callnode.hpp"},{"filename":"src\/hotspot\/share\/opto\/compile.hpp"},{"filename":"src\/hotspot\/share\/opto\/macro.cpp"}],"sha":"8e69016bbb0b1a34373036dff51e029956008439"}]