{"files":[{"patch":"@@ -695,0 +695,4 @@\n+    Node* sibling = xorx->in(1);\n+    if (sibling == node) {\n+      sibling = xorx->in(2);\n+    }\n@@ -725,0 +729,6 @@\n+\n+    \/\/ handle XorL's the other input\n+    \/\/ it may invoke eliminate_gc_barrier() if it's a CastP2X too\n+    if (sibling->Opcode() == Op_CastP2X) {\n+       macro->replace_node(sibling, macro->top());\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1264,1 +1264,1 @@\n-              Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);\n+              Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false, CHECK_NULL);\n@@ -1524,1 +1524,1 @@\n-  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);\n+  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false, CHECK);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -31,0 +32,2 @@\n+#include \"opto\/castnode.hpp\"\n+#include \"opto\/convertnode.hpp\"\n@@ -36,0 +39,1 @@\n+\n@@ -500,0 +504,41 @@\n+\/\/ return true if the current ArrayCopy copy from byte[] to byte[] and the source is j.l.String::value.\n+bool ArrayCopyNode::is_string_copy(PhaseGVN* phase) const {\n+  if (_kind == ArrayCopy && _alloc_tightly_coupled && _arguments_validated) {\n+      const TypeAryPtr* src_type = nullptr;\n+      const TypeAryPtr* dst_type = nullptr;\n+      const Node* n;\n+\n+      n = in(ArrayCopyNode::Src);\n+      if (n->Opcode() == Op_ConP) {\n+        src_type = n->as_Type()->type()->isa_aryptr();\n+      } else if (n->isa_ConstraintCast()) {\n+        \/\/ if n is CastPP or CheckCastPP, check the instance field of load node.\n+        \/\/ j.l.String::value must be loaded using getfield.\n+        \/\/\n+        \/\/ Expecting DU-chains:\n+        \/\/ -UseCompressedOops: CastPP -> LoadP   -> AddP\n+        \/\/ +UseCompressedOops: CastPP -> DecodeN -> LoadN -> AddP\n+        \/\/                                  ^p\n+        Node* p = n->in(1);\n+\n+        if (p->is_DecodeN()) {\n+          p = p->in(1);\n+        }\n+\n+        if (p->is_Load()) { \/\/ LoadN or LoadP\n+          p = p->in(2);     \/\/ adr\n+          const TypePtr* tp = phase->type(p)->isa_ptr();\n+\n+          assert(tp != nullptr, \"TypePtr* tp is NULL!\");\n+          const TypeOopPtr* tinst = tp->isa_instptr();\n+          if (tinst != nullptr && tinst->klass() == CURRENT_ENV->String_klass() &&\n+              tinst->offset() == java_lang_String::value_offset()) {\n+            src_type = n->as_Type()->type()->isa_aryptr();\n+          }\n+        }\n+      }\n+\n+      n = in(ArrayCopyNode::Dest);\n+      if (n->is_ConstraintCast()) {\n+        dst_type = n->as_ConstraintCast()->type()->isa_aryptr();\n+      }\n@@ -501,0 +546,8 @@\n+      if (src_type != nullptr && src_type->elem() == TypeInt::BYTE &&\n+          dst_type != nullptr && dst_type->elem() == TypeInt::BYTE) {\n+        return true;\n+      }\n+  }\n+\n+  return false;\n+}\n@@ -502,1 +555,1 @@\n-Node *ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+  bool is_string_copy(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -562,0 +562,3 @@\n+  product(bool, OptimizeTempArray, true,                                    \\\n+          \"Optimize temporary Array if it's not escaped\")                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1002,0 +1002,3 @@\n+  \/\/ this is java.lang.String::byte[] value and it's has been obsolete\n+  \/\/ MacroExpansion eliminate this node in expand_macro_nodes()\n+  bool _str_alloc_obsolete;\n@@ -1008,1 +1011,1 @@\n-                   initial_test)\n+                   initial_test), _str_alloc_obsolete(false)\n@@ -1024,1 +1027,2 @@\n-\n+  bool is_str_alloc_obsolete() const { return _str_alloc_obsolete; }\n+  void set_str_alloc_obsolete(bool obsolete) { _str_alloc_obsolete = obsolete; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+    PhaseMacroExpand::print_statistics();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -665,0 +665,1 @@\n+  void          macro_node_swap(int a, int b)   { ::swap(_macro_nodes.at(a), _macro_nodes.at(b)); }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -322,0 +322,1 @@\n+  friend class PhaseMacroExpand;\n@@ -351,0 +352,2 @@\n+    if (idx >= _nodes.length()) return nullptr;\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"opto\/escape.hpp\"\n@@ -597,1 +599,1 @@\n-bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints) {\n+bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, bool str_alloc, GrowableArray <SafePointNode *>& safepoints) {\n@@ -618,1 +620,1 @@\n-      if (length < 0) {\n+      if (length < 0 && !str_alloc) {\n@@ -719,0 +721,1 @@\n+  assert(!str_alloc || can_eliminate, \"OptimizeTempArray must succeed in elimination\");\n@@ -723,0 +726,78 @@\n+\/\/ find AllocateNode of j.l.String from AllocateArrayNode's result_cast()\n+static AllocateNode* find_string_alloc_from_res(PhaseGVN& gvn, Node* dst) {\n+  AllocateNode* found = nullptr;\n+\n+  if (dst != nullptr && dst->has_out_with(Op_EncodeP)) {\n+    dst = dst->find_out_with(Op_EncodeP);\n+  }\n+\n+  if (dst != nullptr) {\n+    \/\/ check all Store & Phi nodes\n+    for (DUIterator_Fast imax, i = dst->fast_outs(imax); i < imax; i++) {\n+      Node* use = dst->fast_out(i);\n+\n+      if (use->is_Store()) {\n+        StoreNode* st = use->as_Store();\n+        const TypePtr* adr_type = st->adr_type();\n+        const TypeOopPtr* t_oop = nullptr;\n+\n+        if (adr_type != nullptr) {\n+          t_oop = adr_type->isa_oopptr();\n+        }\n+\n+        if (t_oop != nullptr && t_oop->is_known_instance_field()) {\n+          Node* res = st->in(2)->as_AddP()->base_node();\n+\n+          if (res != nullptr && res->is_CheckCastPP()) {\n+            \/\/ CheckCastPP <- Proj <- Allocate\n+            res = res->as_CheckCastPP()->in(1)->in(0);\n+\n+            if (res->_idx == static_cast<node_idx_t>(t_oop->instance_id())) {\n+              if (found != nullptr && found != res) {\n+                \/\/ store this narrowoop to more than one place, bail out\n+                return nullptr;\n+              }\n+\n+              AllocateNode* alloc = res->as_Allocate();\n+              const TypeKlassPtr* klass = gvn.type(alloc->in(AllocateNode::KlassNode))->isa_klassptr();\n+              \/\/ after we discover an AllocateNode, verify it is j.l.String\n+              \/\/ and scalar-replaceable\n+              if (alloc->_is_scalar_replaceable &&\n+                  klass->name() == ciSymbols::java_lang_String()) {\n+                found = alloc;\n+              }\n+            }\n+          }\n+        }\n+      } else if (use->is_Phi() && use->as_Phi()->unique_input(&gvn) == nullptr) {\n+        \/\/ merge multiple values, bail out\n+        return nullptr;\n+      }\n+    }\n+  }\n+\n+  return found;\n+}\n+\n+\/\/ Preconditions:\n+\/\/ 1. aa->is_str_alloc_obsolete() is true\n+\/\/ 2. res is aa->result_cast()\n+\/\/\n+\/\/ find ArrayCopyNode which uses res as Dest\n+static ArrayCopyNode* find_arraycopy_node_from_res(CheckCastPPNode* res) {\n+  ArrayCopyNode* ac = nullptr;\n+\n+  if (res != nullptr) {\n+    \/\/ we need to find the arraynode which use res as Dest\n+    for (DUIterator_Fast imax, i = res->fast_outs(imax); i < imax && ac == nullptr; i++) {\n+      Node* use = res->fast_out(i);\n+\n+      if (use->is_ArrayCopy() && res == use->in(ArrayCopyNode::Dest)) {\n+        ac = use->as_ArrayCopy();\n+      }\n+    }\n+  }\n+\n+  return ac;\n+}\n+\n@@ -875,0 +956,1 @@\n+\n@@ -884,0 +966,37 @@\n+\n+      \/\/ intercept the result of j.l.String::value\n+      \/\/ insert a nested sobj for it. the result looks like this:\n+      \/\/ sobj{hash, hashIsZero, coder, sobj{src, srcPos, len}}\n+      if (field_val->is_CheckCastPP() &&\n+          klass != nullptr && klass->name() == ciSymbols::java_lang_String()) {\n+        assert(j == 3, \"must be the field value:byte[]\");\n+\n+        AllocateArrayNode* aa = field_val->in(1)->in(0)->as_AllocateArray();\n+        AllocateNode* obj = find_string_alloc_from_res(_igvn, field_val->as_CheckCastPP());\n+        ArrayCopyNode* ac = nullptr;\n+\n+        if (obj == alloc && aa->is_str_alloc_obsolete()) {\n+          ac = find_arraycopy_node_from_res(field_val->as_CheckCastPP());\n+          assert(ac != nullptr, \"must see an ArrayCopyNode use field_val as Src\");\n+\n+          \/\/ res_type should be an instptr whose klass is j.l.String.\n+          \/\/ There are only 3 fields on purpose! I use SafePointScalarObjectNode and ObjectValue\n+          \/\/ as envelopes to mock and oop.\n+          \/\/ The real purpose is to encode information so deoptimization can allocate an arrayOop.\n+          \/\/ see Deoptimization::realloc_objects()\n+          SafePointScalarObjectNode* nest_sobj = new SafePointScalarObjectNode(res_type,\n+                                                      DEBUG_ONLY(alloc COMMA)\n+                                                      first_ind + j + 1, 3);\n+          nest_sobj->init_req(0, C->root());\n+          transform_later(nest_sobj);\n+\n+          sfpt->add_req(nest_sobj);\n+          \/\/ 1. src oop\n+          sfpt->add_req(ac->in(ArrayCopyNode::Src));\n+          \/\/ 2. src Position\n+          sfpt->add_req(ac->in(ArrayCopyNode::SrcPos));\n+          \/\/ 3. length\n+          sfpt->add_req(ac->in(ArrayCopyNode::Length));\n+          field_val = C->top();\n+        }\n+      }\n@@ -899,0 +1018,44 @@\n+\/\/ This is the specialized version of \"scalar\" replacment, dedicated to j.l.String::value\n+\/\/ the type of value is byte[]. process_users_of_string_allocation has replaced it with\n+\/\/ ArrayCopy's src.\n+\/\/\n+\/\/ Only create one SafePointScalarObject node and crecord 3 fixed fields:\n+\/\/ 1. src oop 2. srcPos 3. length\n+void PhaseMacroExpand::stable_array_replacement(AllocateArrayNode* alloc, ArrayCopyNode* ac, GrowableArray <SafePointNode* >& safepoints) {\n+  const int nfields = 3;\n+  Node* res = alloc->result_cast();\n+  if (res == nullptr) return ;\n+\n+  assert(res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n+  const TypeOopPtr* res_type = _igvn.type(res)->isa_oopptr();\n+\n+  while (safepoints.length() > 0) {\n+    SafePointNode* sfpt = safepoints.pop();\n+    \/\/ Fields of scalar objs are referenced only at the end\n+    \/\/ of regular debuginfo at the last (youngest) JVMS.\n+    \/\/ Record relative start index.\n+    uint first_ind = (sfpt->req() - sfpt->jvms()->scloff());\n+    SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,\n+                                                 DEBUG_ONLY(alloc COMMA)\n+                                                 first_ind, nfields);\n+    sobj->init_req(0, C->root());\n+    transform_later(sobj);\n+\n+    \/\/ 1. src oop\n+    sfpt->add_req(ac->in(ArrayCopyNode::Src));\n+    \/\/ 2. src Position\n+    sfpt->add_req(ac->in(ArrayCopyNode::SrcPos));\n+    \/\/ 3. length\n+    sfpt->add_req(ac->in(ArrayCopyNode::Length));\n+\n+    JVMState *jvms = sfpt->jvms();\n+    jvms->set_endoff(sfpt->req());\n+    \/\/ Now make a pass over the debug information replacing any references\n+    \/\/ to the allocated object with \"sobj\"\n+    int start = jvms->debug_start();\n+    int end   = jvms->debug_end();\n+    sfpt->replace_edges_in_range(res, sobj, start, end);\n+    _igvn._worklist.push(sfpt);\n+  }\n+}\n+\n@@ -1057,0 +1220,212 @@\n+bool PhaseMacroExpand::eliminate_strcpy_node(ArrayCopyNode* ac) {\n+  if (!EliminateAllocations || !OptimizeTempArray || C->congraph() == nullptr)\n+    return false;\n+\n+  if (!ac->is_string_copy(&_igvn))\n+    return false;\n+\n+  const ConnectionGraph& cg = *C->congraph();\n+  CheckCastPPNode* dst = ac->in(ArrayCopyNode::Dest)->as_CheckCastPP();\n+  \/\/ CheckCastPP <- Proj <- AllocateArray\n+  AllocateArrayNode* aa = dst->in(1)->in(0)->as_AllocateArray();\n+  PointsToNode* pt = cg.ptnode_adr(aa->_idx);\n+\n+  if (pt == nullptr || pt->escape_state() >= PointsToNode::GlobalEscape)\n+    return false;\n+\n+  \/\/ if AllocateArray(aa) is non-ecape, we could stop checking obj,\n+  \/\/ users may directly store the temporary contents to an array, eg.\n+  \/\/ byte[] buf = new byte[length] and System.arraycopy(str.value, 0, buf, 0, str.length())\n+  \/\/ but I have no idea how to guarantee aa is a stable array. just be conservative here.\n+  AllocateNode* obj = find_string_alloc_from_res(_igvn, dst);\n+  if (obj != nullptr) {\n+    pt = cg.ptnode_adr(obj->_idx);\n+  } else {\n+    pt = nullptr;\n+  }\n+\n+  if (pt != nullptr && pt->escape_state() == PointsToNode::NoEscape) {\n+#ifndef PRODUCT\n+    if (PrintEliminateAllocations) {\n+      tty->print_cr(\" %d ArrayCopyNode is eliminated\", ac->_idx);\n+    }\n+#endif\n+\n+    aa->_is_non_escaping = true; \/\/ this AllocateArray must be eliminated\n+    aa->_is_scalar_replaceable = true; \/\/ not really, we don't do SR for it.\n+    aa->set_str_alloc_obsolete(true);\n+    C->remove_macro_node(ac);\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+\/\/\n+\/\/ BEFORE\n+\/\/                   -------------------\n+\/\/                   |  AllocateArray  |\n+\/\/                   -------------------\n+\/\/                         |\n+\/\/                   -------------------\n+\/\/                   |   Project #5    |\n+\/\/                   -------------------\n+\/\/                         |\n+\/\/ ----------           -------------------\n+\/\/ | CastPP  |          |   CheckCastPP   |\n+\/\/ ----------           -------------------\n+\/\/            \\Src      |Dest        |  | \\_____________\n+\/\/             --------------------- |  -----------     \\\n+\/\/             |   ArrayCopy       | |  | EncodeP |      --------------\n+\/\/             --------------------- |  -----------      |   CastP2X  |\n+\/\/                                   |     ---------     --------------\n+\/\/                                   |     |ConL#16|\n+\/\/                                   |     ---------\n+\/\/                                    \\      \/\n+\/\/                                   ------------\n+\/\/                                   |  AddP    |\n+\/\/                                   ------------\n+\/\/                                   \/          \\\n+\/\/                              ----------       ----------\n+\/\/                             | LoadUB  |       |LoadRange|\n+\/\/                              ----------       ----------\n+\/\/\n+\/\/\n+\/\/\n+\/\/ AFTER\n+\/\/                       ----------\n+\/\/                       | SrcPos |   -----------\n+\/\/                       ----------  | ContL#16 |\n+\/\/                         |        \/ -----------\n+\/\/           ----------   --------\n+\/\/           | CastPP  |  | ADDL |\n+\/\/           ----------   --------\n+\/\/                 |S       |\n+\/\/                 |R       |\n+\/\/                 |C       |\n+\/\/                 |        |\n+\/\/                 |        \/\n+\/\/                -----------\n+\/\/                |  AddP   |\n+\/\/                -----------\n+\/\/                \/          \\\n+\/\/               ----------   ----------\n+\/\/               | LoadUB  |  |LoadRange|\n+\/\/               ----------   ----------\n+\/\/\n+\/\/\n+\/\/  EncodeP:  delete because we don't need storeN\n+\/\/  CastP2X:  delete because we don't need StoreCM\n+\/\/  AllocateArray: don't need to allocate byte[] (still need allocation in deoptimization)\n+\/\/  ArrayCopy: delete because we don't need to copy contents\n+\/\/  LoadRange: be replaced with ArrayCopy's Length\n+\/\/\n+void PhaseMacroExpand::process_users_of_string_allocation(AllocateArrayNode* alloc, ArrayCopyNode* ac) {\n+  Node* res = alloc->result_cast();\n+  Node* length = ac->in(ArrayCopyNode::Length);\n+  Node* src = ac->in(ArrayCopyNode::Src);\n+  assert(src->Opcode() == Op_CastPP || src->Opcode() == Op_CheckCastPP || src->Opcode() == Op_ConP,\n+        \"must be CastPP, CheckedCastPP or ConP\");\n+  Node* src_adr = nullptr;\n+\n+  if (res == nullptr) return;\n+\n+#ifndef PRODUCT\n+  _eliminated_string_allocation++;\n+  if (Verbose) {\n+    tty->print_cr(\"[process_users_of_string_allocation] alloc = %d, ac = %d\", alloc->_idx, ac->_idx);\n+  }\n+#endif\n+\n+  for (DUIterator_Fast imax, i = res->fast_outs(imax); i < imax; i++) {\n+    Node* use = res->fast_out(i);\n+    uint oc1 = res->outcnt();\n+\n+    if (use->is_AddP()) {\n+      Node* offset = use->in(AddPNode::Offset);\n+      int offset_const = (int) _igvn.find_intptr_t_con(offset, Type::OffsetBot);\n+\n+      \/\/ second AddP: just redirect its Base\n+      if (use->in(AddPNode::Address) != res) {\n+        assert(use->in(AddPNode::Base) == res, \"second AddP\");\n+        _igvn.replace_input_of(use, AddPNode::Base, src);\n+      } else {\n+        assert(use->in(AddPNode::Base) == res && use->in(AddPNode::Address) == res, \"must be a direct AddP\");\n+\n+        for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n+          Node* n = use->fast_out(j);\n+          uint oc2 = use->outcnt();\n+\n+          if (offset_const == arrayOopDesc::length_offset_in_bytes()) {\n+            assert(n->Opcode() == Op_LoadRange, \"res+12 must be the input of a LoadRange\");\n+            _igvn.replace_node(n, length);\n+          } else if (n->Opcode() == Op_StrEquals) {\n+            assert(offset_const == arrayOopDesc::base_offset_in_bytes(T_BYTE), \"offset equals to the base_offset\");\n+            if (src_adr == nullptr) {\n+              src_adr = ConvI2X(ac->in(ArrayCopyNode::SrcPos));\n+              src_adr = basic_plus_adr(src->in(1), src, src_adr);\n+            }\n+            Node* dst_adr = basic_plus_adr(src_adr->in(1), src_adr, offset);\n+            if (n->in(2) == use) { \/\/ str1\n+              _igvn.replace_input_of(n, 2, dst_adr);\n+            }\n+            if (n->in(3) == use) { \/\/ str2\n+              _igvn.replace_input_of(n, 3, dst_adr);\n+            }\n+          } else if (n->is_AddP()) {\n+            \/\/ Skip second AddP. This node must be handled by the upper level.\n+          } else {\n+            assert(n->Opcode() == Op_LoadUB || n->Opcode() == Op_LoadB, \"unknow code shape\");\n+\n+            if (src_adr == nullptr) {\n+              src_adr = ConvI2X(ac->in(ArrayCopyNode::SrcPos));\n+              src_adr = basic_plus_adr(src, src, src_adr);\n+            }\n+            Node* dst_adr = basic_plus_adr(src_adr->in(AddPNode::Base), src_adr, offset);\n+            _igvn.replace_input_of(n, MemNode::Control, ac->in(TypeFunc::Control));\n+            _igvn.replace_input_of(n, MemNode::Memory,  ac->in(TypeFunc::Memory));\n+            _igvn.replace_input_of(n, MemNode::Address, dst_adr);\n+          }\n+\n+          if (oc2 > use->outcnt()) {\n+            --j;\n+            jmax -= oc2 - use->outcnt();\n+          }\n+        }\n+\n+        if (use->outcnt() > 0) {\n+          \/\/ all uses are second AddP nodes\n+          if (src_adr == nullptr) {\n+            src_adr = ConvI2X(ac->in(ArrayCopyNode::SrcPos));\n+            src_adr = basic_plus_adr(src, src, src_adr);\n+          }\n+          _igvn.replace_input_of(use, AddPNode::Base, src);\n+          _igvn.replace_input_of(use, AddPNode::Address, src_adr);\n+        } else {\n+          _igvn.remove_dead_node(use);\n+        }\n+      }\n+    } else if (use->is_EncodeP()) {\n+      _igvn.replace_node(use, top());\n+      _igvn.remove_dead_node(use);\n+    } else if (use->is_ArrayCopy()) {\n+      ArrayCopyNode* ac2 = use->as_ArrayCopy();\n+      if (use == ac || res != ac2->in(ArrayCopyNode::Src)) continue; \/\/ identity or res is not the src of ArrayCopy\n+      Node* pos = transform_later(new AddINode(ac->in(ArrayCopyNode::SrcPos),\n+                                               ac2->in(ArrayCopyNode::SrcPos)));\n+      _igvn.replace_input_of(ac2, ArrayCopyNode::Src, src);\n+      _igvn.replace_input_of(ac2, ArrayCopyNode::SrcPos, pos);\n+      _igvn.replace_input_of(ac2, ArrayCopyNode::SrcLen, length);\n+    } else {\n+      \/\/ don't touch other nodes\n+      \/\/ remaining nodes should be SafePoint nodes. we should generate ad-hoc\n+      \/\/ nodes for debuginfo here\n+    }\n+\n+    if (oc1 > res->outcnt()) {\n+      --i;\n+      imax -= oc1 - res->outcnt();\n+    }\n+  }\n+}\n+\n@@ -1069,0 +1444,6 @@\n+  ArrayCopyNode* ac = nullptr; \/\/ only valid if str_alloc is true\n+\n+  \/\/ if j.l.String::value has been obsolete, AllocateArray can be eliminated\n+  bool str_alloc = alloc->is_AllocateArray() &&\n+                   alloc->as_AllocateArray()->is_str_alloc_obsolete();\n+\n@@ -1078,0 +1459,11 @@\n+  if (alloc->is_AllocateArray()) {\n+    AllocateArrayNode* aa = alloc->as_AllocateArray();\n+\n+    \/\/ aa has deprecated, now we need to handle its uses\n+    if (aa->is_str_alloc_obsolete()) {\n+      ac = find_arraycopy_node_from_res(res->isa_CheckCastPP());\n+      assert(ac != nullptr, \"[Warn]: Can't find the ArrayCopyNode which uses AllocateArray\");\n+      process_users_of_string_allocation(aa, ac);\n+    }\n+  }\n+\n@@ -1081,1 +1473,1 @@\n-  if (!can_eliminate_allocation(alloc, safepoints)) {\n+  if (!can_eliminate_allocation(alloc, str_alloc, safepoints)) {\n@@ -1095,1 +1487,3 @@\n-  if (!scalar_replacement(alloc, safepoints)) {\n+  if (str_alloc && ac != nullptr) {\n+    stable_array_replacement(alloc->as_AllocateArray(), ac, safepoints);\n+  } else if (!scalar_replacement(alloc, safepoints)) {\n@@ -2547,0 +2941,20 @@\n+\/\/ Sort macro nodes for strcpy elimination, result:\n+\/\/ others < AllocateArray(aa) < Allocate(alloc) < ArrayCopy(ac)\n+\/\/\n+\/\/ Rationale:\n+\/\/ the order make sure ME to process ac first and aa last.\n+\/\/ eliminate_strcpy_node(ac) must see alloc and aa, so process first.\n+\/\/ scalar_replacement(alloc) must see aa, so come after ac.\n+void PhaseMacroExpand::sort_macro_for_strcpy_opt() {\n+  int order[] = {Op_ArrayCopy, Op_Allocate, Op_AllocateArray};\n+\n+  int p = C->macro_count() - 1;\n+  for (int i = 0; i < 3; ++i) {\n+    for (int j = p; j >= 0 ; --j) {\n+      if (C->macro_node(j)->Opcode() == order[i]) {\n+        C->macro_node_swap(p--, j);\n+      }\n+    }\n+  }\n+}\n+\n@@ -2577,0 +2991,3 @@\n+\n+  sort_macro_for_strcpy_opt();\n+\n@@ -2600,0 +3017,1 @@\n+        success = eliminate_strcpy_node(n->as_ArrayCopy());\n@@ -2792,0 +3210,9 @@\n+\n+\/\/------------------------------print_statistics-------------------------------\n+#ifndef PRODUCT\n+int PhaseMacroExpand::_eliminated_string_allocation = 0;\n+\n+void PhaseMacroExpand::print_statistics() {\n+  tty->print_cr(\"PhaseMacroExpand elimianted_str_alloc = %d\", _eliminated_string_allocation);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":431,"deletions":4,"binary":false,"changes":435,"status":"modified"},{"patch":"@@ -41,0 +41,4 @@\n+#ifndef PRODUCT\n+  static int _eliminated_string_allocation;\n+#endif\n+\n@@ -109,0 +113,1 @@\n+  bool eliminate_strcpy_node(ArrayCopyNode* ac);\n@@ -110,1 +115,1 @@\n-  bool can_eliminate_allocation(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints);\n+  bool can_eliminate_allocation(AllocateNode *alloc, bool str_alloc, GrowableArray <SafePointNode *>& safepoints);\n@@ -112,0 +117,1 @@\n+  void stable_array_replacement(AllocateArrayNode* alloc, ArrayCopyNode* ac, GrowableArray<SafePointNode* >& safepoints_done);\n@@ -113,0 +119,1 @@\n+  void process_users_of_string_allocation(AllocateArrayNode* alloc, ArrayCopyNode* ac);\n@@ -210,1 +217,1 @@\n-\n+  void sort_macro_for_strcpy_opt();\n@@ -233,0 +240,1 @@\n+  static void print_statistics() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+    bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n@@ -222,0 +223,1 @@\n+      Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal, CHECK_AND_CLEAR_(true));\n@@ -226,0 +228,1 @@\n+      Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal, THREAD);\n@@ -228,2 +231,0 @@\n-    bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n-    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal);\n@@ -1034,0 +1035,32 @@\n+static void toposort_dfs(ObjectValue* ov, GrowableArray<ScopeValue*>& sorted,\n+                         const GrowableArray<ScopeValue*>& objects) {\n+  if (ov->is_visited()) return;\n+\n+  ov->set_visited(true);\n+  for (int i = 0; i < ov->field_size(); ++i) {\n+      if (ov->field_at(i)->is_object()) {\n+#ifdef ASSERT\n+        int ref = objects.find(ov->field_at(i));\n+        assert(ref != -1, \"must in be objects\");\n+#endif\n+        toposort_dfs(ov->field_at(i)->as_ObjectValue(), sorted, objects);\n+      }\n+  }\n+  sorted.append(ov);\n+}\n+\n+static void toposort(GrowableArray<ScopeValue*>& objects) {\n+  GrowableArray<ScopeValue*> sorted;\n+\n+  for (int i = 0; i < objects.length(); ++i) {\n+    toposort_dfs(objects.at(i)->as_ObjectValue(), sorted, objects);\n+  }\n+\n+  objects.swap(&sorted);\n+\n+  \/\/ reset visited\n+  for (int i = 0; i < objects.length(); ++i) {\n+    objects.at(i)->as_ObjectValue()->set_visited(false);\n+  }\n+}\n+\n@@ -1042,0 +1075,4 @@\n+  if (objects->length() > 1) {\n+    toposort(*objects);\n+  }\n+\n@@ -1066,0 +1103,13 @@\n+        } else if (OptimizeTempArray && ik == vmClasses::String_klass() && sv->field_size() == 3) {\n+          TypeArrayKlass* ak = TypeArrayKlass::create_klass(T_BYTE, THREAD);\n+          ScopeValue* x;\n+          StackValue* value;\n+          intptr_t val;\n+          int length;\n+\n+          x = sv->field_at(2);\n+          value = StackValue::create_stack_value(fr, reg_map, x);\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          val = value->get_int();\n+          length = (jint)*((jint*)&val);\n+          obj = ak->allocate(length, THREAD);\n@@ -1390,1 +1440,1 @@\n-void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal) {\n+void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, TRAPS) {\n@@ -1415,1 +1465,33 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);\n+\n+      if (ik == vmClasses::String_klass() && sv->field_size() == 3) {\n+        TypeArrayKlass* ak = TypeArrayKlass::create_klass(T_BYTE, THREAD);\n+        \/\/ open the envelope and re-allocate the eliminated arrayoop\n+        \/\/ [0] src\n+        \/\/ [1] src_pos\n+        \/\/ [2] length\n+        \/\/ dst = Arrays.copyOfRange(src, src_pos, src_pos + length)\n+        oop src;\n+        int src_pos;\n+        ScopeValue* x;\n+        StackValue* value;\n+        intptr_t val;\n+\n+        x = sv->field_at(0);\n+        value = StackValue::create_stack_value(fr, reg_map, x);\n+        assert(value->type() == T_OBJECT, \"Agreement.\");\n+        src = value->get_obj()();\n+\n+        x = sv->field_at(1);\n+        value  = StackValue::create_stack_value(fr, reg_map, x);\n+        assert(value->type() == T_INT, \"Agreement.\");\n+        val = value->get_int();\n+        src_pos = (jint)*((jint*)&val);\n+\n+        assert(sv->value()()->is_array(), \"must be an arrayOop\");\n+        arrayOop dst = (arrayOop)(sv->value()());\n+        ak->copy_array((arrayOop)src, src_pos, dst, 0, dst->length(), THREAD);\n+\n+        objects->delete_at(i--);\n+      } else {\n+        reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);\n+      }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":86,"deletions":4,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal);\n+  static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary verify that -XX:+OptimizeTempArray removes String.substring()\n+ * @library \/test\/lib \/\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4) & vm.debug == true\n+ * @requires !vm.emulatedClient & !vm.graal.enabled\n+ * @run driver compiler.c2.TestOptimizeSubstring\n+ *\/\n+\n+package compiler.c2;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+\n+public class TestOptimizeSubstring {\n+    \/\/ ideally, we should check the opcode 'call' as well, but x86_32.ad uses all CAPITAL opcodes.\n+    \/\/ the feature is 'CALL, static  wrapper for: _new_array_nozero_Java' on i686.\n+    static final String newStringAlloc = \/*call ,*\/\"static  wrapper for: _new_array_nozero_Java\";\n+\n+    public static void main (String args[]) {\n+        if (args.length == 0) {\n+            check(true);  \/\/ check generated code when c2 enables OptimizeSubstring\n+            check(false); \/\/ ... and disabled\n+            check_nontrivial();\n+            check_deoptimization();\n+        } else if (args[0].equals(\"nontrivial\")) {\n+            boolean val1 = false;\n+\n+            for (int i = 0; i < 20_000; ++i) {\n+                val1 |= TestOptimizeSubstring.useStartsWith_NonTrivial();\n+            }\n+\n+            Asserts.assertFalse(val1, \"val1 should be false\");\n+        } else if (args[0].equals(\"deoptimization\")) {\n+            int CNT = 20_000;\n+            String s = \"abcd\";\n+            boolean val1 = true;\n+\n+             for (int i = 0; i < CNT; ++i) {\n+                boolean f = i <= (CNT - 10) ? true : false;\n+                val1 &= TestOptimizeSubstring.mayHaveDeoptimization(s, f);\n+            }\n+\n+            Asserts.assertTrue(val1, \"val1 should be true\");\n+        } else {\n+            boolean val1 = false;\n+            boolean val2 = false;\n+\n+            for (int i = 0; i < 20_000; ++i) {\n+                val1 |= TestOptimizeSubstring.useStartsWith(\"abcdefghijklmnop\");\n+                val2 |= TestOptimizeSubstring.useStartsWith(\"efgdedfghijklmnop\");\n+            }\n+            Asserts.assertTrue (val1, \"val1 should be true\");\n+            Asserts.assertFalse(val2, \"val2 should be false\");\n+\n+            boolean caughtEx = false;\n+            try {\n+                TestOptimizeSubstring.useStartsWith(\"\");\n+            } catch(StringIndexOutOfBoundsException e) {\n+                caughtEx = true;\n+            }\n+            Asserts.assertTrue(caughtEx, \"useStartsWith(\\\"\\\") should throw StringIndexOutOfBoundsException\");\n+\n+        }\n+    }\n+\n+    private static void check(boolean enabled) {\n+        OutputAnalyzer oa;\n+\n+        try {\n+            oa = ProcessTools.executeTestJvm(\"-XX:+UnlockDiagnosticVMOptions\", \"-Xbootclasspath\/a:.\",\n+                    \"-XX:\" + (enabled ? \"+\" : \"-\") + \"OptimizeTempArray\",\n+                    \"-XX:+PrintOptoAssembly\", \"-XX:-TieredCompilation\", \"-XX:ArrayCopyLoadStoreMaxElem=0\",\n+                    \"-XX:CompileOnly=\" + TestOptimizeSubstring.class.getName() + \"::useStartsWith\",\n+                    TestOptimizeSubstring.class.getName(),\n+                    \"runtest\");\n+        } catch (Exception e) {\n+            throw new Error(\"Exception launching child for case enabled=\" + enabled + \" : \" + e, e);\n+        }\n+        oa.shouldHaveExitValue(0);\n+\n+        if (enabled) {\n+            oa.shouldNotContain(TestOptimizeSubstring.newStringAlloc);\n+        } else {\n+            oa.shouldContain(TestOptimizeSubstring.newStringAlloc);\n+        }\n+   }\n+\n+    private static void check_nontrivial() {\n+        OutputAnalyzer oa;\n+        try {\n+            oa = ProcessTools.executeTestJvm(\"-XX:+UnlockDiagnosticVMOptions\", \"-Xbootclasspath\/a:.\",\n+                    \"-XX:+OptimizeTempArray\", \"-XX:-UseOnStackReplacement\",\n+                    \"-XX:+PrintOptoAssembly\", \"-XX:-TieredCompilation\", \"-XX:ArrayCopyLoadStoreMaxElem=0\",\n+                    \"-XX:CompileOnly=\" + TestOptimizeSubstring.class.getName() + \"::useStartsWith_NonTrivial\",\n+                    TestOptimizeSubstring.class.getName(),\n+                    \"nontrivial\");\n+        } catch (Exception e) {\n+            throw new Error(\"Exception launching child for check_nontrivial\");\n+        }\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    private static void check_deoptimization() {\n+        OutputAnalyzer oa;\n+        try {\n+            oa = ProcessTools.executeTestJvm(\"-XX:+UnlockDiagnosticVMOptions\", \"-Xbootclasspath\/a:.\",\n+                    \"-XX:+OptimizeTempArray\", \"-XX:-UseOnStackReplacement\",\n+                    \"-XX:+PrintOptoAssembly\", \"-XX:-TieredCompilation\", \"-XX:ArrayCopyLoadStoreMaxElem=0\",\n+                    \"-XX:CompileOnly=\" + TestOptimizeSubstring.class.getName() + \"::mayHaveDeoptimization\",\n+                    \"-XX:+TraceDeoptimization\", \"-XX:+PrintDeoptimizationDetails\",\n+                    TestOptimizeSubstring.class.getName(),\n+                    \"deoptimization\");\n+        } catch (Exception e) {\n+            throw new Error(\"Exception launching child for mayHaveDeoptimization\");\n+        }\n+        oa.shouldHaveExitValue(0);\n+        oa.shouldNotContain(TestOptimizeSubstring.newStringAlloc);\n+        oa.shouldContain(\"ScObj0 java\/lang\/String={ [hash :0]=#0, [coder :1]=#0, [hashIsZero :2]=#0, [value :3]=#ScObj1 }\");\n+    }\n+\n+\n+    private static boolean useStartsWith(String s) {\n+        String x = s.substring(1);\n+        return x.startsWith(\"a\") | x.startsWith(\"b\") | x.startsWith(\"c\");\n+    }\n+\n+    \/\/ courtesy of John Rose's comment\n+    \/\/ https:\/\/github.com\/openjdk\/jdk\/pull\/974#pullrequestreview-551773771\n+    private static boolean useStartsWith_NonTrivial() {\n+        String s = \"abcd\";\n+        String x = s.substring(1, 2);\n+        return x.startsWith(\"bc\");\n+    }\n+\n+    private static boolean mayHaveDeoptimization(String s, boolean flag) {\n+        String p = s.substring(1, 3);\n+\n+        boolean result = true;\n+        result &= p.length() == 2;\n+        result &= p.charAt(0) == 'b';\n+        result &= p.charAt(1) == 'c';\n+\n+        if (!flag) { \/\/ unlikely, should trigger deoptimization of unstable_if\n+            result &= p.length() > 0;\n+            result &= p.charAt(0) == 'b';\n+            result &= p.charAt(1) == 'c';\n+        }\n+        return result;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestOptimizeSubstring.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 200, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 25, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+public class SubstringStartsWith {\n+    \/\/ model substrings in 3 representative lengths.\n+    \/\/ 1. small size = 4 for a variable name\n+    \/\/ 2. medium size = 24 or url or a filepath\n+    \/\/ 3. long string = 256 for a human-readable message\n+    @Param({\"4\", \"24\", \"256\"})\n+    private int substrLength;\n+    private String sample_ascii;\n+    private String sample_utf16;\n+    private String prefix_ascii;\n+    private String prefix_utf16;\n+\n+    @Setup(Level.Trial)\n+    public void doSetup() {\n+       StringBuilder sb = new StringBuilder();\n+       String tile = \"abcdef\";\n+       for (int i=0; i<512 * 2; i = i + tile.length()) {\n+           sb.append(tile);\n+       }\n+       sample_ascii = sb.toString();\n+       prefix_ascii = sample_ascii.substring(0, 2);\n+\n+       sb = new StringBuilder();\n+       tile = \"\\u4F60\\u597D\\u3088\\u3046\\u3053\\u305DJava\";\n+       for (int i=0; i<512 * 2; i = i + tile.length()) {\n+           sb.append(tile);\n+       }\n+       sample_utf16 = sb.toString();\n+       prefix_utf16 = sample_utf16.substring(0, 2);\n+    }\n+\n+    boolean substr2StartsWith(String base, String prefix) {\n+        return base.substring(1, 1 + substrLength).startsWith(prefix);\n+    }\n+\n+    boolean substr2StartsWith_noalloc(String base, String prefix) {\n+        \/\/boundary check as same as java.lang.String::checkBoundsBeginEnd\n+        int begin = 1;\n+        int end = begin + substrLength;\n+        if (begin < 0 || begin > end || end > base.length()) {\n+            throw new StringIndexOutOfBoundsException(\n+                \"begin \" + begin + \", end \" + end + \", length \" + base.length());\n+        }\n+\n+        return base.startsWith(prefix, begin);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_singleByte() {\n+        return substr2StartsWith(sample_ascii, prefix_ascii);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_noalloc_singleByte() {\n+        return substr2StartsWith_noalloc(sample_ascii, prefix_ascii);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_doubleBytes() {\n+        return substr2StartsWith(sample_utf16, prefix_utf16);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_noalloc_doubleBytes() {\n+        return substr2StartsWith_noalloc(sample_utf16, prefix_utf16);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/SubstringStartsWith.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"}]}