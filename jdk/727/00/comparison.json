{"files":[{"patch":"@@ -347,0 +347,4 @@\n+    if (op == Op_SubI && x == y) {\n+      \/\/ SubI(x, x) should be simplified to zero during parsing.\n+      return this_changed;\n+    }\n@@ -403,5 +407,13 @@\n-    Node *hook = new Node(1);\n-    hook->init_req(0, cx);  \/\/ Add a use to cx to prevent him from dying\n-    Node* cy = phase->C->constrained_convI2L(phase, y, TypeInt::make(rylo, ryhi, widen), NULL);\n-    hook->del_req(0);  \/\/ Just yank bogus edge\n-    hook->destruct();\n+    Node* cy;\n+    if (x == y) {\n+      \/\/ In the special case ConvI2L(AddI(x, x)), feed both inputs of AddL with\n+      \/\/ the same node cx = cy = ConvI2L(x).\n+      cy = cx;\n+    } else {\n+      \/\/ General case (x != y): create a different node cy = ConvI2L(y).\n+      Node *hook = new Node(1);\n+      hook->init_req(0, cx);  \/\/ Add a use to cx to prevent him from dying\n+      cy = phase->C->constrained_convI2L(phase, y, TypeInt::make(rylo, ryhi, widen), NULL);\n+      hook->del_req(0);  \/\/ Just yank bogus edge\n+      hook->destruct();\n+    }\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.conversions;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8254317\n+ * @requires vm.compiler2.enabled\n+ * @summary Exercises the optimization that moves integer-to-long conversions\n+ *          upwards through a chain of integer additions.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileOnly=compiler.conversions.TestMoveConvI2LThroughAddIChain::main\n+ *      compiler.conversions.TestMoveConvI2LThroughAddIChain\n+ *\/\n+\n+public class TestMoveConvI2LThroughAddIChain {\n+    static boolean val = true;\n+    public static void main(String[] args) {\n+        \/\/ This should make C2 infer that 'a' is in the value range [2,10],\n+        \/\/ enabling the optimization in ConvI2LNode::Ideal() for LP64 platforms.\n+        int a = val ? 2 : 10;\n+        int b = a + a;\n+        int c = b + b;\n+        int d = c + c;\n+        long out = d;\n+        Asserts.assertEQ(out, 16L);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LThroughAddIChain.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.conversions;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8254317\n+ * @requires vm.compiler2.enabled\n+ * @summary Exercises the optimization that moves integer-to-long conversions\n+ *          upwards through a DAG of integer additions.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileOnly=compiler.conversions.TestMoveConvI2LThroughAddIDAG::main\n+ *      compiler.conversions.TestMoveConvI2LThroughAddIDAG\n+ *\/\n+\n+public class TestMoveConvI2LThroughAddIDAG {\n+    static boolean val = true;\n+    public static void main(String[] args) {\n+        \/\/ This should make C2 infer that a0-3 are in the value range [2,10],\n+        \/\/ enabling the optimization in ConvI2LNode::Ideal() for LP64 platforms.\n+        int a0 = val ? 2 : 10;\n+        int a1 = val ? 2 : 10;\n+        int a2 = val ? 2 : 10;\n+        int a3 = val ? 2 : 10;\n+        int b0 = a0 + a1;\n+        int b1 = a1 + a2;\n+        int b2 = a2 + a3;\n+        int c0 = b0 + b1;\n+        int c1 = b1 + b2;\n+        int d = c0 + c1;\n+        long out = d;\n+        Asserts.assertEQ(out, 16L);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LThroughAddIDAG.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.conversions;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8254317\n+ * @requires vm.compiler2.enabled\n+ * @summary Exercises the optimization that moves integer-to-long conversions\n+ *          upwards through a tree of integer additions.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileOnly=compiler.conversions.TestMoveConvI2LThroughAddITree::main\n+ *      compiler.conversions.TestMoveConvI2LThroughAddITree\n+ *\/\n+\n+public class TestMoveConvI2LThroughAddITree {\n+    static boolean val = true;\n+    public static void main(String[] args) {\n+        \/\/ This should make C2 infer that a0-7 are in the value range [2,10],\n+        \/\/ enabling the optimization in ConvI2LNode::Ideal() for LP64 platforms.\n+        int a0 = val ? 2 : 10;\n+        int a1 = val ? 2 : 10;\n+        int a2 = val ? 2 : 10;\n+        int a3 = val ? 2 : 10;\n+        int a4 = val ? 2 : 10;\n+        int a5 = val ? 2 : 10;\n+        int a6 = val ? 2 : 10;\n+        int a7 = val ? 2 : 10;\n+        int b0 = a0 + a1;\n+        int b1 = a2 + a3;\n+        int b2 = a4 + a5;\n+        int b3 = a6 + a7;\n+        int c0 = b0 + b1;\n+        int c1 = b2 + b3;\n+        int d = c0 + c1;\n+        long out = d;\n+        Asserts.assertEQ(out, 16L);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LThroughAddITree.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmarks C2 compilation time on long chains of integer additions followed\n+ * by an integer-to-long conversion. This pattern triggers an optimization in\n+ * ConvI2LNode::Ideal() that resulted in an exponential growth of compilation\n+ * time and memory (see bug 8254317).\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(10)\n+public class ConvertIntAddChainToLong {\n+\n+    static boolean val = true;\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.COMPILE_ONLY)\n+    @Fork(jvmArgsAppend = {\"-Xcomp\", \"-XX:-TieredCompilation\"})\n+    public void convertIntAddChainToLong(Blackhole bh) {\n+        \/\/ This should make C2 infer that 'a' is in the value range [2,10],\n+        \/\/ enabling the optimization in ConvI2LNode::Ideal() for LP64 platforms.\n+        int a = val ? 2 : 10;\n+        \/\/ This loop should be fully unrolled into a long chain of additions.\n+        for (int i = 0; i < 24; i++) {\n+            a = a + a;\n+        }\n+        \/\/ This conversion should trigger the ConvI2LNode::Ideal() optimization.\n+        long out = a;\n+        bh.consume(out);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ConvertIntAddChainToLong.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"}]}