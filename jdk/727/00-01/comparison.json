{"files":[{"patch":"@@ -261,0 +261,15 @@\n+\n+\/\/ If the given node has a ConvI2LNode user of the given type, return it.\n+\/\/ Otherwise, create and return a new one, postponing its optimization to avoid\n+\/\/ an explosion of recursive Ideal() calls when compiling long AddI chains.\n+static Node* find_or_make_convI2L(PhaseIterGVN* igvn, Node* value,\n+                                  const TypeLong* ltype) {\n+  for (DUIterator_Fast imax, i = value->fast_outs(imax); i < imax; i++) {\n+    Node* n = value->fast_out(i);\n+    if (n->Opcode() == Op_ConvI2L &&\n+        static_cast<TypeNode*>(n)->type()->is_long()->eq(ltype)) {\n+      return n;\n+    }\n+  }\n+  return igvn->register_new_node_with_optimizer(new ConvI2LNode(value, ltype));\n+}\n@@ -265,0 +280,1 @@\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n@@ -268,1 +284,1 @@\n-  if (can_reshape) {\n+  if (igvn != NULL) {\n@@ -337,4 +353,3 @@\n-    if (!can_reshape) {\n-      \/\/ Postpone this optimization to after parsing because with deep AddNode\n-      \/\/ chains a large amount of dead ConvI2L nodes might be created that are\n-      \/\/ not removed during parsing. As a result, we might hit the node limit.\n+    if (igvn == NULL) {\n+      \/\/ Postpone this optimization to iterative GVN, where we can handle deep\n+      \/\/ AddI chains without an exponential number of recursive Ideal() calls.\n@@ -347,4 +362,0 @@\n-    if (op == Op_SubI && x == y) {\n-      \/\/ SubI(x, x) should be simplified to zero during parsing.\n-      return this_changed;\n-    }\n@@ -406,14 +417,2 @@\n-    Node* cx = phase->C->constrained_convI2L(phase, x, TypeInt::make(rxlo, rxhi, widen), NULL);\n-    Node* cy;\n-    if (x == y) {\n-      \/\/ In the special case ConvI2L(AddI(x, x)), feed both inputs of AddL with\n-      \/\/ the same node cx = cy = ConvI2L(x).\n-      cy = cx;\n-    } else {\n-      \/\/ General case (x != y): create a different node cy = ConvI2L(y).\n-      Node *hook = new Node(1);\n-      hook->init_req(0, cx);  \/\/ Add a use to cx to prevent him from dying\n-      cy = phase->C->constrained_convI2L(phase, y, TypeInt::make(rylo, ryhi, widen), NULL);\n-      hook->del_req(0);  \/\/ Just yank bogus edge\n-      hook->destruct();\n-    }\n+    Node* cx = find_or_make_convI2L(igvn, x, TypeLong::make(rxlo, rxhi, widen));\n+    Node* cy = find_or_make_convI2L(igvn, y, TypeLong::make(rylo, ryhi, widen));\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.conversions;\n-\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test\n- * @bug 8254317\n- * @requires vm.compiler2.enabled\n- * @summary Exercises the optimization that moves integer-to-long conversions\n- *          upwards through a chain of integer additions.\n- * @library \/test\/lib \/\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation\n- *      -XX:CompileOnly=compiler.conversions.TestMoveConvI2LThroughAddIChain::main\n- *      compiler.conversions.TestMoveConvI2LThroughAddIChain\n- *\/\n-\n-public class TestMoveConvI2LThroughAddIChain {\n-    static boolean val = true;\n-    public static void main(String[] args) {\n-        \/\/ This should make C2 infer that 'a' is in the value range [2,10],\n-        \/\/ enabling the optimization in ConvI2LNode::Ideal() for LP64 platforms.\n-        int a = val ? 2 : 10;\n-        int b = a + a;\n-        int c = b + b;\n-        int d = c + c;\n-        long out = d;\n-        Asserts.assertEQ(out, 16L);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LThroughAddIChain.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.conversions;\n-\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test\n- * @bug 8254317\n- * @requires vm.compiler2.enabled\n- * @summary Exercises the optimization that moves integer-to-long conversions\n- *          upwards through a DAG of integer additions.\n- * @library \/test\/lib \/\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation\n- *      -XX:CompileOnly=compiler.conversions.TestMoveConvI2LThroughAddIDAG::main\n- *      compiler.conversions.TestMoveConvI2LThroughAddIDAG\n- *\/\n-\n-public class TestMoveConvI2LThroughAddIDAG {\n-    static boolean val = true;\n-    public static void main(String[] args) {\n-        \/\/ This should make C2 infer that a0-3 are in the value range [2,10],\n-        \/\/ enabling the optimization in ConvI2LNode::Ideal() for LP64 platforms.\n-        int a0 = val ? 2 : 10;\n-        int a1 = val ? 2 : 10;\n-        int a2 = val ? 2 : 10;\n-        int a3 = val ? 2 : 10;\n-        int b0 = a0 + a1;\n-        int b1 = a1 + a2;\n-        int b2 = a2 + a3;\n-        int c0 = b0 + b1;\n-        int c1 = b1 + b2;\n-        int d = c0 + c1;\n-        long out = d;\n-        Asserts.assertEQ(out, 16L);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LThroughAddIDAG.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.conversions;\n-\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test\n- * @bug 8254317\n- * @requires vm.compiler2.enabled\n- * @summary Exercises the optimization that moves integer-to-long conversions\n- *          upwards through a tree of integer additions.\n- * @library \/test\/lib \/\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation\n- *      -XX:CompileOnly=compiler.conversions.TestMoveConvI2LThroughAddITree::main\n- *      compiler.conversions.TestMoveConvI2LThroughAddITree\n- *\/\n-\n-public class TestMoveConvI2LThroughAddITree {\n-    static boolean val = true;\n-    public static void main(String[] args) {\n-        \/\/ This should make C2 infer that a0-7 are in the value range [2,10],\n-        \/\/ enabling the optimization in ConvI2LNode::Ideal() for LP64 platforms.\n-        int a0 = val ? 2 : 10;\n-        int a1 = val ? 2 : 10;\n-        int a2 = val ? 2 : 10;\n-        int a3 = val ? 2 : 10;\n-        int a4 = val ? 2 : 10;\n-        int a5 = val ? 2 : 10;\n-        int a6 = val ? 2 : 10;\n-        int a7 = val ? 2 : 10;\n-        int b0 = a0 + a1;\n-        int b1 = a2 + a3;\n-        int b2 = a4 + a5;\n-        int b3 = a6 + a7;\n-        int c0 = b0 + b1;\n-        int c1 = b2 + b3;\n-        int d = c0 + c1;\n-        long out = d;\n-        Asserts.assertEQ(out, 16L);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LThroughAddITree.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.conversions;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8254317\n+ * @requires vm.compiler2.enabled\n+ * @summary Exercises the optimization that moves integer-to-long conversions\n+ *          upwards through different shapes of integer addition\n+ *          subgraphs. Contains three basic (small) tests and two stress tests\n+ *          that resulted in a compilation time and memory explosion, triggering\n+ *          the short specified timeout.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:-Inline\n+ *      -XX:CompileOnly=::testChain,::testTree,::testDAG\n+ *      compiler.conversions.TestMoveConvI2LThroughAddIs basic\n+ * @run main\/othervm\/timeout=1 -Xcomp -XX:-TieredCompilation -XX:-Inline\n+ *      -XX:CompileOnly=::testStress1\n+ *      compiler.conversions.TestMoveConvI2LThroughAddIs stress1\n+ * @run main\/othervm\/timeout=1 -Xcomp -XX:-TieredCompilation -XX:-Inline\n+ *      -XX:CompileOnly=::testStress2\n+ *      compiler.conversions.TestMoveConvI2LThroughAddIs stress2\n+ *\/\n+\n+public class TestMoveConvI2LThroughAddIs {\n+\n+    \/\/ This guard is used to make C2 infer that the 'a' variables in the\n+    \/\/ different test methods are in a small value range, enabling the\n+    \/\/ optimization in ConvI2LNode::Ideal() for LP64 platforms.\n+    static boolean val = true;\n+\n+    static void testChain() {\n+        int a = val ? 2 : 10;\n+        int b = a + a;\n+        int c = b + b;\n+        int d = c + c;\n+        long out = d;\n+        Asserts.assertEQ(out, 16L);\n+    }\n+\n+    static void testTree() {\n+        int a0 = val ? 2 : 10;\n+        int a1 = val ? 2 : 10;\n+        int a2 = val ? 2 : 10;\n+        int a3 = val ? 2 : 10;\n+        int a4 = val ? 2 : 10;\n+        int a5 = val ? 2 : 10;\n+        int a6 = val ? 2 : 10;\n+        int a7 = val ? 2 : 10;\n+        int b0 = a0 + a1;\n+        int b1 = a2 + a3;\n+        int b2 = a4 + a5;\n+        int b3 = a6 + a7;\n+        int c0 = b0 + b1;\n+        int c1 = b2 + b3;\n+        int d = c0 + c1;\n+        long out = d;\n+        Asserts.assertEQ(out, 16L);\n+    }\n+\n+    static void testDAG() {\n+        int a0 = val ? 2 : 10;\n+        int a1 = val ? 2 : 10;\n+        int a2 = val ? 2 : 10;\n+        int a3 = val ? 2 : 10;\n+        int b0 = a0 + a1;\n+        int b1 = a1 + a2;\n+        int b2 = a2 + a3;\n+        int c0 = b0 + b1;\n+        int c1 = b1 + b2;\n+        int d = c0 + c1;\n+        long out = d;\n+        Asserts.assertEQ(out, 16L);\n+    }\n+\n+    static void testStress1() {\n+        int a = val ? 2 : 10;\n+        \/\/ This loop should be fully unrolled.\n+        for (int i = 0; i < 24; i++) {\n+            a = a + a;\n+        }\n+        long out = a;\n+        Asserts.assertEQ(out, 33554432L);\n+    }\n+\n+    static void testStress2() {\n+         int a = val ? 1 : 2;\n+         int b = a;\n+         int c = a + a;\n+         \/\/ This loop should be fully unrolled.\n+         for (int i = 0; i < 16; i++) {\n+             b = b + c;\n+             c = b + c;\n+         }\n+         long out = b + c;\n+         Asserts.assertEQ(out, 14930352L);\n+     }\n+\n+    public static void main(String[] args) {\n+        switch(args[0]) {\n+        case \"basic\":\n+            testChain();\n+            testTree();\n+            testDAG();\n+            break;\n+        case \"stress1\":\n+            testStress1();\n+        case \"stress2\":\n+            testStress2();\n+        default:\n+            System.out.println(\"invalid mode\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LThroughAddIs.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.vm.compiler;\n-\n-import org.openjdk.jmh.annotations.*;\n-import org.openjdk.jmh.infra.*;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * Benchmarks C2 compilation time on long chains of integer additions followed\n- * by an integer-to-long conversion. This pattern triggers an optimization in\n- * ConvI2LNode::Ideal() that resulted in an exponential growth of compilation\n- * time and memory (see bug 8254317).\n- *\/\n-@BenchmarkMode(Mode.SingleShotTime)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@State(Scope.Thread)\n-@Fork(10)\n-public class ConvertIntAddChainToLong {\n-\n-    static boolean val = true;\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.COMPILE_ONLY)\n-    @Fork(jvmArgsAppend = {\"-Xcomp\", \"-XX:-TieredCompilation\"})\n-    public void convertIntAddChainToLong(Blackhole bh) {\n-        \/\/ This should make C2 infer that 'a' is in the value range [2,10],\n-        \/\/ enabling the optimization in ConvI2LNode::Ideal() for LP64 platforms.\n-        int a = val ? 2 : 10;\n-        \/\/ This loop should be fully unrolled into a long chain of additions.\n-        for (int i = 0; i < 24; i++) {\n-            a = a + a;\n-        }\n-        \/\/ This conversion should trigger the ConvI2LNode::Ideal() optimization.\n-        long out = a;\n-        bh.consume(out);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ConvertIntAddChainToLong.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"}]}