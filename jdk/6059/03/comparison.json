{"files":[{"patch":"@@ -47,0 +47,12 @@\n+static uint default_log2_card_region_per_region() {\n+  \/\/ Heap region virtualization.\n+  uint log2_card_region_per_heap_region = 0;\n+\n+  uint bits_storable = G1CardSetContainer::LogCardsPerRegionLimit;\n+  if (bits_storable < (uint)HeapRegion::LogCardsPerRegion) {\n+    log2_card_region_per_heap_region = (uint)HeapRegion::LogCardsPerRegion - bits_storable;\n+  }\n+\n+  return log2_card_region_per_heap_region;\n+}\n+\n@@ -53,2 +65,6 @@\n-                         (uint)HeapRegion::CardsPerRegion)                          \/* max_cards_in_cardset *\/\n-                         { }\n+                         (uint)HeapRegion::CardsPerRegion,                          \/* max_cards_in_cardset *\/\n+                         default_log2_card_region_per_region())                     \/* log2_card_region_per_region *\/\n+{\n+  assert((_log2_card_region_per_heap_region + _log2_card_region_size) == (uint)HeapRegion::LogCardsPerRegion,\n+         \"inconsistent heap region virtualization setup\");\n+}\n@@ -60,1 +76,2 @@\n-                                               uint max_cards_in_card_set) :\n+                                               uint max_cards_in_card_set,\n+                                               uint log2_card_region_per_region) :\n@@ -68,2 +85,3 @@\n-                         max_cards_in_card_set)                                \/* max_cards_in_cardset *\/\n-                         { }\n+                         max_cards_in_card_set,                                \/* max_cards_in_cardset *\/\n+                         log2_card_region_per_region)\n+{ }\n@@ -76,1 +94,2 @@\n-                                               uint max_cards_in_card_set) :\n+                                               uint max_cards_in_card_set,\n+                                               uint log2_card_region_per_heap_region) :\n@@ -85,1 +104,3 @@\n-  _bitmap_hash_mask(~(~(0) << _log2_num_cards_in_howl_bitmap)) {\n+  _bitmap_hash_mask(~(~(0) << _log2_num_cards_in_howl_bitmap)),\n+  _log2_card_region_per_heap_region(log2_card_region_per_heap_region),\n+  _log2_card_region_size(log2i_exact(_max_cards_in_card_set) - _log2_card_region_per_heap_region) {\n@@ -91,1 +112,0 @@\n-\n@@ -112,1 +132,2 @@\n-                          \"Howl Bitmap #elems %u size %zu coarsen threshold %u\",\n+                          \"Howl Bitmap #elems %u size %zu coarsen threshold %u \"\n+                          \"Card regions per heap region %u card region size %u\",\n@@ -116,1 +137,3 @@\n-                          num_cards_in_howl_bitmap(), G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), cards_in_howl_bitmap_threshold());\n+                          num_cards_in_howl_bitmap(), G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), cards_in_howl_bitmap_threshold(),\n+                          (uint)1 << log2_card_region_per_heap_region(),\n+                          (uint)1 << log2_card_region_size());\n@@ -831,0 +854,18 @@\n+template <typename Closure, template <typename> class CardOrRanges>\n+class G1CardSetIterateCardsIterator : public G1CardSet::G1CardSetPtrIterator {\n+  G1CardSet* _card_set;\n+  Closure& _iter;\n+\n+public:\n+\n+  G1CardSetIterateCardsIterator(G1CardSet* card_set,\n+                                Closure& iter) :\n+    _card_set(card_set),\n+    _iter(iter) { }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    CardOrRanges<Closure> cl(_iter, region_idx);\n+    _card_set->iterate_cards_or_ranges_in_container(card_set, cl);\n+  }\n+};\n+\n@@ -832,1 +873,1 @@\n-  G1CardSetMergeCardIterator<G1CardSetCardIterator, G1ContainerCards> cl(this, iter);\n+  G1CardSetIterateCardsIterator<G1CardSetCardIterator, G1ContainerCards> cl(this, iter);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":52,"deletions":11,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+  uint _log2_card_region_per_heap_region;\n+  uint _log2_card_region_size;\n@@ -69,1 +71,2 @@\n-                         uint max_cards_in_card_set);\n+                         uint max_cards_in_card_set,\n+                         uint log2_card_region_per_heap_region);\n@@ -78,1 +81,1 @@\n-  \/\/ Only for test\n+  \/\/ Testing only.\n@@ -83,1 +86,2 @@\n-                         uint max_cards_in_card_set);\n+                         uint max_cards_in_cardset,\n+                         uint log2_card_region_per_region);\n@@ -118,0 +122,14 @@\n+  \/\/ Heap region virtualization: there are some limitations to how much cards the\n+  \/\/ containers can cover to save memory for the common case. Heap region virtualization\n+  \/\/ allows to use multiple entries in the G1CardSet hash table per area covered\n+  \/\/ by the remembered set (e.g. heap region); each such entry is called \"card_region\".\n+  \/\/\n+  \/\/ The next two members give information about how many card regions are there\n+  \/\/ per area (heap region) and how large each card region is.\n+\n+  \/\/ The log2 of the amount of card regions configured.\n+  uint log2_card_region_per_heap_region() const { return _log2_card_region_per_heap_region; }\n+  \/\/ The log2 of the card region size. This is calculated from max_cards_in_region()\n+  \/\/ and above.\n+  uint log2_card_region_size() const { return _log2_card_region_size; }\n+\n@@ -174,3 +192,0 @@\n-  template <typename Closure, template <typename> class CardorRanges>\n-  friend class G1CardSetMergeCardIterator;\n-\n@@ -281,17 +296,0 @@\n-  \/\/ Iterate over the container, calling a method on every card or card range contained\n-  \/\/ in the card container.\n-  \/\/ For every container, first calls\n-  \/\/\n-  \/\/   void start_iterate(uint tag, uint region_idx);\n-  \/\/\n-  \/\/ Then for every card or card range it calls\n-  \/\/\n-  \/\/   void do_card(uint card_idx);\n-  \/\/   void do_card_range(uint card_idx, uint length);\n-  \/\/\n-  \/\/ where card_idx is the card index within that region_idx passed before in\n-  \/\/ start_iterate().\n-  \/\/\n-  template <class CardOrRangeVisitor>\n-  void iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found);\n-\n@@ -343,1 +341,17 @@\n-  \/\/ Various iterators - should be made inlineable somehow.\n+  \/\/ Iterate over the container, calling a method on every card or card range contained\n+  \/\/ in the card container.\n+  \/\/ For every container, first calls\n+  \/\/\n+  \/\/   void start_iterate(uint tag, uint region_idx);\n+  \/\/\n+  \/\/ Then for every card or card range it calls\n+  \/\/\n+  \/\/   void do_card(uint card_idx);\n+  \/\/   void do_card_range(uint card_idx, uint length);\n+  \/\/\n+  \/\/ where card_idx is the card index within that region_idx passed before in\n+  \/\/ start_iterate().\n+  \/\/\n+  template <class CardOrRangeVisitor>\n+  void iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found);\n+\n@@ -357,5 +371,0 @@\n-\n-  \/\/ Iterate all cards for card set merging. Must be a CardOrRangeVisitor as\n-  \/\/ explained above.\n-  template <class CardOrRangeVisitor>\n-  void iterate_for_merge(CardOrRangeVisitor& cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":38,"deletions":29,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -83,42 +83,0 @@\n-template <typename Closure>\n-class G1ContainerCardsOrRanges {\n-  Closure& _iter;\n-  uint _region_idx;\n-\n-public:\n-  G1ContainerCardsOrRanges(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n-\n-  bool start_iterate(uint tag) {\n-    return _iter.start_iterate(tag, _region_idx);\n-  }\n-\n-  void operator()(uint card_idx) {\n-    _iter.do_card(card_idx);\n-  }\n-\n-  void operator()(uint card_idx, uint length) {\n-    _iter.do_card_range(card_idx, length);\n-  }\n-};\n-\n-template <typename Closure, template <typename> class CardOrRanges>\n-class G1CardSetMergeCardIterator : public G1CardSet::G1CardSetPtrIterator {\n-  G1CardSet* _card_set;\n-  Closure& _iter;\n-\n-public:\n-\n-  G1CardSetMergeCardIterator(G1CardSet* card_set, Closure& iter) : _card_set(card_set), _iter(iter) { }\n-\n-  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n-    CardOrRanges<Closure> cl(_iter, region_idx);\n-    _card_set->iterate_cards_or_ranges_in_container(card_set, cl);\n-  }\n-};\n-\n-template <class CardOrRangeVisitor>\n-inline void G1CardSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n-  G1CardSetMergeCardIterator<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(this, cl);\n-  iterate_containers(&cl2, true \/* at_safepoint *\/);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.inline.hpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -109,2 +109,2 @@\n-  \/\/ Testing showed that 8 for 1M\/2M region, 16 for 4M\/8M regions, 32 for 16\/32M regions\n-  \/\/ seems to be such a good trade-off.\n+  \/\/ Testing showed that 8 for 1M\/2M region, 16 for 4M\/8M regions, 32 for 16\/32M regions,\n+  \/\/ and so on seems to be such a good trade-off.\n@@ -115,2 +115,2 @@\n-    assert(log_region_size >= 20 && log_region_size <= 25,\n-           \"expected value in [20,25], but got %u\", log_region_size);\n+    assert(log_region_size >= 20 && log_region_size <= 29,\n+           \"expected value in [20,29], but got %u\", log_region_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-          range(0, 32*M)                                                    \\\n+          range(0, NOT_LP64(32*M) LP64_ONLY(512*M))                         \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  static const size_t MAX_REGION_SIZE = 32 * 1024 * 1024;\n+  static const size_t MAX_REGION_SIZE = 512 * 1024 * 1024;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionBounds.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,50 @@\n+template <typename Closure>\n+class G1ContainerCardsOrRanges {\n+  Closure& _iter;\n+  uint _region_idx;\n+  uint _offset;\n+\n+public:\n+  G1ContainerCardsOrRanges(Closure& iter, uint region_idx, uint offset) : _iter(iter), _region_idx(region_idx), _offset(offset) { }\n+\n+  bool start_iterate(uint tag) {\n+    return _iter.start_iterate(tag, _region_idx);\n+  }\n+\n+  void operator()(uint card_idx) {\n+    _iter.do_card(card_idx + _offset);\n+  }\n+\n+  void operator()(uint card_idx, uint length) {\n+    _iter.do_card_range(card_idx + _offset, length);\n+  }\n+};\n+\n+template <typename Closure, template <typename> class CardOrRanges>\n+class G1HeapRegionRemSetMergeCardIterator : public G1CardSet::G1CardSetPtrIterator {\n+  G1CardSet* _card_set;\n+  Closure& _iter;\n+  uint _log_card_regions_per_region;\n+  uint _card_regions_per_region_mask;\n+  uint _log_card_region_size;\n+\n+public:\n+\n+  G1HeapRegionRemSetMergeCardIterator(G1CardSet* card_set,\n+                                      Closure& iter,\n+                                      uint log_card_regions_per_region,\n+                                      uint log_card_region_size) :\n+    _card_set(card_set),\n+    _iter(iter),\n+    _log_card_regions_per_region(log_card_regions_per_region),\n+    _card_regions_per_region_mask((1 << log_card_regions_per_region) - 1),\n+    _log_card_region_size(log_card_region_size) {\n+  }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    CardOrRanges<Closure> cl(_iter,\n+                             region_idx >> _log_card_regions_per_region,\n+                             (region_idx & _card_regions_per_region_mask) << _log_card_region_size);\n+    _card_set->iterate_cards_or_ranges_in_container(card_set, cl);\n+  }\n+};\n@@ -61,1 +111,5 @@\n-  _card_set.iterate_for_merge(cl);\n+  G1HeapRegionRemSetMergeCardIterator<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(&_card_set,\n+                                                                                        cl,\n+                                                                                        _card_set.config()->log2_card_region_per_heap_region(),\n+                                                                                        _card_set.config()->log2_card_region_size());\n+  _card_set.iterate_containers(&cl2, true \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -213,1 +213,2 @@\n-                                CardsPerRegion);\n+                                CardsPerRegion,\n+                                0);\n@@ -431,1 +432,2 @@\n-                                CardsPerRegion);\n+                                CardsPerRegion,\n+                                0);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.test.lib.Platform;\n@@ -85,1 +86,7 @@\n-    checkG1HeapRegionSize(new String[] { \"-Xmx256m\", \"-XX:G1HeapRegionSize=64m\" }, 32*M, 1);\n+    if (Platform.is64bit()) {\n+      checkG1HeapRegionSize(new String[] { \"-Xmx4096m\", \"-XX:G1HeapRegionSize=64m\" }, 64*M, 0);\n+      checkG1HeapRegionSize(new String[] { \"-Xmx4096m\", \"-XX:G1HeapRegionSize=512m\" }, 512*M, 0);\n+      checkG1HeapRegionSize(new String[] { \"-Xmx4096m\", \"-XX:G1HeapRegionSize=1024m\" }, 512*M, 1);\n+    } else {\n+      checkG1HeapRegionSize(new String[] { \"-Xmx256m\", \"-XX:G1HeapRegionSize=64m\" }, 64*M, 1);\n+    }\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapRegionSize.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}