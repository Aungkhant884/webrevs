{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,3 +139,0 @@\n-        \/\/ work around 1.4.2 counter inititization bugs\n-        kludge(map);\n-\n@@ -304,145 +301,0 @@\n-    \/**\n-     * method to make adjustments for known counter problems. This\n-     * method depends on the availability of certain counters, which\n-     * is generally guaranteed by the synchWithTarget() method.\n-     *\/\n-    protected void kludge(Map<String, Monitor> map) {\n-        if (Boolean.getBoolean(\"sun.jvmstat.perfdata.disableKludge\")) {\n-            \/\/ bypass all kludges\n-            return;\n-        }\n-\n-        String name = \"java.vm.version\";\n-        StringMonitor jvm_version = (StringMonitor)map.get(name);\n-        if (jvm_version == null) {\n-            jvm_version = (StringMonitor)findByAlias(name);\n-        }\n-\n-        name = \"java.vm.name\";\n-        StringMonitor jvm_name = (StringMonitor)map.get(name);\n-        if (jvm_name == null) {\n-            jvm_name = (StringMonitor)findByAlias(name);\n-        }\n-\n-        name = \"hotspot.vm.args\";\n-        StringMonitor args = (StringMonitor)map.get(name);\n-        if (args == null) {\n-            args = (StringMonitor)findByAlias(name);\n-        }\n-\n-        assert ((jvm_name != null) && (jvm_version != null) && (args != null));\n-\n-        if (jvm_name.stringValue().indexOf(\"HotSpot\") >= 0) {\n-            if (jvm_version.stringValue().startsWith(\"1.4.2\")) {\n-                kludgeMantis(map, args);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * method to repair the 1.4.2 parallel scavenge counters that are\n-     * incorrectly initialized by the JVM when UseAdaptiveSizePolicy\n-     * is set. This bug couldn't be fixed for 1.4.2 FCS due to putback\n-     * restrictions.\n-     *\/\n-    private void kludgeMantis(Map<String, Monitor> map, StringMonitor args) {\n-        \/*\n-         * the HotSpot 1.4.2 JVM with the +UseParallelGC option along\n-         * with its default +UseAdaptiveSizePolicy option has a bug with\n-         * the initialization of the sizes of the eden and survivor spaces.\n-         * See bugid 4890736.\n-         *\n-         * note - use explicit 1.4.2 counter names here - don't update\n-         * to latest counter names or attempt to find aliases.\n-         *\/\n-\n-        String cname = \"hotspot.gc.collector.0.name\";\n-        StringMonitor collector = (StringMonitor)map.get(cname);\n-\n-        if (collector.stringValue().equals(\"PSScavenge\")) {\n-            boolean adaptiveSizePolicy = true;\n-\n-            \/*\n-             * HotSpot processes the -XX:Flags\/.hotspotrc arguments prior to\n-             * processing the command line arguments. This allows the command\n-             * line arguments to override any defaults set in .hotspotrc\n-             *\/\n-            cname = \"hotspot.vm.flags\";\n-            StringMonitor flags = (StringMonitor)map.get(cname);\n-            String allArgs = flags.stringValue() + \" \" + args.stringValue();\n-\n-            \/*\n-             * ignore the -XX: prefix as it only applies to the arguments\n-             * passed from the command line (i.e. the invocation api).\n-             * arguments passed through .hotspotrc omit the -XX: prefix.\n-             *\/\n-            int ahi = allArgs.lastIndexOf(\"+AggressiveHeap\");\n-            int aspi = allArgs.lastIndexOf(\"-UseAdaptiveSizePolicy\");\n-\n-            if (ahi != -1) {\n-                \/*\n-                 * +AggressiveHeap was set, check if -UseAdaptiveSizePolicy\n-                 * is set after +AggressiveHeap.\n-                 *\/\n-                \/\/\n-                if ((aspi != -1) && (aspi > ahi)) {\n-                    adaptiveSizePolicy = false;\n-                }\n-            } else {\n-                \/*\n-                 * +AggressiveHeap not set, must be +UseParallelGC. The\n-                 * relative position of -UseAdaptiveSizePolicy is not\n-                 * important in this case, as it will override the\n-                 * UseParallelGC default (+UseAdaptiveSizePolicy) if it\n-                 * appears anywhere in the JVM arguments.\n-                 *\/\n-                if (aspi != -1) {\n-                    adaptiveSizePolicy = false;\n-                }\n-            }\n-\n-            if (adaptiveSizePolicy) {\n-                \/\/ adjust the buggy AdaptiveSizePolicy size counters.\n-\n-                \/\/ first remove the real counters.\n-                String eden_size = \"hotspot.gc.generation.0.space.0.size\";\n-                String s0_size = \"hotspot.gc.generation.0.space.1.size\";\n-                String s1_size = \"hotspot.gc.generation.0.space.2.size\";\n-                map.remove(eden_size);\n-                map.remove(s0_size);\n-                map.remove(s1_size);\n-\n-                \/\/ get the maximum new generation size\n-                String new_max_name = \"hotspot.gc.generation.0.capacity.max\";\n-                LongMonitor new_max = (LongMonitor)map.get(new_max_name);\n-\n-                \/*\n-                 * replace the real counters with pseudo counters that are\n-                 * initialized to the correct values. The maximum size of\n-                 * the eden and survivor spaces are supposed to be:\n-                 *    max_eden_size = new_size - (2*alignment).\n-                 *    max_survivor_size = new_size - (2*alignment).\n-                 * since we don't know the alignment value used, and because\n-                 * of other parallel scavenge bugs that result in oversized\n-                 * spaces, we just set the maximum size of each space to the\n-                 * full new gen size.\n-                 *\/\n-                Monitor monitor = null;\n-\n-                LongBuffer lb = LongBuffer.allocate(1);\n-                lb.put(new_max.longValue());\n-                monitor = new PerfLongMonitor(eden_size, Units.BYTES,\n-                                              Variability.CONSTANT, false, lb);\n-                map.put(eden_size, monitor);\n-\n-                monitor = new PerfLongMonitor(s0_size, Units.BYTES,\n-                                              Variability.CONSTANT, false, lb);\n-                map.put(s0_size, monitor);\n-\n-                monitor = new PerfLongMonitor(s1_size, Units.BYTES,\n-                                              Variability.CONSTANT, false, lb);\n-                map.put(s1_size, monitor);\n-            }\n-        }\n-    }\n-\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/v1_0\/PerfDataBuffer.java","additions":1,"deletions":149,"binary":false,"changes":150,"status":"modified"}]}