{"files":[{"patch":"@@ -1726,2 +1726,2 @@\n-void C2_MacroAssembler::compare_v(VectorRegister vd, BasicType bt, int length_in_bytes,\n-                                  VectorRegister src1, VectorRegister src2, int cond, VectorMask vm) {\n+void C2_MacroAssembler::compare_integral_v(VectorRegister vd, BasicType bt, int length_in_bytes,\n+                                           VectorRegister src1, VectorRegister src2, int cond, VectorMask vm) {\n@@ -1730,24 +1730,34 @@\n-  if (bt == T_FLOAT || bt == T_DOUBLE) {\n-    switch (cond) {\n-      case BoolTest::eq: vmfeq_vv(vd, src1, src2, vm); break;\n-      case BoolTest::ne: vmfne_vv(vd, src1, src2, vm); break;\n-      case BoolTest::le: vmfle_vv(vd, src1, src2, vm); break;\n-      case BoolTest::ge: vmfge_vv(vd, src1, src2, vm); break;\n-      case BoolTest::lt: vmflt_vv(vd, src1, src2, vm); break;\n-      case BoolTest::gt: vmfgt_vv(vd, src1, src2, vm); break;\n-      default:\n-        assert(false, \"unsupported compare condition\");\n-        ShouldNotReachHere();\n-    }\n-  } else {\n-    assert(is_integral_type(bt), \"unsupported element type\");\n-    switch (cond) {\n-      case BoolTest::eq: vmseq_vv(vd, src1, src2, vm); break;\n-      case BoolTest::ne: vmsne_vv(vd, src1, src2, vm); break;\n-      case BoolTest::le: vmsle_vv(vd, src1, src2, vm); break;\n-      case BoolTest::ge: vmsge_vv(vd, src1, src2, vm); break;\n-      case BoolTest::lt: vmslt_vv(vd, src1, src2, vm); break;\n-      case BoolTest::gt: vmsgt_vv(vd, src1, src2, vm); break;\n-      default:\n-        assert(false, \"unsupported compare condition\");\n-        ShouldNotReachHere();\n+  assert(is_integral_type(bt), \"unsupported element type\");\n+  switch (cond) {\n+    case BoolTest::eq: vmseq_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ne: vmsne_vv(vd, src1, src2, vm); break;\n+    case BoolTest::le: vmsle_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ge: vmsge_vv(vd, src1, src2, vm); break;\n+    case BoolTest::lt: vmslt_vv(vd, src1, src2, vm); break;\n+    case BoolTest::gt: vmsgt_vv(vd, src1, src2, vm); break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::compare_floating_point_v(VectorRegister vd, BasicType bt, int length_in_bytes,\n+                                                 VectorRegister src1, VectorRegister src2,\n+                                                 VectorRegister tmp1, VectorRegister tmp2, int cond, VectorMask vm) {\n+  rvv_vsetvli(bt, length_in_bytes);\n+  vmxor_mm(vd, vd, vd);\n+  assert(is_floating_point_type(bt), \"unsupported element type\");\n+  \/\/ vmfeq and vmfne raise the invalid operation exception \n+  \/\/ only on signaling NaN inputs.\n+  \/\/ vmflt, vmfle, vmfgt, and vmfge raise the invalid operation \n+  \/\/ exception on both signaling and quiet NaN inputs, so we should \n+  \/\/ mask the signaling compares when either input is NaN \n+  \/\/ to implement floating-point quiet compares.\n+  if (cond == BoolTest::le || cond == BoolTest::ge || cond == BoolTest::lt || cond == BoolTest::gt) {\n+    vmfeq_vv(tmp1, src1, src1);\n+    vmfeq_vv(tmp2, src2, src2);\n+    if (vm == Assembler::v0_t) {\n+      vmand_mm(tmp2, tmp1, tmp2);\n+      vmand_mm(v0, v0, tmp2);\n+    } else {\n+      vmand_mm(v0, tmp1, tmp2);\n@@ -1756,0 +1766,11 @@\n+  switch (cond) {\n+    case BoolTest::eq: vmfeq_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ne: vmfne_vv(vd, src1, src2, vm); break;\n+    case BoolTest::le: vmfle_vv(vd, src1, src2, Assembler::v0_t); break;\n+    case BoolTest::ge: vmfge_vv(vd, src1, src2, Assembler::v0_t); break;\n+    case BoolTest::lt: vmflt_vv(vd, src1, src2, Assembler::v0_t); break;\n+    case BoolTest::gt: vmfgt_vv(vd, src1, src2, Assembler::v0_t); break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":47,"deletions":26,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -203,2 +203,6 @@\n- void compare_v(VectorRegister dst, BasicType bt, int length_in_bytes,\n-                  VectorRegister src1, VectorRegister src2, int cond, VectorMask vm = Assembler::unmasked);\n+ void compare_integral_v(VectorRegister dst, BasicType bt, int length_in_bytes,\n+                         VectorRegister src1, VectorRegister src2, int cond, VectorMask vm = Assembler::unmasked);\n+\n+ void compare_floating_point_v(VectorRegister dst, BasicType bt, int length_in_bytes,\n+                               VectorRegister src1, VectorRegister src2, VectorRegister tmp1, VectorRegister tmp2,\n+                               int cond, VectorMask vm = Assembler::unmasked);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -164,0 +164,4 @@\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -169,2 +173,2 @@\n-    __ compare_v(as_VectorRegister($dst$$reg), bt, length_in_bytes, as_VectorRegister($src1$$reg),\n-                   as_VectorRegister($src2$$reg), (int)($cond$$constant));\n+    __ compare_integral_v(as_VectorRegister($dst$$reg), bt, length_in_bytes, as_VectorRegister($src1$$reg),\n+                          as_VectorRegister($src2$$reg), (int)($cond$$constant));\n@@ -176,0 +180,4 @@\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -182,2 +190,2 @@\n-    __ compare_v(as_VectorRegister($tmp$$reg), bt, length_in_bytes, as_VectorRegister($src1$$reg),\n-                   as_VectorRegister($src2$$reg), (int)($cond$$constant), Assembler::v0_t);\n+    __ compare_integral_v(as_VectorRegister($tmp$$reg), bt, length_in_bytes, as_VectorRegister($src1$$reg),\n+                          as_VectorRegister($src2$$reg), (int)($cond$$constant), Assembler::v0_t);\n@@ -189,0 +197,37 @@\n+\/\/ vector mask float compare\n+\n+instruct vmaskcmp_DF(vRegMask dst, vReg src1, vReg src2, immI cond, vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT ||\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"vmaskcmp_DF $dst, $src1, $src2, $cond\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ compare_floating_point_v(as_VectorRegister($dst$$reg), bt, length_in_bytes,\n+                                as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                                as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                                (int)($cond$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_DF_masked(vRegMask dst, vReg src1, vReg src2, immI cond, vRegMask_V0 vmask, vReg tmp1, vReg tmp2, vReg tmp3) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT ||\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond vmask)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  format %{ \"vmaskcmp_DF_masked $dst, $src1, $src2, $vmask, $tmp1, $tmp2, $tmp3 $cond\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ compare_floating_point_v(as_VectorRegister($tmp1$$reg), bt, length_in_bytes,\n+                                as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                                as_VectorRegister($tmp2$$reg), as_VectorRegister($tmp3$$reg),\n+                                (int)($cond$$constant), Assembler::v0_t);\n+    __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($tmp1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":49,"deletions":4,"binary":false,"changes":53,"status":"modified"}]}