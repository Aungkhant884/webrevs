{"files":[{"patch":"@@ -39,0 +39,9 @@\n+ * @implNote Methods that describe a conversion check among unconditionally exact types\n+ * (they would return true) are ommited. Similarly, methods that describe a conversion check\n+ * which can be redirected through one of the methods in this classes are omitted too. These are the following:\n+ *  - byte to char ~> isIntToCharExact\n+ *  - short to byte ~> isIntToByteExact\n+ *  - short to char ~> isIntToCharExact\n+ *  - char to byte ~> isIntToByteExact\n+ *  - char to short ~> isIntToShortExact\n+ *\n@@ -45,2 +54,2 @@\n-     \/** Exactness method from int to byte\n-     *\n+    \/**\n+     * Exactness method from int to byte\n@@ -49,3 +58,2 @@\n-     *\n-     * *\/\n-    public static boolean intToByteExact(int n)      {return n == (int)(byte)n;}\n+     *\/\n+    public static boolean isIntToByteExact(int n)      {return n == (int)(byte)n;}\n@@ -53,2 +61,2 @@\n-    \/** Exactness method from int to short\n-     *\n+    \/**\n+     * Exactness method from int to short\n@@ -57,3 +65,2 @@\n-     *\n-     * *\/\n-    public static boolean intToShortExact(int n)     {return n == (int)(short)n;}\n+     *\/\n+    public static boolean isIntToShortExact(int n)     {return n == (int)(short)n;}\n@@ -61,2 +68,2 @@\n-    \/** Exactness method from int to char\n-     *\n+    \/**\n+     * Exactness method from int to char\n@@ -65,3 +72,2 @@\n-     *\n-     * *\/\n-    public static boolean intToCharExact(int n)      {return n == (int)(char)n;}\n+     *\/\n+    public static boolean isIntToCharExact(int n)      {return n == (int)(char)n;}\n@@ -69,2 +75,2 @@\n-    \/** Exactness method from int to float\n-     *\n+    \/**\n+     * Exactness method from int to float\n@@ -76,3 +82,2 @@\n-     *\n-     * *\/\n-    public static boolean intToFloatExact(int n) { return n == (int)(float)n && n != Integer.MAX_VALUE; }\n+     *\/\n+    public static boolean isIntToFloatExact(int n) { return n == (int)(float)n && n != Integer.MAX_VALUE; }\n@@ -80,2 +85,2 @@\n-    \/** Exactness method from long to byte\n-     *\n+    \/**\n+     * Exactness method from long to byte\n@@ -84,3 +89,2 @@\n-     *\n-     * *\/\n-    public static boolean longToByteExact(long n)    {return n == (long)(byte)n;}\n+     *\/\n+    public static boolean isLongToByteExact(long n)    {return n == (long)(byte)n;}\n@@ -88,2 +92,2 @@\n-    \/** Exactness method from long to short\n-     *\n+    \/**\n+     * Exactness method from long to short\n@@ -92,3 +96,2 @@\n-     *\n-     * *\/\n-    public static boolean longToShortExact(long n)   {return n == (long)(short)n;}\n+     *\/\n+    public static boolean isLongToShortExact(long n)   {return n == (long)(short)n;}\n@@ -96,2 +99,2 @@\n-    \/** Exactness method from long to char\n-     *\n+    \/**\n+     * Exactness method from long to char\n@@ -100,3 +103,2 @@\n-     *\n-     * *\/\n-    public static boolean longToCharExact(long n)    {return n == (long)(char)n;}\n+     *\/\n+    public static boolean isLongToCharExact(long n)    {return n == (long)(char)n;}\n@@ -104,2 +106,2 @@\n-    \/** Exactness method from long to int\n-     *\n+    \/**\n+     * Exactness method from long to int\n@@ -108,3 +110,2 @@\n-     *\n-     * *\/\n-    public static boolean longToIntExact(long n)     {return n == (long)(int)n;}\n+     *\/\n+    public static boolean isLongToIntExact(long n)     {return n == (long)(int)n;}\n@@ -112,2 +113,2 @@\n-    \/** Exactness method from long to float\n-     *\n+    \/**\n+     * Exactness method from long to float\n@@ -116,1 +117,0 @@\n-     *\n@@ -119,3 +119,2 @@\n-     *\n-     * *\/\n-    public static boolean longToFloatExact(long n) {\n+     *\/\n+    public static boolean isLongToFloatExact(long n) {\n@@ -125,2 +124,2 @@\n-    \/** Exactness method from long to double\n-     *\n+    \/**\n+     * Exactness method from long to double\n@@ -129,1 +128,0 @@\n-     *\n@@ -132,2 +130,2 @@\n-     * *\/\n-    public static boolean longToDoubleExact(long n) {\n+     *\/\n+    public static boolean isLongToDoubleExact(long n) {\n@@ -137,2 +135,2 @@\n-    \/** Exactness method from float to byte\n-     *\n+    \/**\n+     * Exactness method from float to byte\n@@ -141,1 +139,0 @@\n-     *\n@@ -144,3 +141,2 @@\n-     *\n-     * *\/\n-    public static boolean floatToByteExact(float n)  {\n+     *\/\n+    public static boolean isFloatToByteExact(float n)  {\n@@ -150,2 +146,2 @@\n-    \/** Exactness method from float to short\n-     *\n+    \/**\n+     * Exactness method from float to short\n@@ -154,1 +150,0 @@\n-     *\n@@ -157,3 +152,2 @@\n-     *\n-     * *\/\n-    public static boolean floatToShortExact(float n) {\n+     *\/\n+    public static boolean isFloatToShortExact(float n) {\n@@ -163,2 +157,2 @@\n-    \/** Exactness method from float to char\n-     *\n+    \/**\n+     * Exactness method from float to char\n@@ -167,1 +161,0 @@\n-     *\n@@ -170,3 +163,2 @@\n-     *\n-     * *\/\n-    public static boolean floatToCharExact(float n)  {\n+     *\/\n+    public static boolean isFloatToCharExact(float n)  {\n@@ -176,2 +168,2 @@\n-    \/** Exactness method from float to int\n-     *\n+    \/**\n+     * Exactness method from float to int\n@@ -180,1 +172,0 @@\n-     *\n@@ -183,2 +174,2 @@\n-     * *\/\n-    public static boolean floatToIntExact(float n) {\n+     *\/\n+    public static boolean isFloatToIntExact(float n) {\n@@ -188,2 +179,2 @@\n-    \/** Exactness method from float to long\n-     *\n+    \/**\n+     * Exactness method from float to long\n@@ -192,1 +183,0 @@\n-     *\n@@ -195,2 +185,2 @@\n-     * *\/\n-    public static boolean floatToLongExact(float n) {\n+     *\/\n+    public static boolean isFloatToLongExact(float n) {\n@@ -200,2 +190,2 @@\n-    \/** Exactness method from double to byte\n-     *\n+    \/**\n+     * Exactness method from double to byte\n@@ -204,1 +194,0 @@\n-     *\n@@ -207,3 +196,2 @@\n-     *\n-     * *\/\n-    public static boolean doubleToByteExact(double n) {\n+     *\/\n+    public static boolean isDoubleToByteExact(double n) {\n@@ -213,2 +201,2 @@\n-    \/** Exactness method from double to short\n-     *\n+    \/**\n+     * Exactness method from double to short\n@@ -217,1 +205,0 @@\n-     *\n@@ -220,3 +207,2 @@\n-     *\n-     * *\/\n-    public static boolean doubleToShortExact(double n){\n+     *\/\n+    public static boolean isDoubleToShortExact(double n){\n@@ -226,2 +212,2 @@\n-    \/** Exactness method from double to char\n-     *\n+    \/**\n+     * Exactness method from double to char\n@@ -230,1 +216,0 @@\n-     *\n@@ -233,3 +218,2 @@\n-     *\n-     * *\/\n-    public static boolean doubleToCharExact(double n) {\n+     *\/\n+    public static boolean isDoubleToCharExact(double n) {\n@@ -239,2 +223,2 @@\n-    \/** Exactness method from double to int\n-     *\n+    \/**\n+     * Exactness method from double to int\n@@ -243,1 +227,0 @@\n-     *\n@@ -246,3 +229,2 @@\n-     *\n-     * *\/\n-    public static boolean doubleToIntExact(double n)  {\n+     *\/\n+    public static boolean isDoubleToIntExact(double n)  {\n@@ -252,2 +234,2 @@\n-    \/** Exactness method from double to long\n-     *\n+    \/**\n+     * Exactness method from double to long\n@@ -256,1 +238,0 @@\n-     *\n@@ -259,3 +240,2 @@\n-     *\n-     * *\/\n-    public static boolean doubleToLongExact(double n) {\n+     *\/\n+    public static boolean isDoubleToLongExact(double n) {\n@@ -265,2 +245,2 @@\n-    \/** Exactness method from double to float\n-     *\n+    \/**\n+     * Exactness method from double to float\n@@ -269,1 +249,0 @@\n-     *\n@@ -272,3 +251,2 @@\n-     *\n-     * *\/\n-    public static boolean doubleToFloatExact(double n) {\n+     *\/\n+    public static boolean isDoubleToFloatExact(double n) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ExactConversionsSupport.java","additions":93,"deletions":115,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -357,8 +357,5 @@\n-    private static boolean unconditionalExactnessCheck(Object selectorType, Class<?> targetType) {\n-        if ((selectorType.equals(byte.class) && targetType.equals(Byte.class)) ||\n-            (selectorType.equals(char.class) && targetType.equals(Character.class)) ||\n-            (selectorType.equals(long.class) && targetType.equals(Long.class)) ||\n-            (selectorType.equals(double.class) && targetType.equals(Double.class)) ||\n-            (selectorType.equals(float.class) && targetType.equals(Float.class)) ||\n-            (selectorType.equals(short.class) && targetType.equals(Short.class)) ||\n-            (selectorType.equals(int.class) && targetType.equals(Integer.class)))\n+    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.checkUnconditionallyExactPrimitives\n+    private static boolean unconditionalExactnessCheck(Class<?> selectorType, Class<?> targetType) {\n+        Wrapper selectorWrapper = Wrapper.forBasicType(selectorType);\n+        Wrapper targetWrapper   = Wrapper.forBasicType(targetType);\n+        if (selectorType.isPrimitive() && targetType.equals(selectorWrapper.wrapperType())) {\n@@ -366,6 +363,7 @@\n-        else if (selectorType.equals(targetType) || (selectorType.equals(byte.class) && !targetType.equals(char.class)  ||\n-                (selectorType.equals(short.class) && (targetType.equals(int.class)   || targetType.equals(long.class) || targetType.equals(float.class) || targetType.equals(double.class))) ||\n-                (selectorType.equals(char.class)  && (targetType.equals(int.class)   || targetType.equals(long.class) || targetType.equals(float.class) || targetType.equals(double.class))) ||\n-                (selectorType.equals(long.class) && (targetType.equals(long.class))) ||\n-                (selectorType.equals(int.class) && (targetType.equals(double.class)  || targetType.equals(long.class))) ||\n-                (selectorType.equals(float.class) && (targetType.equals(double.class))))) return true;\n+        }\n+        else if (selectorType.equals(targetType) ||\n+                ((selectorType.equals(byte.class) && !targetType.equals(char.class)) ||\n+                 (selectorType.equals(short.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))) ||\n+                 (selectorType.equals(char.class)  && (selectorWrapper.isStrictSubRangeOf(targetWrapper)))  ||\n+                 (selectorType.equals(int.class)   && (targetType.equals(double.class) || targetType.equals(long.class))) ||\n+                 (selectorType.equals(float.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))))) return true;\n@@ -563,26 +561,26 @@\n-            typePairToName.put(new TypePairs(byte.class,   char.class),   \"intToCharExact\");      \/\/ redirected\n-            typePairToName.put(new TypePairs(short.class,  byte.class),   \"intToByteExact\");      \/\/ redirected\n-            typePairToName.put(new TypePairs(short.class,  char.class),   \"intToCharExact\");      \/\/ redirected\n-            typePairToName.put(new TypePairs(char.class,   byte.class),   \"intToByteExact\");      \/\/ redirected\n-            typePairToName.put(new TypePairs(char.class,   short.class),  \"intToShortExact\");     \/\/ redirected\n-            typePairToName.put(new TypePairs(int.class,    byte.class),   \"intToByteExact\");\n-            typePairToName.put(new TypePairs(int.class,    short.class),  \"intToShortExact\");\n-            typePairToName.put(new TypePairs(int.class,    char.class),   \"intToCharExact\");\n-            typePairToName.put(new TypePairs(int.class,    float.class),  \"intToFloatExact\");\n-            typePairToName.put(new TypePairs(long.class,   byte.class),   \"longToByteExact\");\n-            typePairToName.put(new TypePairs(long.class,   short.class),  \"longToShortExact\");\n-            typePairToName.put(new TypePairs(long.class,   char.class),   \"longToCharExact\");\n-            typePairToName.put(new TypePairs(long.class,   int.class),    \"longToIntExact\");\n-            typePairToName.put(new TypePairs(long.class,   float.class),  \"longToFloatExact\");\n-            typePairToName.put(new TypePairs(long.class,   double.class), \"longToDoubleExact\");\n-            typePairToName.put(new TypePairs(float.class,  byte.class),   \"floatToByteExact\");\n-            typePairToName.put(new TypePairs(float.class,  short.class),  \"floatToShortExact\");\n-            typePairToName.put(new TypePairs(float.class,  char.class),   \"floatToCharExact\");\n-            typePairToName.put(new TypePairs(float.class,  int.class),    \"floatToIntExact\");\n-            typePairToName.put(new TypePairs(float.class,  long.class),   \"floatToLongExact\");\n-            typePairToName.put(new TypePairs(double.class, byte.class),   \"doubleToByteExact\");\n-            typePairToName.put(new TypePairs(double.class, short.class),  \"doubleToShortExact\");\n-            typePairToName.put(new TypePairs(double.class, char.class),   \"doubleToCharExact\");\n-            typePairToName.put(new TypePairs(double.class, int.class),    \"doubleToIntExact\");\n-            typePairToName.put(new TypePairs(double.class, long.class),   \"doubleToLongExact\");\n-            typePairToName.put(new TypePairs(double.class, float.class),  \"doubleToFloatExact\");\n+            typePairToName.put(new TypePairs(byte.class,   char.class),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  byte.class),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  char.class),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   byte.class),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   short.class),  \"isIntToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(int.class,    byte.class),   \"isIntToByteExact\");\n+            typePairToName.put(new TypePairs(int.class,    short.class),  \"isIntToShortExact\");\n+            typePairToName.put(new TypePairs(int.class,    char.class),   \"isIntToCharExact\");\n+            typePairToName.put(new TypePairs(int.class,    float.class),  \"isIntToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   byte.class),   \"isLongToByteExact\");\n+            typePairToName.put(new TypePairs(long.class,   short.class),  \"isLongToShortExact\");\n+            typePairToName.put(new TypePairs(long.class,   char.class),   \"isLongToCharExact\");\n+            typePairToName.put(new TypePairs(long.class,   int.class),    \"isLongToIntExact\");\n+            typePairToName.put(new TypePairs(long.class,   float.class),  \"isLongToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   double.class), \"isLongToDoubleExact\");\n+            typePairToName.put(new TypePairs(float.class,  byte.class),   \"isFloatToByteExact\");\n+            typePairToName.put(new TypePairs(float.class,  short.class),  \"isFloatToShortExact\");\n+            typePairToName.put(new TypePairs(float.class,  char.class),   \"isFloatToCharExact\");\n+            typePairToName.put(new TypePairs(float.class,  int.class),    \"isFloatToIntExact\");\n+            typePairToName.put(new TypePairs(float.class,  long.class),   \"isFloatToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, byte.class),   \"isDoubleToByteExact\");\n+            typePairToName.put(new TypePairs(double.class, short.class),  \"isDoubleToShortExact\");\n+            typePairToName.put(new TypePairs(double.class, char.class),   \"isDoubleToCharExact\");\n+            typePairToName.put(new TypePairs(double.class, int.class),    \"isDoubleToIntExact\");\n+            typePairToName.put(new TypePairs(double.class, long.class),   \"isDoubleToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, float.class),  \"isDoubleToFloatExact\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":38,"deletions":40,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Map;\n+import static sun.invoke.util.Wrapper.NumericClasses.*;\n@@ -31,2 +33,2 @@\n-    \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray     format\n-    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1)),\n+    \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray     format               numericClass  superClass\n+    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1), 0, 0),\n@@ -35,8 +37,8 @@\n-    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8)),\n-    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16)),\n-    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16)),\n-    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32)),\n-    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64)),\n-    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32)),\n-    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64)),\n-    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1)),\n+    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8), BYTE_CLASS, BYTE_SUPERCLASSES),\n+    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16), SHORT_CLASS, SHORT_SUPERCLASSES),\n+    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16), CHAR_CLASS, CHAR_SUPERCLASSES),\n+    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32), INT_CLASS, INT_SUPERCLASSES),\n+    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64), LONG_CLASS, LONG_SUPERCLASSES),\n+    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32), FLOAT_CLASS, FLOAT_SUPERCLASSES),\n+    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64), DOUBLE_CLASS, DOUBLE_CLASS),\n+    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1), 0, 0),\n@@ -44,1 +46,1 @@\n-    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0)),\n+    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0), 0, 0),\n@@ -55,0 +57,2 @@\n+    private final int      numericClass;\n+    private final int      superClasses;\n@@ -58,1 +62,1 @@\n-    private Wrapper(Class<?> wtype, String wtypeName, Class<?> ptype, String ptypeName, char tchar, Object emptyArray, int format) {\n+    private Wrapper(Class<?> wtype, String wtypeName, Class<?> ptype, String ptypeName, char tchar, Object emptyArray, int format, int numericClass, int superClasses) {\n@@ -65,0 +69,2 @@\n+        this.numericClass = numericClass;\n+        this.superClasses = superClasses;\n@@ -631,0 +637,30 @@\n+\n+    \/\/ NumericClasses should be in sync with com.sun.tools.javac.code.TypeTag.NumericClasses\n+    public static class NumericClasses {\n+        public static final int BYTE_CLASS = 1;\n+        public static final int CHAR_CLASS = 2;\n+        public static final int SHORT_CLASS = 4;\n+        public static final int INT_CLASS = 8;\n+        public static final int LONG_CLASS = 16;\n+        public static final int FLOAT_CLASS = 32;\n+        public static final int DOUBLE_CLASS = 64;\n+\n+        static final int BYTE_SUPERCLASSES = BYTE_CLASS | SHORT_CLASS | INT_CLASS |\n+                LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int CHAR_SUPERCLASSES = CHAR_CLASS | INT_CLASS |\n+                LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int SHORT_SUPERCLASSES = SHORT_CLASS | INT_CLASS |\n+                LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int INT_SUPERCLASSES = INT_CLASS | LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int LONG_SUPERCLASSES = LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int FLOAT_SUPERCLASSES = FLOAT_CLASS | DOUBLE_CLASS;\n+    }\n+\n+    public boolean isStrictSubRangeOf(Wrapper target) {\n+        return (this.superClasses & target.numericClass) != 0 && this != target;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":48,"deletions":12,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -5045,2 +5045,2 @@\n-     *  @param source     Source primitive type\n-     *  @param target     Target primitive type\n+     *  @param selectorType     Type of selector\n+     *  @param targetType       Target type\n@@ -5048,2 +5048,2 @@\n-    public boolean checkUnconditionallyExactPrimitives(Type source, Type target) {\n-        if (isSameType(source, target)) {\n+    public boolean checkUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n+        if (isSameType(selectorType, targetType)) {\n@@ -5053,7 +5053,6 @@\n-        return (source.isPrimitive() && target.isPrimitive()) &&\n-                ((source.hasTag(BYTE) && !target.hasTag(CHAR) ||\n-                        (source.hasTag(SHORT) && (target.hasTag(INT) || target.hasTag(LONG) || target.hasTag(FLOAT) || target.hasTag(DOUBLE)))||\n-                        (source.hasTag(CHAR)  && (target.hasTag(INT) || target.hasTag(LONG) || target.hasTag(FLOAT) || target.hasTag(DOUBLE))) ||\n-                        (source.hasTag(LONG) && (target.hasTag(LONG))) ||\n-                        (source.hasTag(INT) && (target.hasTag(DOUBLE) || target.hasTag(LONG))) ||\n-                        (source.hasTag(FLOAT) && (target.hasTag(DOUBLE)))));\n+        return (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n+                ((selectorType.hasTag(BYTE) && !targetType.hasTag(CHAR)) ||\n+                 (selectorType.hasTag(SHORT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))) ||\n+                 (selectorType.hasTag(CHAR)  && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag())))  ||\n+                 (selectorType.hasTag(INT)   && (targetType.hasTag(DOUBLE) || targetType.hasTag(LONG))) ||\n+                 (selectorType.hasTag(FLOAT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2910,0 +2910,40 @@\n+    \/**\n+     * All the exactness checks between primitive types that require a run-time check\n+     * are in `java.lang.runtime.ExactConversionsSupport`. Those methods are in the\n+     * form `ExactConversionsSupport.<S>_<T>` where both `S` and `T` are primitive\n+     * types and correspond to the runtime check that will be executed when the program\n+     * needs to check whether a certain value (that is passed as a parameter) can be\n+     * converted to T without loss of information.\n+     * Rewrite instanceof if expr : Object and Type is primitive type\n+     *\n+     * According to the Table 5.5-A. Casting conversions to primitive types in the JLS this\n+     * conversion is permitted under a casting context, and employs a narrowing reference conversion\n+     * followed by an unboxing conversion. As a result the only check that needs to be done is an\n+     * `instanceof` to `Float`. The unboxing conversion from `Float` to `float` is always exact\n+     * so if `v` is `Float` then `v` will be `instanceof float` too (without further checks).\n+     *\n+     *   Object v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (v instanceof Float)\n+     *\n+     * Rewrite instanceof if expr : wrapper reference type\n+     *\n+     *   Integer v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; tmp$123 != null && ExactConversionsSupport.intToFloatExact(tmp$123.intValue()))\n+     *\n+     * Rewrite instanceof if expr : primitive\n+     *\n+     *   int v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; ExactConversionsSupport.intToFloatExact(tmp$123))\n+     *\n+     * More rewritings:\n+     *\n+     * - If the `instanceof` check is unconditionally exact rewrite to true.\n+     * - If expression type is `Byte`, `Short`, `Integer`, an unboxing conversion followed by a widening primitive conversion.\n+     * - If expression type is a supertype: `Number`, a narrowing reference conversion followed by an unboxing conversion\n+     *\/\n@@ -2992,26 +3032,26 @@\n-            typePairToName.put(new TypePairs(syms.byteType,   syms.charType),   \"intToCharExact\");      \/\/ redirected\n-            typePairToName.put(new TypePairs(syms.shortType,  syms.byteType),   \"intToByteExact\");      \/\/ redirected\n-            typePairToName.put(new TypePairs(syms.shortType,  syms.charType),   \"intToCharExact\");      \/\/ redirected\n-            typePairToName.put(new TypePairs(syms.charType,   syms.byteType),   \"intToByteExact\");      \/\/ redirected\n-            typePairToName.put(new TypePairs(syms.charType,   syms.shortType),  \"intToShortExact\");     \/\/ redirected\n-            typePairToName.put(new TypePairs(syms.intType,    syms.byteType),   \"intToByteExact\");\n-            typePairToName.put(new TypePairs(syms.intType,    syms.shortType),  \"intToShortExact\");\n-            typePairToName.put(new TypePairs(syms.intType,    syms.charType),   \"intToCharExact\");\n-            typePairToName.put(new TypePairs(syms.intType,    syms.floatType),  \"intToFloatExact\");\n-            typePairToName.put(new TypePairs(syms.longType,   syms.byteType),   \"longToByteExact\");\n-            typePairToName.put(new TypePairs(syms.longType,   syms.shortType),  \"longToShortExact\");\n-            typePairToName.put(new TypePairs(syms.longType,   syms.charType),   \"longToCharExact\");\n-            typePairToName.put(new TypePairs(syms.longType,   syms.intType),    \"longToIntExact\");\n-            typePairToName.put(new TypePairs(syms.longType,   syms.floatType),  \"longToFloatExact\");\n-            typePairToName.put(new TypePairs(syms.longType,   syms.doubleType), \"longToDoubleExact\");\n-            typePairToName.put(new TypePairs(syms.floatType,  syms.byteType),   \"floatToByteExact\");\n-            typePairToName.put(new TypePairs(syms.floatType,  syms.shortType),  \"floatToShortExact\");\n-            typePairToName.put(new TypePairs(syms.floatType,  syms.charType),   \"floatToCharExact\");\n-            typePairToName.put(new TypePairs(syms.floatType,  syms.intType),    \"floatToIntExact\");\n-            typePairToName.put(new TypePairs(syms.floatType,  syms.longType),   \"floatToLongExact\");\n-            typePairToName.put(new TypePairs(syms.doubleType, syms.byteType),   \"doubleToByteExact\");\n-            typePairToName.put(new TypePairs(syms.doubleType, syms.shortType),  \"doubleToShortExact\");\n-            typePairToName.put(new TypePairs(syms.doubleType, syms.charType),   \"doubleToCharExact\");\n-            typePairToName.put(new TypePairs(syms.doubleType, syms.intType),    \"doubleToIntExact\");\n-            typePairToName.put(new TypePairs(syms.doubleType, syms.longType),   \"doubleToLongExact\");\n-            typePairToName.put(new TypePairs(syms.doubleType, syms.floatType),  \"doubleToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.byteType,   syms.charType),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.byteType),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.charType),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.byteType),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.shortType),  \"isIntToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.intType,    syms.byteType),   \"isIntToByteExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.shortType),  \"isIntToShortExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.charType),   \"isIntToCharExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.floatType),  \"isIntToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.byteType),   \"isLongToByteExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.shortType),  \"isLongToShortExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.charType),   \"isLongToCharExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.intType),    \"isLongToIntExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.floatType),  \"isLongToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.doubleType), \"isLongToDoubleExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.byteType),   \"isFloatToByteExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.shortType),  \"isFloatToShortExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.charType),   \"isFloatToCharExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.intType),    \"isFloatToIntExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.longType),   \"isFloatToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.byteType),   \"isDoubleToByteExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.shortType),  \"isDoubleToShortExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.charType),   \"isDoubleToCharExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.intType),    \"isDoubleToIntExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.longType),   \"isDoubleToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.floatType),  \"isDoubleToFloatExact\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":66,"deletions":26,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsComboTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}