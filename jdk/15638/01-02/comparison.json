{"files":[{"patch":"@@ -39,40 +39,0 @@\n-    \/** Exactness method from byte to char\n-     *\n-     * @param n value\n-     * @return  true if the passed value can be converted exactly to the target type\n-     *\n-     * *\/\n-    public static boolean byte_char(byte n)    {return n == (char) n;}\n-\n-    \/** Exactness method from short to byte\n-     *\n-     * @param n value\n-     * @return  true if the passed value can be converted exactly to the target type\n-     *\n-     * *\/\n-    public static boolean short_byte(short n)  {return n == (short)(byte)(n);}\n-\n-    \/** Exactness method from short to char\n-     *\n-     * @param n value\n-     * @return  true if the passed value can be converted exactly to the target type\n-     *\n-     * *\/\n-    public static boolean short_char(short n)  {return n == (char)(n);}\n-\n-    \/** Exactness method from char to byte\n-     *\n-     * @param n value\n-     * @return  true if the passed value can be converted exactly to the target type\n-     *\n-     * *\/\n-    public static boolean char_byte(char n)    {return n == (byte)(n);}\n-\n-    \/** Exactness method from char to short\n-     *\n-     * @param n value\n-     * @return  true if the passed value can be converted exactly to the target type\n-     *\n-     * *\/\n-    public static boolean char_short(char n)   {return n == (short)(n);}\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ExactnessMethods.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.HashMap;\n@@ -70,0 +71,1 @@\n+    private static final HashMap<TypePairs, String> typePairToName;\n@@ -72,0 +74,1 @@\n+        typePairToName = TypePairs.initialize();\n@@ -246,3 +249,4 @@\n-                                String methodName = selectorType.toString().substring(selectorType.toString().lastIndexOf(\".\") + 1) + \"_\" + currentLabelClass;\n-                                MethodType methodType = MethodType.methodType(boolean.class, selectorType);\n-                                exactnessCheck = lookup.findStatic(ExactnessMethods.class, methodName, methodType);\n+                                TypePairs typePair = TypePairs.of(selectorType, currentLabelClass);\n+                                String methodName = typePairToName.get(typePair);\n+                                MethodType methodType = MethodType.methodType(boolean.class, typePair.from);\n+                                exactnessCheck = lookup.findStatic(ExactnessMethods.class, methodName, methodType).asType(MethodType.methodType(boolean.class, selectorType));\n@@ -562,0 +566,64 @@\n+\n+    static class TypePairs {\n+        public Class<?> from, to;\n+\n+        public static TypePairs of(Class<?> from,  Class<?> to) {\n+            if (from == byte.class || from == short.class || from == char.class) {\n+                from = int.class;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        private TypePairs(Class<?> from,  Class<?> to) {\n+            this.from = from;\n+            this.to = to;\n+        }\n+\n+        public static HashMap<TypePairs, String> initialize() {\n+            HashMap<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(byte.class,   char.class),   \"int_char\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  byte.class),   \"int_byte\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  char.class),   \"int_char\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   byte.class),   \"int_byte\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   short.class),  \"int_short\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(int.class,    byte.class),   \"int_byte\");\n+            typePairToName.put(new TypePairs(int.class,    short.class),  \"int_short\");\n+            typePairToName.put(new TypePairs(int.class,    char.class),   \"int_char\");\n+            typePairToName.put(new TypePairs(int.class,    float.class),  \"int_float\");\n+            typePairToName.put(new TypePairs(long.class,   byte.class),   \"long_byte\");\n+            typePairToName.put(new TypePairs(long.class,   short.class),  \"long_short\");\n+            typePairToName.put(new TypePairs(long.class,   char.class),   \"long_char\");\n+            typePairToName.put(new TypePairs(long.class,   int.class),    \"long_int\");\n+            typePairToName.put(new TypePairs(long.class,   float.class),  \"long_float\");\n+            typePairToName.put(new TypePairs(long.class,   double.class), \"long_double\");\n+            typePairToName.put(new TypePairs(float.class,  byte.class),   \"float_byte\");\n+            typePairToName.put(new TypePairs(float.class,  short.class),  \"float_short\");\n+            typePairToName.put(new TypePairs(float.class,  char.class),   \"float_char\");\n+            typePairToName.put(new TypePairs(float.class,  int.class),    \"float_int\");\n+            typePairToName.put(new TypePairs(float.class,  long.class),   \"float_long\");\n+            typePairToName.put(new TypePairs(double.class, byte.class),   \"double_byte\");\n+            typePairToName.put(new TypePairs(double.class, short.class),  \"double_short\");\n+            typePairToName.put(new TypePairs(double.class, char.class),   \"double_char\");\n+            typePairToName.put(new TypePairs(double.class, int.class),    \"double_int\");\n+            typePairToName.put(new TypePairs(double.class, long.class),   \"double_long\");\n+            typePairToName.put(new TypePairs(double.class, float.class),  \"double_float\");\n+            return typePairToName;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int code = 0;\n+            code += from.hashCode();\n+            code += to.hashCode();\n+            return code;\n+        }\n+\n+        @Override\n+        public boolean equals(Object testName) {\n+            if ((!(testName instanceof TypePairs testNameAsName))) return false;\n+            else {\n+                return this.from.equals(testNameAsName.from) &&\n+                        this.to.equals(testNameAsName.to);\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":71,"deletions":3,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+    private final HashMap<TypePairs, String> typePairToName;\n@@ -137,0 +138,1 @@\n+        typePairToName = TypePairs.initialize(syms);\n@@ -2999,0 +3001,64 @@\n+    static class TypePairs {\n+        public Type from, to;\n+\n+        public static TypePairs of(Symtab syms, Type from, Type to) {\n+            if (from == syms.byteType || from == syms.shortType || from == syms.charType) {\n+                from = syms.intType;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        private TypePairs(Type from, Type to) {\n+            this.from = from;\n+            this.to = to;\n+        }\n+\n+        public static HashMap<TypePairs, String> initialize(Symtab syms) {\n+            HashMap<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(syms.byteType,   syms.charType),   \"int_char\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.byteType),   \"int_byte\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.charType),   \"int_char\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.byteType),   \"int_byte\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.shortType),  \"int_short\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.intType,    syms.byteType),   \"int_byte\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.shortType),  \"int_short\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.charType),   \"int_char\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.floatType),  \"int_float\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.byteType),   \"long_byte\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.shortType),  \"long_short\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.charType),   \"long_char\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.intType),    \"long_int\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.floatType),  \"long_float\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.doubleType), \"long_double\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.byteType),   \"float_byte\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.shortType),  \"float_short\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.charType),   \"float_char\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.intType),    \"float_int\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.longType),   \"float_long\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.byteType),   \"double_byte\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.shortType),  \"double_short\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.charType),   \"double_char\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.intType),    \"double_int\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.longType),   \"double_long\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.floatType),  \"double_float\");\n+            return typePairToName;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int code = 0;\n+            code += from.tsym.hashCode();\n+            code += to.tsym.hashCode();\n+            return code;\n+        }\n+\n+        @Override\n+        public boolean equals(Object testName) {\n+            if ((!(testName instanceof TypePairs testNameAsName))) return false;\n+            else {\n+                return this.from.tsym.equals(testNameAsName.from.tsym) &&\n+                        this.to.tsym.equals(testNameAsName.to.tsym);\n+            }\n+        }\n+    }\n+\n@@ -3000,1 +3066,3 @@\n-        Name exactnessFunction = names.fromString(types.unboxedTypeOrType(tree.expr.type).tsym.name.toString() + \"_\"+ tree.pattern.type.toString());\n+        TypePairs pair = TypePairs.of(syms, types.unboxedTypeOrType(tree.expr.type), tree.pattern.type);\n+\n+        Name exactnessFunction = names.fromString(typePairToName.get(pair));\n@@ -3007,1 +3075,1 @@\n-                List.of(tree.expr.type),\n+                List.of(pair.from),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":70,"deletions":2,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+        assertEquals(1,  primitiveSwitchUnconditionallyExact(Byte.MAX_VALUE));\n@@ -85,0 +86,4 @@\n+        assertEquals(1, switchRedirectedExactnessMethods1('a'));\n+        assertEquals(-1, switchRedirectedExactnessMethods1('\\u03A9'));\n+        assertEquals(1, switchRedirectedExactnessMethods2('\\u03A9'));\n+        assertEquals(-1, switchRedirectedExactnessMethods2('\\uFFFF'));\n@@ -141,0 +146,6 @@\n+    public static int primitiveSwitchUnconditionallyExact(byte c) {\n+        return switch (c) {\n+            case short _ -> 1;\n+        };\n+    }\n+\n@@ -381,0 +392,24 @@\n+    \/\/ tests that Exactness.char_byte is properly redirected to int_byte\n+    public static int switchRedirectedExactnessMethods1(char c) {\n+        return switch (c) {\n+            case byte _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.char_short is properly redirected to int_short\n+    public static int switchRedirectedExactnessMethods2(char c) {\n+        return switch (c) {\n+            case short _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.short_byte is properly redirected to int_byte\n+    public static int switchRedirectedExactnessMethods2(short c) {\n+        return switch (c) {\n+            case byte _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatterns.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"}]}