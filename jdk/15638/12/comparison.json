{"files":[{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.runtime;\n+\n+\/**\n+ * Exactness methods to test whether a conversion between types would be\n+ * exact when not enough static information is present. These methods may\n+ * be used, for example, by Java compiler implementations to implement checks\n+ * for instanceof and pattern matching runtime implementations.\n+ *\n+ * @since 22\n+ *\/\n+public final class ExactnessMethods {\n+\n+    private ExactnessMethods() { }\n+\n+     \/** Exactness method from int to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean intToByteExact(int n)      {return n == (int)(byte)n;}\n+\n+    \/** Exactness method from int to short\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean intToShortExact(int n)     {return n == (int)(short)n;}\n+\n+    \/** Exactness method from int to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean intToCharExact(int n)      {return n == (int)(char)n;}\n+\n+    \/** Exactness method from int to float\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean intToFloatExact(int n) { return n == (int)(float)n && n != Integer.MAX_VALUE; }\n+\n+    \/** Exactness method from long to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean longToByteExact(long n)    {return n == (long)(byte)n;}\n+\n+    \/** Exactness method from long to short\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean longToShortExact(long n)   {return n == (long)(short)n;}\n+\n+    \/** Exactness method from long to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean longToCharExact(long n)    {return n == (long)(char)n;}\n+\n+    \/** Exactness method from long to int\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean longToIntExact(long n)     {return n == (long)(int)n;}\n+\n+    \/** Exactness method from long to float\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean longToFloatExact(long n) {\n+        return n == (long)(float)n && n != Long.MAX_VALUE;\n+    }\n+\n+    \/** Exactness method from long to double\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean longToDoubleExact(long n) {\n+        return n == (long)(double)n && n != Long.MAX_VALUE;\n+    }\n+\n+    \/** Exactness method from float to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean floatToByteExact(float n)  {\n+        return n == (float)(byte)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from float to short\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean floatToShortExact(float n) {\n+        return n == (float)(short)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from float to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean floatToCharExact(float n)  {\n+        return n == (float)(char)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from float to int\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean floatToIntExact(float n) {\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from float to long\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean floatToLongExact(float n) {\n+        return n == (float)(long)n && n != 0x1p63f && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to byte\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean doubleToByteExact(double n) {\n+        return n == (double)(byte)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to short\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean doubleToShortExact(double n){\n+        return n == (double)(short)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to char\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean doubleToCharExact(double n) {\n+        return n == (double)(char)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to int\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean doubleToIntExact(double n)  {\n+        return n == (double)(int)n && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to long\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean doubleToLongExact(double n) {\n+        return n == (double)(long)n && n != 0x1p63 && !isNegativeZero(n);\n+    }\n+\n+    \/** Exactness method from double to float\n+     *\n+     * @param n value\n+     * @return  true if the passed value can be converted exactly to the target type\n+     *\n+     * *\/\n+    public static boolean doubleToFloatExact(double n) {\n+        return n == (double)(float)n || n != n;\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+\n+    private static boolean isNegativeZero(double n) {\n+        return Double.doubleToRawLongBits(n) == Long.MIN_VALUE;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ExactnessMethods.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -34,0 +34,2 @@\n+import java.util.Arrays;\n+import java.util.HashMap;\n@@ -39,0 +41,1 @@\n+import sun.invoke.util.Wrapper;\n@@ -58,0 +61,1 @@\n+    private static final MethodHandle IS_ASSIGNABLE_FROM_CHECK;\n@@ -59,0 +63,3 @@\n+    private static final MethodHandle FLOAT_EQ_CHECK;\n+    private static final MethodHandle DOUBLE_EQ_CHECK;\n+    private static final MethodHandle BOOLEAN_EQ_CHECK;\n@@ -65,0 +72,1 @@\n+    private static final HashMap<TypePairs, String> typePairToName;\n@@ -67,0 +75,1 @@\n+        typePairToName = TypePairs.initialize();\n@@ -71,0 +80,3 @@\n+            IS_ASSIGNABLE_FROM_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, \"isAssignableFrom\",\n+                                                                                 MethodType.methodType(boolean.class, Class.class)),\n+                                                              MethodType.methodType(boolean.class, Class.class, Class.class), 1, 0);\n@@ -73,0 +85,6 @@\n+            FLOAT_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"floatEqCheck\",\n+                    MethodType.methodType(boolean.class, float.class, Float.class));\n+            DOUBLE_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"doubleEqCheck\",\n+                    MethodType.methodType(boolean.class, double.class, Double.class));\n+            BOOLEAN_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"booleanEqCheck\",\n+                    MethodType.methodType(boolean.class, boolean.class, Boolean.class));\n@@ -150,1 +168,0 @@\n-            || invocationType.parameterType(0).isPrimitive()\n@@ -158,1 +175,7 @@\n-        MethodHandle target = createMethodHandleSwitch(lookup, labels);\n+        MethodHandle target;\n+        if (invocationType.parameterType(0).isPrimitive()) {\n+            target = createMethodHandleSwitch(lookup, labels, invocationType.parameterType(0));\n+        }\n+        else {\n+            target = createMethodHandleSwitch(lookup, labels, Object.class);\n+        }\n@@ -171,0 +194,3 @@\n+            labelClass != Float.class &&\n+            labelClass != Double.class &&\n+            labelClass != Boolean.class &&\n@@ -184,2 +210,2 @@\n-    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n+    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels, Class<?> selectorType) {\n+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, selectorType);\n@@ -188,1 +214,2 @@\n-\n+        \/\/ unconditionally exact patterns always match\n+        MethodHandle trueDef = MethodHandles.dropArguments(MethodHandles.constant(boolean.class, true), 0, selectorType, Object.class);\n@@ -193,1 +220,0 @@\n-\n@@ -196,0 +222,1 @@\n+                Object testLabel = currentLabel;\n@@ -198,5 +225,46 @@\n-                if (currentLabel instanceof Class<?>) {\n-                    currentTest = INSTANCEOF_CHECK;\n-                } else if (currentLabel instanceof Integer) {\n-                    currentTest = INTEGER_EQ_CHECK;\n-                } else if (currentLabel instanceof EnumDesc) {\n+                if (currentLabel instanceof Class<?> currentLabelClass) {\n+                    if (unconditionalExactnessCheck(selectorType, currentLabelClass)) {\n+                        currentTest = trueDef;\n+                    } else if (currentLabelClass.isPrimitive()) {\n+                         if (selectorType.equals(Object.class)) {\n+                            currentTest = INSTANCEOF_CHECK;\n+                            testLabel = Wrapper.forBasicType(currentLabelClass).wrapperType();\n+                        } else {\n+                            MethodHandle exactnessCheck;\n+                            try {\n+                                TypePairs typePair = TypePairs.of(selectorType, currentLabelClass);\n+                                String methodName = typePairToName.get(typePair);\n+                                MethodType methodType = MethodType.methodType(boolean.class, typePair.from);\n+                                exactnessCheck = lookup.findStatic(ExactnessMethods.class, methodName, methodType).asType(MethodType.methodType(boolean.class, selectorType));\n+                            }\n+                            catch (ReflectiveOperationException e) {\n+                                throw new ExceptionInInitializerError(e);\n+                            }\n+                            currentTest = MethodHandles.dropArguments(exactnessCheck, 1, Object.class);\n+                        }\n+                    } else if (selectorType.isPrimitive()) {\n+                        currentTest = IS_ASSIGNABLE_FROM_CHECK;\n+                        currentTest = MethodHandles.dropArguments(currentTest, 0, selectorType);\n+                        currentTest = MethodHandles.insertArguments(currentTest, 1, Class.class);\n+                        testLabel = currentLabelClass;\n+                    } else {\n+                        currentTest = INSTANCEOF_CHECK;\n+                    }\n+                } else if (currentLabel instanceof Integer ii) {\n+                    if (selectorType.equals(boolean.class)) {\n+                        testLabel = ii.intValue() == 1;\n+                        currentTest = BOOLEAN_EQ_CHECK;\n+                    } else {\n+                        currentTest = INTEGER_EQ_CHECK;\n+                    }\n+                }\n+                else if (selectorType.isPrimitive() && currentLabel instanceof Float) {\n+                    currentTest = FLOAT_EQ_CHECK;\n+                }\n+                else if (selectorType.isPrimitive() && currentLabel instanceof Double) {\n+                    currentTest = DOUBLE_EQ_CHECK;\n+                }\n+                else if (selectorType.isPrimitive() && currentLabel instanceof Boolean) {\n+                    currentTest = BOOLEAN_EQ_CHECK;\n+                }\n+                else if (currentLabel instanceof EnumDesc) {\n@@ -204,0 +272,2 @@\n+                    currentTest = MethodHandles.explicitCastArguments(currentTest,\n+                            MethodType.methodType(boolean.class, selectorType, EnumDesc.class));\n@@ -207,2 +277,2 @@\n-                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),\n-                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),\n+                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, testLabel),\n+                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, selectorType),\n@@ -222,1 +292,5 @@\n-    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n+    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels, Class<?> selectorType) {\n+        if (!selectorType.isPrimitive() && !selectorType.isEnum()) {\n+            selectorType = Object.class;\n+        }\n+\n@@ -224,1 +298,1 @@\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0,  selectorType);\n@@ -226,1 +300,1 @@\n-            mainTest = createRepeatIndexSwitch(lookup, labels);\n+            mainTest = createRepeatIndexSwitch(lookup, labels, selectorType);\n@@ -230,4 +304,12 @@\n-        MethodHandle body =\n-                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n-                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n-                                            mainTest);\n+\n+        MethodHandle body;\n+        if (!selectorType.isPrimitive()) {\n+            var castedNullCheckMT = MethodHandles.explicitCastArguments(NULL_CHECK,\n+                    MethodType.methodType(boolean.class, selectorType));\n+            body = MethodHandles.guardWithTest(MethodHandles.dropArguments(castedNullCheckMT, 0, int.class),\n+                    MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, selectorType),\n+                    mainTest);\n+        } else {\n+            body = mainTest;\n+        }\n+\n@@ -235,1 +317,1 @@\n-                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n+                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, selectorType, int.class), 1, 0);\n@@ -239,0 +321,21 @@\n+    private static boolean floatEqCheck(float value, Float constant) {\n+        if (Float.valueOf(value).equals(constant.floatValue())) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static boolean doubleEqCheck(double value, Double constant) {\n+        if (Double.valueOf(value).equals(constant.doubleValue())) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static boolean booleanEqCheck(boolean value, Boolean constant) {\n+        if (Boolean.valueOf(value).equals(constant.booleanValue())) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n@@ -245,1 +348,3 @@\n-\n+        else if (value instanceof Boolean input && constant.intValue() == (input.booleanValue() ? 1 : 0)) {\n+            return true;\n+        }\n@@ -253,0 +358,18 @@\n+    private static boolean unconditionalExactnessCheck(Object selectorType, Class<?> targetType) {\n+        if ((selectorType.equals(byte.class) && targetType.equals(Byte.class)) ||\n+            (selectorType.equals(char.class) && targetType.equals(Character.class)) ||\n+            (selectorType.equals(long.class) && targetType.equals(Long.class)) ||\n+            (selectorType.equals(double.class) && targetType.equals(Double.class)) ||\n+            (selectorType.equals(float.class) && targetType.equals(Float.class)) ||\n+            (selectorType.equals(short.class) && targetType.equals(Short.class)) ||\n+            (selectorType.equals(int.class) && targetType.equals(Integer.class)))\n+            return true;\n+        else if (selectorType.equals(targetType) || (selectorType.equals(byte.class) && !targetType.equals(char.class)  ||\n+                (selectorType.equals(short.class) && (targetType.equals(int.class)   || targetType.equals(long.class) || targetType.equals(float.class) || targetType.equals(double.class))) ||\n+                (selectorType.equals(char.class)  && (targetType.equals(int.class)   || targetType.equals(long.class) || targetType.equals(float.class) || targetType.equals(double.class))) ||\n+                (selectorType.equals(long.class) && (targetType.equals(long.class))) ||\n+                (selectorType.equals(int.class) && (targetType.equals(double.class)  || targetType.equals(long.class))) ||\n+                (selectorType.equals(float.class) && (targetType.equals(double.class))))) return true;\n+        return false;\n+    }\n+\n@@ -338,1 +461,1 @@\n-                                                                            createRepeatIndexSwitch(lookup, labels),\n+                                                                            createRepeatIndexSwitch(lookup, labels, invocationType.parameterType(0)),\n@@ -342,1 +465,1 @@\n-            target = createMethodHandleSwitch(lookup, labels);\n+            target = createMethodHandleSwitch(lookup, labels, invocationType.parameterType(0));\n@@ -429,0 +552,41 @@\n+\n+    \/\/ TypePairs should be in sync with the corresponding record in Lower\n+    record TypePairs(Class<?> from, Class<?> to) {\n+        public static TypePairs of(Class<?> from,  Class<?> to) {\n+            if (from == byte.class || from == short.class || from == char.class) {\n+                from = int.class;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        public static HashMap<TypePairs, String> initialize() {\n+            HashMap<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(byte.class,   char.class),   \"intToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  byte.class),   \"intToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  char.class),   \"intToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   byte.class),   \"intToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   short.class),  \"intToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(int.class,    byte.class),   \"intToByteExact\");\n+            typePairToName.put(new TypePairs(int.class,    short.class),  \"intToShortExact\");\n+            typePairToName.put(new TypePairs(int.class,    char.class),   \"intToCharExact\");\n+            typePairToName.put(new TypePairs(int.class,    float.class),  \"intToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   byte.class),   \"longToByteExact\");\n+            typePairToName.put(new TypePairs(long.class,   short.class),  \"longToShortExact\");\n+            typePairToName.put(new TypePairs(long.class,   char.class),   \"longToCharExact\");\n+            typePairToName.put(new TypePairs(long.class,   int.class),    \"longToIntExact\");\n+            typePairToName.put(new TypePairs(long.class,   float.class),  \"longToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   double.class), \"longToDoubleExact\");\n+            typePairToName.put(new TypePairs(float.class,  byte.class),   \"floatToByteExact\");\n+            typePairToName.put(new TypePairs(float.class,  short.class),  \"floatToShortExact\");\n+            typePairToName.put(new TypePairs(float.class,  char.class),   \"floatToCharExact\");\n+            typePairToName.put(new TypePairs(float.class,  int.class),    \"floatToIntExact\");\n+            typePairToName.put(new TypePairs(float.class,  long.class),   \"floatToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, byte.class),   \"doubleToByteExact\");\n+            typePairToName.put(new TypePairs(double.class, short.class),  \"doubleToShortExact\");\n+            typePairToName.put(new TypePairs(double.class, char.class),   \"doubleToCharExact\");\n+            typePairToName.put(new TypePairs(double.class, int.class),    \"doubleToIntExact\");\n+            typePairToName.put(new TypePairs(double.class, long.class),   \"doubleToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, float.class),  \"doubleToFloatExact\");\n+            return typePairToName;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":188,"deletions":24,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -215,0 +215,1 @@\n+            case PRIMITIVE_PATTERNS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+        PRIMITIVE_PATTERNS(JDK22, Fragments.FeaturePrimitivePatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+    public final Type exactnessMethodsType;\n@@ -548,0 +549,1 @@\n+        exactnessMethodsType = enterClass(\"java.lang.runtime.ExactnessMethods\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5012,0 +5012,50 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n+    \/** Check unconditionality between any combination of reference or primitive types.\n+     *\n+     *  Rules:\n+     *    an identity conversion\n+     *    a widening reference conversion\n+     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n+     *    a boxing conversion\n+     *    a boxing conversion followed by a widening reference conversion\n+     *\n+     *  @param source     Source primitive or reference type\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean checkUnconditionallyExact(Type source, Type target) {\n+        if (isSameType(source, target)) {\n+            return true;\n+        }\n+\n+        if (target.isPrimitive()) {\n+            return (source.isReference() && isSubtype(source, target)) ||\n+                    checkUnconditionallyExactPrimitives(source, target);\n+        } else {\n+            return isSubtype(boxedTypeOrType(erasure(source)), target);\n+        }\n+    }\n+\n+    \/** Check unconditionality between primitive types.\n+     *\n+     *  - widening from one integral type to another,\n+     *  - widening from one floating point type to another,\n+     *  - widening from byte, short, or char to a floating point type,\n+     *  - widening from int to double.\n+     *\n+     *  @param source     Source primitive type\n+     *  @param target     Target primitive type\n+     *\/\n+    public boolean checkUnconditionallyExactPrimitives(Type source, Type target) {\n+        if (isSameType(source, target)) {\n+            return true;\n+        }\n+\n+        return (source.isPrimitive() && target.isPrimitive()) &&\n+                ((source.hasTag(BYTE) && !target.hasTag(CHAR) ||\n+                        (source.hasTag(SHORT) && (target.hasTag(INT) || target.hasTag(LONG) || target.hasTag(FLOAT) || target.hasTag(DOUBLE)))||\n+                        (source.hasTag(CHAR)  && (target.hasTag(INT) || target.hasTag(LONG) || target.hasTag(FLOAT) || target.hasTag(DOUBLE))) ||\n+                        (source.hasTag(LONG) && (target.hasTag(LONG))) ||\n+                        (source.hasTag(INT) && (target.hasTag(DOUBLE) || target.hasTag(LONG))) ||\n+                        (source.hasTag(FLOAT) && (target.hasTag(DOUBLE)))));\n+    }\n+    \/\/ <\/editor-fold>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -175,0 +175,2 @@\n+        allowPrimitivePatterns = (preview.isEnabled() || !preview.isPreview(Feature.PRIMITIVE_PATTERNS)) &&\n+                Feature.PRIMITIVE_PATTERNS.allowedInSource(source);\n@@ -203,0 +205,4 @@\n+    \/** Are primitive patterns in instanceof allowed\n+     *\/\n+    private final boolean allowPrimitivePatterns;\n+\n@@ -1684,0 +1690,1 @@\n+            boolean booleanSwitch = types.isAssignable(seltype, syms.booleanType);\n@@ -1686,1 +1693,1 @@\n-            boolean errorPrimitiveSwitch = seltype.isPrimitive() && !intSwitch;\n+            boolean errorPrimitiveSwitch = seltype.isPrimitive() && !intSwitch && !allowPrimitivePatterns;\n@@ -1711,0 +1718,1 @@\n+            JCCaseLabel unconditionalCaseLabel = null;\n@@ -1778,4 +1786,20 @@\n-                                } else if (!stringSwitch && !intSwitch && !errorPrimitiveSwitch) {\n-                                    log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n-                                } else if (!constants.add(pattype.constValue())) {\n-                                    log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                }\n+                                else if (allowPrimitivePatterns) {\n+                                    if (!stringSwitch && !intSwitch && !booleanSwitch &&\n+                                        !(types.isSameType(pattype, syms.longType) && types.isAssignable(seltype, syms.longType)) &&\n+                                        !(types.isSameType(pattype, syms.floatType) && types.isAssignable(seltype, syms.floatType)) &&\n+                                        !(types.isSameType(pattype, syms.doubleType) && types.isAssignable(seltype, syms.doubleType))) {\n+                                        log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                    } else if (booleanSwitch &&\n+                                        !(types.isAssignable(pattype, syms.booleanType))) {\n+                                        log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                    } else if (!constants.add(pattype.constValue())) {\n+                                        log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                    }\n+                                }\n+                                else {\n+                                    if (!stringSwitch && !intSwitch && !errorPrimitiveSwitch) {\n+                                        log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                    } else if (!constants.add(pattype.constValue())) {\n+                                        log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                    }\n@@ -1798,1 +1822,2 @@\n-                        if (!primaryType.hasTag(TYPEVAR)) {\n+\n+                        if (!primaryType.hasTag(TYPEVAR) && !(primaryType.isPrimitive() && allowPrimitivePatterns)) {\n@@ -1800,0 +1825,2 @@\n+                        } else if (primaryType.isPrimitive() && allowPrimitivePatterns) {\n+                            preview.warnPreview(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -1835,0 +1862,1 @@\n+                            unconditionalCaseLabel = label;\n@@ -1861,1 +1889,1 @@\n-                chk.checkSwitchCaseLabelDominated(cases);\n+                chk.checkSwitchCaseLabelDominated(unconditionalCaseLabel, cases);\n@@ -4125,2 +4153,7 @@\n-        Type exprtype = chk.checkNullOrRefType(\n-                tree.expr.pos(), attribExpr(tree.expr, env));\n+        Type exprtype = attribExpr(tree.expr, env);\n+        if (!allowPrimitivePatterns) {\n+            exprtype = chk.checkNullOrRefType(\n+                    tree.expr.pos(), exprtype);\n+        } else if (tree.pattern.type != null && exprtype.isPrimitive() && preview.isPreview(Feature.PRIMITIVE_PATTERNS)) {\n+            preview.warnPreview(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+        }\n@@ -4145,1 +4178,3 @@\n-            chk.validate(typeTree, env, false);\n+            if (!clazztype.isPrimitive()  || !allowPrimitivePatterns) {\n+                chk.validate(typeTree, env, false);\n+            }\n@@ -4147,1 +4182,1 @@\n-        if (!clazztype.hasTag(TYPEVAR)) {\n+        if (!clazztype.hasTag(TYPEVAR) && !allowPrimitivePatterns) {\n@@ -4150,11 +4185,13 @@\n-        if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n-            boolean valid = false;\n-            if (allowReifiableTypesInInstanceof) {\n-                valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n-            } else {\n-                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                          Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n-                allowReifiableTypesInInstanceof = true;\n-            }\n-            if (!valid) {\n-                clazztype = types.createErrorType(clazztype);\n+        if(!clazztype.isPrimitive() || !allowPrimitivePatterns) {\n+            if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n+                boolean valid = false;\n+                if (allowReifiableTypesInInstanceof) {\n+                    valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n+                } else {\n+                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    allowReifiableTypesInInstanceof = true;\n+                }\n+                if (!valid) {\n+                    clazztype = types.createErrorType(clazztype);\n+                }\n@@ -4162,0 +4199,2 @@\n+        } else if (clazztype.isPrimitive() && preview.isPreview(Feature.PRIMITIVE_PATTERNS)) {\n+            preview.warnPreview(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4164,0 +4203,1 @@\n+\n@@ -4180,6 +4220,9 @@\n-                   (!exprType.isPrimitive() ||\n-                    !pattType.isPrimitive() ||\n-                    !types.isSameType(exprType, pattType))) {\n-            chk.basicHandler.report(pos,\n-                    diags.fragment(Fragments.NotApplicableTypes(exprType, pattType)));\n-            return false;\n+                (!exprType.isPrimitive() || !pattType.isPrimitive() || !types.isSameType(exprType, pattType))) {\n+            if (!allowPrimitivePatterns) {\n+                chk.basicHandler.report(pos,\n+                        diags.fragment(Fragments.NotApplicableTypes(exprType, pattType)));\n+                return false;\n+            } else {\n+                preview.warnPreview(pos, Feature.PRIMITIVE_PATTERNS);\n+                return true;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":71,"deletions":28,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -4689,1 +4689,1 @@\n-    void checkSwitchCaseLabelDominated(List<JCCase> cases) {\n+    void checkSwitchCaseLabelDominated(JCCaseLabel unconditionalCaseLabel, List<JCCase> cases) {\n@@ -4694,0 +4694,2 @@\n+        boolean unconditionalFound = false;\n+\n@@ -4721,1 +4723,3 @@\n-                    if (types.isSubtype(currentType, testType) &&\n+                    boolean dominated = false;\n+                    if (unconditionalCaseLabel == testCaseLabel) unconditionalFound = true;\n+                    if (types.checkUnconditionallyExact(currentType, testType) &&\n@@ -4724,1 +4728,0 @@\n-                        boolean dominated = false;\n@@ -4734,3 +4737,9 @@\n-                        if (dominated) {\n-                            log.error(label.pos(), Errors.PatternDominated);\n-                        }\n+                    }\n+\n+                    \/\/ Domination can occur even when we have not an unconditional pair between case labels.\n+                    if (unconditionalFound && unconditionalCaseLabel != label) {\n+                        dominated = true;\n+                    }\n+\n+                    if (dominated) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n@@ -4747,1 +4756,1 @@\n-                case CONSTANTCASELABEL -> types.boxedTypeOrType(((JCConstantCaseLabel) label).expr.type);\n+                case CONSTANTCASELABEL -> ((JCConstantCaseLabel) label).expr.type;\n@@ -4754,1 +4763,1 @@\n-            if (existingPatternType.isPrimitive() ^ currentPatternType.isPrimitive()) {\n+            if (!types.checkUnconditionallyExact(currentPatternType, existingPatternType)) {\n@@ -4757,7 +4766,0 @@\n-            if (existingPatternType.isPrimitive()) {\n-                return types.isSameType(existingPatternType, currentPatternType);\n-            } else {\n-                if (!types.isSubtype(currentPatternType, existingPatternType)) {\n-                    return false;\n-                }\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -735,0 +735,7 @@\n+\n+            boolean exhaustive = exhausts(tree.selector, tree.cases);\n+\n+            if (tree.selector.type.hasTag(TypeTag.BOOLEAN) && exhaustive && tree.hasUnconditionalPattern) {\n+                log.error(tree, Errors.DefaultLabelNotAllowed);\n+            }\n+\n@@ -736,2 +743,3 @@\n-                                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) ||\n-                                exhausts(tree.selector, tree.cases);\n+                    TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) ||\n+                    exhaustive;\n+\n@@ -748,0 +756,1 @@\n+            Set<Object> booleanLiterals = new HashSet<>();\n@@ -758,9 +767,14 @@\n-                        Symbol s = TreeInfo.symbol(constantLabel.expr);\n-                        if (s != null && s.isEnum()) {\n-                            enum2Constants.computeIfAbsent(s.owner, x -> {\n-                                Set<Symbol> result = new HashSet<>();\n-                                s.owner.members()\n-                                       .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n-                                       .forEach(result::add);\n-                                return result;\n-                            }).remove(s);\n+                        if (selector.type.hasTag(TypeTag.BOOLEAN)) {\n+                            Object value = ((JCLiteral) constantLabel.expr).value;\n+                            booleanLiterals.add(value);\n+                        } else {\n+                            Symbol s = TreeInfo.symbol(constantLabel.expr);\n+                            if (s != null && s.isEnum()) {\n+                                enum2Constants.computeIfAbsent(s.owner, x -> {\n+                                    Set<Symbol> result = new HashSet<>();\n+                                    s.owner.members()\n+                                            .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n+                                            .forEach(result::add);\n+                                    return result;\n+                                }).remove(s);\n+                            }\n@@ -771,0 +785,5 @@\n+\n+            if (selector.type.hasTag(TypeTag.BOOLEAN) && booleanLiterals.size() == 2) {\n+                return true;\n+            }\n+\n@@ -801,2 +820,1 @@\n-                    if (pd instanceof BindingPattern bp &&\n-                        types.isSubtype(seltypeComponent, types.erasure(bp.type))) {\n+                    if(isBpCovered(seltypeComponent, pd)) {\n@@ -1082,2 +1100,1 @@\n-                    covered &= newNested instanceof BindingPattern bp &&\n-                               types.isSubtype(types.erasure(componentType[i]), types.erasure(bp.type));\n+                    covered &= isBpCovered(componentType[i], newNested);\n@@ -1259,0 +1276,24 @@\n+    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n+        if (newNested instanceof BindingPattern bp) {\n+            var seltype = types.erasure(componentType);\n+\n+            if (seltype.isPrimitive()) {\n+                if (types.isSameType(bp.type, types.boxedClass(seltype).type)) {\n+                    return true;\n+                }\n+\n+                \/\/ if the target is unconditionally exact to the pattern, target is covered\n+                if (types.checkUnconditionallyExact(seltype, bp.type)) {\n+                    return true;\n+                }\n+            } else if (seltype.isReference() && bp.type.isPrimitive() && types.isCastable(seltype, bp.type)) {\n+                return true;\n+            } else {\n+                if (types.isSubtype(seltype, types.erasure(bp.type))) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -3462,1 +3503,1 @@\n-            Type type = types.isSubtype(selectorType, binding.type)\n+            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":57,"deletions":16,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -105,0 +106,1 @@\n+    private final HashMap<TypePairs, String> typePairToName;\n@@ -136,0 +138,1 @@\n+        typePairToName = TypePairs.initialize(syms);\n@@ -2908,0 +2911,139 @@\n+    public void visitTypeTest(JCInstanceOf tree) {\n+        if (tree.expr.type.isPrimitive() || tree.pattern.type.isPrimitive()) {\n+            JCExpression exactnessCheck = null;\n+            JCExpression instanceOfExpr = translate(tree.expr);\n+\n+            \/\/ preserving the side effects of the value\n+            VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n+                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    tree.expr.type,\n+                    currentMethodSym);\n+            JCStatement var = make.at(tree.pos())\n+                    .VarDef(dollar_s, instanceOfExpr).setType(dollar_s.type);\n+\n+            if (types.checkUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n+                if (tree.expr.type.isReference()) {\n+                    JCExpression nullCheck = makeBinary(NE,\n+                            make.Ident(dollar_s),\n+                            makeNull());\n+\n+                    exactnessCheck = make.LetExpr(List.of(var), nullCheck)\n+                            .setType(syms.booleanType);\n+                } else {\n+                    exactnessCheck = make\n+                            .LetExpr(List.of(var), make.Literal(BOOLEAN, 1).setType(syms.booleanType))\n+                            .setType(syms.booleanType);\n+                }\n+            }\n+            else if (tree.expr.type.isReference()) {\n+                JCExpression nullCheck = makeBinary(NE,\n+                        make.Ident(dollar_s),\n+                        makeNull());\n+                if (types.checkUnconditionallyExactPrimitives(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                    exactnessCheck = make\n+                            .LetExpr(List.of(var), nullCheck)\n+                            .setType(syms.booleanType);\n+                } else if (types.unboxedType(tree.expr.type).isPrimitive()) {\n+                    exactnessCheck = getExactnessCheck(tree,\n+                            boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type)));\n+                } else {\n+                    exactnessCheck = make.at(tree.pos())\n+                            .TypeTest(tree.expr, make.Type(types.boxedClass(tree.pattern.type).type))\n+                            .setType(syms.booleanType);\n+                }\n+\n+                exactnessCheck = make.LetExpr(List.of(var), makeBinary(AND,\n+                        nullCheck,\n+                        exactnessCheck))\n+                        .setType(syms.booleanType);\n+            }\n+            else if (tree.expr.type.isPrimitive()) {\n+                JCIdent argument = make.Ident(dollar_s);\n+\n+                JCExpression exactnessCheckCall =\n+                        getExactnessCheck(tree, argument);\n+\n+                exactnessCheck = make.LetExpr(List.of(var), exactnessCheckCall)\n+                        .setType(syms.booleanType);\n+            }\n+\n+            result = exactnessCheck;\n+        } else {\n+            tree.expr = translate(tree.expr);\n+            tree.pattern = translate(tree.pattern);\n+            result = tree;\n+        }\n+    }\n+\n+    \/\/ TypePairs should be in sync with the corresponding record in SwitchBootstraps\n+    record TypePairs(TypeSymbol from, TypeSymbol to) {\n+        public static TypePairs of(Symtab syms, Type from, Type to) {\n+            if (from == syms.byteType || from == syms.shortType || from == syms.charType) {\n+                from = syms.intType;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        public TypePairs(Type from, Type to) {\n+            this(from.tsym, to.tsym);\n+        }\n+\n+        public static HashMap<TypePairs, String> initialize(Symtab syms) {\n+            HashMap<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(syms.byteType,   syms.charType),   \"intToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.byteType),   \"intToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.charType),   \"intToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.byteType),   \"intToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.shortType),  \"intToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.intType,    syms.byteType),   \"intToByteExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.shortType),  \"intToShortExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.charType),   \"intToCharExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.floatType),  \"intToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.byteType),   \"longToByteExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.shortType),  \"longToShortExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.charType),   \"longToCharExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.intType),    \"longToIntExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.floatType),  \"longToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.doubleType), \"longToDoubleExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.byteType),   \"floatToByteExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.shortType),  \"floatToShortExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.charType),   \"floatToCharExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.intType),    \"floatToIntExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.longType),   \"floatToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.byteType),   \"doubleToByteExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.shortType),  \"doubleToShortExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.charType),   \"doubleToCharExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.intType),    \"doubleToIntExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.longType),   \"doubleToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.floatType),  \"doubleToFloatExact\");\n+            return typePairToName;\n+        }\n+    }\n+\n+    private JCExpression getExactnessCheck(JCInstanceOf tree, JCExpression argument) {\n+        TypePairs pair = TypePairs.of(syms, types.unboxedTypeOrType(tree.expr.type), tree.pattern.type);\n+\n+        Name exactnessFunction = names.fromString(typePairToName.get(pair));\n+\n+        \/\/ Resolve the exactness method\n+        Symbol ecsym = rs.resolveQualifiedMethod(null,\n+                attrEnv,\n+                syms.exactnessMethodsType,\n+                exactnessFunction,\n+                List.of(pair.from.type),\n+                List.nil());\n+\n+        \/\/ Generate the method call ExactnessChecks.<exactness method>(<argument>);\n+        JCFieldAccess select = make.Select(\n+                make.QualIdent(syms.exactnessMethodsType.tsym),\n+                exactnessFunction);\n+        select.sym = ecsym;\n+        select.setType(syms.booleanType);\n+\n+        JCExpression exactnessCheck = make.Apply(List.nil(),\n+                select,\n+                List.of(argument));\n+        exactnessCheck.setType(syms.booleanType);\n+        return exactnessCheck;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -75,0 +76,1 @@\n+import java.util.stream.Stream;\n@@ -239,1 +241,1 @@\n-                if (!tree.allowNull && !principalType.isPrimitive()) {\n+                if (!tree.allowNull || !types.isSubtype(currentValue.type, principalType)) {\n@@ -499,0 +501,1 @@\n+            boolean primitiveSelector = seltype.isPrimitive();\n@@ -503,0 +506,1 @@\n+            Type resolvedSelectorType = enumSelector || primitiveSelector ? seltype : syms.objectType;\n@@ -504,1 +508,1 @@\n-                    List.of(enumSelector ? seltype : syms.objectType, syms.intType),\n+                    List.of(resolvedSelectorType, syms.intType),\n@@ -738,0 +742,55 @@\n+    private Symbol.DynamicVarSymbol makePrimitive(DiagnosticPosition pos, Type primitiveType) {\n+        Assert.checkNonNull(currentClass);\n+\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                syms.stringType,\n+                new ClassType(syms.classType.getEnclosingType(),\n+                        List.of(syms.constantBootstrapsType),\n+                        syms.classType.tsym));\n+\n+        Name bootstrapName = names.fromString(\"primitiveClass\");\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                bootstrapName, bsm_staticArgs, List.nil());\n+\n+        PrimitiveGenerator primitiveGenerator = new PrimitiveGenerator();\n+        primitiveGenerator.assembleSig(primitiveType);\n+        return new Symbol.DynamicVarSymbol(names.fromString(primitiveGenerator.sb.toString()),\n+                syms.noSymbol,\n+                new Symbol.MethodHandleSymbol(bsm),\n+                syms.classType,\n+                new LoadableConstant[]{});\n+    }\n+\n+    private class PrimitiveGenerator extends Types.SignatureGenerator {\n+\n+        \/**\n+         * An output buffer for type signatures.\n+         *\/\n+        StringBuilder sb = new StringBuilder();\n+\n+        PrimitiveGenerator() {\n+            super(types);\n+        }\n+\n+        @Override\n+        protected void append(char ch) {\n+            sb.append(ch);\n+        }\n+\n+        @Override\n+        protected void append(byte[] ba) {\n+            sb.append(new String(ba));\n+        }\n+\n+        @Override\n+        protected void append(Name name) {\n+            sb.append(name.toString());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+\n+\n@@ -826,1 +885,2 @@\n-                                instanceofCheck.allowNull &&\n+                                (!types.erasure(binding.type).isPrimitive() ? instanceofCheck.allowNull :\n+                                types.checkUnconditionallyExact(commonNestedExpression.type, types.erasure(binding.type))) &&\n@@ -857,0 +917,1 @@\n+                    newSwitch.hasUnconditionalPattern = hasUnconditional;\n@@ -932,0 +993,3 @@\n+        if (p instanceof JCPattern jcp && jcp.type.isPrimitive()) {\n+            return jcp.type;\n+        }\n@@ -938,2 +1002,6 @@\n-            if (types.isSubtype(selector, principalType)) {\n-                return (LoadableConstant) selector;\n+            if (((JCPatternCaseLabel) l).pat.type.isReference()) {\n+                if (types.isSubtype(selector, principalType)) {\n+                    return (LoadableConstant) selector;\n+                } else {\n+                    return (LoadableConstant) principalType;\n+                }\n@@ -941,1 +1009,1 @@\n-                return (LoadableConstant) principalType;\n+                return makePrimitive(l.pos(), principalType);\n@@ -956,2 +1024,4 @@\n-                    case BYTE, CHAR,\n-                         SHORT, INT -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case BYTE, CHAR, SHORT, INT, BOOLEAN -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case LONG -> LoadableConstant.Long((Long) expr.type.constValue());\n+                    case FLOAT -> LoadableConstant.Float((Float) expr.type.constValue());\n+                    case DOUBLE -> LoadableConstant.Double((Double) expr.type.constValue());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":78,"deletions":8,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -3179,0 +3179,3 @@\n+compiler.misc.feature.primitive.patterns=\\\n+    primitive patterns\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -212,8 +212,8 @@\n-        BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1),  \/\/  boolean\n-        BYTE(TokenKind.BYTE, XEXPR1|XDECL1),  \/\/  byte\n-        CHAR(TokenKind.CHAR, XEXPR1|XDECL1),  \/\/  char\n-        DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1),  \/\/  double\n-        FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1),  \/\/  float\n-        INT(TokenKind.INT, XEXPR1|XDECL1),  \/\/  int\n-        LONG(TokenKind.LONG, XEXPR1|XDECL1),  \/\/  long\n-        SHORT(TokenKind.SHORT, XEXPR1|XDECL1),  \/\/  short\n+        BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1|XTERM),  \/\/  boolean\n+        BYTE(TokenKind.BYTE, XEXPR1|XDECL1|XTERM),  \/\/  byte\n+        CHAR(TokenKind.CHAR, XEXPR1|XDECL1|XTERM),  \/\/  char\n+        DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1|XTERM),  \/\/  double\n+        FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1|XTERM),  \/\/  float\n+        INT(TokenKind.INT, XEXPR1|XDECL1|XTERM),  \/\/  int\n+        LONG(TokenKind.LONG, XEXPR1|XDECL1|XTERM),  \/\/  long\n+        SHORT(TokenKind.SHORT, XEXPR1|XDECL1|XTERM),  \/\/  short\n@@ -808,1 +808,2 @@\n-            while (token.kind.isExpression())\n+            while (token.kind.isExpression()) {\n+                CT prevToken = in.prevCT;\n@@ -810,0 +811,15 @@\n+                \/\/ primitive types can only appear in the end of an `instanceof` expression\n+                switch (token.kind) {\n+                    case EOF:\n+                        switch (in.prevCT.kind) {\n+                            case BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE, BOOLEAN:\n+                                switch (prevToken.kind) {\n+                                    case INSTANCEOF:\n+                                        return Completeness.COMPLETE;\n+                                    default:\n+                                        return Completeness.DEFINITELY_INCOMPLETE;\n+                                }\n+                        }\n+                }\n+            }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -105,6 +105,3 @@\n-        try {\n-            testType(1, 0, 1, 1.0, Integer.class);\n-            fail(\"Didn't get the expected exception.\");\n-        } catch (IllegalArgumentException ex) {\n-            \/\/OK\n-        }\n+        testType(1, 0, 1, 1.0d, Integer.class);\n+        testType(1, 0, 1, 1.0f, Integer.class);\n+        testType(1, 0, 1, true, Integer.class);\n@@ -144,1 +141,0 @@\n-            MethodType.methodType(int.class, double.class, int.class),\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -399,0 +399,5 @@\n+\n+    public void testInstanceOf() {\n+        assertStatus(\"i instanceof Integer\", COMPLETE, \"i instanceof Integer\");\n+        assertStatus(\"i instanceof int\", COMPLETE, \"i instanceof int\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @build KullaTesting TestingInputStream\n+ * @run testng PrimitiveInstanceOfTest\n+ *\/\n+import jdk.jshell.JShell;\n+import org.testng.annotations.Test;\n+\n+import java.util.function.Consumer;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class PrimitiveInstanceOfTest extends KullaTesting {\n+\n+    public void testInstanceOf() {\n+        assertEval(\"int i = 42;\");\n+        assertEval(\"i instanceof Integer\");\n+        assertEval(\"i instanceof int\");\n+    }\n+\n+    public void testInstanceOfRef() {\n+        assertEval(\"Integer i = 42;\");\n+        assertEval(\"i instanceof Integer\");\n+        assertEval(\"i instanceof Number\");\n+    }\n+\n+    @org.testng.annotations.BeforeMethod\n+    public void setUp() {\n+        super.setUp(bc -> bc.compilerOptions(\"--source\", System.getProperty(\"java.specification.version\"), \"--enable-preview\").remoteVMOptions(\"--enable-preview\"));\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/PrimitiveInstanceOfTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.primitive.patterns\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PrimitivePatternMatching {\n+    boolean m(Object o) {\n+        return o instanceof int s;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitivePatternMatching.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -6,1 +6,1 @@\n- *\/\n+ * @compile --enable-preview --source 22 CastConversionMatch.java *\/\n","filename":"test\/langtools\/tools\/javac\/patterns\/CastConversionMatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @compile -g --enable-preview -source ${jdk.version} PrimitiveInstanceOf.java\n+ * @run main\/othervm --enable-preview PrimitiveInstanceOf\n+ *\/\n+public class PrimitiveInstanceOf {\n+\n+    public static void main(String[] args) {\n+        assertEquals(true,  identityPrimitiveConversion());\n+        assertEquals(true,  wideningPrimitiveConversion());\n+        assertEquals(true,  narrowingPrimitiveConversion());\n+        assertEquals(true,  wideningAndNarrowingPrimitiveConversion());\n+        assertEquals(true,  boxingConversion());\n+        assertEquals(true,  boxingAndWideningReferenceConversion());\n+        assertEquals(true,  unboxing());\n+        assertEquals(true,  unboxingWithObject());\n+        assertEquals(true,  wideningReferenceConversionUnboxing(42));\n+        assertEquals(true,  wideningReferenceConversionUnboxingAndWideningPrimitive(42));\n+        assertEquals(true,  unboxingAndWideningPrimitiveExact());\n+        assertEquals(false, unboxingAndWideningPrimitiveNotExact());\n+        assertEquals(true,  unboxingWhenNullAndWideningPrimitive());\n+        assertEquals(true,  narrowingAndUnboxing());\n+        assertEquals(true,  patternExtractRecordComponent());\n+        assertEquals(true,  exprMethod());\n+        assertEquals(true,  exprStaticallyQualified());\n+    }\n+\n+    public static boolean identityPrimitiveConversion() {\n+        int i = 42;\n+        return i instanceof int;\n+    }\n+\n+    public static boolean wideningPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        short s = (short) 42;\n+        char c = 'a';\n+\n+        return b instanceof int && s instanceof int && c instanceof int;\n+    }\n+\n+    public static boolean narrowingPrimitiveConversion() {\n+        long l_within_int_range = 42L;\n+        long l_outside_int_range = 999999999999999999L;\n+\n+        return l_within_int_range instanceof int && !(l_outside_int_range instanceof int);\n+    }\n+\n+    public static boolean wideningAndNarrowingPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        byte b2 = (byte) -42;\n+        char c = (char) 42;\n+        return b instanceof char && c instanceof byte && !(b2 instanceof char);\n+    }\n+\n+    public static boolean boxingConversion() {\n+        int i = 42;\n+\n+        return i instanceof Integer;\n+    }\n+\n+    public static boolean boxingAndWideningReferenceConversion() {\n+        int i = 42;\n+        return i instanceof Object &&\n+                i instanceof Number &&\n+                i instanceof Comparable;\n+    }\n+\n+    public static boolean unboxing() {\n+        Integer i = Integer.valueOf(1);\n+        return i instanceof int;\n+    }\n+\n+    public static boolean unboxingWithObject() {\n+        Object o1 = (int) 42;\n+        Object o2 = (byte) 42;\n+\n+        return o1 instanceof int i1 &&\n+                o2 instanceof byte b1 &&\n+                !(o1 instanceof byte b2 &&\n+                !(o2 instanceof int i2));\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing(T i) {\n+        return i instanceof int;\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndWideningPrimitive(T i) {\n+        return i instanceof double;\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveExact() {\n+        Byte b = Byte.valueOf((byte)42);\n+        Short s = Short.valueOf((short)42);\n+        Character c = Character.valueOf('a');\n+\n+        return (b instanceof int) && (s instanceof int) && (c instanceof int);\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveNotExact() {\n+        int smallestIntNotRepresentable = 16777217; \/\/ 2^24 + 1\n+        Integer i = Integer.valueOf(smallestIntNotRepresentable);\n+\n+        return i instanceof float;\n+    }\n+\n+    public static boolean unboxingWhenNullAndWideningPrimitive() {\n+        Byte b = null;\n+        Short s = null;\n+        Character c = null;\n+\n+        return !(b instanceof int) && !(s instanceof int) && !(c instanceof int);\n+    }\n+\n+    public static boolean narrowingAndUnboxing() {\n+        Number n = Byte.valueOf((byte) 42);\n+\n+        return n instanceof byte;\n+    }\n+\n+    public record P(int i) { }\n+    public static boolean patternExtractRecordComponent() {\n+        Object p = new P(42);\n+        if (p instanceof P(byte b)) {\n+            return b == 42;\n+        }\n+        return false;\n+    }\n+\n+    public static int meth() {return 42;}\n+    public static boolean exprMethod() {\n+        return meth() instanceof int;\n+    }\n+\n+    public class A1 {\n+        public static int i = 42;\n+    }\n+    public static boolean exprStaticallyQualified() {\n+        return A1.i instanceof int;\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOf.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @compile\/fail\/ref=PrimitiveInstanceOfErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitiveInstanceOfErrors.java\n+ *\/\n+public class PrimitiveInstanceOfErrors {\n+    public static boolean unboxingAndNarrowingPrimitiveNotAllowedPerCastingConversion() {\n+        Long l_within_int_range = 42L;\n+        Long l_outside_int_range = 999999999999999999L;\n+\n+        return l_within_int_range instanceof int && !(l_outside_int_range instanceof int);\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndNarrowingPrimitive(T i) {\n+        return i instanceof byte;\n+    }\n+\n+    public static void boxingConversionsBetweenIncompatibleTypes() {\n+        int i = 42;\n+\n+        boolean ret1 = i instanceof Integer; \/\/ (Integer) i \/\/ OK and true\n+        boolean ret2 = i instanceof Double;  \/\/ error: incompatible types\n+        boolean ret3 = i instanceof Short;   \/\/ error: incompatible types\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfErrors.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+PrimitiveInstanceOfErrors.java:12:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Long, int)\n+PrimitiveInstanceOfErrors.java:12:55: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Long, int)\n+PrimitiveInstanceOfErrors.java:16:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: T, byte)\n+PrimitiveInstanceOfErrors.java:23:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Double)\n+PrimitiveInstanceOfErrors.java:24:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Short)\n+- compiler.note.preview.filename: PrimitiveInstanceOfErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfErrors.out","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @compile -g --enable-preview -source ${jdk.version} PrimitiveInstanceOfNumericValueTests.java\n+ * @run main\/othervm --enable-preview PrimitiveInstanceOfNumericValueTests\n+ *\/\n+public class PrimitiveInstanceOfNumericValueTests {\n+\n+    public static void main(String[] args) {\n+        testByte();\n+        testShort();\n+        testChar();\n+        testInt();\n+        testLong();\n+        testFloat();\n+        testDouble();\n+    }\n+\n+    public static void testByte() {\n+        assertEquals(true,  ((byte) (Byte.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((byte) (0)) instanceof byte);\n+        assertEquals(true,  ((byte) (Byte.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, ((short) (Short.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((short) (0)) instanceof byte);\n+        assertEquals(false, ((short) (Short.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, ((char) (Character.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((char) (Character.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  (0) instanceof byte);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  (0) instanceof byte);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  ((float) 0) instanceof byte);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Float.NaN) instanceof byte);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (-0.0f) instanceof byte);\n+        assertEquals(true,  (+0.0f) instanceof byte);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  ((double) 0) instanceof byte);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Double.NaN) instanceof byte);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (-0.0d) instanceof byte);\n+        assertEquals(true,  (+0.0d) instanceof byte);\n+    }\n+    public static void testShort() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((byte) (0)) instanceof short);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof short);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((short) (0)) instanceof short);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof short);\n+        assertEquals(false, ((char) (Character.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof short);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof short);\n+        assertEquals(true, (0) instanceof short);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof short);\n+        assertEquals(true, (0) instanceof short);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof short);\n+        assertEquals(true, ((float) 0) instanceof short);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.NaN) instanceof short);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof short);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof short);\n+        assertEquals(false, (-0.0f) instanceof short);\n+        assertEquals(true, (+0.0f) instanceof short);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof short);\n+        assertEquals(true, ((double) 0) instanceof short);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Double.NaN) instanceof short);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof short);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof short);\n+        assertEquals(false, (-0.0d) instanceof short);\n+        assertEquals(true, (+0.0d) instanceof short);\n+    }\n+    public static void testChar() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((byte) (0)) instanceof char);\n+        assertEquals(false, ((byte) (Byte.MIN_VALUE)) instanceof char);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((short) (0)) instanceof char);\n+        assertEquals(false, ((short) (Short.MIN_VALUE)) instanceof char);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof char);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof char);\n+        assertEquals(true, (0) instanceof char);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof char);\n+        assertEquals(true, (0) instanceof char);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof char);\n+        assertEquals(true, ((float) 0) instanceof char);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Float.NaN) instanceof char);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof char);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof char);\n+        assertEquals(false, (-0.0f) instanceof char);\n+        assertEquals(true, (+0.0f) instanceof char);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof char);\n+        assertEquals(true, ((double) 0) instanceof char);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Double.NaN) instanceof char);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof char);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof char);\n+        assertEquals(false, (-0.0d) instanceof char);\n+        assertEquals(true, (+0.0d) instanceof char);\n+    }\n+    public static void testInt() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((byte) (0)) instanceof int);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof int);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((short) (0)) instanceof int);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof int);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof int);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof int);\n+        assertEquals(true, (0) instanceof int);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof int);\n+        assertEquals(true, (0) instanceof int);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof int);\n+        assertEquals(true, ((float) 0) instanceof int);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Float.NaN) instanceof int);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof int);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof int);\n+        assertEquals(false, (-0.0f) instanceof int);\n+        assertEquals(true, (+0.0f) instanceof int);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof int);\n+        assertEquals(true, ((double) 0) instanceof int);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Double.NaN) instanceof int);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof int);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof int);\n+        assertEquals(false, (-0.0d) instanceof int);\n+        assertEquals(true, (+0.0d) instanceof int);\n+    }\n+    public static void testLong() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((byte) (0)) instanceof long);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof long);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((short) (0)) instanceof long);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof long);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof long);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof long);\n+        assertEquals(true, (0) instanceof long);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof long);\n+        assertEquals(true, (Long.MAX_VALUE) instanceof long);\n+        assertEquals(true, (0) instanceof long);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof long);\n+        assertEquals(true, ((float) 0) instanceof long);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Float.NaN) instanceof long);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof long);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof long);\n+        assertEquals(false, (-0.0f) instanceof long);\n+        assertEquals(true, (+0.0f) instanceof long);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof long);\n+        assertEquals(true, ((double) 0) instanceof long);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Double.NaN) instanceof long);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof long);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof long);\n+        assertEquals(false, (-0.0d) instanceof long);\n+        assertEquals(true, (+0.0d) instanceof long);\n+    }\n+    public static void testFloat() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((byte) (0) instanceof float));\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof float);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((short) (0)) instanceof float);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof float);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof float);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof float);\n+        assertEquals(true, (0) instanceof float);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof float);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof float);\n+        assertEquals(true, (0) instanceof float);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Float.MAX_VALUE) instanceof float);\n+        assertEquals(true, ((float) 0) instanceof float);\n+        assertEquals(true, (Float.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Float.NaN) instanceof float);\n+        assertEquals(true, (Float.POSITIVE_INFINITY) instanceof float);\n+        assertEquals(true, (Float.NEGATIVE_INFINITY) instanceof float);\n+        assertEquals(true, (-0.0f) instanceof float);\n+        assertEquals(true, (+0.0f) instanceof float);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof float);\n+        assertEquals(true, ((double) 0) instanceof float);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Double.NaN) instanceof float);\n+        assertEquals(true, (Double.POSITIVE_INFINITY) instanceof float);\n+        assertEquals(true, (Double.NEGATIVE_INFINITY) instanceof float);\n+        assertEquals(true, (-0.0d) instanceof float);\n+        assertEquals(true, (+0.0d) instanceof float);\n+    }\n+    public static void testDouble() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((byte) (0)) instanceof double);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof double);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((short) (0)) instanceof double);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof double);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof double);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof double);\n+        assertEquals(true, (0) instanceof double);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof double);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof double);\n+        assertEquals(true, (0) instanceof double);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Float.MAX_VALUE) instanceof double);\n+        assertEquals(true, ((float) 0) instanceof double);\n+        assertEquals(true, (Float.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Float.NaN) instanceof double);\n+        assertEquals(true, (Float.POSITIVE_INFINITY) instanceof double);\n+        assertEquals(true, (Float.NEGATIVE_INFINITY) instanceof double);\n+        assertEquals(true, (-0.0f) instanceof double);\n+        assertEquals(true, (+0.0f) instanceof double);\n+        assertEquals(true, (Double.MAX_VALUE) instanceof double);\n+        assertEquals(true, ((double) 0) instanceof double);\n+        assertEquals(true, (Double.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Double.NaN) instanceof double);\n+        assertEquals(true, (Double.POSITIVE_INFINITY) instanceof double);\n+        assertEquals(true, (Double.NEGATIVE_INFINITY) instanceof double);\n+        assertEquals(true, (-0.0d) instanceof double);\n+        assertEquals(true, (+0.0d) instanceof double);\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfNumericValueTests.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,444 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitivePatterns.java\n+ * @run main\/othervm PrimitivePatterns\n+ *\/\n+public class PrimitivePatterns {\n+    public static void main(String[] args) {\n+        assertEquals(42, primitivePattern());\n+        assertEquals(42, primitivePatternUnnamed());\n+        assertEquals(1,  primitiveSwitch(42));\n+        assertEquals(2,  primitiveSwitch(123));\n+        assertEquals(1,  primitiveSwitchUnnamed(42));\n+        assertEquals(2,  primitiveSwitchUnnamed(123));\n+        assertEquals(42, primitiveSwitch2());\n+        assertEquals(42, primitiveSwitch3());\n+        assertEquals(1,  primitiveSwitch4(0.0f));\n+        assertEquals(2,  primitiveSwitch4(1.0f));\n+        assertEquals(1,  primitiveSwitchUnconditionallyExact(Byte.MAX_VALUE));\n+        assertEquals(42, exhaustive0());\n+        assertEquals(1,  exhaustive1WithDefault());\n+        assertEquals(2,  exhaustive2WithDefault());\n+        assertEquals(1,  exhaustive1());\n+        assertEquals(1,  exhaustive2());\n+        assertEquals(1,  exhaustive3());\n+        assertEquals(1,  exhaustive4());\n+        assertEquals(2,  exhaustive5());\n+        assertEquals(1,  exhaustive6());\n+        assertEquals(1,  exhaustiveWithRecords1());\n+        assertEquals(1,  exhaustiveWithRecords2());\n+        assertEquals(1,  exhaustiveWithRecords4());\n+        assertEquals(1,  exhaustiveWithRecords5());\n+        assertEquals(1,  exhaustiveWithRecords6());\n+        assertEquals(2,  ensureProperSelectionWithRecords());\n+        assertEquals(1,  ensureProperSelectionWithRecords2());\n+        assertEquals(3,  ensureProperSelectionWithRecords3());\n+        assertEquals(42, switchAndDowncastFromObjectPrimitive());\n+        assertEquals(42, dominationBetweenBoxedAndPrimitive());\n+        assertEquals(2,  wideningAndUnboxing());\n+        assertEquals(2,  wideningAndUnboxingInRecord());\n+        assertEquals(2,  wideningAndInferredUnboxingInRecord());\n+        assertEquals(5f, switchOverBoxedFloat(0f));\n+        assertEquals(7f, switchOverBoxedFloat(1f));\n+        assertEquals(9f, switchOverBoxedFloat(2f));\n+        assertEquals(9f, switchOverBoxedFloat(2f));\n+        assertEquals(5f, switchOverPrimitiveDouble(0d));\n+        assertEquals(7f, switchOverPrimitiveDouble(1d));\n+        assertEquals(9f, switchOverPrimitiveDouble(2d));\n+        assertEquals(1, switchOverPrimitiveChar('a'));\n+        assertEquals(-1, switchOverPrimitiveChar('x'));\n+        assertTrue(switchOverBoxedBooleanWithUnconditional(Boolean.valueOf(true)));\n+        assertTrue(switchOverBoxedBooleanWithUnconditional(true));\n+        assertTrue(!switchOverBoxedBooleanWithUnconditional(false));\n+        assertEquals(1, switchOverPrimitiveBooleanWithDefault(true));\n+        assertEquals(2, switchOverPrimitiveBooleanWithDefault(false));\n+        assertEquals(1, switchOverPrimitiveBoolean(true));\n+        assertEquals(2, switchOverPrimitiveBoolean(false));\n+        assertEquals(1, switchOverPrimitiveFloat(0.0f\/0.0f));\n+        assertEquals(2, switchOverPrimitiveFloat((float) Math.pow(0.0f\/0.0f, 0)));\n+        assertEquals(3, switchOverPrimitiveFloat(0.0f));\n+        assertEquals(4, switchOverPrimitiveFloat(-0.0f));\n+        assertEquals(1, switchRedirectedExactnessMethods1('a'));\n+        assertEquals(-1, switchRedirectedExactnessMethods1('\\u03A9'));\n+        assertEquals(1, switchRedirectedExactnessMethods2('\\u03A9'));\n+        assertEquals(-1, switchRedirectedExactnessMethods2('\\uFFFF'));\n+    }\n+\n+    public static int primitivePattern() {\n+        int i = 42;\n+        if (i instanceof int p) {\n+            return p;\n+        }\n+        return -1;\n+    }\n+\n+    public static int primitivePatternUnnamed() {\n+        int i = 42;\n+        if (i instanceof int _) {\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    public static int primitiveSwitch(int i) {\n+        return switch (i) {\n+            case int j when j == 42-> 1;\n+            case int j -> 2;\n+        };\n+    }\n+\n+    public static int primitiveSwitchUnnamed(int i) {\n+        return switch (i) {\n+            case int _ when i == 42-> 1;\n+            case int _ -> 2;\n+        };\n+    }\n+\n+    public static int primitiveSwitch2() {\n+        Object o = Integer.valueOf(42);\n+        switch (o) {\n+            case int i: return i;\n+            default: break;\n+        }\n+        return -1;\n+    }\n+\n+    public static int primitiveSwitch3() {\n+        int i = 42;\n+        switch (i) {\n+            case Integer ii: return ii;\n+        }\n+    }\n+\n+    public static int primitiveSwitch4(float f) {\n+        return switch (f) {\n+            case 0.0f -> 1;\n+            case Float fi when fi == 1f -> 2;\n+            case Float fi -> 3;\n+        };\n+    }\n+\n+    public static int primitiveSwitchUnconditionallyExact(byte c) {\n+        return switch (c) {\n+            case short _ -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive0() {\n+        Integer i = 42;\n+        switch (i) {\n+            case int j: return j;\n+        }\n+    }\n+\n+    public static int exhaustive1WithDefault() {\n+        int i = 42;\n+        return switch (i) {\n+            case byte  b -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive2WithDefault() {\n+        int i = 30000;\n+        return switch (i) {\n+            case byte  b -> 1;\n+            case short s -> 2;\n+            default -> 3;\n+        };\n+    }\n+\n+    public static int exhaustive1() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer p -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive2() {\n+        int i = 42;\n+        return switch (i) {\n+            case long d -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive3() {\n+        int i = 42;\n+        return switch (i) {\n+            case double d -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive4() {\n+        int i = 127;\n+        return switch (i) {\n+            case byte b -> 1;\n+            case double d -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive5() {\n+        int i = 127 + 1;\n+        return switch (i) {\n+            case byte b -> 1;\n+            case double d -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive6() {\n+        Integer i = Integer.valueOf(42);\n+        return switch (i) {\n+            case int p -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords1() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because Integer exhaustive at type int\n+            case R_int(Integer x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords2() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because double unconditional at int\n+            case R_int(double x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords4() {\n+        R_Integer r = new R_Integer(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because R_Integer(int) exhaustive at type R_Integer(Integer), because int exhaustive at type Integer\n+            case R_Integer(int x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords5() {\n+        R_Integer r = new R_Integer(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because double exhaustive at Integer\n+            case R_Integer(double x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords6() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) -> 2;\n+        };\n+    }\n+\n+    public static int ensureProperSelectionWithRecords() {\n+        R_int r = new R_int(4242);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) -> 2;\n+        };\n+    }\n+\n+    public static int ensureProperSelectionWithRecords2() {\n+        R_double r = new R_double(42);\n+        switch (r) {\n+            case R_double(int i):\n+                return meth_int(i);\n+            case R_double(double x):\n+                return meth_double(x);\n+        }\n+    }\n+\n+    public static int ensureProperSelectionWithRecords3() {\n+        R_int r = new R_int(4242);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) when x == 236 -> 2;\n+            case R_int(int x) -> 3;\n+        };\n+    }\n+\n+    public static int meth_int(int i) { return 1; }\n+    public static int meth_double(double d) { return 2;}\n+\n+    public static int switchAndDowncastFromObjectPrimitive() {\n+        Object i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static int dominationBetweenBoxedAndPrimitive() {\n+        Object i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            case byte ip     -> ip;\n+            default -> -1;\n+        };\n+    }\n+\n+    static int wideningAndUnboxing() {\n+        Number o = Integer.valueOf(42);\n+        return switch (o) {\n+            case byte b -> 1;\n+            case int i -> 2;\n+            case float f -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    static int wideningAndUnboxingInRecord() {\n+        Box<Number> box = new Box<>(Integer.valueOf(42));\n+        return switch (box) {\n+            case Box<Number>(byte b) -> 1;\n+            case Box<Number>(int i) -> 2;\n+            case Box<Number>(float f) -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    static int wideningAndInferredUnboxingInRecord() {\n+        Box<Number> box = new Box<>(Integer.valueOf(42));\n+        return switch (box) {\n+            case Box(byte b) -> 1;\n+            case Box(int i) -> 2;\n+            case Box(float f) -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    public static float switchOverBoxedFloat(Float f) {\n+        return switch (f) {\n+            case 0f -> 5f + 0f;\n+            case Float fi when fi == 1f -> 6f + fi;\n+            case Float fi -> 7f + fi;\n+        };\n+    }\n+\n+    public static double switchOverPrimitiveDouble(Double d) {\n+        return switch (d) {\n+            case 0d -> 5d + 0d;\n+            case Double di when di == 1d -> 6d + di;\n+            case Double di -> 7d + di;\n+        };\n+    }\n+\n+    public static boolean switchOverBoxedBooleanWithUnconditional(Boolean b) {\n+        return switch (b) {\n+            case true -> true;\n+            case Boolean bi -> bi;\n+        };\n+    }\n+\n+    public static int switchOverPrimitiveBooleanWithDefault(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    public static int switchOverPrimitiveBoolean(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+        };\n+    }\n+\n+    public static int switchOverPrimitiveChar(char c) {\n+        return switch (c) {\n+            case 'a' -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static final float NaNconstant = Float.NaN;\n+    public static int switchOverPrimitiveFloat(float f) {\n+        return switch (f) {\n+            case NaNconstant -> 1;\n+            case 1.0f -> 2;\n+            case 0.0f -> 3;\n+            case -0.0f -> 4;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.char_byte is properly redirected to int_byte\n+    public static int switchRedirectedExactnessMethods1(char c) {\n+        return switch (c) {\n+            case byte _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.char_short is properly redirected to int_short\n+    public static int switchRedirectedExactnessMethods2(char c) {\n+        return switch (c) {\n+            case short _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.short_byte is properly redirected to int_byte\n+    public static int switchRedirectedExactnessMethods2(short c) {\n+        return switch (c) {\n+            case byte _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    record R_Integer(Integer x) {}\n+    record R_int(int x) {}\n+    record R_double(double x) {}\n+    record Box<N extends Number>(N num) {}\n+\n+    static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+\n+    static void assertEquals(float expected, float actual) {\n+        if (Float.compare(expected, actual) != 0) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    static void assertEquals(double expected, double actual) {\n+        if (Double.compare(expected, actual) != 0) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    static void assertTrue(boolean actual) {\n+        if (!actual) {\n+            throw new AssertionError(\"Expected: true, but got false\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatterns.java","additions":444,"deletions":0,"binary":false,"changes":444,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @build combo.ComboTestHelper\n+ * @compile PrimitivePatternsComboTest.java\n+ * @run main PrimitivePatternsComboTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask;\n+import combo.ComboTestHelper;\n+import toolbox.ToolBox;\n+\n+public class PrimitivePatternsComboTest extends ComboInstance<PrimitivePatternsComboTest> {\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    protected ToolBox tb;\n+\n+    PrimitivePatternsComboTest() {\n+        super();\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<PrimitivePatternsComboTest>()\n+                .withDimension(\"TYPE1\", (x, type1) -> x.type1 = type1, Type.values())\n+                .withDimension(\"TYPE2\", (x, type2) -> x.type2 = type2, Type.values())\n+                .withFailMode(ComboTestHelper.FailMode.FAIL_FAST)\n+                .run(PrimitivePatternsComboTest::new);\n+    }\n+\n+    private Type type1;\n+    private Type type2;\n+\n+    private static final String test1 =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest(#{TYPE1} in) {\n+                    var r = (#{TYPE2}) in;\n+                }\n+            }\n+            \"\"\";\n+\n+    private static final String test2 =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest(#{TYPE1} in) {\n+                    var r = in instanceof #{TYPE2};\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    protected void doWork() throws Throwable {\n+        ComboTask task1 = newCompilationTask()\n+                .withSourceFromTemplate(test1.replace(\"#{TYPE1}\", type1.code).replace(\"#{TYPE2}\", type2.code))\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\").withOption(JAVA_VERSION);;\n+\n+        ComboTask task2 = newCompilationTask()\n+                .withSourceFromTemplate(test2.replace(\"#{TYPE1}\", type1.code).replace(\"#{TYPE2}\", type2.code))\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\").withOption(JAVA_VERSION);;\n+\n+        task1.generate(result1 -> {\n+            task2.generate(result2 -> {\n+                if (result1.hasErrors() ^ result2.hasErrors()) {\n+                    throw new AssertionError(\"Unexpected result: \" +\n+                            \"\\n task1: \" + result1.hasErrors() + \", info: \" + result1.compilationInfo() +\n+                            \"\\n task1: \" + result2.hasErrors() + \", info: \" + result2.compilationInfo());\n+                }\n+            });\n+        });\n+    }\n+\n+    public enum Type implements ComboParameter {\n+        BYTE(\"byte\"),\n+        SHORT(\"short\"),\n+        CHAR(\"char\"),\n+        INT(\"int\"),\n+        LONG(\"long\"),\n+        FLOAT(\"float\"),\n+        DOUBLE(\"double\"),\n+        BOOLEAN(\"boolean\"),\n+\n+        BYTE_r(\"Byte\"),\n+        SHORT_r(\"Short\"),\n+        CHAR_r(\"Character\"),\n+        INTEGER_r(\"Integer\"),\n+        LONG_r(\"Long\"),\n+        FLOAT_r(\"Float\"),\n+        DOUBLE_r(\"Double\"),\n+        BOOLEAN_r(\"Boolean\");\n+\n+        private final String code;\n+\n+        Type(String code) {\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            throw new UnsupportedOperationException(\"Not supported.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsComboTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @compile\/fail\/ref=PrimitivePatternsSwitchErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsSwitchErrors.java\n+ *\/\n+public class PrimitivePatternsSwitchErrors {\n+    record R_int(int x) {}\n+\n+    public static void dominationBetweenPrimitivePatterns() {\n+        int i = 42;\n+        switch (i) {\n+            case short s -> System.out.println(\"its a short\");\n+            case byte b  -> System.out.println(\"its a byte\"); \/\/ Error - dominated!\n+            default      -> System.out.println(\"any other integral value\");\n+        }\n+    }\n+\n+    public static int dominationWithRecordPatterns() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(int x) -> 1;\n+            case R_int(byte x) -> 2;  \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int inconvertibleNestedComponent() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(Long x) -> 1; \/\/ inconvertible\n+        };\n+    }\n+\n+    public static int nonExhaustive1() {\n+        int i = 42;\n+        return switch (i) {  \/\/ Error - not exhaustive\n+            case short s -> s;\n+        };\n+    }\n+\n+    public static int nonExhaustive2() {\n+        int i = 42;\n+        return switch (i) { \/\/ Error - not exhaustive\n+            case byte  b -> 1;\n+            case short s -> 2;\n+        };\n+    }\n+\n+    public static int nonExhaustive3() {\n+        int i = 42;\n+        return switch (i) { \/\/ Error - not exhaustive\n+            case byte  b -> 1;\n+            case float f -> 2;\n+        };\n+    }\n+\n+    public static int dominationBetweenBoxedAndPrimitive() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            case byte ip     -> ip; \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int constantDominatedWithPrimitivePattern() {\n+        int i = 42;\n+        return switch (i) {\n+            case int j -> 42;\n+            case 43    -> -1;   \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int constantDominatedWithFloatPrimitivePattern() {\n+        float f = 42.0f;\n+        return switch (f) {\n+            case Float ff -> 42;\n+            case 43.0f    -> -1;   \/\/ Error - dominated!\n+        };\n+    }\n+\n+    void switchLongOverByte(byte b) {\n+        switch (b) {\n+            case 0L: return ;\n+        }\n+    }\n+\n+    void switchOverPrimitiveFloatFromInt(float f) {\n+        switch (f) {\n+            case 16777216:\n+                break;\n+            case 16777217:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    void switchOverNotRepresentableFloat(Float f) {\n+        switch (f) {\n+            case 1.0f:\n+                break;\n+            case 0.999999999f:\n+                break;\n+            case Float fi:\n+                break;\n+        }\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedDefault(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+            default -> 3;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+PrimitivePatternsSwitchErrors.java:14:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:23:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:30:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Long)\n+PrimitivePatternsSwitchErrors.java:61:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:69:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:77:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:83:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: long, byte)\n+PrimitivePatternsSwitchErrors.java:89:18: compiler.err.constant.label.not.compatible: int, float\n+PrimitivePatternsSwitchErrors.java:91:18: compiler.err.constant.label.not.compatible: int, float\n+PrimitivePatternsSwitchErrors.java:102:13: compiler.err.duplicate.case.label\n+PrimitivePatternsSwitchErrors.java:29:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:36:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:43:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:51:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:110:16: compiler.err.default.label.not.allowed\n+- compiler.note.preview.filename: PrimitivePatternsSwitchErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+15 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.out","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -6,0 +6,1 @@\n+ * @compile --enable-preview --source 22 SwitchNoExtraTypes.java\n@@ -13,0 +14,1 @@\n+            default:\n@@ -18,1 +20,2 @@\n-            case 0: return ;\n+            case 0l: return ;\n+            default:\n@@ -24,1 +27,2 @@\n-            case 0: return ;\n+            case 0f: return ;\n+            default:\n@@ -30,1 +34,2 @@\n-            case 0: return ;\n+            case 0d: return ;\n+            default:\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-SwitchNoExtraTypes.java:11:16: compiler.err.selector.type.not.allowed: boolean\n-SwitchNoExtraTypes.java:17:16: compiler.err.selector.type.not.allowed: long\n-SwitchNoExtraTypes.java:23:16: compiler.err.selector.type.not.allowed: float\n-SwitchNoExtraTypes.java:29:16: compiler.err.selector.type.not.allowed: double\n+SwitchNoExtraTypes.java:12:16: compiler.err.selector.type.not.allowed: boolean\n+SwitchNoExtraTypes.java:19:16: compiler.err.selector.type.not.allowed: long\n+SwitchNoExtraTypes.java:26:16: compiler.err.selector.type.not.allowed: float\n+SwitchNoExtraTypes.java:33:16: compiler.err.selector.type.not.allowed: double\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.preview.patterns;\n+\n+import static java.lang.runtime.ExactnessMethods.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * Tests Exactness methods\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations=5, time=1)\n+@Measurement(iterations=5, time=1)\n+@Threads(2)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class Exactness {\n+\n+    private static boolean int_float_based_on_leading_trailing(int n) {\n+        if (n == Integer.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (32 - (Integer.numberOfLeadingZeros(n) +\n+                        Integer.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean int_float_based_on_filtering(int n) {\n+        return n == (int)(float)n && n != Integer.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_filtering(long n) {\n+        return n == (long)(float)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Double.PRECISION >= \/\/ 53\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_filtering(long n) {\n+        return n == (long)(double)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean float_int_based_on_compare(float n) {\n+        return Double.compare((double)n, (double)((int)n)) == 0;\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_compare(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_compare(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+    private static boolean float_int_based_on_filtering(float n) {\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_filtering(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_filtering(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/preview\/patterns\/Exactness.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}