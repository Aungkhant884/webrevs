{"files":[{"patch":"@@ -5016,2 +5016,5 @@\n-     *  - widening from one reference type to another,\n-     *  - boxing.\n+     *    an identity conversion\n+     *    a widening reference conversion\n+     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n+     *    a boxing conversion\n+     *    a boxing conversion followed by a widening reference conversion\n@@ -5028,2 +5031,1 @@\n-            return (source.isReference() && isSubtype(boxedTypeOrType(erasure(source)), target)) ||\n-                    (source.isReference() && checkUnconditionallyExactPrimitives(unboxedType(source), target) ) ||\n+            return (source.isReference() && isSubtype(source, target)) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4741,1 +4741,1 @@\n-                case CONSTANTCASELABEL -> types.boxedTypeOrType(((JCConstantCaseLabel) label).expr.type);\n+                case CONSTANTCASELABEL -> ((JCConstantCaseLabel) label).expr.type;\n@@ -4748,3 +4748,1 @@\n-\n-            boolean unconditionallyExact = types.checkUnconditionallyExact(currentPatternType, existingPatternType);\n-            if (!unconditionallyExact) {\n+            if (!types.checkUnconditionallyExact(currentPatternType, existingPatternType)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}