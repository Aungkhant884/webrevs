{"files":[{"patch":"@@ -5029,2 +5029,2 @@\n-                    (source.isReference() && isExactPrimitiveWidening(unboxedType(source), target) ) ||\n-                    isExactPrimitiveWidening(source, target);\n+                    (source.isReference() && checkUnconditionallyExactPrimitives(unboxedType(source), target) ) ||\n+                    checkUnconditionallyExactPrimitives(source, target);\n@@ -5046,1 +5046,1 @@\n-    public boolean isExactPrimitiveWidening(Type source, Type target) {\n+    public boolean checkUnconditionallyExactPrimitives(Type source, Type target) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2929,4 +2929,2 @@\n-                !(tree.expr.type.isReference() && types.isExactPrimitiveWidening(types.unboxedType(tree.expr.type), tree.pattern.type))) {\n-                if (types.isConvertible(tree.expr.type, tree.pattern.type)) {\n-                    exactnessCheck = make.Literal(BOOLEAN, 1).setType(syms.booleanType);\n-                }\n+                !(tree.expr.type.isReference() && types.checkUnconditionallyExactPrimitives(types.unboxedType(tree.expr.type), tree.pattern.type))) {\n+                exactnessCheck = make.Literal(BOOLEAN, 1).setType(syms.booleanType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -493,13 +493,0 @@\n-\n-            \/\/ The boolean flag `hasUnconditionalPattern` is true when either there\n-            \/\/ is a default case or an unconditional pattern. Consequently, we\n-            \/\/ disambiguate. The last should be the one before the unconditional or the default case.\n-            Stream<JCCase> effectiveCases = null;\n-            if (cases.stream().flatMap(c -> c.labels.stream()).noneMatch(p -> p.hasTag(Tag.DEFAULTCASELABEL))) {\n-                effectiveCases = cases.stream()\n-                        .limit(hasUnconditionalPattern ? cases.size() - 1 : cases.size());\n-            } else {\n-                effectiveCases = cases.stream()\n-                        .limit(cases.size());\n-            }\n-\n@@ -507,1 +494,1 @@\n-                    effectiveCases\n+                    cases.stream()\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"}]}