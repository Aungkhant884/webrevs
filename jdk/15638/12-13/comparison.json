{"files":[{"patch":"@@ -175,2 +175,0 @@\n-        allowPrimitivePatterns = (preview.isEnabled() || !preview.isPreview(Feature.PRIMITIVE_PATTERNS)) &&\n-                Feature.PRIMITIVE_PATTERNS.allowedInSource(source);\n@@ -205,4 +203,0 @@\n-    \/** Are primitive patterns in instanceof allowed\n-     *\/\n-    private final boolean allowPrimitivePatterns;\n-\n@@ -1690,1 +1684,1 @@\n-            boolean booleanSwitch = types.isAssignable(seltype, syms.booleanType);\n+            boolean booleanSwitch = types.isSameType(types.unboxedTypeOrType(seltype), syms.booleanType);\n@@ -1693,1 +1687,0 @@\n-            boolean errorPrimitiveSwitch = seltype.isPrimitive() && !intSwitch && !allowPrimitivePatterns;\n@@ -1696,1 +1689,1 @@\n-                !intSwitch && !errorPrimitiveSwitch) {\n+                !intSwitch) {\n@@ -1700,2 +1693,3 @@\n-                if (errorPrimitiveSwitch) {\n-                    log.error(selector.pos(), Errors.SelectorTypeNotAllowed(seltype));\n+                if (seltype.isPrimitive() && !intSwitch) {\n+                    preview.checkSourceLevel(selector.pos(), Feature.PRIMITIVE_PATTERNS);\n+                    patternSwitch = true;\n@@ -1787,13 +1781,0 @@\n-                                else if (allowPrimitivePatterns) {\n-                                    if (!stringSwitch && !intSwitch && !booleanSwitch &&\n-                                        !(types.isSameType(pattype, syms.longType) && types.isAssignable(seltype, syms.longType)) &&\n-                                        !(types.isSameType(pattype, syms.floatType) && types.isAssignable(seltype, syms.floatType)) &&\n-                                        !(types.isSameType(pattype, syms.doubleType) && types.isAssignable(seltype, syms.doubleType))) {\n-                                        log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n-                                    } else if (booleanSwitch &&\n-                                        !(types.isAssignable(pattype, syms.booleanType))) {\n-                                        log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n-                                    } else if (!constants.add(pattype.constValue())) {\n-                                        log.error(c.pos(), Errors.DuplicateCaseLabel);\n-                                    }\n-                                }\n@@ -1801,1 +1782,3 @@\n-                                    if (!stringSwitch && !intSwitch && !errorPrimitiveSwitch) {\n+                                    if (!stringSwitch && !intSwitch &&\n+                                            !(nonIntegralPrimitiveTypes.contains(pattype.getTag()) &&\n+                                              types.isSameType(types.unboxedTypeOrType(seltype), pattype))) {\n@@ -1814,0 +1797,2 @@\n+                        }  else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                            log.error(label.pos(), Errors.UnconditionalPatternAndDefault); \/\/ TODO improve error\n@@ -1823,1 +1808,3 @@\n-                        if (!primaryType.hasTag(TYPEVAR) && !(primaryType.isPrimitive() && allowPrimitivePatterns)) {\n+                        if (primaryType.isPrimitive()) {\n+                            preview.checkSourceLevel(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                        } else if (!primaryType.hasTag(TYPEVAR)) {\n@@ -1825,5 +1812,0 @@\n-                        } else if (primaryType.isPrimitive() && allowPrimitivePatterns) {\n-                            preview.warnPreview(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n-                        }\n-                        if (!errorPrimitiveSwitch) {\n-                            checkCastablePattern(pat.pos(), seltype, primaryType);\n@@ -1831,0 +1813,1 @@\n+                        checkCastablePattern(pat.pos(), seltype, primaryType);\n@@ -1853,2 +1836,1 @@\n-                                types.isSubtype(types.boxedTypeOrType(types.erasure(seltype)),\n-                                                patternType);\n+                                types.checkUnconditionallyExact(seltype, patternType);\n@@ -1860,0 +1842,2 @@\n+                            } else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                                log.error(pat.pos(), Errors.UnconditionalPatternAndDefault); \/\/ TODO improve error\n@@ -1938,0 +1922,7 @@\n+    \/\/ where\n+    static final Set<TypeTag> nonIntegralPrimitiveTypes = Set.of(\n+            LONG,\n+            FLOAT,\n+            DOUBLE,\n+            BOOLEAN\n+    );\n@@ -4154,1 +4145,3 @@\n-        if (!allowPrimitivePatterns) {\n+        if (exprtype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n@@ -4157,2 +4150,0 @@\n-        } else if (tree.pattern.type != null && exprtype.isPrimitive() && preview.isPreview(Feature.PRIMITIVE_PATTERNS)) {\n-            preview.warnPreview(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4178,6 +4169,1 @@\n-            if (!clazztype.isPrimitive()  || !allowPrimitivePatterns) {\n-                chk.validate(typeTree, env, false);\n-            }\n-        }\n-        if (!clazztype.hasTag(TYPEVAR) && !allowPrimitivePatterns) {\n-            clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n+            chk.validate(typeTree, env, false);\n@@ -4185,1 +4171,6 @@\n-        if(!clazztype.isPrimitive() || !allowPrimitivePatterns) {\n+        if (clazztype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n+            if (!clazztype.hasTag(TYPEVAR)) {\n+                clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n+            }\n@@ -4199,2 +4190,0 @@\n-        } else if (clazztype.isPrimitive() && preview.isPreview(Feature.PRIMITIVE_PATTERNS)) {\n-            preview.warnPreview(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4203,1 +4192,0 @@\n-\n@@ -4221,8 +4209,2 @@\n-            if (!allowPrimitivePatterns) {\n-                chk.basicHandler.report(pos,\n-                        diags.fragment(Fragments.NotApplicableTypes(exprType, pattType)));\n-                return false;\n-            } else {\n-                preview.warnPreview(pos, Feature.PRIMITIVE_PATTERNS);\n-                return true;\n-            }\n+            preview.checkSourceLevel(pos, Feature.PRIMITIVE_PATTERNS);\n+            return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":36,"deletions":54,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -736,4 +736,5 @@\n-            boolean exhaustive = exhausts(tree.selector, tree.cases);\n-\n-            if (tree.selector.type.hasTag(TypeTag.BOOLEAN) && exhaustive && tree.hasUnconditionalPattern) {\n-                log.error(tree, Errors.DefaultLabelNotAllowed);\n+            if (tree.hasUnconditionalPattern ||\n+                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+                tree.isExhaustive = true;\n+            } else {\n+                tree.isExhaustive = exhausts(tree.selector, tree.cases);\n@@ -742,4 +743,0 @@\n-            tree.isExhaustive = tree.hasUnconditionalPattern ||\n-                    TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) ||\n-                    exhaustive;\n-\n@@ -767,1 +764,1 @@\n-                        if (selector.type.hasTag(TypeTag.BOOLEAN)) {\n+                        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n@@ -786,1 +783,1 @@\n-            if (selector.type.hasTag(TypeTag.BOOLEAN) && booleanLiterals.size() == 2) {\n+            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.size() == 2) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.Method;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -76,1 +75,0 @@\n-import java.util.stream.Stream;\n@@ -993,4 +991,1 @@\n-        if (p instanceof JCPattern jcp && jcp.type.isPrimitive()) {\n-            return jcp.type;\n-        }\n-        return types.boxedTypeOrType(types.erasure(TreeInfo.primaryPatternType(p)));\n+        return types.erasure(TreeInfo.primaryPatternType(p));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CastConversionMatch.java:11:26: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n+CastConversionMatch.java:11:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\n","filename":"test\/langtools\/tools\/javac\/patterns\/CastConversionMatch.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,7 +30,0 @@\n-        if (p instanceof P7(byte b)); \/\/incorrect pattern type\n-        if (p instanceof P7(long l)); \/\/incorrect pattern type\n-        switch (p) {\n-            case P7(byte b) -> {} \/\/incorrect pattern type - no exception should occur\n-            case P7(long l) -> {} \/\/incorrect pattern type - no exception should occur\n-            default -> {}\n-        }\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-DeconstructionPatternErrors.java:42:37: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:44:28: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:46:42: compiler.err.expected: ';'\n-DeconstructionPatternErrors.java:46:43: compiler.err.not.stmt\n+DeconstructionPatternErrors.java:35:37: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:37:28: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:39:42: compiler.err.expected: ';'\n+DeconstructionPatternErrors.java:39:43: compiler.err.not.stmt\n@@ -23,5 +23,1 @@\n-DeconstructionPatternErrors.java:30:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-DeconstructionPatternErrors.java:33:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-26 errors\n\\ No newline at end of file\n+22 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -220,0 +220,27 @@\n+    \/\/ todo run tests\n+    int exhaustive7(Boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+            case false: return 2;  \/\/ with reminder, null, OK\n+        }\n+    }\n+\n+    int exhaustive7s(Boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;      \/\/ with reminder, null, OK\n+        };\n+    }\n+\n+    int exhaustive8(Boolean b) {\n+        switch (b) {\n+            case boolean bb: return 1;\n+        }\n+    }\n+\n+    int exhaustive9(boolean b) {\n+        switch (b) {\n+            case Boolean bb: return 1;\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatterns.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -116,0 +116,95 @@\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedDefaultStatement(boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+            case false: return 2;\n+            default: return 3;\n+        }\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedUnconditionalStatement(boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+            case false: return 2;\n+            case boolean bb: return 3; \/\/ error\n+        }\n+    }\n+\n+    void switchCombinationsNonIntegral() {\n+        float f = 0f;\n+        long l = 0L;\n+        double d = 0d;\n+        Float fB = 0F;\n+        Long lB = 0L;\n+        Double dB = 0D;\n+\n+        switch (f) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (l) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (d) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (fB) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (lB) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (dB) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+    }\n+\n+    \/\/ todo: check\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedUnconditional(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+            case boolean bb -> 3; \/\/ error\n+        };\n+    }\n+\n+    int duplicateUnconditionalWithPrimitives(int i) {\n+        return switch (i) {\n+            case int ii -> 1;\n+            case long l -> 2; \/\/ error\n+        };\n+    }\n+\n+    int booleanSingleCase(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+        };\n+    }\n+\n+    int booleanSingleCase(boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+PrimitivePatternsSwitchErrors.java:206:9: compiler.err.already.defined: kindname.method, booleanSingleCase(boolean), kindname.class, PrimitivePatternsSwitchErrors\n@@ -11,0 +12,17 @@\n+PrimitivePatternsSwitchErrors.java:113:13: compiler.err.unconditional.pattern.and.default\n+PrimitivePatternsSwitchErrors.java:121:13: compiler.err.unconditional.pattern.and.default\n+PrimitivePatternsSwitchErrors.java:129:18: compiler.err.unconditional.pattern.and.default\n+PrimitivePatternsSwitchErrors.java:142:18: compiler.err.constant.label.not.compatible: long, float\n+PrimitivePatternsSwitchErrors.java:144:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: double, float)\n+PrimitivePatternsSwitchErrors.java:150:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: float, long)\n+PrimitivePatternsSwitchErrors.java:151:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: double, long)\n+PrimitivePatternsSwitchErrors.java:156:18: compiler.err.constant.label.not.compatible: long, double\n+PrimitivePatternsSwitchErrors.java:157:18: compiler.err.constant.label.not.compatible: float, double\n+PrimitivePatternsSwitchErrors.java:163:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, java.lang.Float)\n+PrimitivePatternsSwitchErrors.java:165:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, java.lang.Float)\n+PrimitivePatternsSwitchErrors.java:171:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, java.lang.Long)\n+PrimitivePatternsSwitchErrors.java:172:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, java.lang.Long)\n+PrimitivePatternsSwitchErrors.java:177:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, java.lang.Double)\n+PrimitivePatternsSwitchErrors.java:178:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, java.lang.Double)\n+PrimitivePatternsSwitchErrors.java:189:18: compiler.err.unconditional.pattern.and.default\n+PrimitivePatternsSwitchErrors.java:196:18: compiler.err.duplicate.unconditional.pattern\n@@ -15,1 +33,2 @@\n-PrimitivePatternsSwitchErrors.java:110:16: compiler.err.default.label.not.allowed\n+PrimitivePatternsSwitchErrors.java:201:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:207:9: compiler.err.not.exhaustive.statement\n@@ -18,1 +37,1 @@\n-15 errors\n+34 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.out","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -131,0 +131,179 @@\n+    @Test\n+    public void testNestedPrimitive1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       if (r instanceof R(byte b)) {\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:28: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testNestedPrimitive2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       switch (r) {\n+                           case R(byte b) -> {}\n+                           default -> {}\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:20: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testNestedPrimitive3(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       if (r instanceof R(long l)) {\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:28: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testNestedPrimitive4(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       switch (r) {\n+                           case R(long l) -> {}\n+                           default -> {}\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:20: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitive2Reference1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(int i) {\n+                       if (i instanceof Integer j) {}\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:13: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitive2Reference2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(int i) {\n+                       switch (i) {\n+                           case Integer j -> {}\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testReference2Primitive1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Integer i) {\n+                       if (i instanceof int j) {}\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testReference2Primitive2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Integer i) {\n+                       switch (i) {\n+                           case int j -> {}\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitivePatternObject1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       if (o instanceof int j) {}\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitivePatternObject2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       switch (o) {\n+                           case int j -> {}\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n@@ -132,0 +311,4 @@\n+        doTest(base, testCode, 17, expectedErrors);\n+    }\n+\n+    private void doTest(Path base, String testCode, int sourceLevel, String... expectedErrors) throws IOException {\n@@ -141,1 +324,1 @@\n-                    .options(\"--release\", \"17\",\n+                    .options(\"--release\", \"\" + sourceLevel,\n","filename":"test\/langtools\/tools\/javac\/patterns\/SourceLevelChecks.java","additions":184,"deletions":1,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -130,6 +130,0 @@\n-    void primitivePattern(Object o) {\n-        switch (o) {\n-            case int i: break;\n-            default: break;\n-        }\n-    }\n@@ -242,10 +236,0 @@\n-    void primitiveToReference(int i) {\n-        switch (i) {\n-            case Integer j: break;\n-        }\n-    }\n-    void referenceToPrimitive(Integer i) {\n-        switch (i) {\n-            case int j: break;\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4,9 +4,11 @@\n-SwitchErrors.java:138:28: compiler.err.default.label.not.allowed\n-SwitchErrors.java:144:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:149:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:154:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:213:29: compiler.err.default.label.not.allowed\n-SwitchErrors.java:220:32: compiler.err.default.label.not.allowed\n-SwitchErrors.java:227:32: compiler.err.default.label.not.allowed\n-SwitchErrors.java:283:20: compiler.err.illegal.start.of.type\n-SwitchErrors.java:286:28: compiler.err.illegal.start.of.type\n+SwitchErrors.java:132:28: compiler.err.default.label.not.allowed\n+SwitchErrors.java:138:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:143:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:148:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:207:29: compiler.err.default.label.not.allowed\n+SwitchErrors.java:214:32: compiler.err.default.label.not.allowed\n+SwitchErrors.java:221:32: compiler.err.default.label.not.allowed\n+SwitchErrors.java:267:20: compiler.err.illegal.start.of.type\n+SwitchErrors.java:270:28: compiler.err.illegal.start.of.type\n+SwitchErrors.java:290:42: compiler.err.expected2: :, ->\n+SwitchErrors.java:299:45: compiler.err.expected2: :, ->\n@@ -14,2 +16,0 @@\n-SwitchErrors.java:315:45: compiler.err.expected2: :, ->\n-SwitchErrors.java:322:42: compiler.err.expected2: :, ->\n@@ -39,24 +39,21 @@\n-SwitchErrors.java:132:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:143:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:149:27: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:155:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:167:18: compiler.err.pattern.expected\n-SwitchErrors.java:173:78: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:179:73: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:186:21: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:197:13: compiler.err.unconditional.pattern.and.default\n-SwitchErrors.java:195:29: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:204:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:220:21: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:227:29: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:239:18: compiler.err.duplicate.unconditional.pattern\n-SwitchErrors.java:244:18: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, java.lang.Integer)\n-SwitchErrors.java:249:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:255:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:262:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:269:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:276:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:292:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n-SwitchErrors.java:294:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n-SwitchErrors.java:300:26: compiler.err.pattern.type.cannot.infer\n-SwitchErrors.java:315:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:137:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:143:27: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:149:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:161:18: compiler.err.pattern.expected\n+SwitchErrors.java:167:78: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:173:73: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:180:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:191:13: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:189:29: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:198:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:214:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:221:29: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:233:18: compiler.err.duplicate.unconditional.pattern\n+SwitchErrors.java:239:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:246:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:253:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:260:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:276:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:278:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:284:26: compiler.err.pattern.type.cannot.infer\n+SwitchErrors.java:299:21: compiler.err.invalid.case.label.combination\n@@ -73,3 +70,3 @@\n-SwitchErrors.java:159:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:232:9: compiler.err.not.exhaustive.statement\n-74 errors\n\\ No newline at end of file\n+SwitchErrors.java:153:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:226:9: compiler.err.not.exhaustive.statement\n+71 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":35,"deletions":38,"binary":false,"changes":73,"status":"modified"}]}