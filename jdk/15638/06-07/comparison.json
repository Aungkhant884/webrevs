{"files":[{"patch":"@@ -2912,37 +2912,13 @@\n-        if (tree.expr.type.equals(syms.objectType) && tree.pattern.type.isPrimitive()) {\n-            \/\/ Object v = ...\n-            \/\/ v instanceof float\n-            \/\/ =>\n-            \/\/ v instanceof Float\n-            result = make.at(tree.pos()).TypeTest(tree.expr, make.Type(types.boxedClass(tree.pattern.type).type)).setType(syms.booleanType);\n-        }\n-        else if (!(tree.expr.type.isNullOrReference() && tree.pattern.type.isReference())) {\n-            JCExpression exactnessCheck = null;\n-\n-            \/\/ translate tree.expr to resolve potential statically qualified names, etc\n-            JCExpression instanceOfExpr = translate(tree.expr);\n-\n-            \/\/ We regard Wrapper instanceof p as unconditional if the underlying primitive of Wrapper is unconditional to p.\n-            \/\/ However, we still need to emit a null check.\n-            \/\/ This branch covers true unconditionality for the underlying type as well.\n-            if (types.checkUnconditionallyExact(tree.expr.type, tree.pattern.type) &&\n-                !(tree.expr.type.isReference() && types.checkUnconditionallyExactPrimitives(types.unboxedType(tree.expr.type), tree.pattern.type))) {\n-                exactnessCheck = make.Literal(BOOLEAN, 1).setType(syms.booleanType);\n-            } else if (tree.pattern.type.isPrimitive()) {\n-                \/\/ Covers cases where the Type of the pattern is primitive e.g., v instanceof int\n-                \/\/ - case type of v is ReferenceType, null check and unbox\n-                \/\/ - case type of v is PrimitiveType\n-\n-                \/\/ rewrite instanceof if expr : wrapper reference type\n-                \/\/\n-                \/\/ Integer v = ...\n-                \/\/ if (v instanceof float)\n-                \/\/ =>\n-                \/\/ if (let tmp$123 = v; tmp$123 != null <&& if not unconditionally exact> ExactnessChecks.intToFloatExact(tmp$123.intValue()))\n-                VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n-                        names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n-                        tree.expr.type,\n-                        currentMethodSym);\n-\n-                JCStatement var = make.at(tree.pos()).VarDef(dollar_s, instanceOfExpr).setType(dollar_s.type);\n-\n+        JCExpression exactnessCheck = null;\n+        JCExpression instanceOfExpr = translate(tree.expr);\n+\n+        if (tree.expr.type.isPrimitive() || tree.pattern.type.isPrimitive()) {\n+            \/\/ preserving the side-effects of the value\n+            VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n+                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    tree.expr.type,\n+                    currentMethodSym);\n+            JCStatement var = make.at(tree.pos())\n+                    .VarDef(dollar_s, instanceOfExpr).setType(dollar_s.type);\n+\n+            if (types.checkUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n@@ -2954,19 +2930,1 @@\n-                    if (types.checkUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n-                        exactnessCheck = make.Literal(BOOLEAN, 1).setType(syms.booleanType);                                          \/\/ emit no exactness check\n-                    } else {\n-                        \/\/ if expression type is Byte, Short, Integer, ...\n-                        \/\/ an unboxing conversion followed by a widening primitive conversion\n-                        if (types.unboxedType(tree.expr.type).isPrimitive()) {\n-                            exactnessCheck = getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))); \/\/ emit the exactness call\n-                        } else {\n-                            \/\/ if expression type is a supertype: Number, ..\n-                            \/\/ a narrowing reference conversion followed by an unboxing conversion\n-                            exactnessCheck = make.at(tree.pos()).TypeTest(tree.expr, make.Type(types.boxedClass(tree.pattern.type).type)).setType(syms.booleanType);;\n-                        }\n-                    }\n-\n-                    JCBinary nullCheckFollowedByExactnessCheckCall = makeBinary(AND,\n-                            nullCheck,\n-                            exactnessCheck);\n-\n-                    exactnessCheck = make.LetExpr(List.of(var), nullCheckFollowedByExactnessCheckCall)\n+                    exactnessCheck = make.LetExpr(List.of(var), nullCheck)\n@@ -2975,11 +2933,19 @@\n-                    \/\/ rewrite instanceof if expr : primitive\n-                    \/\/ int v = ...\n-                    \/\/ if (v instanceof float)\n-                    \/\/ =>\n-                    \/\/ if (let tmp$123 = v; ExactnessChecks.intToFloatExact(tmp$123))\n-                    JCIdent argument = make.Ident(dollar_s);\n-\n-                    JCExpression exactnessCheckCall =\n-                            getExactnessCheck(tree, argument);\n-\n-                    exactnessCheck = make.LetExpr(List.of(var), exactnessCheckCall)\n+                    exactnessCheck = make\n+                            .LetExpr(List.of(var), make.Literal(BOOLEAN, 1).setType(syms.booleanType))\n+                            .setType(syms.booleanType);\n+                }\n+            }\n+            else if (tree.expr.type.isReference()) {\n+                JCExpression nullCheck = makeBinary(NE,\n+                        make.Ident(dollar_s),\n+                        makeNull());\n+                if (types.checkUnconditionallyExactPrimitives(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                    exactnessCheck = make\n+                            .LetExpr(List.of(var), nullCheck)\n+                            .setType(syms.booleanType);\n+                } else if (types.unboxedType(tree.expr.type).isPrimitive()) {\n+                    exactnessCheck = getExactnessCheck(tree,\n+                            boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type)));\n+                } else {\n+                    exactnessCheck = make.at(tree.pos())\n+                            .TypeTest(tree.expr, make.Type(types.boxedClass(tree.pattern.type).type))\n@@ -2988,0 +2954,14 @@\n+\n+                exactnessCheck = make.LetExpr(List.of(var), makeBinary(AND,\n+                        nullCheck,\n+                        exactnessCheck))\n+                        .setType(syms.booleanType);\n+            }\n+            else if (tree.expr.type.isPrimitive()) {\n+                JCIdent argument = make.Ident(dollar_s);\n+\n+                JCExpression exactnessCheckCall =\n+                        getExactnessCheck(tree, argument);\n+\n+                exactnessCheck = make.LetExpr(List.of(var), exactnessCheckCall)\n+                        .setType(syms.booleanType);\n@@ -2991,2 +2971,1 @@\n-        }\n-        else {\n+        } else {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":48,"deletions":69,"binary":false,"changes":117,"status":"modified"}]}