{"files":[{"patch":"@@ -84,1 +84,1 @@\n-#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n@@ -1121,5 +1121,0 @@\n-#if INCLUDE_JFR\n-  EventNativeLibraryLoad event;\n-  event.set_name(filename);\n-#endif\n-\n@@ -1136,1 +1131,3 @@\n-  void * result= ::dlopen(filename, dflags);\n+  void* result;\n+  JFR_ONLY(NativeLibraryLoadEvent load_event(filename, &result);)\n+  result = ::dlopen(filename, dflags);\n@@ -1142,7 +1139,0 @@\n-\n-#if INCLUDE_JFR\n-    event.set_success(true);\n-    event.set_errorMessage(nullptr);\n-    event.commit();\n-#endif\n-\n@@ -1162,6 +1152,1 @@\n-\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(error_report);\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(error_report);)\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n@@ -984,6 +985,3 @@\n-#if INCLUDE_JFR\n-  EventNativeLibraryLoad event;\n-  event.set_name(filename);\n-#endif\n-\n-  void * result= ::dlopen(filename, RTLD_LAZY);\n+  void* result;\n+  JFR_ONLY(NativeLibraryLoadEvent load_event(filename, &result);)\n+  result = ::dlopen(filename, RTLD_LAZY);\n@@ -994,5 +992,0 @@\n-#if INCLUDE_JFR\n-    event.set_success(true);\n-    event.set_errorMessage(nullptr);\n-    event.commit();\n-#endif\n@@ -1013,5 +1006,1 @@\n-#if INCLUDE_JFR\n-  event.set_success(false);\n-  event.set_errorMessage(error_report);\n-  event.commit();\n-#endif\n+  JFR_ONLY(load_event.set_error_msg(error_report);)\n@@ -1029,6 +1018,3 @@\n-#if INCLUDE_JFR\n-  EventNativeLibraryLoad event;\n-  event.set_name(filename);\n-#endif\n-\n-  void * result= ::dlopen(filename, RTLD_LAZY);\n+  void* result;\n+  JFR_ONLY(NativeLibraryLoadEvent load_event(filename, &result);)\n+  result = ::dlopen(filename, RTLD_LAZY);\n@@ -1039,5 +1025,0 @@\n-#if INCLUDE_JFR\n-    event.set_success(true);\n-    event.set_errorMessage(nullptr);\n-    event.commit();\n-#endif\n@@ -1060,5 +1041,1 @@\n-#if INCLUDE_JFR\n-  event.set_success(false);\n-  event.set_errorMessage(error_report);\n-  event.commit();\n-#endif\n+  JFR_ONLY(load_event.set_error_msg(error_report);)\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":9,"deletions":32,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n@@ -1803,9 +1804,4 @@\n-void * os::Linux::dlopen_helper(const char *filename, char *ebuf,\n-                                int ebuflen) {\n-  void * result = ::dlopen(filename, RTLD_LAZY);\n-\n-#if INCLUDE_JFR\n-  EventNativeLibraryLoad event;\n-  event.set_name(filename);\n-#endif\n-\n+void * os::Linux::dlopen_helper(const char *filename, char *ebuf, int ebuflen) {\n+  void* result;\n+  JFR_ONLY(NativeLibraryLoadEvent load_event(filename, &result);)\n+  result = ::dlopen(filename, RTLD_LAZY);\n@@ -1823,5 +1819,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(error_report);\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(error_report);)\n@@ -1831,5 +1823,0 @@\n-#if INCLUDE_JFR\n-    event.set_success(true);\n-    event.set_errorMessage(nullptr);\n-    event.commit();\n-#endif\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n@@ -728,4 +728,1 @@\n-#if INCLUDE_JFR\n-  EventNativeLibraryUnload event;\n-  event.set_name(l_path);\n-#endif\n+  JFR_ONLY(NativeLibraryUnloadEvent unload_event(l_path);)\n@@ -742,5 +739,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(true);\n-    event.set_errorMessage(nullptr);\n-    event.commit();\n-#endif\n+    JFR_ONLY(unload_event.set_result(true);)\n@@ -757,5 +750,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(error_report);\n-    event.commit();\n-#endif\n+    JFR_ONLY(unload_event.set_error_msg(error_report);)\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n@@ -1243,4 +1244,1 @@\n-#if INCLUDE_JFR\n-  EventNativeLibraryUnload event;\n-  event.set_name(name);\n-#endif\n+  JFR_ONLY(NativeLibraryUnloadEvent unload_event(name);)\n@@ -1251,5 +1249,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(true);\n-    event.set_errorMessage(nullptr);\n-    event.commit();\n-#endif\n+    JFR_ONLY(unload_event.set_result(true);)\n@@ -1262,2 +1256,0 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n@@ -1267,3 +1259,1 @@\n-    event.set_errorMessage(buf);\n-    event.commit();\n-#endif\n+    JFR_ONLY(unload_event.set_error_msg(buf);)\n@@ -1538,5 +1528,3 @@\n-#if INCLUDE_JFR\n-  EventNativeLibraryLoad event;\n-  event.set_name(name);\n-#endif\n-  void * result = LoadLibrary(name);\n+  void* result;\n+  JFR_ONLY(NativeLibraryLoadEvent load_event(name, &result);)\n+  result = LoadLibrary(name);\n@@ -1548,5 +1536,0 @@\n-#if INCLUDE_JFR\n-    event.set_success(true);\n-    event.set_errorMessage(nullptr);\n-    event.commit();\n-#endif\n@@ -1566,5 +1549,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(ebuf);\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(ebuf);)\n@@ -1581,5 +1560,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(\"open on dll file did not work\");\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(\"open on dll file did not work\");)\n@@ -1612,5 +1587,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(\"failed to get lib architecture\");\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(\"failed to get lib architecture\");)\n@@ -1661,5 +1632,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(\"lib architecture matches, but other error occured\");\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(\"lib architecture matches, but other error occured\");)\n@@ -1679,6 +1646,1 @@\n-#if INCLUDE_JFR\n-  event.set_success(false);\n-  event.set_errorMessage(ebuf);\n-  event.commit();\n-#endif\n-\n+  JFR_ONLY(load_event.set_error_msg(ebuf);)\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":12,"deletions":50,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -942,1 +942,1 @@\n-  <Event name=\"NativeLibraryLoad\" category=\"Java Virtual Machine, Runtime\" label=\"Native Library Load\" thread=\"false\" stackTrace=\"true\" startTime=\"true\"\n+  <Event name=\"NativeLibraryLoad\" category=\"Java Virtual Machine, Runtime\" label=\"Native Library Load\" thread=\"true\" stackTrace=\"true\" startTime=\"true\"\n@@ -949,1 +949,1 @@\n-  <Event name=\"NativeLibraryUnload\" category=\"Java Virtual Machine, Runtime\" label=\"Native Library Unload\" thread=\"false\" stackTrace=\"true\" startTime=\"true\"\n+  <Event name=\"NativeLibraryUnload\" category=\"Java Virtual Machine, Runtime\" label=\"Native Library Unload\" thread=\"true\" stackTrace=\"true\" startTime=\"true\"\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+JfrNativeLibraryEventBase::JfrNativeLibraryEventBase(const char* name) : _name(name), _error_msg(nullptr), _start_time(nullptr) {}\n+\n+JfrNativeLibraryEventBase::~JfrNativeLibraryEventBase() {\n+  delete _start_time;\n+}\n+\n+const char* JfrNativeLibraryEventBase::name() const {\n+  return _name;\n+}\n+\n+JfrTicksWrapper* JfrNativeLibraryEventBase::start_time() const {\n+  return _start_time;\n+}\n+\n+bool JfrNativeLibraryEventBase::has_start_time() const {\n+  return _start_time != nullptr;\n+}\n+\n+const char* JfrNativeLibraryEventBase::error_msg() const {\n+  return _error_msg;\n+}\n+\n+void JfrNativeLibraryEventBase::set_error_msg(const char* error_msg) {\n+  assert(_error_msg == nullptr, \"invariant\");\n+  _error_msg = error_msg;\n+}\n+\n+\/*\n+ * The JfrTicks value is heap allocated inside an object of type JfrTicksWrapper.\n+ * The reason is that a raw value object of type Ticks is not possible at this\n+ * location because this code runs as part of early VM bootstrap, at a moment\n+ * where Ticks support is not yet initialized.\n+ *\/\n+template <typename EventType>\n+static inline JfrTicksWrapper* allocate_start_time() {\n+  return EventType::is_enabled() ? new JfrTicksWrapper() : nullptr;\n+}\n+\n+NativeLibraryLoadEvent::NativeLibraryLoadEvent(const char* name, void** result) : JfrNativeLibraryEventBase(name), _result(result) {\n+  assert(_result != nullptr, \"invariant\");\n+  _start_time = allocate_start_time<EventNativeLibraryLoad>();\n+}\n+\n+bool NativeLibraryLoadEvent::success() const {\n+  return *_result != nullptr;\n+}\n+\n+NativeLibraryUnloadEvent::NativeLibraryUnloadEvent(const char* name) : JfrNativeLibraryEventBase(name), _result(false) {\n+  _start_time = allocate_start_time<EventNativeLibraryUnload>();\n+}\n+\n+bool NativeLibraryUnloadEvent::success() const {\n+  return _result;\n+}\n+\n+void NativeLibraryUnloadEvent::set_result(bool result) {\n+  _result = result;\n+}\n+\n+template <typename EventType, typename HelperType>\n+static void commit(HelperType& helper) {\n+  if (!helper.has_start_time()) {\n+    return;\n+  }\n+  EventType event(UNTIMED);\n+  event.set_endtime(JfrTicks::now());\n+  event.set_starttime(*helper.start_time());\n+  event.set_name(helper.name());\n+  event.set_errorMessage(helper.error_msg());\n+  event.set_success(helper.success());\n+  Thread* thread = Thread::current();\n+  assert(thread != nullptr, \"invariant\");\n+  if (thread->is_Java_thread()) {\n+    JavaThread* jt = JavaThread::cast(thread);\n+    if (jt->thread_state() != _thread_in_vm) {\n+      assert(jt->thread_state() == _thread_in_native, \"invariant\");\n+      \/\/ For a JavaThread to take a JFR stacktrace, it must be in _thread_in_vm. Can safepoint here.\n+      ThreadInVMfromNative transition(jt);\n+      event.commit();\n+      return;\n+    }\n+  }\n+  event.commit();\n+}\n+\n+NativeLibraryLoadEvent::~NativeLibraryLoadEvent() {\n+  commit<EventNativeLibraryLoad>(*this);\n+}\n+\n+NativeLibraryUnloadEvent::~NativeLibraryUnloadEvent() {\n+  commit<EventNativeLibraryUnload>(*this);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrNativeLibraryLoadEvent.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRNATIVELIBRARYLOADEVENT_HPP\n+#define SHARE_JFR_SUPPORT_JFRNATIVELIBRARYLOADEVENT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class JfrTicksWrapper;\n+\n+\/*\n+ * Helper types for populating NativeLibrary events.\n+ * Event commit is run as part of destructors.\n+ *\/\n+\n+class JfrNativeLibraryEventBase : public StackObj {\n+ protected:\n+  const char* _name;\n+  const char* _error_msg;\n+  JfrTicksWrapper* _start_time;\n+  JfrNativeLibraryEventBase(const char* name);\n+  ~JfrNativeLibraryEventBase();\n+ public:\n+  const char* name() const;\n+  const char* error_msg() const;\n+  void set_error_msg(const char* error_msg);\n+  JfrTicksWrapper* start_time() const;\n+  bool has_start_time() const;\n+};\n+\n+class NativeLibraryLoadEvent : public JfrNativeLibraryEventBase {\n+ private:\n+  void** _result;\n+ public:\n+  NativeLibraryLoadEvent(const char* name, void** result);\n+  ~NativeLibraryLoadEvent();\n+  bool success() const;\n+};\n+\n+class NativeLibraryUnloadEvent : public JfrNativeLibraryEventBase {\n+ private:\n+  bool _result;\n+ public:\n+  NativeLibraryUnloadEvent(const char* name);\n+  ~NativeLibraryUnloadEvent();\n+  bool success() const;\n+  void set_result(bool result);\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRNATIVELIBRARYLOADEVENT_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrNativeLibraryLoadEvent.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n@@ -44,0 +45,9 @@\n+\/\/ For dynamically allocated Ticks values.\n+class JfrTicksWrapper : public JfrCHeapObj {\n+ private:\n+  JfrTicks _ticks;\n+ public:\n+  JfrTicksWrapper() : _ticks(JfrTicks::now()) {}\n+  operator JfrTicks() const { return _ticks; }\n+};\n+\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTime.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import static jdk.test.lib.Asserts.assertNotNull;\n+import static jdk.test.lib.Asserts.assertNull;\n@@ -28,4 +30,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n@@ -34,0 +32,3 @@\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedStackTrace;\n@@ -49,0 +50,4 @@\n+    private final static String LOAD_CLASS_NAME = \"java.lang.System\";\n+    private final static String LOAD_METHOD_NAME = \"loadLibrary\";\n+    private final static String LIBRARY = \"instrument\";\n+    private final static String PLATFORM_LIBRARY_NAME = Platform.buildSharedLibraryName(LIBRARY);\n@@ -54,1 +59,1 @@\n-            System.loadLibrary(\"instrument\");\n+            System.loadLibrary(LIBRARY);\n@@ -57,2 +62,0 @@\n-            String expectedLib = Platform.buildSharedLibraryName(\"instrument\");\n-            boolean expectedLibFound = false;\n@@ -60,5 +63,2 @@\n-                System.out.println(\"Event:\" + event);\n-                String lib = Events.assertField(event, \"name\").notEmpty().getValue();\n-                Events.assertField(event, \"success\");\n-                if (lib.contains(expectedLib)) {\n-                    expectedLibFound = true;\n+                if (validate(event)) {\n+                    return;\n@@ -67,1 +67,19 @@\n-            assertTrue(expectedLibFound, \"Missing library \" + expectedLib);\n+            assertTrue(false, \"Missing library \" + PLATFORM_LIBRARY_NAME);\n+        }\n+    }\n+\n+    private static boolean validate(RecordedEvent event) {\n+        assertTrue(event.getEventType().getName().equals(EVENT_NAME));\n+        String lib = Events.assertField(event, \"name\").notEmpty().getValue();\n+        System.out.println(lib);\n+        if (!lib.endsWith(PLATFORM_LIBRARY_NAME)) {\n+            return false;\n+        }\n+        assertTrue(Events.assertField(event, \"success\").getValue());\n+        assertNull(Events.assertField(event, \"errorMessage\").getValue());\n+        RecordedStackTrace stacktrace = event.getStackTrace();\n+        assertNotNull(stacktrace);\n+        for (RecordedFrame f : stacktrace.getFrames()) {\n+            if (match(f.getMethod())) {\n+                return true;\n+            }\n@@ -69,0 +87,7 @@\n+        return false;\n+    }\n+\n+    private static boolean match(RecordedMethod method) {\n+        assertNotNull(method);\n+        System.out.println(method.getType().getName() + \".\" + method.getName());\n+        return method.getName().equals(LOAD_METHOD_NAME) && method.getType().getName().equals(LOAD_CLASS_NAME);\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeLibraryLoadEvent.java","additions":38,"deletions":13,"binary":false,"changes":51,"status":"modified"}]}