{"files":[{"patch":"@@ -228,0 +228,1 @@\n+        java.naming,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,3 @@\n+import java.lang.ref.Cleaner.Cleanable;\n+import jdk.internal.ref.CleanerFactory;\n+\n@@ -45,3 +48,0 @@\n-    private boolean cleaned = false;\n-    private LdapResult res;\n-    private LdapClient enumClnt;\n@@ -52,1 +52,1 @@\n-    protected LdapCtx homeCtx;\n+\n@@ -56,0 +56,35 @@\n+    \/* This class maintains the pieces of state that need (or are needed for)\n+     * cleanup.\n+     *\/\n+    private static class EnumCtx implements Runnable {\n+        private LdapCtx homeCtx;\n+        private LdapResult res;\n+        private LdapClient enumClnt;\n+\n+        private EnumCtx(LdapCtx homeCtx, LdapResult answer, LdapClient client) {\n+            this.homeCtx = homeCtx;\n+            this.res = answer;\n+            this.enumClnt = client;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (enumClnt != null) {\n+                assert homeCtx != null;\n+                enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n+                enumClnt = null;\n+            }\n+            if (homeCtx != null) {\n+                homeCtx.decEnumCount();\n+                homeCtx = null;\n+            }\n+        }\n+    }\n+\n+    private final EnumCtx enumCtx;\n+    private final Cleanable cleanable;\n+\n+    \/\/ Subclasses interact directly with the LdapCtx. This method provides\n+    \/\/ access to the LdapCtx in the CleaningAction.\n+    protected final LdapCtx homeCtx() { return enumCtx.homeCtx; }\n+\n@@ -87,1 +122,0 @@\n-            res = answer;\n@@ -97,0 +131,1 @@\n+            this.enumCtx = new EnumCtx(homeCtx, answer, homeCtx.clnt);\n@@ -98,3 +133,2 @@\n-            this.homeCtx = homeCtx;\n-            homeCtx.incEnumCount();\n-            enumClnt = homeCtx.clnt; \/\/ remember\n+            this.enumCtx.homeCtx.incEnumCount();\n+            this.cleanable = CleanerFactory.cleaner().register(this, enumCtx);\n@@ -130,2 +164,2 @@\n-        res = homeCtx.getSearchReply(enumClnt, res);\n-        if (res == null) {\n+        enumCtx.res = homeCtx().getSearchReply(enumCtx.enumClnt, enumCtx.res);\n+        if (enumCtx.res == null) {\n@@ -136,1 +170,1 @@\n-        entries = res.entries;\n+        entries = enumCtx.res.entries;\n@@ -142,3 +176,3 @@\n-        if ((res.status != LdapClient.LDAP_SUCCESS) ||\n-            ((res.status == LdapClient.LDAP_SUCCESS) &&\n-                (res.referrals != null))) {\n+        if ((enumCtx.res.status != LdapClient.LDAP_SUCCESS) ||\n+            ((enumCtx.res.status == LdapClient.LDAP_SUCCESS) &&\n+                (enumCtx.res.referrals != null))) {\n@@ -148,1 +182,1 @@\n-                homeCtx.processReturnCode(res, listArg);\n+                homeCtx().processReturnCode(enumCtx.res, listArg);\n@@ -157,1 +191,1 @@\n-        if (res.refEx != null) {\n+        if (enumCtx.res.refEx != null) {\n@@ -159,1 +193,1 @@\n-                refEx = res.refEx;\n+                refEx = enumCtx.res.refEx;\n@@ -161,1 +195,1 @@\n-                refEx = refEx.appendUnprocessedReferrals(res.refEx);\n+                refEx = refEx.appendUnprocessedReferrals(enumCtx.res.refEx);\n@@ -163,1 +197,1 @@\n-            res.refEx = null; \/\/ reset\n+            enumCtx.res.refEx = null; \/\/ reset\n@@ -166,2 +200,2 @@\n-        if (res.resControls != null) {\n-            homeCtx.respCtls = res.resControls;\n+        if (enumCtx.res.resControls != null) {\n+            homeCtx().respCtls = enumCtx.res.resControls;\n@@ -318,1 +352,1 @@\n-            if (homeCtx.handleReferrals == LdapClient.LDAP_REF_THROW) {\n+            if (homeCtx().handleReferrals == LdapClient.LDAP_REF_THROW) {\n@@ -327,1 +361,1 @@\n-                    homeCtx.envprops, homeCtx.reqCtls);\n+                    homeCtx().envprops, homeCtx().reqCtls);\n@@ -366,1 +400,1 @@\n-        homeCtx.decEnumCount();\n+        homeCtx().decEnumCount();\n@@ -369,2 +403,2 @@\n-        homeCtx = ne.homeCtx;\n-        enumClnt = ne.enumClnt;\n+        enumCtx.homeCtx = ne.enumCtx.homeCtx;\n+        enumCtx.enumClnt = ne.enumCtx.enumClnt;\n@@ -372,4 +406,5 @@\n-        \/\/ Do this to prevent referral enumeration (ne) from decrementing\n-        \/\/ enum count because we'll be doing that here from this\n-        \/\/ enumeration.\n-        ne.homeCtx = null;\n+        \/\/ ne's homeCtx is now referred to by state.homeCtx; we will decrement\n+        \/\/ its enum count later (via cleanup() or Cleaner).\n+        \/\/ Clear ne's reference to homeCtx so ne's Cleaner doesn't *also*\n+        \/\/ decrement the count.\n+        ne.enumCtx.homeCtx = null;\n@@ -380,1 +415,1 @@\n-        res = ne.res;\n+        enumCtx.res = ne.enumCtx.res;\n@@ -386,5 +421,0 @@\n-    @SuppressWarnings(\"removal\")\n-    protected final void finalize() {\n-        cleanup();\n-    }\n-\n@@ -392,12 +422,2 @@\n-        if (cleaned) return; \/\/ been there; done that\n-\n-        if(enumClnt != null) {\n-            enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n-        }\n-\n-        enumClnt = null;\n-        cleaned = true;\n-        if (homeCtx != null) {\n-            homeCtx.decEnumCount();\n-            homeCtx = null;\n-        }\n+        \/\/ Run the cleaning action (if it has not run already)\n+        cleanable.clean();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/AbstractLdapNamingEnumeration.java","additions":69,"deletions":49,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-            obj = new LdapCtx(homeCtx, dn);\n+            obj = new LdapCtx(homeCtx(), dn);\n@@ -79,2 +79,2 @@\n-            obj = DirectoryManager.getObjectInstance(obj, cn, homeCtx,\n-                homeCtx.envprops, attrs);\n+            obj = DirectoryManager.getObjectInstance(obj, cn, homeCtx(),\n+                homeCtx().envprops, attrs);\n@@ -96,1 +96,1 @@\n-                                homeCtx.convertControls(respCtls));\n+                                homeCtx().convertControls(respCtls));\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapBindingEnumeration.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-                        homeCtx.convertControls(respCtls));\n+                        homeCtx().convertControls(respCtls));\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapNamingEnumeration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-                relHome = parsed.getSuffix(homeCtx.currentParsedDN.size()).toString();\n+                relHome = parsed.getSuffix(homeCtx().currentParsedDN.size()).toString();\n@@ -89,2 +89,2 @@\n-                    LdapURL.toUrlString(homeCtx.hostname, homeCtx.port_number,\n-                    dn, homeCtx.hasLdapsScheme);\n+                    LdapURL.toUrlString(homeCtx().hostname, homeCtx().port_number,\n+                    dn, homeCtx().hasLdapsScheme);\n@@ -96,2 +96,2 @@\n-                LdapURL.toUrlString(homeCtx.hostname, homeCtx.port_number,\n-                dn, homeCtx.hasLdapsScheme);\n+                LdapURL.toUrlString(homeCtx().hostname, homeCtx().port_number,\n+                dn, homeCtx().hasLdapsScheme);\n@@ -115,1 +115,1 @@\n-        homeCtx.setParents(attrs, rcn);\n+        homeCtx().setParents(attrs, rcn);\n@@ -131,1 +131,1 @@\n-                obj = new LdapCtx(homeCtx, dn);\n+                obj = new LdapCtx(homeCtx(), dn);\n@@ -138,2 +138,2 @@\n-                    obj, rcn, (relative ? homeCtx : null),\n-                    homeCtx.envprops, attrs);\n+                    obj, rcn, (relative ? homeCtx() : null),\n+                    homeCtx().envprops, attrs);\n@@ -181,1 +181,1 @@\n-                relative, homeCtx.convertControls(respCtls));\n+                relative, homeCtx().convertControls(respCtls));\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapSearchEnumeration.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8283660\n+ * @summary Verify the AbstractLdapNamingEnumeration Cleaner doesn't keep the\n+ *          enumeration reachable\n+ * @modules java.naming\/com.sun.jndi.ldap\n+ * @library \/test\/lib ..\/lib\/ \/javax\/naming\/module\/src\/test\/test\/\n+ * @build LDAPServer LDAPTestUtils\n+ * @run main\/othervm LdapEnumeration\n+ *\/\n+\n+import javax.naming.NamingEnumeration;\n+import javax.naming.directory.Attribute;\n+import javax.naming.directory.Attributes;\n+import javax.naming.directory.BasicAttribute;\n+import javax.naming.directory.BasicAttributes;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+import javax.naming.directory.SearchControls;\n+import javax.naming.directory.SearchResult;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.SocketAddress;\n+import java.util.Hashtable;\n+import java.util.WeakHashMap;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+\/*\n+ * This test is a copy of com\/sun\/jndi\/ldap\/blits\/AddTests\/AddNewEntry.java,\n+ * altered to confirm that the NamingEnumeration<SearchResult> is not prevented\n+ * from being collected by the Cleaner code in AbstractLdapNamingEnumeration.\n+ *\/\n+public class LdapEnumeration {\n+    static WeakHashMap whm = new WeakHashMap();\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create unbound server socket\n+        ServerSocket serverSocket = new ServerSocket();\n+\n+        \/\/ Bind it to the loopback address\n+        SocketAddress sockAddr = new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0);\n+        serverSocket.bind(sockAddr);\n+\n+        \/\/ Construct the provider URL for LDAPTestUtils\n+        String providerURL = URIBuilder.newBuilder()\n+                .scheme(\"ldap\")\n+                .loopback()\n+                .port(serverSocket.getLocalPort())\n+                .buildUnchecked().toString();\n+\n+        Hashtable<Object, Object> env;\n+\n+        \/\/ initialize test\n+        env = LDAPTestUtils.initEnv(serverSocket, providerURL,\n+                         LdapEnumeration.class.getName(), args, true);\n+\n+        \/* Build attribute set *\/\n+        String[] ids = { \"objectClass\", \"sn\", \"cn\", \"telephoneNumber\", \"mail\",\n+                \"description\", \"uid\" };\n+        Attribute objectClass = new BasicAttribute(ids[0]);\n+        objectClass.add(\"top\");\n+        objectClass.add(\"person\");\n+        objectClass.add(\"organizationalPerson\");\n+        objectClass.add(\"inetOrgPerson\");\n+\n+        Attribute sn = new BasicAttribute(ids[1], \"Powers\");\n+        Attribute cn = new BasicAttribute(ids[2],\n+                \"Austin \\\\\\\"Danger\\\\\\\" Powers\");\n+        Attribute telephoneNumber = new BasicAttribute(ids[3], \"+44 582 10101\");\n+        Attribute mail = new BasicAttribute(ids[4], \"secret_agent_man@imc.org\");\n+        Attribute description = new BasicAttribute(ids[5], \"Yea Baby!!\");\n+        description.add(\"Behave!\");\n+        Attribute uid = new BasicAttribute(ids[6], \"secret_agent_man\");\n+\n+        Attributes attrs = new BasicAttributes();\n+        attrs.put(objectClass);\n+        attrs.put(sn);\n+        attrs.put(cn);\n+        attrs.put(telephoneNumber);\n+        attrs.put(mail);\n+        attrs.put(description);\n+        attrs.put(uid);\n+\n+        DirContext ctx = null;\n+        String[] bases = new String[] { (String) env.get(\"client\"),\n+                (String) env.get(\"vendor\"), \"Add\" };\n+        String baseDN = LDAPTestUtils.buildDN(bases, (String) env.get(\"root\"));\n+        String entryDN = \"cn=Austin Powers,\" + baseDN;\n+        String expect = \"\"; \/\/ relative name\n+\n+        try {\n+            \/\/ connect to server\n+            ctx = new InitialDirContext(env);\n+\n+            \/\/ add entry\n+            ctx.createSubcontext(entryDN, attrs);\n+\n+            \/\/ specify base search\n+            SearchControls constraints = new SearchControls();\n+            constraints.setSearchScope(SearchControls.OBJECT_SCOPE);\n+\n+            NamingEnumeration<SearchResult> results = ctx\n+                    .search(entryDN, \"(objectclass=*)\", constraints);\n+\n+            if (!\"LdapSearchEnumeration\".equals(results.getClass().getSimpleName())) {\n+                throw new RuntimeException(\"Unexpected results class: \" + results.getClass());\n+            }\n+\n+            whm.put(results, null);\n+            results = null;\n+            \/\/ Run GC to run the Cleaner and collect 'results'\n+            for (int i = 0; i < 100; i++) {\n+                System.gc();\n+                Thread.sleep(1);\n+            }\n+            \/\/ If the Cleaner holds a reference to 'results', it won't be cleared from the map\n+            if (whm.size() > 0) {\n+                throw new RuntimeException(\"NamingEnumeration is still strongly reachable\");\n+            }\n+\n+        } finally {\n+            LDAPTestUtils.cleanupSubcontext(ctx, entryDN);\n+            LDAPTestUtils.cleanup(ctx);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/CleanerTests\/LdapEnumeration.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/CleanerTests\/LdapEnumeration.ldap","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/com\/sun\/jndi\/ldap\/blits\/AddTests\/AddNewEntry.ldap","status":"copied"}]}