{"files":[{"patch":"@@ -58,0 +58,44 @@\n+    \/* This class maintains the pieces of state that need to be cleaned up (or\n+     * are needed for cleanup). It gets registered with Cleaner to perform cleanup.\n+     * Because the state is mutable, synchronization is used to ensure that changes\n+     * made on the program thread are seen by the cleanup thread.\n+     *\/\n+    private static class EnumCtx implements Runnable {\n+        \/\/ *ONLY* update these variables using the setter methods below\n+        private LdapCtx homeCtx;\n+        private LdapResult res;\n+        private LdapClient enumClnt;\n+\n+        private EnumCtx(LdapCtx homeCtx, LdapResult answer, LdapClient client) {\n+            this.homeCtx = homeCtx;\n+            this.res = answer;\n+            this.enumClnt = client;\n+        }\n+\n+        \/\/ Synchronization provides memory visibility between threads, but isn't\n+        \/\/ needed to prevent race conditions. The reachabilityFences prevent the\n+        \/\/ cleaner thread from running and accessing the EnumCtx while a program is\n+        \/\/ still using it. Thus, only the setters are synchronized.\n+        private synchronized void setRes(LdapResult newRes) { this.res = newRes; }\n+        private synchronized void setHomeCtx(LdapCtx newCtx) { this.homeCtx = newCtx; }\n+        private synchronized void setEnumClnt(LdapClient newClnt) { this.enumClnt = newClnt; }\n+\n+        LdapResult getRes() { return this.res; }\n+        LdapCtx getHomeCtx() { return this.homeCtx; }\n+        LdapClient getEnumClnt() { return this.enumClnt; }\n+\n+        @Override\n+        public synchronized void run() {\n+            if (enumClnt != null) {\n+                if (homeCtx != null) {\n+                    enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n+                }\n+                enumClnt = null;\n+            }\n+            if (homeCtx != null) {\n+                homeCtx.decEnumCount();\n+                homeCtx = null;\n+            }\n+        }\n+    }\n+\n@@ -107,1 +151,1 @@\n-            homeCtx.incEnumCount();\n+            this.enumCtx.homeCtx.incEnumCount();\n@@ -422,45 +466,0 @@\n-\n-\/* This class maintains the pieces of state that need to be cleaned up (or\n- * are needed for cleanup). It gets registered with Cleaner to perform cleanup.\n- * Because the state is mutable, synchronization is used to ensure that changes\n- * made on the program thread are seen by the cleanup thread.\n- * It is a top-level (not nested) class to prevent access to private members,\n- * enforcing use of the setters.\n- *\/\n-class EnumCtx implements Runnable {\n-    private LdapCtx homeCtx;\n-    private LdapResult res;\n-    private LdapClient enumClnt;\n-\n-    EnumCtx(LdapCtx homeCtx, LdapResult answer, LdapClient client) {\n-        this.homeCtx = homeCtx;\n-        this.res = answer;\n-        this.enumClnt = client;\n-    }\n-\n-    \/\/ Synchronization provides memory visibility between threads, but isn't\n-    \/\/ needed to prevent race conditions. The reachabilityFences prevent the\n-    \/\/ cleaner thread from running and accessing the EnumCtx while a program is\n-    \/\/ still using it. Thus, only the setters are synchronized.\n-    synchronized void setRes(LdapResult newRes) { this.res = newRes; }\n-    synchronized void setHomeCtx(LdapCtx newCtx) { this.homeCtx = newCtx; }\n-    synchronized void setEnumClnt(LdapClient newClnt) { this.enumClnt = newClnt; }\n-\n-    LdapResult getRes() { return this.res; }\n-    LdapCtx getHomeCtx() { return this.homeCtx; }\n-    LdapClient getEnumClnt() { return this.enumClnt; }\n-\n-    @Override\n-    public synchronized void run() {\n-        if (enumClnt != null) {\n-            if (homeCtx != null) {\n-                enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n-            }\n-            enumClnt = null;\n-        }\n-        if (homeCtx != null) {\n-            homeCtx.decEnumCount();\n-            homeCtx = null;\n-        }\n-    }\n-}\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/AbstractLdapNamingEnumeration.java","additions":45,"deletions":46,"binary":false,"changes":91,"status":"modified"}]}