{"files":[{"patch":"@@ -58,36 +58,0 @@\n-    \/* This class maintains the pieces of state that need to be cleaned up (or\n-     * are needed for cleanup). It gets registered with Cleaner to perform cleanup.\n-     * Because the state is mutable, synchronization is used to ensure that all\n-     * updates made by the program thread are seen by the cleanup thread.\n-     *\/\n-    private static class EnumCtx implements Runnable {\n-        \/\/ Only update these variables using the set* methods below\n-        private LdapCtx homeCtx;\n-        private LdapResult res;\n-        private LdapClient enumClnt;\n-\n-        private EnumCtx(LdapCtx homeCtx, LdapResult answer, LdapClient client) {\n-            this.homeCtx = homeCtx;\n-            this.res = answer;\n-            this.enumClnt = client;\n-        }\n-\n-        private synchronized void setRes(LdapResult newRes) { this.res = newRes; }\n-        private synchronized void setHomeCtx(LdapCtx newCtx) { this.homeCtx = newCtx; }\n-        private synchronized void setEnumClnt(LdapClient newClnt) { this.enumClnt = newClnt; }\n-\n-        @Override\n-        public synchronized void run() {\n-            if (enumClnt != null) {\n-                if (homeCtx != null) {\n-                    enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n-                }\n-                enumClnt = null;\n-            }\n-            if (homeCtx != null) {\n-                homeCtx.decEnumCount();\n-                homeCtx = null;\n-            }\n-        }\n-    }\n-\n@@ -99,1 +63,1 @@\n-    protected final LdapCtx homeCtx() { return enumCtx.homeCtx; }\n+    protected final LdapCtx getHomeCtx() { return enumCtx.getHomeCtx(); }\n@@ -143,1 +107,1 @@\n-            this.enumCtx.homeCtx.incEnumCount();\n+            homeCtx.incEnumCount();\n@@ -174,3 +138,4 @@\n-            LdapResult newRes = homeCtx().getSearchReply(enumCtx.enumClnt, enumCtx.res);\n-            enumCtx.setRes(newRes);\n-            if (enumCtx.res == null) {\n+            LdapCtx homeCtx = getHomeCtx();\n+            LdapResult res = homeCtx.getSearchReply(enumCtx.getEnumClnt(), enumCtx.getRes());\n+            enumCtx.setRes(res);\n+            if (res == null) {\n@@ -181,1 +146,1 @@\n-            entries = enumCtx.res.entries;\n+            entries = res.entries;\n@@ -187,3 +152,3 @@\n-            if ((enumCtx.res.status != LdapClient.LDAP_SUCCESS) ||\n-                ((enumCtx.res.status == LdapClient.LDAP_SUCCESS) &&\n-                    (enumCtx.res.referrals != null))) {\n+            if ((res.status != LdapClient.LDAP_SUCCESS) ||\n+                ((res.status == LdapClient.LDAP_SUCCESS) &&\n+                    (res.referrals != null))) {\n@@ -193,1 +158,1 @@\n-                    homeCtx().processReturnCode(enumCtx.res, listArg);\n+                    homeCtx.processReturnCode(res, listArg);\n@@ -202,1 +167,1 @@\n-            if (enumCtx.res.refEx != null) {\n+            if (res.refEx != null) {\n@@ -204,1 +169,1 @@\n-                    refEx = enumCtx.res.refEx;\n+                    refEx = res.refEx;\n@@ -206,1 +171,1 @@\n-                    refEx = refEx.appendUnprocessedReferrals(enumCtx.res.refEx);\n+                    refEx = refEx.appendUnprocessedReferrals(res.refEx);\n@@ -208,1 +173,1 @@\n-                enumCtx.res.refEx = null; \/\/ reset\n+                res.refEx = null; \/\/ reset\n@@ -211,2 +176,2 @@\n-            if (enumCtx.res.resControls != null) {\n-                homeCtx().respCtls = enumCtx.res.resControls;\n+            if (res.resControls != null) {\n+                homeCtx.respCtls = res.resControls;\n@@ -367,1 +332,2 @@\n-                if (homeCtx().handleReferrals == LdapClient.LDAP_REF_THROW) {\n+                LdapCtx homeCtx = getHomeCtx();\n+                if (homeCtx.handleReferrals == LdapClient.LDAP_REF_THROW) {\n@@ -376,1 +342,1 @@\n-                        homeCtx().envprops, homeCtx().reqCtls);\n+                        homeCtx.envprops, homeCtx.reqCtls);\n@@ -420,1 +386,1 @@\n-            homeCtx().decEnumCount();\n+            getHomeCtx().decEnumCount();\n@@ -423,2 +389,2 @@\n-            enumCtx.setHomeCtx(ne.enumCtx.homeCtx);\n-            enumCtx.setEnumClnt(ne.enumCtx.enumClnt);\n+            enumCtx.setHomeCtx(ne.enumCtx.getHomeCtx());\n+            enumCtx.setEnumClnt(ne.enumCtx.getEnumClnt());\n@@ -435,1 +401,1 @@\n-            enumCtx.setRes(ne.enumCtx.res);\n+            enumCtx.setRes(ne.enumCtx.getRes());\n@@ -456,0 +422,45 @@\n+\n+\/* This class maintains the pieces of state that need to be cleaned up (or\n+ * are needed for cleanup). It gets registered with Cleaner to perform cleanup.\n+ * Because the state is mutable, synchronization is used to ensure that changes\n+ * made on the program thread are seen by the cleanup thread.\n+ * It is a top-level (not nested) class to prevent access to private members,\n+ * enforcing use of the setters.\n+ *\/\n+class EnumCtx implements Runnable {\n+    private LdapCtx homeCtx;\n+    private LdapResult res;\n+    private LdapClient enumClnt;\n+\n+    EnumCtx(LdapCtx homeCtx, LdapResult answer, LdapClient client) {\n+        this.homeCtx = homeCtx;\n+        this.res = answer;\n+        this.enumClnt = client;\n+    }\n+\n+    \/\/ Synchronization provides memory visibility between threads, but isn't\n+    \/\/ needed to prevent race conditions. The reachabilityFences prevent the\n+    \/\/ cleaner thread from running and accessing the EnumCtx while a program is\n+    \/\/ still using it. Thus, only the setters are synchronized.\n+    synchronized void setRes(LdapResult newRes) { this.res = newRes; }\n+    synchronized void setHomeCtx(LdapCtx newCtx) { this.homeCtx = newCtx; }\n+    synchronized void setEnumClnt(LdapClient newClnt) { this.enumClnt = newClnt; }\n+\n+    LdapResult getRes() { return this.res; }\n+    LdapCtx getHomeCtx() { return this.homeCtx; }\n+    LdapClient getEnumClnt() { return this.enumClnt; }\n+\n+    @Override\n+    public synchronized void run() {\n+        if (enumClnt != null) {\n+            if (homeCtx != null) {\n+                enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n+            }\n+            enumClnt = null;\n+        }\n+        if (homeCtx != null) {\n+            homeCtx.decEnumCount();\n+            homeCtx = null;\n+        }\n+    }\n+}\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/AbstractLdapNamingEnumeration.java","additions":69,"deletions":58,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+            LdapCtx homeCtx = getHomeCtx();\n@@ -73,1 +74,1 @@\n-                obj = new LdapCtx(homeCtx(), dn);\n+                obj = new LdapCtx(homeCtx, dn);\n@@ -80,2 +81,2 @@\n-                obj = DirectoryManager.getObjectInstance(obj, cn, homeCtx(),\n-                    homeCtx().envprops, attrs);\n+                obj = DirectoryManager.getObjectInstance(obj, cn, homeCtx,\n+                    homeCtx.envprops, attrs);\n@@ -97,1 +98,1 @@\n-                                     homeCtx().convertControls(respCtls));\n+                                     homeCtx.convertControls(respCtls));\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapBindingEnumeration.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+            LdapCtx homeCtx = getHomeCtx();\n@@ -66,1 +67,1 @@\n-                        homeCtx().convertControls(respCtls));\n+                        homeCtx.convertControls(respCtls));\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapNamingEnumeration.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+            LdapCtx homeCtx = getHomeCtx();\n@@ -86,1 +87,1 @@\n-                    relHome = parsed.getSuffix(homeCtx().currentParsedDN.size()).toString();\n+                    relHome = parsed.getSuffix(homeCtx.currentParsedDN.size()).toString();\n@@ -90,2 +91,2 @@\n-                        LdapURL.toUrlString(homeCtx().hostname, homeCtx().port_number,\n-                        dn, homeCtx().hasLdapsScheme);\n+                        LdapURL.toUrlString(homeCtx.hostname, homeCtx.port_number,\n+                        dn, homeCtx.hasLdapsScheme);\n@@ -97,2 +98,2 @@\n-                    LdapURL.toUrlString(homeCtx().hostname, homeCtx().port_number,\n-                    dn, homeCtx().hasLdapsScheme);\n+                    LdapURL.toUrlString(homeCtx.hostname, homeCtx.port_number,\n+                    dn, homeCtx.hasLdapsScheme);\n@@ -116,1 +117,1 @@\n-            homeCtx().setParents(attrs, rcn);\n+            homeCtx.setParents(attrs, rcn);\n@@ -132,1 +133,1 @@\n-                    obj = new LdapCtx(homeCtx(), dn);\n+                    obj = new LdapCtx(homeCtx, dn);\n@@ -139,2 +140,2 @@\n-                        obj, rcn, (relative ? homeCtx() : null),\n-                        homeCtx().envprops, attrs);\n+                        obj, rcn, (relative ? homeCtx : null),\n+                        homeCtx.envprops, attrs);\n@@ -182,1 +183,1 @@\n-                    relative, homeCtx().convertControls(respCtls));\n+                    relative, homeCtx.convertControls(respCtls));\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapSearchEnumeration.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n- * altered to confirm that the NamingEnumeration<SearchResult> is not prevented\n- * from being collected by the Cleaner code in AbstractLdapNamingEnumeration.\n+ * altered to confirm correct operation of the NamingEnumeration<SearchResult>\n+ * cleaning action.\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/CleanerTests\/LdapEnumeration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}