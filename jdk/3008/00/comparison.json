{"files":[{"patch":"@@ -4146,2 +4146,2 @@\n-          Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);\n-          ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);\n+          \/\/ Clones are always tightly coupled.\n+          ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -664,0 +664,3 @@\n+    \/\/ A tightly coupled arraycopy of reference types might touch uninitialized memory\n+    \/\/ which will make cardbarriers fail.\n+    bool may_be_uninitialized = dest_uninitialized || (ac->is_alloc_tightly_coupled() && !ReduceInitialCardMarks && is_reference_type(basic_elem_type));\n@@ -667,1 +670,1 @@\n-                                                         ConvI2X(copy_length), dest_uninitialized);\n+                                                         ConvI2X(copy_length), may_be_uninitialized);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -518,2 +518,2 @@\n-#define RETURN_STUB_PARM(xxx_arraycopy, parm) {           \\\n-  name = #xxx_arraycopy; \\\n+#define RETURN_STUB_PARM(xxx_arraycopy, parm) { \\\n+  name = parm ? #xxx_arraycopy \"_uninit\": #xxx_arraycopy; \\\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}