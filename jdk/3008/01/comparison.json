{"files":[{"patch":"@@ -4146,2 +4146,2 @@\n-          Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);\n-          ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);\n+          \/\/ Clones are always tightly coupled.\n+          ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -384,2 +384,3 @@\n-  Node* original_dest      = dest;\n-  bool  dest_uninitialized = false;\n+  Node* original_dest = dest;\n+  bool  dest_needs_zeroing   = false;\n+  bool  acopy_to_uninitialized = false;\n@@ -397,14 +398,22 @@\n-      && _igvn.find_int_con(alloc->in(AllocateNode::ALength), 1) > 0\n-      && alloc->maybe_set_complete(&_igvn)) {\n-    \/\/ \"You break it, you buy it.\"\n-    InitializeNode* init = alloc->initialization();\n-    assert(init->is_complete(), \"we just did this\");\n-    init->set_complete_with_arraycopy();\n-    assert(dest->is_CheckCastPP(), \"sanity\");\n-    assert(dest->in(0)->in(0) == init, \"dest pinned\");\n-    adr_type = TypeRawPtr::BOTTOM;  \/\/ all initializations are into raw memory\n-    \/\/ From this point on, every exit path is responsible for\n-    \/\/ initializing any non-copied parts of the object to zero.\n-    \/\/ Also, if this flag is set we make sure that arraycopy interacts properly\n-    \/\/ with G1, eliding pre-barriers. See CR 6627983.\n-    dest_uninitialized = true;\n+      && _igvn.find_int_con(alloc->in(AllocateNode::ALength), 1) > 0) {\n+    assert(ac->is_alloc_tightly_coupled(), \"sanity\");\n+    \/\/ acopy to uninitialized tightly coupled allocations\n+    \/\/ needs zeroing outside the copy range\n+    \/\/ and the acopy itself will be to uninitialized memory\n+    acopy_to_uninitialized = true;\n+    if (alloc->maybe_set_complete(&_igvn)) {\n+      \/\/ \"You break it, you buy it.\"\n+      InitializeNode* init = alloc->initialization();\n+      assert(init->is_complete(), \"we just did this\");\n+      init->set_complete_with_arraycopy();\n+      assert(dest->is_CheckCastPP(), \"sanity\");\n+      assert(dest->in(0)->in(0) == init, \"dest pinned\");\n+      adr_type = TypeRawPtr::BOTTOM;  \/\/ all initializations are into raw memory\n+      \/\/ From this point on, every exit path is responsible for\n+      \/\/ initializing any non-copied parts of the object to zero.\n+      \/\/ Also, if this flag is set we make sure that arraycopy interacts properly\n+      \/\/ with G1, eliding pre-barriers. See CR 6627983.\n+      dest_needs_zeroing = true;\n+    } else {\n+      \/\/ dest_need_zeroing = false;\n+    }\n@@ -412,4 +421,5 @@\n-    \/\/ No zeroing elimination here.\n-    alloc             = NULL;\n-    \/\/original_dest   = dest;\n-    \/\/dest_uninitialized = false;\n+    \/\/ No zeroing elimination needed here.\n+    alloc                  = NULL;\n+    acopy_to_uninitialized = false;\n+    \/\/original_dest        = dest;\n+    \/\/dest_needs_zeroing   = false;\n@@ -449,1 +459,1 @@\n-    assert(!dest_uninitialized, \"\");\n+    assert(!dest_needs_zeroing, \"\");\n@@ -453,1 +463,1 @@\n-                                          copy_length, dest_uninitialized);\n+                                          copy_length, acopy_to_uninitialized);\n@@ -474,1 +484,1 @@\n-    if (dest_uninitialized) {\n+    if (dest_needs_zeroing) {\n@@ -509,1 +519,1 @@\n-  if (!(*ctrl)->is_top() && dest_uninitialized) {\n+  if (!(*ctrl)->is_top() && dest_needs_zeroing) {\n@@ -550,1 +560,1 @@\n-                                         dest_size, dest_uninitialized);\n+                                         dest_size, acopy_to_uninitialized);\n@@ -638,1 +648,1 @@\n-                                                ConvI2X(copy_length), dest_uninitialized);\n+                                                ConvI2X(copy_length), acopy_to_uninitialized);\n@@ -663,1 +673,0 @@\n-\n@@ -667,1 +676,1 @@\n-                                                         ConvI2X(copy_length), dest_uninitialized);\n+                                                         ConvI2X(copy_length), acopy_to_uninitialized);\n@@ -756,1 +765,1 @@\n-    if (dest_uninitialized) {\n+    if (dest_needs_zeroing) {\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":38,"deletions":29,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -518,2 +518,2 @@\n-#define RETURN_STUB_PARM(xxx_arraycopy, parm) {           \\\n-  name = #xxx_arraycopy; \\\n+#define RETURN_STUB_PARM(xxx_arraycopy, parm) { \\\n+  name = parm ? #xxx_arraycopy \"_uninit\": #xxx_arraycopy; \\\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}