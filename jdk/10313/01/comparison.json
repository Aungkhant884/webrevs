{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,2 @@\n+\n+  _deferred_obj_array = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapWord*>(10, mtGC);\n@@ -168,0 +170,9 @@\n+void ParCompactionManager::drain_deferred_objects() {\n+  while (!_deferred_obj_array->is_empty()) {\n+    HeapWord* addr = _deferred_obj_array->pop();\n+    assert(addr != NULL, \"expected a deferred object\");\n+    PSParallelCompact::update_deferred_object(this, addr);\n+  }\n+  _deferred_obj_array->clear_and_deallocate();\n+}\n+\n@@ -198,0 +209,4 @@\n+void ParCompactionManager::push_deferred_object(HeapWord* addr) {\n+  _deferred_obj_array->push(addr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+  GrowableArray<HeapWord*>*    _deferred_obj_array;\n+\n@@ -131,0 +133,2 @@\n+  void push_deferred_object(HeapWord* addr);\n+\n@@ -198,0 +202,1 @@\n+  void drain_deferred_objects();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2430,0 +2430,4 @@\n+\n+    \/\/ At this point all regions have been compacted, so it's now safe\n+    \/\/ to update the deferred objects that cross region boundaries.\n+    cm->drain_deferred_objects();\n@@ -2459,1 +2463,1 @@\n-    \/\/ Verify that all regions have been processed before the deferred updates.\n+    \/\/ Verify that all regions have been processed.\n@@ -2466,9 +2470,0 @@\n-  {\n-    GCTraceTime(Trace, gc, phases) tm(\"Deferred Updates\", &_gc_timer);\n-    \/\/ Update the deferred objects, if any.\n-    ParCompactionManager* cm = ParCompactionManager::get_vmthread_cm();\n-    for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n-      update_deferred_objects(cm, SpaceId(id));\n-    }\n-  }\n-\n@@ -2601,4 +2596,2 @@\n-void PSParallelCompact::update_deferred_objects(ParCompactionManager* cm,\n-                                                SpaceId id) {\n-  assert(id < last_space_id, \"bad space id\");\n-\n+void PSParallelCompact::update_deferred_object(ParCompactionManager* cm, HeapWord *addr) {\n+#ifdef ASSERT\n@@ -2606,2 +2599,4 @@\n-  const SpaceInfo* const space_info = _space_info + id;\n-  ObjectStartArray* const start_array = space_info->start_array();\n+  size_t region_idx = sd.addr_to_region_idx(addr);\n+  assert(sd.region(region_idx)->completed(), \"first region must be completed before deferred updates\");\n+  assert(sd.region(region_idx + 1)->completed(), \"second region must be completed before deferred updates\");\n+#endif\n@@ -2609,17 +2604,4 @@\n-  const MutableSpace* const space = space_info->space();\n-  assert(space_info->dense_prefix() >= space->bottom(), \"dense_prefix not set\");\n-  HeapWord* const beg_addr = space_info->dense_prefix();\n-  HeapWord* const end_addr = sd.region_align_up(space_info->new_top());\n-\n-  const RegionData* const beg_region = sd.addr_to_region_ptr(beg_addr);\n-  const RegionData* const end_region = sd.addr_to_region_ptr(end_addr);\n-  const RegionData* cur_region;\n-  for (cur_region = beg_region; cur_region < end_region; ++cur_region) {\n-    HeapWord* const addr = cur_region->deferred_obj_addr();\n-    if (addr != NULL) {\n-      if (start_array != NULL) {\n-        start_array->allocate_block(addr);\n-      }\n-      cm->update_contents(cast_to_oop(addr));\n-      assert(oopDesc::is_oop_or_null(cast_to_oop(addr)), \"Expected an oop or NULL at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n-    }\n+  const SpaceInfo* const space_info = _space_info + space_id(addr);\n+  ObjectStartArray* const start_array = space_info->start_array();\n+  if (start_array != NULL) {\n+    start_array->allocate_block(addr);\n@@ -2627,0 +2609,3 @@\n+\n+  cm->update_contents(cast_to_oop(addr));\n+  assert(oopDesc::is_oop(cast_to_oop(addr)), \"Expected an oop at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n@@ -2873,1 +2858,0 @@\n-      region_ptr->set_deferred_obj_addr(NULL);\n@@ -2918,1 +2902,1 @@\n-      region_ptr->set_deferred_obj_addr(closure.destination());\n+      cm->push_deferred_object(closure.destination());\n@@ -2930,1 +2914,0 @@\n-      region_ptr->set_deferred_obj_addr(NULL);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":19,"deletions":36,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -246,7 +246,0 @@\n-    \/\/ The object (if any) starting in this region and ending in a different\n-    \/\/ region that could not be updated during the main (parallel) compaction\n-    \/\/ phase.  This is different from _partial_obj_addr, which is an object that\n-    \/\/ extends onto a source region.  However, the two uses do not overlap in\n-    \/\/ time, so the same field is used to save space.\n-    HeapWord* deferred_obj_addr() const { return _partial_obj_addr; }\n-\n@@ -315,1 +308,0 @@\n-    void set_deferred_obj_addr(HeapWord* addr) { _partial_obj_addr = addr; }\n@@ -951,2 +943,2 @@\n-\/\/ containing AAA.  These AAA's have there references updated at the end in a\n-\/\/ clean up phase.  See the method PSParallelCompact::update_deferred_objects().\n+\/\/ containing AAA.  These AAA's have their references updated at the end in a\n+\/\/ clean up phase.  See the method PSParallelCompact::update_deferred_object().\n@@ -1251,2 +1243,2 @@\n-  \/\/ Update the deferred objects in the space.\n-  static void update_deferred_objects(ParCompactionManager* cm, SpaceId id);\n+  \/\/ Update a single deferred object.\n+  static void update_deferred_object(ParCompactionManager* cm, HeapWord* addr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"}]}