[{"commit":{"message":"Make assert more strict"},"files":[{"filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp"}],"sha":"a4a24531b9d26fe9f8e0cb4af2829b1c42f46d22"},{"commit":{"message":"8292296: Use multiple threads to process ParallelGC deferred updates\n\nThis is a follow-up to an initial patch I posted a while back to\nhotspot-gc-dev:\n\nhttps:\/\/mail.openjdk.org\/pipermail\/hotspot-gc-dev\/2022-August\/039905.html\n\nThe problem here is that some applications including SPECjbb spend a lot\nof time in the \"Deferred Updates\" stage of parallel compaction if they\nhappen to generate a lot of objects that cross region boundaries.\n\nThe patch above is parallelising the existing serial processing of\ndeferred updates on the main VM thread.  However I think we can solve\nthis in a simpler way by instead having each GC worker thread keep a\nprivate list of the deferred objects it encountered during compaction,\nand then once all regions have been compacted, process its private list\nof deferred updates.\n\nWe know that `compaction_with_stealing_work()` won't return until all\nregions have been compacted because otherwise\n`terminator->offer_termination()` would return false and the worker\nthread would attempt to steal tasks from another thread.\n\nThe advantage of this approach over a separate parallel deferred updates\nstep is that we don't have to worry about adding heuristics for when and\nhow many worker threads to start up, which has the potential to cause\nregressions in some cases.  Processing the deferred objects on the\nworker thread shouldn't be any slower than the existing serial scan on\nthe VM thread, even if all the deferred objects end up on the queue of\none thread (there's no attempt to balance or work-steal between\nthreads).  We also avoid having to scan each region for deferred objects\nin the common case where there are none in a space.\n\nThe new per-thread deferred objects list is dynamically allocated but\nits size is bounded by the number of 512k heap regions as we will push\nat most one pointer per region.\n\nWith SPECjbb on AWS c7g.16xlarge I see median full GC pause times reduce\nby around 20% with a corresponding ~1% increase in critical-jOPS\naveraged over several runs.  On the \"derby\" benchmark from SPECjvm I\nalso see an improvement in median full GC pause times of around 11%.  I\ntried a variety of other benchmarks from Dacapo and SPECjvm but I\ncouldn't see any other significant effect: it seems quite dependent on\nthe type and size of objects allocated.\n\nTested tier1-3 with -XX:+UseParallelGC."},"files":[{"filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp"},{"filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp"},{"filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp"},{"filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp"}],"sha":"6a99b848096dc24a6c66d39fc1b9c8d64eabf531"}]