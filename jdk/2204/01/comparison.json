{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -29,0 +33,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -31,0 +36,135 @@\n+\/\/ SeenThread objects represent list of threads that are\n+\/\/ currently performing a load action on a class.\n+\/\/ For class circularity, set before loading a superclass.\n+\/\/ For bootclasssearchpath, set before calling load_instance_class.\n+\/\/ Defining must be single threaded on a class\/classloader basis\n+\/\/ For DEFINE_CLASS, the head of the queue owns the\n+\/\/ define token and the rest of the threads wait to return the\n+\/\/ result the first thread gets.\n+class SeenThread: public CHeapObj<mtInternal> {\n+private:\n+   Thread *_thread;\n+   SeenThread* _stnext;\n+   SeenThread* _stprev;\n+public:\n+   SeenThread(Thread *thread) {\n+       _thread = thread;\n+       _stnext = NULL;\n+       _stprev = NULL;\n+   }\n+   Thread* thread()                const { return _thread;}\n+   void set_thread(Thread *thread) { _thread = thread; }\n+\n+   SeenThread* next()              const { return _stnext;}\n+   void set_next(SeenThread *seen) { _stnext = seen; }\n+   void set_prev(SeenThread *seen) { _stprev = seen; }\n+\n+  void print_action_queue(outputStream* st) {\n+    SeenThread* seen = this;\n+    while (seen != NULL) {\n+      seen->thread()->print_value_on(st);\n+      st->print(\", \");\n+      seen = seen->next();\n+    }\n+  }\n+};\n+\n+SeenThread* PlaceholderEntry::actionToQueue(PlaceholderTable::classloadAction action) {\n+  SeenThread* queuehead = NULL;\n+  switch (action) {\n+    case PlaceholderTable::LOAD_INSTANCE:\n+       queuehead = _loadInstanceThreadQ;\n+       break;\n+    case PlaceholderTable::LOAD_SUPER:\n+       queuehead = _superThreadQ;\n+       break;\n+    case PlaceholderTable::DEFINE_CLASS:\n+       queuehead = _defineThreadQ;\n+       break;\n+    default: Unimplemented();\n+  }\n+  return queuehead;\n+}\n+\n+void PlaceholderEntry::set_threadQ(SeenThread* seenthread, PlaceholderTable::classloadAction action) {\n+  switch (action) {\n+    case PlaceholderTable::LOAD_INSTANCE:\n+       _loadInstanceThreadQ = seenthread;\n+       break;\n+    case PlaceholderTable::LOAD_SUPER:\n+       _superThreadQ = seenthread;\n+       break;\n+    case PlaceholderTable::DEFINE_CLASS:\n+       _defineThreadQ = seenthread;\n+       break;\n+    default: Unimplemented();\n+  }\n+  return;\n+}\n+\n+\/\/ Doubly-linked list of Threads per action for class\/classloader pair\n+\/\/ Class circularity support: links in thread before loading superclass\n+\/\/ bootstrapsearchpath support: links in a thread before load_instance_class\n+\/\/ definers: use as queue of define requestors, including owner of\n+\/\/ define token. Appends for debugging of requestor order\n+void PlaceholderEntry::add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+  assert_lock_strong(SystemDictionary_lock);\n+  SeenThread* threadEntry = new SeenThread(thread);\n+  SeenThread* seen = actionToQueue(action);\n+\n+  if (seen == NULL) {\n+    set_threadQ(threadEntry, action);\n+    return;\n+  }\n+  SeenThread* next;\n+  while ((next = seen->next()) != NULL) {\n+    seen = next;\n+  }\n+  seen->set_next(threadEntry);\n+  threadEntry->set_prev(seen);\n+  return;\n+}\n+\n+bool PlaceholderEntry::check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+  assert_lock_strong(SystemDictionary_lock);\n+  SeenThread* threadQ = actionToQueue(action);\n+  SeenThread* seen = threadQ;\n+  while (seen) {\n+    if (thread == seen->thread()) {\n+      return true;\n+    }\n+    seen = seen->next();\n+  }\n+  return false;\n+}\n+\n+\/\/ returns true if seenthreadQ is now empty\n+\/\/ Note, caller must ensure probe still exists while holding\n+\/\/ SystemDictionary_lock\n+\/\/ ignores if cleanup has already been done\n+\/\/ if found, deletes SeenThread\n+bool PlaceholderEntry::remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+  assert_lock_strong(SystemDictionary_lock);\n+  SeenThread* threadQ = actionToQueue(action);\n+  SeenThread* seen = threadQ;\n+  SeenThread* prev = NULL;\n+  while (seen) {\n+    if (thread == seen->thread()) {\n+      if (prev) {\n+        prev->set_next(seen->next());\n+      } else {\n+        set_threadQ(seen->next(), action);\n+      }\n+      if (seen->next()) {\n+        seen->next()->set_prev(prev);\n+      }\n+      delete seen;\n+      break;\n+    }\n+    prev = seen;\n+    seen = seen->next();\n+  }\n+  return (actionToQueue(action) == NULL);\n+}\n+\n+\n@@ -119,5 +259,24 @@\n-  \/\/ find_and_add returns probe pointer - old or new\n-  \/\/ If no entry exists, add a placeholder entry\n-  \/\/ If entry exists, reuse entry\n-  \/\/ For both, push SeenThread for classloadAction\n-  \/\/ If LOAD_SUPER, this is used for circularity detection for instanceklass loading.\n+static const char* action_to_string(PlaceholderTable::classloadAction action) {\n+  switch (action) {\n+  case PlaceholderTable::LOAD_INSTANCE: return \"LOAD_INSTANCE\";\n+  case PlaceholderTable::LOAD_SUPER:    return \"LOAD_SUPER\";\n+  case PlaceholderTable::DEFINE_CLASS:  return \"DEFINE_CLASS\";\n+ }\n+ return \"\";\n+}\n+\n+inline void log(PlaceholderEntry* entry, const char* function, PlaceholderTable::classloadAction action) {\n+  if (log_is_enabled(Debug, class, load, placeholders)) {\n+    LogTarget(Debug, class, load, placeholders) lt;\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print(\"%s %s \", function, action_to_string(action));\n+    entry->print_entry(&ls);\n+  }\n+}\n+\n+\/\/ find_and_add returns probe pointer - old or new\n+\/\/ If no entry exists, add a placeholder entry\n+\/\/ If entry exists, reuse entry\n+\/\/ For both, push SeenThread for classloadAction\n+\/\/ If LOAD_SUPER, this is used for circularity detection for instanceklass loading.\n@@ -141,0 +300,1 @@\n+  log(probe, \"find_and_add\", action);\n@@ -165,0 +325,1 @@\n+       log(probe, \"find_and_remove\", action);\n@@ -237,0 +398,2 @@\n+\n+void PlaceholderTable::print() const { return print_on(tty); }\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":169,"deletions":6,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"runtime\/thread.hpp\"\n@@ -32,0 +31,3 @@\n+class Thread;\n+class ClassLoaderData;\n+class Symbol;\n@@ -98,0 +100,1 @@\n+  void print() const;\n@@ -101,35 +104,1 @@\n-\/\/ SeenThread objects represent list of threads that are\n-\/\/ currently performing a load action on a class.\n-\/\/ For class circularity, set before loading a superclass.\n-\/\/ For bootclasssearchpath, set before calling load_instance_class.\n-\/\/ Defining must be single threaded on a class\/classloader basis\n-\/\/ For DEFINE_CLASS, the head of the queue owns the\n-\/\/ define token and the rest of the threads wait to return the\n-\/\/ result the first thread gets.\n-class SeenThread: public CHeapObj<mtInternal> {\n-private:\n-   Thread *_thread;\n-   SeenThread* _stnext;\n-   SeenThread* _stprev;\n-public:\n-   SeenThread(Thread *thread) {\n-       _thread = thread;\n-       _stnext = NULL;\n-       _stprev = NULL;\n-   }\n-   Thread* thread()                const { return _thread;}\n-   void set_thread(Thread *thread) { _thread = thread; }\n-\n-   SeenThread* next()              const { return _stnext;}\n-   void set_next(SeenThread *seen) { _stnext = seen; }\n-   void set_prev(SeenThread *seen) { _stprev = seen; }\n-\n-  void print_action_queue(outputStream* st) {\n-    SeenThread* seen = this;\n-    while (seen != NULL) {\n-      seen->thread()->print_value_on(st);\n-      st->print(\", \");\n-      seen = seen->next();\n-    }\n-  }\n-};\n+class SeenThread;\n@@ -145,0 +114,2 @@\n+  friend class PlaceholderTable;\n+\n@@ -160,0 +131,5 @@\n+  SeenThread* actionToQueue(PlaceholderTable::classloadAction action);\n+  void set_threadQ(SeenThread* seenthread, PlaceholderTable::classloadAction action);\n+  void add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n+  bool remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n+\n@@ -202,33 +178,0 @@\n-  SeenThread* actionToQueue(PlaceholderTable::classloadAction action) {\n-    SeenThread* queuehead = NULL;\n-    switch (action) {\n-      case PlaceholderTable::LOAD_INSTANCE:\n-         queuehead = _loadInstanceThreadQ;\n-         break;\n-      case PlaceholderTable::LOAD_SUPER:\n-         queuehead = _superThreadQ;\n-         break;\n-      case PlaceholderTable::DEFINE_CLASS:\n-         queuehead = _defineThreadQ;\n-         break;\n-      default: Unimplemented();\n-    }\n-    return queuehead;\n-  }\n-\n-  void set_threadQ(SeenThread* seenthread, PlaceholderTable::classloadAction action) {\n-    switch (action) {\n-      case PlaceholderTable::LOAD_INSTANCE:\n-         _loadInstanceThreadQ = seenthread;\n-         break;\n-      case PlaceholderTable::LOAD_SUPER:\n-         _superThreadQ = seenthread;\n-         break;\n-      case PlaceholderTable::DEFINE_CLASS:\n-         _defineThreadQ = seenthread;\n-         break;\n-      default: Unimplemented();\n-    }\n-    return;\n-  }\n-\n@@ -247,64 +190,2 @@\n-\/\/ Doubly-linked list of Threads per action for class\/classloader pair\n-\/\/ Class circularity support: links in thread before loading superclass\n-\/\/ bootstrapsearchpath support: links in a thread before load_instance_class\n-\/\/ definers: use as queue of define requestors, including owner of\n-\/\/ define token. Appends for debugging of requestor order\n-  void add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n-    assert_lock_strong(SystemDictionary_lock);\n-    SeenThread* threadEntry = new SeenThread(thread);\n-    SeenThread* seen = actionToQueue(action);\n-\n-    if (seen == NULL) {\n-      set_threadQ(threadEntry, action);\n-      return;\n-    }\n-    SeenThread* next;\n-    while ((next = seen->next()) != NULL) {\n-      seen = next;\n-    }\n-    seen->set_next(threadEntry);\n-    threadEntry->set_prev(seen);\n-    return;\n-  }\n-\n-  bool check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n-    assert_lock_strong(SystemDictionary_lock);\n-    SeenThread* threadQ = actionToQueue(action);\n-    SeenThread* seen = threadQ;\n-    while (seen) {\n-      if (thread == seen->thread()) {\n-        return true;\n-      }\n-      seen = seen->next();\n-    }\n-    return false;\n-  }\n-\n-  \/\/ returns true if seenthreadQ is now empty\n-  \/\/ Note, caller must ensure probe still exists while holding\n-  \/\/ SystemDictionary_lock\n-  \/\/ ignores if cleanup has already been done\n-  \/\/ if found, deletes SeenThread\n-  bool remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n-    assert_lock_strong(SystemDictionary_lock);\n-    SeenThread* threadQ = actionToQueue(action);\n-    SeenThread* seen = threadQ;\n-    SeenThread* prev = NULL;\n-    while (seen) {\n-      if (thread == seen->thread()) {\n-        if (prev) {\n-          prev->set_next(seen->next());\n-        } else {\n-          set_threadQ(seen->next(), action);\n-        }\n-        if (seen->next()) {\n-          seen->next()->set_prev(prev);\n-        }\n-        delete seen;\n-        break;\n-      }\n-      prev = seen;\n-      seen = seen->next();\n-    }\n-    return (actionToQueue(action) == NULL);\n-  }\n+  \/\/ Used for ClassCircularityError checking\n+  bool check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":15,"deletions":134,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,0 +142,1 @@\n+  LOG_TAG(placeholders) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}