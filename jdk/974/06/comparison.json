{"files":[{"patch":"@@ -1275,0 +1275,7 @@\n+bool ciMethod::is_string_substring() const {\n+  if (holder() == CURRENT_ENV->String_klass()) {\n+    return intrinsic_id() == vmIntrinsics::_String_substring;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+  bool is_string_substring() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -962,0 +962,6 @@\n+  do_intrinsic(_String_substring, java_lang_String, substring_name, int_int_string_signature,                      F_R)   \\\n+   do_name(    substring_name,    \"substring\")                                                                            \\\n+                                                                                                                          \\\n+  do_intrinsic(_String_startsWith, java_lang_String, startsWith_name, string_bool_signature,                       F_R)   \\\n+   do_name(    startsWith_name,   \"startsWith\")                                                                           \\\n+                                                                                                                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -556,0 +556,3 @@\n+  template(string_bool_signature,                     \"(Ljava\/lang\/String;)Z\")                                    \\\n+  template(string_int_bool_signature,                 \"(Ljava\/lang\/String;I)Z\")                                   \\\n+  template(int_int_string_signature,                  \"(II)Ljava\/lang\/String;\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -557,0 +557,6 @@\n+  product(bool, OptimizeSubstring, true,                                    \\\n+          \"enable substring optimization\")                                  \\\n+                                                                            \\\n+  notproduct(bool, PrintOptimizeSubstring, false,                           \\\n+          \"Trace substring stack replacement\")                              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,0 +84,4 @@\n+  virtual void set_callee_method(ciMethod* m) {\n+    assert(InlineTree::check_can_parse(m) == NULL, \"parse must be possible\");\n+    _method = m;\n+  }\n@@ -717,1 +721,6 @@\n-    LateInlineStringCallGenerator* cg = new LateInlineStringCallGenerator(method(), _inline_cg);\n+    CallJavaNode* callj = call->as_CallJava();\n+\n+    if (_inline_cg->method() != callj->method()) {\n+      _inline_cg->set_callee_method(callj->method());\n+    }\n+    LateInlineStringCallGenerator* cg = new LateInlineStringCallGenerator(callj->method(), _inline_cg);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- private:\n+ protected:\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1016,0 +1016,1 @@\n+  if (_bci == -1) return true;\n@@ -1018,0 +1019,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -303,0 +303,1 @@\n+  void              set_method(ciMethod* method) { _method = method; }\n@@ -674,1 +675,1 @@\n-  const int       _bci;         \/\/ Byte Code Index of call byte code\n+  int     _bci;                    \/\/ Byte Code Index of call byte code\n@@ -698,1 +699,2 @@\n-\n+  int bci() const { return _bci; }\n+  void set_bci(int bci) { _bci = bci;}\n@@ -742,1 +744,1 @@\n-    if ((jvms() != NULL) && is_boxing_method()) {\n+    if (jvms() != NULL) {\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -257,0 +257,1 @@\n+    PhaseStringOpts::print_statistics();\n@@ -729,2 +730,2 @@\n-\n-    if (_late_inlines.length() == 0 && !has_mh_late_inlines() && !failing() && has_stringbuilder()) {\n+    \/\/ c2 may skip the incremental inliner, so process _string_late_inlines earlier\n+    if (_late_inlines.length() == 0 && !has_mh_late_inlines() && !failing() && (has_stringbuilder() || has_stringsubstring())) {\n@@ -967,0 +968,1 @@\n+  set_has_stringsubstring(false);\n@@ -2017,1 +2019,0 @@\n-    assert(has_stringbuilder(), \"inconsistent\");\n@@ -4797,0 +4798,21 @@\n+\n+void Compile::update_string_late_inline(CallJavaNode* call, CallJavaNode* new_call) {\n+  for (int i = 0; i < _string_late_inlines.length(); i++) {\n+    CallGenerator* cg = _string_late_inlines.at(i);\n+    CallGenerator* new_cg;\n+\n+    if (call == cg->call_node()) {\n+      assert(cg->is_string_late_inline(), \"not string late!\");\n+      _string_late_inlines.at(i) = new_cg = cg->with_call_node(new_call);\n+\n+      if (print_inlining() || print_intrinsics()) {\n+        for (int j = 0; j < _print_inlining_list->length(); j++) {\n+          if (_print_inlining_list->adr_at(j)->cg() == cg) {\n+            _print_inlining_list->adr_at(j)->set_cg(new_cg);\n+          }\n+        }\n+      }\n+      return;\n+    }\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+class CallJavaNode;\n@@ -278,0 +279,1 @@\n+  bool                  _has_stringsubstring;   \/\/ True String.substring() is allocated.\n@@ -555,0 +557,2 @@\n+  bool              has_stringsubstring() const   { return _has_stringsubstring; }\n+  void          set_has_stringsubstring(bool z)   { _has_stringsubstring = z; }\n@@ -1191,0 +1195,2 @@\n+\n+  void update_string_late_inline(CallJavaNode* call, CallJavaNode* new_call);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -162,0 +162,4 @@\n+  if (callee->is_string_substring()) {\n+    C->set_has_stringsubstring(true);\n+  }\n+\n@@ -426,0 +430,11 @@\n+\n+  if (call_method->holder() == C->env()->String_klass()) {\n+    switch (call_method->intrinsic_id()) {\n+    case vmIntrinsics::_String_startsWith:\n+    case vmIntrinsics::_String_substring:\n+      return true;\n+    default:\n+      ;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1211,0 +1211,6 @@\n+  \/\/ a dummy region node: one single input\n+  \/\/ dummy region nodes should only exist before Optimize()\n+  if (ctrl != NULL && ctrl->is_Region() && ctrl->req() == 2) {\n+    ctrl = ctrl->in(1);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,13 @@\n+static bool is_SB_toString(Node* call) {\n+  if (call->is_CallStaticJava()) {\n+    CallStaticJavaNode* csj = call->as_CallStaticJava();\n+    ciMethod* m = csj->method();\n+    if (m != NULL &&\n+        (m->intrinsic_id() == vmIntrinsics::_StringBuilder_toString ||\n+          m->intrinsic_id() == vmIntrinsics::_StringBuffer_toString)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -135,13 +148,0 @@\n-  static bool is_SB_toString(Node* call) {\n-    if (call->is_CallStaticJava()) {\n-      CallStaticJavaNode* csj = call->as_CallStaticJava();\n-      ciMethod* m = csj->method();\n-      if (m != NULL &&\n-          (m->intrinsic_id() == vmIntrinsics::_StringBuilder_toString ||\n-           m->intrinsic_id() == vmIntrinsics::_StringBuffer_toString)) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n@@ -208,1 +208,0 @@\n-  void eliminate_call(CallNode* call);\n@@ -273,1 +272,5 @@\n-        eliminate_call(n->as_Call());\n+        CallNode* call = n->as_Call();\n+        CallProjections projs;\n+\n+        call->extract_projections(&projs, false);\n+        _stringopts->eliminate_call(call, projs);\n@@ -324,38 +327,0 @@\n-\n-void StringConcat::eliminate_call(CallNode* call) {\n-  Compile* C = _stringopts->C;\n-  CallProjections projs;\n-  call->extract_projections(&projs, false);\n-  if (projs.fallthrough_catchproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_catchproj, call->in(TypeFunc::Control));\n-  }\n-  if (projs.fallthrough_memproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_memproj, call->in(TypeFunc::Memory));\n-  }\n-  if (projs.catchall_memproj != NULL) {\n-    C->gvn_replace_by(projs.catchall_memproj, C->top());\n-  }\n-  if (projs.fallthrough_ioproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_ioproj, call->in(TypeFunc::I_O));\n-  }\n-  if (projs.catchall_ioproj != NULL) {\n-    C->gvn_replace_by(projs.catchall_ioproj, C->top());\n-  }\n-  if (projs.catchall_catchproj != NULL) {\n-    \/\/ EA can't cope with the partially collapsed graph this\n-    \/\/ creates so put it on the worklist to be collapsed later.\n-    for (SimpleDUIterator i(projs.catchall_catchproj); i.has_next(); i.next()) {\n-      Node *use = i.get();\n-      int opc = use->Opcode();\n-      if (opc == Op_CreateEx || opc == Op_Region) {\n-        _stringopts->record_dead_node(use);\n-      }\n-    }\n-    C->gvn_replace_by(projs.catchall_catchproj, C->top());\n-  }\n-  if (projs.resproj != NULL) {\n-    C->gvn_replace_by(projs.resproj, C->top());\n-  }\n-  C->gvn_replace_by(call, C->top());\n-}\n-\n@@ -381,2 +346,3 @@\n-Node_List PhaseStringOpts::collect_toString_calls() {\n-  Node_List string_calls;\n+template <Predicate Pred>\n+Node_List PhaseStringOpts::collect_interesting_calls() {\n+  Node_List calls;\n@@ -386,1 +352,0 @@\n-\n@@ -397,1 +362,1 @@\n-    if (StringConcat::is_SB_toString(ctrl)) {\n+    if (Pred(ctrl)) {\n@@ -399,1 +364,1 @@\n-      string_calls.push(csj);\n+      calls.push(csj);\n@@ -412,2 +377,0 @@\n-  return string_calls;\n-}\n@@ -415,0 +378,2 @@\n+  return calls;\n+}\n@@ -596,0 +561,256 @@\n+static bool is_string_startsWith(Node* call) {\n+  if (call->is_CallStaticJava()) {\n+    CallStaticJavaNode* csj = call->as_CallStaticJava();\n+    ciMethod* m = csj->method();\n+    if (m != NULL &&\n+        m->intrinsic_id() == vmIntrinsics::_String_startsWith) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+void PhaseStringOpts::eliminate_call(CallNode* call, CallProjections& projs) {\n+  if (projs.fallthrough_catchproj != NULL) {\n+    C->gvn_replace_by(projs.fallthrough_catchproj, call->in(TypeFunc::Control));\n+  }\n+  if (projs.fallthrough_memproj != NULL) {\n+    C->gvn_replace_by(projs.fallthrough_memproj, call->in(TypeFunc::Memory));\n+  }\n+  if (projs.catchall_memproj != NULL) {\n+    C->gvn_replace_by(projs.catchall_memproj, C->top());\n+  }\n+  if (projs.fallthrough_ioproj != NULL) {\n+    C->gvn_replace_by(projs.fallthrough_ioproj, call->in(TypeFunc::I_O));\n+  }\n+  if (projs.catchall_ioproj != NULL) {\n+    C->gvn_replace_by(projs.catchall_ioproj, C->top());\n+  }\n+  if (projs.catchall_catchproj != NULL) {\n+    \/\/ EA can't cope with the partially collapsed graph this\n+    \/\/ creates so put it on the worklist to be collapsed later.\n+    for (SimpleDUIterator i(projs.catchall_catchproj); i.has_next(); i.next()) {\n+      Node *use = i.get();\n+      int opc = use->Opcode();\n+      if (opc == Op_CreateEx || opc == Op_Region) {\n+        record_dead_node(use);\n+      }\n+    }\n+    C->gvn_replace_by(projs.catchall_catchproj, C->top());\n+  }\n+  if (projs.resproj != NULL) {\n+    C->gvn_replace_by(projs.resproj, C->top());\n+  }\n+  C->gvn_replace_by(call, C->top());\n+}\n+\n+JVMState* PhaseStringOpts::clone_substr_jvms(CallJavaNode* call) {\n+  JVMState* jvms = call->jvms()->clone_shallow(C);\n+  uint size = call->req();\n+  SafePointNode* map = new SafePointNode(size, jvms);\n+\n+  \/\/ copy the control and memory state from the final call into our\n+  \/\/ new starting state.  This allows any preceeding tests to feed\n+  \/\/ into the new section of code.\n+  for (uint i1 = 0; i1 < TypeFunc::Parms; i1++) {\n+    map->init_req(i1, call->in(i1));\n+  }\n+\n+  for (uint i1 = TypeFunc::Parms; i1 < jvms->debug_start(); i1++) {\n+    map->init_req(i1, call->in(i1));\n+  }\n+\n+  \/\/ Copy the rest of the inputs for the JVMState\n+  for (uint i1 = jvms->debug_start(); i1 < call->req(); i1++) {\n+    map->init_req(i1, call->in(i1));\n+  }\n+\n+  \/\/ Make sure the memory state is a MergeMem for parsing.\n+  if (!map->in(TypeFunc::Memory)->is_MergeMem()) {\n+    map->set_req(TypeFunc::Memory, MergeMemNode::make(map->in(TypeFunc::Memory)));\n+  }\n+\n+  jvms->set_map(map);\n+  map->ensure_stack(jvms, jvms->method()->max_stack());\n+  jvms->set_should_reexecute(true);\n+  return jvms;\n+}\n+\n+\/\/ api-level substitution\n+\/\/ transform from s=substring(base, beg); s.startsWith(prefix)\n+\/\/ to substring(base, beg)| base.startsWith(prefix, beg)\n+CallJavaNode* PhaseStringOpts::optimize_startsWith(CallJavaNode* substr, CallJavaNode* startsWith, Node* castpp) {\n+  ciMethod* m = startsWith->method();\n+  ciInstanceKlass* holder = m->holder();\n+  ciMethod* m2 = holder->find_method(m->name(), ciSymbols::string_int_bool_signature());\n+\n+  Node* base = substr->in(TypeFunc::Parms + 0);\n+  Node* beg_idx = substr->in(TypeFunc::Parms + 1);\n+  Node* end_idx = substr->in(TypeFunc::Parms + 2);\n+  CallJavaNode* new_call = static_cast<CallJavaNode* >(_gvn->transform(startsWith->clone()));\n+\n+  new_call->replace_edge(new_call->in(TypeFunc::Parms + 0), base);\n+  new_call->ins_req(TypeFunc::Parms + 2, beg_idx);\n+  new_call->set_tf(TypeFunc::make(m2));\n+  new_call->set_method(m2);\n+  new_call->set_bci(-1);\n+  new_call->jvms()->adapt_position(+1);\n+  C->update_string_late_inline(startsWith, new_call);\n+  C->gvn_replace_by(startsWith, new_call);\n+\n+  startsWith->disconnect_inputs(C);\n+  startsWith->destruct(_gvn);\n+\n+  Node* ctrl = new_call->in(TypeFunc::Control);\n+  Node* iff = nullptr;\n+\n+  if (ctrl->is_IfProj()) {\n+    iff = ctrl->in(TypeFunc::Control);\n+  }\n+\n+  if (iff != nullptr && iff->is_If()) {\n+    ctrl = iff->find_exact_control(iff->in(TypeFunc::Control));\n+    \/\/ if substr controls new_call, hoist it\n+    if (ctrl == substr) {\n+      \/\/ invalidate the nullcheck of substring\n+      iff->replace_edge(iff->in(1), C->top());\n+      C->for_igvn()->push(iff);\n+\n+      \/\/ rewrite defs using the defs of substr\n+      for (node_idx_t idx = TypeFunc::Control; idx < TypeFunc::Parms; ++idx) {\n+        new_call->replace_edge(new_call->in(idx), substr->in(idx));\n+      }\n+    }\n+  }\n+\n+  JVMState* jvms = clone_substr_jvms(substr);\n+  GraphKit kit(jvms);\n+\n+  ctrl = new_call->in(TypeFunc::Control);\n+  kit.set_control(ctrl);\n+  kit.push(base);\n+  kit.push(beg_idx);\n+  kit.push(end_idx);\n+\n+  Node* base_len = kit.load_String_length(base, false);\n+  RegionNode* throwEx = new RegionNode(1);\n+  kit.gvn().set_type(throwEx, Type::CONTROL);\n+\n+  \/\/ check IndexOutofBoundsException in java.lang.String::checkBoundsOffCount\n+  \/\/ (begin < 0 || begin > end || end > length)\n+  IfNode* check = kit.create_and_map_if(ctrl, __ Bool(__ CmpI(beg_idx, __ intcon(0)), BoolTest::lt),\n+                                      PROB_MIN, COUNT_UNKNOWN);\n+  throwEx->add_req(__ IfTrue(check));\n+  check = kit.create_and_map_if(__ IfFalse(check), __ Bool(__ CmpI(beg_idx, end_idx), BoolTest::gt),\n+                                      PROB_MIN, COUNT_UNKNOWN);\n+  throwEx->add_req(__ IfTrue(check));\n+  check = kit.create_and_map_if(__ IfFalse(check), __ Bool(__ CmpI(end_idx, base_len), BoolTest::gt),\n+                                      PROB_MIN, COUNT_UNKNOWN);\n+  throwEx->add_req(__ IfTrue(check));\n+\n+  Node* normal = __ IfFalse(check);\n+  ctrl->replace_edge(new_call, normal);\n+  new_call->set_req(TypeFunc::Control, normal);\n+\n+  {\n+    \/\/ instead of constructing an IndexOutofBoundsException with offset index,\n+    \/\/ just punt to the interpreter and reexecute substring()\n+    PreserveJVMState pjvms(&kit);\n+    kit.set_control(throwEx);\n+    C->record_for_igvn(throwEx);\n+    kit.uncommon_trap(Deoptimization::Reason_intrinsic,\n+                      Deoptimization::Action_none);\n+  }\n+\n+  if (castpp->outcnt() == 0 && substr->outcnt() > 0) {\n+    CallProjections projs;\n+    substr->extract_projections(&projs, true);\n+    eliminate_call(substr, projs);\n+    assert(substr->outcnt() == 0, \"failed to eliminate substring call\");\n+\n+#ifndef PRODUCT\n+    substring_eliminated++;\n+    if (PrintOptimizeSubstring) {\n+      tty->print_cr(\"eliminate substring:\");\n+      substr->dump(0);\n+    }\n+#endif\n+  }\n+\n+  return new_call;\n+}\n+\n+\/\/ A substring is trivial if it is generated from String.substring(base, beginIndex)\n+\/\/ C2 may avoid from creating trivial substring by using alternative APIs, eg.\n+\/\/ String::startsWith(base, beginIdex) or StringBuilder::append(base, beginIdex)\n+bool PhaseStringOpts::is_trivial_substring(CallStaticJavaNode* substr) {\n+  if (substr != nullptr && substr->method() != nullptr) {\n+    if (substr->method()->is_string_substring()) {\n+      \/\/ fastpath: caller is substring(base, beginIndex)\n+      ciMethod* caller = substr->jvms()->method();\n+      if (caller->name() == ciSymbols::substring_name() && caller->arg_size_no_receiver() == 1)\n+        return true;\n+\n+\/\/ return true if caller is  String.substring(base, beginIndex, base.length())\n+\/\/     88  AddP  === _  44  44  87  [[ 89  163  171 ]]   Oop:java\/lang\/String:NotNull:exact+16 * ...\n+\/\/   89  LoadB  === _  7  88  [[ 94  164  172 ]]\n+\/\/   68  LoadRange  === _  7  67  [[ 94 ]]\n+\/\/ 94  RShiftI  === _  68  89  [[ 95  154 ]]  !jvms: String::length @ bci:9 (line 675) ...\n+      Node* base = substr->in(TypeFunc::Parms + 0);\n+      Node* end_idx = substr->in(TypeFunc::Parms + 2);\n+      Node_Notes* notes = C->node_notes_at(end_idx->_idx);\n+      if (notes != nullptr && !notes->is_clear()) {\n+        JVMState* jvms = notes->jvms();\n+        if (jvms->has_method()) {\n+          Node* t;\n+          ciMethod* method = jvms->method();\n+\n+          \/\/ callee is java.lang.String::length\n+          if (method->holder()->name() == ciSymbols::java_lang_String() &&\n+              method->name() == ciSymbols::length_name() &&\n+              end_idx->Opcode() == Op_RShiftI) {\n+            t = end_idx->in(2);\n+            if (t->is_Load()) {\n+              t = t->in(2);\n+              return t->is_AddP() && t->in(1) == base;\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+void PhaseStringOpts::optimize_for_substring() {\n+  Node_List calls = collect_interesting_calls<is_string_startsWith>();\n+\n+  for (uint i = 0; i < calls.size(); ++i) {\n+    CallJavaNode* call = calls[i]->as_CallStaticJava();\n+\n+    Node* castpp = call->in(TypeFunc::Parms);\n+    if (castpp->Opcode() == Op_CastPP && castpp->in(1)->is_Proj()) {\n+      CallStaticJavaNode* substr = castpp->in(1)->in(0)->isa_CallStaticJava();\n+\n+      if (is_trivial_substring(substr)) {\n+\n+#ifndef PRODUCT\n+        if (PrintOptimizeSubstring) {\n+          tty->print_cr(\"[optimize_startsWith] before:\");\n+          call->dump(0);\n+        }\n+#endif \/*PRODUCT*\/\n+\n+        call = optimize_startsWith(substr, call, castpp);\n+\n+#ifndef PRODUCT\n+        if (PrintOptimizeSubstring) {\n+          tty->print_cr(\"[optimize_startsWith] after:\");\n+          call->dump(0);\n+        }\n+#endif \/*PRODUCT*\/\n+      }\n+    }\n+  }\n+}\n@@ -601,1 +822,5 @@\n-  assert(OptimizeStringConcat, \"shouldn't be here\");\n+  if (OptimizeSubstring && C->has_stringsubstring()) {\n+    optimize_for_substring();\n+  }\n+\n+  if(!OptimizeStringConcat) return;\n@@ -621,1 +846,1 @@\n-  Node_List toStrings = collect_toString_calls();\n+  Node_List toStrings = collect_interesting_calls<is_SB_toString>();\n@@ -635,1 +860,1 @@\n-      if (arg->is_Proj() && StringConcat::is_SB_toString(arg->in(0))) {\n+      if (arg->is_Proj() && is_SB_toString(arg->in(0))) {\n@@ -1995,0 +2220,8 @@\n+\n+#ifndef PRODUCT\n+int PhaseStringOpts::substring_eliminated = 0;\n+\n+void PhaseStringOpts::print_statistics() {\n+  tty->print_cr(\"OptimizeSubstring: substring_eliminated= %d\", substring_eliminated);\n+}\n+#endif \/*PRODUCT*\/\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":296,"deletions":63,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+typedef bool (*Predicate)(Node*);\n@@ -52,2 +53,2 @@\n-  \/\/ Collect a list of all SB.toString calls\n-  Node_List collect_toString_calls();\n+  template <Predicate Pred>\n+  Node_List collect_interesting_calls();\n@@ -107,0 +108,6 @@\n+  void eliminate_call(CallNode* call, CallProjections& projs);\n+  void optimize_for_substring();\n+  CallJavaNode* optimize_startsWith(CallJavaNode* substr, CallJavaNode* startsWith, Node* castpp);\n+  JVMState* clone_substr_jvms(CallJavaNode* call);\n+  bool is_trivial_substring(CallStaticJavaNode* substr);\n+\n@@ -114,0 +121,1 @@\n+  NOT_PRODUCT(static int substring_eliminated;)\n@@ -116,0 +124,1 @@\n+  NOT_PRODUCT(static void print_statistics();)\n","filename":"src\/hotspot\/share\/opto\/stringopts.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1499,0 +1499,1 @@\n+    @IntrinsicCandidate\n@@ -1905,0 +1906,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary verify that -XX:+OptimizeSubstring removes String.substring()\n+ * @library \/test\/lib \/\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4) & vm.debug == true\n+ * @requires !vm.emulatedClient & !vm.graal.enabled\n+ * @run driver compiler.c2.TestOptimizeSubstring\n+ *\/\n+\n+package compiler.c2;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+\n+public class TestOptimizeSubstring {\n+\n+    public static void main (String args[]) {\n+        if (args.length == 0) {\n+            check(true);  \/\/ check generated code when c2 enables OptimizeSubstring\n+            check(false); \/\/ ... and disabled\n+            check_nontrivial();\n+        } else if (args[0].equals(\"nontrivial\")) {\n+            boolean val1 = false;\n+             for (int i = 0; i < 20_000; ++i) {\n+                val1 |= TestOptimizeSubstring.useStartsWith_NonTrivial();\n+            }\n+\n+            Asserts.assertFalse(val1, \"val1 should be false\");\n+        } else {\n+            boolean val1 = false;\n+            boolean val2 = false;\n+            boolean caughtEx;\n+\n+            for (int i = 0; i < 20_000; ++i) {\n+                val1 |= TestOptimizeSubstring.useStartsWith(\"abcdef\");\n+                val2 |= TestOptimizeSubstring.useStartsWith(\"efgdedf\");\n+\n+                caughtEx = false;\n+                try {\n+                    TestOptimizeSubstring.useStartsWith(\"\");\n+                } catch(StringIndexOutOfBoundsException e) {\n+                    caughtEx = true;\n+                }\n+                Asserts.assertTrue(caughtEx, \"useStartsWith(\\\"\\\") should throw StringIndexOutOfBoundsException\");\n+            }\n+\n+            Asserts.assertTrue (val1, \"val1 should be true\");\n+            Asserts.assertFalse(val2, \"val2 should be false\");\n+        }\n+    }\n+\n+    private static void check(boolean enabled) {\n+        OutputAnalyzer oa;\n+        \/\/ ideally, we should check the opcode 'call' as well, but x86_32.ad uses all CAPITAL opcodes.\n+        \/\/ the feature is 'CALL, static  wrapper for: _new_array_nozero_Java' on i686.\n+        String newStringAlloc = \/*call ,*\/\"static  wrapper for: _new_array_nozero_Java\";\n+        try {\n+            oa = ProcessTools.executeTestJvm(\"-XX:+UnlockDiagnosticVMOptions\", \"-Xbootclasspath\/a:.\",\n+                    \"-XX:\" + (enabled ? \"+\" : \"-\") + \"OptimizeSubstring\",\n+                    \"-XX:+PrintOptoAssembly\", \"-XX:-TieredCompilation\",\n+                    \"-XX:CompileOnly=\" + TestOptimizeSubstring.class.getName() + \"::useStartsWith\",\n+                    TestOptimizeSubstring.class.getName(),\n+                    \"runtest\");\n+        } catch (Exception e) {\n+            throw new Error(\"Exception launching child for case enabled=\" + enabled + \" : \" + e, e);\n+        }\n+        oa.shouldHaveExitValue(0);\n+\n+        if (enabled) {\n+            oa.shouldNotContain(newStringAlloc);\n+        } else {\n+            oa.shouldContain(newStringAlloc);\n+        }\n+   }\n+\n+    private static void check_nontrivial() {\n+        OutputAnalyzer oa;\n+        try {\n+            oa = ProcessTools.executeTestJvm(\"-XX:+UnlockDiagnosticVMOptions\", \"-Xbootclasspath\/a:.\",\n+                    \"-XX:+OptimizeSubstring\", \"-XX:-UseOnStackReplacement\",\n+                    \"-XX:+PrintOptoAssembly\", \"-XX:-TieredCompilation\",\n+                    \"-XX:CompileOnly=\" + TestOptimizeSubstring.class.getName() + \"::useStartsWith_NonTrivial\",\n+                    TestOptimizeSubstring.class.getName(),\n+                    \"nontrivial\");\n+        } catch (Exception e) {\n+            throw new Error(\"Exception launching child for check_nontrivial\");\n+        }\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    private static boolean useStartsWith(String s) {\n+        String x = s.substring(1);\n+        return x.startsWith(\"a\") | x.startsWith(\"b\") | x.startsWith(\"c\");\n+    }\n+\n+    \/\/ courtesy of John Rose's comment\n+    \/\/ https:\/\/github.com\/openjdk\/jdk\/pull\/974#pullrequestreview-551773771\n+    private static boolean useStartsWith_NonTrivial() {\n+        String s = \"abcd\";\n+        String x = s.substring(1, 2);\n+        return x.startsWith(\"bc\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestOptimizeSubstring.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 200, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 25, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+public class SubstringStartsWith {\n+    \/\/ model substrings in 3 representative lengths.\n+    \/\/ 1. small size = 4 for a variable name\n+    \/\/ 2. medium size = 24 or url or a filepath\n+    \/\/ 3. long string = 256 for a human-readable message\n+    @Param({\"4\", \"24\", \"256\"})\n+    private int substrLength;\n+    private String sample_ascii;\n+    private String sample_utf16;\n+    private String prefix_ascii;\n+    private String prefix_utf16;\n+\n+    @Setup(Level.Trial)\n+    public void doSetup() {\n+       StringBuilder sb = new StringBuilder();\n+       String tile = \"abcdef\";\n+       for (int i=0; i<512 * 2; i = i + tile.length()) {\n+           sb.append(tile);\n+       }\n+       sample_ascii = sb.toString();\n+       prefix_ascii = sample_ascii.substring(0, 2);\n+\n+       sb = new StringBuilder();\n+       tile = \"\\u4F60\\u597D\\u3088\\u3046\\u3053\\u305DJava\";\n+       for (int i=0; i<512 * 2; i = i + tile.length()) {\n+           sb.append(tile);\n+       }\n+       sample_utf16 = sb.toString();\n+       prefix_utf16 = sample_utf16.substring(0, 2);\n+    }\n+\n+    boolean substr2StartsWith(String base, String prefix) {\n+        return base.substring(1, 1 + substrLength).startsWith(prefix);\n+    }\n+\n+    boolean substr2StartsWith_noalloc(String base, String prefix) {\n+        \/\/boundary check as same as java.lang.String::checkBoundsBeginEnd\n+        int begin = 1;\n+        int end = begin + substrLength;\n+        if (begin < 0 || begin > end || end > base.length()) {\n+            throw new StringIndexOutOfBoundsException(\n+                \"begin \" + begin + \", end \" + end + \", length \" + base.length());\n+        }\n+\n+        return base.startsWith(prefix, begin);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_singleByte() {\n+        return substr2StartsWith(sample_ascii, prefix_ascii);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_noalloc_singleByte() {\n+        return substr2StartsWith_noalloc(sample_ascii, prefix_ascii);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_doubleBytes() {\n+        return substr2StartsWith(sample_utf16, prefix_utf16);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_noalloc_doubleBytes() {\n+        return substr2StartsWith_noalloc(sample_utf16, prefix_utf16);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/SubstringStartsWith.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"}]}