{"files":[{"patch":"@@ -1361,0 +1361,7 @@\n+bool ciMethod::is_string_substring() const {\n+  if (holder() == CURRENT_ENV->String_klass()) {\n+    return intrinsic_id() == vmIntrinsics::_String_substring;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -359,0 +359,1 @@\n+  bool is_string_substring() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -943,0 +943,6 @@\n+  do_intrinsic(_String_substring, java_lang_String, substring_name, int_int_string_signature,                      F_R)   \\\n+   do_name(    substring_name,    \"substring\")                                                                            \\\n+                                                                                                                          \\\n+  do_intrinsic(_String_startsWith, java_lang_String, startsWith_name, string_bool_signature,                       F_R)   \\\n+   do_name(    startsWith_name,   \"startsWith\")                                                                           \\\n+                                                                                                                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -545,0 +545,3 @@\n+  template(string_bool_signature,                     \"(Ljava\/lang\/String;)Z\")                                    \\\n+  template(string_int_bool_signature,                 \"(Ljava\/lang\/String;I)Z\")                                   \\\n+  template(int_int_string_signature,                  \"(II)Ljava\/lang\/String;\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -558,0 +558,6 @@\n+  product(bool, OptimizeSubstring, true,                                    \\\n+          \"enable substring optimization\")                                  \\\n+                                                                            \\\n+  notproduct(bool, PrintOptimizeSubstring, false,                           \\\n+          \"Trace substring stack replacement\")                              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1017,0 +1017,8 @@\n+\n+  \/\/ vmIntrinsics::_String_startsWith, callee has changed to the overrided version\n+  if (callee->holder()->name() == ciSymbol::java_lang_String()\n+          && 0 == strcmp(callee->name()->as_quoted_ascii(), \"startsWith\")\n+          && override_symbolic_info()) {\n+    return true; \/\/skip\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -301,0 +301,1 @@\n+  void              set_method(ciMethod* method) { _method = method; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -254,0 +254,1 @@\n+    PhaseStringOpts::print_statistics();\n@@ -917,0 +918,1 @@\n+  set_has_stringsubstring(false);\n@@ -1937,1 +1939,0 @@\n-    assert(has_stringbuilder(), \"inconsistent\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+  bool                  _has_stringsubstring;   \/\/ True String.substring() is allocated.\n@@ -551,0 +552,2 @@\n+  bool              has_stringsubstring() const   { return _has_stringsubstring; }\n+  void          set_has_stringsubstring(bool z)   { _has_stringsubstring = z; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -161,0 +161,4 @@\n+  if (callee->is_string_substring()) {\n+    C->set_has_stringsubstring(true);\n+  }\n+\n@@ -418,0 +422,11 @@\n+\n+  if (call_method->holder() == C->env()->String_klass()) {\n+    switch (call_method->intrinsic_id()) {\n+    case vmIntrinsics::_String_startsWith:\n+    case vmIntrinsics::_String_substring:\n+      return true;\n+    default:\n+      ;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,0 +42,13 @@\n+static bool is_SB_toString(Node* call) {\n+  if (call->is_CallStaticJava()) {\n+    CallStaticJavaNode* csj = call->as_CallStaticJava();\n+    ciMethod* m = csj->method();\n+    if (m != NULL &&\n+        (m->intrinsic_id() == vmIntrinsics::_StringBuilder_toString ||\n+          m->intrinsic_id() == vmIntrinsics::_StringBuffer_toString)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -133,13 +146,0 @@\n-  static bool is_SB_toString(Node* call) {\n-    if (call->is_CallStaticJava()) {\n-      CallStaticJavaNode* csj = call->as_CallStaticJava();\n-      ciMethod* m = csj->method();\n-      if (m != NULL &&\n-          (m->intrinsic_id() == vmIntrinsics::_StringBuilder_toString ||\n-           m->intrinsic_id() == vmIntrinsics::_StringBuffer_toString)) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n@@ -206,1 +206,0 @@\n-  void eliminate_call(CallNode* call);\n@@ -271,1 +270,5 @@\n-        eliminate_call(n->as_Call());\n+        CallNode* call = n->as_Call();\n+        CallProjections projs;\n+\n+        call->extract_projections(&projs, false);\n+        _stringopts->eliminate_call(call, projs);\n@@ -322,38 +325,0 @@\n-\n-void StringConcat::eliminate_call(CallNode* call) {\n-  Compile* C = _stringopts->C;\n-  CallProjections projs;\n-  call->extract_projections(&projs, false);\n-  if (projs.fallthrough_catchproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_catchproj, call->in(TypeFunc::Control));\n-  }\n-  if (projs.fallthrough_memproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_memproj, call->in(TypeFunc::Memory));\n-  }\n-  if (projs.catchall_memproj != NULL) {\n-    C->gvn_replace_by(projs.catchall_memproj, C->top());\n-  }\n-  if (projs.fallthrough_ioproj != NULL) {\n-    C->gvn_replace_by(projs.fallthrough_ioproj, call->in(TypeFunc::I_O));\n-  }\n-  if (projs.catchall_ioproj != NULL) {\n-    C->gvn_replace_by(projs.catchall_ioproj, C->top());\n-  }\n-  if (projs.catchall_catchproj != NULL) {\n-    \/\/ EA can't cope with the partially collapsed graph this\n-    \/\/ creates so put it on the worklist to be collapsed later.\n-    for (SimpleDUIterator i(projs.catchall_catchproj); i.has_next(); i.next()) {\n-      Node *use = i.get();\n-      int opc = use->Opcode();\n-      if (opc == Op_CreateEx || opc == Op_Region) {\n-        _stringopts->record_dead_node(use);\n-      }\n-    }\n-    C->gvn_replace_by(projs.catchall_catchproj, C->top());\n-  }\n-  if (projs.resproj != NULL) {\n-    C->gvn_replace_by(projs.resproj, C->top());\n-  }\n-  C->gvn_replace_by(call, C->top());\n-}\n-\n@@ -379,2 +344,3 @@\n-Node_List PhaseStringOpts::collect_toString_calls() {\n-  Node_List string_calls;\n+template <Predicate Pred>\n+Node_List PhaseStringOpts::collect_interesting_calls() {\n+  Node_List calls;\n@@ -384,1 +350,0 @@\n-\n@@ -395,1 +360,1 @@\n-    if (StringConcat::is_SB_toString(ctrl)) {\n+    if (Pred(ctrl)) {\n@@ -397,1 +362,1 @@\n-      string_calls.push(csj);\n+      calls.push(csj);\n@@ -410,2 +375,0 @@\n-  return string_calls;\n-}\n@@ -413,0 +376,2 @@\n+  return calls;\n+}\n@@ -594,0 +559,207 @@\n+static bool is_string_startsWith(Node* call) {\n+  if (call->is_CallStaticJava()) {\n+    CallStaticJavaNode* csj = call->as_CallStaticJava();\n+    ciMethod* m = csj->method();\n+    if (m != NULL &&\n+        m->intrinsic_id() == vmIntrinsics::_String_startsWith) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+void PhaseStringOpts::eliminate_call(CallNode* call, CallProjections& projs) {\n+  if (projs.fallthrough_catchproj != NULL) {\n+    C->gvn_replace_by(projs.fallthrough_catchproj, call->in(TypeFunc::Control));\n+  }\n+  if (projs.fallthrough_memproj != NULL) {\n+    C->gvn_replace_by(projs.fallthrough_memproj, call->in(TypeFunc::Memory));\n+  }\n+  if (projs.catchall_memproj != NULL) {\n+    C->gvn_replace_by(projs.catchall_memproj, C->top());\n+  }\n+  if (projs.fallthrough_ioproj != NULL) {\n+    C->gvn_replace_by(projs.fallthrough_ioproj, call->in(TypeFunc::I_O));\n+  }\n+  if (projs.catchall_ioproj != NULL) {\n+    C->gvn_replace_by(projs.catchall_ioproj, C->top());\n+  }\n+  if (projs.catchall_catchproj != NULL) {\n+    \/\/ EA can't cope with the partially collapsed graph this\n+    \/\/ creates so put it on the worklist to be collapsed later.\n+    for (SimpleDUIterator i(projs.catchall_catchproj); i.has_next(); i.next()) {\n+      Node *use = i.get();\n+      int opc = use->Opcode();\n+      if (opc == Op_CreateEx || opc == Op_Region) {\n+        record_dead_node(use);\n+      }\n+    }\n+    C->gvn_replace_by(projs.catchall_catchproj, C->top());\n+  }\n+  if (projs.resproj != NULL) {\n+    C->gvn_replace_by(projs.resproj, C->top());\n+  }\n+  C->gvn_replace_by(call, C->top());\n+}\n+\n+JVMState* PhaseStringOpts::clone_substr_jvms(CallJavaNode* call) {\n+  JVMState* jvms = call->jvms()->clone_shallow(C);\n+  uint size = call->req();\n+  SafePointNode* map = new SafePointNode(size, jvms);\n+\n+  \/\/ copy the control and memory state from the final call into our\n+  \/\/ new starting state.  This allows any preceeding tests to feed\n+  \/\/ into the new section of code.\n+  for (uint i1 = 0; i1 < TypeFunc::Parms; i1++) {\n+    map->init_req(i1, call->in(i1));\n+  }\n+\n+  for (uint i1 = TypeFunc::Parms; i1 < jvms->debug_start(); i1++) {\n+    map->init_req(i1, call->in(i1));\n+  }\n+\n+  \/\/ Copy the rest of the inputs for the JVMState\n+  for (uint i1 = jvms->debug_start(); i1 < call->req(); i1++) {\n+    map->init_req(i1, call->in(i1));\n+  }\n+\n+  \/\/ Make sure the memory state is a MergeMem for parsing.\n+  if (!map->in(TypeFunc::Memory)->is_MergeMem()) {\n+    map->set_req(TypeFunc::Memory, MergeMemNode::make(map->in(TypeFunc::Memory)));\n+  }\n+\n+  jvms->set_map(map);\n+  map->ensure_stack(jvms, jvms->method()->max_stack());\n+  jvms->set_should_reexecute(true);\n+  return jvms;\n+}\n+\n+\/\/ api-level substitution\n+\/\/ transform from s=substring(base, beg, end); s.startsWith(prefix)\n+\/\/ to substring(base, beg, end)| base.startsWith(prefix, beg)\n+void PhaseStringOpts::optimize_startsWith(CallJavaNode* substr, CallJavaNode* startsWith,\n+                                          Node* castpp, CallProjections& projs) {\n+  ciMethod* m = startsWith->method();\n+  ciInstanceKlass* holder = m->holder();\n+  ciMethod* m2 = holder->find_method(m->name(), ciSymbol::string_int_bool_signature());\n+\n+  Node* base = substr->in(TypeFunc::Parms + 0);\n+  Node* beg_idx = substr->in(TypeFunc::Parms + 1);\n+  Node* end_idx = substr->in(TypeFunc::Parms + 2);\n+\n+  startsWith->replace_edge(startsWith->in(TypeFunc::Parms + 0), base);\n+  startsWith->ins_req(TypeFunc::Parms + 2, beg_idx);\n+  startsWith->set_tf(TypeFunc::make(m2));\n+  startsWith->set_method(m2);\n+  startsWith->set_override_symbolic_info(true);\n+  startsWith->jvms()->adapt_position(+1);\n+\n+  Node* ctrl = startsWith->in(TypeFunc::Control);\n+  Node* iff = nullptr;\n+\n+  if (ctrl->is_IfProj()) {\n+    iff = ctrl->in(TypeFunc::Control);\n+  }\n+\n+  if (iff != nullptr && iff->is_If()) {\n+    ctrl = iff->find_exact_control(iff->in(TypeFunc::Control));\n+    \/\/ if substr controls startsWith, hoist startsWith\n+    if (ctrl == substr) {\n+      \/\/ invalidate the nullcheck of substring\n+      iff->replace_edge(iff->in(1), C->top());\n+      C->for_igvn()->push(iff);\n+\n+      \/\/ rewrite defs using the defs of substr\n+      for (node_idx_t idx = TypeFunc::Control; idx < TypeFunc::Parms; ++idx) {\n+        startsWith->replace_edge(startsWith->in(idx), substr->in(idx));\n+      }\n+    }\n+  }\n+\n+  JVMState* jvms = clone_substr_jvms(substr);\n+  GraphKit kit(jvms);\n+\n+  ctrl = startsWith->in(TypeFunc::Control);\n+  kit.set_control(ctrl);\n+  kit.push(base);\n+  kit.push(beg_idx);\n+  kit.push(end_idx);\n+\n+  Node* base_len = kit.load_String_length(base, false);\n+  RegionNode* throwEx = new RegionNode(1);\n+  kit.gvn().set_type(throwEx, Type::CONTROL);\n+\n+  \/\/ check IndexOutofBoundsException in java.lang.String::checkBoundsOffCount\n+  \/\/ (begin < 0 || begin > end || end > length)\n+  IfNode* check = kit.create_and_map_if(ctrl, __ Bool(__ CmpI(beg_idx, __ intcon(0)), BoolTest::lt),\n+                                      PROB_MIN, COUNT_UNKNOWN);\n+  throwEx->add_req(__ IfTrue(check));\n+  check = kit.create_and_map_if(__ IfFalse(check), __ Bool(__ CmpI(beg_idx, end_idx), BoolTest::gt),\n+                                      PROB_MIN, COUNT_UNKNOWN);\n+  throwEx->add_req(__ IfTrue(check));\n+  check = kit.create_and_map_if(__ IfFalse(check), __ Bool(__ CmpI(end_idx, base_len), BoolTest::gt),\n+                                      PROB_MIN, COUNT_UNKNOWN);\n+  throwEx->add_req(__ IfTrue(check));\n+\n+  Node* normal = __ IfFalse(check);\n+  ctrl->replace_edge(startsWith, normal);\n+  startsWith->set_req(TypeFunc::Control, normal);\n+\n+  {\n+    \/\/ instead of constructing an IndexOutofBoundsException with offset index,\n+    \/\/ just punt to the interpreter and reexecute substring()\n+    PreserveJVMState pjvms(&kit);\n+    kit.set_control(throwEx);\n+    C->record_for_igvn(throwEx);\n+    kit.uncommon_trap(Deoptimization::Reason_intrinsic,\n+                      Deoptimization::Action_none);\n+  }\n+\n+  if (castpp->outcnt() == 0 && substr->outcnt() > 0) {\n+    eliminate_call(substr, projs);\n+    assert(substr->outcnt() == 0, \"failed to eliminate substring call\");\n+\n+#ifndef PRODUCT\n+    substring_eliminated++;\n+    if (PrintOptimizeSubstring) {\n+      tty->print_cr(\"eliminate substring:\");\n+      substr->dump(0);\n+    }\n+#endif\n+  }\n+}\n+\n+void PhaseStringOpts::optimize_for_substring() {\n+  Node_List calls = collect_interesting_calls<is_string_startsWith>();\n+\n+  for (uint i = 0; i < calls.size(); ++i) {\n+    CallStaticJavaNode* call = calls[i]->as_CallStaticJava();\n+\n+    Node* castpp = call->in(TypeFunc::Parms);\n+    if (castpp->Opcode() == Op_CastPP && castpp->in(1)->is_Proj()) {\n+      CallStaticJavaNode* substr = castpp->in(1)->in(0)->isa_CallStaticJava();\n+      CallProjections projs;\n+\n+      if (substr != nullptr && substr->method() != nullptr &&\n+          substr->method()->is_string_substring()) {\n+        substr->extract_projections(&projs, true);\n+#ifndef PRODUCT\n+        if (PrintOptimizeSubstring) {\n+          tty->print_cr(\"[optimize_startsWith] before:\");\n+          call->dump(0);\n+        }\n+#endif \/*PRODUCT*\/\n+\n+        optimize_startsWith(substr, call, castpp, projs);\n+\n+#ifndef PRODUCT\n+        if (PrintOptimizeSubstring) {\n+          tty->print_cr(\"[optimize_startsWith] after:\");\n+          call->dump(0);\n+        }\n+#endif \/*PRODUCT*\/\n+      }\n+    }\n+  }\n+}\n@@ -599,1 +771,5 @@\n-  assert(OptimizeStringConcat, \"shouldn't be here\");\n+  if (OptimizeSubstring && C->has_stringsubstring()) {\n+    optimize_for_substring();\n+  }\n+\n+  if(!OptimizeStringConcat) return;\n@@ -619,1 +795,1 @@\n-  Node_List toStrings = collect_toString_calls();\n+  Node_List toStrings = collect_interesting_calls<is_SB_toString>();\n@@ -633,1 +809,1 @@\n-      if (arg->is_Proj() && StringConcat::is_SB_toString(arg->in(0))) {\n+      if (arg->is_Proj() && is_SB_toString(arg->in(0))) {\n@@ -1989,0 +2165,10 @@\n+\n+#ifndef PRODUCT\n+int PhaseStringOpts::substring_eliminated = 0;\n+\n+void PhaseStringOpts::print_statistics() {\n+  if (OptimizeSubstring) {\n+    tty->print_cr(\"OptimizeSubstring: substring_eliminated= %d\", substring_eliminated);\n+  }\n+}\n+#endif \/*PRODUCT*\/\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":249,"deletions":63,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+typedef bool (*Predicate)(Node*);\n@@ -52,2 +53,2 @@\n-  \/\/ Collect a list of all SB.toString calls\n-  Node_List collect_toString_calls();\n+  template <Predicate Pred>\n+  Node_List collect_interesting_calls();\n@@ -107,0 +108,5 @@\n+  void eliminate_call(CallNode* call, CallProjections& projs);\n+  void optimize_for_substring();\n+  void optimize_startsWith(CallJavaNode* substr, CallJavaNode* startsWith, Node* castpp, CallProjections& projs);\n+  JVMState* clone_substr_jvms(CallJavaNode* call);\n+\n@@ -114,0 +120,1 @@\n+  NOT_PRODUCT(static int substring_eliminated;)\n@@ -116,0 +123,1 @@\n+  NOT_PRODUCT(static void print_statistics();)\n","filename":"src\/hotspot\/share\/opto\/stringopts.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1499,0 +1499,1 @@\n+    @IntrinsicCandidate\n@@ -1905,0 +1906,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary verify that -XX:+OptimizeSubstring removes String.substring()\n+ * @library \/test\/lib \/\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4) & vm.debug == true\n+ * @requires !vm.emulatedClient & !vm.graal.enabled\n+ * @run driver compiler.c2.TestOptimizeSubstring\n+ *\/\n+\n+package compiler.c2;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+\n+public class TestOptimizeSubstring {\n+\n+    public static void main (String args[]) {\n+        if (args.length == 0) {\n+            check(true);  \/\/ check generated code when c2 enables OptimizeSubstring\n+            check(false); \/\/ ... and disabled\n+        }\n+        else {\n+            boolean val1 = false;\n+            boolean val2 = false;\n+            boolean caughtEx;\n+\n+            for (int i = 0; i < 20_000; ++i) {\n+                val1 |= TestOptimizeSubstring.useStartsWith(\"abcdef\");\n+                val2 |= TestOptimizeSubstring.useStartsWith(\"efgdedf\");\n+\n+                caughtEx = false;\n+                try {\n+                    TestOptimizeSubstring.useStartsWith(\"\");\n+                } catch(StringIndexOutOfBoundsException e) {\n+                    caughtEx = true;\n+                }\n+                Asserts.assertTrue(caughtEx, \"useStartsWith(\\\"\\\") should throw StringIndexOutOfBoundsException\");\n+            }\n+\n+            Asserts.assertTrue (val1, \"val1 should be true\");\n+            Asserts.assertFalse(val2, \"val2 should be false\");\n+        }\n+    }\n+\n+    private static void check(boolean enabled) {\n+        OutputAnalyzer oa;\n+        \/\/ ideally, we should check the opcode 'call' as well, but x86_32.ad uses all CAPITAL opcodes.\n+        \/\/ the feature is 'CALL, static  wrapper for: _new_array_nozero_Java' on i686.\n+        String newStringAlloc = \/*call ,*\/\"static  wrapper for: _new_array_nozero_Java\";\n+        try {\n+            oa = ProcessTools.executeTestJvm(\"-XX:+UnlockDiagnosticVMOptions\", \"-Xbootclasspath\/a:.\",\n+                    \"-XX:\" + (enabled ? \"+\" : \"-\") + \"OptimizeSubstring\",\n+                    \"-XX:+PrintOptoAssembly\", \"-XX:-TieredCompilation\",\n+                    \"-XX:CompileOnly=\" + TestOptimizeSubstring.class.getName() + \"::useStartsWith\",\n+                    TestOptimizeSubstring.class.getName(),\n+                    \"runtest\");\n+        } catch (Exception e) {\n+            throw new Error(\"Exception launching child for case enabled=\" + enabled + \" : \" + e, e);\n+        }\n+        oa.shouldHaveExitValue(0);\n+\n+        if (enabled) {\n+            oa.shouldNotContain(newStringAlloc);\n+        } else {\n+            oa.shouldContain(newStringAlloc);\n+        }\n+   }\n+\n+    private static boolean useStartsWith(String s) {\n+        String x = s.substring(1);\n+        return x.startsWith(\"a\") | x.startsWith(\"b\") | x.startsWith(\"c\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestOptimizeSubstring.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 200, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 25, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+public class SubstringStartsWith {\n+    \/\/ model substrings in 3 representative lengths.\n+    \/\/ 1. small size = 4 for a variable name\n+    \/\/ 2. medium size = 24 or url or a filepath\n+    \/\/ 3. long string = 256 for a human-readable message\n+    @Param({\"4\", \"24\", \"256\"})\n+    private int substrLength;\n+    private String sample_ascii;\n+    private String sample_utf16;\n+    private String prefix_ascii;\n+    private String prefix_utf16;\n+\n+    @Setup(Level.Trial)\n+    public void doSetup() {\n+       StringBuilder sb = new StringBuilder();\n+       String tile = \"abcdef\";\n+       for (int i=0; i<512 * 2; i = i + tile.length()) {\n+           sb.append(tile);\n+       }\n+       sample_ascii = sb.toString();\n+       prefix_ascii = sample_ascii.substring(0, 2);\n+\n+       sb = new StringBuilder();\n+       tile = \"\\u4F60\\u597D\\u3088\\u3046\\u3053\\u305DJava\";\n+       for (int i=0; i<512 * 2; i = i + tile.length()) {\n+           sb.append(tile);\n+       }\n+       sample_utf16 = sb.toString();\n+       prefix_utf16 = sample_utf16.substring(0, 2);\n+    }\n+\n+    boolean substr2StartsWith(String base, String prefix) {\n+        return base.substring(1, 1 + substrLength).startsWith(prefix);\n+    }\n+\n+    boolean substr2StartsWith_noalloc(String base, String prefix) {\n+        \/\/boundary check as same as java.lang.String::checkBoundsBeginEnd\n+        int begin = 1;\n+        int end = begin + substrLength;\n+        if (begin < 0 || begin > end || end > base.length()) {\n+            throw new StringIndexOutOfBoundsException(\n+                \"begin \" + begin + \", end \" + end + \", length \" + base.length());\n+        }\n+\n+        return base.startsWith(prefix, begin);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_singleByte() {\n+        return substr2StartsWith(sample_ascii, prefix_ascii);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_noalloc_singleByte() {\n+        return substr2StartsWith_noalloc(sample_ascii, prefix_ascii);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_doubleBytes() {\n+        return substr2StartsWith(sample_utf16, prefix_utf16);\n+    }\n+\n+    @Benchmark\n+    public boolean substr2StartsWith_noalloc_doubleBytes() {\n+        return substr2StartsWith_noalloc(sample_utf16, prefix_utf16);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/SubstringStartsWith.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"}]}