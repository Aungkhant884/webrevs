{"files":[{"patch":"@@ -71,0 +71,1 @@\n+import jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;\n@@ -1769,1 +1770,2 @@\n-            if (service == null) {\n+            LoggerFinder finder = service;\n+            if (finder == null) {\n@@ -1772,1 +1774,1 @@\n-                service = AccessController.doPrivileged(pa, null,\n+                finder = AccessController.doPrivileged(pa, null,\n@@ -1774,0 +1776,2 @@\n+                if (finder instanceof TemporaryLoggerFinder) return finder;\n+                service = finder;\n@@ -1775,1 +1779,1 @@\n-            return service;\n+            return finder;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.lang.System.Logger.Level;\n@@ -230,0 +229,3 @@\n+    \/\/ tests whether the logger is invoked by the loading thread before\n+    \/\/ the LoggerFinder is loaded; can be null;\n+    final BooleanSupplier isLoadingThread;\n@@ -231,1 +233,7 @@\n-    BootstrapLogger(LazyLoggerAccessor holder) {\n+    \/\/ returns true if the logger is invoked by the loading thread before the\n+    \/\/ LoggerFinder service is loaded\n+    boolean isLoadingThread() {\n+        return isLoadingThread != null && isLoadingThread.getAsBoolean();\n+    }\n+\n+    BootstrapLogger(LazyLoggerAccessor holder, BooleanSupplier isLoadingThread) {\n@@ -233,0 +241,1 @@\n+        this.isLoadingThread = isLoadingThread;\n@@ -508,1 +517,1 @@\n-                log.log(logger);\n+                BootstrapExecutors.submit(() -> log.log(logger));\n@@ -513,3 +522,4 @@\n-                AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-                    log.log(logger); return null;\n-                }, log.acc);\n+                BootstrapExecutors.submit(() ->\n+                    AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+                        log.log(logger); return null;\n+                }, log.acc));\n@@ -562,1 +572,1 @@\n-        if (isBooted()) {\n+        if (isBooted() && !isLoadingThread()) {\n@@ -564,0 +574,1 @@\n+            holder.getConcreteLogger(this);\n@@ -938,4 +949,10 @@\n-    public static synchronized boolean useLazyLoggers() {\n-        return !BootstrapLogger.isBooted()\n-                || DetectBackend.detectedBackend == LoggingBackend.CUSTOM\n-                || useSurrogateLoggers();\n+    public static boolean useLazyLoggers() {\n+        \/\/ Note: avoid triggering the initialization of the DetectBackend class\n+        \/\/ while holding the BootstrapLogger class monitor\n+        if (!BootstrapLogger.isBooted() ||\n+                DetectBackend.detectedBackend == LoggingBackend.CUSTOM) {\n+            return true;\n+        }\n+        synchronized (BootstrapLogger.class) {\n+            return useSurrogateLoggers();\n+        }\n@@ -949,3 +966,3 @@\n-    static Logger getLogger(LazyLoggerAccessor accessor) {\n-        if (!BootstrapLogger.isBooted()) {\n-            return new BootstrapLogger(accessor);\n+    static Logger getLogger(LazyLoggerAccessor accessor, BooleanSupplier isLoading) {\n+        if (!BootstrapLogger.isBooted() || isLoading != null && isLoading.getAsBoolean()) {\n+            return new BootstrapLogger(accessor, isLoading);\n@@ -967,0 +984,6 @@\n+    \/\/ trigger class initialization outside of holding lock\n+    static void ensureBackendDetected() {\n+        assert VM.isBooted() : \"VM is not booted\";\n+        \/\/ triggers detection of the backend\n+        var backend = DetectBackend.detectedBackend;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/BootstrapLogger.java","additions":38,"deletions":15,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import java.util.function.BooleanSupplier;\n+\n+import jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;\n@@ -77,0 +80,1 @@\n+\n@@ -113,0 +117,3 @@\n+        \/\/ whether this is the loading thread, can be null\n+        private final BooleanSupplier isLoadingThread;\n+\n@@ -125,0 +132,7 @@\n+            this(name, factories, module, null);\n+        }\n+\n+        private LazyLoggerAccessor(String name,\n+                                   LazyLoggerFactories<? extends Logger> factories,\n+                                   Module module, BooleanSupplier isLoading) {\n+\n@@ -126,1 +140,1 @@\n-                    Objects.requireNonNull(module), null);\n+                    Objects.requireNonNull(module), isLoading, null);\n@@ -131,1 +145,1 @@\n-                                   Module module, Void unused) {\n+                                   Module module, BooleanSupplier isLoading, Void unused) {\n@@ -135,0 +149,1 @@\n+            this.isLoadingThread = isLoading;\n@@ -165,1 +180,1 @@\n-            wrapped = BootstrapLogger.getLogger(this);\n+            wrapped = BootstrapLogger.getLogger(this, isLoadingThread);\n@@ -197,1 +212,1 @@\n-            final Logger wrapped = BootstrapLogger.getLogger(this);\n+            final Logger wrapped = BootstrapLogger.getLogger(this, isLoadingThread);\n@@ -285,1 +300,0 @@\n-         * @param <T> An interface that extends {@link Logger}.\n@@ -289,0 +303,1 @@\n+         * @param module The module for which the logger is being created\n@@ -343,0 +358,1 @@\n+            if (prov instanceof TemporaryLoggerFinder) return prov;\n@@ -362,1 +378,0 @@\n-\n@@ -380,0 +395,5 @@\n+    static Logger makeLazyLogger(String name, Module module, BooleanSupplier isLoading) {\n+        final LazyLoggerAccessor holder = new LazyLoggerAccessor(name, factories, module, isLoading);\n+        return new JdkLazyLogger(holder, null);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/LazyLoggers.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.System.Logger;\n+import java.lang.System.LoggerFinder;\n@@ -35,0 +37,3 @@\n+import java.util.function.BooleanSupplier;\n+\n+import jdk.internal.vm.annotation.Stable;\n@@ -68,1 +73,2 @@\n-\n+    \/\/ record the loadingThread while loading the backend\n+    static volatile Thread loadingThread;\n@@ -72,0 +78,2 @@\n+        \/\/ ensure backend is detected before attempting to load the finder\n+        BootstrapLogger.ensureBackendDetected();\n@@ -74,1 +82,13 @@\n-            service = loadLoggerFinder();\n+            Thread currentThread = Thread.currentThread();\n+            if (loadingThread == currentThread) {\n+                \/\/ recursive attempt to load the backend while loading the backend\n+                \/\/ use a temporary logger finder that returns special BootstrapLogger\n+                \/\/ which will wait until loading is finished\n+                return TemporaryLoggerFinder.INSTANCE;\n+            }\n+            loadingThread = currentThread;\n+            try {\n+                service = loadLoggerFinder();\n+            } finally {\n+                loadingThread = null;\n+            }\n@@ -82,0 +102,6 @@\n+    \/\/ returns true if called by the thread that loads the LoggerFinder, while\n+    \/\/ loading the LoggerFinder.\n+    static boolean isLoadingThread() {\n+        return loadingThread != null && loadingThread == Thread.currentThread();\n+    }\n+\n@@ -120,0 +146,28 @@\n+    public static final class TemporaryLoggerFinder extends LoggerFinder {\n+        private TemporaryLoggerFinder() {}\n+        @Stable\n+        private LoggerFinder loadedService;\n+\n+        private static final BooleanSupplier isLoadingThread = new BooleanSupplier() {\n+            @Override\n+            public boolean getAsBoolean() {\n+                return LoggerFinderLoader.isLoadingThread();\n+            }\n+        };\n+        private static final TemporaryLoggerFinder INSTANCE = new TemporaryLoggerFinder();\n+\n+        @Override\n+        public Logger getLogger(String name, Module module) {\n+            if (loadedService == null) {\n+                loadedService = service;\n+                if (loadedService == null) {\n+                    return LazyLoggers.makeLazyLogger(name, module, isLoadingThread);\n+                }\n+            }\n+            assert loadedService != null;\n+            assert !LoggerFinderLoader.isLoadingThread();\n+            assert loadedService != this;\n+            return LazyLoggers.getLogger(name, module);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/LoggerFinderLoader.java","additions":57,"deletions":3,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+loggerfinder.SimpleLoggerFinder\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/RecursiveLoading\/META-INF\/services\/java.lang.System$LoggerFinder","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8314263\n+ * @summary Creating a logger while loading the Logger finder\n+ *          triggers recursion and StackOverflowError\n+ * @modules java.base\/sun.util.logging\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.process.*\n+ *        jdk.test.lib.util.JarUtils\n+ *        jdk.test.lib.JDKToolLauncher\n+ * @compile RecursiveLoadingTest.java SimpleLoggerFinder.java\n+ * @run main\/othervm PlatformRecursiveLoadingTest\n+ *\/\n+\n+\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.LogRecord;\n+\n+import sun.util.logging.PlatformLogger;\n+\n+public class PlatformRecursiveLoadingTest {\n+\n+    \/**\n+     * This test triggers recursion in the broken JDK. The error can\n+     * manifest in a few different ways.\n+     * One error seen is \"java.lang.NoClassDefFoundError:\n+     * Could not initialize class jdk.internal.logger.LoggerFinderLoader$ErrorPolicy\"\n+     *\n+     * The original reported error was a StackOverflow (also seen in different iterations\n+     * of this run). Running test in signed and unsigned jar mode for sanity coverage.\n+     * The current bug only manifests when jars are signed.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        PlatformLogger.getLogger(\"main\").info(\"in main\");\n+        List<Object> logs = loggerfinder.SimpleLoggerFinder.LOGS;\n+\t\/*\n+        logs.stream().map(SimpleLogRecord::of).forEach(System.out::println);\n+        logs.stream().map(SimpleLogRecord::of).forEach(SimpleLogRecord::check);\n+        assertEquals(String.valueOf(logs.size()), String.valueOf(2));*\/\n+    }\n+\n+    static List<Object> asList(Object[] params) {\n+        return params == null ? null : Arrays.asList(params);\n+    }\n+\n+    record SimpleLogRecord(String message, Instant instant, String loggerName,\n+                           java.util.logging.Level level, List<Object> params,\n+                           String resourceBundleName, long seqNumber,\n+                           String sourceClassName, String methodName, Throwable thrown) {\n+        SimpleLogRecord(LogRecord record) {\n+            this(record.getMessage(), record.getInstant(), record.getLoggerName(), record.getLevel(),\n+                    asList(record.getParameters()), record.getResourceBundleName(), record.getSequenceNumber(),\n+                    record.getSourceClassName(), record.getSourceMethodName(), record.getThrown());\n+        }\n+        static SimpleLogRecord of(Object o) {\n+            return (o instanceof LogRecord record) ? new SimpleLogRecord(record) : null;\n+        }\n+        static SimpleLogRecord check(SimpleLogRecord record) {\n+            if (record.loggerName.equals(\"dummy\")) {\n+                assertEquals(record.sourceClassName, \"jdk.internal.logger.BootstrapLogger$LogEvent\");\n+                assertEquals(record.methodName(), \"log\");\n+            }\n+            if (record.loggerName.equals(\"main\")) {\n+                assertEquals(record.sourceClassName, PlatformRecursiveLoadingTest.class.getName());\n+                assertEquals(record.methodName, \"main\");\n+            }\n+            return record;\n+        }\n+    }\n+\n+    private static void assertEquals(String received, String expected) {\n+        if (!expected.equals(received)) {\n+            throw new RuntimeException(\"Received: \" + received);\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/RecursiveLoading\/PlatformRecursiveLoadingTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8314263\n+ * @summary Creating a logger while loading the Logger finder\n+ *          triggers recursion and StackOverflowError\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.process.*\n+ *        jdk.test.lib.util.JarUtils\n+ *        jdk.test.lib.JDKToolLauncher\n+ * @compile RecursiveLoadingTest.java SimpleLoggerFinder.java\n+ * @run main\/othervm RecursiveLoadingTest\n+ *\/\n+\n+\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.LogRecord;\n+\n+public class RecursiveLoadingTest {\n+\n+    \/**\n+     * This test triggers recursion in the broken JDK. The error can\n+     * manifest in a few different ways.\n+     * One error seen is \"java.lang.NoClassDefFoundError:\n+     * Could not initialize class jdk.internal.logger.LoggerFinderLoader$ErrorPolicy\"\n+     *\n+     * The original reported error was a StackOverflow (also seen in different iterations\n+     * of this run). Running test in signed and unsigned jar mode for sanity coverage.\n+     * The current bug only manifests when jars are signed.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        System.getLogger(\"main\").log(System.Logger.Level.INFO, \"in main\");\n+        List<Object> logs = loggerfinder.SimpleLoggerFinder.LOGS;\n+        logs.stream().map(SimpleLogRecord::of).forEach(System.out::println);\n+        logs.stream().map(SimpleLogRecord::of).forEach(SimpleLogRecord::check);\n+        assertEquals(String.valueOf(logs.size()), String.valueOf(2));\n+    }\n+\n+    static List<Object> asList(Object[] params) {\n+        return params == null ? null : Arrays.asList(params);\n+    }\n+\n+    record SimpleLogRecord(String message, Instant instant, String loggerName,\n+                           java.util.logging.Level level, List<Object> params,\n+                           String resourceBundleName, long seqNumber,\n+                           String sourceClassName, String methodName, Throwable thrown) {\n+        SimpleLogRecord(LogRecord record) {\n+            this(record.getMessage(), record.getInstant(), record.getLoggerName(), record.getLevel(),\n+                    asList(record.getParameters()), record.getResourceBundleName(), record.getSequenceNumber(),\n+                    record.getSourceClassName(), record.getSourceMethodName(), record.getThrown());\n+        }\n+        static SimpleLogRecord of(Object o) {\n+            return (o instanceof LogRecord record) ? new SimpleLogRecord(record) : null;\n+        }\n+        static SimpleLogRecord check(SimpleLogRecord record) {\n+            if (record.loggerName.equals(\"dummy\")) {\n+                assertEquals(record.sourceClassName, \"jdk.internal.logger.BootstrapLogger$LogEvent\");\n+                assertEquals(record.methodName(), \"log\");\n+            }\n+            if (record.loggerName.equals(\"main\")) {\n+                assertEquals(record.sourceClassName, RecursiveLoadingTest.class.getName());\n+                assertEquals(record.methodName, \"main\");\n+            }\n+            return record;\n+        }\n+    }\n+\n+    private static void assertEquals(String received, String expected) {\n+        if (!expected.equals(received)) {\n+            throw new RuntimeException(\"Received: \" + received);\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/RecursiveLoading\/RecursiveLoadingTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package loggerfinder;\n+\n+import java.lang.*;\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+public class SimpleLoggerFinder extends System.LoggerFinder {\n+\n+    static {\n+        try {\n+            long sleep = new Random().nextLong(1000L) + 1L;\n+            \/\/ simulate a slow load service\n+            Thread.sleep(sleep);\n+            System.getLogger(\"dummy\")\n+                    .log(System.Logger.Level.INFO,\n+                            \"Logger finder service load sleep value: \" + sleep);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static final CopyOnWriteArrayList<Object> LOGS = new CopyOnWriteArrayList<>();\n+\n+    @Override\n+    public System.Logger getLogger(String name, Module module) {\n+        return new SimpleLogger(name);\n+    }\n+\n+    private static class SimpleLogger implements System.Logger {\n+        private final java.util.logging.Logger logger;\n+\n+        private static final class SimpleHandler extends Handler {\n+            @Override\n+            public void publish(LogRecord record) {\n+                LOGS.add(record);\n+            }\n+            @Override public void flush() { }\n+            @Override public void close() { }\n+        }\n+\n+        public SimpleLogger(String name) {\n+            logger = Logger.getLogger(name);\n+            logger.addHandler(new SimpleHandler());\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return logger.getName();\n+        }\n+\n+        java.util.logging.Level level(Level level) {\n+            return switch (level) {\n+                case ALL -> java.util.logging.Level.ALL;\n+                case DEBUG -> java.util.logging.Level.FINE;\n+                case TRACE -> java.util.logging.Level.FINER;\n+                case INFO -> java.util.logging.Level.INFO;\n+                case WARNING -> java.util.logging.Level.WARNING;\n+                case ERROR -> java.util.logging.Level.SEVERE;\n+                case OFF -> java.util.logging.Level.OFF;\n+            };\n+        }\n+\n+        @Override\n+        public boolean isLoggable(Level level) {\n+            return logger.isLoggable(level(level));\n+        }\n+\n+        @Override\n+        public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n+            var julLevel = level(level);\n+            if (!logger.isLoggable(julLevel)) return;\n+            if (bundle != null) {\n+                logger.logrb(julLevel, bundle, msg, thrown);\n+            } else {\n+                logger.log(julLevel, msg, thrown);\n+            }\n+        }\n+\n+        @Override\n+        public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n+            var julLevel = level(level);\n+            if (!logger.isLoggable(julLevel)) return;\n+            if (params == null) {\n+                if (bundle == null) {\n+                    logger.log(julLevel, format);\n+                } else {\n+                    logger.logrb(julLevel, bundle, format);\n+                }\n+            } else {\n+                if (bundle == null) {\n+                    logger.log(julLevel, format, params);\n+                } else {\n+                    logger.logrb(julLevel, bundle, format, params);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/RecursiveLoading\/SimpleLoggerFinder.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+loggerfinder.SimpleLoggerFinder\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/META-INF\/services\/java.lang.System$LoggerFinder","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8314263\n+ * @summary Signed jars triggering Logger finder recursion and StackOverflowError\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.process.*\n+ *        jdk.test.lib.util.JarUtils\n+ *        jdk.test.lib.JDKToolLauncher\n+ * @compile SignedLoggerFinderTest.java SimpleLoggerFinder.java\n+ * @run main SignedLoggerFinderTest init\n+ * @run main SignedLoggerFinderTest init sign\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.*;\n+import java.security.*;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.jar.*;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.JarUtils;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static java.util.Arrays.asList;\n+\n+public class SignedLoggerFinderTest {\n+\n+    \/**\n+     * This test triggers recursion in the broken JDK. The error can\n+     * manifest in a few different ways.\n+     * One error seen is \"java.lang.NoClassDefFoundError:\n+     * Could not initialize class jdk.internal.logger.LoggerFinderLoader$ErrorPolicy\"\n+     *\n+     * The original reported error was a StackOverflow (also seen in different iterations\n+     * of this run). Running test in signed and unsigned jar mode for sanity coverage.\n+     * The current bug only manifests when jars are signed.\n+     *\/\n+\n+    private static boolean init = false;\n+    private static boolean signJars = false;\n+    private static boolean mutliThreadLoad = false;\n+    private static volatile boolean testComplete = false;\n+\n+    private static final String KEYSTORE = \"8314263.keystore\";\n+    private static final String ALIAS = \"JavaTest\";\n+    private static final String STOREPASS = \"changeit\";\n+    private static final String KEYPASS = \"changeit\";\n+    private static final String DNAME = \"CN=sample\";\n+    private static final String CUSTOM_LOGGER_FINDER_NAME =\n+            \"loggerfinder.SimpleLoggerFinder\";\n+    private static final String CUSTOM_LOGGER_NAME =\n+            \"loggerfinder.SimpleLoggerFinder$SimpleLogger\";\n+    private static final String INTERNAL_LOGGER_FINDER_NAME =\n+            \"sun.util.logging.internal.LoggingProviderImpl\";\n+    private static final String INTERNAL_LOGGER_NAME =\n+            \"sun.util.logging.internal.LoggingProviderImpl$JULWrapper\";\n+    private static final Path jarPath1 =\n+        Path.of(System.getProperty(\"test.classes\", \".\"), \"SimpleLoggerFinder.jar\");\n+    private static final Path jarPath2 =\n+            Path.of(System.getProperty(\"test.classes\", \".\"), \"SimpleLoggerFinder2.jar\");\n+\n+    public static void main(String[] args) throws Throwable {\n+        init = args.length >=1 && args[0].equals(\"init\");\n+        signJars = args.length >=2 && args[1].equals(\"sign\");\n+\n+        \/\/ init only passed in by jtreg test run, initialize the environment\n+        \/\/ for the subsequent test run\n+        if (init) {\n+            initialize();\n+            launchTest(false, false);\n+            launchTest(false, true);\n+            launchTest(true, false);\n+            launchTest(true, true);\n+\n+        } else {\n+            \/\/ set up complete. Run the code to trigger the recursion\n+            \/\/ We're in the JVM launched by ProcessTools.executeCommand\n+            boolean mutliThreadLoad =\n+                Boolean.parseBoolean(System.getProperty(\"mutliThreadLoad\", \"false\"));\n+            boolean withCustomLoggerFinder =\n+                Boolean.parseBoolean(System.getProperty(\"withCustomLoggerFinder\", \"false\"));\n+\n+            if (mutliThreadLoad) {\n+                long sleep = new Random().nextLong(100L) + 1L;\n+                System.out.println(\"multi thread load sleep value: \" + sleep);\n+                new Thread(runnableWithSleep(\n+                        () -> System.getLogger(\"logger\" + System.currentTimeMillis()),\n+                        sleep, \"System.getLogger type: \")).start();\n+                new Thread(runnableWithSleep(\n+                        () -> System.LoggerFinder.getLoggerFinder(),\n+                        sleep, \"System.getLoggerFinder type: \")).start();\n+            }\n+\n+            if (withCustomLoggerFinder) {\n+                JarFile jf = new JarFile(jarPath1.toString(), true);\n+                jf.getInputStream(jf.getJarEntry(\"loggerfinder\/SimpleLoggerFinder.class\"));\n+                JarFile jf2 = new JarFile(jarPath2.toString(), true);\n+                jf2.getInputStream(jf.getJarEntry(\"loggerfinder\/SimpleLoggerFinder.class\"));\n+            } else {\n+                \/\/ some other call to prod LoggerFinder loading\n+                System.getLogger(\"random\" + System.currentTimeMillis());\n+                System.LoggerFinder.getLoggerFinder();\n+            }\n+            Security.setProperty(\"test_1\", \"test\");\n+\n+            \/\/ some extra sanity checks\n+            if (withCustomLoggerFinder) {\n+                assertEquals(System.LoggerFinder.getLoggerFinder().getClass().getName(),\n+                        CUSTOM_LOGGER_FINDER_NAME);\n+                System.Logger testLogger = System.getLogger(\"jdk.event.security\");\n+                assertEquals(testLogger.getClass().getName(), CUSTOM_LOGGER_NAME);\n+            } else {\n+                if (signJars) {\n+                    assertEquals(System.LoggerFinder.getLoggerFinder().getClass().getName(),\n+                            INTERNAL_LOGGER_FINDER_NAME);\n+                    System.Logger testLogger = System.getLogger(\"jdk.event.security\");\n+                    assertEquals(testLogger.getClass().getName(), INTERNAL_LOGGER_FINDER_NAME);\n+                } else {\n+                    assertEquals(System.LoggerFinder.getLoggerFinder().getClass().getName(),\n+                            INTERNAL_LOGGER_FINDER_NAME);\n+                    System.Logger testLogger = System.getLogger(\"jdk.event.security\");\n+                    assertEquals(testLogger.getClass().getName(), INTERNAL_LOGGER_NAME);\n+                }\n+            }\n+            testComplete = true;\n+\n+            \/\/ LoggerFinder should be initialized, trigger a simple log call\n+            Security.setProperty(\"test_2\", \"test\");\n+        }\n+    }\n+\n+    \/\/ helper to create the inner test. Run config variations with the LoggerFinder jars\n+    \/\/ on the classpath and with other threads running System.Logger calls during load\n+    private static void launchTest(boolean mutliThreadLoad, boolean withCustomLoggerFinder) {\n+        List<String> cmds = new ArrayList<>();\n+        cmds.add(JDKToolFinder.getJDKTool(\"java\"));\n+        cmds.addAll(asList(Utils.getTestJavaOpts()));\n+        if (withCustomLoggerFinder) {\n+            cmds.addAll(List.of(\"-classpath\",\n+                System.getProperty(\"test.classes\") + File.pathSeparator +\n+                jarPath1.toString() + File.pathSeparator + jarPath2.toString(),\n+                \"-Dtest.classes=\" + System.getProperty(\"test.classes\")));\n+        } else {\n+            cmds.addAll(List.of(\"-classpath\",\n+                System.getProperty(\"test.classes\")));\n+        }\n+        cmds.addAll(List.of(\n+            \/\/ following debug property seems useful to tickle the issue\n+            \"-Dsun.misc.URLClassPath.debug=true\",\n+            \/\/ console logger level to capture event output\n+            \"-Djdk.system.logger.level=DEBUG\",\n+            \/\/ useful for debug purposes\n+            \"-Djdk.logger.finder.error=DEBUG\",\n+            \/\/ enable logging to verify correct output\n+            \"-Djava.util.logging.config.file=\" +\n+                    Path.of(System.getProperty(\"test.src\", \".\"), \"logging.properties\")));\n+        if (mutliThreadLoad) {\n+            cmds.add(\"-DmutliThreadLoad=true\");\n+        }\n+        if (withCustomLoggerFinder) {\n+            cmds.add(\"-DwithCustomLoggerFinder=true\");\n+        }\n+        cmds.addAll(List.of(\n+            \"SignedLoggerFinderTest\",\n+            \"no-init\"));\n+\n+        try {\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeCommand(cmds.stream()\n+                    .filter(t -> !t.isEmpty())\n+                    .toArray(String[]::new))\n+                    .shouldHaveExitValue(0);\n+            if (withCustomLoggerFinder) {\n+                outputAnalyzer\n+                    .shouldContain(\"TEST LOGGER: [test_1, test]\")\n+                    .shouldContain(\"TEST LOGGER: [test_2, test]\");\n+            } else {\n+                outputAnalyzer\n+                    .shouldContain(\"SecurityPropertyModification: key:test_1\")\n+                    .shouldContain(\"SecurityPropertyModification: key:test_2\");\n+            }\n+            if (withCustomLoggerFinder && signJars) {\n+                \/\/ X509 cert generated during verification of signed jar file\n+                outputAnalyzer\n+                    .shouldContain(DNAME);\n+            }\n+\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Unexpected fail.\", t);\n+        }\n+    }\n+\n+    private static Runnable runnableWithSleep(Supplier s, long sleep, String desc) {\n+        return () -> {\n+            while(!testComplete) {\n+                System.out.println(desc + s.get().getClass().getName());\n+                try {\n+                    Thread.sleep(sleep);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+    }\n+\n+    private static void initialize() throws Throwable {\n+        if (signJars) {\n+            genKey();\n+        }\n+\n+        Path classes = Paths.get(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(jarPath1,\n+            classes,\n+            classes.resolve(\"loggerfinder\/SimpleLoggerFinder.class\"),\n+            classes.resolve(\"loggerfinder\/SimpleLoggerFinder$SimpleLogger.class\"));\n+\n+        JarUtils.updateJarFile(jarPath1, Path.of(System.getProperty(\"test.src\")),\n+            Path.of(\"META-INF\", \"services\", \"java.lang.System$LoggerFinder\"));\n+        if (signJars) {\n+            signJar(jarPath1.toString());\n+        }\n+        \/\/ multiple signed jars with services to have ServiceLoader iteration\n+        Files.copy(jarPath1, jarPath2, REPLACE_EXISTING);\n+    }\n+\n+    private static void genKey() throws Throwable {\n+        String keytool = JDKToolFinder.getJDKTool(\"keytool\");\n+        Files.deleteIfExists(Paths.get(KEYSTORE));\n+        ProcessTools.executeCommand(keytool,\n+                \"-J-Duser.language=en\",\n+                \"-J-Duser.country=US\",\n+                \"-genkey\",\n+                \"-keyalg\", \"rsa\",\n+                \"-alias\", ALIAS,\n+                \"-keystore\", KEYSTORE,\n+                \"-keypass\", KEYPASS,\n+                \"-dname\", DNAME,\n+                \"-storepass\", STOREPASS\n+        ).shouldHaveExitValue(0);\n+    }\n+\n+\n+    private static OutputAnalyzer signJar(String jarName) throws Throwable {\n+        List<String> args = new ArrayList<>();\n+        args.add(\"-verbose\");\n+        args.add(jarName);\n+        args.add(ALIAS);\n+\n+        return jarsigner(args);\n+    }\n+\n+    private static OutputAnalyzer jarsigner(List<String> extra)\n+            throws Throwable {\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jarsigner\")\n+                .addVMArg(\"-Duser.language=en\")\n+                .addVMArg(\"-Duser.country=US\")\n+                .addToolArg(\"-keystore\")\n+                .addToolArg(KEYSTORE)\n+                .addToolArg(\"-storepass\")\n+                .addToolArg(STOREPASS)\n+                .addToolArg(\"-keypass\")\n+                .addToolArg(KEYPASS);\n+        for (String s : extra) {\n+            if (s.startsWith(\"-J\")) {\n+                launcher.addVMArg(s.substring(2));\n+            } else {\n+                launcher.addToolArg(s);\n+            }\n+        }\n+        return ProcessTools.executeCommand(launcher.getCommand());\n+    }\n+\n+    private static void assertEquals(String received, String expected) {\n+        if (!expected.equals(received)) {\n+            throw new RuntimeException(\"Received: \" + received);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/SignedLoggerFinderTest.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package loggerfinder;\n+\n+import java.lang.*;\n+import java.util.*;\n+\n+public class SimpleLoggerFinder extends System.LoggerFinder {\n+\n+    static {\n+        try {\n+            long sleep = new Random().nextLong(1000L) + 1L;\n+            System.out.println(\"Logger finder service load sleep value: \" + sleep);\n+            \/\/ simulate a slow load service\n+            Thread.sleep(sleep);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+     @Override\n+     public System.Logger getLogger(String name, Module module) {\n+         return new SimpleLogger(name);\n+     }\n+\n+    private static class SimpleLogger implements System.Logger {\n+        private final String name;\n+\n+        public SimpleLogger(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public boolean isLoggable(Level level) {\n+            return true;\n+        }\n+\n+        @Override\n+        public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n+            System.out.println(\"TEST LOGGER: \" + msg);\n+        }\n+\n+        @Override\n+        public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n+            System.out.println(\"TEST LOGGER: \" + Arrays.asList(params));\n+\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/SimpleLoggerFinder.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -14,0 +14,1 @@\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/logging.properties","additions":1,"deletions":0,"binary":false,"changes":1,"previous_filename":"test\/jdk\/java\/util\/jar\/JarFile\/jarVerification\/logging.properties","status":"copied"}]}