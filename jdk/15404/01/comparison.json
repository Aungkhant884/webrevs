{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -41,1 +42,0 @@\n-import java.lang.System.Logger.Level;\n@@ -230,0 +230,9 @@\n+    \/\/ tests whether the logger is invoked by the loading thread before\n+    \/\/ the LoggerFinder is loaded; can be null;\n+    final BooleanSupplier isLoadingThread;\n+\n+    \/\/ returns true if the logger is invoked by the loading thread before the\n+    \/\/ LoggerFinder service is loaded\n+    boolean isLoadingThread() {\n+        return isLoadingThread != null && isLoadingThread.getAsBoolean();\n+    }\n@@ -232,0 +241,3 @@\n+        this(holder, null);\n+    }\n+    BootstrapLogger(LazyLoggerAccessor holder, BooleanSupplier isLoadingThread) {\n@@ -233,0 +245,1 @@\n+        this.isLoadingThread = isLoadingThread;\n@@ -562,1 +575,1 @@\n-        if (isBooted()) {\n+        if (isBooted() && !isLoadingThread()) {\n@@ -938,4 +951,10 @@\n-    public static synchronized boolean useLazyLoggers() {\n-        return !BootstrapLogger.isBooted()\n-                || DetectBackend.detectedBackend == LoggingBackend.CUSTOM\n-                || useSurrogateLoggers();\n+    public static boolean useLazyLoggers() {\n+        \/\/ Note: avoid triggering the initialization of the DetectBackend class\n+        \/\/ while holding the BotstrapLogger class monitor\n+        if (!BootstrapLogger.isBooted() ||\n+                DetectBackend.detectedBackend == LoggingBackend.CUSTOM) {\n+            return true;\n+        }\n+        synchronized (BootstrapLogger.class) {\n+            return useSurrogateLoggers();\n+        }\n@@ -967,0 +986,12 @@\n+    private static void ensureClassInitialized(Class<?> c) {\n+        try {\n+            MethodHandles.lookup().ensureInitialized(c);\n+        } catch (IllegalAccessException e) {}\n+    }\n+\n+    \/\/ trigger class initialization outside of holding lock\n+    static void detectBackend() {\n+        if (isBooted()) {\n+            ensureClassInitialized(DetectBackend.class);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/BootstrapLogger.java","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+\n@@ -77,0 +78,1 @@\n+\n@@ -296,0 +298,8 @@\n+        public static <T extends Logger>\n+        LazyLoggerAccessor makeAccessorFromSupplier(String name,\n+                                                   BiFunction<String, Module, T> supplier,\n+                                                   Module module) {\n+            LazyLoggerFactories<T> factories = new LazyLoggerFactories<>(supplier);\n+            return new LazyLoggerAccessor(name, factories, module);\n+        }\n+\n@@ -415,0 +425,2 @@\n+        \/\/ triggers detection of the backend\n+        BootstrapLogger.detectBackend();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/LazyLoggers.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.System.Logger;\n+import java.lang.System.LoggerFinder;\n@@ -35,0 +37,4 @@\n+import java.util.function.BiFunction;\n+import java.util.function.BooleanSupplier;\n+\n+import jdk.internal.logger.LazyLoggers.LazyLoggerAccessor;\n@@ -68,1 +74,2 @@\n-\n+    \/\/ record the loadingThread while loading the backend\n+    static volatile Thread loadingThread;\n@@ -74,1 +81,13 @@\n-            service = loadLoggerFinder();\n+            Thread currentThread = Thread.currentThread();\n+            if (loadingThread == currentThread) {\n+                \/\/ recursive attempt to load the backend while loading the backend\n+                \/\/ use a temporary logger finder that returns special BootstrapLogger\n+                \/\/ which will wait until loading is finished\n+                return TemporaryLoggerFinder.INSTANCE;\n+            }\n+            loadingThread = currentThread;\n+            try {\n+                service = loadLoggerFinder();\n+            } finally {\n+                loadingThread = null;\n+            }\n@@ -82,0 +101,6 @@\n+    \/\/ returns true if called by the thread that loads the LoggerFinder, while\n+    \/\/ loading the LoggerFinder.\n+    static boolean isLoadingThread() {\n+        return loadingThread != null && loadingThread == Thread.currentThread();\n+    }\n+\n@@ -120,0 +145,23 @@\n+    private static final class TemporaryLoggerFinder extends LoggerFinder {\n+        private static final BiFunction<String, Module, Logger> loggerSupplier =\n+                new BiFunction<>() {\n+                    @Override\n+                    public Logger apply(String name, Module module) {\n+                        return LazyLoggers.getLogger(name, module);\n+                    }\n+                };\n+        private static final BooleanSupplier isLoadingThread = new BooleanSupplier() {\n+            @Override\n+            public boolean getAsBoolean() {\n+                return LoggerFinderLoader.isLoadingThread();\n+            }\n+        };\n+        private static final TemporaryLoggerFinder INSTANCE = new TemporaryLoggerFinder();\n+\n+        @Override\n+        public Logger getLogger(String name, Module module) {\n+            return new BootstrapLogger(LazyLoggerAccessor.makeAccessorFromSupplier(\n+                    name, loggerSupplier, module), isLoadingThread);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/LoggerFinderLoader.java","additions":51,"deletions":3,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+loggerfinder.SimpleLoggerFinder\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/META-INF\/services\/java.lang.System$LoggerFinder","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8314263\n+ * @summary Signed jars triggering Logger finder recursion and StackOverflowError\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.process.*\n+ *        jdk.test.lib.util.JarUtils\n+ *        jdk.test.lib.JDKToolLauncher\n+ * @compile SignedLoggerFinderTest.java SimpleLoggerFinder.java\n+ * @run main SignedLoggerFinderTest init\n+ * @run main SignedLoggerFinderTest init sign\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.*;\n+import java.security.*;\n+import java.util.*;\n+import java.util.jar.*;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.JarUtils;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static java.util.Arrays.asList;\n+\n+public class SignedLoggerFinderTest {\n+\n+    \/**\n+     * This test triggers recursion in the broken JDK. The error can\n+     * manifest in a few different ways.\n+     * One error seen is \"java.lang.NoClassDefFoundError:\n+     * Could not initialize class jdk.internal.logger.LoggerFinderLoader$ErrorPolicy\"\n+     *\n+     * The original reported error was a StackOverflow (also seen in different iterations\n+     * of this run). Running test in signed and unsigned jar mode for sanity coverage.\n+     * The current bug only manifests when jars are signed.\n+     *\/\n+\n+    private static boolean init = false;\n+    private static boolean signJars = false;\n+    private static boolean mutliThreadLoad = false;\n+    private static volatile boolean testComplete = false;\n+\n+    private static final String KEYSTORE = \"8314263.keystore\";\n+    private static final String ALIAS = \"JavaTest\";\n+    private static final String STOREPASS = \"changeit\";\n+    private static final String KEYPASS = \"changeit\";\n+    private static final String DNAME = \"CN=sample\";\n+    private static final String CUSTOM_LOGGER_FINDER_NAME =\n+            \"loggerfinder.SimpleLoggerFinder\";\n+    private static final String CUSTOM_LOGGER_NAME =\n+            \"loggerfinder.SimpleLoggerFinder$SimpleLogger\";\n+    private static final String INTERNAL_LOGGER_FINDER_NAME =\n+            \"sun.util.logging.internal.LoggingProviderImpl\";\n+    private static final String INTERNAL_LOGGER_NAME =\n+            \"sun.util.logging.internal.LoggingProviderImpl$JULWrapper\";\n+    private static final Path jarPath1 =\n+        Path.of(System.getProperty(\"test.classes\", \".\"), \"SimpleLoggerFinder.jar\");\n+    private static final Path jarPath2 =\n+            Path.of(System.getProperty(\"test.classes\", \".\"), \"SimpleLoggerFinder2.jar\");\n+\n+    public static void main(String[] args) throws Throwable {\n+        init = args.length >=1 && args[0].equals(\"init\");\n+        signJars = args.length >=2 && args[1].equals(\"sign\");\n+\n+        \/\/ init only passed in by jtreg test run, initialize the environment\n+        \/\/ for the subsequent test run\n+        if (init) {\n+            initialize();\n+            launchTest(false, false);\n+            launchTest(false, true);\n+            launchTest(true, false);\n+            launchTest(true, true);\n+\n+        } else {\n+            \/\/ set up complete. Run the code to trigger the recursion\n+            \/\/ We're in the JVM launched by ProcessTools.executeCommand\n+            boolean mutliThreadLoad =\n+                Boolean.parseBoolean(System.getProperty(\"mutliThreadLoad\", \"false\"));\n+            boolean withCustomLoggerFinder =\n+                Boolean.parseBoolean(System.getProperty(\"withCustomLoggerFinder\", \"false\"));\n+\n+            if (mutliThreadLoad) {\n+                long sleep = new Random().nextLong(100L) + 1L;\n+                System.out.println(\"multi thread load sleep value: \" + sleep);\n+                Runnable t = () -> {\n+                    while(!testComplete) {\n+                        \/\/ random logger call to exercise System.getLogger\n+                        System.out.println(\"System.getLogger type:\" +\n+                            System.getLogger(\"random\" + System.currentTimeMillis()));\n+                        try {\n+                            Thread.sleep(sleep);\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                };\n+                new Thread(t).start();\n+            }\n+\n+            if (withCustomLoggerFinder) {\n+                JarFile jf = new JarFile(jarPath1.toString(), true);\n+                jf.getInputStream(jf.getJarEntry(\"loggerfinder\/SimpleLoggerFinder.class\"));\n+                JarFile jf2 = new JarFile(jarPath2.toString(), true);\n+                jf2.getInputStream(jf.getJarEntry(\"loggerfinder\/SimpleLoggerFinder.class\"));\n+            } else {\n+                \/\/ some other call to prod LoggerFinder loading\n+                System.getLogger(\"random\" + System.currentTimeMillis());\n+                System.LoggerFinder.getLoggerFinder();\n+            }\n+            Security.setProperty(\"test_1\", \"test\");\n+\n+            \/\/ some extra sanity checks\n+            if (withCustomLoggerFinder) {\n+                assertEquals(System.LoggerFinder.getLoggerFinder().getClass().getName(),\n+                        CUSTOM_LOGGER_FINDER_NAME);\n+                System.Logger testLogger = System.getLogger(\"jdk.event.security\");\n+                assertEquals(testLogger.getClass().getName(), CUSTOM_LOGGER_NAME);\n+            } else {\n+                if (signJars) {\n+                    assertEquals(System.LoggerFinder.getLoggerFinder().getClass().getName(),\n+                            INTERNAL_LOGGER_FINDER_NAME);\n+                    System.Logger testLogger = System.getLogger(\"jdk.event.security\");\n+                    assertEquals(testLogger.getClass().getName(), INTERNAL_LOGGER_FINDER_NAME);\n+                } else {\n+                    assertEquals(System.LoggerFinder.getLoggerFinder().getClass().getName(),\n+                            INTERNAL_LOGGER_FINDER_NAME);\n+                    System.Logger testLogger = System.getLogger(\"jdk.event.security\");\n+                    assertEquals(testLogger.getClass().getName(), INTERNAL_LOGGER_NAME);\n+                }\n+            }\n+            testComplete = true;\n+\n+            \/\/ LoggerFinder should be initialized, trigger a simple log call\n+            Security.setProperty(\"test_2\", \"test\");\n+        }\n+    }\n+\n+    \/\/ helper to create the inner test. Run config variations with the LoggerFinder jars\n+    \/\/ on the classpath and with other threads running System.Logger calls during load\n+    private static void launchTest(boolean mutliThreadLoad, boolean withCustomLoggerFinder) {\n+        List<String> cmds = new ArrayList<>();\n+        cmds.add(JDKToolFinder.getJDKTool(\"java\"));\n+        cmds.addAll(asList(Utils.getTestJavaOpts()));\n+        if (withCustomLoggerFinder) {\n+            cmds.addAll(List.of(\"-classpath\",\n+                System.getProperty(\"test.classes\") + File.pathSeparator +\n+                jarPath1.toString() + File.pathSeparator + jarPath2.toString(),\n+                \"-Dtest.classes=\" + System.getProperty(\"test.classes\")));\n+        } else {\n+            cmds.addAll(List.of(\"-classpath\",\n+                System.getProperty(\"test.classes\")));\n+        }\n+        cmds.addAll(List.of(\n+            \/\/ following debug property seems useful to tickle the issue\n+            \"-Dsun.misc.URLClassPath.debug=true\",\n+            \/\/ console logger level to capture event output\n+            \"-Djdk.system.logger.level=DEBUG\",\n+            \/\/ useful for debug purposes\n+            \"-Djdk.logger.finder.error=DEBUG\",\n+            \/\/ enable logging to verify correct output\n+            \"-Djava.util.logging.config.file=\" +\n+                    Path.of(System.getProperty(\"test.src\", \".\"), \"logging.properties\")));\n+        if (mutliThreadLoad) {\n+            cmds.add(\"-DmutliThreadLoad=true\");\n+        }\n+        if (withCustomLoggerFinder) {\n+            cmds.add(\"-DwithCustomLoggerFinder=true\");\n+        }\n+        cmds.addAll(List.of(\n+            \"SignedLoggerFinderTest\",\n+            \"no-init\"));\n+\n+        try {\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeCommand(cmds.stream()\n+                    .filter(t -> !t.isEmpty())\n+                    .toArray(String[]::new))\n+                    .shouldHaveExitValue(0);\n+            if (withCustomLoggerFinder) {\n+                outputAnalyzer\n+                    .shouldContain(\"TEST LOGGER: [test_1, test]\")\n+                    .shouldContain(\"TEST LOGGER: [test_2, test]\");\n+            } else {\n+                outputAnalyzer\n+                    .shouldContain(\"SecurityPropertyModification: key:test_1\")\n+                    .shouldContain(\"SecurityPropertyModification: key:test_2\");\n+            }\n+            if (withCustomLoggerFinder && signJars) {\n+                \/\/ X509 cert generated during verification of signed jar file\n+                outputAnalyzer\n+                    .shouldContain(DNAME);\n+            }\n+\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Unexpected fail.\", t);\n+        }\n+    }\n+\n+    private static void initialize() throws Throwable {\n+        if (signJars) {\n+            genKey();\n+        }\n+\n+        Path classes = Paths.get(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(jarPath1,\n+            classes,\n+            classes.resolve(\"loggerfinder\/SimpleLoggerFinder.class\"),\n+            classes.resolve(\"loggerfinder\/SimpleLoggerFinder$SimpleLogger.class\"));\n+\n+        JarUtils.updateJarFile(jarPath1, Path.of(System.getProperty(\"test.src\")),\n+            Path.of(\"META-INF\", \"services\", \"java.lang.System$LoggerFinder\"));\n+        if (signJars) {\n+            signJar(jarPath1.toString());\n+        }\n+        \/\/ multiple signed jars with services to have ServiceLoader iteration\n+        Files.copy(jarPath1, jarPath2, REPLACE_EXISTING);\n+    }\n+\n+    private static void genKey() throws Throwable {\n+        String keytool = JDKToolFinder.getJDKTool(\"keytool\");\n+        Files.deleteIfExists(Paths.get(KEYSTORE));\n+        ProcessTools.executeCommand(keytool,\n+                \"-J-Duser.language=en\",\n+                \"-J-Duser.country=US\",\n+                \"-genkey\",\n+                \"-keyalg\", \"rsa\",\n+                \"-alias\", ALIAS,\n+                \"-keystore\", KEYSTORE,\n+                \"-keypass\", KEYPASS,\n+                \"-dname\", DNAME,\n+                \"-storepass\", STOREPASS\n+        ).shouldHaveExitValue(0);\n+    }\n+\n+\n+    private static OutputAnalyzer signJar(String jarName) throws Throwable {\n+        List<String> args = new ArrayList<>();\n+        args.add(\"-verbose\");\n+        args.add(jarName);\n+        args.add(ALIAS);\n+\n+        return jarsigner(args);\n+    }\n+\n+    private static OutputAnalyzer jarsigner(List<String> extra)\n+            throws Throwable {\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jarsigner\")\n+                .addVMArg(\"-Duser.language=en\")\n+                .addVMArg(\"-Duser.country=US\")\n+                .addToolArg(\"-keystore\")\n+                .addToolArg(KEYSTORE)\n+                .addToolArg(\"-storepass\")\n+                .addToolArg(STOREPASS)\n+                .addToolArg(\"-keypass\")\n+                .addToolArg(KEYPASS);\n+        for (String s : extra) {\n+            if (s.startsWith(\"-J\")) {\n+                launcher.addVMArg(s.substring(2));\n+            } else {\n+                launcher.addToolArg(s);\n+            }\n+        }\n+        return ProcessTools.executeCommand(launcher.getCommand());\n+    }\n+\n+    private static void assertEquals(String received, String expected) {\n+        if (!expected.equals(received)) {\n+            throw new RuntimeException(\"Received: \" + received);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/SignedLoggerFinderTest.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package loggerfinder;\n+\n+import java.lang.*;\n+import java.util.*;\n+\n+public class SimpleLoggerFinder extends System.LoggerFinder {\n+\n+    static {\n+        try {\n+            long sleep = new Random().nextLong(1000L) + 1L;\n+            System.out.println(\"Logger finder service load sleep value: \" + sleep);\n+            \/\/ simulate a slow load service\n+            Thread.sleep(sleep);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+     @Override\n+     public System.Logger getLogger(String name, Module module) {\n+         return new SimpleLogger(name);\n+     }\n+\n+    private static class SimpleLogger implements System.Logger {\n+        private final String name;\n+\n+        public SimpleLogger(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public boolean isLoggable(Level level) {\n+            return true;\n+        }\n+\n+        @Override\n+        public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n+            System.out.println(\"TEST LOGGER: \" + msg);\n+        }\n+\n+        @Override\n+        public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n+            System.out.println(\"TEST LOGGER: \" + Arrays.asList(params));\n+\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/SimpleLoggerFinder.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -14,0 +14,1 @@\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/logging.properties","additions":1,"deletions":0,"binary":false,"changes":1,"previous_filename":"test\/jdk\/java\/util\/jar\/JarFile\/jarVerification\/logging.properties","status":"copied"}]}