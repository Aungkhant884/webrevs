{"files":[{"patch":"@@ -71,0 +71,1 @@\n+import jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;\n@@ -1769,1 +1770,2 @@\n-            if (service == null) {\n+            LoggerFinder finder = service;\n+            if (finder == null) {\n@@ -1772,1 +1774,1 @@\n-                service = AccessController.doPrivileged(pa, null,\n+                finder = AccessController.doPrivileged(pa, null,\n@@ -1774,0 +1776,2 @@\n+                if (finder instanceof TemporaryLoggerFinder) return finder;\n+                service = finder;\n@@ -1775,1 +1779,1 @@\n-            return service;\n+            return finder;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -951,1 +951,1 @@\n-        \/\/ while holding the BotstrapLogger class monitor\n+        \/\/ while holding the BootstrapLogger class monitor\n@@ -985,1 +985,1 @@\n-    static void detectBackend() {\n+    static void ensureBackendDetected() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/BootstrapLogger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;\n@@ -348,3 +349,0 @@\n-            \/\/ ensure backend is detected before attempting to load the finder\n-            BootstrapLogger.detectBackend();\n-\n@@ -360,0 +358,1 @@\n+            if (prov instanceof TemporaryLoggerFinder) return prov;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/LazyLoggers.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -77,0 +78,2 @@\n+        \/\/ ensure backend is detected before attempting to load the finder\n+        BootstrapLogger.ensureBackendDetected();\n@@ -143,1 +146,5 @@\n-    private static final class TemporaryLoggerFinder extends LoggerFinder {\n+    public static final class TemporaryLoggerFinder extends LoggerFinder {\n+        private TemporaryLoggerFinder() {}\n+        @Stable\n+        private LoggerFinder loadedService;\n+\n@@ -154,1 +161,10 @@\n-            return LazyLoggers.makeLazyLogger(name, module, isLoadingThread);\n+            if (loadedService == null) {\n+                loadedService = service;\n+                if (loadedService == null) {\n+                    return LazyLoggers.makeLazyLogger(name, module, isLoadingThread);\n+                }\n+            }\n+            assert loadedService != null;\n+            assert !LoggerFinderLoader.isLoadingThread();\n+            assert loadedService != this;\n+            return LazyLoggers.getLogger(name, module);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/LoggerFinderLoader.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/RecursiveLoading\/META-INF\/services\/java.lang.System$LoggerFinder","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/META-INF\/services\/java.lang.System$LoggerFinder","status":"copied"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8314263\n+ * @summary Creating a logger while loading the Logger finder\n+ *          triggers recursion and StackOverflowError\n+ * @modules java.base\/sun.util.logging\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.process.*\n+ *        jdk.test.lib.util.JarUtils\n+ *        jdk.test.lib.JDKToolLauncher\n+ * @compile RecursiveLoadingTest.java SimpleLoggerFinder.java\n+ * @run main\/othervm PlatformRecursiveLoadingTest\n+ *\/\n+\n+\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.LogRecord;\n+\n+import sun.util.logging.PlatformLogger;\n+\n+public class PlatformRecursiveLoadingTest {\n+\n+    \/**\n+     * This test triggers recursion in the broken JDK. The error can\n+     * manifest in a few different ways.\n+     * One error seen is \"java.lang.NoClassDefFoundError:\n+     * Could not initialize class jdk.internal.logger.LoggerFinderLoader$ErrorPolicy\"\n+     *\n+     * The original reported error was a StackOverflow (also seen in different iterations\n+     * of this run). Running test in signed and unsigned jar mode for sanity coverage.\n+     * The current bug only manifests when jars are signed.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        PlatformLogger.getLogger(\"main\").info(\"in main\");\n+        List<Object> logs = loggerfinder.SimpleLoggerFinder.LOGS;\n+\t\/*\n+        logs.stream().map(SimpleLogRecord::of).forEach(System.out::println);\n+        logs.stream().map(SimpleLogRecord::of).forEach(SimpleLogRecord::check);\n+        assertEquals(String.valueOf(logs.size()), String.valueOf(2));*\/\n+    }\n+\n+    static List<Object> asList(Object[] params) {\n+        return params == null ? null : Arrays.asList(params);\n+    }\n+\n+    record SimpleLogRecord(String message, Instant instant, String loggerName,\n+                           java.util.logging.Level level, List<Object> params,\n+                           String resourceBundleName, long seqNumber,\n+                           String sourceClassName, String methodName, Throwable thrown) {\n+        SimpleLogRecord(LogRecord record) {\n+            this(record.getMessage(), record.getInstant(), record.getLoggerName(), record.getLevel(),\n+                    asList(record.getParameters()), record.getResourceBundleName(), record.getSequenceNumber(),\n+                    record.getSourceClassName(), record.getSourceMethodName(), record.getThrown());\n+        }\n+        static SimpleLogRecord of(Object o) {\n+            return (o instanceof LogRecord record) ? new SimpleLogRecord(record) : null;\n+        }\n+        static SimpleLogRecord check(SimpleLogRecord record) {\n+            if (record.loggerName.equals(\"dummy\")) {\n+                assertEquals(record.sourceClassName, \"jdk.internal.logger.BootstrapLogger$LogEvent\");\n+                assertEquals(record.methodName(), \"log\");\n+            }\n+            if (record.loggerName.equals(\"main\")) {\n+                assertEquals(record.sourceClassName, PlatformRecursiveLoadingTest.class.getName());\n+                assertEquals(record.methodName, \"main\");\n+            }\n+            return record;\n+        }\n+    }\n+\n+    private static void assertEquals(String received, String expected) {\n+        if (!expected.equals(received)) {\n+            throw new RuntimeException(\"Received: \" + received);\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/RecursiveLoading\/PlatformRecursiveLoadingTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8314263\n+ * @summary Creating a logger while loading the Logger finder\n+ *          triggers recursion and StackOverflowError\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.process.*\n+ *        jdk.test.lib.util.JarUtils\n+ *        jdk.test.lib.JDKToolLauncher\n+ * @compile RecursiveLoadingTest.java SimpleLoggerFinder.java\n+ * @run main\/othervm RecursiveLoadingTest\n+ *\/\n+\n+\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.LogRecord;\n+\n+public class RecursiveLoadingTest {\n+\n+    \/**\n+     * This test triggers recursion in the broken JDK. The error can\n+     * manifest in a few different ways.\n+     * One error seen is \"java.lang.NoClassDefFoundError:\n+     * Could not initialize class jdk.internal.logger.LoggerFinderLoader$ErrorPolicy\"\n+     *\n+     * The original reported error was a StackOverflow (also seen in different iterations\n+     * of this run). Running test in signed and unsigned jar mode for sanity coverage.\n+     * The current bug only manifests when jars are signed.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        System.getLogger(\"main\").log(System.Logger.Level.INFO, \"in main\");\n+        List<Object> logs = loggerfinder.SimpleLoggerFinder.LOGS;\n+        logs.stream().map(SimpleLogRecord::of).forEach(System.out::println);\n+        logs.stream().map(SimpleLogRecord::of).forEach(SimpleLogRecord::check);\n+        assertEquals(String.valueOf(logs.size()), String.valueOf(2));\n+    }\n+\n+    static List<Object> asList(Object[] params) {\n+        return params == null ? null : Arrays.asList(params);\n+    }\n+\n+    record SimpleLogRecord(String message, Instant instant, String loggerName,\n+                           java.util.logging.Level level, List<Object> params,\n+                           String resourceBundleName, long seqNumber,\n+                           String sourceClassName, String methodName, Throwable thrown) {\n+        SimpleLogRecord(LogRecord record) {\n+            this(record.getMessage(), record.getInstant(), record.getLoggerName(), record.getLevel(),\n+                    asList(record.getParameters()), record.getResourceBundleName(), record.getSequenceNumber(),\n+                    record.getSourceClassName(), record.getSourceMethodName(), record.getThrown());\n+        }\n+        static SimpleLogRecord of(Object o) {\n+            return (o instanceof LogRecord record) ? new SimpleLogRecord(record) : null;\n+        }\n+        static SimpleLogRecord check(SimpleLogRecord record) {\n+            if (record.loggerName.equals(\"dummy\")) {\n+                assertEquals(record.sourceClassName, \"jdk.internal.logger.BootstrapLogger$LogEvent\");\n+                assertEquals(record.methodName(), \"log\");\n+            }\n+            if (record.loggerName.equals(\"main\")) {\n+                assertEquals(record.sourceClassName, RecursiveLoadingTest.class.getName());\n+                assertEquals(record.methodName, \"main\");\n+            }\n+            return record;\n+        }\n+    }\n+\n+    private static void assertEquals(String received, String expected) {\n+        if (!expected.equals(received)) {\n+            throw new RuntimeException(\"Received: \" + received);\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/RecursiveLoading\/RecursiveLoadingTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package loggerfinder;\n+\n+import java.lang.*;\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+public class SimpleLoggerFinder extends System.LoggerFinder {\n+\n+    static {\n+        try {\n+            long sleep = new Random().nextLong(1000L) + 1L;\n+            \/\/ simulate a slow load service\n+            Thread.sleep(sleep);\n+            System.getLogger(\"dummy\")\n+                    .log(System.Logger.Level.INFO,\n+                            \"Logger finder service load sleep value: \" + sleep);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static final CopyOnWriteArrayList<Object> LOGS = new CopyOnWriteArrayList<>();\n+\n+    @Override\n+    public System.Logger getLogger(String name, Module module) {\n+        return new SimpleLogger(name);\n+    }\n+\n+    private static class SimpleLogger implements System.Logger {\n+        private final java.util.logging.Logger logger;\n+\n+        private static final class SimpleHandler extends Handler {\n+            @Override\n+            public void publish(LogRecord record) {\n+                LOGS.add(record);\n+            }\n+            @Override public void flush() { }\n+            @Override public void close() { }\n+        }\n+\n+        public SimpleLogger(String name) {\n+            logger = Logger.getLogger(name);\n+            logger.addHandler(new SimpleHandler());\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return logger.getName();\n+        }\n+\n+        java.util.logging.Level level(Level level) {\n+            return switch (level) {\n+                case ALL -> java.util.logging.Level.ALL;\n+                case DEBUG -> java.util.logging.Level.FINE;\n+                case TRACE -> java.util.logging.Level.FINER;\n+                case INFO -> java.util.logging.Level.INFO;\n+                case WARNING -> java.util.logging.Level.WARNING;\n+                case ERROR -> java.util.logging.Level.SEVERE;\n+                case OFF -> java.util.logging.Level.OFF;\n+            };\n+        }\n+\n+        @Override\n+        public boolean isLoggable(Level level) {\n+            return logger.isLoggable(level(level));\n+        }\n+\n+        @Override\n+        public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n+            var julLevel = level(level);\n+            if (!logger.isLoggable(julLevel)) return;\n+            if (bundle != null) {\n+                logger.logrb(julLevel, bundle, msg, thrown);\n+            } else {\n+                logger.log(julLevel, msg, thrown);\n+            }\n+        }\n+\n+        @Override\n+        public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n+            var julLevel = level(level);\n+            if (!logger.isLoggable(julLevel)) return;\n+            if (params == null) {\n+                if (bundle == null) {\n+                    logger.log(julLevel, format);\n+                } else {\n+                    logger.logrb(julLevel, bundle, format);\n+                }\n+            } else {\n+                if (bundle == null) {\n+                    logger.log(julLevel, format, params);\n+                } else {\n+                    logger.logrb(julLevel, bundle, format, params);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/RecursiveLoading\/SimpleLoggerFinder.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.function.*;\n@@ -114,13 +115,6 @@\n-                Runnable t = () -> {\n-                    while(!testComplete) {\n-                        \/\/ random logger call to exercise System.getLogger\n-                        System.out.println(\"System.getLogger type:\" +\n-                            System.getLogger(\"random\" + System.currentTimeMillis()));\n-                        try {\n-                            Thread.sleep(sleep);\n-                        } catch (InterruptedException e) {\n-                            throw new RuntimeException(e);\n-                        }\n-                    }\n-                };\n-                new Thread(t).start();\n+                new Thread(runnableWithSleep(\n+                        () -> System.getLogger(\"logger\" + System.currentTimeMillis()),\n+                        sleep, \"System.getLogger type: \")).start();\n+                new Thread(runnableWithSleep(\n+                        () -> System.LoggerFinder.getLoggerFinder(),\n+                        sleep, \"System.getLoggerFinder type: \")).start();\n@@ -227,0 +221,13 @@\n+    private static Runnable runnableWithSleep(Supplier s, long sleep, String desc) {\n+        return () -> {\n+            while(!testComplete) {\n+                System.out.println(desc + s.get().getClass().getName());\n+                try {\n+                    Thread.sleep(sleep);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/SignedLoggerFinderTest.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"}]}