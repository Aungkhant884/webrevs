{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.Function;\n@@ -85,0 +86,2 @@\n+    private Map<String, Function<byte[], byte[]>> certDeflaters = null;\n+    private Map<String, Function<byte[], byte[]>> certInflaters = null;\n@@ -689,0 +692,312 @@\n+\n+    \/**\n+     * Returns a prioritized map of certificate compression algorithm names\n+     * and functions that can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of certificate compression algorithm\n+     * names are defined in the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#cert-compression\">\n+     * Certificate Compression<\/a> section of the Java Security Standard\n+     * Algorithm Names Specification.  Providers may support certificate\n+     * compression algorithms not defined in this list or may not use the\n+     * recommended name for a certain certificate compression algorithm.\n+     * <p>\n+     * The set of certificate compression algorithm names and functions\n+     * that will be used over the SSL\/TLS\/DTLS connections is determined by\n+     * the returned map of this method and the underlying provider-specific\n+     * default certificate compression algorithm names and functions.\n+     * <p>\n+     * If the returned map is {@code null}, then the underlying\n+     * provider-specific default certificate compression algorithm names\n+     * and functions will be used over the SSL\/TLS\/DTLS connections.\n+     * <p>\n+     * If the returned map is empty (zero-length), then the certificate\n+     * compression mechanism is turned off for SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * If the returned map is not {@code null} or empty (zero-length), then\n+     * the certificate compression mechanism is turned on for SSL\/TLS\/DTLS\n+     * protocols.  The certificate compression algorithm names and\n+     * functions in the returned map will be used over the connections.\n+     * <p>\n+     * If the {@link #setCertificateDeflaters} method has not been called,\n+     * this method should return the default certificate compression\n+     * algorithm names and functions for connection populated objects, or\n+     * {@code null} for pre-populated objects.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may return {@code null} instead of the default\n+     * certificate compression algorithm names and functions for connection\n+     * populated objects.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method, but does not define the\n+     * default certificate compression algorithm names and functions.  The\n+     * certificate compression mechanism is turned off by default for the\n+     * SunJSSE provider.  Applications could enable the mechanism in the\n+     * SunJSSE provider by calling {@link #setCertificateDeflaters} in\n+     * the compression side and {@link #setCertificateInflaters} in the\n+     * decompression side.\n+     *\n+     * @return an immutable map of certificate compression algorithm names\n+     *         {@code String}s and {@link Function}s, or {@code null} if\n+     *         none have been set.  Each map entry in the map is non-null, and\n+     *         represents the certificate compression algorithm. The key of\n+     *         the map entry is a non-null {@code String} object which\n+     *         represents the certificate compression algorithm name.  The\n+     *         value of the map entry is a non-null {@link Function} object\n+     *         which will be applied to the Certificate message byte array,\n+     *         and produce Compressed Certificate message byte array.  The\n+     *         map entries are ordered based on certificate compression\n+     *         algorithm preference, with the first entry being the most\n+     *         preferred.  Providers should ignore unknown certificate\n+     *         compression algorithm names while establishing the\n+     *         SSL\/TLS\/DTLS connections.\n+     *\n+     * @see #setCertificateDeflaters\n+     *\n+     * @since 19\n+     *\/\n+    public Map<String, Function<byte[], byte[]>> getCertificateDeflaters() {\n+        return this.certDeflaters;\n+    }\n+\n+    \/**\n+     * Sets a prioritized map of certificate compression algorithm names and\n+     * functions that can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of certificate compression algorithm\n+     * names are defined in the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#cert-compression\">\n+     * Certificate Compression<\/a> section of the Java Security Standard\n+     * Algorithm Names Specification.  Providers may support certificate\n+     * compression algorithms not defined in this list or may not use the\n+     * recommended name for a certain certificate compression algorithm.\n+     * <p>\n+     * The set of certificate compression algorithm names and functions\n+     * that will be used over the SSL\/TLS\/DTLS connections is determined by\n+     * the returned map of this method and the underlying provider-specific\n+     * default certificate compression algorithm names and functions.  See\n+     * {@link #getCertificateDeflaters} for specific details on how the\n+     * parameters are used in SSL\/TLS\/DTLS connections.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may ignore the certificate compression algorithm\n+     * names and functions that are set.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @param certDeflaters an ordered map of certificate compression\n+     *        algorithm names {@code String}s and {@link Function}s with the\n+     *        first entry being the most preferred, or {@code null}.  Each\n+     *        entry in the map is non-null, and represents the certificate\n+     *        compression algorithm.  The key of the map entry is a non-null\n+     *        {@code String} object which represents the certificate\n+     *        compression algorithm name.  The value of the map entry is a\n+     *        non-null {@link Function} object which will be applied to the\n+     *        Certificate message byte array, and produce Compressed\n+     *        Certificate message byte array.  This method will make a copy of\n+     *        this map if necessary to protect against subsequent modification.\n+     *        Providers should ignore unknown certificate compression\n+     *        algorithm names and the relevant functions while establishing\n+     *        the SSL\/TLS\/DTLS connections.\n+     * @throws IllegalArgumentException if any entry, key, or value in the\n+     *        {@code certDeflaters} map is {@code null}, or any key is\n+     *        {@linkplain String#isBlank() blank}.\n+     *\n+     * @see #getCertificateDeflaters\n+     *\n+     * @since 19\n+     *\/\n+    public void setCertificateDeflaters(\n+            Map<String, Function<byte[], byte[]>> certDeflaters) {\n+        if (this.certDeflaters == certDeflaters) {\n+            return;\n+        }\n+\n+        if (certDeflaters == null) {\n+            this.certDeflaters = null;\n+        } else if (certDeflaters.isEmpty()) {\n+            this.certDeflaters = Map.of();\n+        } else {\n+            @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+            Map.Entry<String, Function<byte[], byte[]>>[] entries =\n+                    new Map.Entry[certDeflaters.size()];\n+            int i = 0;\n+            for (Map.Entry<String, Function<byte[], byte[]>> entry :\n+                    certDeflaters.entrySet()) {\n+                if (entry == null) {\n+                    throw new IllegalArgumentException(\n+                            \"Null entry is not allowed\");\n+                } else if (entry.getKey() == null || entry.getKey().isBlank()) {\n+                    throw new IllegalArgumentException(\n+                            \"Null or blank compression algorithm \" +\n+                            \"name is not allowed\");\n+                } else if (entry.getValue() == null) {\n+                    throw new IllegalArgumentException(\n+                            \"Null compression function is not allowed\");\n+                }\n+                entries[i++] = entry;\n+            }\n+\n+            this.certDeflaters = Map.ofEntries(entries);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a prioritized map of certificate decompression algorithm\n+     * names and functions that can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of certificate decompression algorithm\n+     * names are defined in the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#cert-compression\">\n+     * Certificate Compression<\/a> section of the Java Security Standard\n+     * Algorithm Names Specification.  Providers may support certificate\n+     * decompression algorithms not defined in this list or may not use the\n+     * recommended name for a certain certificate decompression algorithm.\n+     * <p>\n+     * The set of certificate decompression algorithm names and functions\n+     * that will be used over the SSL\/TLS\/DTLS connections is determined by\n+     * the returned map of this method and the underlying provider-specific\n+     * default certificate decompression algorithm names and functions.\n+     * <p>\n+     * If the returned map is {@code null}, then the underlying\n+     * provider-specific default certificate decompression algorithm names\n+     * and functions will be used over the connections.\n+     * <p>\n+     * If the returned map is empty (zero-length), then the certificate\n+     * compression mechanism is turned off for SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * If the returned map is not {@code null} or empty (zero-length), then\n+     * the certificate compression mechanism is turned on for SSL\/TLS\/DTLS\n+     * protocols.  The certificate decompression algorithm names and\n+     * functions in the returned map will be used over the connections.\n+     * <p>\n+     * If the {@link #setCertificateInflaters} method has not been called,\n+     * this method should return the default certificate decompression\n+     * algorithm names and functions for connection populated objects, or\n+     * {@code null} for pre-populated objects.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may return {@code null} instead of the default\n+     * certificate decompression algorithm names and functions for connection\n+     * populated objects.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method, but does not define the\n+     * default certificate decompression algorithm names and functions.  The\n+     * certificate compression mechanism is turned off by default for the\n+     * SunJSSE provider.  Applications could enable the mechanism in the\n+     * SunJSSE provider by calling {@link #setCertificateDeflaters} in\n+     * the compression side and {@link #setCertificateInflaters} in the\n+     * decompression side.\n+     *\n+     * @return an immutable map of certificate decompression algorithm names\n+     *         {@code String}s and {@link Function}s, or {@code null} if\n+     *         none have been set.  Each map entry in the map is non-null, and\n+     *         represents the certificate decompression algorithm. The key of\n+     *         the map entry is a non-null {@code String} object which\n+     *         represents the certificate decompression algorithm name.  The\n+     *         value of the map entry is a non-null {@link Function} object\n+     *         which will be applied to the Compressed Certificate message\n+     *         byte array, and produce Certificate message byte array.  The\n+     *         map entries are ordered based on certificate decompression\n+     *         algorithm preference, with the first entry being the most\n+     *         preferred.  Providers should ignore unknown certificate\n+     *         decompression algorithm names while establishing the\n+     *         SSL\/TLS\/DTLS connections.\n+     *\n+     * @see #setCertificateDeflaters\n+     *\n+     * @since 19\n+     *\/\n+    public Map<String, Function<byte[], byte[]>> getCertificateInflaters() {\n+        return this.certInflaters;\n+    }\n+\n+    \/**\n+     * Sets a prioritized map of certificate decompression algorithm names\n+     * and functions that can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of certificate decompression algorithm\n+     * names are defined in the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#cert-compression\">\n+     * Certificate Compression<\/a> section of the Java Security Standard\n+     * Algorithm Names Specification.  Providers may support certificate\n+     * decompression algorithms not defined in this list or may not use the\n+     * recommended name for a certain certificate decompression algorithm.\n+     * <p>\n+     * The set of certificate decompression algorithm names and functions\n+     * that will be used over the SSL\/TLS\/DTLS connections is determined by\n+     * the returned map of this method and the underlying provider-specific\n+     * default certificate decompression algorithm names and functions.  See\n+     * {@link #getCertificateInflaters} for specific details on how the\n+     * parameters are used in SSL\/TLS\/DTLS connections.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may ignore the certificate decompression algorithm\n+     * names and functions that are set.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @param certInflaters an ordered map of certificate decompression\n+     *        algorithm names {@code String}s and {@link Function}s with the\n+     *        first entry being the most preferred, or {@code null}.  Each\n+     *        entry in the map is non-null, and represents the certificate\n+     *        decompression algorithm.  The key of the map entry is a non-null\n+     *        {@code String} object which represents the certificate\n+     *        decompression algorithm name.  The value of the map entry is a\n+     *        non-null {@link Function} object which will be applied to the\n+     *        Compressed Certificate message byte array, and produce\n+     *        Certificate message byte array.  This method will make a copy of\n+     *        this map if necessary to protect against subsequent modification.\n+     *        Providers should ignore unknown certificate decompression\n+     *        algorithm names and the relevant functions while establishing\n+     *        the SSL\/TLS\/DTLS connections.\n+     * @throws IllegalArgumentException if any entry, key, or value in the\n+     *        {@code certInflaters} map is {@code null}, or any key is\n+     *        {@linkplain String#isBlank() blank}.\n+     *\n+     * @see #getCertificateInflaters\n+     *\n+     * @since 19\n+     *\/\n+    public void setCertificateInflaters(\n+            Map<String, Function<byte[], byte[]>> certInflaters) {\n+        if (this.certInflaters == certInflaters) {\n+            return;\n+        }\n+\n+        if (certInflaters == null) {\n+            this.certInflaters = null;\n+        } else if (certInflaters.isEmpty()) {\n+            this.certInflaters = Map.of();\n+        } else {\n+            @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+            Map.Entry<String, Function<byte[], byte[]>>[] entries =\n+                    new Map.Entry[certInflaters.size()];\n+            int i = 0;\n+            for (Map.Entry<String, Function<byte[], byte[]>> entry :\n+                    certInflaters.entrySet()) {\n+                if (entry == null) {\n+                    throw new IllegalArgumentException(\n+                            \"Null entry is not allowed\");\n+                } else if (entry.getKey() == null || entry.getKey().isBlank()) {\n+                    throw new IllegalArgumentException(\n+                            \"Null or blank decompression algorithm \" +\n+                            \"name is not allowed\");\n+                } else if (entry.getValue() == null) {\n+                    throw new IllegalArgumentException(\n+                            \"Null decompression function is not allowed\");\n+                }\n+                entries[i++] = entry;\n+            }\n+\n+            this.certInflaters = Map.ofEntries(entries);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLParameters.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-                        \/\/ Otherwise ignore the warning but remove the\n+                        \/\/ Otherwise, ignore the warning but remove the\n@@ -280,0 +280,2 @@\n+                        tc.handshakeContext.handshakeConsumers.remove(\n+                                SSLHandshake.COMPRESSED_CERTIFICATE.id);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Alert.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -957,5 +957,4 @@\n-            if (hc.sslConfig.isClientMode) {\n-                return onProduceCertificate(\n-                        (ClientHandshakeContext)context, message);\n-            } else {\n-                return onProduceCertificate(\n+            T13CertificateMessage cm = hc.sslConfig.isClientMode ?\n+                onProduceCertificate(\n+                        (ClientHandshakeContext)context, message) :\n+                onProduceCertificate(\n@@ -963,0 +962,8 @@\n+\n+            \/\/ Output the handshake message.\n+            if (hc.certDeflater == null) {\n+                cm.write(hc.handshakeOutput);\n+                hc.handshakeOutput.flush();\n+            } else {\n+                \/\/ Replace with CompressedCertificate message\n+                CompressedCertificate.handshakeProducer.produce(hc, cm);\n@@ -964,0 +971,3 @@\n+\n+            \/\/ The handshake message has been delivered.\n+            return null;\n@@ -966,1 +976,1 @@\n-        private byte[] onProduceCertificate(ServerHandshakeContext shc,\n+        private T13CertificateMessage onProduceCertificate(ServerHandshakeContext shc,\n@@ -1025,6 +1035,1 @@\n-            \/\/ Output the handshake message.\n-            cm.write(shc.handshakeOutput);\n-            shc.handshakeOutput.flush();\n-\n-            \/\/ The handshake message has been delivered.\n-            return null;\n+            return cm;\n@@ -1093,1 +1098,1 @@\n-        private byte[] onProduceCertificate(ClientHandshakeContext chc,\n+        private T13CertificateMessage onProduceCertificate(ClientHandshakeContext chc,\n@@ -1137,6 +1142,1 @@\n-            \/\/ Output the handshake message.\n-            cm.write(chc.handshakeOutput);\n-            chc.handshakeOutput.flush();\n-\n-            \/\/ The handshake message has been delivered.\n-            return null;\n+            return cm;\n@@ -1162,0 +1162,1 @@\n+            hc.handshakeConsumers.remove(SSLHandshake.COMPRESSED_CERTIFICATE.id);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -938,0 +938,5 @@\n+            if (shc.certInflaters != null && !shc.certInflaters.isEmpty()) {\n+                    shc.handshakeConsumers.put(\n+                        SSLHandshake.COMPRESSED_CERTIFICATE.id,\n+                        SSLHandshake.COMPRESSED_CERTIFICATE);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import sun.security.ssl.SSLExtension.ExtensionConsumer;\n+import sun.security.ssl.SSLExtension.SSLExtensionSpec;\n+import sun.security.ssl.SSLHandshake.HandshakeMessage;\n+\n+import javax.net.ssl.SSLProtocolException;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+\/**\n+ * Pack of the \"compress_certificate\" extensions [RFC 5246].\n+ *\/\n+final class CompressCertExtension {\n+    static final HandshakeProducer chNetworkProducer =\n+            new CHCompressCertificateProducer();\n+    static final ExtensionConsumer chOnLoadConsumer =\n+            new CHCompressCertificateConsumer();\n+\n+    static final HandshakeProducer crNetworkProducer =\n+            new CRCompressCertificateProducer();\n+    static final ExtensionConsumer crOnLoadConsumer =\n+            new CRCompressCertificateConsumer();\n+\n+    static final SSLStringizer ccStringizer =\n+            new CompressCertificateStringizer();\n+\n+    \/**\n+     * The \"signature_algorithms\" extension.\n+     *\/\n+    static final class CertCompressionSpec implements SSLExtensionSpec {\n+        private final int[] compressionAlgorithms;  \/\/ non-null\n+\n+        CertCompressionSpec(\n+            Map<Integer, Function<byte[], byte[]>> certInflaters) {\n+            compressionAlgorithms = new int[certInflaters.size()];\n+            int i = 0;\n+            for (Integer id : certInflaters.keySet()) {\n+                compressionAlgorithms[i++] = id;\n+            }\n+        }\n+\n+        CertCompressionSpec(HandshakeContext hc,\n+                            ByteBuffer buffer) throws IOException {\n+            if (buffer.remaining() < 2) {      \/\/ 2: the length of the list\n+                throw hc.conContext.fatal(Alert.DECODE_ERROR,\n+                        new SSLProtocolException(\n+                    \"Invalid compress_certificate: insufficient data\"));\n+            }\n+\n+            byte[] algs = Record.getBytes8(buffer);\n+            if (buffer.hasRemaining()) {\n+                throw hc.conContext.fatal(Alert.DECODE_ERROR,\n+                        new SSLProtocolException(\n+                    \"Invalid compress_certificate: unknown extra data\"));\n+            }\n+\n+            if (algs.length == 0 || (algs.length & 0x01) != 0) {\n+                throw hc.conContext.fatal(Alert.DECODE_ERROR,\n+                        new SSLProtocolException(\n+                    \"Invalid compress_certificate: incomplete data\"));\n+            }\n+\n+            int[] compressionAlgs = new int[algs.length \/ 2];\n+            for (int i = 0, j = 0; i < algs.length;) {\n+                byte hash = algs[i++];\n+                byte sign = algs[i++];\n+                compressionAlgs[j++] = ((hash & 0xFF) << 8) | (sign & 0xFF);\n+            }\n+\n+            this.compressionAlgorithms = compressionAlgs;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            MessageFormat messageFormat = new MessageFormat(\n+                \"\\\"compression algorithms\\\": '['{0}']'\", Locale.ENGLISH);\n+\n+            if (compressionAlgorithms.length == 0) {\n+                Object[] messageFields = {\n+                        \"<no supported compression algorithms specified>\"\n+                    };\n+                return messageFormat.format(messageFields);\n+            } else {\n+                StringBuilder builder = new StringBuilder(512);\n+                boolean isFirst = true;\n+                for (int ca : compressionAlgorithms) {\n+                    if (isFirst) {\n+                        isFirst = false;\n+                    } else {\n+                        builder.append(\", \");\n+                    }\n+\n+                    builder.append(CompressionAlgorithm.nameOf(ca));\n+                }\n+\n+                Object[] messageFields = {\n+                        builder.toString()\n+                    };\n+\n+                return messageFormat.format(messageFields);\n+            }\n+        }\n+    }\n+\n+    private static final\n+            class CompressCertificateStringizer implements SSLStringizer {\n+        @Override\n+        public String toString(HandshakeContext hc, ByteBuffer buffer) {\n+            try {\n+                return (new CertCompressionSpec(hc, buffer)).toString();\n+            } catch (IOException ioe) {\n+                \/\/ For debug logging only, so please swallow exceptions.\n+                return ioe.getMessage();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Network data producer of a \"compress_certificate\" extension in\n+     * the ClientHello handshake message.\n+     *\/\n+    private static final\n+            class CHCompressCertificateProducer implements HandshakeProducer {\n+        \/\/ Prevent instantiation of this class.\n+        private CHCompressCertificateProducer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public byte[] produce(ConnectionContext context,\n+                HandshakeMessage message) throws IOException {\n+            \/\/ The producing happens in client side only.\n+            ClientHandshakeContext chc = (ClientHandshakeContext)context;\n+\n+            \/\/ Is it a supported and enabled extension?\n+            if (!chc.sslConfig.isAvailable(\n+                    SSLExtension.CH_COMPRESS_CERTIFICATE)) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore unavailable \" +\n+                            \"compress_certificate extension\");\n+                }\n+                return null;\n+            }\n+\n+            \/\/ Produce the extension.\n+            if (chc.certInflaters == null) {\n+                chc.certInflaters =\n+                    CompressionAlgorithm.findInflaters(chc.sslConfig);\n+            }\n+\n+            if (chc.certInflaters.isEmpty()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore unsupported \" +\n+                            \"compress_certificate extension\");\n+                }\n+                return null;\n+            }\n+\n+            int vectorLen = CompressionAlgorithm.sizeInRecord() *\n+                    chc.certInflaters.size();\n+            byte[] extData = new byte[vectorLen + 1];\n+            ByteBuffer m = ByteBuffer.wrap(extData);\n+            Record.putInt8(m, vectorLen);\n+            for (Integer algId : chc.certInflaters.keySet()) {\n+                Record.putInt16(m, algId);\n+            }\n+\n+            \/\/ Update the context.\n+            chc.handshakeExtensions.put(\n+                    SSLExtension.CH_COMPRESS_CERTIFICATE,\n+                    new CertCompressionSpec(chc.certInflaters));\n+\n+            return extData;\n+        }\n+    }\n+\n+    \/**\n+     * Network data consumer of a \"compress_certificate\" extension in\n+     * the ClientHello handshake message.\n+     *\/\n+    private static final\n+            class CHCompressCertificateConsumer implements ExtensionConsumer {\n+        \/\/ Prevent instantiation of this class.\n+        private CHCompressCertificateConsumer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public void consume(ConnectionContext context,\n+            HandshakeMessage message, ByteBuffer buffer) throws IOException {\n+            \/\/ The consuming happens in server side only.\n+            ServerHandshakeContext shc = (ServerHandshakeContext)context;\n+\n+            \/\/ Is it a supported and enabled extension?\n+            if (!shc.sslConfig.isAvailable(\n+                    SSLExtension.CH_COMPRESS_CERTIFICATE)) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore unavailable \" +\n+                            \"compress_certificate extension\");\n+                }\n+                return;     \/\/ ignore the extension\n+            }\n+\n+            if (shc.sslConfig.certDeflaters == null ||\n+                    shc.sslConfig.certDeflaters.isEmpty()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore unsupported \" +\n+                            \"compress_certificate extension\");\n+                }\n+                return;     \/\/ ignore the extension\n+            }\n+\n+            \/\/ Parse the extension.\n+            CertCompressionSpec spec = new CertCompressionSpec(shc, buffer);\n+\n+            \/\/ Update the context.\n+            shc.certDeflater = CompressionAlgorithm.selectDeflater(\n+                            shc.sslConfig, spec.compressionAlgorithms);\n+            if (shc.certDeflater == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore, no supported \" +\n+                            \"certificate compression algorithms\");\n+                }\n+            }\n+\n+            \/\/ No impact on session resumption.\n+        }\n+    }\n+\n+    \/**\n+     * Network data producer of a \"compress_certificate\" extension in\n+     * the CertificateRequest handshake message.\n+     *\/\n+    private static final\n+            class CRCompressCertificateProducer implements HandshakeProducer {\n+        \/\/ Prevent instantiation of this class.\n+        private CRCompressCertificateProducer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public byte[] produce(ConnectionContext context,\n+                HandshakeMessage message) throws IOException {\n+            \/\/ The producing happens in server side only.\n+            ServerHandshakeContext shc = (ServerHandshakeContext)context;\n+\n+            \/\/ Is it a supported and enabled extension?\n+            if (!shc.sslConfig.isAvailable(\n+                    SSLExtension.CR_COMPRESS_CERTIFICATE)) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore unavailable \" +\n+                            \"compress_certificate extension\");\n+                }\n+                return null;\n+            }\n+\n+            \/\/ Produce the extension.\n+            if (shc.certInflaters == null) {\n+                shc.certInflaters =\n+                    CompressionAlgorithm.findInflaters(shc.sslConfig);\n+            }\n+\n+            if (shc.certInflaters.isEmpty()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore unsupported \" +\n+                            \"compress_certificate extension\");\n+                }\n+                return null;\n+            }\n+\n+            int vectorLen = CompressionAlgorithm.sizeInRecord() *\n+                    shc.certInflaters.size();\n+            byte[] extData = new byte[vectorLen + 1];\n+            ByteBuffer m = ByteBuffer.wrap(extData);\n+            Record.putInt8(m, vectorLen);\n+            for (Integer algId : shc.certInflaters.keySet()) {\n+                Record.putInt16(m, algId);\n+            }\n+\n+            \/\/ Update the context.\n+            shc.handshakeExtensions.put(\n+                    SSLExtension.CR_COMPRESS_CERTIFICATE,\n+                    new CertCompressionSpec(shc.certInflaters));\n+\n+            return extData;\n+        }\n+    }\n+\n+    \/**\n+     * Network data consumer of a \"compress_certificate\" extension in\n+     * the CertificateRequest handshake message.\n+     *\/\n+    private static final\n+            class CRCompressCertificateConsumer implements ExtensionConsumer {\n+        \/\/ Prevent instantiation of this class.\n+        private CRCompressCertificateConsumer() {\n+            \/\/ blank\n+        }\n+        @Override\n+        public void consume(ConnectionContext context,\n+            HandshakeMessage message, ByteBuffer buffer) throws IOException {\n+            \/\/ The consuming happens in client side only.\n+            ClientHandshakeContext chc = (ClientHandshakeContext)context;\n+\n+            \/\/ Is it a supported and enabled extension?\n+            if (!chc.sslConfig.isAvailable(\n+                    SSLExtension.CR_COMPRESS_CERTIFICATE)) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore unavailable \" +\n+                            \"compress_certificate extension\");\n+                }\n+                return;     \/\/ ignore the extension\n+            }\n+\n+            if (chc.sslConfig.certDeflaters == null ||\n+                    chc.sslConfig.certDeflaters.isEmpty()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore unsupported \" +\n+                            \"compress_certificate extension\");\n+                }\n+                return;     \/\/ ignore the extension\n+            }\n+\n+            \/\/ Parse the extension.\n+            CertCompressionSpec spec = new CertCompressionSpec(chc, buffer);\n+\n+            \/\/ Update the context.\n+            chc.certDeflater = CompressionAlgorithm.selectDeflater(\n+                            chc.sslConfig, spec.compressionAlgorithms);\n+            if (chc.certDeflater == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Ignore, no supported \" +\n+                            \"certificate compression algorithms\");\n+                }\n+            }\n+\n+            \/\/ No impact on session resumption.\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CompressCertExtension.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import sun.security.ssl.SSLHandshake.HandshakeMessage;\n+import sun.security.util.HexDumpEncoder;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.text.MessageFormat;\n+import java.util.*;\n+import java.util.function.Function;\n+\n+\/**\n+ * Pack of the CompressedCertificate handshake message.\n+ *\/\n+final class CompressedCertificate {\n+    static final SSLConsumer handshakeConsumer =\n+        new CompressedCertConsumer();\n+    static final HandshakeProducer handshakeProducer =\n+        new CompressedCertProducer();\n+\n+    \/**\n+     * The CompressedCertificate handshake message for TLS 1.3.\n+     *\/\n+    static final class CompressedCertMessage extends HandshakeMessage {\n+        private final int algorithmId;\n+        private final int uncompressedLength;\n+        private final byte[] compressedCert;\n+\n+        CompressedCertMessage(HandshakeContext context,\n+                int algorithmId, int uncompressedLength,\n+                byte[] compressedCert) {\n+            super(context);\n+\n+            this.algorithmId = algorithmId;\n+            this.uncompressedLength = uncompressedLength;\n+            this.compressedCert = compressedCert;\n+        }\n+\n+        CompressedCertMessage(HandshakeContext handshakeContext,\n+                ByteBuffer m) throws IOException {\n+            super(handshakeContext);\n+\n+            \/\/ struct {\n+            \/\/     CertificateCompressionAlgorithm algorithm;\n+            \/\/     uint24 uncompressed_length;\n+            \/\/     opaque compressed_certificate_message<1..2^24-1>;\n+            \/\/ } CompressedCertificate;\n+            if (m.remaining() < 9) {\n+                throw new SSLProtocolException(\n+                        \"Invalid CompressedCertificate message: \" +\n+                        \"insufficient data (length=\" + m.remaining() + \")\");\n+            }\n+            this.algorithmId = Record.getInt16(m);\n+            this.uncompressedLength = Record.getInt24(m);\n+            this.compressedCert = Record.getBytes24(m);\n+\n+            if (m.hasRemaining()) {\n+                throw handshakeContext.conContext.fatal(\n+                        Alert.HANDSHAKE_FAILURE,\n+                        \"Invalid CompressedCertificate message: \" +\n+                        \"unknown extra data\");\n+            }\n+        }\n+\n+        @Override\n+        public SSLHandshake handshakeType() {\n+            return SSLHandshake.COMPRESSED_CERTIFICATE;\n+        }\n+\n+        @Override\n+        public int messageLength() {\n+            return 8 + compressedCert.length;\n+        }\n+\n+        @Override\n+        public void send(HandshakeOutStream hos) throws IOException {\n+            hos.putInt16(algorithmId);\n+            hos.putInt24(uncompressedLength);\n+            hos.putBytes24(compressedCert);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            MessageFormat messageFormat = new MessageFormat(\n+                    \"\"\"\n+                            \"CompressedCertificate\": '{'\n+                              \"algorithm\": \"{0}\",\n+                              \"uncompressed_length\": {1}\n+                              \"compressed_certificate_message\": [\n+                            {2}\n+                              ]\n+                            '}'\"\"\",\n+                Locale.ENGLISH);\n+\n+            HexDumpEncoder hexEncoder = new HexDumpEncoder();\n+            Object[] messageFields = {\n+                CompressionAlgorithm.nameOf(algorithmId),\n+                uncompressedLength,\n+                Utilities.indent(hexEncoder.encode(compressedCert), \"    \")\n+            };\n+\n+            return messageFormat.format(messageFields);\n+        }\n+    }\n+\n+    \/**\n+     * The \"Certificate\" handshake message producer for TLS 1.3.\n+     *\/\n+    private static final\n+            class CompressedCertProducer implements HandshakeProducer {\n+        \/\/ Prevent instantiation of this class.\n+        private CompressedCertProducer() {\n+            \/\/ blank\n+        }\n+\n+        \/\/ Note this is a special producer, which can only be called from\n+        \/\/ the CertificateMessage producer.  The input 'message' parameter\n+        \/\/ represents the Certificate handshake message.\n+        @Override\n+        public byte[] produce(ConnectionContext context,\n+                HandshakeMessage message) throws IOException {\n+            \/\/ The producing happens in handshake context only.\n+            HandshakeContext hc = (HandshakeContext)context;\n+\n+            \/\/ Compress the Certificate message.\n+            HandshakeOutStream hos = new HandshakeOutStream(null);\n+            message.send(hos);\n+            byte[] certMsg = hos.toByteArray();\n+            byte[] compressedCertMsg =\n+                    hc.certDeflater.getValue().apply(certMsg);\n+            if (compressedCertMsg == null || compressedCertMsg.length == 0) {\n+                throw hc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No compressed Certificate data\");\n+            }\n+\n+            CompressedCertMessage ccm = new CompressedCertMessage(hc,\n+                    hc.certDeflater.getKey(), certMsg.length,\n+                    compressedCertMsg);\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"Produced Compressed Certificate message\", ccm);\n+            }\n+\n+            ccm.write(hc.handshakeOutput);\n+            hc.handshakeOutput.flush();\n+\n+            \/\/ The handshake message has been delivered.\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * The \"Certificate\" handshake message consumer for TLS 1.3.\n+     *\/\n+    private static final class CompressedCertConsumer implements SSLConsumer {\n+        \/\/ Prevent instantiation of this class.\n+        private CompressedCertConsumer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public void consume(ConnectionContext context,\n+                ByteBuffer message) throws IOException {\n+            \/\/ The consuming happens in handshake context only.\n+            HandshakeContext hc = (HandshakeContext)context;\n+\n+            \/\/ clean up this consumer\n+            hc.handshakeConsumers.remove(SSLHandshake.COMPRESSED_CERTIFICATE.id);\n+            hc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE.id);\n+\n+            \/\/ Parse the handshake message\n+            CompressedCertMessage ccm = new CompressedCertMessage(hc, message);\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"Consuming CompressedCertificate handshake message\", ccm);\n+            }\n+\n+            \/\/ check the compression algorithm\n+            Function<byte[], byte[]> inflater =\n+                    hc.certInflaters.get(ccm.algorithmId);\n+            if (inflater == null) {\n+                throw hc.conContext.fatal(Alert.BAD_CERTIFICATE,\n+                    \"Unsupported certificate compression algorithm\");\n+            }\n+\n+            \/\/ decompress\n+            byte[] certificateMessage = inflater.apply(ccm.compressedCert);\n+\n+            \/\/ check the uncompressed length\n+            if (certificateMessage == null ||\n+                    certificateMessage.length != ccm.uncompressedLength) {\n+                throw hc.conContext.fatal(Alert.BAD_CERTIFICATE,\n+                    \"Improper certificate compression\");\n+            }\n+\n+            \/\/ Call the Certificate handshake message consumer.\n+            CertificateMessage.t13HandshakeConsumer.consume(hc,\n+                    ByteBuffer.wrap(certificateMessage));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CompressedCertificate.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.util.AbstractMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+\/**\n+ * Enum for (D)TLS certificate compression algorithms.\n+ *\/\n+enum CompressionAlgorithm {\n+    ZLIB                (1,  \"zlib\"),\n+    BROTLI              (2,  \"brotli\"),\n+    ZSTD                (3,  \"zstd\");\n+\n+    final int id;\n+    final String name;\n+\n+    CompressionAlgorithm(int id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    static CompressionAlgorithm nameOf(String name) {\n+        for (CompressionAlgorithm cca :\n+                CompressionAlgorithm.values()) {\n+            if (cca.name.equals(name)) {\n+                return cca;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    static String nameOf(int id) {\n+        for (CompressionAlgorithm cca :\n+                CompressionAlgorithm.values()) {\n+            if (cca.id == id) {\n+                return cca.name;\n+            }\n+        }\n+\n+        return \"<UNKNOWN CONTENT TYPE: \" + id + \">\";\n+    }\n+\n+    \/\/ Return the size of a SignatureScheme structure in TLS record\n+    static int sizeInRecord() {\n+        return 2;\n+    }\n+\n+    \/\/ Get local supported algorithm collection.\n+    static Map<Integer, Function<byte[], byte[]>> findInflaters(\n+            SSLConfiguration config) {\n+        if (config.certInflaters == null || config.certInflaters.isEmpty()) {\n+            if (SSLLogger.isOn &&\n+                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                SSLLogger.finest(\n+                    \"No supported certificate compression algorithms\");\n+            }\n+            return Map.of();\n+        }\n+\n+        Map<Integer, Function<byte[], byte[]>> inflaters =\n+                new LinkedHashMap<>(config.certInflaters.size());\n+        for (Map.Entry<String, Function<byte[], byte[]>> entry :\n+                config.certInflaters.entrySet()) {\n+            CompressionAlgorithm ca =\n+                    CompressionAlgorithm.nameOf(entry.getKey());\n+            if (ca == null) {\n+                if (SSLLogger.isOn &&\n+                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                    SSLLogger.finest(\n+                        \"Ignore unsupported certificate \" +\n+                        \"compression algorithm: \" + entry.getKey());\n+                }\n+                continue;\n+            }\n+\n+            inflaters.putIfAbsent(ca.id, entry.getValue());\n+        }\n+\n+        return inflaters;\n+    }\n+\n+    static Map.Entry<Integer, Function<byte[], byte[]>> selectDeflater(\n+            SSLConfiguration config,\n+            int[] compressionAlgorithmIds) {\n+        if (config.certDeflaters == null) {\n+            return null;\n+        }\n+\n+        for (Map.Entry<String, Function<byte[], byte[]>> entry :\n+                config.certDeflaters.entrySet()) {\n+            CompressionAlgorithm ca =\n+                    CompressionAlgorithm.nameOf(entry.getKey());\n+            if (ca != null) {\n+                for (int id :  compressionAlgorithmIds) {\n+                    if (ca.id == id) {\n+                        return new AbstractMap.SimpleImmutableEntry<>(\n+                                id, entry.getValue());\n+                    }\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CompressionAlgorithm.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.function.Function;\n@@ -143,0 +144,4 @@\n+    \/\/ CertificateCompressionAlgorithm\n+    Map<Integer, Function<byte[], byte[]>>          certInflaters;\n+    Map.Entry<Integer, Function<byte[], byte[]>>    certDeflater;\n+\n@@ -594,1 +599,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,5 +32,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n+import java.util.*;\n@@ -38,0 +34,1 @@\n+import java.util.function.Function;\n@@ -71,0 +68,5 @@\n+    \/\/ The configured certificate compression algorithms for\n+    \/\/ \"compress_certificate\" extensions\n+    Map<String, Function<byte[], byte[]>> certDeflaters;\n+    Map<String, Function<byte[], byte[]>> certInflaters;\n+\n@@ -153,0 +155,4 @@\n+\n+        this.certDeflaters = Map.of();\n+        this.certInflaters = Map.of();\n+\n@@ -203,0 +209,2 @@\n+        params.setCertificateDeflaters(this.certDeflaters);\n+        params.setCertificateInflaters(this.certInflaters);\n@@ -264,0 +272,2 @@\n+        this.certDeflaters = params.getCertificateDeflaters();\n+        this.certInflaters = params.getCertificateInflaters();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -274,0 +274,21 @@\n+    \/\/ Extensions defined in RFC 8879 (TLS Certificate Compression)\n+    CH_COMPRESS_CERTIFICATE (0x001B, \"compress_certificate\",\n+                             SSLHandshake.CLIENT_HELLO,\n+                             ProtocolVersion.PROTOCOLS_OF_13,\n+                             CompressCertExtension.chNetworkProducer,\n+                             CompressCertExtension.chOnLoadConsumer,\n+                             null,\n+                             null,\n+                             null,\n+                             CompressCertExtension.ccStringizer),\n+\n+    CR_COMPRESS_CERTIFICATE (0x001B, \"compress_certificate\",\n+                             SSLHandshake.CERTIFICATE_REQUEST,\n+                             ProtocolVersion.PROTOCOLS_OF_13,\n+                             CompressCertExtension.crNetworkProducer,\n+                             CompressCertExtension.crOnLoadConsumer,\n+                             null,\n+                             null,\n+                             null,\n+                             CompressCertExtension.ccStringizer),\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLExtension.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -349,0 +349,18 @@\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    COMPRESSED_CERTIFICATE      ((byte)0x19, \"compressed_certificate\",\n+            (Map.Entry<SSLConsumer, ProtocolVersion[]>[])(new Map.Entry[] {\n+                    new SimpleImmutableEntry<>(\n+                            CompressedCertificate.handshakeConsumer,\n+                            ProtocolVersion.PROTOCOLS_OF_13\n+                    )\n+            }),\n+            (Map.Entry<HandshakeProducer, ProtocolVersion[]>[])(new Map.Entry[] {\n+                    \/\/ Note that the producing of this message is delegated to\n+                    \/\/ CertificateMessage producer.\n+                    new SimpleImmutableEntry<>(\n+                            CertificateMessage.t13HandshakeProducer,\n+                            ProtocolVersion.PROTOCOLS_OF_13\n+                    )\n+            })),\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLHandshake.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1398,0 +1398,5 @@\n+            if (chc.certInflaters != null && !chc.certInflaters.isEmpty()) {\n+                chc.handshakeConsumers.put(\n+                        SSLHandshake.COMPRESSED_CERTIFICATE.id,\n+                        SSLHandshake.COMPRESSED_CERTIFICATE);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -545,0 +545,2 @@\n+        p1.setCertificateDeflaters(p.getCertificateDeflaters());\n+        p1.setCertificateInflaters(p.getCertificateInflaters());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8273042\n+ * @summary TLS certificate compression\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm HttpsCompressedCert\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.zip.Inflater;\n+\n+import static java.net.http.HttpResponse.BodyHandlers.ofString;\n+\n+public class HttpsCompressedCert {\n+    private static final Function<byte[], byte[]> certInflater = (input) -> {\n+        try {\n+            Inflater inflater = new Inflater();\n+            inflater.setInput(input);\n+            byte[] output = new byte[1024 * 8];\n+            int l = inflater.inflate(output);\n+            inflater.end();\n+\n+            byte[] data = new byte[l];\n+            System.arraycopy(output, 0, data, 0, l);\n+\n+            return data;\n+        } catch (Exception ex) {\n+            \/\/ just ignore\n+            return null;\n+        }\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        SSLParameters sslParameters = new SSLParameters();\n+        sslParameters.setCertificateInflaters(Map.of(\"brotli\", certInflater));\n+        HttpClient httpClient = HttpClient.newBuilder()\n+                .sslContext(SSLClientContext.createClientSSLContext())\n+                .version(HttpClient.Version.HTTP_2)\n+                .sslParameters(sslParameters)\n+                .build();\n+\n+        HttpRequest httpRequest = HttpRequest.newBuilder(\n+                        new URI(\"https:\/\/www.google.com\/\"))\n+                .GET()\n+                .build();\n+        HttpResponse<String> response = httpClient.send(httpRequest, ofString());\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/HttpsCompressedCert.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8273042\n+ * @summary TLS Certificate Compression\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm CompressedCert\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLSocket;\n+import java.security.Security;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.zip.Deflater;\n+import java.util.zip.Inflater;\n+\n+public class CompressedCert extends SSLSocketTemplate {\n+    private final Map<String, Function<byte[], byte[]>> certDeflaters;\n+    private final Map<String, Function<byte[], byte[]>> certInflaters;\n+    private final boolean requireClientCert;\n+    private final boolean exceptionExpected;\n+\n+    private static final Function<byte[], byte[]> certDeflater = (input) -> {\n+        Deflater deflater = new Deflater();\n+        deflater.setInput(input);\n+        deflater.finish();\n+        byte[] output = new byte[input.length];\n+        int l = deflater.deflate(output);\n+        deflater.end();\n+\n+        byte[] data = new byte[l];\n+        System.arraycopy(output, 0, data, 0, l);\n+\n+        return data;\n+    };\n+\n+    private static final Function<byte[], byte[]> certInflater = (input) -> {\n+        try {\n+            Inflater inflater = new Inflater();\n+            inflater.setInput(input);\n+            byte[] output = new byte[1024 * 8];\n+            int l = inflater.inflate(output);\n+            inflater.end();\n+\n+            byte[] data = new byte[l];\n+            System.arraycopy(output, 0, data, 0, l);\n+\n+            return data;\n+        } catch (Exception ex) {\n+            \/\/ just ignore\n+            return null;\n+        }\n+    };\n+\n+    private static final Function<byte[], byte[]> invalidDeflater = (input) -> {\n+        return input;\n+    };\n+\n+    private static final Function<byte[], byte[]> invalidInflater = (input) -> {\n+        return input;\n+    };\n+\n+    public CompressedCert(\n+            Map<String, Function<byte[], byte[]>> certDeflaters,\n+            Map<String, Function<byte[], byte[]>> certInflaters,\n+            boolean requireClientCert,\n+            boolean exceptionExpected) {\n+        this.certDeflaters = certDeflaters;\n+        this.certInflaters = certInflaters;\n+        this.requireClientCert =  requireClientCert;\n+        this.exceptionExpected = exceptionExpected;\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        sslParameters.setCertificateDeflaters(certDeflaters);\n+        sslParameters.setCertificateInflaters(certInflaters);\n+        sslParameters.setNeedClientAuth(requireClientCert);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        SSLParameters sslParameters = socket.getSSLParameters();\n+        sslParameters.setCertificateDeflaters(certDeflaters);\n+        sslParameters.setCertificateInflaters(certInflaters);\n+        socket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) {\n+        try {\n+            super.runServerApplication(socket);\n+        } catch (Exception ex) {\n+            \/\/ Just ignore, let the client handle the failure information.\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n+        try {\n+            super.runClientApplication(sslSocket);\n+            if (exceptionExpected) {\n+                throw new RuntimeException(\"Unexpected success!\");\n+            }\n+        } catch (Exception ex) {\n+            if (!exceptionExpected) {\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                Map.of(\"zlib\", certInflater),\n+                false,\n+                false);\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                Map.of(\"zlib\", certInflater),\n+                true,\n+                false);\n+\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                Map.of(),\n+                false,\n+                false);\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                Map.of(),\n+                true,\n+                false);\n+\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                null,\n+                false,\n+                false);\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                null,\n+                true,\n+                false);\n+\n+        runTest(Map.of(),\n+                Map.of(\"zlib\", certInflater),\n+                false,\n+                false);\n+        runTest(Map.of(),\n+                Map.of(\"zlib\", certInflater),\n+                true,\n+                false);\n+\n+        runTest(Map.of(),\n+                Map.of(),\n+                false,\n+                false);\n+        runTest(Map.of(),\n+                Map.of(),\n+                true,\n+                false);\n+\n+        runTest(Map.of(),\n+                null,\n+                false,\n+                false);\n+        runTest(Map.of(),\n+                null,\n+                true,\n+                false);\n+\n+        runTest(null,\n+                Map.of(\"zlib\", certInflater),\n+                false,\n+                false);\n+        runTest(null,\n+                Map.of(\"zlib\", certInflater),\n+                true,\n+                false);\n+\n+        runTest(null,\n+                Map.of(),\n+                false,\n+                false);\n+        runTest(null,\n+                Map.of(),\n+                true,\n+                false);\n+\n+        runTest(null,\n+                null,\n+                false,\n+                false);\n+        runTest(null,\n+                null,\n+                true,\n+                false);\n+\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                Map.of(\"brotli\", certInflater),\n+                false,\n+                false);\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                Map.of(\"brotli\", certInflater),\n+                true,\n+                false);\n+\n+        runTest(Map.of(\"brotli\", certDeflater),\n+                Map.of(\"zlib\", certInflater),\n+                false,\n+                false);\n+        runTest(Map.of(\"brotli\", certDeflater),\n+                Map.of(\"zlib\", certInflater),\n+                true,\n+                false);\n+\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                Map.of(\"zlib\", invalidInflater),\n+                false,\n+                true);\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                Map.of(\"zlib\", invalidInflater),\n+                true,\n+                true);\n+\n+        runTest(Map.of(\"zlib\", invalidDeflater),\n+                Map.of(\"zlib\", certInflater),\n+                false,\n+                true);\n+        runTest(Map.of(\"zlib\", invalidDeflater),\n+                Map.of(\"zlib\", certInflater),\n+                true,\n+                true);\n+    }\n+\n+    private static void runTest(\n+            Map<String, Function<byte[], byte[]>> certDeflaters,\n+            Map<String, Function<byte[], byte[]>> certInflaters,\n+            boolean requireClientCert,\n+            boolean exceptionExpected) throws Exception {\n+        new CompressedCert(certDeflaters, certInflaters,\n+                requireClientCert, exceptionExpected).run();\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/CompressedCert.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8273042\n+ * @summary TLS Certificate Compression\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm UnsetCompressedCert\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLSocket;\n+import java.security.Security;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.zip.Deflater;\n+import java.util.zip.Inflater;\n+\n+public class UnsetCompressedCert extends SSLSocketTemplate {\n+    private final Map<String, Function<byte[], byte[]>> certDeflaters;\n+    private final Map<String, Function<byte[], byte[]>> certInflaters;\n+    private final boolean requireClientCert;\n+\n+    private static final Function<byte[], byte[]> certDeflater = (input) -> {\n+        Deflater deflater = new Deflater();\n+        deflater.setInput(input);\n+        deflater.finish();\n+        byte[] output = new byte[input.length];\n+        int l = deflater.deflate(output);\n+        deflater.end();\n+\n+        byte[] data = new byte[l];\n+        System.arraycopy(output, 0, data, 0, l);\n+\n+        return data;\n+    };\n+\n+    private static final Function<byte[], byte[]> certInflater = (input) -> {\n+        try {\n+            Inflater inflater = new Inflater();\n+            inflater.setInput(input);\n+            byte[] output = new byte[1024 * 8];\n+            int l = inflater.inflate(output);\n+            inflater.end();\n+\n+            byte[] data = new byte[l];\n+            System.arraycopy(output, 0, data, 0, l);\n+\n+            return data;\n+        } catch (Exception ex) {\n+            \/\/ just ignore\n+            return null;\n+        }\n+    };\n+\n+    public UnsetCompressedCert(\n+            Map<String, Function<byte[], byte[]>> certDeflaters,\n+            Map<String, Function<byte[], byte[]>> certInflaters,\n+            boolean requireClientCert) {\n+        this.certDeflaters = certDeflaters;\n+        this.certInflaters = certInflaters;\n+        this.requireClientCert =  requireClientCert;\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        if (certDeflaters != null) {\n+            sslParameters.setCertificateDeflaters(certDeflaters);\n+        }\n+        if (certInflaters != null) {\n+            sslParameters.setCertificateInflaters(certInflaters);\n+        }\n+        sslParameters.setNeedClientAuth(requireClientCert);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        SSLParameters sslParameters = socket.getSSLParameters();\n+        if (certDeflaters != null) {\n+            sslParameters.setCertificateDeflaters(certDeflaters);\n+        }\n+\n+        if (certInflaters != null) {\n+            sslParameters.setCertificateInflaters(certInflaters);\n+        }\n+        socket.setSSLParameters(sslParameters);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                null,\n+                false);\n+        runTest(Map.of(\"zlib\", certDeflater),\n+                null,\n+                true);\n+\n+        runTest(Map.of(),\n+                null,\n+                false);\n+        runTest(Map.of(),\n+                null,\n+                true);\n+\n+        runTest(null,\n+                Map.of(\"zlib\", certInflater),\n+                false);\n+        runTest(null,\n+                Map.of(\"zlib\", certInflater),\n+                true);\n+\n+        runTest(null,\n+                Map.of(),\n+                false);\n+        runTest(null,\n+                Map.of(),\n+                true);\n+\n+        runTest(null,\n+                null,\n+                false);\n+        runTest(null,\n+                null,\n+                true);\n+    }\n+\n+    private static void runTest(\n+            Map<String, Function<byte[], byte[]>> certDeflaters,\n+            Map<String, Function<byte[], byte[]>> certInflaters,\n+            boolean requireClientCert) throws Exception {\n+        new UnsetCompressedCert(\n+                certDeflaters, certInflaters, requireClientCert).run();\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/UnsetCompressedCert.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManagerFactory;\n+import java.io.ByteArrayInputStream;\n+import java.security.KeyStore;\n+import java.security.cert.CertificateFactory;\n+\n+public enum SSLClientContext {\n+    GTS_ROOT_R1(\"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIIFWjCCA0KgAwIBAgIQbkepxUtHDA3sM9CJuRz04TANBgkqhkiG9w0BAQwFADBH\n+            MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM\n+            QzEUMBIGA1UEAxMLR1RTIFJvb3QgUjEwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIy\n+            MDAwMDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNl\n+            cnZpY2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjEwggIiMA0GCSqGSIb3DQEB\n+            AQUAA4ICDwAwggIKAoICAQC2EQKLHuOhd5s73L+UPreVp0A8of2C+X0yBoJx9vaM\n+            f\/vo27xqLpeXo4xL+Sv2sfnOhB2x+cWX3u+58qPpvBKJXqeqUqv4IyfLpLGcY9vX\n+            mX7wCl7raKb0xlpHDU0QM+NOsROjyBhsS+z8CZDfnWQpJSMHobTSPS5g4M\/SCYe7\n+            zUjwTcLCeoiKu7rPWRnWr4+wB7CeMfGCwcDfLqZtbBkOtdh+JhpFAz2weaSUKK0P\n+            fyblqAj+lug8aJRT7oM6iCsVlgmy4HqMLnXWnOunVmSPlk9orj2XwoSPwLxAwAtc\n+            vfaHszVsrBhQf4TgTM2S0yDpM7xSma8ytSmzJSq0SPly4cpk9+aCEI3oncKKiPo4\n+            Zor8Y\/kB+Xj9e1x3+naH+uzfsQ55lVe0vSbv1gHR6xYKu44LtcXFilWr06zqkUsp\n+            zBmkMiVOKvFlRNACzqrOSbTqn3yDsEB750Orp2yjj32JgfpMpf\/VjsPOS+C12LOO\n+            Rc92wO1AK\/1TD7Cn1TsNsYqiA94xrcx36m97PtbfkSIS5r762DL8EGMUUXLeXdYW\n+            k70paDPvOmbsB4om3xPXV2V4J95eSRQAogB\/mqghtqmxlbCluQ0WEdrHbEg8QOB+\n+            DVrNVjzRlwW5y0vtOUucxD\/SVRNuJLDWcfr0wbrM7Rv1\/oFB2ACYPTrIrnqYNxgF\n+            lQIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH\/BAUwAwEB\/zAdBgNV\n+            HQ4EFgQU5K8rJnEaK0gnhS9SZizv8IkTcT4wDQYJKoZIhvcNAQEMBQADggIBADiW\n+            Cu49tJYeX++dnAsznyvgyv3SjgofQXSlfKqE1OXyHuY3UjKcC9FhHb8owbZEKTV1\n+            d5iyfNm9dKyKaOOpMQkpAWBz40d8U6iQSifvS9efk+eCNs6aaAyC58\/UEBZvXw6Z\n+            XPYfcX3v73svfuo21pdwCxXu11xWajOl40k4DLh9+42FpLFZXvRq4d2h9mREruZR\n+            gyFmxhE+885H7pwoHyXa\/6xmld01D1zvICxi\/ZG6qcz8WpyTgYMpl0p8WnK0OdC3\n+            d8t5\/Wk6kjftbjhlRn7pYL15iJdfOBL07q9bgsiG1eGZbYwE8na6SfZu6W0eX6Dv\n+            J4J2QPim01hcDyxC2kLGe4g0x8HYRZvBPsVhHdljUEn2NIVq4BjFbkerQUIpm\/Zg\n+            DdIx02OYI5NaAIFItO\/Nis3Jz5nu2Z6qNuFoS3FJFDYoOj0dzpqPJeaAcWErtXvM\n+            +SUWgeExX6GjfhaknBZqlxi9dnKlC54dNuYvoS++cJEPqOba+MSSQGwlfnuzCdyy\n+            F62ARPBopY+Udf90WuioAnwMCeKpSwughQtiue+hMZL77\/ZRBIls6Kl0obsXs7X9\n+            SQ98POyDGCBDTtWTurQ0sR8WNh8M5mQ5Fkzc4P4dyKliPUDqysU0ArSuiYgzNdws\n+            E3PYJ\/HQcu51OyLemGhmW\/HGY0dVHLqlCFF1pkgl\n+            -----END CERTIFICATE-----\"\"\"),\n+\n+    GTS_ROOT_R2(\"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIIFWjCCA0KgAwIBAgIQbkepxlqz5yDFMJo\/aFLybzANBgkqhkiG9w0BAQwFADBH\n+            MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM\n+            QzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIy\n+            MDAwMDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNl\n+            cnZpY2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwggIiMA0GCSqGSIb3DQEB\n+            AQUAA4ICDwAwggIKAoICAQDO3v2m++zsFDQ8BwZabFn3GTXd98GdVarTzTukk3Lv\n+            CvptnfbwhYBboUhSnznFt+4orO\/LdmgUud+tAWyZH8QiHZ\/+cnfgLFuv5AS\/T3Kg\n+            GjSY6Dlo7JUle3ah5mm5hRm9iYz+re026nO8\/4Piy33B0s5Ks40FnotJk9\/BW9Bu\n+            XvAuMC6C\/Pq8tBcKSOWIm8Wba96wyrQD8Nr0kLhlZPdcTK3ofmZemde4wj7I0BOd\n+            re7kRXuJVfeKH2JShBKzwkCX44ofR5GmdFrS+LFjKBC4swm4VndAoiaYecb+3yXu\n+            PuWgf9RhD1FLPD+M2uFwdNjCaKH5wQzpoeJ\/u1U8dgbuak7MkogwTZq9TwtImoS1\n+            mKPV+3PBV2HdKFZ1E66HjucMUQkQdYhMvI35ezzUIkgfKtzra7tEscszcTJGr61K\n+            8YzodDqs5xoic4DSMPclQsciOzsSrZYuxsN2B6ogtzVJV+mSSeh2FnIxZyuWfoqj\n+            x5RWIr9qS34BIbIjMt\/kmkRtWVtd9QCgHJvGeJeNkP+byKq0rxFROV7Z+2et1VsR\n+            nTKaG73VululycslaVNVJ1zgyjbLiGH7HrfQy+4W+9OmTN6SpdTi3\/UGVN4unUu0\n+            kzCqgc7dGtxRcw1PcOnlthYhGXmy5okLdWTK1au8CcEYof\/UVKGFPP0UJAOyh9Ok\n+            twIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH\/BAUwAwEB\/zAdBgNV\n+            HQ4EFgQUu\/\/KjiOfT5nK2+JopqUVJxce2Q4wDQYJKoZIhvcNAQEMBQADggIBALZp\n+            8KZ3\/p7uC4Gt4cCpx\/k1HUCCq+YEtN\/L9x0Pg\/B+E02NjO7jMyLDOfxA325BS0JT\n+            vhaI8dI4XsRomRyYUpOM52jtG2pzegVATX9lO9ZY8c6DR2Dj\/5epnGB3GFW1fgiT\n+            z9D2PGcDFWEJ+YF59exTpJ\/JjwGLc8R3dtyDovUMSRqodt6Sm2T4syzFJ9MHwAiA\n+            pJiS4wGWAqoC7o87xdFtCjMwc3i5T1QWvwsHoaRc5svJXISPD+AVdyx+Jn7axEvb\n+            pxZ3B7DNdehyQtaVhJ2Gg\/LkkM0JR9SLA3DaWsYDQvTtN6LwG1BUSw7YhN4ZKJmB\n+            R64JGz9I0cNv4rBgF\/XuIwKl2gBbbZCr7qLpGzvpx0QnRY5rn\/WkhLx3+WuXrD5R\n+            RaIRpsyF7gpo8j5QOHokYh4XIDdtak23CZvJ\/KRY9bb7nE4Yu5UC56GtmwfuNmsk\n+            0jmGwZODUNKBRqhfYlcsu2xkiAhu7xNUX90txGdj08+JN7+dIPT7eoOboB6BAFDC\n+            5AwiWVIQ7UNWhwD4FFKnHYuTjKJNRn8nxnGbJN7k2oaLDX5rIMHAnuFl2GqjpuiF\n+            izoHCBy69Y9Vmhh1fuXsgWbRIXOhNUQLgD1bnF5vKheW0YMjiGZt5obicDIvUiLn\n+            yOd\/xCxgXS\/Dr55FBcOEArf9LAhST4Ldo\/DUhgkC\n+            -----END CERTIFICATE-----\"\"\"),\n+\n+    GTS_ROOT_R3(\"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIICDDCCAZGgAwIBAgIQbkepx2ypcyRAiQ8DVd2NHTAKBggqhkjOPQQDAzBHMQsw\n+            CQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExMQzEU\n+            MBIGA1UEAxMLR1RTIFJvb3QgUjMwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIyMDAw\n+            MDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZp\n+            Y2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjMwdjAQBgcqhkjOPQIBBgUrgQQA\n+            IgNiAAQfTzOHMymKoYTey8chWEGJ6ladK0uFxh1MJ7x\/JlFyb+Kf1qPKzEUURout\n+            736GjOyxfi\/\/qXGdGIRFBEFVbivqJn+7kAHjSxm65FSWRQmx1WyRRK2EE46ajA2A\n+            DDL24CejQjBAMA4GA1UdDwEB\/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH\/MB0GA1Ud\n+            DgQWBBTB8Sa6oC2uhYHP0\/EqEr24Cmf9vDAKBggqhkjOPQQDAwNpADBmAjEAgFuk\n+            fCPAlaUs3L6JbyO5o91lAFJekazInXJ0glMLfalAvWhgxeG4VDvBNhcl2MG9AjEA\n+            njWSdIUlUfUk7GRSJFClH9voy8l27OyCbvWFGFPouOOaKaqW04MjyaR7YbPMAuhd\n+            -----END CERTIFICATE-----\"\"\"),\n+\n+    GTS_ROOT_R4(\"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIICCjCCAZGgAwIBAgIQbkepyIuUtui7OyrYorLBmTAKBggqhkjOPQQDAzBHMQsw\n+            CQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExMQzEU\n+            MBIGA1UEAxMLR1RTIFJvb3QgUjQwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIyMDAw\n+            MDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZp\n+            Y2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjQwdjAQBgcqhkjOPQIBBgUrgQQA\n+            IgNiAATzdHOnaItgrkO4NcWBMHtLSZ37wWHO5t5GvWvVYRg1rkDdc\/eJkTBa6zzu\n+            hXyiQHY7qca4R9gq55KRanPpsXI5nymfopjTX15YhmUPoYRlBtHci8nHc8iMai\/l\n+            xKvRHYqjQjBAMA4GA1UdDwEB\/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH\/MB0GA1Ud\n+            DgQWBBSATNbrdP9JNqPV2Py1PsVq8JQdjDAKBggqhkjOPQQDAwNnADBkAjBqUFJ0\n+            CMRw3J5QdCHojXohw0+WbhXRIjVhLfoIN+4Zba3bssx9BzT1YBkstTTZbyACMANx\n+            sbqjYAuG7ZoIapVon+Kz4ZNkfF6Tpt95LY2F45TPI11xzPKwTdb+mciUqXWi4w==\n+            -----END CERTIFICATE-----\"\"\");\n+\n+    final String certStr;\n+\n+    SSLClientContext(String certStr) {\n+        this.certStr = certStr;\n+    }\n+\n+    public static SSLContext createClientSSLContext() throws Exception {\n+        \/\/ Generate certificate from cert string.\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n+        \/\/ Import the trusted certs.\n+        KeyStore ts = KeyStore.getInstance(\"PKCS12\");\n+        ts.load(null, null);\n+        for (SSLClientContext clientContext : SSLClientContext.values()) {\n+            try (ByteArrayInputStream is = new ByteArrayInputStream(\n+                        clientContext.certStr.getBytes())) {\n+                ts.setCertificateEntry(\"trusted-cert-\" +\n+                        clientContext.name(), cf.generateCertificate(is));\n+            }\n+        }\n+\n+        \/\/ Create an SSLContext object.\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ts);\n+\n+        SSLContext context = SSLContext.getInstance(\"TLS\");\n+        context.init(null, tmf.getTrustManagers(), null);\n+\n+        return context;\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLClientContext.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}