{"files":[{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4460376\n+  @summary we should create Component-, Container- and HierarchyEvents if\n+  appropriate AWTEventListener added on Toolkit\n+  @key headful\n+*\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ContainerEvent;\n+import java.awt.event.HierarchyEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ToolkitListenerTest implements AWTEventListener\n+{\n+    public static Frame frame;\n+    static boolean containerEventReceived = false;\n+    static boolean componentEventReceived = false;\n+    static boolean hierarchyEventReceived = false;\n+    static boolean hierarchyBoundsEventReceived = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        ToolkitListenerTest test = new ToolkitListenerTest();\n+        test.start();\n+    }\n+    public void start() throws Exception {\n+        Toolkit.getDefaultToolkit().\n+            addAWTEventListener(this,\n+                AWTEvent.COMPONENT_EVENT_MASK |\n+                    AWTEvent.CONTAINER_EVENT_MASK |\n+                    AWTEvent.HIERARCHY_EVENT_MASK |\n+                    AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK);\n+        EventQueue.invokeAndWait(() -> {\n+            frame = new Frame(\"ToolkitListenerTest\");\n+            frame.setSize(200,200);\n+            frame.add(new Button());\n+            frame.setBounds(100, 100, 100, 100);\n+        });\n+        try {\n+            Toolkit.getDefaultToolkit().getSystemEventQueue().\n+                invokeAndWait(new Runnable() {\n+                    public void run() {}\n+                });\n+\n+            if (!componentEventReceived) {\n+                throw new RuntimeException(\"Test Failed: ComponentEvent was not dispatched\");\n+            }\n+            if (!containerEventReceived) {\n+                throw new RuntimeException(\"Test Failed: ContainerEvent was not dispatched\");\n+            }\n+            if (!hierarchyEventReceived) {\n+                throw new RuntimeException(\"Test Failed: HierarchyEvent(HIERARCHY_CHANGED) was not dispatched\");\n+            }\n+            if (!hierarchyBoundsEventReceived) {\n+                throw new RuntimeException(\"Test Failed: HierarchyEvent(ANCESTOR_MOVED or ANCESTOR_RESIZED) was not dispatched\");\n+            }\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(\"Test Failed: InterruptedException accured.\");\n+        } catch (InvocationTargetException ite) {\n+            throw new RuntimeException(\"Test Failed: InvocationTargetException accured.\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        System.err.println(e);\n+        if (e instanceof ContainerEvent) {\n+            containerEventReceived = true;\n+        } else if (e instanceof ComponentEvent) {\n+            componentEventReceived = true;\n+        } else if (e instanceof HierarchyEvent) {\n+            switch (e.getID()) {\n+                case HierarchyEvent.HIERARCHY_CHANGED:\n+                    hierarchyEventReceived = true;\n+                    break;\n+                case HierarchyEvent.ANCESTOR_MOVED:\n+                case HierarchyEvent.ANCESTOR_RESIZED:\n+                    hierarchyBoundsEventReceived = true;\n+                    break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Toolkit\/ToolkitListenerTest\/ToolkitListenerTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4914613\n+  @summary tests that \"\\r\\n\" is not converted to \"\\r\\r\\n\"\n+  @key headful\n+*\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.SystemFlavorMap;\n+import java.awt.datatransfer.Transferable;\n+import java.io.File;\n+import java.io.InputStream;\n+\n+public class CRLFTest {\n+    private int returnCode = 0;\n+\n+    public static void main(String[] args) {\n+        CRLFTest parent = new CRLFTest();\n+        parent.start();\n+    }\n+    public void start() {\n+\n+        try {\n+            String javaPath = System.getProperty(\"java.home\", \"\");\n+            String command = javaPath + File.separator + \"bin\" +\n+                File.separator + \"java -cp \" +\n+                System.getProperty(\"test.classes\", \".\") +\n+                \" CRLFTestClipboard\";\n+\n+            Process process = Runtime.getRuntime().exec(command);\n+            ProcessResults pres = ProcessResults.doWaitFor(process);\n+            returnCode = pres.exitValue;\n+\n+            if (pres.stderr != null && pres.stderr.length() > 0) {\n+                System.err.println(\"========= Child VM System.err ========\");\n+                System.err.print(pres.stderr);\n+                System.err.println(\"======================================\");\n+            }\n+\n+            if (pres.stdout != null && pres.stdout.length() > 0) {\n+                System.err.println(\"========= Child VM System.out ========\");\n+                System.err.print(pres.stdout);\n+                System.err.println(\"======================================\");\n+            }\n+\n+            System.err.println(\"Child return code=\" + returnCode);\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n+\n+class CRLFTestClipboard implements ClipboardOwner {\n+    private static final Clipboard clipboard =\n+        Toolkit.getDefaultToolkit().getSystemClipboard();\n+\n+    public static void main(String[] args) {\n+        CRLFTestClipboard child = new CRLFTestClipboard();\n+        child.run();\n+    }\n+\n+    public void run() {\n+        ClipboardOwner owner = new ClipboardOwner() {\n+            public void lostOwnership(Clipboard clipboard,\n+                                      Transferable contents) {\n+                System.exit(0);\n+            }\n+        };\n+        clipboard.setContents(new StringSelection(\"\\r\\n\"), owner);\n+\n+        \/\/ Wait to let the parent retrieve the contents.\n+        try {\n+            Thread.sleep(30000);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void lostOwnership(Clipboard clip, Transferable contents) {\n+        final DataFlavor df =\n+            new DataFlavor(\"text\/test-subtype; class=java.io.InputStream\",\n+                null);\n+        SystemFlavorMap sfm =\n+            (SystemFlavorMap)SystemFlavorMap.getDefaultFlavorMap();\n+        sfm.addUnencodedNativeForFlavor(df, \"TEXT\");\n+        sfm.addFlavorForUnencodedNative(\"TEXT\", df);\n+        Runnable r = new Runnable() {\n+            public void run() {\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                Transferable t = clipboard.getContents(null);\n+                boolean passed = true;\n+                try {\n+                    InputStream is =\n+                        (InputStream)t.getTransferData(df);\n+                    int prev = 0;\n+                    int b = 0;\n+                    System.err.print(\"Bytes: \");\n+                    while ((b = is.read()) != -1) {\n+                        System.err.print(\" \" + Integer.\n+                            toHexString((int)b & 0xFF));\n+                        if (b == 0xD && prev == 0xD) {\n+                            passed = false;\n+                        }\n+                        prev = b;\n+                    }\n+                    System.err.println();\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+                clipboard.setContents(new StringSelection(\"\"), null);\n+\n+                if (!passed) {\n+                    throw new RuntimeException(\"Test failed\");\n+                }\n+            }\n+        };\n+        new Thread(r).start();\n+    }\n+}\n+\n+class ProcessResults {\n+    public int exitValue;\n+    public String stdout;\n+    public String stderr;\n+\n+    public ProcessResults() {\n+        exitValue = -1;\n+        stdout = \"\";\n+        stderr = \"\";\n+    }\n+\n+    \/**\n+     * Method to perform a \"wait\" for a process and return its exit value.\n+     * This is a workaround for <code>Process.waitFor()<\/code> never returning.\n+     *\/\n+    public static ProcessResults doWaitFor(Process p) {\n+        ProcessResults pres = new ProcessResults();\n+\n+        InputStream in = null;\n+        InputStream err = null;\n+\n+        try {\n+            in = p.getInputStream();\n+            err = p.getErrorStream();\n+\n+            boolean finished = false;\n+\n+            while (!finished) {\n+                try {\n+                    while (in.available() > 0) {\n+                        pres.stdout += (char)in.read();\n+                    }\n+                    while (err.available() > 0) {\n+                        pres.stderr += (char)err.read();\n+                    }\n+                    \/\/ Ask the process for its exitValue. If the process\n+                    \/\/ is not finished, an IllegalThreadStateException\n+                    \/\/ is thrown. If it is finished, we fall through and\n+                    \/\/ the variable finished is set to true.\n+                    pres.exitValue = p.exitValue();\n+                    finished  = true;\n+                }\n+                catch (IllegalThreadStateException e) {\n+                    \/\/ Process is not finished yet;\n+                    \/\/ Sleep a little to save on CPU cycles\n+                    Thread.currentThread().sleep(500);\n+                }\n+            }\n+            if (in != null) in.close();\n+            if (err != null) err.close();\n+        }\n+        catch (Throwable e) {\n+            System.err.println(\"doWaitFor(): unexpected exception\");\n+            e.printStackTrace();\n+        }\n+        return pres;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/datatransfer\/CRLFTest\/CRLFTest.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4760364\n+  @summary Tests that the deadlock doesn't happen when two apps request\n+           selection data from each other.\n+  @key headful\n+*\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+public class DataConversionDeadlockTest {\n+\n+    public static void main(String[] args) {\n+        DataConversionDeadlockTest parent = new DataConversionDeadlockTest();\n+        parent.start();\n+    }\n+\n+    public void start() {\n+        try {\n+            String javaPath = System.getProperty(\"java.home\", \"\");\n+            String cmd = javaPath + File.separator + \"bin\" +\n+                File.separator + \"java -cp \" +\n+                System.getProperty(\"test.classes\", \".\") +\n+                \" DataConversionDeadlockTestChild\";\n+\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            ProcessResults pres = ProcessResults.doWaitFor(process);\n+\n+            if (pres.stderr != null && pres.stderr.length() > 0) {\n+                System.err.println(\"========= Child VM System.err ========\");\n+                System.err.print(pres.stderr);\n+                System.err.println(\"======================================\");\n+            }\n+\n+            if (pres.stdout != null && pres.stdout.length() > 0) {\n+                System.err.println(\"========= Child VM System.out ========\");\n+                System.err.print(pres.stdout);\n+                System.err.println(\"======================================\");\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n+\n+class DataConversionDeadlockTestChild implements ClipboardOwner, Runnable {\n+    private static final Toolkit toolkit = Toolkit.getDefaultToolkit();\n+    private static final Clipboard clipboard = toolkit.getSystemClipboard();\n+    private static final Clipboard selection = toolkit.getSystemSelection();\n+    private static final Transferable t = new StringSelection(\"TEXT\");\n+\n+    public void lostOwnership(Clipboard cb, Transferable contents) {\n+        ClipboardUtil.setClipboardContents(selection, t, this);\n+        new Thread(this).start();\n+    }\n+\n+    public void run() {\n+        for (int i = 0; i < 100; i++) {\n+            EventQueue.invokeLater(new Runnable() {\n+                public void run() {\n+                    ClipboardUtil.getClipboardContents(clipboard, null);\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        if (clipboard == null || selection == null) {\n+            return;\n+        }\n+        ClipboardUtil.setClipboardContents(clipboard, t, null);\n+        for (int i = 0; i < 100; i++) {\n+            EventQueue.invokeLater(new Runnable() {\n+                public void run() {\n+                    ClipboardUtil.getClipboardContents(selection, null);\n+                }\n+            });\n+        }\n+    }\n+}\n+\n+class ClipboardUtil {\n+    public static void setClipboardContents(Clipboard cb,\n+                                            Transferable contents,\n+                                            ClipboardOwner owner) {\n+        synchronized (cb) {\n+            boolean set = false;\n+            while (!set) {\n+                try {\n+                    cb.setContents(contents, owner);\n+                    set = true;\n+                } catch (IllegalStateException ise) {\n+                    try { Thread.sleep(100); }\n+                    catch (InterruptedException e) { e.printStackTrace(); }\n+                }\n+            }\n+        }\n+    }\n+\n+    public static Transferable getClipboardContents(Clipboard cb,\n+                                                    Object requestor) {\n+        synchronized (cb) {\n+            while (true) {\n+                try {\n+                    Transferable t = cb.getContents(requestor);\n+                    return t;\n+                } catch (IllegalStateException ise) {\n+                    try { Thread.sleep(100); }\n+                    catch (InterruptedException e) { e.printStackTrace(); }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+class ProcessResults {\n+    public int exitValue;\n+    public String stdout;\n+    public String stderr;\n+\n+    public ProcessResults() {\n+        exitValue = -1;\n+        stdout = \"\";\n+        stderr = \"\";\n+    }\n+\n+    \/**\n+     * Method to perform a \"wait\" for a process and return its exit value.\n+     * This is a workaround for <code>Process.waitFor()<\/code> never returning.\n+     *\/\n+    public static ProcessResults doWaitFor(Process p) {\n+        ProcessResults pres = new ProcessResults();\n+\n+        InputStream in = null;\n+        InputStream err = null;\n+\n+        try {\n+            in = p.getInputStream();\n+            err = p.getErrorStream();\n+\n+            boolean finished = false;\n+\n+            while (!finished) {\n+                try {\n+                    while (in.available() > 0) {\n+                        pres.stdout += (char)in.read();\n+                    }\n+                    while (err.available() > 0) {\n+                        pres.stderr += (char)err.read();\n+                    }\n+                    \/\/ Ask the process for its exitValue. If the process\n+                    \/\/ is not finished, an IllegalThreadStateException\n+                    \/\/ is thrown. If it is finished, we fall through and\n+                    \/\/ the variable finished is set to true.\n+                    pres.exitValue = p.exitValue();\n+                    finished  = true;\n+                }\n+                catch (IllegalThreadStateException e) {\n+                    \/\/ Process is not finished yet;\n+                    \/\/ Sleep a little to save on CPU cycles\n+                    Thread.currentThread().sleep(500);\n+                }\n+            }\n+            if (in != null) in.close();\n+            if (err != null) err.close();\n+        }\n+        catch (Throwable e) {\n+            System.err.println(\"doWaitFor(): unexpected exception\");\n+            e.printStackTrace();\n+        }\n+        return pres;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/datatransfer\/DataConversionDeadlockTest\/DataConversionDeadlockTest.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @summary  To test if the DataFlavor.selectBestTextFlavor() method\n+         is selecting the correct best flavor from an array of flavors.\n+*\/\n+\n+\n+import java.awt.datatransfer.DataFlavor;\n+import java.util.Vector;\n+\n+public class BestTextFlavorTest {\n+    public static DataFlavor plainISOFlavor,\n+        plainAsciiFlavor,\n+        plainTextFlavor,\n+        enrichFlavor;\n+    public static DataFlavor[] bestFlavorArray1;\n+    public static DataFlavor[] bestFlavorArray2;\n+    public static DataFlavor bestFlavor1,bestFlavor2;\n+    private static Vector tmpFlavors;\n+\n+    \/\/Creating new flavors\n+    static {\n+\n+        tmpFlavors = new Vector();\n+        try {\n+            tmpFlavors.addElement(DataFlavor.stringFlavor);\n+            tmpFlavors.addElement(new DataFlavor\n+                (\"text\/plain; charset=unicode\"));\n+            tmpFlavors.addElement(\n+                new DataFlavor(\"text\/plain; charset=us-ascii\"));\n+            enrichFlavor=new DataFlavor(\"text\/enriched; charset=ascii\");\n+            tmpFlavors.addElement(enrichFlavor);\n+            plainTextFlavor=DataFlavor.getTextPlainUnicodeFlavor();\n+            tmpFlavors.addElement(plainTextFlavor);\n+            plainAsciiFlavor=new DataFlavor(\"text\/plain; charset=ascii\");\n+            tmpFlavors.addElement(plainAsciiFlavor);\n+            plainISOFlavor=new DataFlavor(\"text\/plain; charset=iso8859-1\");\n+            tmpFlavors.addElement(plainISOFlavor);\n+        }\/\/try\n+        catch (ClassNotFoundException e) {\n+            \/\/ should never happen...\n+            System.out.println(\"ClassNotFound Exception is thrown when\"+\n+                \"flavors are created\");\n+        }\/\/catch\n+    }\n+\n+    public static void main(String[] args) {\n+        bestFlavorArray1 = new DataFlavor[tmpFlavors.size()];\n+        tmpFlavors.copyInto(bestFlavorArray1);\n+\n+        \/\/Selecting the best text flavor from a set of Data Flavors.\n+        bestFlavor1 = DataFlavor.selectBestTextFlavor(bestFlavorArray1);\n+        System.out.println(\"The Best Text Flavor is \" + bestFlavor1);\n+\n+        bestFlavorArray2 = reverseDataFlavor(bestFlavorArray1);\n+        bestFlavor2 = DataFlavor.selectBestTextFlavor(bestFlavorArray2);\n+        System.out.println(\"The Best Text Flavor is \" + bestFlavor2);\n+\n+        \/\/Checking whether the selected flavors in both the arrays are same.\n+        if(bestFlavor2.match(bestFlavor1)) {\n+            System.out.println(\"The test is Passed\");\n+            System.out.println(\"Pass\");\n+        }\n+        else {\n+            System.out.println(\"The test is Failed\");\n+            throw new RuntimeException(\"SelectBestTextFlavor doesn't return \"+\n+                \"the same best Text flavor  from a set of DataFlavors, \"+\n+                \"it always returns the first Text Flavor encountered.\");\n+        }\n+    }\n+\n+    \/\/Returns the array of DataFlavor passed in reverse order.\n+    public static DataFlavor[] reverseDataFlavor(DataFlavor[] dataflavor) {\n+\n+        DataFlavor[] tempFlavor = new DataFlavor[dataflavor.length];\n+        int j = 0;\n+        for(int i = dataflavor.length - 1  ; i >= 0; i--) {\n+            tempFlavor[j] = dataflavor[i];\n+            j++;\n+        }\n+        return tempFlavor;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/datatransfer\/DataFlavor\/BestTextFlavorTest\/BestTextFlavorTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+  @test\n+  @bug 4916420\n+  @requires os.family == \"linux\"\n+  @summary verifies that AWT_LOCK is properly taken during file transfer\n+  @key headful\n+*\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+\n+public class FileTransferAWTLockTest {\n+\n+    public static void main(String[] args) {\n+        if (!(System.getProperty(\"os.name\").startsWith(\"Linux\"))) {\n+            return;\n+        }\n+        FileTransferAWTLockTest parent = new FileTransferAWTLockTest();\n+        parent.start();\n+    }\n+\n+    public void start() {\n+        String stderr = null;\n+        try {\n+            String javaPath = System.getProperty(\"java.home\", \"\");\n+            String command = javaPath + File.separator + \"bin\" +\n+                File.separator + \"java -cp \" +\n+                System.getProperty(\"test.classes\", \".\") +\n+                \" -Dawt.toolkit=sun.awt.X11.XToolkit\" +\n+                \" FileTransferAWTLockTestChild\";\n+\n+            Process process = Runtime.getRuntime().exec(command);\n+            ProcessResults pres = ProcessResults.doWaitFor(process);\n+\n+            stderr = pres.stderr;\n+\n+            if (pres.stderr != null && pres.stderr.length() > 0) {\n+                System.err.println(\"========= Child VM System.err ========\");\n+                System.err.print(pres.stderr);\n+                System.err.println(\"======================================\");\n+            }\n+\n+            if (pres.stdout != null && pres.stdout.length() > 0) {\n+                System.err.println(\"========= Child VM System.out ========\");\n+                System.err.print(pres.stdout);\n+                System.err.println(\"======================================\");\n+            }\n+\n+            System.err.println(\"Child VM return code: \" + pres.exitValue);\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+\n+        if (stderr != null && stderr.indexOf(\"InternalError\") >= 0) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+}\n+\n+class FileTransferAWTLockTestChild {\n+    static final Clipboard clipboard =\n+        Toolkit.getDefaultToolkit().getSystemClipboard();\n+    static final Transferable transferable = new Transferable() {\n+        public DataFlavor[] getTransferDataFlavors() {\n+            return new DataFlavor[] { DataFlavor.javaFileListFlavor };\n+        }\n+        public boolean isDataFlavorSupported(DataFlavor df) {\n+            return DataFlavor.javaFileListFlavor.equals(df);\n+        }\n+        public Object getTransferData(DataFlavor df)\n+            throws IOException, UnsupportedFlavorException {\n+            if (!isDataFlavorSupported(df)) {\n+                throw new UnsupportedFlavorException(df);\n+            }\n+\n+            File file = new File(\"file.txt\");\n+            ArrayList list = new ArrayList();\n+            list.add(file);\n+            return list;\n+        }\n+    };\n+\n+    public static void main(String[] args) {\n+        Util.setClipboardContents(clipboard, transferable, null);\n+        FileTransferAWTLockTestChild test = new FileTransferAWTLockTestChild();\n+        test.run();\n+    }\n+\n+    public void run() {\n+        Transferable t = Util.getClipboardContents(clipboard, null);\n+        try {\n+            t.getTransferData(DataFlavor.javaFileListFlavor);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n+\n+class Util {\n+    public static void setClipboardContents(Clipboard cb,\n+                                            Transferable contents,\n+                                            ClipboardOwner owner) {\n+        synchronized (cb) {\n+            while (true) {\n+                try {\n+                    cb.setContents(contents, owner);\n+                    return;\n+                } catch (IllegalStateException ise) {\n+                    try { Thread.sleep(100); }\n+                    catch (InterruptedException e) { e.printStackTrace(); }\n+                }\n+            }\n+        }\n+    }\n+\n+    public static Transferable getClipboardContents(Clipboard cb,\n+                                                    Object requestor) {\n+        synchronized (cb) {\n+            while (true) {\n+                try {\n+                    return cb.getContents(requestor);\n+                } catch (IllegalStateException ise) {\n+                    try { Thread.sleep(100); }\n+                    catch (InterruptedException e) { e.printStackTrace(); }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+class ProcessResults {\n+    public int exitValue;\n+    public String stdout;\n+    public String stderr;\n+\n+    public ProcessResults() {\n+        exitValue = -1;\n+        stdout = \"\";\n+        stderr = \"\";\n+    }\n+\n+    \/**\n+     * Method to perform a \"wait\" for a process and return its exit value.\n+     * This is a workaround for <code>Process.waitFor()<\/code> never returning.\n+     *\/\n+    public static ProcessResults doWaitFor(Process p) {\n+        ProcessResults pres = new ProcessResults();\n+\n+        InputStream in = null;\n+        InputStream err = null;\n+\n+        try {\n+            in = p.getInputStream();\n+            err = p.getErrorStream();\n+\n+            boolean finished = false;\n+\n+            while (!finished) {\n+                try {\n+                    while (in.available() > 0) {\n+                        pres.stdout += (char)in.read();\n+                    }\n+                    while (err.available() > 0) {\n+                        pres.stderr += (char)err.read();\n+                    }\n+                    \/\/ Ask the process for its exitValue. If the process\n+                    \/\/ is not finished, an IllegalThreadStateException\n+                    \/\/ is thrown. If it is finished, we fall through and\n+                    \/\/ the variable finished is set to true.\n+                    pres.exitValue = p.exitValue();\n+                    finished  = true;\n+                }\n+                catch (IllegalThreadStateException e) {\n+                    \/\/ Process is not finished yet;\n+                    \/\/ Sleep a little to save on CPU cycles\n+                    Thread.currentThread().sleep(500);\n+                }\n+            }\n+            if (in != null) in.close();\n+            if (err != null) err.close();\n+        }\n+        catch (Throwable e) {\n+            System.err.println(\"doWaitFor(): unexpected exception\");\n+            e.printStackTrace();\n+        }\n+        return pres;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/datatransfer\/FileTransferAWTLockTest\/FileTransferAWTLockTest.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"}]}