{"files":[{"patch":"@@ -132,1 +132,1 @@\n-          sudo qemu-debootstrap\n+          sudo debootstrap\n@@ -148,1 +148,3 @@\n-          rm -rf sysroot\/{dev,proc,run,sys}\n+          rm -rf sysroot\/{dev,proc,run,sys,var}\n+          rm -rf sysroot\/usr\/{sbin,bin,share}\n+          rm -rf sysroot\/usr\/lib\/{apt,udev,systemd}\n","filename":".github\/workflows\/build-cross-compile.yml","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -278,0 +278,2 @@\n+    elif test \"x$OPENJDK_TARGET_CPU\" = \"xriscv64\"; then\n+      AC_MSG_RESULT([yes])\n","filename":"make\/autoconf\/jvm-features.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-DISABLED_WARNINGS_java += lossy-conversions\n","filename":"make\/modules\/jdk.naming.dns\/Java.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -463,0 +463,1 @@\n+    \/\/ Governing predicates for load\/store and arithmetic\n@@ -470,1 +471,0 @@\n-    P7,\n@@ -472,0 +472,1 @@\n+    \/\/ Extra predicates\n@@ -480,0 +481,3 @@\n+\n+    \/\/ Preserved for all-true predicate\n+    P7,\n@@ -5541,0 +5545,1 @@\n+  match(pReg);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4662,1 +4662,1 @@\n-instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+instruct vloadmaskB_sve(pReg dst, vReg src, rFlagsReg cr) %{\n@@ -4674,1 +4674,1 @@\n-instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_sve(pReg dst, vReg src, vReg tmp, rFlagsReg cr) %{\n@@ -4688,1 +4688,1 @@\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+instruct vloadmaskB_masked(pReg dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n@@ -4700,1 +4700,1 @@\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_masked(pReg dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -4754,1 +4754,1 @@\n-instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+instruct vstoremaskB_sve(vReg dst, pReg src, immI_1 size) %{\n@@ -4764,1 +4764,1 @@\n-instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+instruct vstoremask_narrow_sve(vReg dst, pReg src, immI_gt_1 size, vReg tmp) %{\n@@ -4781,1 +4781,1 @@\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadV(pReg dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n@@ -4803,1 +4803,1 @@\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+instruct vloadmask_loadV_masked(pReg dst, indirect mem, pRegGov pg,\n@@ -4824,1 +4824,1 @@\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadVMasked(pReg dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -4851,1 +4851,1 @@\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+instruct vloadmask_loadVMasked_masked(pReg dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n@@ -4881,1 +4881,1 @@\n-instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+instruct storeV_vstoremask(indirect mem, pReg src, immI_gt_1 esize, vReg tmp) %{\n@@ -4902,1 +4902,1 @@\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+instruct storeV_vstoremask_masked(indirect mem, pReg src, immI_gt_1 esize,\n@@ -4924,1 +4924,1 @@\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+instruct storeVMasked_vstoremask(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n@@ -4950,1 +4950,1 @@\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize,\n@@ -4980,1 +4980,1 @@\n-instruct vmask_and(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_and(pReg pd, pReg pn, pReg pm) %{\n@@ -4990,1 +4990,1 @@\n-instruct vmask_or(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_or(pReg pd, pReg pn, pReg pm) %{\n@@ -5000,1 +5000,1 @@\n-instruct vmask_xor(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_xor(pReg pd, pReg pn, pReg pm) %{\n@@ -5010,1 +5010,1 @@\n-instruct vmask_and_notI(pRegGov pd, pRegGov pn, pRegGov pm, immI_M1 m1) %{\n+instruct vmask_and_notI(pReg pd, pReg pn, pReg pm, immI_M1 m1) %{\n@@ -5020,1 +5020,1 @@\n-instruct vmask_and_notL(pRegGov pd, pRegGov pn, pRegGov pm, immL_M1 m1) %{\n+instruct vmask_and_notL(pReg pd, pReg pn, pReg pm, immL_M1 m1) %{\n@@ -5048,1 +5048,1 @@\n-instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+instruct vmaskcmp_sve(pReg dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n@@ -5063,1 +5063,1 @@\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+instruct vmaskcmp_masked(pReg dst, vReg src1, vReg src2, immI cond,\n@@ -5090,1 +5090,1 @@\n-instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+instruct vmaskcast_same_esize_sve(pReg dst_src) %{\n@@ -5100,1 +5100,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend(pReg dst, pReg src) %{\n@@ -5117,1 +5117,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow(pReg dst, pReg src) %{\n@@ -5136,1 +5136,1 @@\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+instruct vmask_reinterpret_same_esize(pReg dst_src) %{\n@@ -5147,1 +5147,1 @@\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+instruct vmask_reinterpret_diff_esize(pReg dst, pReg src, vReg tmp, rFlagsReg cr) %{\n@@ -5293,1 +5293,1 @@\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pReg pg, pReg ptmp) %{\n@@ -5405,1 +5405,1 @@\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+instruct vmask_fromlong(pReg dst, iRegL src, vReg tmp1, vReg tmp2) %{\n@@ -5422,1 +5422,1 @@\n-instruct vmaskAll_immI(pRegGov dst, immI src, rFlagsReg cr) %{\n+instruct vmaskAll_immI(pReg dst, immI src, rFlagsReg cr) %{\n@@ -5440,1 +5440,1 @@\n-instruct vmaskAllI(pRegGov dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllI(pReg dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n@@ -5456,1 +5456,1 @@\n-instruct vmaskAllI_masked(pRegGov dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllI_masked(pReg dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -5471,1 +5471,1 @@\n-instruct vmaskAll_immL(pRegGov dst, immL src, rFlagsReg cr) %{\n+instruct vmaskAll_immL(pReg dst, immL src, rFlagsReg cr) %{\n@@ -5489,1 +5489,1 @@\n-instruct vmaskAllL(pRegGov dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllL(pReg dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n@@ -5505,1 +5505,1 @@\n-instruct vmaskAllL_masked(pRegGov dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllL_masked(pReg dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -5522,1 +5522,1 @@\n-instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+instruct vmask_gen_I(pReg pd, iRegIorL2I src, rFlagsReg cr) %{\n@@ -5534,1 +5534,1 @@\n-instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+instruct vmask_gen_L(pReg pd, iRegL src, rFlagsReg cr) %{\n@@ -5546,1 +5546,1 @@\n-instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+instruct vmask_gen_imm(pReg pd, immL con, rFlagsReg cr) %{\n@@ -5840,1 +5840,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n@@ -5874,1 +5874,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -3096,1 +3096,1 @@\n-instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+instruct vloadmaskB_sve(pReg dst, vReg src, rFlagsReg cr) %{\n@@ -3108,1 +3108,1 @@\n-instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_sve(pReg dst, vReg src, vReg tmp, rFlagsReg cr) %{\n@@ -3122,1 +3122,1 @@\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+instruct vloadmaskB_masked(pReg dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n@@ -3134,1 +3134,1 @@\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_masked(pReg dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -3188,1 +3188,1 @@\n-instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+instruct vstoremaskB_sve(vReg dst, pReg src, immI_1 size) %{\n@@ -3198,1 +3198,1 @@\n-instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+instruct vstoremask_narrow_sve(vReg dst, pReg src, immI_gt_1 size, vReg tmp) %{\n@@ -3215,1 +3215,1 @@\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadV(pReg dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n@@ -3237,1 +3237,1 @@\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+instruct vloadmask_loadV_masked(pReg dst, indirect mem, pRegGov pg,\n@@ -3258,1 +3258,1 @@\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadVMasked(pReg dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -3285,1 +3285,1 @@\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+instruct vloadmask_loadVMasked_masked(pReg dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n@@ -3315,1 +3315,1 @@\n-instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+instruct storeV_vstoremask(indirect mem, pReg src, immI_gt_1 esize, vReg tmp) %{\n@@ -3336,1 +3336,1 @@\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+instruct storeV_vstoremask_masked(indirect mem, pReg src, immI_gt_1 esize,\n@@ -3358,1 +3358,1 @@\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+instruct storeVMasked_vstoremask(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n@@ -3384,1 +3384,1 @@\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize,\n@@ -3416,1 +3416,1 @@\n-instruct vmask_$1(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_$1(pReg pd, pReg pn, pReg pm) %{\n@@ -3429,1 +3429,1 @@\n-instruct vmask_and_not$1(pRegGov pd, pRegGov pn, pRegGov pm, imm$1_M1 m1) %{\n+instruct vmask_and_not$1(pReg pd, pReg pn, pReg pm, imm$1_M1 m1) %{\n@@ -3464,1 +3464,1 @@\n-instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+instruct vmaskcmp_sve(pReg dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n@@ -3479,1 +3479,1 @@\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+instruct vmaskcmp_masked(pReg dst, vReg src1, vReg src2, immI cond,\n@@ -3506,1 +3506,1 @@\n-instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+instruct vmaskcast_same_esize_sve(pReg dst_src) %{\n@@ -3516,1 +3516,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend(pReg dst, pReg src) %{\n@@ -3533,1 +3533,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow(pReg dst, pReg src) %{\n@@ -3552,1 +3552,1 @@\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+instruct vmask_reinterpret_same_esize(pReg dst_src) %{\n@@ -3563,1 +3563,1 @@\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+instruct vmask_reinterpret_diff_esize(pReg dst, pReg src, vReg tmp, rFlagsReg cr) %{\n@@ -3709,1 +3709,1 @@\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pReg pg, pReg ptmp) %{\n@@ -3821,1 +3821,1 @@\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+instruct vmask_fromlong(pReg dst, iRegL src, vReg tmp1, vReg tmp2) %{\n@@ -3841,1 +3841,1 @@\n-instruct vmaskAll_imm$1(pRegGov dst, imm$1 src, rFlagsReg cr) %{\n+instruct vmaskAll_imm$1(pReg dst, imm$1 src, rFlagsReg cr) %{\n@@ -3862,1 +3862,1 @@\n-instruct vmaskAll$1(pRegGov dst, $2 src, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAll$1(pReg dst, $2 src, vReg tmp, rFlagsReg cr) %{\n@@ -3881,1 +3881,1 @@\n-instruct vmaskAll$1_masked(pRegGov dst, $2 src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAll$1_masked(pReg dst, $2 src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -3905,1 +3905,1 @@\n-instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+instruct vmask_gen_I(pReg pd, iRegIorL2I src, rFlagsReg cr) %{\n@@ -3917,1 +3917,1 @@\n-instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+instruct vmask_gen_L(pReg pd, iRegL src, rFlagsReg cr) %{\n@@ -3929,1 +3929,1 @@\n-instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+instruct vmask_gen_imm(pReg pd, immL con, rFlagsReg cr) %{\n@@ -4212,1 +4212,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n@@ -4246,1 +4246,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2397,1 +2397,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2399,1 +2399,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -2434,1 +2434,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2436,1 +2436,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -2940,1 +2940,1 @@\n-    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n+    for (int i = 0; i < PRegister::number_of_registers; i++) {\n@@ -2949,1 +2949,1 @@\n-    for (int i = PRegister::number_of_saved_registers - 1; i >= 0; i--) {\n+    for (int i = PRegister::number_of_registers - 1; i >= 0; i--) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -299,5 +299,0 @@\n-    \/\/ p0-p7 are governing predicates for load\/store and arithmetic, but p7 is\n-    \/\/ preserved as an all-true predicate in OpenJDK. And since we don't support\n-    \/\/ non-governing predicate registers allocation for non-temp register, the\n-    \/\/ predicate registers to be saved are p0-p6.\n-    number_of_saved_registers = number_of_governing_registers - 1,\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,5 +164,2 @@\n-    \/\/ The number of total predicate bytes is unlikely to be a multiple\n-    \/\/ of 16 bytes so we manually align it up.\n-    return align_up(Matcher::scalable_predicate_reg_slots() *\n-                    VMRegImpl::stack_slot_size *\n-                    PRegister::number_of_saved_registers, 16);\n+    return (Matcher::scalable_vector_reg_size(T_BYTE) >> LogBitsPerByte) *\n+           PRegister::number_of_registers;\n@@ -254,8 +251,0 @@\n-  if (_save_vectors && use_sve) {\n-    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n-      PRegister r = as_PRegister(i);\n-      int sp_offset = sve_predicate_size_in_slots * i;\n-      oop_map->set_callee_saved(VMRegImpl::stack2reg(sp_offset), r->as_VMReg());\n-    }\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -643,2 +643,2 @@\n-  INSN(_beq, 0b1100011, 0b000);\n-  INSN(_bne, 0b1100011, 0b001);\n+  INSN(beq, 0b1100011, 0b000);\n+  INSN(bne, 0b1100011, 0b001);\n@@ -861,1 +861,1 @@\n-  INSN(_jal, 0b1101111);\n+  INSN(jal, 0b1101111);\n@@ -2082,7 +2082,6 @@\n-\/\/ 1. When UseRVC is enabled, 32-bit instructions under 'CompressibleRegion's will be\n-\/\/    transformed to 16-bit instructions if compressible.\n-\/\/ 2. RVC instructions in Assembler always begin with 'c_' prefix, as 'c_li',\n-\/\/    but most of time we have no need to explicitly use these instructions.\n-\/\/ 3. 'CompressibleRegion' is introduced to hint instructions in this Region's RTTI range\n-\/\/    are qualified to be compressed with their 2-byte versions.\n-\/\/    An example:\n+\/\/ 1. Assembler functions encoding 16-bit compressed instructions always begin with a 'c_'\n+\/\/    prefix, such as 'c_add'. Correspondingly, assembler functions encoding normal 32-bit\n+\/\/    instructions with begin with a '_' prefix, such as \"_add\". Most of time users have no\n+\/\/    need to explicitly emit these compressed instructions. Instead, they still use unified\n+\/\/    wrappers such as 'add' which do the compressing work through 'c_add' depending on the\n+\/\/    the operands of the instruction and availability of the RVC hardware extension.\n@@ -2090,2 +2089,3 @@\n-\/\/      CompressibleRegion cr(_masm);\n-\/\/      __ andr(...);      \/\/ this instruction could change to c.and if able to\n+\/\/ 2. 'CompressibleRegion' and 'IncompressibleRegion' are introduced to mark assembler scopes\n+\/\/     within which instructions are qualified or unqualified to be compressed into their 16-bit\n+\/\/     versions. An example:\n@@ -2093,2 +2093,10 @@\n-\/\/ 4. Using -XX:PrintAssemblyOptions=no-aliases could distinguish RVC instructions from\n-\/\/    normal ones.\n+\/\/      CompressibleRegion cr(_masm);\n+\/\/      __ add(...);       \/\/ this instruction will be compressed into 'c.and' when possible\n+\/\/      {\n+\/\/         IncompressibleRegion ir(_masm);\n+\/\/         __ add(...);    \/\/ this instruction will not be compressed\n+\/\/         {\n+\/\/            CompressibleRegion cr(_masm);\n+\/\/            __ add(...); \/\/ this instruction will be compressed into 'c.and' when possible\n+\/\/         }\n+\/\/      }\n@@ -2096,0 +2104,2 @@\n+\/\/ 3. When printing JIT assembly code, using -XX:PrintAssemblyOptions=no-aliases could help\n+\/\/    distinguish compressed 16-bit instructions from normal 32-bit ones.\n@@ -2104,2 +2114,2 @@\n-  \/\/ a compressible region\n-  class CompressibleRegion : public StackObj {\n+  \/\/ an abstract compressible region\n+  class AbstractCompressibleRegion : public StackObj {\n@@ -2109,2 +2119,2 @@\n-  public:\n-    CompressibleRegion(Assembler *_masm)\n+  protected:\n+    AbstractCompressibleRegion(Assembler *_masm)\n@@ -2112,1 +2122,6 @@\n-    , _saved_in_compressible_region(_masm->in_compressible_region()) {\n+    , _saved_in_compressible_region(_masm->in_compressible_region()) {}\n+  };\n+  \/\/ a compressible region\n+  class CompressibleRegion : public AbstractCompressibleRegion {\n+  public:\n+    CompressibleRegion(Assembler *_masm) : AbstractCompressibleRegion(_masm) {\n@@ -2119,0 +2134,10 @@\n+  \/\/ an incompressible region\n+  class IncompressibleRegion : public AbstractCompressibleRegion {\n+  public:\n+    IncompressibleRegion(Assembler *_masm) : AbstractCompressibleRegion(_masm) {\n+      _masm->set_in_compressible_region(false);\n+    }\n+    ~IncompressibleRegion() {\n+      _masm->set_in_compressible_region(_saved_in_compressible_region);\n+    }\n+  };\n@@ -2819,20 +2844,0 @@\n-\/\/ --------------------------\n-\/\/ Conditional branch instructions\n-\/\/ --------------------------\n-#define INSN(NAME, C_NAME, NORMAL_NAME)                                                      \\\n-  void NAME(Register Rs1, Register Rs2, const int64_t offset) {                              \\\n-    \/* beq\/bne -> c.beqz\/c.bnez *\/                                                           \\\n-    if (do_compress() &&                                                                     \\\n-        (offset != 0 && Rs2 == x0 && Rs1->is_compressed_valid() &&                           \\\n-        is_imm_in_range(offset, 8, 1))) {                                                    \\\n-      C_NAME(Rs1, offset);                                                                   \\\n-      return;                                                                                \\\n-    }                                                                                        \\\n-    NORMAL_NAME(Rs1, Rs2, offset);                                                           \\\n-  }\n-\n-  INSN(beq, c_beqz, _beq);\n-  INSN(bne, c_bnez, _bne);\n-\n-#undef INSN\n-\n@@ -2841,15 +2846,0 @@\n-\/\/ --------------------------\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, const int32_t offset) {                                             \\\n-    \/* jal -> c.j *\/                                                                         \\\n-    if (do_compress() && offset != 0 && Rd == x0 && is_imm_in_range(offset, 11, 1)) {        \\\n-      c_j(offset);                                                                           \\\n-      return;                                                                                \\\n-    }                                                                                        \\\n-    _jal(Rd, offset);                                                                        \\\n-  }\n-\n-  INSN(jal);\n-\n-#undef INSN\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":44,"deletions":54,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -326,0 +326,1 @@\n+  IncompressibleRegion ir(this);  \/\/ keep the nop as 4 bytes for patching.\n@@ -327,1 +328,1 @@\n-  nop();\n+  nop();  \/\/ 4 bytes\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -246,0 +246,2 @@\n+  IncompressibleRegion ir(this);  \/\/ Fixed length: see C2_MacroAssembler::entry_barrier_stub_size()\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -196,0 +196,2 @@\n+  Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see entry_barrier_offset()\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"jvmci\/jvmci.hpp\"\n+#include \"jvmci\/jvmciCodeInstaller.hpp\"\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#include \"jvmci\/jvmciCompilerToVM.hpp\"\n+#include \"jvmci\/jvmciJavaClasses.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"vmreg_riscv.inline.hpp\"\n+\n+jint CodeInstaller::pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCI_TRAPS) {\n+  address pc = (address) inst;\n+  if (inst->is_call()) {\n+    return pc_offset + NativeCall::instruction_size;\n+  } else if (inst->is_jump()) {\n+    return pc_offset + NativeJump::instruction_size;\n+  } else if (inst->is_movptr()) {\n+    return pc_offset + NativeMovConstReg::movptr_instruction_size;\n+  } else {\n+    JVMCI_ERROR_0(\"unsupported type of instruction for call site\");\n+  }\n+}\n+\n+void CodeInstaller::pd_patch_OopConstant(int pc_offset, Handle& obj, bool compressed, JVMCI_TRAPS) {\n+  address pc = _instructions->start() + pc_offset;\n+  jobject value = JNIHandles::make_local(obj());\n+  MacroAssembler::patch_oop(pc, cast_from_oop<address>(obj()));\n+  int oop_index = _oop_recorder->find_index(value);\n+  RelocationHolder rspec = oop_Relocation::spec(oop_index);\n+  _instructions->relocate(pc, rspec);\n+}\n+\n+void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS) {\n+  address pc = _instructions->start() + pc_offset;\n+  if (tag == PATCH_NARROW_KLASS) {\n+    narrowKlass narrowOop = record_narrow_metadata_reference(_instructions, pc, stream, tag, JVMCI_CHECK);\n+    MacroAssembler::pd_patch_instruction_size(pc, (address) (long) narrowOop);\n+    JVMCI_event_3(\"relocating (narrow metaspace constant) at \" PTR_FORMAT \"\/0x%x\", p2i(pc), narrowOop);\n+  } else {\n+    NativeMovConstReg* move = nativeMovConstReg_at(pc);\n+    void* reference = record_metadata_reference(_instructions, pc, stream, tag, JVMCI_CHECK);\n+    move->set_data((intptr_t) reference);\n+    JVMCI_event_3(\"relocating (metaspace constant) at \" PTR_FORMAT \"\/\" PTR_FORMAT, p2i(pc), p2i(reference));\n+  }\n+}\n+\n+void CodeInstaller::pd_patch_DataSectionReference(int pc_offset, int data_offset, JVMCI_TRAPS) {\n+  address pc = _instructions->start() + pc_offset;\n+  address dest = _constants->start() + data_offset;\n+  _instructions->relocate(pc, section_word_Relocation::spec((address) dest, CodeBuffer::SECT_CONSTS));\n+  JVMCI_event_3(\"relocating at \" PTR_FORMAT \" (+%d) with destination at %d\", p2i(pc), pc_offset, data_offset);\n+}\n+\n+void CodeInstaller::pd_relocate_ForeignCall(NativeInstruction* inst, jlong foreign_call_destination, JVMCI_TRAPS) {\n+  address pc = (address) inst;\n+  if (inst->is_jal()) {\n+    NativeCall* call = nativeCall_at(pc);\n+    call->set_destination((address) foreign_call_destination);\n+    _instructions->relocate(call->instruction_address(), runtime_call_Relocation::spec());\n+  } else if (inst->is_jump()) {\n+    NativeJump* jump = nativeJump_at(pc);\n+    jump->set_jump_destination((address) foreign_call_destination);\n+    _instructions->relocate(jump->instruction_address(), runtime_call_Relocation::spec());\n+  } else if (inst->is_movptr()) {\n+    NativeMovConstReg* movptr = nativeMovConstReg_at(pc);\n+    movptr->set_data((intptr_t) foreign_call_destination);\n+    _instructions->relocate(movptr->instruction_address(), runtime_call_Relocation::spec());\n+  } else {\n+    JVMCI_ERROR(\"unknown call or jump instruction at \" PTR_FORMAT, p2i(pc));\n+  }\n+  JVMCI_event_3(\"relocating (foreign call) at \" PTR_FORMAT, p2i(inst));\n+}\n+\n+void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &cbuf, methodHandle& method, jint pc_offset, JVMCI_TRAPS) {\n+  Unimplemented();\n+}\n+\n+void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {\n+  Unimplemented();\n+}\n+\n+\/\/ convert JVMCI register indices (as used in oop maps) to HotSpot registers\n+VMReg CodeInstaller::get_hotspot_reg(jint jvmci_reg, JVMCI_TRAPS) {\n+  if (jvmci_reg < Register::number_of_registers) {\n+    return as_Register(jvmci_reg)->as_VMReg();\n+  } else {\n+    jint floatRegisterNumber = jvmci_reg - Register::number_of_registers;\n+    if (floatRegisterNumber >= 0 && floatRegisterNumber < FloatRegister::number_of_registers) {\n+      return as_FloatRegister(floatRegisterNumber)->as_VMReg();\n+    }\n+    JVMCI_ERROR_NULL(\"invalid register number: %d\", jvmci_reg);\n+  }\n+}\n+\n+bool CodeInstaller::is_general_purpose_reg(VMReg hotspotRegister) {\n+  return !(hotspotRegister->is_FloatRegister() || hotspotRegister->is_VectorRegister());\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -244,0 +244,1 @@\n+    IncompressibleRegion ir(this);  \/\/ the label address will be patched back.\n@@ -552,0 +553,1 @@\n+  IncompressibleRegion ir(this);  \/\/ Fixed length: see CompiledStaticCall::to_interp_stub_size().\n@@ -754,0 +756,1 @@\n+  IncompressibleRegion ir(this);   \/\/ the label address may be patched back.\n@@ -2440,0 +2443,1 @@\n+  IncompressibleRegion ir(this);  \/\/ Fixed length: see MacroAssembler::far_branch_size()\n@@ -2458,0 +2462,1 @@\n+  IncompressibleRegion ir(this);  \/\/ Fixed length: see MacroAssembler::far_branch_size()\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -393,0 +393,1 @@\n+  Assembler::IncompressibleRegion ir(&a);  \/\/ Fixed length: see NativeGeneralJump::get_instruction_size()\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1321,2 +1321,5 @@\n-  MacroAssembler::assert_alignment(__ pc());\n-  __ nop();\n+  {\n+    Assembler::IncompressibleRegion ir(&_masm);  \/\/ keep the nop as 4 bytes for patching.\n+    MacroAssembler::assert_alignment(__ pc());\n+    __ nop();  \/\/ 4 bytes\n+  }\n@@ -1683,0 +1686,1 @@\n+  Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see BoxLockNode::size()\n@@ -2271,0 +2275,1 @@\n+    Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see ret_addr_offset\n@@ -2309,0 +2314,1 @@\n+    Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see ret_addr_offset\n@@ -2327,0 +2333,1 @@\n+    Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see ret_addr_offset\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciJavaClasses.hpp\"\n+#endif\n@@ -211,0 +214,3 @@\n+#if !INCLUDE_JVMCI\n+  assert(!_save_vectors, \"vectors are generated only by C2 and JVMCI\");\n+#endif\n@@ -496,0 +502,12 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    \/\/ check if this call should be routed towards a specific entry point\n+    __ ld(t0, Address(xthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));\n+    Label no_alternative_target;\n+    __ beqz(t0, no_alternative_target);\n+    __ mv(t1, t0);\n+    __ sd(zr, Address(xthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));\n+    __ bind(no_alternative_target);\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n@@ -941,2 +959,5 @@\n-    MacroAssembler::assert_alignment(__ pc());\n-    __ nop();\n+    {\n+      Assembler::IncompressibleRegion ir(masm);  \/\/ keep the nop as 4 bytes for patching.\n+      MacroAssembler::assert_alignment(__ pc());\n+      __ nop();  \/\/ 4 bytes\n+    }\n@@ -1093,2 +1114,5 @@\n-  MacroAssembler::assert_alignment(__ pc());\n-  __ nop();\n+  {\n+    Assembler::IncompressibleRegion ir(masm);  \/\/ keep the nop as 4 bytes for patching.\n+    MacroAssembler::assert_alignment(__ pc());\n+    __ nop();  \/\/ 4 bytes\n+  }\n@@ -1678,0 +1702,5 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    pad += 512; \/\/ Increase the buffer size when compiling for JVMCI\n+  }\n+#endif\n@@ -1729,0 +1758,6 @@\n+#if INCLUDE_JVMCI && !defined(COMPILER1)\n+  if (EnableJVMCI && UseJVMCICompiler) {\n+    \/\/ JVMCI does not use this kind of deoptimization\n+    __ should_not_reach_here();\n+  }\n+#endif\n@@ -1739,0 +1774,38 @@\n+#if INCLUDE_JVMCI\n+  Label after_fetch_unroll_info_call;\n+  int implicit_exception_uncommon_trap_offset = 0;\n+  int uncommon_trap_offset = 0;\n+\n+  if (EnableJVMCI) {\n+    implicit_exception_uncommon_trap_offset = __ pc() - start;\n+\n+    __ ld(ra, Address(xthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));\n+    __ sd(zr, Address(xthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));\n+\n+    uncommon_trap_offset = __ pc() - start;\n+\n+    \/\/ Save everything in sight.\n+    reg_saver.save_live_registers(masm, 0, &frame_size_in_words);\n+    \/\/ fetch_unroll_info needs to call last_java_frame()\n+    Label retaddr;\n+    __ set_last_Java_frame(sp, noreg, retaddr, t0);\n+\n+    __ lw(c_rarg1, Address(xthread, in_bytes(JavaThread::pending_deoptimization_offset())));\n+    __ mvw(t0, -1);\n+    __ sw(t0, Address(xthread, in_bytes(JavaThread::pending_deoptimization_offset())));\n+\n+    __ mvw(xcpool, (int32_t)Deoptimization::Unpack_reexecute);\n+    __ mv(c_rarg0, xthread);\n+    __ orrw(c_rarg2, zr, xcpool); \/\/ exec mode\n+    int32_t offset = 0;\n+    __ la_patchable(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)), offset);\n+    __ jalr(x1, t0, offset);\n+    __ bind(retaddr);\n+    oop_maps->add_gc_map( __ pc()-start, map->deep_copy());\n+\n+    __ reset_last_Java_frame(false);\n+\n+    __ j(after_fetch_unroll_info_call);\n+  } \/\/ EnableJVMCI\n+#endif \/\/ INCLUDE_JVMCI\n+\n@@ -1832,0 +1905,6 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    __ bind(after_fetch_unroll_info_call);\n+  }\n+#endif\n+\n@@ -1987,0 +2066,6 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    _deopt_blob->set_uncommon_trap_offset(uncommon_trap_offset);\n+    _deopt_blob->set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":89,"deletions":4,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -1702,1 +1702,0 @@\n-#if _MSC_VER >= 1900\n@@ -1711,23 +1710,0 @@\n-#else\n-  \/\/ Before Visual Studio 2015, vsnprintf is not C99 compliant, so use\n-  \/\/ _vsnprintf, whose behavior seems to be *mostly* consistent across\n-  \/\/ versions.  However, when len == 0, avoid _vsnprintf too, and just\n-  \/\/ go straight to _vscprintf.  The output is going to be truncated in\n-  \/\/ that case, except in the unusual case of empty output.  More\n-  \/\/ importantly, the documentation for various versions of Visual Studio\n-  \/\/ are inconsistent about the behavior of _vsnprintf when len == 0,\n-  \/\/ including it possibly being an error.\n-  int result = -1;\n-  if (len > 0) {\n-    result = _vsnprintf(buf, len, fmt, args);\n-    \/\/ If output (including NUL terminator) is truncated, the buffer\n-    \/\/ won't be NUL terminated.  Add the trailing NUL specified by C99.\n-    if ((result < 0) || ((size_t)result >= len)) {\n-      buf[len - 1] = '\\0';\n-    }\n-  }\n-  if (result < 0) {\n-    result = _vscprintf(fmt, args);\n-  }\n-  return result;\n-#endif \/\/ _MSC_VER dispatch\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,4 +49,0 @@\n-#if _MSC_VER < 1900\n-#define snprintf _snprintf\n-#endif\n-\n","filename":"src\/hotspot\/share\/adlc\/adlc.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  _output = new(ResourceObj::C_HEAP, mtCompiler) fileStream(file_name, \"at\");\n+  _output = new(mtCompiler) fileStream(file_name, \"at\");\n","filename":"src\/hotspot\/share\/c1\/c1_CFGPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    _classlist_file = new(ResourceObj::C_HEAP, mtInternal)\n+    _classlist_file = new(mtInternal)\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,4 @@\n-    \/\/ is being redefined or retransformed. We use jvmti_thread_state()\n+    \/\/ is being retransformed. If class file load hook provides\n+    \/\/ modified class data during class loading or redefinition,\n+    \/\/ new cached class file buffer should be allocated.\n+    \/\/ We use jvmti_thread_state()\n@@ -135,2 +138,1 @@\n-\n-      if (k != NULL) {\n+      if (k != NULL && state->get_class_load_kind() == jvmti_class_load_kind_retransform) {\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1963,1 +1963,1 @@\n-        CompileLog* log = new(ResourceObj::C_HEAP, mtCompiler) CompileLog(file_name, fp, thread_id);\n+        CompileLog* log = new(mtCompiler) CompileLog(file_name, fp, thread_id);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  initialize(new(ResourceObj::C_HEAP, mtCompiler) fileStream(fp, true));\n+  initialize(new(mtCompiler) fileStream(fp, true));\n","filename":"src\/hotspot\/share\/compiler\/compileLog.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#ifndef ZERO\n@@ -75,0 +76,6 @@\n+#else\n+\/\/ Zero runs without compilers. Do not let this code to force\n+\/\/ the GC mode and default heap settings.\n+define_pd_global(bool, NeverActAsServerClassMachine, false);\n+define_pd_global(uint64_t,MaxRAM,                    128ULL*G);\n+#endif\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals_pd.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-  _lines = new (ResourceObj::C_HEAP, mtGC) stringStream();\n-  _temp = new (ResourceObj::C_HEAP, mtGC) stringStream();\n+  _lines = new (mtGC) stringStream();\n+  _temp = new (mtGC) stringStream();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-  _alloc_failure_waiters_lock(Mutex::safepoint-1, \"ShenandoahAllocFailureGC_lock\", true),\n-  _gc_waiters_lock(Mutex::safepoint-1, \"ShenandoahRequestedGC_lock\", true),\n+  _alloc_failure_waiters_lock(Mutex::safepoint-2, \"ShenandoahAllocFailureGC_lock\", true),\n+  _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -280,3 +280,1 @@\n-  if (periodMillis > 0) {\n-    JfrEventSetting::set_enabled(typed_event_id, true); \/\/ ensure sampling event is enabled\n-  }\n+  JfrEventSetting::set_enabled(typed_event_id, periodMillis > 0);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -302,2 +302,4 @@\n-    for (uint i = 0; i < _added_java; ++i) {\n-      _events[i].commit();\n+    if (EventExecutionSample::is_enabled()) {\n+      for (uint i = 0; i < _added_java; ++i) {\n+        _events[i].commit();\n+      }\n@@ -308,2 +310,4 @@\n-    for (uint i = 0; i < _added_native; ++i) {\n-      _events_native[i].commit();\n+    if (EventNativeMethodSample::is_enabled()) {\n+      for (uint i = 0; i < _added_native; ++i) {\n+        _events_native[i].commit();\n+      }\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+typedef JfrCheckpointManager::ConstBufferPtr ConstBufferPtr;\n@@ -80,2 +81,3 @@\n-  _global_mspace(NULL),\n-  _thread_local_mspace(NULL),\n+  _global_mspace(nullptr),\n+  _thread_local_mspace(nullptr),\n+  _virtual_thread_local_mspace(nullptr),\n@@ -94,2 +96,5 @@\n-static const size_t thread_local_buffer_prealloc_count = 32;\n-static const size_t thread_local_buffer_size = 4 * K;\n+static const size_t thread_local_buffer_prealloc_count = 16;\n+static const size_t thread_local_buffer_size = 256;\n+\n+static const size_t virtual_thread_local_buffer_prealloc_count = 0;\n+static const size_t virtual_thread_local_buffer_size = 4 * K;\n@@ -113,1 +118,1 @@\n-                                                                        JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n+                                                                        thread_local_buffer_prealloc_count,\n@@ -117,0 +122,8 @@\n+\n+  assert(_virtual_thread_local_mspace == NULL, \"invariant\");\n+  _virtual_thread_local_mspace = new JfrThreadLocalCheckpointMspace();\n+  if (_virtual_thread_local_mspace == NULL || !_virtual_thread_local_mspace->initialize(virtual_thread_local_buffer_size,\n+                                                                                        JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n+                                                                                        virtual_thread_local_buffer_prealloc_count)) {\n+    return false;\n+  }\n@@ -121,1 +134,1 @@\n-static void assert_lease(const BufferPtr buffer) {\n+static void assert_lease(ConstBufferPtr buffer) {\n@@ -127,1 +140,1 @@\n-static void assert_release(const BufferPtr buffer) {\n+static void assert_release(ConstBufferPtr buffer) {\n@@ -133,1 +146,1 @@\n-static void assert_retired(const BufferPtr buffer, Thread* thread) {\n+static void assert_retired(ConstBufferPtr buffer, Thread* thread) {\n@@ -145,1 +158,16 @@\n-BufferPtr JfrCheckpointManager::lease(Thread* thread, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n+static inline bool is_global(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_GLOBAL;\n+}\n+\n+static inline bool is_thread_local(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_THREADLOCAL;\n+}\n+\n+static inline bool is_virtual_thread_local(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_VIRTUAL_THREADLOCAL;\n+}\n+\n+BufferPtr JfrCheckpointManager::lease_global(Thread* thread, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n@@ -163,23 +191,9 @@\n-const u1 thread_local_context = 1;\n-\n-static bool is_thread_local(const JfrBuffer* buffer) {\n-  assert(buffer != NULL, \"invariant\");\n-  return buffer->context() == thread_local_context;\n-}\n-\n-static void retire(JfrBuffer* buffer) {\n-  DEBUG_ONLY(assert_release(buffer);)\n-  buffer->clear_lease();\n-  buffer->set_retired();\n-}\n-\n-\/*\n- * The buffer is effectively invalidated for the thread post-return,\n- * and the caller should take means to ensure that it is not referenced.\n- *\/\n-static void release(JfrBuffer* buffer) {\n-  DEBUG_ONLY(assert_release(buffer);)\n-  if (!is_thread_local(buffer)) {\n-    buffer->clear_lease();\n-    buffer->release();\n-  }\n+BufferPtr JfrCheckpointManager::lease_thread_local(Thread* thread, size_t size) {\n+  BufferPtr buffer = instance()._thread_local_mspace->acquire(size, thread);\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(buffer->free_size() >= size, \"invariant\");\n+  buffer->set_lease();\n+  DEBUG_ONLY(assert_lease(buffer);)\n+  buffer->set_context(JFR_THREADLOCAL);\n+  assert(is_thread_local(buffer), \"invariant\");\n+  return buffer;\n@@ -188,1 +202,1 @@\n-BufferPtr JfrCheckpointManager::get_thread_local(Thread* thread) {\n+BufferPtr JfrCheckpointManager::get_virtual_thread_local(Thread* thread) {\n@@ -194,1 +208,1 @@\n-void JfrCheckpointManager::set_thread_local(Thread* thread, BufferPtr buffer) {\n+void JfrCheckpointManager::set_virtual_thread_local(Thread* thread, BufferPtr buffer) {\n@@ -203,4 +217,3 @@\n-BufferPtr JfrCheckpointManager::acquire_thread_local(size_t size, Thread* thread) {\n-  assert(thread != NULL, \"invariant\");\n-  JfrBuffer* const buffer = instance()._thread_local_mspace->acquire(size, thread);\n-  assert(buffer != NULL, \"invariant\");\n+BufferPtr JfrCheckpointManager::new_virtual_thread_local(Thread* thread, size_t size) {\n+  BufferPtr buffer = instance()._virtual_thread_local_mspace->acquire(size, thread);\n+  assert(buffer != nullptr, \"invariant\");\n@@ -208,4 +221,3 @@\n-  buffer->set_context(thread_local_context);\n-  assert(is_thread_local(buffer), \"invariant\");\n-  buffer->set_lease();\n-  set_thread_local(thread, buffer);\n+  buffer->set_context(JFR_VIRTUAL_THREADLOCAL);\n+  assert(is_virtual_thread_local(buffer), \"invariant\");\n+  set_virtual_thread_local(thread, buffer);\n@@ -215,7 +227,4 @@\n-BufferPtr JfrCheckpointManager::lease_thread_local(Thread* thread, size_t size \/* 0 *\/) {\n-  JfrBuffer* buffer = get_thread_local(thread);\n-  if (buffer == NULL) {\n-    buffer = acquire_thread_local(size, thread);\n-  } else if (buffer->free_size() < size) {\n-    retire(buffer);\n-    buffer = acquire_thread_local(size, thread);\n+BufferPtr JfrCheckpointManager::acquire_virtual_thread_local(Thread* thread, size_t size \/* 0 *\/) {\n+  BufferPtr buffer = get_virtual_thread_local(thread);\n+  if (buffer == nullptr || buffer->free_size() < size) {\n+    buffer = new_virtual_thread_local(thread, size);\n@@ -223,1 +232,1 @@\n-  DEBUG_ONLY(assert_lease(buffer);)\n+  assert(buffer->acquired_by_self(), \"invariant\");\n@@ -225,1 +234,2 @@\n-  assert(get_thread_local(thread) == buffer, \"invariant\");\n+  assert(get_virtual_thread_local(thread) == buffer, \"invariant\");\n+  assert(is_virtual_thread_local(buffer), \"invariant\");\n@@ -229,1 +239,1 @@\n-BufferPtr JfrCheckpointManager::lease(BufferPtr old, Thread* thread, size_t size) {\n+BufferPtr JfrCheckpointManager::renew(ConstBufferPtr old, Thread* thread, size_t size, JfrCheckpointBufferKind kind \/* JFR_THREADLOCAL *\/) {\n@@ -231,2 +241,42 @@\n-  return is_thread_local(old) ? acquire_thread_local(size, thread) :\n-                                lease(thread, instance()._global_mspace->in_previous_epoch_list(old), size);\n+  assert(old->acquired_by_self(), \"invariant\");\n+  if (kind == JFR_GLOBAL) {\n+    return lease_global(thread, instance()._global_mspace->in_previous_epoch_list(old), size);\n+  }\n+  return kind == JFR_THREADLOCAL ? lease_thread_local(thread, size) : acquire_virtual_thread_local(thread, size);\n+}\n+\n+BufferPtr JfrCheckpointManager::acquire(Thread* thread, JfrCheckpointBufferKind kind \/* JFR_THREADLOCAL *\/, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n+  if (kind == JFR_GLOBAL) {\n+    return lease_global(thread, previous_epoch, size);\n+  }\n+  if (kind == JFR_THREADLOCAL) {\n+    return lease_thread_local(thread, size);\n+  }\n+  assert(kind == JFR_VIRTUAL_THREADLOCAL, \"invariant\");\n+  return acquire_virtual_thread_local(thread, size);\n+}\n+\n+static inline void retire(BufferPtr buffer) {\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(buffer->acquired_by_self(), \"invariant\");\n+  buffer->set_retired();\n+}\n+\n+\/*\n+ * The buffer is effectively invalidated for the thread post-return,\n+ * and the caller should take means to ensure that it is not referenced.\n+ *\/\n+static inline void release(BufferPtr buffer) {\n+  DEBUG_ONLY(assert_release(buffer);)\n+  assert(!is_virtual_thread_local(buffer), \"invariant\");\n+  if (is_global(buffer)) {\n+    buffer->release();\n+    return;\n+  }\n+  assert(is_thread_local(buffer), \"invariant\");\n+  retire(buffer);\n+}\n+\n+static inline JfrCheckpointBufferKind kind(ConstBufferPtr buffer) {\n+  assert(buffer != nullptr, \"invariant\");\n+  return static_cast<JfrCheckpointBufferKind>(buffer->context());\n@@ -237,1 +287,0 @@\n-  assert(old->lease(), \"invariant\");\n@@ -240,0 +289,1 @@\n+    assert(old->lease(), \"invariant\");\n@@ -245,1 +295,1 @@\n-  BufferPtr new_buffer = lease(old, thread, used + requested);\n+  BufferPtr new_buffer = renew(old, thread, used + requested, kind(old));\n@@ -375,1 +425,1 @@\n-class ThreadLocalCheckpointWriteOp {\n+class VirtualThreadLocalCheckpointWriteOp {\n@@ -384,1 +434,1 @@\n-  ThreadLocalCheckpointWriteOp(JfrChunkWriter& cw) : _cw(cw), _begin_offset(cw.current_offset()), _elements_offset(0), _processed(0), _elements(0) {\n+  VirtualThreadLocalCheckpointWriteOp(JfrChunkWriter& cw) : _cw(cw), _begin_offset(cw.current_offset()), _elements_offset(0), _processed(0), _elements(0) {\n@@ -399,1 +449,1 @@\n-  ~ThreadLocalCheckpointWriteOp() {\n+  ~VirtualThreadLocalCheckpointWriteOp() {\n@@ -420,2 +470,1 @@\n-typedef ThreadLocalCheckpointWriteOp<JfrCheckpointManager::Buffer> ThreadLocalCheckpointOperation;\n-typedef MutexedWriteOp<ThreadLocalCheckpointOperation> ThreadLocalWriteOperation;\n+typedef MutexedWriteOp<WriteOperation> MutexedWriteOperation;\n@@ -423,2 +472,3 @@\n-typedef ExclusiveOp<WriteOperation> GlobalWriteOperation;\n-typedef CompositeOperation<GlobalWriteOperation, ReleaseOperation> GlobalWriteReleaseOperation;\n+typedef CompositeOperation<MutexedWriteOperation, ReleaseOperation> WriteReleaseOperation;\n+typedef VirtualThreadLocalCheckpointWriteOp<JfrCheckpointManager::Buffer> VirtualThreadLocalCheckpointOperation;\n+typedef MutexedWriteOp<VirtualThreadLocalCheckpointOperation> VirtualThreadLocalWriteOperation;\n@@ -441,1 +491,2 @@\n-  GlobalWriteOperation gwo(wo);\n+  MutexedWriteOperation mwo(wo);\n+  _thread_local_mspace->iterate(mwo, true); \/\/ previous epoch list\n@@ -443,8 +494,8 @@\n-  ReleaseOperation ro(_global_mspace, _global_mspace->live_list(true));\n-  GlobalWriteReleaseOperation gwro(&gwo, &ro);\n-  process_live_list(gwro, _global_mspace, true); \/\/ previous epoch list\n-  \/\/ Do thread local list after global. Careful, the tlco destructor writes to chunk.\n-  ThreadLocalCheckpointOperation tlco(_chunkwriter);\n-  ThreadLocalWriteOperation tlwo(tlco);\n-  _thread_local_mspace->iterate(tlwo, true); \/\/ previous epoch list\n-  return wo.processed() + tlco.processed();\n+  ReleaseOperation ro(_global_mspace, _global_mspace->live_list(true)); \/\/ previous epoch list\n+  WriteReleaseOperation wro(&mwo, &ro);\n+  process_live_list(wro, _global_mspace, true); \/\/ previous epoch list\n+  \/\/ Do virtual thread local list last. Careful, the vtlco destructor writes to chunk.\n+  VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+  VirtualThreadLocalWriteOperation vtlwo(vtlco);\n+  _virtual_thread_local_mspace->iterate(vtlwo, true); \/\/ previous epoch list\n+  return wo.processed() + vtlco.processed();\n@@ -453,3 +504,2 @@\n-typedef DiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > ThreadLocalDiscardOperation;\n-typedef ExclusiveDiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > GlobalDiscardOperation;\n-typedef CompositeOperation<GlobalDiscardOperation, ReleaseOperation> DiscardReleaseOperation;\n+typedef DiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > DiscardOperation;\n+typedef CompositeOperation<DiscardOperation, ReleaseOperation> DiscardReleaseOperation;\n@@ -460,3 +510,3 @@\n-  ThreadLocalDiscardOperation tldo(mutexed); \/\/ mutexed discard mode\n-  _thread_local_mspace->iterate(tldo, true); \/\/ previous epoch list\n-  GlobalDiscardOperation gdo(mutexed); \/\/ mutexed discard mode\n+  DiscardOperation dop(mutexed); \/\/ mutexed discard mode\n+  _thread_local_mspace->iterate(dop, true); \/\/ previous epoch list\n+  _virtual_thread_local_mspace->iterate(dop, true); \/\/ previous epoch list\n@@ -464,1 +514,1 @@\n-  DiscardReleaseOperation dro(&gdo, &ro);\n+  DiscardReleaseOperation dro(&dop, &ro);\n@@ -467,1 +517,1 @@\n-  return tldo.elements() + gdo.elements();\n+  return dop.elements();\n@@ -564,0 +614,3 @@\n+    WriteOperation wo(_chunkwriter);\n+    MutexedWriteOperation mwo(wo);\n+    _thread_local_mspace->iterate(mwo); \/\/ current epoch list\n@@ -566,9 +619,5 @@\n-    WriteOperation wo(_chunkwriter);\n-    GlobalWriteOperation gwo(wo);\n-    ReleaseOperation ro(_global_mspace, _global_mspace->live_list()); \/\/ current epoch list\n-    GlobalWriteReleaseOperation gwro(&gwo, &ro);\n-    process_live_list(gwro, _global_mspace); \/\/ current epoch list\n-    \/\/ Do thread local list after global. Careful, the tlco destructor writes to chunk.\n-    ThreadLocalCheckpointOperation tlco(_chunkwriter);\n-    ThreadLocalWriteOperation tlwo(tlco);\n-    _thread_local_mspace->iterate(tlwo); \/\/ current epoch list\n+    process_live_list(mwo, _global_mspace); \/\/ current epoch list\n+    \/\/ Do virtual thread local list last. Careful, the vtlco destructor writes to chunk.\n+    VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+    VirtualThreadLocalWriteOperation vtlwo(vtlco);\n+    _virtual_thread_local_mspace->iterate(vtlwo); \/\/ current epoch list\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":138,"deletions":89,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  typedef const JfrCheckpointMspace::Node* ConstBufferPtr;\n@@ -63,0 +64,1 @@\n+  JfrThreadLocalCheckpointMspace* _virtual_thread_local_mspace;\n@@ -72,3 +74,4 @@\n-  static BufferPtr get_thread_local(Thread* thread);\n-  static void set_thread_local(Thread* thread, BufferPtr buffer);\n-  static BufferPtr acquire_thread_local(size_t size, Thread* thread);\n+  static BufferPtr get_virtual_thread_local(Thread* thread);\n+  static void set_virtual_thread_local(Thread* thread, BufferPtr buffer);\n+  static BufferPtr acquire_virtual_thread_local(Thread* thread, size_t size);\n+  static BufferPtr new_virtual_thread_local(Thread* thread, size_t size = 0);\n@@ -76,2 +79,0 @@\n-  static BufferPtr lease(Thread* thread, bool previous_epoch = false, size_t size = 0);\n-  static BufferPtr lease(BufferPtr old, Thread* thread, size_t size);\n@@ -79,0 +80,1 @@\n+  static BufferPtr lease_global(Thread* thread, bool previous_epoch = false, size_t size = 0);\n@@ -80,0 +82,2 @@\n+  static BufferPtr acquire(Thread* thread, JfrCheckpointBufferKind kind = JFR_THREADLOCAL, bool previous_epoch = false, size_t size = 0);\n+  static BufferPtr renew(ConstBufferPtr old, Thread* thread, size_t size, JfrCheckpointBufferKind kind = JFR_THREADLOCAL);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -34,2 +35,2 @@\n-JfrCheckpointWriter::JfrCheckpointWriter(JfrCheckpointType type \/* GENERIC *\/) :\n-  JfrCheckpointWriterBase(JfrCheckpointManager::lease(Thread::current()), Thread::current()),\n+JfrCheckpointWriter::JfrCheckpointWriter(bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, JfrCheckpointBufferKind kind \/* JFR_GLOBAL *\/) :\n+  JfrCheckpointWriterBase(JfrCheckpointManager::acquire(Thread::current(), kind), Thread::current()),\n@@ -40,1 +41,1 @@\n-  _header(true) {\n+  _header(header) {\n@@ -48,2 +49,2 @@\n-JfrCheckpointWriter::JfrCheckpointWriter(Thread* thread, bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, bool global_lease \/* true *\/) :\n-  JfrCheckpointWriterBase(global_lease ? JfrCheckpointManager::lease(thread) : JfrCheckpointManager::lease_thread_local(thread), thread),\n+JfrCheckpointWriter::JfrCheckpointWriter(Thread* thread, bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, JfrCheckpointBufferKind kind \/* JFR_GLOBAL *\/) :\n+  JfrCheckpointWriterBase(JfrCheckpointManager::acquire(thread, kind), thread),\n@@ -63,1 +64,1 @@\n-  JfrCheckpointWriterBase(JfrCheckpointManager::lease(thread, previous_epoch), thread),\n+  JfrCheckpointWriterBase(JfrCheckpointManager::lease_global(thread, previous_epoch), thread),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -73,3 +73,3 @@\n- public:\n-  JfrCheckpointWriter(JfrCheckpointType type = GENERIC);\n-  JfrCheckpointWriter(Thread* thread, bool header = true, JfrCheckpointType mode = GENERIC, bool global_lease = true);\n+public:\n+  JfrCheckpointWriter(bool header = true, JfrCheckpointType mode = GENERIC, JfrCheckpointBufferKind kind = JFR_GLOBAL);\n+  JfrCheckpointWriter(Thread* thread, bool header = true, JfrCheckpointType mode = GENERIC, JfrCheckpointBufferKind kind = JFR_GLOBAL);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -107,1 +108,1 @@\n-  JfrCheckpointWriter writer(jt, true, THREADS, false); \/\/ Thread local lease for blob creation.\n+  JfrCheckpointWriter writer(jt, true, THREADS, JFR_THREADLOCAL); \/\/ Thread local lease for blob creation.\n@@ -122,1 +123,1 @@\n-  JfrCheckpointWriter writer(current, true, THREADS, !is_vthread); \/\/ Virtual Threads use thread local lease.\n+  JfrCheckpointWriter writer(current, true, THREADS, is_vthread ? JFR_VIRTUAL_THREADLOCAL : JFR_THREADLOCAL);\n@@ -205,1 +206,1 @@\n-    JfrCheckpointWriter writer(STATICS);\n+    JfrCheckpointWriter writer(Thread::current(), true, STATICS);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeManager.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  bool _started;\n@@ -73,1 +72,1 @@\n-                                          _started(false), _untimed(timing == UNTIMED),\n+                                          _untimed(timing == UNTIMED),\n@@ -79,5 +78,2 @@\n-    if (T::is_enabled() && JfrThreadLocal::is_included(Thread::current())) {\n-      _started = true;\n-      if (TIMED == timing && !T::isInstant) {\n-        set_starttime(JfrTicks::now());\n-      }\n+    if (!T::isInstant && !_untimed && is_enabled()) {\n+      set_starttime(JfrTicks::now());\n@@ -149,2 +145,2 @@\n-  bool is_started() const {\n-    return _started;\n+  bool is_started() {\n+    return is_instant() || _start_time != 0 || _untimed;\n@@ -154,1 +150,1 @@\n-    if (!_started) {\n+    if (!is_enabled()) {\n@@ -160,3 +156,0 @@\n-    if (_evaluated) {\n-      return _should_commit;\n-    }\n@@ -170,1 +163,7 @@\n-    return _started && (_evaluated ? _should_commit : evaluate());\n+    if (_evaluated) {\n+      return _should_commit;\n+    }\n+    if (!is_enabled()) {\n+      return false;\n+    }\n+    return evaluate() && JfrThreadLocal::is_included(Thread::current());\n@@ -174,1 +173,0 @@\n-    assert(_started, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEvent.hpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-bool JfrBuffer::initialize(size_t header_size, size_t size) {\n+void JfrBuffer::initialize(size_t header_size, size_t size) {\n@@ -51,1 +51,0 @@\n-  return true;\n@@ -54,1 +53,1 @@\n-void JfrBuffer::reinitialize(bool exclusion \/* false *\/) {\n+void JfrBuffer::reinitialize() {\n@@ -176,2 +175,1 @@\n-  LEASE = 4,\n-  EXCLUDED = 8\n+  LEASE = 4\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-  bool initialize(size_t header_size, size_t size);\n-  void reinitialize(bool exclusion = false);\n+  void initialize(size_t header_size, size_t size);\n+  void reinitialize();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,4 +221,1 @@\n-  if (!node->initialize(sizeof(Node), aligned_size_bytes)) {\n-    JfrCHeapObj::free(node, aligned_size_bytes + sizeof(Node));\n-    return NULL;\n-  }\n+  node->initialize(sizeof(Node), aligned_size_bytes);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrMemorySpace.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,6 @@\n+enum JfrCheckpointBufferKind {\n+  JFR_GLOBAL,\n+  JFR_THREADLOCAL,\n+  JFR_VIRTUAL_THREADLOCAL\n+};\n+\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTypes.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    _jni_config_file = new(ResourceObj::C_HEAP, mtJVMCI) fileStream(JVMCILibDumpJNIConfig);\n+    _jni_config_file = new(mtJVMCI) fileStream(JVMCILibDumpJNIConfig);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,1 +177,55 @@\n-template <MEMFLAGS F> class CHeapObj {\n+class CHeapObjBase {\n+ public:\n+  ALWAYSINLINE void* operator new(size_t size, MEMFLAGS f) throw() {\n+    return AllocateHeap(size, f);\n+  }\n+\n+  ALWAYSINLINE void* operator new(size_t size,\n+                                  MEMFLAGS f,\n+                                  const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack);\n+  }\n+\n+  ALWAYSINLINE void* operator new(size_t size,\n+                                  MEMFLAGS f,\n+                                  const std::nothrow_t&,\n+                                  const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  ALWAYSINLINE void* operator new(size_t size,\n+                                  MEMFLAGS f,\n+                                  const std::nothrow_t&) throw() {\n+    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size, MEMFLAGS f) throw() {\n+    return AllocateHeap(size, f);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size,\n+                                    MEMFLAGS f,\n+                                    const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size,\n+                                    MEMFLAGS f,\n+                                    const std::nothrow_t&,\n+                                    const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size,\n+                                    MEMFLAGS f,\n+                                    const std::nothrow_t&) throw() {\n+    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  void operator delete(void* p)     { FreeHeap(p); }\n+  void operator delete [] (void* p) { FreeHeap(p); }\n+};\n+\n+\/\/ Uses the implicitly static new and delete operators of CHeapObjBase\n+template<MEMFLAGS F>\n+class CHeapObj {\n@@ -180,1 +234,1 @@\n-    return (void*)AllocateHeap(size, F);\n+    return CHeapObjBase::operator new(size, F);\n@@ -185,1 +239,1 @@\n-    return (void*)AllocateHeap(size, F, stack);\n+    return CHeapObjBase::operator new(size, F, stack);\n@@ -188,1 +242,1 @@\n-  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&,\n+  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t& nt,\n@@ -190,1 +244,1 @@\n-    return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);\n+    return CHeapObjBase::operator new(size, F, nt, stack);\n@@ -193,2 +247,2 @@\n-  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&) throw() {\n-    return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);\n+  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t& nt) throw() {\n+    return CHeapObjBase::operator new(size, F, nt);\n@@ -198,1 +252,1 @@\n-    return (void*)AllocateHeap(size, F);\n+    return CHeapObjBase::operator new[](size, F);\n@@ -202,2 +256,2 @@\n-                                  const NativeCallStack& stack) throw() {\n-    return (void*)AllocateHeap(size, F, stack);\n+                                    const NativeCallStack& stack) throw() {\n+    return CHeapObjBase::operator new[](size, F, stack);\n@@ -206,1 +260,1 @@\n-  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&,\n+  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t& nt,\n@@ -208,1 +262,5 @@\n-    return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);\n+    return CHeapObjBase::operator new[](size, F, nt, stack);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t& nt) throw() {\n+    return CHeapObjBase::operator new[](size, F, nt);\n@@ -211,2 +269,2 @@\n-  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&) throw() {\n-    return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);\n+  void operator delete(void* p)     {\n+    CHeapObjBase::operator delete(p);\n@@ -215,2 +273,3 @@\n-  void  operator delete(void* p)     { FreeHeap(p); }\n-  void  operator delete [] (void* p) { FreeHeap(p); }\n+  void operator delete [] (void* p) {\n+    CHeapObjBase::operator delete[](p);\n+  }\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":75,"deletions":16,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -640,1 +641,1 @@\n-                  _print_inlining_stream(new stringStream()),\n+                  _print_inlining_stream(new (mtCompiler) stringStream()),\n@@ -913,1 +914,1 @@\n-    _print_inlining_stream(new stringStream()),\n+    _print_inlining_stream(new (mtCompiler) stringStream()),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1061,0 +1061,4 @@\n+  ~Compile() {\n+    delete _print_inlining_stream;\n+  };\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-  _xml = new (ResourceObj::C_HEAP, mtCompiler) xmlStream(_output);\n+  _xml = new (mtCompiler) xmlStream(_output);\n@@ -734,1 +734,1 @@\n-  GrowableArray<Node *> nodeStack(Thread::current()->resource_area(), 0, 0, NULL);\n+  GrowableArray<Node *> nodeStack(Thread::current()->resource_area(), 0, 0, nullptr);\n@@ -736,2 +736,1 @@\n-  visited.test_set(start->_idx);\n-  if (C->cfg() != NULL) {\n+  if (C->cfg() != nullptr) {\n@@ -748,1 +747,5 @@\n-  while(nodeStack.length() > 0) {\n+  while (nodeStack.length() > 0) {\n+    Node* n = nodeStack.pop();\n+    if (visited.test_set(n->_idx)) {\n+      continue;\n+    }\n@@ -750,1 +753,0 @@\n-    Node *n = nodeStack.pop();\n@@ -755,4 +757,1 @@\n-        Node* p = n->out(i);\n-        if (!visited.test_set(p->_idx)) {\n-          nodeStack.push(p);\n-        }\n+        nodeStack.push(n->out(i));\n@@ -762,5 +761,3 @@\n-    for ( uint i = 0; i < n->len(); i++ ) {\n-      if ( n->in(i) ) {\n-        if (!visited.test_set(n->in(i)->_idx)) {\n-          nodeStack.push(n->in(i));\n-        }\n+    for (uint i = 0; i < n->len(); i++) {\n+      if (n->in(i) != nullptr) {\n+        nodeStack.push(n->in(i));\n@@ -854,1 +851,1 @@\n-    _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(st.as_string(), \"w\");\n+    _output = new (mtCompiler) fileStream(st.as_string(), \"w\");\n@@ -856,1 +853,1 @@\n-    _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(file_name, append ? \"a\" : \"w\");\n+    _output = new (mtCompiler) fileStream(file_name, append ? \"a\" : \"w\");\n@@ -865,1 +862,1 @@\n-  _network_stream = new (ResourceObj::C_HEAP, mtCompiler) networkStream();\n+  _network_stream = new (mtCompiler) networkStream();\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -861,1 +862,1 @@\n-    predString = new stringStream();\n+    predString = new (mtCompiler) stringStream();\n@@ -986,1 +987,1 @@\n-    predString->~stringStream();\n+    delete predString;\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4332,11 +4332,3 @@\n-  \/\/ The class file bytes from before any retransformable agents mucked\n-  \/\/ with them was cached on the scratch class, move to the_class.\n-  \/\/ Note: we still want to do this if nothing needed caching since it\n-  \/\/ should get cleared in the_class too.\n-  if (the_class->get_cached_class_file() == 0) {\n-    \/\/ the_class doesn't have a cache yet so copy it\n-    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n-  }\n-  else if (scratch_class->get_cached_class_file() !=\n-           the_class->get_cached_class_file()) {\n-    \/\/ The same class can be present twice in the scratch classes list or there\n+  if (scratch_class->get_cached_class_file() != the_class->get_cached_class_file()) {\n+    \/\/ 1. the_class doesn't have a cache yet, scratch_class does have a cache.\n+    \/\/ 2. The same class can be present twice in the scratch classes list or there\n@@ -4344,2 +4336,8 @@\n-    \/\/ In such cases we have to deallocate scratch_class cached_class_file.\n-    os::free(scratch_class->get_cached_class_file());\n+    \/\/ the_class and scratch_class have the same cached bytes, but different buffers.\n+    \/\/ In such cases we need to deallocate one of the buffers.\n+    \/\/ 3. RedefineClasses and the_class has cached bytes from a previous transformation.\n+    \/\/ In the case we need to use class bytes from scratch_class.\n+    if (the_class->get_cached_class_file() != nullptr) {\n+      os::free(the_class->get_cached_class_file());\n+    }\n+    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -358,18 +358,0 @@\n-void* NativeLookup::dll_load(const methodHandle& method) {\n-  if (method->has_native_function()) {\n-\n-    address current_entry = method->native_function();\n-\n-    char dll_name[JVM_MAXPATHLEN];\n-    dll_name[0] = '\\0';\n-    int offset;\n-    bool ret = os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &offset);\n-    if (ret && dll_name[0] != '\\0') {\n-      char ebuf[32];\n-      return os::dll_load(dll_name, ebuf, sizeof(ebuf));\n-    }\n-  }\n-\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  static void* dll_load(const methodHandle& method);\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,5 +206,1 @@\n-      #if _MSC_VER == 1800\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 12.0 (VS2013)\"\n-      #elif _MSC_VER == 1900\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 14.0 (VS2015)\"\n-      #elif _MSC_VER == 1911\n+      #if _MSC_VER == 1911\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3155,6 +3155,0 @@\n-\n-  \/\/ Zero runs without compilers. Do not let compiler selection code\n-  \/\/ to force it into Serial GC, let the GC ergonomics decide.\n-  if (FLAG_IS_DEFAULT(NeverActAsServerClassMachine)) {\n-    FLAG_SET_ERGO(NeverActAsServerClassMachine, false);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-    fs = new (ResourceObj::C_HEAP, mtInternal) fileStream(path);\n+    fs = new (mtInternal) fileStream(path);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -671,1 +671,1 @@\n-  fileStream* file = new(ResourceObj::C_HEAP, mtInternal) fileStream(try_name);\n+  fileStream* file = new (mtInternal) fileStream(try_name);\n@@ -689,1 +689,1 @@\n-  file = new(ResourceObj::C_HEAP, mtInternal) fileStream(try_name);\n+  file = new (mtInternal) fileStream(try_name);\n@@ -706,1 +706,1 @@\n-    _outer_xmlStream = new(ResourceObj::C_HEAP, mtInternal) xmlStream(file);\n+    _outer_xmlStream = new(mtInternal) xmlStream(file);\n@@ -948,1 +948,1 @@\n-    defaultStream::instance = new(ResourceObj::C_HEAP, mtInternal) defaultStream();\n+    defaultStream::instance = new(mtInternal) defaultStream();\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-class outputStream : public ResourceObj {\n+class outputStream : public CHeapObjBase {\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,8 @@\n-        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+        try {\n+            cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+        } catch (Throwable t) {\n+            \/\/ Prevent leak if the Deallocator or Cleaner fail for any reason\n+            UNSAFE.freeMemory(base);\n+            Bits.unreserveMemory(size, cap);\n+            throw t;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -531,0 +531,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -546,0 +550,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -562,0 +570,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -577,0 +589,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -596,0 +612,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -616,0 +636,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/DatagramChannel.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -375,0 +375,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -386,0 +390,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -397,0 +405,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -415,0 +427,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -432,0 +448,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -449,0 +469,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -78,0 +82,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SeekableByteChannel.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,0 +606,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -612,0 +615,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -619,0 +625,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -627,0 +636,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -633,0 +645,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -640,0 +655,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SocketChannel.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -313,0 +313,2 @@\n+     *\n+     * @throws  ClosedChannelException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelectableChannel.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,2 +156,2 @@\n-     * If (count == 0) this throws a NumberFormatException, which\n-     * mimics Long.parseLong().\n+     * If (count == 0) this returns 0.0,\n+     * unlike Double.parseDouble(\"\") which throws NumberFormatException.\n@@ -174,1 +174,2 @@\n-     * If (count == 0) this returns 0, unlike Long.parseLong().\n+     * If (count == 0) this returns 0,\n+     * unlike Long.parseLong(\"\") which throws NumberFormatException.\n@@ -198,0 +199,5 @@\n+    \/**\n+     * Utility routine to get the value of the digit list.\n+     * If (count == 0) this does not throw a NumberFormatException,\n+     * unlike BigDecimal(\"\").\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,4 @@\n-                assert (n - i >= 2);\n+                if (n - i < 2) {\n+                    throw new IllegalArgumentException(\"Malformed escape pair: \" + s);\n+                }\n+\n@@ -203,2 +206,2 @@\n-                } catch (NumberFormatException e) {\n-                    throw new IllegalArgumentException();\n+                } catch (NumberFormatException | IndexOutOfBoundsException e) {\n+                    throw new IllegalArgumentException(\"Malformed escape pair: \" + s);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/ParseUtil.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.net.MalformedURLException;\n@@ -61,1 +62,9 @@\n-        return new FtpURLConnection(u, p);\n+        FtpURLConnection connection = null;\n+        try {\n+            connection = new FtpURLConnection(u, p);\n+        } catch (IllegalArgumentException e) {\n+            var mfue = new MalformedURLException(e.getMessage());\n+            mfue.initCause(e);\n+            throw mfue;\n+        }\n+        return connection;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/ftp\/Handler.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1672,11 +1672,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -1796,11 +1785,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -1969,11 +1947,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2099,11 +2066,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2238,11 +2194,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2367,11 +2312,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2529,11 +2463,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2660,11 +2583,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.io.OutputStream;\n@@ -31,0 +30,1 @@\n+import java.io.OutputStream;\n@@ -82,1 +82,1 @@\n-    public void write(byte tag, byte[] buf) throws IOException {\n+    public DerOutputStream write(byte tag, byte[] buf) throws IOException {\n@@ -86,0 +86,1 @@\n+        return this;\n@@ -97,1 +98,1 @@\n-    public void write(byte tag, DerOutputStream out) throws IOException {\n+    public DerOutputStream write(byte tag, DerOutputStream out) throws IOException {\n@@ -101,0 +102,1 @@\n+        return this;\n@@ -120,1 +122,1 @@\n-    public void writeImplicit(byte tag, DerOutputStream value)\n+    public DerOutputStream writeImplicit(byte tag, DerOutputStream value)\n@@ -124,0 +126,1 @@\n+        return this;\n@@ -129,1 +132,1 @@\n-    public void putDerValue(DerValue val) throws IOException {\n+    public DerOutputStream putDerValue(DerValue val) throws IOException {\n@@ -131,0 +134,1 @@\n+        return this;\n@@ -144,1 +148,1 @@\n-    public void putBoolean(boolean val) throws IOException {\n+    public DerOutputStream putBoolean(boolean val) throws IOException {\n@@ -152,0 +156,1 @@\n+        return this;\n@@ -158,1 +163,1 @@\n-    public void putEnumerated(int i) throws IOException {\n+    public DerOutputStream putEnumerated(int i) throws IOException {\n@@ -161,0 +166,1 @@\n+        return this;\n@@ -168,1 +174,1 @@\n-    public void putInteger(BigInteger i) throws IOException {\n+    public DerOutputStream putInteger(BigInteger i) throws IOException {\n@@ -173,0 +179,1 @@\n+        return this;\n@@ -180,1 +187,1 @@\n-    public void putInteger(byte[] buf) throws IOException {\n+    public DerOutputStream putInteger(byte[] buf) throws IOException {\n@@ -184,0 +191,1 @@\n+        return this;\n@@ -190,2 +198,2 @@\n-    public void putInteger(Integer i) throws IOException {\n-        putInteger(i.intValue());\n+    public DerOutputStream putInteger(Integer i) throws IOException {\n+        return putInteger(i.intValue());\n@@ -198,1 +206,1 @@\n-    public void putInteger(int i) throws IOException {\n+    public DerOutputStream putInteger(int i) throws IOException {\n@@ -201,0 +209,1 @@\n+        return this;\n@@ -253,1 +262,1 @@\n-    public void putBitString(byte[] bits) throws IOException {\n+    public DerOutputStream putBitString(byte[] bits) throws IOException {\n@@ -258,0 +267,1 @@\n+        return this;\n@@ -266,1 +276,1 @@\n-    public void putUnalignedBitString(BitArray ba) throws IOException {\n+    public DerOutputStream putUnalignedBitString(BitArray ba) throws IOException {\n@@ -273,0 +283,1 @@\n+        return this;\n@@ -281,2 +292,2 @@\n-    public void putTruncatedUnalignedBitString(BitArray ba) throws IOException {\n-        putUnalignedBitString(ba.truncate());\n+    public DerOutputStream putTruncatedUnalignedBitString(BitArray ba) throws IOException {\n+        return putUnalignedBitString(ba.truncate());\n@@ -290,2 +301,2 @@\n-    public void putOctetString(byte[] octets) throws IOException {\n-        write(DerValue.tag_OctetString, octets);\n+    public DerOutputStream putOctetString(byte[] octets) throws IOException {\n+        return write(DerValue.tag_OctetString, octets);\n@@ -298,1 +309,1 @@\n-    public void putNull() throws IOException {\n+    public DerOutputStream putNull() throws IOException {\n@@ -301,0 +312,1 @@\n+        return this;\n@@ -307,1 +319,1 @@\n-    public void putOID(ObjectIdentifier oid) throws IOException {\n+    public DerOutputStream putOID(ObjectIdentifier oid) throws IOException {\n@@ -309,0 +321,1 @@\n+        return this;\n@@ -316,1 +329,1 @@\n-    public void putSequence(DerValue[] seq) throws IOException {\n+    public DerOutputStream putSequence(DerValue[] seq) throws IOException {\n@@ -323,1 +336,1 @@\n-        write(DerValue.tag_Sequence, bytes);\n+        return write(DerValue.tag_Sequence, bytes);\n@@ -333,1 +346,1 @@\n-    public void putSet(DerValue[] set) throws IOException {\n+    public DerOutputStream putSet(DerValue[] set) throws IOException {\n@@ -340,1 +353,1 @@\n-        write(DerValue.tag_Set, bytes);\n+        return write(DerValue.tag_Set, bytes);\n@@ -353,2 +366,2 @@\n-    public void putOrderedSetOf(byte tag, DerEncoder[] set) throws IOException {\n-        putOrderedSet(tag, set, lexOrder);\n+    public DerOutputStream putOrderedSetOf(byte tag, DerEncoder[] set) throws IOException {\n+        return putOrderedSet(tag, set, lexOrder);\n@@ -367,2 +380,2 @@\n-    public void putOrderedSet(byte tag, DerEncoder[] set) throws IOException {\n-        putOrderedSet(tag, set, tagOrder);\n+    public DerOutputStream putOrderedSet(byte tag, DerEncoder[] set) throws IOException {\n+        return putOrderedSet(tag, set, tagOrder);\n@@ -389,1 +402,1 @@\n-    private void putOrderedSet(byte tag, DerEncoder[] set,\n+    private DerOutputStream putOrderedSet(byte tag, DerEncoder[] set,\n@@ -409,2 +422,1 @@\n-        write(tag, bytes);\n-\n+        return write(tag, bytes);\n@@ -416,2 +428,2 @@\n-    public void putUTF8String(String s) throws IOException {\n-        writeString(s, DerValue.tag_UTF8String, UTF_8);\n+    public DerOutputStream putUTF8String(String s) throws IOException {\n+        return writeString(s, DerValue.tag_UTF8String, UTF_8);\n@@ -423,2 +435,2 @@\n-    public void putPrintableString(String s) throws IOException {\n-        writeString(s, DerValue.tag_PrintableString, US_ASCII);\n+    public DerOutputStream putPrintableString(String s) throws IOException {\n+        return writeString(s, DerValue.tag_PrintableString, US_ASCII);\n@@ -430,1 +442,1 @@\n-    public void putT61String(String s) throws IOException {\n+    public DerOutputStream putT61String(String s) throws IOException {\n@@ -435,1 +447,1 @@\n-        writeString(s, DerValue.tag_T61String, ISO_8859_1);\n+        return writeString(s, DerValue.tag_T61String, ISO_8859_1);\n@@ -441,2 +453,2 @@\n-    public void putIA5String(String s) throws IOException {\n-        writeString(s, DerValue.tag_IA5String, US_ASCII);\n+    public DerOutputStream putIA5String(String s) throws IOException {\n+        return writeString(s, DerValue.tag_IA5String, US_ASCII);\n@@ -448,2 +460,2 @@\n-    public void putBMPString(String s) throws IOException {\n-        writeString(s, DerValue.tag_BMPString, UTF_16BE);\n+    public DerOutputStream putBMPString(String s) throws IOException {\n+        return writeString(s, DerValue.tag_BMPString, UTF_16BE);\n@@ -455,2 +467,2 @@\n-    public void putGeneralString(String s) throws IOException {\n-        writeString(s, DerValue.tag_GeneralString, US_ASCII);\n+    public DerOutputStream putGeneralString(String s) throws IOException {\n+        return writeString(s, DerValue.tag_GeneralString, US_ASCII);\n@@ -467,1 +479,1 @@\n-    private void writeString(String s, byte stringTag, Charset charset)\n+    private DerOutputStream writeString(String s, byte stringTag, Charset charset)\n@@ -474,0 +486,1 @@\n+        return this;\n@@ -482,2 +495,2 @@\n-    public void putUTCTime(Date d) throws IOException {\n-        putTime(d, DerValue.tag_UtcTime);\n+    public DerOutputStream putUTCTime(Date d) throws IOException {\n+        return putTime(d, DerValue.tag_UtcTime);\n@@ -492,2 +505,2 @@\n-    public void putGeneralizedTime(Date d) throws IOException {\n-        putTime(d, DerValue.tag_GeneralizedTime);\n+    public DerOutputStream putGeneralizedTime(Date d) throws IOException {\n+        return putTime(d, DerValue.tag_GeneralizedTime);\n@@ -503,1 +516,1 @@\n-    private void putTime(Date d, byte tag) throws IOException {\n+    private DerOutputStream putTime(Date d, byte tag) throws IOException {\n@@ -530,0 +543,1 @@\n+        return this;\n@@ -566,17 +580,0 @@\n-    \/**\n-     * Put the tag of the attribute in the stream.\n-     *\n-     * @param tagClass the tag class type, one of UNIVERSAL, CONTEXT,\n-     *        APPLICATION or PRIVATE\n-     * @param form if true, the value is constructed, otherwise it is\n-     * primitive.\n-     * @param val the tag value\n-     *\/\n-    public void putTag(byte tagClass, boolean form, byte val) {\n-        byte tag = (byte)(tagClass | val);\n-        if (form) {\n-            tag |= (byte)0x20;\n-        }\n-        write(tag);\n-    }\n-\n@@ -593,0 +590,10 @@\n+    \/**\n+     * Write a DerEncoder onto the output stream.\n+     * @param encoder the DerEncoder\n+     * @throws IOException on output error\n+     *\/\n+    public DerOutputStream write(DerEncoder encoder) throws IOException {\n+        encoder.derEncode(this);\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerOutputStream.java","additions":73,"deletions":66,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,3 +68,3 @@\n-    private List<Method> methods;\n-    private Map<String,PropertyInfo> properties;\n-    private Map<String,EventSetInfo> eventSets;\n+    private volatile List<Method> methods;\n+    private volatile Map<String,PropertyInfo> properties;\n+    private volatile Map<String,EventSetInfo> eventSets;\n@@ -77,1 +77,2 @@\n-        if (this.methods == null) {\n+        List<Method> methods = this.methods;\n+        if (methods == null) {\n@@ -79,2 +80,4 @@\n-                if (this.methods == null) {\n-                    this.methods = MethodInfo.get(this.type);\n+                methods = this.methods;\n+                if (methods == null) {\n+                    methods = MethodInfo.get(this.type);\n+                    this.methods = methods;\n@@ -84,1 +87,1 @@\n-        return this.methods;\n+        return methods;\n@@ -88,1 +91,2 @@\n-        if (this.properties == null) {\n+        Map<String, PropertyInfo> properties = this.properties;\n+        if (properties == null) {\n@@ -90,2 +94,4 @@\n-                if (this.properties == null) {\n-                    this.properties = PropertyInfo.get(this.type);\n+                properties = this.properties;\n+                if (properties == null) {\n+                    properties = PropertyInfo.get(this.type);\n+                    this.properties = properties;\n@@ -95,1 +101,1 @@\n-        return this.properties;\n+        return properties;\n@@ -99,1 +105,2 @@\n-        if (this.eventSets == null) {\n+        Map<String, EventSetInfo> eventSets = this.eventSets;\n+        if (eventSets == null) {\n@@ -101,2 +108,4 @@\n-                if (this.eventSets == null) {\n-                    this.eventSets = EventSetInfo.get(this.type);\n+                eventSets = this.eventSets;\n+                if (eventSets == null) {\n+                    eventSets = EventSetInfo.get(this.type);\n+                    this.eventSets = eventSets;\n@@ -106,1 +115,1 @@\n-        return this.eventSets;\n+        return eventSets;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/introspect\/ClassInfo.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -983,0 +983,20 @@\n+\n+        @Override\n+        public Vector<File> getDirectories() {\n+            Vector<File> files = super.getDirectories();\n+\n+            \/*\n+             * Delete the \"\/..\" file entry from file chooser directory list in\n+             * GTK LAF if current directory is root and files vector contains\n+             * \"\/..\" entry.\n+             *\n+             * It is not possible to go beyond root directory.\n+             *\/\n+            File crntDir = getFileChooser().getCurrentDirectory();\n+            FileSystemView fsv = getFileChooser().getFileSystemView();\n+            if (crntDir != null && fsv.isFileSystemRoot(crntDir) &&\n+                files.contains(new File(\"\/..\"))) {\n+                    files.removeElementAt(0);\n+            }\n+            return files;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKFileChooserUI.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -74,4 +74,4 @@\n- * The details of this class are not important for simple applets, which draw in\n- * a default color space or manipulate and display imported images with a known\n- * color space. At most, such applets would need to get one of the default color\n- * spaces via {@link ColorSpace#getInstance}.\n+ * The details of this class are not important for simple applications, which\n+ * draw in a default color space or manipulate and display imported images with\n+ * a known color space. At most, such applications would need to get one of the\n+ * default color spaces via {@link ColorSpace#getInstance}.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ColorSpace.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1076,2 +1076,2 @@\n-     * This method is useful for advanced applets or applications which need to\n-     * access profile data directly.\n+     * This method is useful for advanced applications which need to access\n+     * profile data directly.\n@@ -1102,2 +1102,2 @@\n-     * This method is useful for advanced applets or applications which need to\n-     * access profile data directly.\n+     * This method is useful for advanced applications which need to access\n+     * profile data directly.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -211,0 +214,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -219,0 +225,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -227,0 +236,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -241,0 +253,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -245,0 +260,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -249,0 +267,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -265,0 +286,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -269,0 +293,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -283,0 +310,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -287,0 +317,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -321,0 +354,4 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     * @throws java.io.UTFDataFormatException {@inheritDoc}\n+     *\/\n@@ -343,0 +380,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -360,0 +400,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -364,0 +407,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -380,0 +426,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -396,0 +445,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -412,0 +464,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -428,0 +483,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -444,0 +502,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -644,0 +705,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -666,0 +730,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageInputStreamImpl.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,0 +159,3 @@\n+    \/**\n+     * @throws UTFDataFormatException {@inheritDoc}\n+     *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageOutputStreamImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,3 +1269,1 @@\n-            if (!getFileChooser().getCurrentDirectory().equals(f)) {\n-                getFileChooser().setCurrentDirectory(f);\n-            }\n+            getFileChooser().setCurrentDirectory(f);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalFileChooserUI.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -416,0 +416,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -420,0 +424,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -424,0 +432,3 @@\n+    \/**\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -428,0 +439,3 @@\n+    \/**\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -432,0 +446,3 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     *\/\n@@ -436,0 +453,3 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     *\/\n@@ -440,0 +460,3 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     *\/\n@@ -444,0 +467,3 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     *\/\n@@ -472,0 +498,5 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     * @throws  NotContextException {@inheritDoc}\n+     * @throws  ContextNotEmptyException {@inheritDoc}\n+     *\/\n@@ -476,0 +507,5 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     * @throws  NotContextException {@inheritDoc}\n+     * @throws  ContextNotEmptyException {@inheritDoc}\n+     *\/\n@@ -480,0 +516,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -484,0 +524,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -554,0 +598,3 @@\n+    \/**\n+     * @throws OperationNotSupportedException {@inheritDoc}\n+     *\/\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/InitialContext.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,0 +477,2 @@\n+      *\n+      * @throws OperationNotSupportedException {@inheritDoc}\n@@ -487,0 +489,2 @@\n+      *\n+      * @throws OperationNotSupportedException {@inheritDoc}\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/BasicAttribute.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -184,0 +184,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -189,0 +192,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -194,0 +200,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -199,0 +208,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -204,0 +216,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -209,0 +225,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -214,0 +234,3 @@\n+    \/**\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -219,0 +242,3 @@\n+    \/**\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -224,0 +250,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -229,0 +259,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -234,0 +268,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -238,0 +275,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -242,0 +282,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -247,0 +290,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -290,0 +336,4 @@\n+    \/**\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     *\/\n@@ -299,0 +349,4 @@\n+    \/**\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     *\/\n@@ -308,0 +362,4 @@\n+    \/**\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     *\/\n@@ -319,0 +377,4 @@\n+    \/**\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     *\/\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/InitialDirContext.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-    return context.getRegisterAsAddress(X86ThreadContext.ESP);\n+    return context.getRegisterAsAddress(X86ThreadContext.SP);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/linux_x86\/LinuxX86JavaThreadPDAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n+\n+import static java.util.Collections.emptyMap;\n+import static jdk.vm.ci.common.InitTimer.timer;\n+\n+import java.util.EnumSet;\n+import java.util.Map;\n+\n+import jdk.vm.ci.riscv64.RISCV64;\n+import jdk.vm.ci.riscv64.RISCV64.CPUFeature;\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.RegisterConfig;\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.code.stack.StackIntrospection;\n+import jdk.vm.ci.common.InitTimer;\n+import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;\n+import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;\n+import jdk.vm.ci.hotspot.HotSpotJVMCIBackendFactory;\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n+import jdk.vm.ci.hotspot.HotSpotMetaAccessProvider;\n+import jdk.vm.ci.hotspot.HotSpotStackIntrospection;\n+import jdk.vm.ci.meta.ConstantReflectionProvider;\n+import jdk.vm.ci.runtime.JVMCIBackend;\n+\n+public class RISCV64HotSpotJVMCIBackendFactory implements HotSpotJVMCIBackendFactory {\n+\n+    private static EnumSet<RISCV64.CPUFeature> computeFeatures(RISCV64HotSpotVMConfig config) {\n+        \/\/ Configure the feature set using the HotSpot flag settings.\n+        Map<String, Long> constants = config.getStore().getConstants();\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+    }\n+\n+    private static EnumSet<RISCV64.Flag> computeFlags(RISCV64HotSpotVMConfig config) {\n+        EnumSet<RISCV64.Flag> flags = EnumSet.noneOf(RISCV64.Flag.class);\n+\n+        if (config.useConservativeFence) {\n+            flags.add(RISCV64.Flag.UseConservativeFence);\n+        }\n+        if (config.avoidUnalignedAccesses) {\n+            flags.add(RISCV64.Flag.AvoidUnalignedAccesses);\n+        }\n+        if (config.nearCpool) {\n+            flags.add(RISCV64.Flag.NearCpool);\n+        }\n+        if (config.traceTraps) {\n+            flags.add(RISCV64.Flag.TraceTraps);\n+        }\n+        if (config.useRVV) {\n+            flags.add(RISCV64.Flag.UseRVV);\n+        }\n+        if (config.useRVC) {\n+            flags.add(RISCV64.Flag.UseRVC);\n+        }\n+        if (config.useZba) {\n+            flags.add(RISCV64.Flag.UseZba);\n+        }\n+        if (config.useZbb) {\n+            flags.add(RISCV64.Flag.UseZbb);\n+        }\n+        if (config.useRVVForBigIntegerShiftIntrinsics) {\n+            flags.add(RISCV64.Flag.UseRVVForBigIntegerShiftIntrinsics);\n+        }\n+\n+        return flags;\n+    }\n+\n+    private static TargetDescription createTarget(RISCV64HotSpotVMConfig config) {\n+        final int stackFrameAlignment = 16;\n+        final int implicitNullCheckLimit = 4096;\n+        final boolean inlineObjects = true;\n+        Architecture arch = new RISCV64(computeFeatures(config), computeFlags(config));\n+        return new TargetDescription(arch, true, stackFrameAlignment, implicitNullCheckLimit, inlineObjects);\n+    }\n+\n+    protected HotSpotConstantReflectionProvider createConstantReflection(HotSpotJVMCIRuntime runtime) {\n+        return new HotSpotConstantReflectionProvider(runtime);\n+    }\n+\n+    private static RegisterConfig createRegisterConfig(RISCV64HotSpotVMConfig config, TargetDescription target) {\n+        return new RISCV64HotSpotRegisterConfig(target, config.useCompressedOops, config.linuxOs);\n+    }\n+\n+    protected HotSpotCodeCacheProvider createCodeCache(HotSpotJVMCIRuntime runtime, TargetDescription target, RegisterConfig regConfig) {\n+        return new HotSpotCodeCacheProvider(runtime, target, regConfig);\n+    }\n+\n+    protected HotSpotMetaAccessProvider createMetaAccess(HotSpotJVMCIRuntime runtime) {\n+        return new HotSpotMetaAccessProvider(runtime);\n+    }\n+\n+    @Override\n+    public String getArchitecture() {\n+        return \"riscv64\";\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"JVMCIBackend:\" + getArchitecture();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"try\")\n+    public JVMCIBackend createJVMCIBackend(HotSpotJVMCIRuntime runtime, JVMCIBackend host) {\n+        assert host == null;\n+        RISCV64HotSpotVMConfig config = new RISCV64HotSpotVMConfig(runtime.getConfigStore());\n+        TargetDescription target = createTarget(config);\n+\n+        RegisterConfig regConfig;\n+        HotSpotCodeCacheProvider codeCache;\n+        ConstantReflectionProvider constantReflection;\n+        HotSpotMetaAccessProvider metaAccess;\n+        StackIntrospection stackIntrospection;\n+        try (InitTimer t = timer(\"create providers\")) {\n+            try (InitTimer rt = timer(\"create MetaAccess provider\")) {\n+                metaAccess = createMetaAccess(runtime);\n+            }\n+            try (InitTimer rt = timer(\"create RegisterConfig\")) {\n+                regConfig = createRegisterConfig(config, target);\n+            }\n+            try (InitTimer rt = timer(\"create CodeCache provider\")) {\n+                codeCache = createCodeCache(runtime, target, regConfig);\n+            }\n+            try (InitTimer rt = timer(\"create ConstantReflection provider\")) {\n+                constantReflection = createConstantReflection(runtime);\n+            }\n+            try (InitTimer rt = timer(\"create StackIntrospection provider\")) {\n+                stackIntrospection = new HotSpotStackIntrospection(runtime);\n+            }\n+        }\n+        try (InitTimer rt = timer(\"instantiate backend\")) {\n+            return createBackend(metaAccess, codeCache, constantReflection, stackIntrospection);\n+        }\n+    }\n+\n+    protected JVMCIBackend createBackend(HotSpotMetaAccessProvider metaAccess, HotSpotCodeCacheProvider codeCache, ConstantReflectionProvider constantReflection,\n+                    StackIntrospection stackIntrospection) {\n+        return new JVMCIBackend(metaAccess, codeCache, constantReflection, stackIntrospection);\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n+\n+import static jdk.vm.ci.riscv64.RISCV64.x0;\n+import static jdk.vm.ci.riscv64.RISCV64.x1;\n+import static jdk.vm.ci.riscv64.RISCV64.x2;\n+import static jdk.vm.ci.riscv64.RISCV64.x3;\n+import static jdk.vm.ci.riscv64.RISCV64.x4;\n+import static jdk.vm.ci.riscv64.RISCV64.x5;\n+import static jdk.vm.ci.riscv64.RISCV64.x6;\n+import static jdk.vm.ci.riscv64.RISCV64.x7;\n+import static jdk.vm.ci.riscv64.RISCV64.x8;\n+import static jdk.vm.ci.riscv64.RISCV64.x10;\n+import static jdk.vm.ci.riscv64.RISCV64.x11;\n+import static jdk.vm.ci.riscv64.RISCV64.x12;\n+import static jdk.vm.ci.riscv64.RISCV64.x13;\n+import static jdk.vm.ci.riscv64.RISCV64.x14;\n+import static jdk.vm.ci.riscv64.RISCV64.x15;\n+import static jdk.vm.ci.riscv64.RISCV64.x16;\n+import static jdk.vm.ci.riscv64.RISCV64.x17;\n+import static jdk.vm.ci.riscv64.RISCV64.x23;\n+import static jdk.vm.ci.riscv64.RISCV64.x27;\n+import static jdk.vm.ci.riscv64.RISCV64.f10;\n+import static jdk.vm.ci.riscv64.RISCV64.f11;\n+import static jdk.vm.ci.riscv64.RISCV64.f12;\n+import static jdk.vm.ci.riscv64.RISCV64.f13;\n+import static jdk.vm.ci.riscv64.RISCV64.f14;\n+import static jdk.vm.ci.riscv64.RISCV64.f15;\n+import static jdk.vm.ci.riscv64.RISCV64.f16;\n+import static jdk.vm.ci.riscv64.RISCV64.f17;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.vm.ci.riscv64.RISCV64;\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.CallingConvention;\n+import jdk.vm.ci.code.CallingConvention.Type;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.RegisterArray;\n+import jdk.vm.ci.code.RegisterAttributes;\n+import jdk.vm.ci.code.RegisterConfig;\n+import jdk.vm.ci.code.StackSlot;\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.code.ValueKindFactory;\n+import jdk.vm.ci.common.JVMCIError;\n+import jdk.vm.ci.hotspot.HotSpotCallingConventionType;\n+import jdk.vm.ci.meta.AllocatableValue;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.PlatformKind;\n+import jdk.vm.ci.meta.Value;\n+import jdk.vm.ci.meta.ValueKind;\n+\n+public class RISCV64HotSpotRegisterConfig implements RegisterConfig {\n+\n+    private final TargetDescription target;\n+\n+    private final RegisterArray allocatable;\n+\n+    \/**\n+     * The caller saved registers always include all parameter registers.\n+     *\/\n+    private final RegisterArray callerSaved;\n+\n+    private final boolean allAllocatableAreCallerSaved;\n+\n+    private final RegisterAttributes[] attributesMap;\n+\n+    @Override\n+    public RegisterArray getAllocatableRegisters() {\n+        return allocatable;\n+    }\n+\n+    @Override\n+    public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {\n+        ArrayList<Register> list = new ArrayList<>();\n+        for (Register reg : registers) {\n+            if (target.arch.canStoreValue(reg.getRegisterCategory(), kind)) {\n+                list.add(reg);\n+            }\n+        }\n+\n+        return new RegisterArray(list);\n+    }\n+\n+    @Override\n+    public RegisterAttributes[] getAttributesMap() {\n+        return attributesMap.clone();\n+    }\n+\n+    private final RegisterArray javaGeneralParameterRegisters = new RegisterArray(x11, x12, x13, x14, x15, x16, x17, x10);\n+    private final RegisterArray nativeGeneralParameterRegisters = new RegisterArray(x10, x11, x12, x13, x14, x15, x16, x17);\n+    private final RegisterArray fpParameterRegisters = new RegisterArray(f10, f11, f12, f13, f14, f15, f16, f17);\n+\n+    public static final Register zero = x0;\n+    public static final Register ra = x1;\n+    public static final Register sp = x2;\n+    public static final Register gp = x3;\n+    public static final Register tp = x4;\n+    public static final Register t0 = x5;\n+    public static final Register t1 = x6;\n+    public static final Register t2 = x7;\n+    public static final Register fp = x8;\n+    public static final Register threadRegister = x23;\n+    public static final Register heapBaseRegister = x27;\n+\n+    private static final RegisterArray reservedRegisters = new RegisterArray(zero, ra, sp, gp, tp, t0, t1, t2, fp);\n+\n+    private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase) {\n+        RegisterArray allRegisters = arch.getAvailableValueRegisters();\n+        Register[] registers = new Register[allRegisters.size() - reservedRegisters.size() - (reserveForHeapBase ? 1 : 0)];\n+        List<Register> reservedRegistersList = reservedRegisters.asList();\n+\n+        int idx = 0;\n+        for (Register reg : allRegisters) {\n+            if (reservedRegistersList.contains(reg)) {\n+                \/\/ skip reserved registers\n+                continue;\n+            }\n+            assert !(reg.equals(zero) || reg.equals(ra) || reg.equals(sp) || reg.equals(gp) || reg.equals(tp) ||\n+                     reg.equals(t0) || reg.equals(t1) || reg.equals(t2) || reg.equals(fp));\n+            if (reserveForHeapBase && reg.equals(heapBaseRegister)) {\n+                \/\/ skip heap base register\n+                continue;\n+            }\n+\n+            registers[idx++] = reg;\n+        }\n+\n+        assert idx == registers.length;\n+        return new RegisterArray(registers);\n+    }\n+\n+    public RISCV64HotSpotRegisterConfig(TargetDescription target, boolean useCompressedOops, boolean linuxOs) {\n+        this(target, initAllocatable(target.arch, useCompressedOops));\n+        assert callerSaved.size() >= allocatable.size();\n+    }\n+\n+    public RISCV64HotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable) {\n+        this.target = target;\n+        this.allocatable = allocatable;\n+\n+        Set<Register> callerSaveSet = new HashSet<>();\n+        allocatable.addTo(callerSaveSet);\n+        fpParameterRegisters.addTo(callerSaveSet);\n+        javaGeneralParameterRegisters.addTo(callerSaveSet);\n+        nativeGeneralParameterRegisters.addTo(callerSaveSet);\n+        callerSaved = new RegisterArray(callerSaveSet);\n+\n+        allAllocatableAreCallerSaved = true;\n+        attributesMap = RegisterAttributes.createMap(this, RISCV64.allRegisters);\n+    }\n+\n+    @Override\n+    public RegisterArray getCallerSaveRegisters() {\n+        return callerSaved;\n+    }\n+\n+    @Override\n+    public RegisterArray getCalleeSaveRegisters() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean areAllAllocatableRegistersCallerSaved() {\n+        return allAllocatableAreCallerSaved;\n+    }\n+\n+    @Override\n+    public CallingConvention getCallingConvention(Type type, JavaType returnType, JavaType[] parameterTypes, ValueKindFactory<?> valueKindFactory) {\n+        HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;\n+        if (type == HotSpotCallingConventionType.NativeCall) {\n+            return callingConvention(nativeGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);\n+        }\n+        return callingConvention(javaGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);\n+    }\n+\n+    @Override\n+    public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {\n+        HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;\n+        switch (kind) {\n+            case Boolean:\n+            case Byte:\n+            case Short:\n+            case Char:\n+            case Int:\n+            case Long:\n+            case Object:\n+                return hotspotType == HotSpotCallingConventionType.NativeCall ? nativeGeneralParameterRegisters : javaGeneralParameterRegisters;\n+            case Float:\n+            case Double:\n+                return fpParameterRegisters;\n+            default:\n+                throw JVMCIError.shouldNotReachHere();\n+        }\n+    }\n+\n+    private CallingConvention callingConvention(RegisterArray generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,\n+                    ValueKindFactory<?> valueKindFactory) {\n+        AllocatableValue[] locations = new AllocatableValue[parameterTypes.length];\n+\n+        int currentGeneral = 0;\n+        int currentFP = 0;\n+        int currentStackOffset = 0;\n+\n+        for (int i = 0; i < parameterTypes.length; i++) {\n+            final JavaKind kind = parameterTypes[i].getJavaKind().getStackKind();\n+\n+            switch (kind) {\n+                case Byte:\n+                case Boolean:\n+                case Short:\n+                case Char:\n+                case Int:\n+                case Long:\n+                case Object:\n+                    if (currentGeneral < generalParameterRegisters.size()) {\n+                        Register register = generalParameterRegisters.get(currentGeneral++);\n+                        locations[i] = register.asValue(valueKindFactory.getValueKind(kind));\n+                    }\n+                    break;\n+                case Float:\n+                case Double:\n+                    if (currentFP < fpParameterRegisters.size()) {\n+                        Register register = fpParameterRegisters.get(currentFP++);\n+                        locations[i] = register.asValue(valueKindFactory.getValueKind(kind));\n+                    } else if (currentGeneral < generalParameterRegisters.size()) {\n+                        Register register = generalParameterRegisters.get(currentGeneral++);\n+                        locations[i] = register.asValue(valueKindFactory.getValueKind(kind));\n+                    }\n+                    break;\n+                default:\n+                    throw JVMCIError.shouldNotReachHere();\n+            }\n+\n+            if (locations[i] == null) {\n+                ValueKind<?> valueKind = valueKindFactory.getValueKind(kind);\n+                locations[i] = StackSlot.get(valueKind, currentStackOffset, !type.out);\n+                currentStackOffset += Math.max(valueKind.getPlatformKind().getSizeInBytes(), target.wordSize);\n+            }\n+        }\n+\n+        JavaKind returnKind = returnType == null ? JavaKind.Void : returnType.getJavaKind();\n+        AllocatableValue returnLocation = returnKind == JavaKind.Void ? Value.ILLEGAL : getReturnRegister(returnKind).asValue(valueKindFactory.getValueKind(returnKind.getStackKind()));\n+        return new CallingConvention(currentStackOffset, returnLocation, locations);\n+    }\n+\n+    @Override\n+    public Register getReturnRegister(JavaKind kind) {\n+        switch (kind) {\n+            case Boolean:\n+            case Byte:\n+            case Char:\n+            case Short:\n+            case Int:\n+            case Long:\n+            case Object:\n+                return x10;\n+            case Float:\n+            case Double:\n+                return f10;\n+            case Void:\n+            case Illegal:\n+                return null;\n+            default:\n+                throw new UnsupportedOperationException(\"no return register for type \" + kind);\n+        }\n+    }\n+\n+    @Override\n+    public Register getFrameRegister() {\n+        return x2;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Allocatable: \" + getAllocatableRegisters() + \"%n\" + \"CallerSave:  \" + getCallerSaveRegisters() + \"%n\");\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotRegisterConfig.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n+\n+import jdk.vm.ci.hotspot.HotSpotVMConfigAccess;\n+import jdk.vm.ci.hotspot.HotSpotVMConfigStore;\n+import jdk.vm.ci.services.Services;\n+\n+\/**\n+ * Used to access native configuration details.\n+ *\n+ * All non-static, public fields in this class are so that they can be compiled as constants.\n+ *\/\n+class RISCV64HotSpotVMConfig extends HotSpotVMConfigAccess {\n+\n+    RISCV64HotSpotVMConfig(HotSpotVMConfigStore config) {\n+        super(config);\n+    }\n+\n+    final boolean linuxOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Linux\");\n+\n+    final boolean useCompressedOops = getFlag(\"UseCompressedOops\", Boolean.class);\n+\n+    \/\/ CPU Capabilities\n+\n+    \/*\n+     * These flags are set based on the corresponding command line flags.\n+     *\/\n+    final boolean useConservativeFence = getFlag(\"UseConservativeFence\", Boolean.class);\n+    final boolean avoidUnalignedAccesses = getFlag(\"AvoidUnalignedAccesses\", Boolean.class);\n+    final boolean nearCpool = getFlag(\"NearCpool\", Boolean.class);\n+    final boolean traceTraps = getFlag(\"TraceTraps\", Boolean.class);\n+    final boolean useRVV = getFlag(\"UseRVV\", Boolean.class);\n+    final boolean useRVC = getFlag(\"UseRVC\", Boolean.class);\n+    final boolean useZba = getFlag(\"UseZba\", Boolean.class);\n+    final boolean useZbb = getFlag(\"UseZbb\", Boolean.class);\n+    final boolean useRVVForBigIntegerShiftIntrinsics = getFlag(\"UseRVVForBigIntegerShiftIntrinsics\", Boolean.class);\n+\n+    final long vmVersionFeatures = getFieldValue(\"Abstract_VM_Version::_features\", Long.class, \"uint64_t\");\n+\n+    \/*\n+     * These flags are set if the corresponding support is in the hardware.\n+     *\/\n+    \/\/ Checkstyle: stop\n+    \/\/ CPU feature flags are currently not available in VM_Version\n+    \/\/ Checkstyle: resume\n+\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotVMConfig.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * The RISCV64 HotSpot specific portions of the JVMCI API.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/package-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.riscv64;\n+\n+import java.nio.ByteOrder;\n+import java.util.EnumSet;\n+\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.CPUFeatureName;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.Register.RegisterCategory;\n+import jdk.vm.ci.code.RegisterArray;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.PlatformKind;\n+\n+\/**\n+ * Represents the RISCV64 architecture.\n+ *\/\n+public class RISCV64 extends Architecture {\n+\n+    public static final RegisterCategory CPU = new RegisterCategory(\"CPU\");\n+\n+    \/\/ General purpose CPU registers\n+    public static final Register x0 = new Register(0, 0, \"x0\", CPU);\n+    public static final Register x1 = new Register(1, 1, \"x1\", CPU);\n+    public static final Register x2 = new Register(2, 2, \"x2\", CPU);\n+    public static final Register x3 = new Register(3, 3, \"x3\", CPU);\n+    public static final Register x4 = new Register(4, 4, \"x4\", CPU);\n+    public static final Register x5 = new Register(5, 5, \"x5\", CPU);\n+    public static final Register x6 = new Register(6, 6, \"x6\", CPU);\n+    public static final Register x7 = new Register(7, 7, \"x7\", CPU);\n+    public static final Register x8 = new Register(8, 8, \"x8\", CPU);\n+    public static final Register x9 = new Register(9, 9, \"x9\", CPU);\n+    public static final Register x10 = new Register(10, 10, \"x10\", CPU);\n+    public static final Register x11 = new Register(11, 11, \"x11\", CPU);\n+    public static final Register x12 = new Register(12, 12, \"x12\", CPU);\n+    public static final Register x13 = new Register(13, 13, \"x13\", CPU);\n+    public static final Register x14 = new Register(14, 14, \"x14\", CPU);\n+    public static final Register x15 = new Register(15, 15, \"x15\", CPU);\n+    public static final Register x16 = new Register(16, 16, \"x16\", CPU);\n+    public static final Register x17 = new Register(17, 17, \"x17\", CPU);\n+    public static final Register x18 = new Register(18, 18, \"x18\", CPU);\n+    public static final Register x19 = new Register(19, 19, \"x19\", CPU);\n+    public static final Register x20 = new Register(20, 20, \"x20\", CPU);\n+    public static final Register x21 = new Register(21, 21, \"x21\", CPU);\n+    public static final Register x22 = new Register(22, 22, \"x22\", CPU);\n+    public static final Register x23 = new Register(23, 23, \"x23\", CPU);\n+    public static final Register x24 = new Register(24, 24, \"x24\", CPU);\n+    public static final Register x25 = new Register(25, 25, \"x25\", CPU);\n+    public static final Register x26 = new Register(26, 26, \"x26\", CPU);\n+    public static final Register x27 = new Register(27, 27, \"x27\", CPU);\n+    public static final Register x28 = new Register(28, 28, \"x28\", CPU);\n+    public static final Register x29 = new Register(29, 29, \"x29\", CPU);\n+    public static final Register x30 = new Register(30, 30, \"x30\", CPU);\n+    public static final Register x31 = new Register(31, 31, \"x31\", CPU);\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray cpuRegisters = new RegisterArray(\n+        x0,  x1,  x2,  x3,  x4,  x5,  x6,  x7,\n+        x8,  x9,  x10, x11, x12, x13, x14, x15,\n+        x16, x17, x18, x19, x20, x21, x22, x23,\n+        x24, x25, x26, x27, x28, x29, x30, x31\n+    );\n+    \/\/ @formatter:on\n+\n+    public static final RegisterCategory FP = new RegisterCategory(\"FP\");\n+\n+    \/\/ Simd registers\n+    public static final Register f0 = new Register(32, 0, \"f0\", FP);\n+    public static final Register f1 = new Register(33, 1, \"f1\", FP);\n+    public static final Register f2 = new Register(34, 2, \"f2\", FP);\n+    public static final Register f3 = new Register(35, 3, \"f3\", FP);\n+    public static final Register f4 = new Register(36, 4, \"f4\", FP);\n+    public static final Register f5 = new Register(37, 5, \"f5\", FP);\n+    public static final Register f6 = new Register(38, 6, \"f6\", FP);\n+    public static final Register f7 = new Register(39, 7, \"f7\", FP);\n+    public static final Register f8 = new Register(40, 8, \"f8\", FP);\n+    public static final Register f9 = new Register(41, 9, \"f9\", FP);\n+    public static final Register f10 = new Register(42, 10, \"f10\", FP);\n+    public static final Register f11 = new Register(43, 11, \"f11\", FP);\n+    public static final Register f12 = new Register(44, 12, \"f12\", FP);\n+    public static final Register f13 = new Register(45, 13, \"f13\", FP);\n+    public static final Register f14 = new Register(46, 14, \"f14\", FP);\n+    public static final Register f15 = new Register(47, 15, \"f15\", FP);\n+    public static final Register f16 = new Register(48, 16, \"f16\", FP);\n+    public static final Register f17 = new Register(49, 17, \"f17\", FP);\n+    public static final Register f18 = new Register(50, 18, \"f18\", FP);\n+    public static final Register f19 = new Register(51, 19, \"f19\", FP);\n+    public static final Register f20 = new Register(52, 20, \"f20\", FP);\n+    public static final Register f21 = new Register(53, 21, \"f21\", FP);\n+    public static final Register f22 = new Register(54, 22, \"f22\", FP);\n+    public static final Register f23 = new Register(55, 23, \"f23\", FP);\n+    public static final Register f24 = new Register(56, 24, \"f24\", FP);\n+    public static final Register f25 = new Register(57, 25, \"f25\", FP);\n+    public static final Register f26 = new Register(58, 26, \"f26\", FP);\n+    public static final Register f27 = new Register(59, 27, \"f27\", FP);\n+    public static final Register f28 = new Register(60, 28, \"f28\", FP);\n+    public static final Register f29 = new Register(61, 29, \"f29\", FP);\n+    public static final Register f30 = new Register(62, 30, \"f30\", FP);\n+    public static final Register f31 = new Register(63, 31, \"f31\", FP);\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray fpRegisters = new RegisterArray(\n+        f0,  f1,  f2,  f3,  f4,  f5,  f6,  f7,\n+        f8,  f9,  f10, f11, f12, f13, f14, f15,\n+        f16, f17, f18, f19, f20, f21, f22, f23,\n+        f24, f25, f26, f27, f28, f29, f30, f31\n+    );\n+    \/\/ @formatter:on\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray allRegisters = new RegisterArray(\n+        x0,  x1,  x2,  x3,  x4,  x5,  x6,  x7,\n+        x8,  x9,  x10, x11, x12, x13, x14, x15,\n+        x16, x17, x18, x19, x20, x21, x22, x23,\n+        x24, x25, x26, x27, x28, x29, x30, x31,\n+\n+        f0,  f1,  f2,  f3,  f4,  f5,  f6,  f7,\n+        f8,  f9,  f10, f11, f12, f13, f14, f15,\n+        f16, f17, f18, f19, f20, f21, f22, f23,\n+        f24, f25, f26, f27, f28, f29, f30, f31\n+    );\n+    \/\/ @formatter:on\n+\n+    \/**\n+     * Basic set of CPU features mirroring what is returned from the mcpuid register. See:\n+     * {@code VM_Version::cpuFeatureFlags}.\n+     *\/\n+    public enum CPUFeature implements CPUFeatureName {\n+        I,\n+        M,\n+        A,\n+        F,\n+        D,\n+        C,\n+        V\n+    }\n+\n+    private final EnumSet<CPUFeature> features;\n+\n+    \/**\n+     * Set of flags to control code emission.\n+     *\/\n+    public enum Flag {\n+        UseConservativeFence,\n+        AvoidUnalignedAccesses,\n+        NearCpool,\n+        TraceTraps,\n+        UseRVV,\n+        UseRVC,\n+        UseZba,\n+        UseZbb,\n+        UseRVVForBigIntegerShiftIntrinsics\n+    }\n+\n+    private final EnumSet<Flag> flags;\n+\n+    public RISCV64(EnumSet<CPUFeature> features, EnumSet<Flag> flags) {\n+        super(\"riscv64\", RISCV64Kind.QWORD, ByteOrder.LITTLE_ENDIAN, true, allRegisters, 0, 0, 8);\n+        this.features = features;\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public EnumSet<CPUFeature> getFeatures() {\n+        return features;\n+    }\n+\n+    public EnumSet<Flag> getFlags() {\n+        return flags;\n+    }\n+\n+    @Override\n+    public PlatformKind getPlatformKind(JavaKind javaKind) {\n+        switch (javaKind) {\n+            case Boolean:\n+            case Byte:\n+                return RISCV64Kind.BYTE;\n+            case Short:\n+            case Char:\n+                return RISCV64Kind.WORD;\n+            case Int:\n+                return RISCV64Kind.DWORD;\n+            case Long:\n+            case Object:\n+                return RISCV64Kind.QWORD;\n+            case Float:\n+                return RISCV64Kind.SINGLE;\n+            case Double:\n+                return RISCV64Kind.DOUBLE;\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean canStoreValue(RegisterCategory category, PlatformKind platformKind) {\n+        RISCV64Kind kind = (RISCV64Kind) platformKind;\n+        if (kind.isInteger()) {\n+            return category.equals(CPU);\n+        } else if (kind.isFP()) {\n+            return category.equals(FP);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public RISCV64Kind getLargestStorableKind(RegisterCategory category) {\n+        if (category.equals(CPU)) {\n+            return RISCV64Kind.QWORD;\n+        } else if (category.equals(FP)) {\n+            return RISCV64Kind.DOUBLE;\n+        } else {\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.riscv64\/src\/jdk\/vm\/ci\/riscv64\/RISCV64.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.riscv64;\n+\n+import jdk.vm.ci.meta.PlatformKind;\n+\n+public enum RISCV64Kind implements PlatformKind {\n+\n+    \/\/ scalar\n+    BYTE(1),\n+    WORD(2),\n+    DWORD(4),\n+    QWORD(8),\n+    SINGLE(4),\n+    DOUBLE(8);\n+\n+    private final int size;\n+    private final int vectorLength;\n+\n+    private final RISCV64Kind scalar;\n+    private final EnumKey<RISCV64Kind> key = new EnumKey<>(this);\n+\n+    RISCV64Kind(int size) {\n+        this.size = size;\n+        this.scalar = this;\n+        this.vectorLength = 1;\n+    }\n+\n+    RISCV64Kind(int size, RISCV64Kind scalar) {\n+        this.size = size;\n+        this.scalar = scalar;\n+\n+        assert size % scalar.size == 0;\n+        this.vectorLength = size \/ scalar.size;\n+    }\n+\n+    public RISCV64Kind getScalar() {\n+        return scalar;\n+    }\n+\n+    @Override\n+    public int getSizeInBytes() {\n+        return size;\n+    }\n+\n+    @Override\n+    public int getVectorLength() {\n+        return vectorLength;\n+    }\n+\n+    @Override\n+    public Key getKey() {\n+        return key;\n+    }\n+\n+    public boolean isInteger() {\n+        switch (this) {\n+            case BYTE:\n+            case WORD:\n+            case DWORD:\n+            case QWORD:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public boolean isFP() {\n+        switch (this) {\n+            case SINGLE:\n+            case DOUBLE:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    @Override\n+    public char getTypeChar() {\n+        switch (this) {\n+            case BYTE:\n+                return 'b';\n+            case WORD:\n+                return 'w';\n+            case DWORD:\n+                return 'd';\n+            case QWORD:\n+                return 'q';\n+            case SINGLE:\n+                return 'S';\n+            case DOUBLE:\n+                return 'D';\n+            default:\n+                return '-';\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.riscv64\/src\/jdk\/vm\/ci\/riscv64\/RISCV64Kind.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * The RISCV64 platform independent portions of the JVMCI API.\n+ *\/\n+package jdk.vm.ci.riscv64;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.riscv64\/src\/jdk\/vm\/ci\/riscv64\/package-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -42,1 +42,2 @@\n-        jdk.vm.ci.hotspot.amd64.AMD64HotSpotJVMCIBackendFactory;\n+        jdk.vm.ci.hotspot.amd64.AMD64HotSpotJVMCIBackendFactory,\n+        jdk.vm.ci.hotspot.riscv64.RISCV64HotSpotJVMCIBackendFactory;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import jdk.jfr.internal.EventInstrumentation.SettingInfo;\n@@ -69,1 +68,1 @@\n-    private final ArrayList<SettingInfo> settingInfos = new ArrayList<>();\n+    private final ArrayList<SettingControl> settingControls = new ArrayList<>();\n@@ -166,1 +165,0 @@\n-            int index = settingInfos.size();\n@@ -183,1 +181,1 @@\n-                settingInfos.add(new SettingInfo(FIELD_SETTING_PREFIX + index, index, null, null, settingControl));\n+                settingControls.add(settingControl);\n@@ -311,2 +309,9 @@\n-    public List<SettingInfo> getSettingInfos() {\n-        return settingInfos;\n+    \/**\n+     * A malicious user must never be able to run a callback in the wrong\n+     * context. Methods on SettingControl must therefore never be invoked directly\n+     * by JFR, instead use jdk.jfr.internal.Control.\n+     *\n+     * The returned list is only to be used inside EventConfiguration\n+     *\/\n+    public List<SettingControl> getSettingControls() {\n+        return settingControls;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -63,9 +63,1 @@\n-    record SettingInfo(String fieldName, int index, Type paramType, String methodName, SettingControl settingControl) {\n-        \/**\n-         * A malicious user must never be able to run a callback in the wrong\n-         * context. Methods on SettingControl must therefore never be invoked directly\n-         * by JFR, instead use jdk.jfr.internal.Control.\n-         *\/\n-        public SettingControl settingControl() {\n-            return this.settingControl;\n-        }\n+    record SettingInfo(Type paramType, String methodName) {\n@@ -74,1 +66,1 @@\n-    record FieldInfo(String fieldName, String fieldDescriptor, String internalClassName) {\n+    record FieldInfo(String name, String descriptor) {\n@@ -139,2 +131,2 @@\n-        for (FieldInfo v : fields) {\n-            sb.append(v.fieldDescriptor);\n+        for (FieldInfo field : fields) {\n+            sb.append(field.descriptor);\n@@ -247,2 +239,0 @@\n-                                String fieldName = EventControl.FIELD_SETTING_PREFIX + settingInfos.size();\n-                                int index = settingInfos.size();\n@@ -250,1 +240,1 @@\n-                                settingInfos.add(new SettingInfo(fieldName, index, paramType, m.name, null));\n+                                settingInfos.add(new SettingInfo(paramType, m.name));\n@@ -266,2 +256,0 @@\n-                                String fieldName = EventControl.FIELD_SETTING_PREFIX + settingInfos.size();\n-                                int index = settingInfos.size();\n@@ -269,1 +257,1 @@\n-                                settingInfos.add(new SettingInfo(fieldName, index, paramType, method.getName(), null));\n+                                settingInfos.add(new SettingInfo(paramType, method.getName()));\n@@ -288,2 +276,2 @@\n-        fieldInfos.add(new FieldInfo(\"startTime\", Type.LONG_TYPE.getDescriptor(), classNode.name));\n-        fieldInfos.add(new FieldInfo(\"duration\", Type.LONG_TYPE.getDescriptor(), classNode.name));\n+        fieldInfos.add(new FieldInfo(\"startTime\", Type.LONG_TYPE.getDescriptor()));\n+        fieldInfos.add(new FieldInfo(\"duration\", Type.LONG_TYPE.getDescriptor()));\n@@ -292,1 +280,1 @@\n-                FieldInfo fi = new FieldInfo(field.name, field.desc, classNode.name);\n+                FieldInfo fi = new FieldInfo(field.name, field.desc);\n@@ -306,1 +294,1 @@\n-                            fieldInfos.add(new FieldInfo(fieldName, fieldType.getDescriptor(), internalClassName));\n+                            fieldInfos.add(new FieldInfo(fieldName, fieldType.getDescriptor()));\n@@ -577,1 +565,1 @@\n-                    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), field.fieldName, field.fieldDescriptor);\n+                    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), field.name, field.descriptor);\n@@ -636,2 +624,2 @@\n-            int index = 0;\n-            for (SettingInfo si : settingInfos) {\n+            for (int index = 0; index < settingInfos.size(); index++) {\n+                SettingInfo si = settingInfos.get(index);\n@@ -651,1 +639,0 @@\n-                index++;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    public static EventWriterMethod lookupMethod(FieldInfo v) {\n+    public static EventWriterMethod lookupMethod(FieldInfo field) {\n@@ -72,1 +72,1 @@\n-        if (v.fieldName().equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n+        if (field.name().equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n@@ -76,1 +76,1 @@\n-            if (v.fieldDescriptor().equals(m.typeDescriptor)) {\n+            if (field.descriptor().equals(m.typeDescriptor)) {\n@@ -80,1 +80,1 @@\n-        throw new Error(\"Unknown type \" + v.fieldDescriptor());\n+        throw new Error(\"Unknown type \" + field.descriptor());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterMethod.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-    private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec, SettingControl[] settings) {\n+    private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec) {\n@@ -194,1 +194,1 @@\n-                var argClasses = new Class<?>[] { EventType.class, EventControl.class, SettingControl[].class };\n+                var argClasses = new Class<?>[] { EventType.class, EventControl.class};\n@@ -199,1 +199,1 @@\n-            return cachedEventConfigurationConstructor.newInstance(eventType, ec, settings);\n+            return cachedEventConfigurationConstructor.newInstance(eventType, ec);\n@@ -212,7 +212,1 @@\n-        List<SettingInfo> settingInfos = ec.getSettingInfos();\n-        SettingControl[] settings = new SettingControl[settingInfos.size()];\n-        int index = 0;\n-        for (var settingInfo : settingInfos) {\n-            settings[index++] = settingInfo.settingControl();\n-        }\n-        EventConfiguration configuration = newEventConfiguration(eventType, ec, settings);\n+        EventConfiguration configuration = newEventConfiguration(eventType, ec);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    private EventConfiguration(EventType eventType, EventControl eventControl, SettingControl[] settings) {\n+    private EventConfiguration(EventType eventType, EventControl eventControl) {\n@@ -47,1 +47,1 @@\n-        this.settings = settings;\n+        this.settings = eventControl.getSettingControls().toArray(new SettingControl[0]);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventConfiguration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -136,0 +141,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -176,0 +186,7 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     * @throws ExecutionControl.EngineTerminationException {@inheritDoc}\n+     * @throws ExecutionControl.NotImplementedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/DirectExecutionControl.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -113,0 +113,7 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     * @throws ExecutionControl.EngineTerminationException {@inheritDoc}\n+     * @throws ExecutionControl.NotImplementedException {@inheritDoc}\n+     *\/\n@@ -119,0 +126,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/RemoteExecutionControl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -108,0 +113,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -154,0 +164,7 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     * @throws ExecutionControl.EngineTerminationException {@inheritDoc}\n+     * @throws ExecutionControl.NotImplementedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/StreamingExecutionControl.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -733,1 +733,1 @@\n-            timeoutLeft -= System.currentTimeMillis() - start;\n+            timeoutLeft -= (int) (System.currentTimeMillis() - start);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsClient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.vm.ci.riscv64.RISCV64;\n@@ -33,0 +34,1 @@\n+import jdk.vm.ci.code.test.riscv64.RISCV64TestAssembler;\n@@ -79,0 +81,2 @@\n+        } else if (arch instanceof RISCV64) {\n+            return new RISCV64TestAssembler(codeCache, config);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/CodeInstallationTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/DataPatchTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/InterpreterFrameSizeTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -37,1 +37,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/MaxOopMapStackOffsetTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -37,1 +37,2 @@\n- * @compile CodeInstallationTest.java TestHotSpotVMConfig.java NativeCallTest.java TestAssembler.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java TestHotSpotVMConfig.java NativeCallTest.java TestAssembler.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/NativeCallTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleCodeInstallationTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleDebugInfoTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/VirtualObjectDebugInfoTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,542 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.vm.ci.code.test.riscv64;\n+\n+import jdk.vm.ci.code.CallingConvention;\n+import jdk.vm.ci.code.CodeCacheProvider;\n+import jdk.vm.ci.code.DebugInfo;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.RegisterValue;\n+import jdk.vm.ci.code.StackSlot;\n+import jdk.vm.ci.code.site.ConstantReference;\n+import jdk.vm.ci.code.site.DataSectionReference;\n+import jdk.vm.ci.code.test.TestAssembler;\n+import jdk.vm.ci.code.test.TestHotSpotVMConfig;\n+import jdk.vm.ci.hotspot.HotSpotCallingConventionType;\n+import jdk.vm.ci.hotspot.HotSpotConstant;\n+import jdk.vm.ci.hotspot.HotSpotForeignCallTarget;\n+import jdk.vm.ci.meta.AllocatableValue;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.VMConstant;\n+import jdk.vm.ci.riscv64.RISCV64;\n+import jdk.vm.ci.riscv64.RISCV64Kind;\n+\n+public class RISCV64TestAssembler extends TestAssembler {\n+\n+    private static final Register scratchRegister = RISCV64.x5;\n+    private static final Register doubleScratch = RISCV64.f5;\n+\n+    public RISCV64TestAssembler(CodeCacheProvider codeCache, TestHotSpotVMConfig config) {\n+        super(codeCache, config,\n+              16 \/* initialFrameSize *\/, 16 \/* stackAlignment *\/,\n+              RISCV64Kind.DWORD \/* narrowOopKind *\/,\n+              \/* registers *\/\n+              RISCV64.x10, RISCV64.x11, RISCV64.x12, RISCV64.x13,\n+              RISCV64.x14, RISCV64.x15, RISCV64.x16, RISCV64.x17);\n+    }\n+\n+    private static int f(int val, int msb, int lsb) {\n+        int nbits = msb - lsb + 1;\n+        assert val >= 0;\n+        assert val < (1 << nbits);\n+        assert msb >= lsb;\n+        return val << lsb;\n+    }\n+\n+    private static int f(Register r, int msb, int lsb) {\n+        assert msb - lsb == 4;\n+        return f(r.encoding, msb, lsb);\n+    }\n+\n+    private static int instructionImmediate(int imm, int rs1, int funct, int rd, int opcode) {\n+        return f(imm, 31, 20) | f(rs1, 19, 15) | f(funct, 14, 12) | f(rd, 11, 7) | f(opcode, 6, 0);\n+    }\n+\n+    private static int instructionRegister(int funct7, int rs2, int rs1, int funct3, int rd, int opcode) {\n+        return f(funct7, 31, 25) | f(rs2, 24, 20) | f(rs1, 19, 15) | f(funct3, 14, 12) | f(rd, 11, 7) | f(opcode, 6, 0);\n+    }\n+\n+    private void emitNop() {\n+        code.emitInt(instructionImmediate(0, 0, 0b000, 0, 0b0010011));\n+    }\n+\n+    private void emitAdd(Register Rd, Register Rm, Register Rn) {\n+        \/\/ ADD\n+        code.emitInt(instructionRegister(0b0000000, Rn.encoding, Rm.encoding, 0b000, Rd.encoding, 0b0110011));\n+    }\n+\n+    private void emitAdd(Register Rd, Register Rn, int imm12) {\n+        \/\/ ADDI\n+        code.emitInt(instructionImmediate(imm12 & 0xfff, Rn.encoding, 0b000, Rd.encoding, 0b0010011));\n+    }\n+\n+    private void emitAddW(Register Rd, Register Rn, int imm12) {\n+        \/\/ ADDIW\n+        code.emitInt(instructionImmediate(imm12 & 0xfff, Rn.encoding, 0b000, Rd.encoding, 0b0011011));\n+    }\n+\n+    private void emitSub(Register Rd, Register Rn, int imm12) {\n+        \/\/ SUBI\n+        emitAdd(Rd, Rn, -imm12);;\n+    }\n+\n+    private void emitSub(Register Rd, Register Rm, Register Rn) {\n+        \/\/ SUB\n+        code.emitInt(instructionRegister(0b0100000, Rn.encoding, Rm.encoding, 0b000, Rd.encoding, 0b0110011));\n+    }\n+\n+    private void emitMv(Register Rd, Register Rn) {\n+        \/\/ MV\n+        code.emitInt(instructionRegister(0b0000000, 0, Rn.encoding, 0b000, Rd.encoding, 0b0110011));\n+    }\n+\n+    private void emitShiftLeft(Register Rd, Register Rn, int shift) {\n+        \/\/ SLLI\n+        code.emitInt(instructionImmediate(shift & 0x3f, Rn.encoding, 0b001, Rd.encoding, 0b0010011));\n+    }\n+\n+    private void emitShiftRight(Register Rd, Register Rn, int shift) {\n+        \/\/ SRLI\n+        code.emitInt(instructionImmediate(shift & 0x3f, Rn.encoding, 0b101, Rd.encoding, 0b0010011));\n+    }\n+\n+    private void emitLui(Register Rd, int imm20) {\n+        \/\/ LUI\n+        code.emitInt(f(imm20, 31, 12) | f(Rd, 11, 7) | f(0b0110111, 6, 0));\n+    }\n+\n+    private void emitAuipc(Register Rd, int imm20) {\n+        \/\/ AUIPC\n+        code.emitInt(f(imm20, 31, 12) | f(Rd, 11, 7) | f(0b0010111, 6, 0));\n+    }\n+\n+    private void emitLoadImmediate(Register Rd, int imm32) {\n+        long upper = imm32, lower = imm32;\n+        lower = (lower << 52) >> 52;\n+        upper -= lower;\n+        upper = (int) upper;\n+        emitLui(Rd, ((int) (upper >> 12)) & 0xfffff);\n+        emitAddW(Rd, Rd, (int) lower);\n+    }\n+\n+    private void emitLoadRegister(Register Rd, RISCV64Kind kind, Register Rn, int offset) {\n+        \/\/ LB\/LH\/LW\/LD (immediate)\n+        assert offset >= 0;\n+        int size = 0;\n+        int opc = 0;\n+        switch (kind) {\n+            case BYTE: size = 0b000; opc = 0b0000011; break;\n+            case WORD: size = 0b001; opc = 0b0000011; break;\n+            case DWORD: size = 0b010; opc = 0b0000011; break;\n+            case QWORD: size = 0b011; opc = 0b0000011; break;\n+            case SINGLE: size = 0b010; opc = 0b0000111; break;\n+            case DOUBLE: size = 0b011; opc = 0b0000111; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f(offset, 31, 20) | f(Rn, 19, 15) | f(size, 14, 12) | f(Rd, 11, 7) | f(opc, 6, 0));\n+    }\n+\n+    private void emitStoreRegister(Register Rd, RISCV64Kind kind, Register Rn, int offset) {\n+        \/\/ SB\/SH\/SW\/SD (immediate)\n+        assert offset >= 0;\n+        int size = 0;\n+        int opc = 0;\n+        switch (kind) {\n+            case BYTE: size = 0b000; opc = 0b0100011; break;\n+            case WORD: size = 0b001; opc = 0b0100011; break;\n+            case DWORD: size = 0b010; opc = 0b0100011; break;\n+            case QWORD: size = 0b011; opc = 0b0100011; break;\n+            case SINGLE: size = 0b010; opc = 0b0100111; break;\n+            case DOUBLE: size = 0b011; opc = 0b0100111; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f((offset >> 5), 31, 25) | f(Rd, 24, 20) | f(Rn, 19, 15) | f(size, 14, 12) | f((offset & 0x1f), 11, 7) | f(opc, 6, 0));\n+    }\n+\n+    private void emitJalr(Register Rd, Register Rn, int imm) {\n+        code.emitInt(instructionImmediate(imm & 0xfff, Rn.encoding, 0b000, Rd.encoding, 0b1100111));\n+    }\n+\n+    private void emitFmv(Register Rd, RISCV64Kind kind, Register Rn) {\n+        int funct = 0;\n+        switch (kind) {\n+            case SINGLE: funct = 0b1111000; break;\n+            case DOUBLE: funct = 0b1111001; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(instructionRegister(funct, 0b00000, Rn.encoding, 0b000, Rd.encoding, 0b1010011));\n+    }\n+\n+    @Override\n+    public void emitGrowStack(int size) {\n+        assert size % 16 == 0;\n+        if (size > -2048 && size < 0) {\n+            emitAdd(RISCV64.x2, RISCV64.x2, -size);\n+        } else if (size == 0) {\n+            \/\/ No-op\n+        } else if (size < 2048) {\n+            emitSub(RISCV64.x2, RISCV64.x2, size);\n+        } else if (size < 65535) {\n+            emitLoadImmediate(scratchRegister, size);\n+            emitSub(RISCV64.x2, RISCV64.x2, scratchRegister);\n+        } else {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    @Override\n+    public void emitPrologue() {\n+        \/\/ Must be patchable by NativeJump::patch_verified_entry\n+        emitNop();\n+        emitAdd(RISCV64.x2, RISCV64.x2, -32); \/\/ addi sp sp -32\n+        emitStoreRegister(RISCV64.x8, RISCV64Kind.QWORD, RISCV64.x2, 0); \/\/ sd x8 sp(0)\n+        emitStoreRegister(RISCV64.x1, RISCV64Kind.QWORD, RISCV64.x2, 8); \/\/ sd x1 sp(8)\n+        emitMv(RISCV64.x8, RISCV64.x2); \/\/ mv x8, x2\n+\n+        setDeoptRescueSlot(newStackSlot(RISCV64Kind.QWORD));\n+    }\n+\n+    @Override\n+    public void emitEpilogue() {\n+        recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);\n+        recordCall(new HotSpotForeignCallTarget(config.handleDeoptStub), 6*4, true, null);\n+        emitCall(0xdeaddeaddeadL);\n+    }\n+\n+    @Override\n+    public void emitCallPrologue(CallingConvention cc, Object... prim) {\n+        emitGrowStack(cc.getStackSize());\n+        frameSize += cc.getStackSize();\n+        AllocatableValue[] args = cc.getArguments();\n+        for (int i = 0; i < args.length; i++) {\n+            emitLoad(args[i], prim[i]);\n+        }\n+    }\n+\n+    @Override\n+    public void emitCallEpilogue(CallingConvention cc) {\n+        emitGrowStack(-cc.getStackSize());\n+        frameSize -= cc.getStackSize();\n+    }\n+\n+    @Override\n+    public void emitCall(long addr) {\n+        emitMovPtrHelper(scratchRegister, addr);\n+        emitJalr(RISCV64.x1, scratchRegister, (int) (addr & 0x3f));\n+    }\n+\n+    @Override\n+    public void emitLoad(AllocatableValue av, Object prim) {\n+        if (av instanceof RegisterValue) {\n+            Register reg = ((RegisterValue) av).getRegister();\n+            if (prim instanceof Float) {\n+                emitLoadFloat(reg, (Float) prim);\n+            } else if (prim instanceof Double) {\n+                emitLoadDouble(reg, (Double) prim);\n+            } else if (prim instanceof Integer) {\n+                emitLoadInt(reg, (Integer) prim);\n+            } else if (prim instanceof Long) {\n+                emitLoadLong(reg, (Long) prim);\n+            }\n+        } else if (av instanceof StackSlot) {\n+            StackSlot slot = (StackSlot) av;\n+            if (prim instanceof Float) {\n+                emitFloatToStack(slot, emitLoadFloat(doubleScratch, (Float) prim));\n+            } else if (prim instanceof Double) {\n+                emitDoubleToStack(slot, emitLoadDouble(doubleScratch, (Double) prim));\n+            } else if (prim instanceof Integer) {\n+                emitIntToStack(slot, emitLoadInt(scratchRegister, (Integer) prim));\n+            } else if (prim instanceof Long) {\n+                emitLongToStack(slot, emitLoadLong(scratchRegister, (Long) prim));\n+            } else {\n+                assert false : \"Unimplemented\";\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown value \" + av);\n+        }\n+    }\n+\n+    private void emitLoad32(Register ret, int addr) {\n+        long upper = addr, lower = addr;\n+        lower = (lower << 52) >> 52;\n+        upper -= lower;\n+        upper = (int) upper;\n+        emitLui(ret, ((int) (upper >> 12)) & 0xfffff);\n+        emitAdd(ret, ret, (int) lower);\n+    }\n+\n+    private void emitMovPtrHelper(Register ret, long addr) {\n+        \/\/ 48-bit VA\n+        assert (addr >> 48) == 0 : \"invalid pointer\" + Long.toHexString(addr);\n+        emitLoad32(ret, (int) (addr >> 17));\n+        emitShiftLeft(ret, ret, 11);\n+        emitAdd(ret, ret, (int) ((addr >> 6) & 0x7ff));\n+        emitShiftLeft(ret, ret, 6);\n+    }\n+\n+    private void emitLoadPointer32(Register ret, int addr) {\n+        emitLoadImmediate(ret, addr);\n+        \/\/ Lui sign-extends the value, which we do not want\n+        emitShiftLeft(ret, ret, 32);\n+        emitShiftRight(ret, ret, 32);\n+    }\n+\n+    private void emitLoadPointer48(Register ret, long addr) {\n+        emitMovPtrHelper(ret, addr);\n+        emitAdd(ret, ret, (int) (addr & 0x3f));\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(HotSpotConstant c) {\n+        recordDataPatchInCode(new ConstantReference((VMConstant) c));\n+\n+        Register ret = newRegister();\n+        if (c.isCompressed()) {\n+            emitLoadPointer32(ret, 0xdeaddead);\n+        } else {\n+            emitLoadPointer48(ret, 0xdeaddeaddeadL);\n+        }\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(Register b, int offset) {\n+        Register ret = newRegister();\n+        emitLoadRegister(ret, RISCV64Kind.QWORD, b, offset & 0xfff);\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadNarrowPointer(DataSectionReference ref) {\n+        recordDataPatchInCode(ref);\n+\n+        Register ret = newRegister();\n+        emitAuipc(ret, 0xdead >> 11);\n+        emitLoadRegister(ret, RISCV64Kind.DWORD, ret, 0xdead & 0x7ff);\n+        \/\/ The value is sign-extendsed, which we do not want\n+        emitShiftLeft(ret, ret, 32);\n+        emitShiftRight(ret, ret, 32);\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(DataSectionReference ref) {\n+        recordDataPatchInCode(ref);\n+\n+        Register ret = newRegister();\n+        emitAuipc(ret, 0xdead >> 11);\n+        emitLoadRegister(ret, RISCV64Kind.QWORD, ret, 0xdead & 0x7ff);\n+        return ret;\n+    }\n+\n+    private Register emitLoadDouble(Register reg, double c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+        data.emitDouble(c);\n+\n+        recordDataPatchInCode(ref);\n+        emitAuipc(scratchRegister, 0xdead >> 11);\n+        emitLoadRegister(scratchRegister, RISCV64Kind.QWORD, scratchRegister, 0xdead & 0x7ff);\n+        if (reg.getRegisterCategory().equals(RISCV64.FP)) {\n+            emitFmv(reg, RISCV64Kind.DOUBLE, scratchRegister);\n+        } else {\n+            emitMv(reg, scratchRegister);\n+        }\n+        return reg;\n+    }\n+\n+    private Register emitLoadFloat(Register reg, float c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+        data.emitFloat(c);\n+\n+        recordDataPatchInCode(ref);\n+        emitAuipc(scratchRegister, 0xdead >> 11);\n+        emitLoadRegister(scratchRegister, RISCV64Kind.DWORD, scratchRegister, 0xdead & 0x7ff);\n+        if (reg.getRegisterCategory().equals(RISCV64.FP)) {\n+            emitFmv(reg, RISCV64Kind.SINGLE, scratchRegister);\n+        } else {\n+            emitMv(reg, scratchRegister);\n+        }\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadFloat(float c) {\n+        Register ret = RISCV64.f10;\n+        return emitLoadFloat(ret, c);\n+    }\n+\n+    private Register emitLoadLong(Register reg, long c) {\n+        long lower = c & 0xffffffff;\n+        lower = lower - ((lower << 44) >> 44);\n+        emitLoad32(reg, (int) ((c >> 32) & 0xffffffff));\n+        emitShiftLeft(reg, reg, 12);\n+        emitAdd(reg, reg, (int) ((lower >> 20) & 0xfff));\n+        emitShiftLeft(reg, reg, 12);\n+        emitAdd(reg, reg, (int) ((c << 44) >> 52));\n+        emitShiftLeft(reg, reg, 8);\n+        emitAdd(reg, reg, (int) (c & 0xff));\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadLong(long c) {\n+        Register ret = newRegister();\n+        return emitLoadLong(ret, c);\n+    }\n+\n+    private Register emitLoadInt(Register reg, int c) {\n+        emitLoadImmediate(reg, c);\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadInt(int c) {\n+        Register ret = newRegister();\n+        return emitLoadInt(ret, c);\n+    }\n+\n+    @Override\n+    public Register emitIntArg0() {\n+        return codeCache.getRegisterConfig()\n+            .getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)\n+            .get(0);\n+    }\n+\n+    @Override\n+    public Register emitIntArg1() {\n+        return codeCache.getRegisterConfig()\n+            .getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)\n+            .get(1);\n+    }\n+\n+    @Override\n+    public Register emitIntAdd(Register a, Register b) {\n+        emitAdd(a, a, b);\n+        return a;\n+    }\n+\n+    @Override\n+    public void emitTrap(DebugInfo info) {\n+        \/\/ Dereference null pointer\n+        emitAdd(scratchRegister, RISCV64.x0, 0);\n+        recordImplicitException(info);\n+        emitLoadRegister(RISCV64.x0, RISCV64Kind.QWORD, scratchRegister, 0);\n+    }\n+\n+    @Override\n+    public void emitIntRet(Register a) {\n+        emitMv(RISCV64.x10, a);\n+        emitMv(RISCV64.x2, RISCV64.x8);  \/\/ mv sp, x8\n+        emitLoadRegister(RISCV64.x8, RISCV64Kind.QWORD, RISCV64.x2, 0);  \/\/ ld x8 0(sp)\n+        emitLoadRegister(RISCV64.x1, RISCV64Kind.QWORD, RISCV64.x2, 8);  \/\/ ld x1 8(sp)\n+        emitAdd(RISCV64.x2, RISCV64.x2, 32);  \/\/ addi sp sp 32\n+        emitJalr(RISCV64.x0, RISCV64.x1, 0);  \/\/ ret\n+    }\n+\n+    @Override\n+    public void emitFloatRet(Register a) {\n+        assert a == RISCV64.f10 : \"Unimplemented move \" + a;\n+        emitMv(RISCV64.x2, RISCV64.x8);  \/\/ mv sp, x8\n+        emitLoadRegister(RISCV64.x8, RISCV64Kind.QWORD, RISCV64.x2, 0);  \/\/ ld x8 0(sp)\n+        emitLoadRegister(RISCV64.x1, RISCV64Kind.QWORD, RISCV64.x2, 8);  \/\/ ld x1 8(sp)\n+        emitAdd(RISCV64.x2, RISCV64.x2, 32);  \/\/ addi sp sp 32\n+        emitJalr(RISCV64.x0, RISCV64.x1, 0);  \/\/ ret\n+    }\n+\n+    @Override\n+    public void emitPointerRet(Register a) {\n+        emitIntRet(a);\n+    }\n+\n+    @Override\n+    public StackSlot emitPointerToStack(Register a) {\n+        return emitLongToStack(a);\n+    }\n+\n+    @Override\n+    public StackSlot emitNarrowPointerToStack(Register a) {\n+        return emitIntToStack(a);\n+    }\n+\n+    @Override\n+    public Register emitUncompressPointer(Register compressed, long base, int shift) {\n+        if (shift > 0) {\n+            emitShiftLeft(compressed, compressed, shift);\n+        }\n+\n+        if (base != 0) {\n+            emitLoadLong(scratchRegister, base);\n+            emitAdd(compressed, compressed, scratchRegister);\n+        }\n+\n+        return compressed;\n+    }\n+\n+    private StackSlot emitDoubleToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.DOUBLE, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitDoubleToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.DOUBLE);\n+        return emitDoubleToStack(ret, a);\n+    }\n+\n+    private StackSlot emitFloatToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.SINGLE, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitFloatToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.SINGLE);\n+        return emitFloatToStack(ret, a);\n+    }\n+\n+    private StackSlot emitIntToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.DWORD, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitIntToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.DWORD);\n+        return emitIntToStack(ret, a);\n+    }\n+\n+    private StackSlot emitLongToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.QWORD, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitLongToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.QWORD);\n+        return emitLongToStack(ret, a);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/riscv64\/RISCV64TestAssembler.java","additions":542,"deletions":0,"binary":false,"changes":542,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- *      -XX:StressLongCountedLoop=0\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:StressLongCountedLoop=0\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestRemoveEmptyLoop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,4 @@\n- * @summary Test various reverse bytes ideal transforms on X86(AVX2, AVX512) and AARCH64(NEON)\n+ * @summary Test various reverse bytes ideal transforms on X86(AVX2, AVX512) and AArch64(NEON).\n+ *          For AArch64(SVE), we have a specific optimization,\n+ *          ReverseBytesV (ReverseBytesV X MASK) MASK => X, which eliminates both ReverseBytesV\n+ *          nodes. The test cases for AArch64(SVE) are in TestReverseByteTransformsSVE.java.\n@@ -42,0 +45,1 @@\n+ * @requires !(vm.cpu.features ~= \".*sve.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransforms.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        runTest(AppendClasspath::testDefaultBase);\n+        runTest(RelativePath::testDefaultBase);\n@@ -57,0 +57,10 @@\n+\n+        \/\/ Create CDS Archive\n+        dump(topArchiveName, \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=debug\",\n+            \"-cp\", appJar + File.pathSeparator + appJar2,\n+            \"HelloMore\")\n+            .assertNormalExit(output-> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+            });\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/RelativePath.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @bug 7124710\n+ *\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/test\/lib\n+ *\n+ * @comment main\/othervm\/native -Xlog:redefine*=trace -agentlib:RedefineRetransform RedefineRetransform\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 1\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 2\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 3\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 4\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 5\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 6\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+\/*\n+ * The test verifies that after interleaved RedefineClasses\/RetransformClasses calls\n+ * JVMTI passes correct class bytes to ClassFileLoadHook (as per JVMTI spec).\n+ * To distinguish class version the test instruments test class overriding runtime-visible annotation.\n+ *\/\n+public class RedefineRetransform {\n+    static {\n+        System.loadLibrary(\"RedefineRetransform\");\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface ClassVersion {\n+        int value();\n+    }\n+\n+    \/\/ Use runtime-visible annotation to specify class version.\n+    @ClassVersion(0)\n+    static class TestClass {\n+        public TestClass() { }\n+    }\n+\n+    \/\/ Redefines testClass with classBytes, instruments with classLoadHookBytes (if != null).\n+    \/\/ Returns class bytes passed to ClassFileLoadHook or null on error.\n+    private static native byte[] nRedefine(Class testClass, byte[] classBytes, byte[] classLoadHookBytes);\n+    \/\/ Retransforms testClass, instruments with classBytes (if != null).\n+    \/\/ Returns class bytes passed to ClassFileLoadHook or null on error.\n+    private static native byte[] nRetransform(Class testClass, byte[] classBytes);\n+\n+    \/\/ Class bytes for initial TestClass (ClassVersion == 0).\n+    private static byte[] initialClassBytes;\n+\n+    private static class VersionScanner extends ClassVisitor {\n+        private Integer detectedVersion;\n+        private Integer versionToSet;\n+        \/\/ to get version\n+        public VersionScanner() {\n+            super(Opcodes.ASM7);\n+        }\n+        \/\/ to set version\n+        public VersionScanner(int verToSet, ClassVisitor classVisitor) {\n+            super(Opcodes.ASM7, classVisitor);\n+            versionToSet = verToSet;\n+        }\n+\n+        public int detectedVersion() {\n+            if (detectedVersion == null) {\n+                throw new RuntimeException(\"Version not detected\");\n+            }\n+            return detectedVersion;\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n+            \/\/log(\"visitAnnotation: descr = '\" + descriptor + \"', visible = \" + visible);\n+            if (Type.getDescriptor(ClassVersion.class).equals(descriptor)) {\n+                return new AnnotationVisitor(Opcodes.ASM7, super.visitAnnotation(descriptor, visible)) {\n+                    @Override\n+                    public void visit(String name, Object value) {\n+                        \/\/log(\"visit: name = '\" + name + \"', value = \" + value\n+                        \/\/        + \" (\" + (value == null ? \"N\/A\" : value.getClass()) + \")\");\n+                        if (\"value\".equals(name) && value instanceof Integer intValue) {\n+                            detectedVersion = intValue;\n+                            if (versionToSet != null) {\n+                                \/\/log(\"replace with \" + versionToSet);\n+                                value = versionToSet;\n+                            }\n+                        }\n+                        super.visit(name, value);\n+                    }\n+                };\n+            }\n+            return super.visitAnnotation(descriptor, visible);\n+        }\n+    }\n+\n+    \/\/ Generates TestClass class bytes with the specified ClassVersion value.\n+    private static byte[] getClassBytes(int ver) {\n+        if (ver < 0) {\n+            return null;\n+        }\n+        ClassWriter cw = new ClassWriter(0);\n+        ClassReader cr = new ClassReader(initialClassBytes);\n+        cr.accept(new VersionScanner(ver, cw), 0);\n+        return cw.toByteArray();\n+    }\n+\n+    \/\/ Extracts ClassVersion values from the provided class bytes.\n+    private static int getClassBytesVersion(byte[] classBytes) {\n+        ClassReader cr = new ClassReader(classBytes);\n+        VersionScanner scanner = new VersionScanner();\n+        cr.accept(scanner, 0);\n+        return scanner.detectedVersion();\n+    }\n+\n+    static void init() {\n+        try {\n+            initialClassBytes = TestClass.class.getClassLoader()\n+                    .getResourceAsStream(\"RedefineRetransform$TestClass.class\")\n+                    .readAllBytes();\n+            log(\"Read TestClass bytes: \" + initialClassBytes.length);\n+        } catch (IOException ex) {\n+            throw new RuntimeException(\"Failed to read class bytes\", ex);\n+        }\n+    }\n+\n+    \/\/ Redefines TestClass to the version specified.\n+    static void redefine(int ver) {\n+        redefine(ver, -1);\n+    }\n+\n+    \/\/ Redefines TestClass to the version specified\n+    \/\/ instrumenting (from ClassFileLoadHook) with 'classLoadHookVer' class bytes (if >= 0).\n+    \/\/ Also verifies that class bytes passed to ClassFileLoadHook have correct version (ver).\n+    static void redefine(int ver, int classLoadHookVer) {\n+        byte[] classBytes = getClassBytes(ver);\n+        byte[] classLoadHookBytes = getClassBytes(classLoadHookVer);\n+\n+        byte[] hookClassBytes = nRedefine(TestClass.class, classBytes, classLoadHookBytes);\n+        if (hookClassBytes == null) {\n+            throw new RuntimeException(\"Redefine error (ver = \" + ver + \")\");\n+        }\n+        \/\/ verify ClassFileLoadHook gets the expected class bytes\n+        int hookVer = getClassBytesVersion(hookClassBytes);\n+        if (hookVer != ver) {\n+            throw new RuntimeException(\"CLFH got unexpected version: \"  + hookVer\n+                    + \" (expected \" + ver + \")\");\n+        }\n+    }\n+\n+    \/\/ Retransforms TestClass instrumenting (from ClassFileLoadHook) with 'ver' class bytes (if >= 0).\n+    \/\/ Verifies that class bytes passed to ClassFileLoadHook have correct version (expectedVer).\n+    static void retransform(int ver, int expectedVer) {\n+        byte[] classBytes = getClassBytes(ver);\n+        byte[] hookClassBytes = nRetransform(TestClass.class, classBytes);\n+        int hookVer = getClassBytesVersion(hookClassBytes);\n+        if (hookVer != expectedVer) {\n+            throw new RuntimeException(\"CLFH got unexpected version: \"  + hookVer\n+                    + \" (expected \" + expectedVer + \")\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int testCase;\n+        try {\n+            testCase = Integer.valueOf(args[0]);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Single numeric argument expected\", ex);\n+        }\n+        init();\n+        switch (testCase) {\n+        case 1:\n+            test(\"Redefine-Retransform-Retransform\", () -> {\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                retransform(3, 1);  \/\/ uses existing cache\n+            });\n+            break;\n+\n+        case 2:\n+            test(\"Redefine-Retransform-Redefine-Redefine\", () -> {\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                redefine(3);        \/\/ resets cached class bytes to nullptr\n+                redefine(4);        \/\/ cached class bytes are not set\n+            });\n+            break;\n+\n+        case 3:\n+            test(\"Redefine-Retransform-Redefine-Retransform\", () -> {\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                redefine(3);        \/\/ resets cached class bytes to nullptr\n+                retransform(4, 3);  \/\/ sets cached class bytes to ver 3\n+            });\n+            break;\n+\n+        case 4:\n+            test(\"Retransform-Redefine-Retransform-Retransform\", () -> {\n+                retransform(1, 0);  \/\/ sets cached class bytes to ver 0 (initially loaded)\n+                redefine(2);        \/\/ resets cached class bytes to nullptr\n+                retransform(3, 2);  \/\/ sets cached class bytes to ver 2\n+                retransform(4, 2);  \/\/ uses existing cache\n+            });\n+            break;\n+\n+        case 5:\n+            test(\"Redefine-Retransform-Redefine-Retransform with CFLH\", () -> {\n+                redefine(1, 5);     \/\/ CFLH sets cached class bytes to ver 1\n+                retransform(2, 1);  \/\/ uses existing cache\n+                redefine(3, 6);     \/\/ resets cached class bytes to nullptr,\n+                                    \/\/ CFLH sets cached class bytes to ver 3\n+                retransform(4, 3);  \/\/ uses existing cache\n+            });\n+            break;\n+\n+        case 6:\n+            test(\"Retransform-Redefine-Retransform-Retransform with CFLH\", () -> {\n+                retransform(1, 0);  \/\/ sets cached class bytes to ver 0 (initially loaded)\n+                redefine(2, 5);     \/\/ resets cached class bytes to nullptr,\n+                                    \/\/ CFLH sets cached class bytes to ver 2\n+                retransform(3, 2);  \/\/ uses existing cache\n+                retransform(4, 2);  \/\/ uses existing cache\n+            });\n+            break;\n+        }\n+    }\n+\n+    private static void log(Object msg) {\n+        System.out.println(msg);\n+    }\n+\n+    private interface Test {\n+        void test();\n+    }\n+\n+    private static void test(String name, Test theTest) {\n+        log(\">>Test: \" + name);\n+        theTest.test();\n+        log(\"<<Test: \" + name + \" - OK\");\n+        log(\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+\/\/ set by Agent_OnLoad\n+static jvmtiEnv* jvmti = nullptr;\n+\n+static const char testClassName[] = \"RedefineRetransform$TestClass\";\n+\n+static void _log(const char* format, ...) {\n+    va_list args;\n+    va_start(args, format);\n+    vprintf(format, args);\n+    va_end(args);\n+    fflush(0);\n+}\n+\n+static bool isTestClass(const char* name) {\n+    return name != nullptr && strcmp(name, testClassName) == 0;\n+}\n+\n+\/*\n+ * Helper class for data exchange between RedefineClasses\/RetransformClasses and\n+ * ClassFileLoadHook callback (saves class bytes to be passed to CFLH,\n+ * allows setting new class bytes to return from CFLH).\n+ * Callers create an instance on the stack, ClassFileLoadHook handler uses getInstance().\n+ *\/\n+class ClassFileLoadHookHelper {\n+    const char* mode;   \/\/ for logging only\n+    bool eventEnabled;\n+    JNIEnv* env;\n+    jbyteArray classBytes = nullptr;\n+\n+    unsigned char* savedClassBytes = nullptr;\n+    jint savedClassBytesLen = 0;\n+\n+    \/\/ single instance\n+    static ClassFileLoadHookHelper *instance;\n+public:\n+    ClassFileLoadHookHelper(const char* mode, JNIEnv* jni_env, jbyteArray hookClassBytes)\n+        : mode(mode), eventEnabled(false), env(jni_env), classBytes(nullptr),\n+        savedClassBytes(nullptr), savedClassBytesLen(0)\n+    {\n+        _log(\">>%s\\n\", mode);\n+        if (hookClassBytes != nullptr) {\n+            classBytes = (jbyteArray)env->NewGlobalRef(hookClassBytes);\n+        }\n+    }\n+\n+    ~ClassFileLoadHookHelper() {\n+        \/\/ cleanup on error\n+        stop();\n+        if (classBytes != nullptr) {\n+            env->DeleteGlobalRef(classBytes);\n+        }\n+        if (savedClassBytes != nullptr) {\n+            jvmti->Deallocate(savedClassBytes);\n+        }\n+        _log(\"<<%s\\n\", mode);\n+    }\n+\n+    bool start() {\n+        instance = this;\n+        jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"%s: SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", mode, err);\n+            eventEnabled = true;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void stop() {\n+        instance = nullptr;\n+        if (eventEnabled) {\n+            jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+            if (err != JVMTI_ERROR_NONE) {\n+                _log(\"%s: SetEventNotificationMode(JVMTI_DISABLE) error %d\\n\", mode, err);\n+                return;\n+            }\n+            eventEnabled = false;\n+        }\n+    }\n+\n+    \/\/ valid only between start() and stop()\n+    static ClassFileLoadHookHelper* getInstance() {\n+        return instance;\n+    }\n+\n+    bool getHookClassBytes(unsigned char** newClassBytes, jint* newLen) {\n+        if (classBytes != nullptr) {\n+            jsize len = env->GetArrayLength(classBytes);\n+            unsigned char* buf = nullptr;\n+            jvmtiError err = jvmti->Allocate(len, &buf);\n+            if (err != JVMTI_ERROR_NONE) {\n+                _log(\"ClassFileLoadHook: failed to allocate %ld bytes for new class bytes: %d\", len, err);\n+                return false;\n+            }\n+\n+            jbyte* arrayPtr = env->GetByteArrayElements(classBytes, nullptr);\n+            if (arrayPtr == nullptr) {\n+                _log(\"ClassFileLoadHook: failed to get array elements\\n\");\n+                jvmti->Deallocate(buf);\n+                return false;\n+            }\n+\n+            memcpy(buf, arrayPtr, len);\n+\n+            env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n+\n+            *newClassBytes = buf;\n+            *newLen = len;\n+\n+            _log(\"  ClassFileLoadHook: set new class bytes\\n\");\n+        }\n+        return true;\n+    }\n+\n+    void setSavedHookClassBytes(const unsigned char* bytes, jint len) {\n+        jvmtiError err = jvmti->Allocate(len, &savedClassBytes);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"ClassFileLoadHook: failed to allocate %ld bytes for saved class bytes: %d\", len, err);\n+            return;\n+        }\n+        memcpy(savedClassBytes, bytes, len);\n+        savedClassBytesLen = len;\n+    }\n+\n+    jbyteArray getSavedHookClassBytes() {\n+        if (savedClassBytes == nullptr) {\n+            _log(\"%s: savedClassBytes is NULL\\n\", mode);\n+            return nullptr;\n+        }\n+\n+        jbyteArray result = env->NewByteArray(savedClassBytesLen);\n+        if (result == nullptr) {\n+            _log(\"%s: NewByteArray(%ld) failed\\n\", mode, savedClassBytesLen);\n+        } else {\n+            jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n+            if (arrayPtr == nullptr) {\n+                _log(\"%s: Failed to get array elements\\n\", mode);\n+                result = nullptr;\n+            } else {\n+                memcpy(arrayPtr, savedClassBytes, savedClassBytesLen);\n+                env->ReleaseByteArrayElements(result, arrayPtr, JNI_COMMIT);\n+            }\n+        }\n+        return result;\n+    }\n+};\n+\n+ClassFileLoadHookHelper* ClassFileLoadHookHelper::instance = nullptr;\n+\n+\n+extern \"C\" {\n+\n+JNIEXPORT void JNICALL\n+callbackClassFileLoadHook(jvmtiEnv *jvmti_env,\n+        JNIEnv* jni_env,\n+        jclass class_being_redefined,\n+        jobject loader,\n+        const char* name,\n+        jobject protection_domain,\n+        jint class_data_len,\n+        const unsigned char* class_data,\n+        jint* new_class_data_len,\n+        unsigned char** new_class_data) {\n+    if (isTestClass(name)) {\n+        _log(\">>ClassFileLoadHook: %s, %ld bytes, ptr = %p\\n\", name, class_data_len, class_data);\n+\n+        ClassFileLoadHookHelper* helper = ClassFileLoadHookHelper::getInstance();\n+        if (helper == nullptr) {\n+            _log(\"ClassFileLoadHook ERROR: helper instance is not initialized\\n\");\n+            return;\n+        }\n+        \/\/ save class bytes\n+        helper->setSavedHookClassBytes(class_data, class_data_len);\n+        \/\/ set new class bytes\n+        helper->getHookClassBytes(new_class_data, new_class_data_len);\n+\n+        _log(\"<<ClassFileLoadHook\\n\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+    jint res = jvm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_1);\n+    if (res != JNI_OK) {\n+        _log(\"Failed to get JVMTI interface: %ld\\n\", res);\n+        return JNI_ERR;\n+    }\n+\n+    jvmtiCapabilities caps;\n+    memset(&caps, 0, sizeof(caps));\n+\n+    caps.can_redefine_classes = 1;\n+    caps.can_retransform_classes = 1;\n+    jvmtiError err = jvmti->AddCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"Failed to add capabilities: %d\\n\", err);\n+        return JNI_ERR;\n+    }\n+\n+    jvmtiEventCallbacks eventCallbacks;\n+    memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+    eventCallbacks.ClassFileLoadHook = callbackClassFileLoadHook;\n+    err = jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"Error setting event callbacks: %d\\n\", err);\n+        return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM* jvm) {\n+    return;\n+}\n+\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_RedefineRetransform_nRedefine(JNIEnv* env, jclass klass,\n+                                   jclass testClass, jbyteArray classBytes, jbyteArray classLoadHookBytes) {\n+\n+    ClassFileLoadHookHelper helper(\"nRedefine\", env, classLoadHookBytes);\n+\n+    jsize len = env->GetArrayLength(classBytes);\n+    jbyte* arrayPtr = env->GetByteArrayElements(classBytes, nullptr);\n+    if (arrayPtr == nullptr) {\n+        _log(\"nRedefine: Failed to get array elements\\n\");\n+        return nullptr;\n+    }\n+\n+    if (helper.start()) {\n+        jvmtiClassDefinition classDef;\n+        memset(&classDef, 0, sizeof(classDef));\n+        classDef.klass = testClass;\n+        classDef.class_byte_count = len;\n+        classDef.class_bytes = (unsigned char*)arrayPtr;\n+\n+        jvmtiError err = jvmti->RedefineClasses(1, &classDef);\n+\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"nRedefine: RedefineClasses error %d\", err);\n+            \/\/ don't exit here, need to cleanup\n+        }\n+        helper.stop();\n+    }\n+\n+    env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n+\n+    return helper.getSavedHookClassBytes();\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_RedefineRetransform_nRetransform(JNIEnv* env, jclass klass, jclass testClass, jbyteArray classBytes) {\n+\n+    ClassFileLoadHookHelper helper(\"nRetransform\", env, classBytes);\n+    if (helper.start()) {\n+        jvmtiError err = jvmti->RetransformClasses(1, &testClass);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"nRetransform: RetransformClasses error %d\\n\", err);\n+            \/\/ don't exit here, disable CFLH event\n+        }\n+        helper.stop();\n+    }\n+    return helper.getSavedHookClassBytes();\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/libRedefineRetransform.cpp","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -510,1 +510,0 @@\n-java\/io\/BufferedInputStream\/TransferTo.java                     8294541 generic-all\n@@ -668,0 +667,1 @@\n+javax\/swing\/JRadioButton\/4314194\/bug4314194.java 8295006 linux-all\n@@ -752,1 +752,0 @@\n-jdk\/jfr\/event\/runtime\/TestActiveSettingEvent.java               8287832 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6777156\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"linux\")\n+ * @summary Verifies if user is not able to select \"..\/\" beyond\n+ * root file system.\n+ * @run main\/manual TestFileChooserDirectorySelection\n+ *\/\n+\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class TestFileChooserDirectorySelection {\n+    private static JFrame frame;\n+    private static final String INSTRUCTIONS =\n+            \"Double click on the \\\"..\/\\\" entry from directory list.\\n\\n\" +\n+            \"Repeat the same process till the current directory is root \" +\n+            \"i.e \\\" \/ \\\" .\\n\\n\" +\n+            \"If \\\" ..\/ \\\" option is not available at root directory\" +\n+            \", press Pass else Fail.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\n+                \"JFileChooser Test Instructions\", INSTRUCTIONS, 5, 8, 35);\n+        try {\n+            SwingUtilities.invokeAndWait(\n+                    TestFileChooserDirectorySelection::createAndShowUI);\n+            passFailJFrame.awaitAndCheck();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test File Chooser Directory Selection\");\n+        JFileChooser fileChooser = new JFileChooser();\n+        fileChooser.setControlButtonsAreShown(false);\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(\n+                frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.add(fileChooser);\n+        frame.setSize(500, 500);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/gtk\/TestFileChooserDirectorySelection.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -108,0 +108,9 @@\n+\n+        \/\/ Do a short delay to make sure that the debug agent is done processing all\n+        \/\/ ClassPrepare events. Otherwise the debug agent might still be holding on to\n+        \/\/ a reference to a class, which will prevent it from unloading during the GC.\n+        try {\n+            Thread.sleep(5000);\n+        } catch (InterruptedException e) {\n+        }\n+\n@@ -111,2 +120,2 @@\n-        \/\/ Short delay to make sure all ClassUnloadEvents have been sent\n-        \/\/ before VMDeathEvent is genareated.\n+        \/\/ Do a short delay to make sure all ClassUnloadEvents have been sent\n+        \/\/ before VMDeathEvent is generated.\n","filename":"test\/jdk\/com\/sun\/jdi\/ClassUnloadEventTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.awt.event.MouseAdapter;\n@@ -37,1 +38,6 @@\n-import java.awt.event.*;\n+import java.io.File;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import javax.imageio.ImageIO;\n+import javax.swing.SwingUtilities;\n+\n@@ -51,0 +57,4 @@\n+    private static Robot robot;\n+    private static Frame frame;\n+    private static Rectangle currentScreenBounds;\n+\n@@ -53,0 +63,2 @@\n+        robot = new Robot();\n+        robot.setAutoDelay(200);\n@@ -58,2 +70,2 @@\n-            Rectangle bounds = gc.getBounds();\n-            Point point = new Point(bounds.x, bounds.y);\n+            currentScreenBounds = gc.getBounds();\n+            Point point = new Point(currentScreenBounds.x, currentScreenBounds.y);\n@@ -61,3 +73,3 @@\n-            while (point.y < bounds.y + bounds.height - insets.bottom - SIZE) {\n-                while (point.x\n-                        < bounds.x + bounds.width - insets.right - SIZE) {\n+            while (point.y < currentScreenBounds.y + currentScreenBounds.height - insets.bottom - SIZE) {\n+                while (point.x <\n+                           currentScreenBounds.x + currentScreenBounds.width - insets.right - SIZE) {\n@@ -65,1 +77,3 @@\n-                    point.translate(bounds.width \/ 5, 0);\n+                    point.translate(currentScreenBounds.width \/ 5, 0);\n+                   }\n+                   point.setLocation(currentScreenBounds.x, point.y + currentScreenBounds.height \/ 5);\n@@ -67,1 +81,0 @@\n-                point.setLocation(bounds.x, point.y + bounds.height \/ 5);\n@@ -70,1 +83,0 @@\n-    }\n@@ -73,0 +85,1 @@\n+        frame = new Frame();\n@@ -74,5 +87,6 @@\n-        for (int i = 1; i < 7; i++) {\n-            pm.add(TEXT + i);\n-        }\n-        pm.addActionListener(e -> action = true);\n-        Frame frame = new Frame();\n+        IntStream.rangeClosed(1, 6).forEach(i -> pm.add(TEXT + i));\n+        pm.addActionListener(e -> {\n+            action = true;\n+            System.out.println(\" Got action event \" + e);\n+        });\n+\n@@ -80,0 +94,1 @@\n+            frame.setUndecorated(true);\n@@ -87,0 +102,1 @@\n+\n@@ -98,0 +114,1 @@\n+                        System.out.println(\"Going to show popup \"+pm+\" on \"+frame);\n@@ -109,2 +126,0 @@\n-        Robot robot = new Robot();\n-        robot.setAutoDelay(200);\n@@ -113,1 +128,3 @@\n-        robot.mouseMove(pt.x + frame.getWidth() \/ 2, pt.y + 50);\n+        int x = pt.x + frame.getWidth() \/ 2;\n+        int y = pt.y + 50;\n+        robot.mouseMove(x, y);\n@@ -116,2 +133,2 @@\n-        int x = pt.x + frame.getWidth() \/ 2;\n-        int y = pt.y + 130;\n+        robot.waitForIdle();\n+         y = y+50;\n@@ -123,1 +140,4 @@\n-            throw new RuntimeException();\n+            captureScreen();\n+            throw new RuntimeException(\n+                    \"Failed, Not received the PopupMenu ActionEvent yet on \" +\n+                    \"frame= \"+frame+\", isFocused = \"+frame.isFocused());\n@@ -127,0 +147,11 @@\n+\n+    private static void captureScreen() {\n+        try {\n+            ImageIO.write(robot.createScreenCapture(currentScreenBounds), \"png\",\n+                          new File(\"screen1.png\"));\n+        } catch (Exception exception) {\n+            exception.printStackTrace();\n+        }\n+        action = false;\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/PopupMenuLocation.java","additions":51,"deletions":20,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -64,2 +64,2 @@\n- * @run testng\/othervm\/timeout=180 TransferTo\n- * @bug 8279283\n+ * @run testng\/othervm\/timeout=180 -Xmx1280m TransferTo\n+ * @bug 8279283 8294541\n","filename":"test\/jdk\/java\/io\/BufferedInputStream\/TransferTo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -757,1 +757,1 @@\n-     * and unparking.\n+     * and unparking while pinned.\n@@ -778,1 +778,1 @@\n-     * and unparking.\n+     * and unparking while pinned.\n@@ -782,1 +782,8 @@\n-        VThreadRunner.run(this::testJoin33);\n+        \/\/ need at least two carrier threads due to pinning\n+        int previousParallelism = VThreadRunner.ensureParallelism(2);\n+        try {\n+            VThreadRunner.run(this::testJoin33);\n+        } finally {\n+            \/\/ restore\n+            VThreadRunner.setParallelism(previousParallelism);\n+        }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,7 @@\n+    private static Throwable agentError;\n+\n+    public static void checkErrors() {\n+        if (agentError != null) {\n+            throw new RuntimeException(\"Agent error\", agentError);\n+        }\n+    }\n@@ -90,0 +97,3 @@\n+                    if (agentError == null) {\n+                        agentError = ex;\n+                    }\n@@ -92,2 +102,1 @@\n-                    System.err.println(\"Returning bad class file, to cause test failure\");\n-                    return new byte[0];\n+                    return null;\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixAgent.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,2 @@\n+        NativeMethodPrefixAgent.checkErrors();\n+\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixApp.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-        instrumentingVisitor = new ClassVisitor(Opcodes.ASM7, instrumentingVisitor) {\n+        instrumentingVisitor = new ClassVisitor(Opcodes.ASM9, instrumentingVisitor) {\n","filename":"test\/jdk\/java\/lang\/instrument\/asmlib\/Instrumentor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default\n@@ -30,1 +30,2 @@\n- * @modules java.management\n+ * @modules java.base\/java.lang:+open java.management\n+ * @library \/test\/lib\n@@ -37,1 +38,1 @@\n- * @test\n+ * @test id=no-vmcontinuations\n@@ -40,1 +41,2 @@\n- * @modules java.management\n+ * @modules java.base\/java.lang:+open java.management\n+ * @library \/test\/lib\n@@ -51,0 +53,1 @@\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -64,0 +67,2 @@\n+        \/\/ need at least two carrier threads due to pinning\n+        VThreadRunner.ensureParallelism(2);\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreadDeadlocks.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default\n@@ -34,1 +34,1 @@\n- * @test\n+ * @test id=no-vmcontinuations\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreads.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/* @test\n+ * @summary URL.openConnection can throw IOOBE\n+ * @bug 8282395\n+ *\/\n+\n+import java.net.MalformedURLException;\n+import java.net.Proxy;\n+import java.net.URL;\n+\n+public class B8282395 {\n+    public static void main(String[] args) throws Exception {\n+        boolean res = false;\n+        URL url = new URL(\"ftp:\/\/.:%@\");\n+        try {\n+            \/\/ Will throw IndexOutOfBoundsException if not fixed\n+            url.openConnection();\n+        } catch (MalformedURLException e) {\n+            res = true;\n+        }\n+        if (!res) {\n+            throw new RuntimeException(\"MalformedURLException should be thrown\");\n+        }\n+        res = false;\n+        try {\n+            \/\/ Will throw IndexOutOfBoundsException if not fixed\n+            url.openConnection(Proxy.NO_PROXY);\n+        } catch (MalformedURLException e) {\n+            res = true;\n+        }\n+        if (!res) {\n+            throw new RuntimeException(\"MalformedURLException should be thrown\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/URL\/B8282395.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-            Arrays.asList( NO_DURATION,   ofSeconds(1)  ),\n@@ -59,1 +58,0 @@\n-            Arrays.asList( NO_DURATION,   ofNanos(99)   ),\n@@ -62,1 +60,0 @@\n-            Arrays.asList( ofSeconds(1),  NO_DURATION   ),\n@@ -64,1 +61,0 @@\n-            Arrays.asList( ofNanos(99),   NO_DURATION   ),\n@@ -67,1 +63,0 @@\n-            Arrays.asList( ofSeconds(1),  ofMinutes(1)  ),\n@@ -69,1 +64,0 @@\n-            Arrays.asList( ofNanos(99),   ofMinutes(1)  ),\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractConnectTimeout.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,3 +71,1 @@\n-            Arrays.asList( NO_DURATION,   ofSeconds(1)  ),\n-            Arrays.asList( NO_DURATION,   ofSeconds(2)  ),\n-            Arrays.asList( NO_DURATION,   ofMillis(500) ),\n+            Arrays.asList( NO_DURATION,   ofMillis(100) ),\n@@ -75,3 +73,1 @@\n-            Arrays.asList( ofSeconds(1),  NO_DURATION   ),\n-            Arrays.asList( ofSeconds(2),  NO_DURATION   ),\n-            Arrays.asList( ofMillis(500), NO_DURATION   ),\n+            Arrays.asList( ofMillis(100), NO_DURATION   ),\n@@ -79,3 +75,1 @@\n-            Arrays.asList( ofSeconds(1),  ofMinutes(1)  ),\n-            Arrays.asList( ofSeconds(2),  ofMinutes(1)  ),\n-            Arrays.asList( ofMillis(500), ofMinutes(1)  )\n+            Arrays.asList( ofMillis(100), ofMinutes(1)  )\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractConnectTimeoutHandshake.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JFileChooser;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+\n+import javax.swing.filechooser.FileView;\n+\n+\/*\n+ * @test\n+ * @bug 6616245\n+ * @key headful\n+ * @requires (os.family == \"windows\" | os.family == \"linux\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test to check if NPE occurs when using custom FileView.\n+ * @run main\/manual FileViewNPETest\n+ *\/\n+public class FileViewNPETest {\n+    static PassFailJFrame passFailJFrame;\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            public void run() {\n+                try {\n+                    initialize();\n+                } catch (InterruptedException | InvocationTargetException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    static void initialize() throws InterruptedException, InvocationTargetException {\n+        JFrame frame;\n+        JFileChooser jfc;\n+\n+        \/\/Initialize the components\n+        final String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. The traversable folder is set to the Documents folder,\n+                 if it exists, in the user's home folder, otherwise\n+                 it's the user's home. Other folders are non-traversable.\n+                2. When the file chooser appears on the screen, select any\n+                 non-traversable folder from \"Look-In\" combo box,\n+                 for example the user's folder or a folder above it.\n+                 (The folder will not be opened since it's non-traversable).\n+                3. Select the Documents folder again.\n+                4. If NullPointerException does not occur in the step 3,\n+                 click Pass, otherwise the test fails automatically.\n+                \"\"\";\n+        frame = new JFrame(\"JFileChooser File View NPE test\");\n+        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS,\n+                5L, 13, 40);\n+        jfc = new JFileChooser();\n+\n+        String userHome = System.getProperty(\"user.home\");\n+        String docs = userHome + File.separator + \"Documents\";\n+        String path = (new File(docs).exists()) ? docs : userHome;\n+\n+        jfc.setCurrentDirectory(new File(path));\n+        jfc.setFileView(new CustomFileView(path));\n+        jfc.setControlButtonsAreShown(false);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+\n+        frame.add(jfc, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+}\n+\n+class CustomFileView extends FileView {\n+    private final String basePath;\n+\n+    public CustomFileView(String path) {\n+        basePath = path;\n+    }\n+\n+    public Boolean isTraversable(File filePath) {\n+        return ((filePath != null) && (filePath.isDirectory()))\n+                && filePath.getAbsolutePath().startsWith(basePath);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileViewNPETest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -75,0 +75,1 @@\n+        System.out.println(\"correctColoredPixels \" + correctColoredPixels + \" totalPixels \" + totalPixels);\n@@ -93,2 +94,2 @@\n-        checkBox = new JCheckBox(\"WWWWW\");\n-        radioButton = new JRadioButton(\"WWWWW\");\n+        checkBox = new JCheckBox(\"\\u2588\".repeat(5));\n+        radioButton = new JRadioButton(\"\\u2588\".repeat(5));\n","filename":"test\/jdk\/javax\/swing\/JRadioButton\/4314194\/bug4314194.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.nio.file.Path;\n@@ -27,0 +28,1 @@\n+import java.util.Set;\n@@ -30,1 +32,6 @@\n-import jdk.test.lib.Asserts;\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.SettingDefinition;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.assertFalse;\n@@ -34,1 +41,1 @@\n- * @summary Test enable\/disable event and verify recording has expected events.\n+ * @summary Test jdk.jfr.Event::shouldCommit()\n@@ -38,1 +45,1 @@\n- * @run main\/othervm -Xlog:jfr+event+setting=trace jdk.jfr.api.event.TestShouldCommit\n+ * @run main\/othervm jdk.jfr.api.event.TestShouldCommit\n@@ -40,1 +47,0 @@\n-\n@@ -43,33 +49,2 @@\n-    public static void main(String[] args) throws Exception {\n-        Recording rA = new Recording();\n-\n-        verifyShouldCommitFalse(); \/\/ No active recordings\n-\n-        rA.start();\n-        rA.enable(MyEvent.class).withoutThreshold(); \/\/ recA=all\n-        verifyShouldCommitTrue();\n-\n-        setThreshold(rA, 100); \/\/ recA=100\n-        verifyThreshold(100);\n-\n-        setThreshold(rA, 200); \/\/ recA=200\n-        verifyThreshold(200);\n-\n-        Recording rB = new Recording();\n-        verifyThreshold(200);  \/\/ recA=200, recB=not started\n-\n-        rB.start();\n-        verifyThreshold(200);  \/\/ recA=200, recB=not specified, settings from recA is used.\n-\n-        setThreshold(rB, 100); \/\/ recA=200, recB=100\n-        verifyThreshold(100);\n-\n-        setThreshold(rB, 300); \/\/ recA=200, recB=300\n-        verifyThreshold(200);\n-\n-        rA.disable(MyEvent.class); \/\/ recA=disabled, recB=300\n-\n-        verifyThreshold(300);\n-\n-        rB.disable(MyEvent.class); \/\/ recA=disabled, recB=disabled\n-        verifyShouldCommitFalse();\n+    private static class CatEvent extends Event {\n+    }\n@@ -77,2 +52,2 @@\n-        setThreshold(rA, 200); \/\/ recA=200, recB=disabled\n-        verifyThreshold(200);\n+    private static class DogEvent extends Event {\n+    }\n@@ -80,2 +55,2 @@\n-        rB.enable(MyEvent.class).withoutThreshold(); \/\/ recA=200, recB=all\n-        verifyShouldCommitTrue();\n+    private static class BirdEvent extends Event {\n+        public boolean isFlying;\n@@ -83,2 +58,5 @@\n-        setThreshold(rB, 100); \/\/ recA=200, recB=100\n-        verifyThreshold(100);\n+        @SettingDefinition\n+        public boolean fly(FlySetting control) {\n+            return control.shouldFly() == isFlying;\n+        }\n+    }\n@@ -86,2 +64,2 @@\n-        rB.stop(); \/\/ recA=200, recB=stopped\n-        verifyThreshold(200);\n+    private static class FlySetting extends SettingControl {\n+        private boolean shouldFly;\n@@ -89,2 +67,9 @@\n-        rA.stop(); \/\/ recA=stopped, recB=stopped\n-        verifyShouldCommitFalse();\n+        @Override\n+        public String combine(Set<String> settingValues) {\n+            for (String s : settingValues) {\n+                if (\"true\".equals(s)) {\n+                    return \"true\";\n+                }\n+            }\n+            return \"false\";\n+        }\n@@ -92,2 +77,3 @@\n-        rA.close();\n-        rB.close();\n+        public boolean shouldFly() {\n+            return shouldFly;\n+        }\n@@ -95,2 +81,4 @@\n-        verifyShouldCommitFalse();\n-    }\n+        @Override\n+        public void setValue(String settingValue) {\n+            shouldFly = \"true\".equals(settingValue);\n+        }\n@@ -98,2 +86,4 @@\n-    private static void setThreshold(Recording r, long millis) {\n-        r.enable(MyEvent.class).withThreshold(Duration.ofMillis(millis));\n+        @Override\n+        public String getValue() {\n+            return String.valueOf(shouldFly);\n+        }\n@@ -102,5 +92,6 @@\n-    private static void verifyThreshold(long threshold) throws Exception {\n-        \/\/ Create 2 events, with different sleep time between begin() and end()\n-        \/\/ First event ends just before threshold, the other just after.\n-        verifyThreshold(threshold-5, threshold);\n-        verifyThreshold(threshold+5, threshold);\n+    public static void main(String[] args) throws Exception {\n+        testEnablement();\n+        testThreshold();\n+        testCustomSetting();\n+        testWithoutEnd();\n+        testCommit();\n@@ -109,2 +100,3 @@\n-    private static void verifyThreshold(long sleepMs, long thresholdMs) throws Exception {\n-        MyEvent event = new MyEvent();\n+    private static void testEnablement() throws Exception {\n+        DogEvent b = new DogEvent();\n+        assertFalse(b.shouldCommit(), \"Expected false before recording is started\");\n@@ -112,3 +104,4 @@\n-        long beforeStartNanos = System.nanoTime();\n-        event.begin();\n-        long afterStartNanos = System.nanoTime();\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class);\n+            r.disable(DogEvent.class);\n+            r.start();\n@@ -116,1 +109,2 @@\n-        Thread.sleep(sleepMs);\n+            CatEvent c = new CatEvent();\n+            assertTrue(c.shouldCommit(), \"Expected true for enabled event\");\n@@ -118,3 +112,3 @@\n-        long beforeStopNanos = System.nanoTime();\n-        event.end();\n-        long afterStopNanos = System.nanoTime();\n+            DogEvent d = new DogEvent();\n+            assertFalse(d.shouldCommit(), \"Expected false for disabled event\");\n+        }\n@@ -122,1 +116,3 @@\n-        boolean actualShouldCommit = event.shouldCommit();\n+        CatEvent c = new CatEvent();\n+        assertFalse(c.shouldCommit(), \"Expected false after recording is stopped\");\n+    }\n@@ -124,1 +120,5 @@\n-        final long safetyMarginNanos = 2000000; \/\/ Allow an error of 2 ms. May have to be tuned.\n+    private static void testThreshold() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class).withThreshold(Duration.ofNanos(0));\n+            r.enable(DogEvent.class).withThreshold(Duration.ofDays(1));\n+            r.start();\n@@ -126,5 +126,5 @@\n-        \/\/Duration of event has been at least minDurationMicros\n-        long minDurationMicros = (beforeStopNanos - afterStartNanos - safetyMarginNanos) \/ 1000;\n-        \/\/Duration of event has been at most maxDurationMicros\n-        long maxDurationMicros = (afterStopNanos - beforeStartNanos + safetyMarginNanos) \/ 1000;\n-        Asserts.assertLessThanOrEqual(minDurationMicros, maxDurationMicros, \"Wrong min\/max duration. Test error.\");\n+            CatEvent c = new CatEvent();\n+            c.begin();\n+            Thread.sleep(1);\n+            c.end();\n+            assertTrue(c.shouldCommit(), \"Expected true if above threshold\");\n@@ -132,8 +132,5 @@\n-        long thresholdMicros = thresholdMs * 1000;\n-        Boolean shouldCommit = null;\n-        if (minDurationMicros > thresholdMicros) {\n-            shouldCommit = new Boolean(true);  \/\/ shouldCommit() must be true\n-        } else if (maxDurationMicros < thresholdMicros) {\n-            shouldCommit = new Boolean(false); \/\/ shouldCommit() must be false\n-        } else {\n-            \/\/ Too close to call. No checks are done since we are not sure of expected shouldCommit().\n+            DogEvent d = new DogEvent();\n+            d.begin();\n+            Thread.sleep(1);\n+            d.end();\n+            assertFalse(d.shouldCommit(), \"Expected false if below threshold\");\n@@ -141,0 +138,1 @@\n+    }\n@@ -142,13 +140,15 @@\n-        System.out.printf(\n-            \"threshold=%d, duration=[%d-%d], shouldCommit()=%b, expected=%s%n\",\n-            thresholdMicros, minDurationMicros, maxDurationMicros, actualShouldCommit,\n-            (shouldCommit!=null ? shouldCommit : \"too close to call\"));\n-\n-        try {\n-            if (shouldCommit != null) {\n-                Asserts.assertEquals(shouldCommit.booleanValue(), actualShouldCommit, \"Wrong shouldCommit()\");\n-            }\n-        } catch (Exception e) {\n-            System.out.println(\"Unexpected value of shouldCommit(). Searching for active threshold...\");\n-            searchThreshold(thresholdMs, 2000+thresholdMs);\n-            throw e;\n+    private static void testCustomSetting() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(BirdEvent.class).with(\"fly\", \"true\");\n+            r.start();\n+            BirdEvent b1 = new BirdEvent();\n+            b1.isFlying = false;\n+            b1.begin();\n+            b1.end();\n+            assertFalse(b1.shouldCommit(), \"Expected false if rejected by custom setting\");\n+\n+            BirdEvent b2 = new BirdEvent();\n+            b2.isFlying = true;\n+            b2.begin();\n+            b2.end();\n+            assertTrue(b2.shouldCommit(), \"Expected true if accepted by custom setting\");\n@@ -158,4 +158,5 @@\n-    \/\/ Sleeps until shouldCommit() is true, or give up. Used for logging.\n-    private static void searchThreshold(long expectedMs, long maxMs) throws Exception {\n-        long start = System.nanoTime();\n-        long stop = start + maxMs * 1000000;\n+    private static void testWithoutEnd() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class).withThreshold(Duration.ofDays(0));\n+            r.enable(DogEvent.class).withThreshold(Duration.ofDays(1));\n+            r.start();\n@@ -163,3 +164,4 @@\n-        MyEvent event = new MyEvent();\n-        event.begin();\n-        event.end();\n+            CatEvent c = new CatEvent();\n+            c.begin();\n+            Thread.sleep(1);\n+            assertTrue(c.shouldCommit(), \"Expected true when above threshold and end() not invoked\");\n@@ -167,1 +169,2 @@\n-        while (!event.shouldCommit() && System.nanoTime() < stop) {\n+            DogEvent d = new DogEvent();\n+            d.begin();\n@@ -169,1 +172,1 @@\n-            event.end();\n+            assertFalse(d.shouldCommit(), \"Expected false when below threshold and end() not invoked\");\n@@ -171,17 +174,0 @@\n-        long durationMicros = (System.nanoTime() - start) \/ 1000;\n-        long expectedMicros = expectedMs * 1000;\n-        System.out.printf(\"shouldCommit()=%b after %,d ms, expected %,d%n\", event.shouldCommit(), durationMicros, expectedMicros);\n-    }\n-\n-    private static void verifyShouldCommitFalse() {\n-        MyEvent event = new MyEvent();\n-        event.begin();\n-        event.end();\n-        Asserts.assertFalse(event.shouldCommit(), \"shouldCommit() expected false\");\n-    }\n-\n-    private static void verifyShouldCommitTrue() {\n-        MyEvent event = new MyEvent();\n-        event.begin();\n-        event.end();\n-        Asserts.assertTrue(event.shouldCommit(), \"shouldCommit() expected true\");\n@@ -190,1 +176,17 @@\n-    private static class MyEvent extends Event {\n+    private static void testCommit() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class);\n+            r.start();\n+            CatEvent c = new CatEvent();\n+            c.begin();\n+            Thread.sleep(1);\n+            c.end();\n+            if (c.shouldCommit()) {\n+                c.commit();\n+            }\n+            r.stop();\n+            Path file = Path.of(\"dump.jfr\");\n+            r.dump(file);\n+            boolean hasEvent = RecordingFile.readAllEvents(file).size() > 0;\n+            assertTrue(hasEvent, \"Expected event when using commit() after shouldCommit()\");\n+        }\n@@ -192,1 +194,0 @@\n-\n","filename":"test\/jdk\/jdk\/jfr\/api\/event\/TestShouldCommit.java","additions":125,"deletions":124,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.reflect.Field;\n@@ -27,0 +28,1 @@\n+import java.util.concurrent.ForkJoinPool;\n@@ -30,1 +32,1 @@\n- * Helper class for running tasks in a virtual thread.\n+ * Helper class to support tests running tasks a in virtual thread.\n@@ -143,0 +145,37 @@\n+\n+    \/**\n+     * Returns the virtual thread scheduler.\n+     *\/\n+    private static ForkJoinPool defaultScheduler() {\n+        try {\n+            var clazz = Class.forName(\"java.lang.VirtualThread\");\n+            var field = clazz.getDeclaredField(\"DEFAULT_SCHEDULER\");\n+            field.setAccessible(true);\n+            return (ForkJoinPool) field.get(null);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Sets the virtual thread scheduler's target parallelism.\n+     * @return the previous parallelism level\n+     *\/\n+    public static int setParallelism(int size) {\n+        return defaultScheduler().setParallelism(size);\n+    }\n+\n+    \/**\n+     * Ensures that the virtual thread scheduler's target parallelism is at least\n+     * the given size. If the target parallelism is less than the given size then\n+     * it is changed to the given size.\n+     * @return the previous parallelism level\n+     *\/\n+    public static int ensureParallelism(int size) {\n+        ForkJoinPool pool = defaultScheduler();\n+        int parallelism = pool.getParallelism();\n+        if (size > parallelism) {\n+            pool.setParallelism(size);\n+        }\n+        return parallelism;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/VThreadRunner.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"}]}