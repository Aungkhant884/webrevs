{"files":[{"patch":"@@ -3354,2 +3354,1 @@\n-            x = __HI(x, __HI(x)^sx);\n-            return x;\n+            return __HI(x, __HI(x)^sx);\n@@ -3371,2 +3370,2 @@\n-            if((hy | ly) == 0 || (hx >= 0x7ff0_0000)||       \/\/ y = 0, or x not finite\n-               ((hy | ((ly | -ly) >> 31)) > 0x7ff0_0000))    \/\/ or y is NaN\n+            if ((hy | ly) == 0 || (hx >= 0x7ff0_0000)||       \/\/ y = 0, or x not finite\n+               ((hy | ((ly | -ly) >>> 31)) > 0x7ff0_0000))    \/\/ or y is NaN, unsigned shift\n@@ -3399,1 +3398,1 @@\n-            if(iy >= -1022)\n+            if (iy >= -1022)\n@@ -3414,1 +3413,1 @@\n-            while(n-- != 0) {\n+            while (n-- != 0) {\n@@ -3445,1 +3444,1 @@\n-            while (hx < 0x0010_0000) {          \/\/ normalize x\n+            while (hx < 0x0010_0000) {      \/\/ normalize x\n@@ -3450,1 +3449,1 @@\n-            if( iy >= -1022) {        \/\/ normalize output\n+            if (iy >= -1022) {        \/\/ normalize output\n@@ -3455,0 +3454,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2652,1 +2652,1 @@\n-               ((hy|((ly|-ly)>>31))>0x7ff00000))     \/* or y is NaN *\/\n+               ((hy|((ly|-ly)>>>31))>0x7ff00000))     \/* or y is NaN  *\/ \/\/ unsigned shift\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304028\n+ * @key randomness\n+ * @summary Tests for StrictMath.IEEEremainder\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build IeeeRemainderTests\n+ * @run main IeeeRemainderTests\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+\n+\/**\n+ * The tests in ..\/Math\/IeeeRemainderTests.java test properties that\n+ * should hold for any IEEEremainder implementation, including the\n+ * FDLIBM-based one required for StrictMath.IEEEremainder.  Therefore,\n+ * the test cases in ..\/Math\/IEEEremainderTests.java are run against\n+ * both the Math and StrictMath versions of IEEEremainder.  The role\n+ * of this test is to verify that the FDLIBM IEEEremainder algorithm\n+ * is being used by running golden file tests on values that may vary\n+ * from one conforming IEEEremainder implementation to another.\n+ *\/\n+\n+public class IeeeRemainderTests {\n+    private IeeeRemainderTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslit();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing IEEEremainder incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.IEEEremainder against transliteration port of IEEEremainder.\n+     *\/\n+    private static int testAgainstTranslit() {\n+        int failures = 0;\n+\n+        \/\/ The exact special cases for infinity, NaN, zero,\n+        \/\/ etc. inputs are checked in the Math tests.\n+\n+        \/\/ Test exotic NaN bit patterns\n+        double[][] exoticNaNs = {\n+            {Double.longBitsToDouble(0x7FF0_0000_0000_0001L), 0.0},\n+            {0.0, Double.longBitsToDouble(0x7FF0_0000_0000_0001L)},\n+            {Double.longBitsToDouble(0xFFF_00000_0000_0001L), 0.0},\n+            {0.0, Double.longBitsToDouble(0xFFF0_0000_0000_0001L)},\n+            {Double.longBitsToDouble(0x7FF_00000_7FFF_FFFFL), 0.0},\n+            {0.0, Double.longBitsToDouble(0x7FF0_7FFF_0000_FFFFL)},\n+            {Double.longBitsToDouble(0xFFF_00000_7FFF_FFFFL), 0.0},\n+            {0.0, Double.longBitsToDouble(0xFFF0_7FFF_0000_FFFFL)},\n+        };\n+\n+        for (double[] exoticNaN: exoticNaNs) {\n+            failures += testIEEEremainderCase(exoticNaN[0], exoticNaN[1],\n+                                              FdlibmTranslit.IEEEremainder(exoticNaN[0], exoticNaN[1]));\n+        }\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[][] decisionPoints = { \n+            {0x1.fffffp1022, 100.0},\n+            {0x1.fffffp1022, 0x1.fffffp1022},\n+\n+            {2.0*0x1.0p-1022, 0x1.0p-1022},\n+            {2.0*0x1.0p-1022, 0x1.0p-1023},\n+        };\n+        \n+\n+        for (var decisionPoint : decisionPoints) {\n+            double x = decisionPoint[0];\n+            double p = decisionPoint[1];\n+            double increment_x = Math.ulp(x);\n+            double increment_p = Math.ulp(p);\n+\n+            x = x - 64*increment_x;\n+            p = p - 64*increment_p;\n+\n+            for (int i = 0; i < 128; i++, x += increment_x) {\n+                for (int j = 0; j < 126; j++, p += increment_p) {\n+                    failures += testIEEEremainderCase( x,  p, FdlibmTranslit.IEEEremainder( x,  p));\n+                    failures += testIEEEremainderCase(-x,  p, FdlibmTranslit.IEEEremainder(-x,  p));\n+                    failures += testIEEEremainderCase( x, -p, FdlibmTranslit.IEEEremainder( x, -p));\n+                    failures += testIEEEremainderCase(-x, -p, FdlibmTranslit.IEEEremainder(-x, -p));\n+                }\n+            }\n+        }\n+\n+        \/\/ Check random values\n+        for (int k = 0; k < 200; k++ ) {\n+            double x = random.nextDouble();\n+            double p = random.nextDouble();\n+            failures += testIEEEremainderCase(x, p, FdlibmTranslit.IEEEremainder(x, p));\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testIEEEremainderCase(double input1, double input2, double expected) {\n+        int failures = 0;\n+        failures += Tests.test(\"StrictMath.IEEEremainder(double)\", input1, input2,\n+                               StrictMath::IEEEremainder, expected);\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StrictMath\/IeeeRemainderTests.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"}]}