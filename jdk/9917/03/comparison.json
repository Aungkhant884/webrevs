{"files":[{"patch":"@@ -2010,2 +2010,2 @@\n-\/\/ SymbolHashMap is used to find a constant pool index from a string.\n-\/\/ This function fills in SymbolHashMaps, one for utf8s and one for\n+\/\/ SymbolHash is used to find a constant pool index from a string.\n+\/\/ This function fills in SymbolHashs, one for utf8s and one for\n@@ -2013,2 +2013,2 @@\n-jint ConstantPool::hash_entries_to(SymbolHashMap *symmap,\n-                                          SymbolHashMap *classmap) {\n+jint ConstantPool::hash_entries_to(SymbolHash *symmap,\n+                                   SymbolHash *classmap) {\n@@ -2024,1 +2024,1 @@\n-        symmap->add_entry(sym, idx);\n+        symmap->add_if_absent(sym, idx);\n@@ -2032,1 +2032,1 @@\n-        classmap->add_entry(sym, idx);\n+        classmap->add_if_absent(sym, idx);\n@@ -2053,2 +2053,2 @@\n-                                          SymbolHashMap* tbl,\n-                                          unsigned char *bytes) {\n+                                   SymbolHash* tbl,\n+                                   unsigned char *bytes) {\n@@ -2431,56 +2431,0 @@\n-\n-\n-SymbolHashMap::~SymbolHashMap() {\n-  SymbolHashMapEntry* next;\n-  for (int i = 0; i < _table_size; i++) {\n-    for (SymbolHashMapEntry* cur = bucket(i); cur != NULL; cur = next) {\n-      next = cur->next();\n-      delete(cur);\n-    }\n-  }\n-  FREE_C_HEAP_ARRAY(SymbolHashMapBucket, _buckets);\n-}\n-\n-void SymbolHashMap::add_entry(Symbol* sym, u2 value) {\n-  char *str = sym->as_utf8();\n-  unsigned int hash = compute_hash(str, sym->utf8_length());\n-  unsigned int index = hash % table_size();\n-\n-  \/\/ check if already in map\n-  \/\/ we prefer the first entry since it is more likely to be what was used in\n-  \/\/ the class file\n-  for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en->next()) {\n-    assert(en->symbol() != NULL, \"SymbolHashMapEntry symbol is NULL\");\n-    if (en->hash() == hash && en->symbol() == sym) {\n-        return;  \/\/ already there\n-    }\n-  }\n-\n-  SymbolHashMapEntry* entry = new SymbolHashMapEntry(hash, sym, value);\n-  entry->set_next(bucket(index));\n-  _buckets[index].set_entry(entry);\n-  assert(entry->symbol() != NULL, \"SymbolHashMapEntry symbol is NULL\");\n-}\n-\n-SymbolHashMapEntry* SymbolHashMap::find_entry(Symbol* sym) {\n-  assert(sym != NULL, \"SymbolHashMap::find_entry - symbol is NULL\");\n-  char *str = sym->as_utf8();\n-  int   len = sym->utf8_length();\n-  unsigned int hash = SymbolHashMap::compute_hash(str, len);\n-  unsigned int index = hash % table_size();\n-  for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en->next()) {\n-    assert(en->symbol() != NULL, \"SymbolHashMapEntry symbol is NULL\");\n-    if (en->hash() == hash && en->symbol() == sym) {\n-      return en;\n-    }\n-  }\n-  return NULL;\n-}\n-\n-void SymbolHashMap::initialize_table(int table_size) {\n-  _table_size = table_size;\n-  _buckets = NEW_C_HEAP_ARRAY(SymbolHashMapBucket, table_size, mtSymbol);\n-  for (int index = 0; index < table_size; index++) {\n-    _buckets[index].clear();\n-  }\n-}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":8,"deletions":64,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-class SymbolHashMap;\n-\n@@ -893,0 +891,15 @@\n+  class SymbolHash: public CHeapObj<mtSymbol> {\n+    ResourceHashtable<const Symbol*, u2, 256, ResourceObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n+\n+   public:\n+    void add_if_absent(const Symbol* sym, u2 value) {\n+      bool created;\n+      _table.put_if_absent(sym, value, &created);\n+    }\n+\n+    u2 symbol_to_value(const Symbol* sym) {\n+      u2* value = _table.get(sym);\n+      return (value == nullptr) ? 0 : *value;\n+    }\n+  }; \/\/ End SymbolHash class\n+\n@@ -894,1 +907,1 @@\n-  jint hash_entries_to(SymbolHashMap *symmap, SymbolHashMap *classmap);\n+  jint hash_entries_to(SymbolHash *symmap, SymbolHash *classmap);\n@@ -902,1 +915,1 @@\n-                        SymbolHashMap* tbl,\n+                        SymbolHash* tbl,\n@@ -917,84 +930,0 @@\n-class SymbolHashMapEntry : public CHeapObj<mtSymbol> {\n- private:\n-  SymbolHashMapEntry* _next;   \/\/ Next element in the linked list for this bucket\n-  Symbol*             _symbol; \/\/ 1-st part of the mapping: symbol => value\n-  unsigned int        _hash;   \/\/ 32-bit hash for item\n-  u2                  _value;  \/\/ 2-nd part of the mapping: symbol => value\n-\n- public:\n-  unsigned   int hash() const             { return _hash;   }\n-  void       set_hash(unsigned int hash)  { _hash = hash;   }\n-\n-  SymbolHashMapEntry* next() const        { return _next;   }\n-  void set_next(SymbolHashMapEntry* next) { _next = next;   }\n-\n-  Symbol*    symbol() const               { return _symbol; }\n-  void       set_symbol(Symbol* sym)      { _symbol = sym;  }\n-\n-  u2         value() const                {  return _value; }\n-  void       set_value(u2 value)          { _value = value; }\n-\n-  SymbolHashMapEntry(unsigned int hash, Symbol* symbol, u2 value)\n-    : _next(NULL), _symbol(symbol), _hash(hash), _value(value) {}\n-\n-}; \/\/ End SymbolHashMapEntry class\n-\n-\n-class SymbolHashMapBucket : public CHeapObj<mtSymbol> {\n-\n-private:\n-  SymbolHashMapEntry*    _entry;\n-\n-public:\n-  SymbolHashMapEntry* entry() const         {  return _entry; }\n-  void set_entry(SymbolHashMapEntry* entry) { _entry = entry; }\n-  void clear()                              { _entry = NULL;  }\n-\n-}; \/\/ End SymbolHashMapBucket class\n-\n-\n-class SymbolHashMap: public CHeapObj<mtSymbol> {\n-\n- private:\n-  \/\/ Default number of entries in the table\n-  enum SymbolHashMap_Constants {\n-    _Def_HashMap_Size = 256\n-  };\n-\n-  int                   _table_size;\n-  SymbolHashMapBucket*  _buckets;\n-\n-  void initialize_table(int table_size);\n-\n- public:\n-\n-  int table_size() const        { return _table_size; }\n-\n-  SymbolHashMap()               { initialize_table(_Def_HashMap_Size); }\n-  SymbolHashMap(int table_size) { initialize_table(table_size); }\n-\n-  \/\/ hash P(31) from Kernighan & Ritchie\n-  static unsigned int compute_hash(const char* str, int len) {\n-    unsigned int hash = 0;\n-    while (len-- > 0) {\n-      hash = 31*hash + (unsigned) *str;\n-      str++;\n-    }\n-    return hash;\n-  }\n-\n-  SymbolHashMapEntry* bucket(int i) {\n-    return _buckets[i].entry();\n-  }\n-\n-  void add_entry(Symbol* sym, u2 value);\n-  SymbolHashMapEntry* find_entry(Symbol* sym);\n-\n-  u2 symbol_to_value(Symbol* sym) {\n-    SymbolHashMapEntry *entry = find_entry(sym);\n-    return (entry == NULL) ? 0 : entry->value();\n-  }\n-\n-  ~SymbolHashMap();\n-}; \/\/ End SymbolHashMap class\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":17,"deletions":88,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-  _symmap = new SymbolHashMap();\n-  _classmap = new SymbolHashMap();\n+  _symmap = new ConstantPool::SymbolHash();\n+  _classmap = new ConstantPool::SymbolHash();\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/constantPool.hpp\"\n@@ -34,2 +35,2 @@\n-  SymbolHashMap*       _symmap;\n-  SymbolHashMap*       _classmap;\n+  ConstantPool::SymbolHash*  _symmap;\n+  ConstantPool::SymbolHash*  _classmap;\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}