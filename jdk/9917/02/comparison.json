{"files":[{"patch":"@@ -2014,1 +2014,1 @@\n-                                          SymbolHashMap *classmap) {\n+                                   SymbolHashMap *classmap) {\n@@ -2024,1 +2024,1 @@\n-        symmap->add_entry(sym, idx);\n+        symmap->add_if_absent(sym, idx);\n@@ -2032,1 +2032,1 @@\n-        classmap->add_entry(sym, idx);\n+        classmap->add_if_absent(sym, idx);\n@@ -2053,2 +2053,2 @@\n-                                          SymbolHashMap* tbl,\n-                                          unsigned char *bytes) {\n+                                   SymbolHashMap* tbl,\n+                                   unsigned char *bytes) {\n@@ -2431,56 +2431,0 @@\n-\n-\n-SymbolHashMap::~SymbolHashMap() {\n-  SymbolHashMapEntry* next;\n-  for (int i = 0; i < _table_size; i++) {\n-    for (SymbolHashMapEntry* cur = bucket(i); cur != NULL; cur = next) {\n-      next = cur->next();\n-      delete(cur);\n-    }\n-  }\n-  FREE_C_HEAP_ARRAY(SymbolHashMapBucket, _buckets);\n-}\n-\n-void SymbolHashMap::add_entry(Symbol* sym, u2 value) {\n-  char *str = sym->as_utf8();\n-  unsigned int hash = compute_hash(str, sym->utf8_length());\n-  unsigned int index = hash % table_size();\n-\n-  \/\/ check if already in map\n-  \/\/ we prefer the first entry since it is more likely to be what was used in\n-  \/\/ the class file\n-  for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en->next()) {\n-    assert(en->symbol() != NULL, \"SymbolHashMapEntry symbol is NULL\");\n-    if (en->hash() == hash && en->symbol() == sym) {\n-        return;  \/\/ already there\n-    }\n-  }\n-\n-  SymbolHashMapEntry* entry = new SymbolHashMapEntry(hash, sym, value);\n-  entry->set_next(bucket(index));\n-  _buckets[index].set_entry(entry);\n-  assert(entry->symbol() != NULL, \"SymbolHashMapEntry symbol is NULL\");\n-}\n-\n-SymbolHashMapEntry* SymbolHashMap::find_entry(Symbol* sym) {\n-  assert(sym != NULL, \"SymbolHashMap::find_entry - symbol is NULL\");\n-  char *str = sym->as_utf8();\n-  int   len = sym->utf8_length();\n-  unsigned int hash = SymbolHashMap::compute_hash(str, len);\n-  unsigned int index = hash % table_size();\n-  for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en->next()) {\n-    assert(en->symbol() != NULL, \"SymbolHashMapEntry symbol is NULL\");\n-    if (en->hash() == hash && en->symbol() == sym) {\n-      return en;\n-    }\n-  }\n-  return NULL;\n-}\n-\n-void SymbolHashMap::initialize_table(int table_size) {\n-  _table_size = table_size;\n-  _buckets = NEW_C_HEAP_ARRAY(SymbolHashMapBucket, table_size, mtSymbol);\n-  for (int index = 0; index < table_size; index++) {\n-    _buckets[index].clear();\n-  }\n-}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":5,"deletions":61,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -917,39 +917,0 @@\n-class SymbolHashMapEntry : public CHeapObj<mtSymbol> {\n- private:\n-  SymbolHashMapEntry* _next;   \/\/ Next element in the linked list for this bucket\n-  Symbol*             _symbol; \/\/ 1-st part of the mapping: symbol => value\n-  unsigned int        _hash;   \/\/ 32-bit hash for item\n-  u2                  _value;  \/\/ 2-nd part of the mapping: symbol => value\n-\n- public:\n-  unsigned   int hash() const             { return _hash;   }\n-  void       set_hash(unsigned int hash)  { _hash = hash;   }\n-\n-  SymbolHashMapEntry* next() const        { return _next;   }\n-  void set_next(SymbolHashMapEntry* next) { _next = next;   }\n-\n-  Symbol*    symbol() const               { return _symbol; }\n-  void       set_symbol(Symbol* sym)      { _symbol = sym;  }\n-\n-  u2         value() const                {  return _value; }\n-  void       set_value(u2 value)          { _value = value; }\n-\n-  SymbolHashMapEntry(unsigned int hash, Symbol* symbol, u2 value)\n-    : _next(NULL), _symbol(symbol), _hash(hash), _value(value) {}\n-\n-}; \/\/ End SymbolHashMapEntry class\n-\n-\n-class SymbolHashMapBucket : public CHeapObj<mtSymbol> {\n-\n-private:\n-  SymbolHashMapEntry*    _entry;\n-\n-public:\n-  SymbolHashMapEntry* entry() const         {  return _entry; }\n-  void set_entry(SymbolHashMapEntry* entry) { _entry = entry; }\n-  void clear()                              { _entry = NULL;  }\n-\n-}; \/\/ End SymbolHashMapBucket class\n-\n-\n@@ -957,11 +918,1 @@\n-\n- private:\n-  \/\/ Default number of entries in the table\n-  enum SymbolHashMap_Constants {\n-    _Def_HashMap_Size = 256\n-  };\n-\n-  int                   _table_size;\n-  SymbolHashMapBucket*  _buckets;\n-\n-  void initialize_table(int table_size);\n+  ResourceHashtable<const Symbol*, u2, 256, ResourceObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n@@ -970,14 +921,3 @@\n-\n-  int table_size() const        { return _table_size; }\n-\n-  SymbolHashMap()               { initialize_table(_Def_HashMap_Size); }\n-  SymbolHashMap(int table_size) { initialize_table(table_size); }\n-\n-  \/\/ hash P(31) from Kernighan & Ritchie\n-  static unsigned int compute_hash(const char* str, int len) {\n-    unsigned int hash = 0;\n-    while (len-- > 0) {\n-      hash = 31*hash + (unsigned) *str;\n-      str++;\n-    }\n-    return hash;\n+  void add_if_absent(const Symbol* sym, u2 value) {\n+    bool created;\n+    _table.put_if_absent(sym, value, &created);\n@@ -986,2 +926,3 @@\n-  SymbolHashMapEntry* bucket(int i) {\n-    return _buckets[i].entry();\n+  u2 symbol_to_value(const Symbol* sym) {\n+    u2* value = _table.get(sym);\n+    return (value == nullptr) ? 0 : *value;\n@@ -989,10 +930,0 @@\n-\n-  void add_entry(Symbol* sym, u2 value);\n-  SymbolHashMapEntry* find_entry(Symbol* sym);\n-\n-  u2 symbol_to_value(Symbol* sym) {\n-    SymbolHashMapEntry *entry = find_entry(sym);\n-    return (entry == NULL) ? 0 : entry->value();\n-  }\n-\n-  ~SymbolHashMap();\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":7,"deletions":76,"binary":false,"changes":83,"status":"modified"}]}