{"files":[{"patch":"@@ -40,1 +40,0 @@\n-import java.net.URL;\n@@ -42,1 +41,0 @@\n-import java.security.CodeSource;\n@@ -44,2 +42,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n@@ -48,1 +44,0 @@\n-import java.util.NoSuchElementException;\n@@ -661,1 +656,1 @@\n-                certs = jv.getCerts(JarFile.this, realEntry());\n+                certs = jv.getCerts(realEntry());\n@@ -674,1 +669,1 @@\n-                signers = jv.getCodeSigners(JarFile.this, realEntry());\n+                signers = jv.getCodeSigners(realEntry());\n@@ -1076,191 +1071,0 @@\n-\n-    \/*\n-     * Returns a versioned {@code JarFileEntry} for the given entry,\n-     * if there is one. Otherwise returns the original entry. This\n-     * is invoked by the {@code entries2} for verifier.\n-     *\/\n-    JarEntry newEntry(JarEntry je) {\n-        if (isMultiRelease()) {\n-            return getVersionedEntry(je.getName(), je);\n-        }\n-        return je;\n-    }\n-\n-    \/*\n-     * Returns a versioned {@code JarFileEntry} for the given entry\n-     * name, if there is one. Otherwise returns a {@code JarFileEntry}\n-     * with the given name. It is invoked from JarVerifier's entries2\n-     * for {@code singers}.\n-     *\/\n-    JarEntry newEntry(String name) {\n-        if (isMultiRelease()) {\n-            JarEntry vje = getVersionedEntry(name, null);\n-            if (vje != null) {\n-                return vje;\n-            }\n-        }\n-        return new JarFileEntry(name);\n-    }\n-\n-    Enumeration<String> entryNames(CodeSource[] cs) {\n-        ensureInitialization();\n-        if (jv != null) {\n-            return jv.entryNames(this, cs);\n-        }\n-\n-        \/*\n-         * JAR file has no signed content. Is there a non-signing\n-         * code source?\n-         *\/\n-        boolean includeUnsigned = false;\n-        for (CodeSource c : cs) {\n-            if (c.getCodeSigners() == null) {\n-                includeUnsigned = true;\n-                break;\n-            }\n-        }\n-        if (includeUnsigned) {\n-            return unsignedEntryNames();\n-        } else {\n-            return Collections.emptyEnumeration();\n-        }\n-    }\n-\n-    \/**\n-     * Returns an enumeration of the zip file entries\n-     * excluding internal JAR mechanism entries and including\n-     * signed entries missing from the ZIP directory.\n-     *\/\n-    Enumeration<JarEntry> entries2() {\n-        ensureInitialization();\n-        if (jv != null) {\n-            return jv.entries2(this, JUZFA.entries(JarFile.this));\n-        }\n-\n-        \/\/ screen out entries which are never signed\n-        final var unfilteredEntries = JUZFA.entries(JarFile.this);\n-\n-        return new Enumeration<>() {\n-\n-            JarEntry entry;\n-\n-            public boolean hasMoreElements() {\n-                if (entry != null) {\n-                    return true;\n-                }\n-                while (unfilteredEntries.hasMoreElements()) {\n-                    JarEntry je = unfilteredEntries.nextElement();\n-                    if (JarVerifier.isSigningRelated(je.getName())) {\n-                        continue;\n-                    }\n-                    entry = je;\n-                    return true;\n-                }\n-                return false;\n-            }\n-\n-            public JarEntry nextElement() {\n-                if (hasMoreElements()) {\n-                    JarEntry je = entry;\n-                    entry = null;\n-                    return newEntry(je);\n-                }\n-                throw new NoSuchElementException();\n-            }\n-        };\n-    }\n-\n-    CodeSource[] getCodeSources(URL url) {\n-        ensureInitialization();\n-        if (jv != null) {\n-            return jv.getCodeSources(this, url);\n-        }\n-\n-        \/*\n-         * JAR file has no signed content. Is there a non-signing\n-         * code source?\n-         *\/\n-        Enumeration<String> unsigned = unsignedEntryNames();\n-        if (unsigned.hasMoreElements()) {\n-            return new CodeSource[]{JarVerifier.getUnsignedCS(url)};\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private Enumeration<String> unsignedEntryNames() {\n-        final Enumeration<JarEntry> entries = entries();\n-        return new Enumeration<>() {\n-\n-            String name;\n-\n-            \/*\n-             * Grab entries from ZIP directory but screen out\n-             * metadata.\n-             *\/\n-            public boolean hasMoreElements() {\n-                if (name != null) {\n-                    return true;\n-                }\n-                while (entries.hasMoreElements()) {\n-                    String value;\n-                    ZipEntry e = entries.nextElement();\n-                    value = e.getName();\n-                    if (e.isDirectory() || JarVerifier.isSigningRelated(value)) {\n-                        continue;\n-                    }\n-                    name = value;\n-                    return true;\n-                }\n-                return false;\n-            }\n-\n-            public String nextElement() {\n-                if (hasMoreElements()) {\n-                    String value = name;\n-                    name = null;\n-                    return value;\n-                }\n-                throw new NoSuchElementException();\n-            }\n-        };\n-    }\n-\n-    CodeSource getCodeSource(URL url, String name) {\n-        ensureInitialization();\n-        if (jv != null) {\n-            if (jv.eagerValidation) {\n-                CodeSource cs;\n-                JarEntry je = getJarEntry(name);\n-                if (je != null) {\n-                    cs = jv.getCodeSource(url, this, je);\n-                } else {\n-                    cs = jv.getCodeSource(url, name);\n-                }\n-                return cs;\n-            } else {\n-                return jv.getCodeSource(url, name);\n-            }\n-        }\n-\n-        return JarVerifier.getUnsignedCS(url);\n-    }\n-\n-    void setEagerValidation(boolean eager) {\n-        try {\n-            maybeInstantiateVerifier();\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-        if (jv != null) {\n-            jv.setEagerValidation(eager);\n-        }\n-    }\n-\n-    List<Object> getManifestDigests() {\n-        ensureInitialization();\n-        if (jv != null) {\n-            return jv.getManifestDigests();\n-        }\n-        return new ArrayList<>();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":2,"deletions":198,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.net.URL;\n@@ -31,1 +30,4 @@\n-import java.security.*;\n+import java.security.CodeSigner;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SignatureException;\n+import java.security.cert.Certificate;\n@@ -33,1 +35,0 @@\n-import java.util.zip.ZipEntry;\n@@ -90,6 +91,0 @@\n-    \/** controls eager signature validation *\/\n-    boolean eagerValidation;\n-\n-    \/** makes code source singleton instances unique to us *\/\n-    private Object csdomain = new Object();\n-\n@@ -335,7 +330,1 @@\n-    \/**\n-     * Return an array of java.security.cert.Certificate objects for\n-     * the given file in the jar.\n-     * @deprecated\n-     *\/\n-    @Deprecated\n-    public java.security.cert.Certificate[] getCerts(String name)\n+    public Certificate[] getCerts(JarEntry entry)\n@@ -343,6 +332,1 @@\n-        return mapSignersToCertArray(getCodeSigners(name));\n-    }\n-\n-    public java.security.cert.Certificate[] getCerts(JarFile jar, JarEntry entry)\n-    {\n-        return mapSignersToCertArray(getCodeSigners(jar, entry));\n+        return mapSignersToCertArray(getCodeSigners(entry));\n@@ -361,1 +345,1 @@\n-    public CodeSigner[] getCodeSigners(JarFile jar, JarEntry entry)\n+    public CodeSigner[] getCodeSigners(JarEntry entry)\n@@ -363,18 +347,1 @@\n-        String name = entry.getName();\n-        if (eagerValidation && sigFileSigners.get(name) != null) {\n-            \/*\n-             * Force a read of the entry data to generate the\n-             * verification hash.\n-             *\/\n-            try {\n-                InputStream s = jar.getInputStream(entry);\n-                byte[] buffer = new byte[1024];\n-                int n = buffer.length;\n-                while (n != -1) {\n-                    n = s.read(buffer, 0, buffer.length);\n-                }\n-                s.close();\n-            } catch (IOException e) {\n-            }\n-        }\n-        return getCodeSigners(name);\n+        return getCodeSigners(entry.getName());\n@@ -387,1 +354,1 @@\n-    private static java.security.cert.Certificate[] mapSignersToCertArray(\n+    private static Certificate[] mapSignersToCertArray(\n@@ -391,1 +358,1 @@\n-            ArrayList<java.security.cert.Certificate> certChains = new ArrayList<>();\n+            ArrayList<Certificate> certChains = new ArrayList<>();\n@@ -399,1 +366,1 @@\n-                    new java.security.cert.Certificate[certChains.size()]);\n+                    new Certificate[certChains.size()]);\n@@ -513,363 +480,0 @@\n-    \/\/ Extended JavaUtilJarAccess CodeSource API Support\n-\n-    private Map<URL, Map<CodeSigner[], CodeSource>> urlToCodeSourceMap = new HashMap<>();\n-    private Map<CodeSigner[], CodeSource> signerToCodeSource = new HashMap<>();\n-    private URL lastURL;\n-    private Map<CodeSigner[], CodeSource> lastURLMap;\n-\n-    \/*\n-     * Create a unique mapping from codeSigner cache entries to CodeSource.\n-     * In theory, multiple URLs origins could map to a single locally cached\n-     * and shared JAR file although in practice there will be a single URL in use.\n-     *\/\n-    private synchronized CodeSource mapSignersToCodeSource(URL url, CodeSigner[] signers) {\n-        Map<CodeSigner[], CodeSource> map;\n-        if (url == lastURL) {\n-            map = lastURLMap;\n-        } else {\n-            map = urlToCodeSourceMap.get(url);\n-            if (map == null) {\n-                map = new HashMap<>();\n-                urlToCodeSourceMap.put(url, map);\n-            }\n-            lastURLMap = map;\n-            lastURL = url;\n-        }\n-        CodeSource cs = map.get(signers);\n-        if (cs == null) {\n-            cs = new VerifierCodeSource(csdomain, url, signers);\n-            signerToCodeSource.put(signers, cs);\n-        }\n-        return cs;\n-    }\n-\n-    private CodeSource[] mapSignersToCodeSources(URL url, List<CodeSigner[]> signers, boolean unsigned) {\n-        List<CodeSource> sources = new ArrayList<>();\n-\n-        for (CodeSigner[] signer : signers) {\n-            sources.add(mapSignersToCodeSource(url, signer));\n-        }\n-        if (unsigned) {\n-            sources.add(mapSignersToCodeSource(url, null));\n-        }\n-        return sources.toArray(new CodeSource[sources.size()]);\n-    }\n-    private CodeSigner[] emptySigner = new CodeSigner[0];\n-\n-    \/*\n-     * Match CodeSource to a CodeSigner[] in the signer cache.\n-     *\/\n-    private CodeSigner[] findMatchingSigners(CodeSource cs) {\n-        if (cs instanceof VerifierCodeSource vcs) {\n-            if (vcs.isSameDomain(csdomain)) {\n-                return vcs.getPrivateSigners();\n-            }\n-        }\n-\n-        \/*\n-         * In practice signers should always be optimized above\n-         * but this handles a CodeSource of any type, just in case.\n-         *\/\n-        CodeSource[] sources = mapSignersToCodeSources(cs.getLocation(), getJarCodeSigners(), true);\n-        List<CodeSource> sourceList = new ArrayList<>();\n-        for (CodeSource source : sources) {\n-            sourceList.add(source);\n-        }\n-        int j = sourceList.indexOf(cs);\n-        if (j != -1) {\n-            CodeSigner[] match;\n-            match = ((VerifierCodeSource) sourceList.get(j)).getPrivateSigners();\n-            if (match == null) {\n-                match = emptySigner;\n-            }\n-            return match;\n-        }\n-        return null;\n-    }\n-\n-    \/*\n-     * Instances of this class hold uncopied references to internal\n-     * signing data that can be compared by object reference identity.\n-     *\/\n-    private static class VerifierCodeSource extends CodeSource {\n-        @java.io.Serial\n-        private static final long serialVersionUID = -9047366145967768825L;\n-\n-        URL vlocation;\n-        CodeSigner[] vsigners;\n-        java.security.cert.Certificate[] vcerts;\n-        @SuppressWarnings(\"serial\") \/\/ Not statically typed as Serializable\n-        Object csdomain;\n-\n-        VerifierCodeSource(Object csdomain, URL location, CodeSigner[] signers) {\n-            super(location, signers);\n-            this.csdomain = csdomain;\n-            vlocation = location;\n-            vsigners = signers; \/\/ from signerCache\n-        }\n-\n-        VerifierCodeSource(Object csdomain, URL location, java.security.cert.Certificate[] certs) {\n-            super(location, certs);\n-            this.csdomain = csdomain;\n-            vlocation = location;\n-            vcerts = certs; \/\/ from signerCache\n-        }\n-\n-        \/*\n-         * All VerifierCodeSource instances are constructed based on\n-         * singleton signerCache or signerCacheCert entries for each unique signer.\n-         * No CodeSigner<->Certificate[] conversion is required.\n-         * We use these assumptions to optimize equality comparisons.\n-         *\/\n-        public boolean equals(Object obj) {\n-            if (obj == this) {\n-                return true;\n-            }\n-            if (obj instanceof VerifierCodeSource that) {\n-\n-                \/*\n-                 * Only compare against other per-signer singletons constructed\n-                 * on behalf of the same JarFile instance. Otherwise, compare\n-                 * things the slower way.\n-                 *\/\n-                if (isSameDomain(that.csdomain)) {\n-                    if (that.vsigners != this.vsigners\n-                            || that.vcerts != this.vcerts) {\n-                        return false;\n-                    }\n-                    if (that.vlocation != null) {\n-                        return that.vlocation.equals(this.vlocation);\n-                    } else if (this.vlocation != null) {\n-                        return this.vlocation.equals(that.vlocation);\n-                    } else { \/\/ both null\n-                        return true;\n-                    }\n-                }\n-            }\n-            return super.equals(obj);\n-        }\n-\n-        boolean isSameDomain(Object csdomain) {\n-            return this.csdomain == csdomain;\n-        }\n-\n-        private CodeSigner[] getPrivateSigners() {\n-            return vsigners;\n-        }\n-\n-        private java.security.cert.Certificate[] getPrivateCertificates() {\n-            return vcerts;\n-        }\n-    }\n-    private Map<String, CodeSigner[]> signerMap;\n-\n-    private synchronized Map<String, CodeSigner[]> signerMap() {\n-        if (signerMap == null) {\n-            \/*\n-             * Snapshot signer state so it doesn't change on us. We care\n-             * only about the asserted signatures. Verification of\n-             * signature validity happens via the JarEntry apis.\n-             *\/\n-            signerMap = HashMap.newHashMap(verifiedSigners.size() + sigFileSigners.size());\n-            signerMap.putAll(verifiedSigners);\n-            signerMap.putAll(sigFileSigners);\n-        }\n-        return signerMap;\n-    }\n-\n-    public synchronized Enumeration<String> entryNames(JarFile jar, final CodeSource[] cs) {\n-        final Map<String, CodeSigner[]> map = signerMap();\n-        final Iterator<Map.Entry<String, CodeSigner[]>> itor = map.entrySet().iterator();\n-        boolean matchUnsigned = false;\n-\n-        \/*\n-         * Grab a single copy of the CodeSigner arrays. Check\n-         * to see if we can optimize CodeSigner equality test.\n-         *\/\n-        List<CodeSigner[]> req = new ArrayList<>(cs.length);\n-        for (CodeSource c : cs) {\n-            CodeSigner[] match = findMatchingSigners(c);\n-            if (match != null) {\n-                if (match.length > 0) {\n-                    req.add(match);\n-                } else {\n-                    matchUnsigned = true;\n-                }\n-            } else {\n-                matchUnsigned = true;\n-            }\n-        }\n-\n-        final List<CodeSigner[]> signersReq = req;\n-        final Enumeration<String> enum2 = matchUnsigned ? unsignedEntryNames(jar) : Collections.emptyEnumeration();\n-\n-        return new Enumeration<>() {\n-\n-            String name;\n-\n-            public boolean hasMoreElements() {\n-                if (name != null) {\n-                    return true;\n-                }\n-\n-                while (itor.hasNext()) {\n-                    Map.Entry<String, CodeSigner[]> e = itor.next();\n-                    if (signersReq.contains(e.getValue())) {\n-                        name = e.getKey();\n-                        return true;\n-                    }\n-                }\n-                while (enum2.hasMoreElements()) {\n-                    name = enum2.nextElement();\n-                    return true;\n-                }\n-                return false;\n-            }\n-\n-            public String nextElement() {\n-                if (hasMoreElements()) {\n-                    String value = name;\n-                    name = null;\n-                    return value;\n-                }\n-                throw new NoSuchElementException();\n-            }\n-        };\n-    }\n-\n-    \/*\n-     * Like entries() but screens out internal JAR mechanism entries\n-     * and includes signed entries with no ZIP data.\n-     *\/\n-    public Enumeration<JarEntry> entries2(final JarFile jar, Enumeration<JarEntry> e) {\n-        final Map<String, CodeSigner[]> map = new HashMap<>();\n-        map.putAll(signerMap());\n-        final Enumeration<JarEntry> enum_ = e;\n-        return new Enumeration<>() {\n-\n-            Enumeration<String> signers = null;\n-            JarEntry entry;\n-\n-            public boolean hasMoreElements() {\n-                if (entry != null) {\n-                    return true;\n-                }\n-                while (enum_.hasMoreElements()) {\n-                    JarEntry je = enum_.nextElement();\n-                    if (JarVerifier.isSigningRelated(je.getName())) {\n-                        continue;\n-                    }\n-                    entry = jar.newEntry(je);\n-                    return true;\n-                }\n-                if (signers == null) {\n-                    signers = Collections.enumeration(map.keySet());\n-                }\n-                while (signers.hasMoreElements()) {\n-                    String name = signers.nextElement();\n-                    entry = jar.newEntry(name);\n-                    return true;\n-                }\n-\n-                \/\/ Any map entries left?\n-                return false;\n-            }\n-\n-            public JarEntry nextElement() {\n-                if (hasMoreElements()) {\n-                    JarEntry je = entry;\n-                    map.remove(je.getName());\n-                    entry = null;\n-                    return je;\n-                }\n-                throw new NoSuchElementException();\n-            }\n-        };\n-    }\n-\n-    \/\/ true if file is part of the signature mechanism itself\n-    static boolean isSigningRelated(String name) {\n-        return SignatureFileVerifier.isSigningRelated(name);\n-    }\n-\n-    private Enumeration<String> unsignedEntryNames(JarFile jar) {\n-        final Map<String, CodeSigner[]> map = signerMap();\n-        final Enumeration<JarEntry> entries = jar.entries();\n-        return new Enumeration<>() {\n-\n-            String name;\n-\n-            \/*\n-             * Grab entries from ZIP directory but screen out\n-             * metadata.\n-             *\/\n-            public boolean hasMoreElements() {\n-                if (name != null) {\n-                    return true;\n-                }\n-                while (entries.hasMoreElements()) {\n-                    String value;\n-                    ZipEntry e = entries.nextElement();\n-                    value = e.getName();\n-                    if (e.isDirectory() || isSigningRelated(value)) {\n-                        continue;\n-                    }\n-                    if (map.get(value) == null) {\n-                        name = value;\n-                        return true;\n-                    }\n-                }\n-                return false;\n-            }\n-\n-            public String nextElement() {\n-                if (hasMoreElements()) {\n-                    String value = name;\n-                    name = null;\n-                    return value;\n-                }\n-                throw new NoSuchElementException();\n-            }\n-        };\n-    }\n-    private List<CodeSigner[]> jarCodeSigners;\n-\n-    private synchronized List<CodeSigner[]> getJarCodeSigners() {\n-        if (jarCodeSigners == null) {\n-            HashSet<CodeSigner[]> set = new HashSet<>();\n-            set.addAll(signerMap().values());\n-            jarCodeSigners = new ArrayList<>();\n-            jarCodeSigners.addAll(set);\n-        }\n-        return jarCodeSigners;\n-    }\n-\n-    public synchronized CodeSource[] getCodeSources(JarFile jar, URL url) {\n-        boolean hasUnsigned = unsignedEntryNames(jar).hasMoreElements();\n-\n-        return mapSignersToCodeSources(url, getJarCodeSigners(), hasUnsigned);\n-    }\n-\n-    public CodeSource getCodeSource(URL url, String name) {\n-        CodeSigner[] signers;\n-\n-        signers = signerMap().get(name);\n-        return mapSignersToCodeSource(url, signers);\n-    }\n-\n-    public CodeSource getCodeSource(URL url, JarFile jar, JarEntry je) {\n-        return mapSignersToCodeSource(url, getCodeSigners(jar, je));\n-    }\n-\n-    public void setEagerValidation(boolean eager) {\n-        eagerValidation = eager;\n-    }\n-\n-    public synchronized List<Object> getManifestDigests() {\n-        return Collections.unmodifiableList(manifestDigests);\n-    }\n-\n-    static CodeSource getUnsignedCS(URL url) {\n-        return new VerifierCodeSource(null, url, (java.security.cert.Certificate[]) null);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarVerifier.java","additions":11,"deletions":407,"binary":false,"changes":418,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,6 +29,0 @@\n-import java.net.URL;\n-import java.security.CodeSource;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n@@ -43,24 +37,0 @@\n-    public CodeSource[] getCodeSources(JarFile jar, URL url) {\n-        return jar.getCodeSources(url);\n-    }\n-\n-    public CodeSource getCodeSource(JarFile jar, URL url, String name) {\n-        return jar.getCodeSource(url, name);\n-    }\n-\n-    public Enumeration<String> entryNames(JarFile jar, CodeSource[] cs) {\n-        return jar.entryNames(cs);\n-    }\n-\n-    public Enumeration<JarEntry> entries2(JarFile jar) {\n-        return jar.entries2();\n-    }\n-\n-    public void setEagerValidation(JarFile jar, boolean eager) {\n-        jar.setEagerValidation(eager);\n-    }\n-\n-    public List<Object> getManifestDigests(JarFile jar) {\n-        return jar.getManifestDigests();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JavaUtilJarAccessImpl.java","additions":1,"deletions":31,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,0 @@\n-import java.net.URL;\n-import java.security.CodeSource;\n-import java.util.Enumeration;\n-import java.util.List;\n@@ -40,6 +36,0 @@\n-    public CodeSource[] getCodeSources(JarFile jar, URL url);\n-    public CodeSource getCodeSource(JarFile jar, URL url, String name);\n-    public Enumeration<String> entryNames(JarFile jar, CodeSource[] cs);\n-    public Enumeration<JarEntry> entries2(JarFile jar);\n-    public void setEagerValidation(JarFile jar, boolean eager);\n-    public List<Object> getManifestDigests(JarFile jar);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilJarAccess.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"}]}