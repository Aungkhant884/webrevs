{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n@@ -162,0 +163,1 @@\n+  e.set_objectSize(sample->allocated());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -630,0 +630,1 @@\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"objectSize\" label=\"Object Size\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.oldobject;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedObject;\n+import jdk.jfr.internal.test.WhiteBox;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @run main\/othervm  -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectSize\n+ *\/\n+public class TestObjectSize {\n+\n+    private interface Leak {\n+    }\n+    private static class Leak1 implements Leak {\n+        private long field1;\n+    }\n+    private static class Leak2 implements Leak {\n+        private long field1;\n+        private long field2;\n+    }\n+    private static class Leak3 implements Leak {\n+        private long field1;\n+        private long field2;\n+        private long field3;\n+    }\n+\n+    public static List<Object> leak = new ArrayList<>(OldObjects.MIN_SIZE);\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox.setWriteAllObjectSamples(true);\n+\n+        final Random rand = new Random(1L);\n+\n+        long sizeLeak1, sizeLeak2, sizeLeak3;\n+\n+        do {\n+            sizeLeak1 = -1;\n+            sizeLeak2 = -1;\n+            sizeLeak3 = -1;\n+\n+            try (Recording recording = new Recording()) {\n+                leak.clear();\n+                recording.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n+                recording.start();\n+\n+                for (int i = 0; i < 1000; i++) {\n+                    switch (rand.nextInt(3)) {\n+                    case 0: leak.add(new Leak1()); break;\n+                    case 1: leak.add(new Leak2()); break;\n+                    case 2: leak.add(new Leak3()); break;\n+                    }\n+                }\n+\n+                recording.stop();\n+\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                Events.hasEvents(events);\n+                for (RecordedEvent e : events) {\n+                    RecordedObject object = e.getValue(\"object\");\n+                    RecordedClass type = object.getValue(\"type\");\n+                    long objectSize = e.getLong(\"objectSize\");\n+                    System.err.println(\"type = \" + type.getName() + \", objectSize = \" + e.getLong(\"objectSize\"));\n+                    if (objectSize <= 0) {\n+                        throw new Exception(\"Object size for \" + type.getName() + \" is lower or equal to 0\");\n+                    }\n+                    if (type.getName().equals(Leak1.class.getName())) {\n+                        sizeLeak1 = objectSize;\n+                    }\n+                    if (type.getName().equals(Leak2.class.getName())) {\n+                        sizeLeak2 = objectSize;\n+                    }\n+                    if (type.getName().equals(Leak3.class.getName())) {\n+                        sizeLeak3 = objectSize;\n+                    }\n+                }\n+            }\n+        } while (sizeLeak1 == -1 || sizeLeak2 == -1 || sizeLeak3 == -1);\n+\n+        if (sizeLeak3 <= sizeLeak2) {\n+            throw new Exception(\"Object size for \" + Leak3.class.getName() + \" is lower or equal to size for\" + Leak2.class.getName());\n+        }\n+        if (sizeLeak2 <= sizeLeak1) {\n+            throw new Exception(\"Object size for \" + Leak2.class.getName() + \" is lower or equal to size for\" + Leak1.class.getName());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestObjectSize.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}