{"files":[{"patch":"@@ -45,0 +45,1 @@\n+    jdk.incubator.concurrent \\\n","filename":"make\/conf\/docs-modules.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+    jdk.incubator.concurrent \\\n","filename":"make\/conf\/module-loader-map.conf","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,0 +203,1 @@\n+        jdk.incubator.concurrent,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.concurrent;\n+\n+\/**\n+ * Thrown when a structure violation is detected.\n+ *\n+ * @see StructuredTaskScope#fork(Callable)\n+ * @see StructuredTaskScope#close()\n+ *\n+ * @since 19\n+ *\/\n+public final class StructureViolationException extends RuntimeException {\n+    @java.io.Serial\n+    private static final long serialVersionUID = -7705327650798235468L;\n+\n+    \/**\n+     * Constructs a {@code StructureViolationException} with no detail message.\n+     *\/\n+    public StructureViolationException() {\n+        super();\n+    }\n+\n+    \/**\n+     * Constructs a {@code StructureViolationException} with the specified\n+     * detail message.\n+     *\n+     * @param  message the detail message, can be null\n+     *\/\n+    public StructureViolationException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructureViolationException.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,1189 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Method;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Function;\n+import jdk.internal.misc.PreviewFeatures;\n+import jdk.internal.misc.ThreadFlock;\n+\n+\/**\n+ * A basic API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports\n+ * cases where a task splits into several concurrent subtasks, to be executed in their\n+ * own threads, and where the subtasks must complete before the main task continues. A\n+ * {@code StructuredTaskScope} can be used to ensure that the lifetime of a concurrent\n+ * operation is confined by a <em>syntax block<\/em>, just like that of a sequential\n+ * operation in structured programming.\n+ *\n+ * <h2>Basic usage<\/h2>\n+ *\n+ * A {@code StructuredTaskScope} is created with one of its public constructors. It defines\n+ * the {@link #fork(Callable) fork} method to start a thread to execute a task, the {@link\n+ * #join() join} method to wait for all threads to finish, and the {@link #close() close}\n+ * method to close the task scope. The API is intended to be used with the {@code\n+ * try-with-resources} construct. The intention is that code in the <em>block<\/em> uses\n+ * the {@code fork} method to fork threads to execute the subtasks, wait for the threads\n+ * to finish with the {@code join} method, and then <em>process the results<\/em>.\n+ * Processing of results may include handling or re-throwing of exceptions.\n+ * {@snippet lang=java :\n+ *     try (var scope = new StructuredTaskScope<Object>()) {\n+ *\n+ *         Future<Integer> future1 = scope.fork(task1);   \/\/ @highlight substring=\"fork\"\n+ *         Future<String> future2 = scope.fork(task2);    \/\/ @highlight substring=\"fork\"\n+ *\n+ *         scope.join();                                  \/\/ @highlight substring=\"join\"\n+ *\n+ *         ... process results\/exceptions ...\n+ *\n+ *     } \/\/ close                                         \/\/ @highlight substring=\"close\"\n+ * }\n+ * To ensure correct usage, the {@code join} and {@code close} methods may only be invoked\n+ * by the <em>owner<\/em> (the thread that opened\/created the task scope}, and the\n+ * {@code close} method throws an exception after closing if the owner did not invoke the\n+ * {@code join} method after forking.\n+ *\n+ * <p> {@code StructuredTaskScope} defines the {@link #shutdown() shutdown} method to shut\n+ * down a task scope without closing it. Shutdown is useful for cases where a subtask\n+ * completes with a result (or exception) and the results of other unfinished subtasks are\n+ * no longer needed. If a subtask invokes {@code shutdown} while the owner is waiting in\n+ * the {@code join} method then it will cause {@code join} to wakeup, all unfinished\n+ * threads to be {@linkplain Thread#interrupt() interrupted} and prevents new threads\n+ * from starting in the task scope.\n+ *\n+ * <h2>Subclasses with policies for common cases<\/h2>\n+ *\n+ * Two subclasses of {@code StructuredTaskScope} are defined to implement policy for\n+ * common cases:\n+ * <ol>\n+ *   <li> {@link ShutdownOnSuccess ShutdownOnSuccess} captures the first result and\n+ *   shuts down the task scope to interrupt unfinished threads and wakeup the owner. This\n+ *   class is intended for cases where the result of any subtask will do (\"invoke any\")\n+ *   and where there is no need to wait for results of other unfinished tasks. It defines\n+ *   methods to get the first result or throw an exception if all subtasks fail.\n+ *   <li> {@link ShutdownOnFailure ShutdownOnFailure} captures the first exception and\n+ *   shuts down the task scope. This class is intended for cases where the results of all\n+ *   subtasks are required (\"invoke all\"); if any subtask fails then the results of other\n+ *   unfinished subtasks are no longer needed. If defines methods to throw an exception if\n+ *   any of the subtasks fail.\n+ * <\/ol>\n+ *\n+ * <p> The following are two examples that use the two classes. In both cases, a pair of\n+ * subtasks are forked to fetch resources from two URL locations \"left\" and \"right\". The\n+ * first example creates a ShutdownOnSuccess object to capture the result of the first\n+ * subtask to complete normally, cancelling the other by way of shutting down the task\n+ * scope. The main task waits in {@code join} until either subtask completes with a result\n+ * or both subtasks fail. It invokes {@link ShutdownOnSuccess#result(Function)\n+ * result(Function)} method to get the captured result. If both subtasks fail then this\n+ * method throws a {@code WebApplicationException} with the exception from one of the\n+ * subtasks as the cause.\n+ * {@snippet lang=java :\n+ *     try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n+ *\n+ *         scope.fork(() -> fetch(left));\n+ *         scope.fork(() -> fetch(right));\n+ *\n+ *         scope.join();\n+ *\n+ *         \/\/ @link regex=\"result(?=\\()\" target=\"ShutdownOnSuccess#result\" :\n+ *         String result = scope.result(e -> new WebApplicationException(e));\n+ *\n+ *         ...\n+ *     }\n+ * }\n+ * The second example creates a ShutdownOnFailure object to capture the exception of the\n+ * first subtask to fail, cancelling the other by way of shutting down the task scope. The\n+ * main task waits in {@link #joinUntil(Instant)} until both subtasks complete with a\n+ * result, either fails, or a deadline is reached. It invokes {@link\n+ * ShutdownOnFailure#throwIfFailed(Function) throwIfFailed(Function)} to throw an exception\n+ * when either subtask fails. This method is a no-op if no subtasks fail. The main task\n+ * uses {@code Future}'s {@link Future#resultNow() resultNow()} method to retrieve the\n+ * results.\n+ *\n+ * {@snippet lang=java :\n+ *    Instant deadline = ...\n+ *\n+ *    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n+ *\n+ *         Future<String> future1 = scope.fork(() -> query(left));\n+ *         Future<String> future2 = scope.fork(() -> query(right));\n+ *\n+ *         scope.joinUntil(deadline);\n+ *\n+ *         \/\/ @link substring=\"throwIfFailed\" target=\"ShutdownOnFailure#throwIfFailed\" :\n+ *         scope.throwIfFailed(e -> new WebApplicationException(e));\n+ *\n+ *         \/\/ both subtasks completed successfully\n+ *         String result = Stream.of(future1, future2)\n+ *                 \/\/ @link substring=\"Future::resultNow\" target=\"Future#resultNow\" :\n+ *                 .map(Future::resultNow)\n+ *                 .collect(Collectors.joining(\", \", \"{ \", \" }\"));\n+ *\n+ *         ...\n+ *     }\n+ * }\n+ *\n+ * <h2>Extending StructuredTaskScope<\/h2>\n+ *\n+ * {@code StructuredTaskScope} can be extended, and the {@link #handleComplete(Future)\n+ * handleComplete} overridden, to implement policies other than those implemented by\n+ * {@code ShutdownOnSuccess} and {@code ShutdownOnFailure}. The method may be overridden\n+ * to, for example, collect the results of subtasks that complete with a result and ignore\n+ * subtasks that fail. It may collect exceptions when subtasks fail. It may invoke the\n+ * {@link #shutdown() shutdown} method to shut down and cause {@link #join() join} to\n+ * wakeup when some condition arises.\n+ *\n+ * <p> A subclass will typically define methods to make available results, state, or other\n+ * outcome to code that executes after the {@code join} method. A subclass that collects\n+ * results and ignores subtasks that fail may define a method that returns a collection of\n+ * results. A subclass that implements a policy to shut down when a subtask fails may\n+ * define a method to retrieve the exception of the first subtask to fail.\n+ *\n+ * <p> The following is an example of a {@code StructuredTaskScope} implementation that\n+ * collects the results of subtasks that complete successfully. It defines the method\n+ * <b>{@code results()}<\/b> to be used by the main task to retrieve the results.\n+ *\n+ * {@snippet lang=java :\n+ *     class MyScope<T> extends StructuredTaskScope<T> {\n+ *         private final Queue<T> results = new ConcurrentLinkedQueue<>();\n+ *\n+ *         MyScope() {\n+ *             super(null, Thread.ofVirtual().factory());\n+ *         }\n+ *\n+ *         @Override\n+ *         \/\/ @link substring=\"handleComplete\" target=\"handleComplete\" :\n+ *         protected void handleComplete(Future<T> future) {\n+ *             if (future.state() == Future.State.SUCCESS) {\n+ *                 T result = future.resultNow();\n+ *                 results.add(result);\n+ *             }\n+ *         }\n+ *\n+ *         \/\/ Returns a stream of results from the subtasks that completed successfully\n+ *         public Stream<T> results() {     \/\/ @highlight substring=\"results\"\n+ *             return results.stream();\n+ *         }\n+ *     }\n+ *  }\n+ *\n+ * <h2><a id=\"TreeStructure\">Tree structure<\/a><\/h2>\n+ *\n+ * StructuredTaskScopes form a tree where parent-child relations are established\n+ * implicitly when opening a new task scope:\n+ * <ul>\n+ *   <li> A parent-child relation is established when a thread started in a task scope\n+ *   opens its own task scope. A thread started in task scope \"A\" that opens task scope\n+ *   \"B\" establishes a parent-child relation where task scope \"A\" is the parent of task\n+ *   scope \"B\".\n+ *   <li> A parent-child relation is established with nesting. If a thread opens task\n+ *   scope \"B\", then opens task scope \"C\" (before it closes \"B\"), then the enclosing task\n+ *   scope \"B\" is the parent of the nested task scope \"C\".\n+ * <\/ul>\n+ *\n+ * <p> The tree structure supports confinement checks. The phrase \"threads contained in\n+ * the task scope\" in method descriptions means threads started in the task scope or\n+ * descendant scopes. {@code StructuredTaskScope} does not define APIs that exposes the\n+ * tree structure at this time.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+ * or method in this class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * <h2>Memory consistency effects<\/h2>\n+ *\n+ * <p> Actions in the owner thread of, or a thread contained in, the task scope prior to\n+ * {@linkplain #fork forking} of a {@code Callable} task\n+ * <a href=\"..\/..\/..\/..\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n+ * <i>happen-before<\/i><\/a> any actions taken by that task, which in turn <i>happen-before<\/i>\n+ * the task result is retrieved via its {@code Future}, or <i>happen-before<\/i> any actions\n+ * taken in a thread after {@linkplain #join() joining} of the task scope.\n+ *\n+ * @jls 17.4.5 Happens-before Order\n+ *\n+ * @param <T> the result type of tasks executed in the scope\n+ * @since 19\n+ *\/\n+public class StructuredTaskScope<T> implements AutoCloseable {\n+    private static final VarHandle FUTURES;\n+    static {\n+        try {\n+            MethodHandles.Lookup l = MethodHandles.lookup();\n+            FUTURES = l.findVarHandle(StructuredTaskScope.class, \"futures\", Set.class);\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private final ThreadFactory factory;\n+    private final ThreadFlock flock;\n+    private final ReentrantLock shutdownLock = new ReentrantLock();\n+\n+    \/\/ lazily created set of Future objects with threads waiting in Future::get\n+    private volatile Set<Future<?>> futures;\n+\n+    \/\/ set by owner when it forks, reset by owner when it joins\n+    private boolean needJoin;\n+\n+    \/\/ states: OPEN -> SHUTDOWN -> CLOSED\n+    private static final int OPEN     = 0;   \/\/ initial state\n+    private static final int SHUTDOWN = 1;\n+    private static final int CLOSED   = 2;\n+\n+    \/\/ scope state, set by owner, read by any thread\n+    private volatile int state;\n+\n+    \/**\n+     * Creates a structured task scope with the given name and thread factory. The task\n+     * scope is optionally named for the purposes of monitoring and management. The thread\n+     * factory is used to {@link ThreadFactory#newThread(Runnable) create} threads when\n+     * tasks are {@linkplain #fork(Callable) forked}. The task scope is owned by the\n+     * current thread.\n+     *\n+     * @param name the name of the task scope, can be null\n+     * @param factory the thread factory\n+     *\/\n+    public StructuredTaskScope(String name, ThreadFactory factory) {\n+        this.factory = Objects.requireNonNull(factory, \"'factory' is null\");\n+        this.flock = ThreadFlock.open(name);\n+    }\n+\n+    \/**\n+     * Creates an unnamed structured task scope that creates virtual threads. The task\n+     * scope is owned by the current thread.\n+     *\n+     * <p> This method is equivalent to invoking the 2-arg constructor with a name of\n+     * {@code null} and a thread factory that creates virtual threads.\n+     *\n+     * @throws UnsupportedOperationException if preview features are not enabled\n+     *\/\n+    public StructuredTaskScope() {\n+        PreviewFeatures.ensureEnabled();\n+        this.factory = FactoryHolder.VIRTUAL_THREAD_FACTORY;\n+        this.flock = ThreadFlock.open(null);\n+    }\n+\n+    \/**\n+     * Throws WrongThreadException if the current thread is not the owner.\n+     *\/\n+    private void ensureOwner() {\n+        if (Thread.currentThread() != flock.owner())\n+            throw new WrongThreadException(\"Current thread not owner\");\n+    }\n+\n+    \/**\n+     * Throws WrongThreadException if the current thread is not the owner\n+     * or a thread contained in the tree.\n+     *\/\n+    private void ensureOwnerOrContainsThread() {\n+        Thread currentThread = Thread.currentThread();\n+        if (currentThread != flock.owner() && !flock.containsThread(currentThread))\n+            throw new WrongThreadException(\"Current thread not owner or thread in the tree\");\n+    }\n+\n+    \/**\n+     * Tests if the task scope is shutdown.\n+     *\/\n+    private boolean isShutdown() {\n+        return state >= SHUTDOWN;\n+    }\n+\n+    \/**\n+     * Track the given Future.\n+     *\/\n+    private void track(Future<?> future) {\n+        \/\/ create the set of Futures if not already created\n+        Set<Future<?>> futures = this.futures;\n+        if (futures == null) {\n+            futures = ConcurrentHashMap.newKeySet();\n+            if (!FUTURES.compareAndSet(this, null, futures)) {\n+                \/\/ lost the race\n+                futures = this.futures;\n+            }\n+        }\n+        futures.add(future);\n+    }\n+\n+    \/**\n+     * Stop tracking the Future.\n+     *\/\n+    private void untrack(Future<?> future) {\n+        assert futures != null;\n+        futures.remove(future);\n+    }\n+\n+    \/**\n+     * Invoked when a task completes before the scope is shut down.\n+     *\n+     * <p> The {@code handleComplete} method should be thread safe. It may be invoked by\n+     * several threads concurrently.\n+     *\n+     * @implSpec The default implementation does nothing.\n+     *\n+     * @param future the completed task\n+     *\/\n+    protected void handleComplete(Future<T> future) { }\n+\n+    \/**\n+     * Starts a new thread to run the given task.\n+     *\n+     * <p> The new thread is created with the task scope's {@link ThreadFactory}.\n+     *\n+     * <p> If the task completes before the task scope is {@link #shutdown() shutdown}\n+     * then the {@link #handleComplete(Future) handle} method is invoked to consume the\n+     * completed task. The {@code handleComplete} method is run when the task completes\n+     * with a result or exception. If the {@code Future} {@link Future#cancel(boolean)\n+     * cancel} method is used the cancel a task before the task scope is shut down, then\n+     * the {@code handleComplete} method is run by the thread that invokes {@code cancel}.\n+     * If the task scope shuts down at or around the same time that the task completes or\n+     * is cancelled then the {@code handleComplete} method may or may not be invoked.\n+     *\n+     * <p> If this task scope is {@linkplain #shutdown() shutdown} (or in the process\n+     * of shutting down) then {@code fork} returns a {@code Future} representing a {@link\n+     * Future.State#CANCELLED cancelled} task that was not run.\n+     *\n+     * <p> This method may only be invoked by the task scope owner or threads contained\n+     * in the task scope. The {@link Future#cancel(boolean) cancel} method of the returned\n+     * {@code Future} object is also restricted to the task scope owner or threads contained\n+     * in the task scope. The {@code cancel} method throws {@link WrongThreadException}\n+     * if invoked from another thread. All other methods on the returned {@code Future}\n+     * object, such as {@link Future#get() get}, are not restricted.\n+     *\n+     * @param task the task to run\n+     * @param <U> the result type\n+     * @return a future\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the owner or a thread\n+     * contained in the task scope\n+     * @throws RejectedExecutionException if the thread factory rejected creating a\n+     * thread to run the task\n+     *\/\n+    public <U extends T> Future<U> fork(Callable<? extends U> task) {\n+        Objects.requireNonNull(task, \"'task' is null\");\n+\n+        \/\/ create future\n+        var future = new FutureImpl<U>(this, task);\n+\n+        boolean shutdown = (state >= SHUTDOWN);\n+\n+        if (!shutdown) {\n+            \/\/ create thread\n+            Thread thread = factory.newThread(future);\n+            if (thread == null) {\n+                throw new RejectedExecutionException(\"Rejected by thread factory\");\n+            }\n+\n+            \/\/ attempt to start the thread\n+            try {\n+                flock.start(thread);\n+            } catch (IllegalStateException e) {\n+                \/\/ shutdown or in the process of shutting down\n+                shutdown = true;\n+            }\n+        }\n+\n+        if (shutdown) {\n+            if (state == CLOSED) {\n+                throw new IllegalStateException(\"Task scope is closed\");\n+            } else {\n+                future.cancel(false);\n+            }\n+        }\n+\n+        \/\/ if owner forks then it will need to join\n+        if (Thread.currentThread() == flock.owner() && !needJoin) {\n+            needJoin = true;\n+        }\n+\n+        return future;\n+    }\n+\n+    \/**\n+     * Wait for all threads to finish or the task scope to shut down.\n+     *\/\n+    private void implJoin(Duration timeout)\n+        throws InterruptedException, TimeoutException\n+    {\n+        ensureOwner();\n+        needJoin = false;\n+        int s = state;\n+        if (s >= SHUTDOWN) {\n+            if (s == CLOSED)\n+                throw new IllegalStateException(\"Task scope is closed\");\n+            return;\n+        }\n+\n+        \/\/ wait for all threads, wakeup, interrupt, or timeout\n+        if (timeout != null) {\n+            flock.awaitAll(timeout);\n+        } else {\n+            flock.awaitAll();\n+        }\n+    }\n+\n+    \/**\n+     * Wait for all threads to finish or the task scope to shut down. This method waits\n+     * until all threads started in the task scope finish execution (of both task and\n+     * {@link #handleComplete(Future) handleComplete} method), the {@link #shutdown()\n+     * shutdown} method is invoked to shut down the task scope, or the current thread\n+     * is {@linkplain Thread#interrupt() interrupted}.\n+     *\n+     * <p> This method may only be invoked by the task scope owner.\n+     *\n+     * @return this task scope\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the owner\n+     * @throws InterruptedException if interrupted while waiting\n+     *\/\n+    public StructuredTaskScope<T> join() throws InterruptedException {\n+        try {\n+            implJoin(null);\n+        } catch (TimeoutException e) {\n+            throw new InternalError();\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Wait for all threads to finish or the task scope to shut down, up to the given\n+     * deadline. This method waits until all threads started in the task scope finish\n+     * execution (of both task and {@link #handleComplete(Future) handleComplete} method),\n+     * the {@link #shutdown() shutdown} method is invoked to shut down the task scope,\n+     * the current thread is {@linkplain Thread#interrupt() interrupted}, or the deadline\n+     * is reached.\n+     *\n+     * <p> This method may only be invoked by the task scope owner.\n+     *\n+     * @param deadline the deadline\n+     * @return this task scope\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the owner\n+     * @throws InterruptedException if interrupted while waiting\n+     * @throws TimeoutException if the deadline is reached while waiting\n+     *\/\n+    public StructuredTaskScope<T> joinUntil(Instant deadline)\n+        throws InterruptedException, TimeoutException\n+    {\n+        Duration timeout = Duration.between(Instant.now(), deadline);\n+        implJoin(timeout);\n+        return this;\n+    }\n+\n+    \/**\n+     * Cancel all tracked Future objects.\n+     *\/\n+    private void cancelTrackedFutures() {\n+        Set<Future<?>> futures = this.futures;\n+        if (futures != null) {\n+            futures.forEach(f -> f.cancel(false));\n+        }\n+    }\n+\n+    \/**\n+     * Interrupt all unfinished threads.\n+     *\/\n+    private void implInterruptAll() {\n+        flock.threads().forEach(t -> {\n+            if (t != Thread.currentThread()) {\n+                t.interrupt();\n+            }\n+        });\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private void interruptAll() {\n+        if (System.getSecurityManager() == null) {\n+            implInterruptAll();\n+        } else {\n+            PrivilegedAction<Void> pa = () -> {\n+                implInterruptAll();\n+                return null;\n+            };\n+            AccessController.doPrivileged(pa);\n+        }\n+    }\n+\n+    \/**\n+     * Shutdown the task scope if not already shutdown. Return true if this method\n+     * shutdowns the task scope, false if already shutdown.\n+     *\/\n+    private boolean implShutdown() {\n+        if (state < SHUTDOWN) {\n+            shutdownLock.lock();\n+            try {\n+                if (state < SHUTDOWN) {\n+\n+                    \/\/ prevent new threads from starting\n+                    flock.shutdown();\n+\n+                    \/\/ wakeup any threads waiting in Future::get\n+                    cancelTrackedFutures();\n+\n+                    \/\/ interrupt all unfinished threads\n+                    interruptAll();\n+\n+                    state = SHUTDOWN;\n+                    return true;\n+                }\n+            } finally {\n+                shutdownLock.unlock();\n+            }\n+        }\n+        assert state >= SHUTDOWN;\n+        return false;\n+    }\n+\n+    \/**\n+     * Shut down the task scope without closing it. Shutting down a task scope prevents\n+     * new threads from starting, interrupts all unfinished threads, and causes the\n+     * {@link #join() join} method to wakeup. Shutdown is useful for cases where the\n+     * results of unfinished subtasks are no longer needed.\n+     *\n+     * <p> More specifically, this method:\n+     * <ul>\n+     * <li> {@linkplain Future#cancel(boolean) Cancels} the tasks that have threads\n+     * {@linkplain Future#get() waiting} on a result so that the waiting threads wakeup.\n+     * <li> {@linkplain Thread#interrupt() Interrupts} all unfinished threads in the\n+     * task scope (except the current thread).\n+     * <li> Wakes up the owner if it is waiting in {@link #join()} or {@link\n+     * #joinUntil(Instant)}. If the owner is not waiting then its next call to {@code\n+     * join} or {@code joinUntil} will return immediately.\n+     * <\/ul>\n+     *\n+     * <p> When this method completes then the {@code Future} objects for all tasks will\n+     * be {@linkplain Future#isDone() done}, normally or abnormally. There may still\n+     * be threads that have not finished because they are executing code that did not\n+     * respond (or respond promptly) to thread interrupt. This method does not wait\n+     * for these threads. When the owner invokes the {@link #close() close} method\n+     * to close the task scope then it will wait for the remaining threads to finish.\n+     *\n+     * <p> This method may only be invoked by the task scope owner or threads contained\n+     * in the task scope.\n+     *\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the owner or\n+     * a thread contained in the task scope\n+     *\/\n+    public void shutdown() {\n+        ensureOwnerOrContainsThread();\n+        if (state == CLOSED)\n+            throw new IllegalStateException(\"Task scope is closed\");\n+        if (implShutdown())\n+            flock.wakeup();\n+    }\n+\n+    \/**\n+     * Closes this task scope.\n+     *\n+     * <p> This method first shuts down the task scope (as if by invoking the {@link\n+     * #shutdown() shutdown} method). It then waits for the threads executing any\n+     * unfinished tasks to finish. If interrupted then this method will continue to\n+     * wait for the threads to finish before completing with the interrupt status set.\n+     *\n+     * <p> This method may only be invoked by the task scope owner.\n+     *\n+     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n+     * manner<\/em>. If this method is called to close a task scope before nested task\n+     * scopes are closed then it closes the underlying construct of each nested task scope\n+     * (in the reverse order that they were created in), closes this task scope, and then\n+     * throws {@link StructureViolationException}.\n+     * If a thread terminates without first closing task scopes that it owns then\n+     * termination will cause the underlying construct of each of its open tasks scopes to\n+     * be closed. Closing is performed in the reverse order that the task scopes were\n+     * created in. Thread termination may therefore be delayed when the owner has to wait\n+     * for threads forked in these task scopes to finish.\n+     *\n+     * @throws IllegalStateException thrown after closing the task scope if the owner\n+     * did not invoke join after forking\n+     * @throws WrongThreadException if the current thread is not the owner\n+     * @throws StructureViolationException if a structure violation was detected\n+     *\/\n+    @Override\n+    public void close() {\n+        ensureOwner();\n+        if (state == CLOSED)\n+            return;\n+\n+        try {\n+            implShutdown();\n+            flock.close();\n+        } finally {\n+            state = CLOSED;\n+        }\n+\n+        if (needJoin) {\n+            throw new IllegalStateException(\"Owner did not invoke join or joinUntil after fork\");\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        String name = flock.name();\n+        if (name != null) {\n+            sb.append(name);\n+            sb.append('\/');\n+        }\n+        String id = getClass().getName() + \"@\" + System.identityHashCode(this);\n+        sb.append(id);\n+        int s = state;\n+        if (s == CLOSED)\n+            sb.append(\"\/closed\");\n+        else if (s == SHUTDOWN)\n+            sb.append(\"\/shutdown\");\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * The Future implementation returned by the fork methods. Most methods are\n+     * overridden to support cancellation when the task scope is shutdown.\n+     * The blocking get methods register the Future with the task scope so that they\n+     * are cancelled when the task scope shuts down.\n+     *\/\n+    private static final class FutureImpl<V> extends FutureTask<V> {\n+        private final StructuredTaskScope<V> scope;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        FutureImpl(StructuredTaskScope<? super V> scope, Callable<? extends V> task) {\n+            super((Callable<V>) task);\n+            this.scope = (StructuredTaskScope<V>) scope;\n+        }\n+\n+        @Override\n+        protected void done() {\n+            if (!scope.isShutdown()) {\n+                scope.handleComplete(this);\n+            }\n+        }\n+\n+        private void cancelIfShutdown() {\n+            if (scope.isShutdown() && !super.isDone()) {\n+                super.cancel(false);\n+            }\n+        }\n+\n+        @Override\n+        public boolean isDone() {\n+            cancelIfShutdown();\n+            return super.isDone();\n+        }\n+\n+        @Override\n+        public boolean isCancelled() {\n+            cancelIfShutdown();\n+            return super.isCancelled();\n+        }\n+\n+        @Override\n+        public boolean cancel(boolean mayInterruptIfRunning) {\n+            scope.ensureOwnerOrContainsThread();\n+            cancelIfShutdown();\n+            return super.cancel(mayInterruptIfRunning);\n+        }\n+\n+        @Override\n+        public V get() throws InterruptedException, ExecutionException {\n+            if (super.isDone())\n+                return super.get();\n+            scope.track(this);\n+            try {\n+                cancelIfShutdown();\n+                return super.get();\n+            } finally {\n+                scope.untrack(this);\n+            }\n+        }\n+\n+        @Override\n+        public V get(long timeout, TimeUnit unit)\n+                throws InterruptedException, ExecutionException, TimeoutException {\n+            Objects.requireNonNull(unit);\n+            if (super.isDone())\n+                return super.get();\n+            scope.track(this);\n+            try {\n+                cancelIfShutdown();\n+                return super.get(timeout, unit);\n+            } finally {\n+                scope.untrack(this);\n+            }\n+        }\n+\n+        @Override\n+        public V resultNow() {\n+            cancelIfShutdown();\n+            return super.resultNow();\n+        }\n+\n+        @Override\n+        public Throwable exceptionNow() {\n+            cancelIfShutdown();\n+            return super.exceptionNow();\n+        }\n+\n+        @Override\n+        public State state() {\n+            cancelIfShutdown();\n+            return super.state();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            cancelIfShutdown();\n+            return super.toString();\n+        }\n+    }\n+\n+    \/**\n+     * Maps a Future.State to an int that can be compared.\n+     * RUNNING < CANCELLED < FAILED < SUCCESS.\n+     *\/\n+    private static int futureStateToInt(Future.State s) {\n+        return switch (s) {\n+            case RUNNING   -> 0;\n+            case CANCELLED -> 1;\n+            case FAILED    -> 2;\n+            case SUCCESS   -> 3;\n+        };\n+    }\n+\n+    \/\/ RUNNING < CANCELLED < FAILED < SUCCESS\n+    private static final Comparator<Future.State> FUTURE_STATE_COMPARATOR =\n+            Comparator.comparingInt(StructuredTaskScope::futureStateToInt);\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n+     * complete successfully. Once captured, it invokes the {@linkplain #shutdown() shutdown}\n+     * method to interrupt unfinished threads and wakeup the owner. The policy\n+     * implemented by this class is intended for cases where the result of any subtask\n+     * will do (\"invoke any\") and where the results of other unfinished subtask are no\n+     * longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @param <T> the result type\n+     * @since 19\n+     *\/\n+    public static final class ShutdownOnSuccess<T> extends StructuredTaskScope<T> {\n+        private static final VarHandle FUTURE;\n+        static {\n+            try {\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                FUTURE = l.findVarHandle(ShutdownOnSuccess.class, \"future\", Future.class);\n+            } catch (Exception e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+        private volatile Future<T> future;\n+\n+        \/**\n+         * Constructs a new {@code ShutdownOnSuccess} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when tasks are {@linkplain #fork(Callable) forked}. The task scope is\n+         * owned by the current thread.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public ShutdownOnSuccess(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code ShutdownOnSuccess} that creates virtual threads.\n+         *\n+         * <p> This method is equivalent to invoking the 2-arg constructor with a name of\n+         * {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public ShutdownOnSuccess() {\n+            super(null, FactoryHolder.VIRTUAL_THREAD_FACTORY);\n+        }\n+\n+        \/**\n+         * Shut down the given task scope when invoked for the first time with a {@code\n+         * Future} for a task that completed with a result.\n+         *\n+         * @param future the completed task\n+         * @see #shutdown()\n+         * @see Future.State#SUCCESS\n+         *\/\n+        @Override\n+        protected void handleComplete(Future<T> future) {\n+            Future.State state = future.state();\n+            if (state == Future.State.RUNNING) {\n+                throw new IllegalArgumentException(\"Task is not completed\");\n+            }\n+\n+            Future<T> f;\n+            while (((f = this.future) == null)\n+                    || FUTURE_STATE_COMPARATOR.compare(f.state(), state) < 0) {\n+                if (FUTURE.compareAndSet(this, f, future)) {\n+                    if (state == Future.State.SUCCESS)\n+                        shutdown();\n+                    break;\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnSuccess<T> join() throws InterruptedException {\n+            super.join();\n+            return this;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnSuccess<T> joinUntil(Instant deadline)\n+            throws InterruptedException, TimeoutException\n+        {\n+            super.joinUntil(deadline);\n+            return this;\n+        }\n+\n+        \/**\n+         * {@return the result of the first subtask that completed with a result}\n+         *\n+         * <p> When no subtask completed with a result but a task completed with an\n+         * exception then {@code ExecutionException} is thrown with the exception as the\n+         * {@linkplain Throwable#getCause() cause}. If only cancelled subtasks were\n+         * notified to the {@code handleComplete} method then {@code CancellationException}\n+         * is thrown.\n+         *\n+         * <p> This method is intended to be invoked by the task scope owner after it has\n+         * invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n+         * The behavior of this method is unspecified when invoking this method before\n+         * joining.\n+         *\n+         * @throws ExecutionException if no subtasks completed with a result but a subtask\n+         * completed with an exception\n+         * @throws CancellationException if all subtasks were cancelled\n+         * @throws IllegalStateException if the handle method was not invoked with a\n+         * completed subtask\n+         *\/\n+        public T result() throws ExecutionException {\n+            Future<T> f = future;\n+            if (f == null) {\n+                throw new IllegalStateException(\"No completed subtasks\");\n+            }\n+            return switch (f.state()) {\n+                case SUCCESS   -> f.resultNow();\n+                case FAILED    -> throw new ExecutionException(f.exceptionNow());\n+                case CANCELLED -> throw new CancellationException();\n+                default        -> throw new InternalError(\"Unexpected state: \" + f);\n+            };\n+\n+        }\n+\n+        \/**\n+         * Returns the result of the first subtask that completed with a result, otherwise\n+         * throws an exception produced by the given exception supplying function.\n+         *\n+         * <p> When no subtask completed with a result but a subtask completed with an\n+         * exception then the exception supplying function is invoked with the exception.\n+         * If only cancelled subtasks were notified to the {@code handleComplete} method\n+         * then the exception supplying function is invoked with a {@code CancellationException}.\n+         *\n+         * <p> This method is intended to be invoked by the task scope owner after it has\n+         * invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n+         * The behavior of this method is unspecified when invoking this method before\n+         * joining.\n+         *\n+         * @param esf the exception supplying function\n+         * @param <X> type of the exception to be thrown\n+         * @return the result of the first subtask that completed with a result\n+         * @throws X if no subtask completed with a result\n+         * @throws IllegalStateException if the handle method was not invoked with a\n+         * completed subtask\n+         *\/\n+        public <X extends Throwable> T result(Function<Throwable, ? extends X> esf) throws X {\n+            Objects.requireNonNull(esf);\n+            Future<T> f = future;\n+            if (f == null) {\n+                throw new IllegalStateException(\"No completed subtasks\");\n+            }\n+            Future.State state = f.state();\n+            if (state == Future.State.SUCCESS) {\n+                return f.resultNow();\n+            } else {\n+                Throwable throwable = (state == Future.State.FAILED)\n+                        ? f.exceptionNow()\n+                        : new CancellationException();\n+                X ex = esf.apply(throwable);\n+                Objects.requireNonNull(ex, \"esf returned null\");\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the exception of the first subtask to\n+     * complete abnormally. Once captured, it invokes the {@linkplain #shutdown() shutdown}\n+     * method to interrupt unfinished threads and wakeup the owner. The policy implemented\n+     * by this class is intended for cases where the results for all subtasks are required\n+     * (\"invoke all\"); if any subtask fails then the results of other unfinished subtasks\n+     * are no longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @since 19\n+     *\/\n+    public static final class ShutdownOnFailure extends StructuredTaskScope<Object> {\n+        private static final VarHandle FUTURE;\n+        static {\n+            try {\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                FUTURE = l.findVarHandle(ShutdownOnFailure.class, \"future\", Future.class);\n+            } catch (Exception e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+        private volatile Future<Object> future;\n+\n+        \/**\n+         * Constructs a new {@code ShutdownOnFailure} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when tasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public ShutdownOnFailure(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code ShutdownOnFailure} that creates virtual threads.\n+         *\n+         * <p> This method is equivalent to invoking the 2-arg constructor with a name of\n+         * {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public ShutdownOnFailure() {\n+            super(null, FactoryHolder.VIRTUAL_THREAD_FACTORY);\n+        }\n+\n+        \/**\n+         * Shut down the given task scope when invoked for the first time with a {@code\n+         * Future} for a task that completed abnormally (exception or cancelled).\n+         *\n+         * @param future the completed task\n+         * @see #shutdown()\n+         * @see Future.State#FAILED\n+         * @see Future.State#CANCELLED\n+         *\/\n+        @Override\n+        protected void handleComplete(Future<Object> future) {\n+            Future.State state = future.state();\n+            if (state == Future.State.RUNNING) {\n+                throw new IllegalArgumentException(\"Task is not completed\");\n+            } else if (state == Future.State.SUCCESS) {\n+                return;\n+            }\n+\n+            \/\/ A failed task overrides a cancelled task.\n+            \/\/ The first failed or cancelled task causes the scope to shutdown.\n+            Future<Object> f;\n+            while (((f = this.future) == null)\n+                    || FUTURE_STATE_COMPARATOR.compare(f.state(), state) < 0) {\n+                if (FUTURE.compareAndSet(this, f, future)) {\n+                    shutdown();\n+                    break;\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnFailure join() throws InterruptedException {\n+            super.join();\n+            return this;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnFailure joinUntil(Instant deadline)\n+            throws InterruptedException, TimeoutException\n+        {\n+            super.joinUntil(deadline);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns the exception for the first subtask that completed with an exception.\n+         * If no subtask completed with an exception but cancelled subtasks were notified\n+         * to the {@code handleComplete} method then a {@code CancellationException}\n+         * is returned. If no subtasks completed abnormally then an empty {@code Optional}\n+         * is returned.\n+         *\n+         * <p> This method is intended to be invoked by the task scope owner after it has\n+         * invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n+         * The behavior of this method is unspecified when invoking this method before\n+         * joining.\n+         *\n+         * @return the exception for a subtask that completed abnormally or an empty\n+         * optional if no subtasks completed abnormally\n+         *\/\n+        public Optional<Throwable> exception() {\n+            Future<Object> f = future;\n+            if (f != null) {\n+                Throwable throwable = (f.state() == Future.State.FAILED)\n+                        ? f.exceptionNow()\n+                        : new CancellationException();\n+                return Optional.of(throwable);\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        \/**\n+         * Throws if a subtask completed abnormally. If any subtask completed with an\n+         * exception then {@code ExecutionException} is thrown with the exception of the\n+         * first subtask to fail as the {@linkplain Throwable#getCause() cause}. If no\n+         * subtask completed with an exception but cancelled subtasks were notified to the\n+         * {@code handleComplete} method then {@code CancellationException} is thrown.\n+         * This method does nothing if no subtasks completed abnormally.\n+         *\n+         * <p> This method is intended to be invoked by the task scope owner after it has\n+         * invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n+         * The behavior of this method is unspecified when invoking this method before\n+         * joining.\n+         *\n+         * @throws ExecutionException if a subtask completed with an exception\n+         * @throws CancellationException if no subtasks completed with an exception but\n+         * subtasks were cancelled\n+         *\/\n+        public void throwIfFailed() throws ExecutionException {\n+            Future<Object> f = future;\n+            if (f != null) {\n+                if (f.state() == Future.State.FAILED) {\n+                    throw new ExecutionException(f.exceptionNow());\n+                } else {\n+                    throw new CancellationException();\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Throws the exception produced by the given exception supplying function if\n+         * a subtask completed abnormally. If any subtask completed with an exception then\n+         * the function is invoked with the exception of the first subtask to fail.\n+         * If no subtask completed with an exception but cancelled subtasks were notified\n+         * to the {@code handleComplete} method then the function is called with a {@code\n+         * CancellationException}. The exception returned by the function is thrown.\n+         * This method does nothing if no subtasks completed abnormally.\n+         *\n+         * <p> This method is intended to be invoked by the task scope owner after it has\n+         * invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n+         * The behavior of this method is unspecified when invoking this method before\n+         * joining.\n+         *\n+         * @param esf the exception supplying function\n+         * @param <X> type of the exception to be thrown\n+         * @throws X produced by the exception supplying function\n+         *\/\n+        public <X extends Throwable>\n+        void throwIfFailed(Function<Throwable, ? extends X> esf) throws X {\n+            Objects.requireNonNull(esf);\n+            Future<Object> f = future;\n+            if (f != null) {\n+                Throwable throwable = (f.state() == Future.State.FAILED)\n+                        ? f.exceptionNow()\n+                        : new CancellationException();\n+                X ex = esf.apply(throwable);\n+                Objects.requireNonNull(ex, \"esf returned null\");\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Holder class for the virtual thread factory. It uses reflection to allow\n+     * this class be compiled in an incubator module without also enabling preview\n+     * features.\n+     *\/\n+    private static class FactoryHolder {\n+        static final ThreadFactory VIRTUAL_THREAD_FACTORY = virtualThreadFactory();\n+\n+        @SuppressWarnings(\"removal\")\n+        private static ThreadFactory virtualThreadFactory() {\n+            PrivilegedAction<ThreadFactory> pa = () -> {\n+                try {\n+                    Method ofVirtualMethod = Thread.class.getDeclaredMethod(\"ofVirtual\");\n+                    Object virtualThreadBuilder = ofVirtualMethod.invoke(null);\n+                    Class<?> ofVirtualClass = Class.forName(\"java.lang.Thread$Builder$OfVirtual\");\n+                    Method factoryMethod = ofVirtualClass.getMethod(\"factory\");\n+                    return (ThreadFactory) factoryMethod.invoke(virtualThreadBuilder);\n+                } catch (Exception e) {\n+                    throw new InternalError(e);\n+                }\n+            };\n+            return AccessController.doPrivileged(pa);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":1189,"deletions":0,"binary":false,"changes":1189,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Defines non-final APIs for concurrent programming.\n+ * {@Incubating}\n+ *\/\n+package jdk.incubator.concurrent;\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/package-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Defines non-final APIs for concurrent programming.\n+ * {@Incubating}\n+ *\n+ * @moduleGraph\n+ *\/\n+module jdk.incubator.concurrent {\n+    exports jdk.incubator.concurrent;\n+}\n+\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/module-info.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8284199\n+ * @summary Test StructuredTaskScope without --enable-preview\n+ * @modules jdk.incubator.concurrent\n+ * @run testng\/othervm PreviewFeaturesNotEnabled\n+ *\/\n+\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class PreviewFeaturesNotEnabled {\n+    \/**\n+     * One-arg constructor needs --enable-preview.\n+     *\/\n+    @Test\n+    public void testUnsupportedOperationException() {\n+        assertThrows(UnsupportedOperationException.class, StructuredTaskScope::new);\n+    }\n+\n+    \/**\n+     * Two-arg constructor does not need --enable-preview.\n+     *\/\n+    @Test\n+    public void testNoUnsupportedOperationException() {\n+        try (var scope = new StructuredTaskScope<Object>(null, Thread::new)) {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/PreviewFeaturesNotEnabled.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,1248 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8284199\n+ * @summary Basic tests for StructuredTaskScope\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @run testng\/othervm StructuredTaskScopeTest\n+ *\/\n+\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+import jdk.incubator.concurrent.StructuredTaskScope.ShutdownOnSuccess;\n+import jdk.incubator.concurrent.StructuredTaskScope.ShutdownOnFailure;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.time.Duration;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.NoSuchElementException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class StructuredTaskScopeTest {\n+    private ScheduledExecutorService scheduler;\n+\n+    @BeforeClass\n+    public void setUp() throws Exception {\n+        ThreadFactory factory = (task) -> {\n+            Thread thread = new Thread(task);\n+            thread.setDaemon(true);\n+            return thread;\n+        };\n+        scheduler = Executors.newSingleThreadScheduledExecutor(factory);\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        scheduler.shutdown();\n+    }\n+\n+    \/**\n+     * A provider of ThreadFactory objects for tests.\n+     *\/\n+    @DataProvider\n+    public Object[][] factories() {\n+        var defaultThreadFactory = Executors.defaultThreadFactory();\n+        var virtualThreadFactory = Thread.ofVirtual().factory();\n+        return new Object[][] {\n+                { defaultThreadFactory, },\n+                { virtualThreadFactory, },\n+        };\n+    }\n+\n+    \/**\n+     * Test that each fork creates a thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testFork1(ThreadFactory factory) throws Exception {\n+        AtomicInteger count = new AtomicInteger();\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            for (int i = 0; i < 100; i++) {\n+                scope.fork(() -> count.incrementAndGet());\n+            }\n+            scope.join();\n+        }\n+        assertTrue(count.get() == 100);\n+    }\n+\n+    \/**\n+     * Test that fork uses the specified thread factory.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testFork2(ThreadFactory factory) throws Exception {\n+        AtomicInteger count = new AtomicInteger();\n+        ThreadFactory countingFactory = task -> {\n+            count.incrementAndGet();\n+            return factory.newThread(task);\n+        };\n+        try (var scope = new StructuredTaskScope(null, countingFactory)) {\n+            for (int i = 0; i < 100; i++) {\n+                scope.fork(() -> null);\n+            }\n+            scope.join();\n+        }\n+        assertTrue(count.get() == 100);\n+    }\n+\n+    \/**\n+     * Test fork is confined to threads in the scope \"tree\".\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkConfined(ThreadFactory factory) throws Exception {\n+        try (var scope1 = new StructuredTaskScope();\n+             var scope2 = new StructuredTaskScope()) {\n+\n+            \/\/ thread in scope1 cannot fork thread in scope2\n+            Future<Void> future1 = scope1.fork(() -> {\n+                scope2.fork(() -> null).get();\n+                return null;\n+            });\n+            Throwable ex = expectThrows(ExecutionException.class, future1::get);\n+            assertTrue(ex.getCause() instanceof WrongThreadException);\n+\n+            \/\/ thread in scope2 can fork thread in scope1\n+            Future<Void> future2 = scope2.fork(() -> {\n+                scope1.fork(() -> null).get();\n+                return null;\n+            });\n+            future2.get();\n+            assertTrue(future2.resultNow() == null);\n+\n+            \/\/ random thread cannot fork\n+            try (var pool = Executors.newCachedThreadPool(factory)) {\n+                Future<Void> future = pool.submit(() -> {\n+                    scope1.fork(() -> null);\n+                    return null;\n+                });\n+                ex = expectThrows(ExecutionException.class, future::get);\n+                assertTrue(ex.getCause() instanceof WrongThreadException);\n+            }\n+\n+            scope2.join();\n+            scope1.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when scope is shutdown.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkAfterShutdown(ThreadFactory factory) throws Exception {\n+        AtomicInteger count = new AtomicInteger();\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            scope.shutdown();\n+            Future<String> future = scope.fork(() -> {\n+                count.incrementAndGet();\n+                return \"foo\";\n+            });\n+            assertTrue(future.isCancelled());\n+            scope.join();\n+        }\n+        assertTrue(count.get() == 0);   \/\/ check that task did not run.\n+    }\n+\n+    \/**\n+     * Test fork when scope is closed.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkAfterClose(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            scope.join();\n+            scope.close();\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when the thread factory rejects creating a thread.\n+     *\/\n+    @Test\n+    public void testForkReject() throws Exception {\n+        ThreadFactory factory = task -> null;\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            assertThrows(RejectedExecutionException.class, () -> scope.fork(() -> null));\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * A StructuredTaskScope that collects all Future objects notified to the\n+     * handleComplete method.\n+     *\/\n+    private static class CollectAll<T> extends StructuredTaskScope<T> {\n+        private final List<Future<T>> futures = new CopyOnWriteArrayList<>();\n+\n+        CollectAll(ThreadFactory factory) {\n+            super(null, factory);\n+        }\n+\n+        @Override\n+        protected void handleComplete(Future<T> future) {\n+            assertTrue(future.isDone());\n+            futures.add(future);\n+        }\n+\n+        Stream<Future<T>> futures() {\n+            return futures.stream();\n+        }\n+\n+        Set<Future<T>> futuresAsSet() {\n+            return futures.stream().collect(Collectors.toSet());\n+        }\n+    }\n+\n+    \/**\n+     * Test that handleComplete method is invoked for tasks that complete normally\n+     * and abnormally.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testHandleComplete1(ThreadFactory factory) throws Exception {\n+        try (var scope = new CollectAll(factory)) {\n+\n+            \/\/ completes normally\n+            Future<String> future1 = scope.fork(() -> \"foo\");\n+\n+            \/\/ completes with exception\n+            Future<String> future2 = scope.fork(() -> { throw new FooException(); });\n+\n+            \/\/ cancelled\n+            Future<String> future3 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+            future3.cancel(true);\n+\n+            scope.join();\n+\n+            Set<Future<String>> futures = scope.futuresAsSet();\n+            assertEquals(futures, Set.of(future1, future2, future3));\n+        }\n+    }\n+\n+    \/**\n+     * Test that the handeComplete method is not invoked after the scope has been shutdown.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testHandleComplete2(ThreadFactory factory) throws Exception {\n+        try (var scope = new CollectAll(factory)) {\n+\n+            var latch = new CountDownLatch(1);\n+\n+            \/\/ start task that does not respond to interrupt\n+            Future<String> future1 = scope.fork(() -> {\n+                boolean done = false;\n+                while (!done) {\n+                    try {\n+                        latch.await();\n+                        done = true;\n+                    } catch (InterruptedException e) { }\n+                }\n+                return null;\n+            });\n+\n+            \/\/ start a second task to shutdown the scope after 500ms\n+            Future<String> future2 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(500));\n+                scope.shutdown();\n+                return null;\n+            });\n+\n+            scope.join();\n+\n+            \/\/ let task finish\n+            latch.countDown();\n+\n+            \/\/ handleComplete should not have been called\n+            assertTrue(future1.isDone());\n+            assertTrue(scope.futures().count() == 0L);\n+        }\n+    }\n+\n+    \/**\n+     * Test join with no threads.\n+     *\/\n+    @Test\n+    public void testJoinWithNoThreads() throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test join with threads running.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testJoinWithThreads(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(500));\n+                return \"foo\";\n+            });\n+            scope.join();\n+            assertEquals(future.resultNow(), \"foo\");\n+        }\n+    }\n+\n+    \/**\n+     * Test join is owner confined.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testJoinConfined(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            \/\/ attempt to join on thread in scope\n+            Future<Void> future1 = scope.fork(() -> {\n+                scope.join();\n+                return null;\n+            });\n+            Throwable ex = expectThrows(ExecutionException.class, future1::get);\n+            assertTrue(ex.getCause() instanceof WrongThreadException);\n+\n+            \/\/ random thread cannot join\n+            try (var pool = Executors.newCachedThreadPool(factory)) {\n+                Future<Void> future2 = pool.submit(() -> {\n+                    scope.join();\n+                    return null;\n+                });\n+                ex = expectThrows(ExecutionException.class, future2::get);\n+                assertTrue(ex.getCause() instanceof WrongThreadException);\n+            }\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test join with interrupt status set.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInterruptJoin1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofSeconds(3));\n+                return \"foo\";\n+            });\n+\n+            \/\/ join should throw\n+            Thread.currentThread().interrupt();\n+            try {\n+                scope.join();\n+                fail();\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(future.resultNow(), \"foo\");\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt of thread blocked in join.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInterruptJoin2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofSeconds(3));\n+                return \"foo\";\n+            });\n+\n+            \/\/ join should throw\n+            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n+            try {\n+                scope.join();\n+                fail();\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(future.resultNow(), \"foo\");\n+        }\n+    }\n+\n+    \/**\n+     * Test join when scope is already shutdown.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testJoinWithShutdown1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"foo\";\n+            });\n+            scope.shutdown();  \/\/ interrupts task\n+            scope.join();\n+\n+            \/\/ task should have completed abnormally\n+            assertTrue(future.isDone() && future.state() != Future.State.SUCCESS);\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown when owner is blocked in join.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testJoinWithShutdown2(ThreadFactory factory) throws Exception {\n+        class MyScope<T> extends StructuredTaskScope<T> {\n+            MyScope(ThreadFactory factory) {\n+                super(null, factory);\n+            }\n+            @Override\n+            protected void handleComplete(Future<T> future) {\n+                shutdown();\n+            }\n+        }\n+\n+        try (var scope = new MyScope(factory)) {\n+            Future<String> future1 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"foo\";\n+            });\n+            Future<String> future2 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(500));\n+                return null;\n+            });\n+            scope.join();\n+\n+            \/\/ task1 should have completed abnormally\n+            assertTrue(future1.isDone() && future1.state() != Future.State.SUCCESS);\n+\n+            \/\/ task2 should have completed normally\n+            assertTrue(future2.isDone() && future2.state() == Future.State.SUCCESS);\n+        }\n+    }\n+\n+    \/**\n+     * Test join after scope is shutdown.\n+     *\/\n+    @Test\n+    public void testJoinAfterShutdown() throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            scope.shutdown();\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test join after scope is closed.\n+     *\/\n+    @Test\n+    public void testJoinAfterClose() throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            scope.join();\n+            scope.close();\n+            assertThrows(IllegalStateException.class, () -> scope.join());\n+            assertThrows(IllegalStateException.class, () -> scope.joinUntil(Instant.now()));\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil, threads finish before deadline expires.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testJoinUntil1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofSeconds(2));\n+                } catch (InterruptedException e) { }\n+                return null;\n+            });\n+\n+            long startMillis = millisTime();\n+            scope.joinUntil(Instant.now().plusSeconds(30));\n+            assertTrue(future.isDone() && future.resultNow() == null);\n+            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil, deadline expires before threads finish.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testJoinUntil2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofSeconds(30));\n+                } catch (InterruptedException e) { }\n+                return null;\n+            });\n+\n+            long startMillis = millisTime();\n+            try {\n+                scope.joinUntil(Instant.now().plusSeconds(2));\n+            } catch (TimeoutException e) {\n+                expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+            }\n+            assertFalse(future.isDone());\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil many times.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testJoinUntil3(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofSeconds(30));\n+                } catch (InterruptedException e) { }\n+                return null;\n+            });\n+\n+            try {\n+                for (int i = 0; i < 3; i++) {\n+                    try {\n+                        scope.joinUntil(Instant.now().plusSeconds(1));\n+                        fail();\n+                    } catch (TimeoutException expected) {\n+                        assertFalse(future.isDone());\n+                    }\n+                }\n+            } finally {\n+                future.cancel(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil with a deadline that has already expired.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testJoinUntil4(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofSeconds(30));\n+                } catch (InterruptedException e) { }\n+                return null;\n+            });\n+\n+            try {\n+\n+                \/\/ now\n+                try {\n+                    scope.joinUntil(Instant.now());\n+                    fail();\n+                } catch (TimeoutException expected) {\n+                    assertFalse(future.isDone());\n+                }\n+\n+                \/\/ in the past\n+                try {\n+                    scope.joinUntil(Instant.now().minusSeconds(1));\n+                    fail();\n+                } catch (TimeoutException expected) {\n+                    assertFalse(future.isDone());\n+                }\n+\n+            } finally {\n+                future.cancel(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil with interrupt status set.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInterruptJoinUntil1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofSeconds(3));\n+                return \"foo\";\n+            });\n+\n+            \/\/ join should throw\n+            Thread.currentThread().interrupt();\n+            try {\n+                scope.joinUntil(Instant.now().plusSeconds(10));\n+                fail();\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(future.resultNow(), \"foo\");\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt of thread blocked in joinUntil\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInterruptJoinUntil2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofSeconds(3));\n+                return \"foo\";\n+            });\n+\n+            \/\/ join should throw\n+            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n+            try {\n+                scope.joinUntil(Instant.now().plusSeconds(10));\n+                fail();\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(future.resultNow(), \"foo\");\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown after scope is closed.\n+     *\/\n+    public void testShutdownAfterClose() throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            scope.join();\n+            scope.close();\n+            assertThrows(IllegalStateException.class, () -> scope.shutdown());\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown is confined to threads in the scope \"tree\".\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testShutdownConfined(ThreadFactory factory) throws Exception {\n+        try (var scope1 = new StructuredTaskScope();\n+             var scope2 = new StructuredTaskScope()) {\n+\n+            \/\/ random thread cannot shutdown\n+            try (var pool = Executors.newCachedThreadPool(factory)) {\n+                Future<Void> future = pool.submit(() -> {\n+                    scope1.shutdown();\n+                    return null;\n+                });\n+                Throwable ex = expectThrows(ExecutionException.class, future::get);\n+                assertTrue(ex.getCause() instanceof WrongThreadException);\n+            }\n+\n+            \/\/ thread in scope1 cannot shutdown scope2\n+            Future<Void> future1 = scope1.fork(() -> {\n+                scope2.shutdown();\n+                return null;\n+            });\n+            Throwable ex = expectThrows(ExecutionException.class, future1::get);\n+            assertTrue(ex.getCause() instanceof WrongThreadException);\n+\n+            \/\/ thread in scope2 can shutdown scope1\n+            Future<Void> future2 = scope2.fork(() -> {\n+                scope1.shutdown();\n+                return null;\n+            });\n+            future2.get();\n+            assertTrue(future2.resultNow() == null);\n+\n+            scope2.join();\n+            scope1.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test close without join, no threads forked.\n+     *\/\n+    public void testCloseWithoutJoin1() {\n+        try (var scope = new StructuredTaskScope()) {\n+            \/\/ do nothing\n+        }\n+    }\n+\n+    \/**\n+     * Test close without join, threads forked.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCloseWithoutJoin2(ThreadFactory factory) {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+            assertThrows(IllegalStateException.class, scope::close);\n+            assertTrue(future.isDone() && future.exceptionNow() != null);\n+        }\n+    }\n+\n+    \/**\n+     * Test close with threads forked after join.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCloseWithoutJoin3(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.join();\n+\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+            assertThrows(IllegalStateException.class, scope::close);\n+            assertTrue(future.isDone() && future.exceptionNow() != null);\n+        }\n+    }\n+\n+    \/**\n+     * Test close is owner confined.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCloseConfined(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            \/\/ attempt to close on thread in scope\n+            Future<Void> future1 = scope.fork(() -> {\n+                scope.close();\n+                return null;\n+            });\n+            Throwable ex = expectThrows(ExecutionException.class, future1::get);\n+            assertTrue(ex.getCause() instanceof WrongThreadException);\n+\n+            \/\/ random thread cannot close scope\n+            try (var pool = Executors.newCachedThreadPool(factory)) {\n+                Future<Void> future2 = pool.submit(() -> {\n+                    scope.close();\n+                    return null;\n+                });\n+                ex = expectThrows(ExecutionException.class, future2::get);\n+                assertTrue(ex.getCause() instanceof WrongThreadException);\n+            }\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test close with interrupt status set.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInterruptClose1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+\n+            \/\/ start task that does not respond to interrupt\n+            scope.fork(() -> {\n+                boolean done = false;\n+                while (!done) {\n+                    try {\n+                        latch.await();\n+                        done = true;\n+                    } catch (InterruptedException e) { }\n+                }\n+                return null;\n+            });\n+\n+            scope.shutdown();\n+            scope.join();\n+\n+            \/\/ release task after a delay\n+            scheduler.schedule(latch::countDown, 1, TimeUnit.SECONDS);\n+\n+            \/\/ invoke close with interrupt status set\n+            Thread.currentThread().interrupt();\n+            try {\n+                scope.close();\n+            } finally {\n+                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupting thread waiting in close.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInterruptClose2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+\n+            \/\/ start task that does not respond to interrupt\n+            scope.fork(() -> {\n+                boolean done = false;\n+                while (!done) {\n+                    try {\n+                        latch.await();\n+                        done = true;\n+                    } catch (InterruptedException e) { }\n+                }\n+                return null;\n+            });\n+\n+            scope.shutdown();\n+            scope.join();\n+\n+            \/\/ release task after a delay\n+            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n+            scheduler.schedule(latch::countDown, 3, TimeUnit.SECONDS);\n+            try {\n+                scope.close();\n+            } finally {\n+                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that closing an enclosing scope closes the thread flock of a\n+     * nested scope.\n+     *\/\n+    @Test\n+    public void testStructureViolation1() throws Exception {\n+        try (var scope1 = new StructuredTaskScope()) {\n+            try (var scope2 = new StructuredTaskScope()) {\n+\n+                \/\/ join + close enclosing scope\n+                scope1.join();\n+                try {\n+                    scope1.close();\n+                    fail();\n+                } catch (StructureViolationException expected) { }\n+\n+                \/\/ underlying flock should be closed, fork should return a cancelled task\n+                AtomicBoolean ran = new AtomicBoolean();\n+                Future<String> future = scope2.fork(() -> {\n+                    ran.set(true);\n+                    return null;\n+                });\n+                assertTrue(future.isCancelled());\n+                scope2.join();\n+                assertFalse(ran.get());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test Future::get, task completes normally.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testFuture1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(100));\n+                return \"foo\";\n+            });\n+\n+            assertEquals(future.get(), \"foo\");\n+            assertTrue(future.state() == Future.State.SUCCESS);\n+            assertEquals(future.resultNow(), \"foo\");\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Future::get, task completes with exception.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testFuture2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(100));\n+                throw new FooException();\n+            });\n+\n+            Throwable ex = expectThrows(ExecutionException.class, future::get);\n+            assertTrue(ex.getCause() instanceof FooException);\n+            assertTrue(future.state() == Future.State.FAILED);\n+            assertTrue(future.exceptionNow() instanceof FooException);\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Future::get, task is cancelled.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testFuture3(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            \/\/ timed-get, should timeout\n+            try {\n+                future.get(100, TimeUnit.MICROSECONDS);\n+                fail();\n+            } catch (TimeoutException expected) { }\n+\n+            future.cancel(true);\n+            assertThrows(CancellationException.class, future::get);\n+            assertTrue(future.state() == Future.State.CANCELLED);\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test scope shutdown with a thread blocked in Future::get.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testFutureWithShutdown(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+\n+            \/\/ long running task\n+            Future<String> future = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            \/\/ start a thread to wait in Future::get\n+            AtomicBoolean waitDone = new AtomicBoolean();\n+            Thread waiter = Thread.startVirtualThread(() -> {\n+                try {\n+                    future.get();\n+                } catch (ExecutionException | CancellationException e) {\n+                    waitDone.set(true);\n+                } catch (InterruptedException e) {\n+                    System.out.println(\"waiter thread interrupted!\");\n+                }\n+            });\n+\n+            \/\/ shutdown scope\n+            scope.shutdown();\n+\n+            \/\/ Future should be done and thread should be awakened\n+            assertTrue(future.isDone());\n+            waiter.join();\n+            assertTrue(waitDone.get());\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Future::cancel throws if invoked by a thread that is not in the tree.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testFutureCancelConfined(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            Future<String> future1 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"foo\";\n+            });\n+\n+            \/\/ random thread cannot cancel\n+            try (var pool = Executors.newCachedThreadPool(factory)) {\n+                Future<Void> future2 = pool.submit(() -> {\n+                    future1.cancel(true);\n+                    return null;\n+                });\n+                Throwable ex = expectThrows(ExecutionException.class, future2::get);\n+                assertTrue(ex.getCause() instanceof WrongThreadException);\n+            } finally {\n+                future1.cancel(true);\n+            }\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test StructuredTaskScope::toString includes the scope name.\n+     *\/\n+    @Test\n+    public void testToString() throws Exception {\n+        ThreadFactory factory = Thread.ofVirtual().factory();\n+        try (var scope = new StructuredTaskScope(\"xxx\", factory)) {\n+            \/\/ open\n+            assertTrue(scope.toString().contains(\"xxx\"));\n+\n+            \/\/ shutdown\n+            scope.shutdown();\n+            assertTrue(scope.toString().contains(\"xxx\"));\n+\n+            \/\/ closed\n+            scope.join();\n+            scope.close();\n+            assertTrue(scope.toString().contains(\"xxx\"));\n+        }\n+    }\n+\n+    \/**\n+     * Test for NullPointerException.\n+     *\/\n+    @Test\n+    public void testNulls() throws Exception {\n+        assertThrows(NullPointerException.class, () -> new StructuredTaskScope(\"\", null));\n+        try (var scope = new StructuredTaskScope()) {\n+            assertThrows(NullPointerException.class, () -> scope.fork(null));\n+            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+        }\n+\n+        assertThrows(NullPointerException.class, () -> new ShutdownOnSuccess(\"\", null));\n+        try (var scope = new ShutdownOnSuccess<Object>()) {\n+            assertThrows(NullPointerException.class, () -> scope.fork(null));\n+            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+            assertThrows(NullPointerException.class, () -> scope.result(null));\n+        }\n+\n+        assertThrows(NullPointerException.class, () -> new ShutdownOnFailure(\"\", null));\n+        try (var scope = new ShutdownOnFailure()) {\n+            assertThrows(NullPointerException.class, () -> scope.fork(null));\n+            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+            assertThrows(NullPointerException.class, () -> scope.throwIfFailed(null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with no completed tasks.\n+     *\/\n+    @Test\n+    public void testShutdownOnSuccess1() throws Exception {\n+        try (var scope = new ShutdownOnSuccess<String>()) {\n+            assertThrows(IllegalStateException.class, () -> scope.result());\n+            assertThrows(IllegalStateException.class, () -> scope.result(e -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with tasks that completed normally.\n+     *\/\n+    @Test\n+    public void testShutdownOnSuccess2() throws Exception {\n+        try (var scope = new ShutdownOnSuccess<String>()) {\n+\n+            \/\/ two tasks complete normally\n+            scope.fork(() -> \"foo\");\n+            scope.join();  \/\/ ensures foo completes first\n+            scope.fork(() -> \"bar\");\n+            scope.join();\n+\n+            assertEquals(scope.result(), \"foo\");\n+            assertEquals(scope.result(e -> null), \"foo\");\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with tasks that completed normally and abnormally.\n+     *\/\n+    @Test\n+    public void testShutdownOnSuccess3() throws Exception {\n+        try (var scope = new ShutdownOnSuccess<String>()) {\n+\n+            \/\/ one task completes normally, the other with an exception\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new ArithmeticException(); });\n+            scope.join();\n+\n+            assertEquals(scope.result(), \"foo\");\n+            assertEquals(scope.result(e -> null), \"foo\");\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with a task that completed with an exception.\n+     *\/\n+    @Test\n+    public void testShutdownOnSuccess4() throws Exception {\n+        try (var scope = new ShutdownOnSuccess<String>()) {\n+\n+            \/\/ tasks completes with exception\n+            scope.fork(() -> { throw new ArithmeticException(); });\n+            scope.join();\n+\n+            Throwable ex = expectThrows(ExecutionException.class, () -> scope.result());\n+            assertTrue(ex.getCause() instanceof  ArithmeticException);\n+\n+            ex = expectThrows(FooException.class, () -> scope.result(e -> new FooException(e)));\n+            assertTrue(ex.getCause() instanceof  ArithmeticException);\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with a cancelled task.\n+     *\/\n+    @Test\n+    public void testShutdownOnSuccess5() throws Exception {\n+        try (var scope = new ShutdownOnSuccess<String>()) {\n+\n+            \/\/ cancelled task\n+            var future = scope.fork(() -> {\n+                Thread.sleep(60_000);\n+                return null;\n+            });\n+            future.cancel(false);\n+\n+            scope.join();\n+\n+            assertThrows(CancellationException.class, () -> scope.result());\n+            Throwable ex = expectThrows(FooException.class,\n+                                        () -> scope.result(e -> new FooException(e)));\n+            assertTrue(ex.getCause() instanceof CancellationException);\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with no completed tasks.\n+     *\/\n+    @Test\n+    public void testShutdownOnFailure1() throws Throwable {\n+        try (var scope = new ShutdownOnFailure()) {\n+            assertTrue(scope.exception().isEmpty());\n+            scope.throwIfFailed();\n+            scope.throwIfFailed(e -> new FooException(e));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with tasks that completed normally.\n+     *\/\n+    @Test\n+    public void testShutdownOnFailure2() throws Throwable {\n+        try (var scope = new ShutdownOnFailure()) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> \"bar\");\n+            scope.join();\n+\n+            \/\/ no exception\n+            assertTrue(scope.exception().isEmpty());\n+            scope.throwIfFailed();\n+            scope.throwIfFailed(e -> new FooException(e));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with tasks that completed normally and abnormally.\n+     *\/\n+    @Test\n+    public void testShutdownOnFailure3() throws Throwable {\n+        try (var scope = new ShutdownOnFailure()) {\n+\n+            \/\/ one task completes normally, the other with an exception\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new ArithmeticException(); });\n+            scope.join();\n+\n+            Throwable ex = scope.exception().orElse(null);\n+            assertTrue(ex instanceof ArithmeticException);\n+\n+            ex = expectThrows(ExecutionException.class, () -> scope.throwIfFailed());\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+\n+            ex = expectThrows(FooException.class,\n+                              () -> scope.throwIfFailed(e -> new FooException(e)));\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with a cancelled task.\n+     *\/\n+    @Test\n+    public void testShutdownOnFailure4() throws Throwable {\n+        try (var scope = new ShutdownOnFailure()) {\n+\n+            var future = scope.fork(() -> {\n+                Thread.sleep(60_000);\n+                return null;\n+            });\n+            future.cancel(false);\n+\n+            scope.join();\n+\n+            Throwable ex = scope.exception().orElse(null);\n+            assertTrue(ex instanceof CancellationException);\n+\n+            assertThrows(CancellationException.class, () -> scope.throwIfFailed());\n+\n+            ex = expectThrows(FooException.class,\n+                              () -> scope.throwIfFailed(e -> new FooException(e)));\n+            assertTrue(ex.getCause() instanceof CancellationException);\n+        }\n+    }\n+\n+    \/**\n+     * A runtime exception for tests.\n+     *\/\n+    private static class FooException extends RuntimeException {\n+        FooException() { }\n+        FooException(Throwable cause) { super(cause); }\n+    }\n+\n+    \/**\n+     * Schedules a thread to be interrupted after the given delay.\n+     *\/\n+    private void scheduleInterrupt(Thread thread, Duration delay) {\n+        long millis = delay.toMillis();\n+        scheduler.schedule(thread::interrupt, millis, TimeUnit.MILLISECONDS);\n+    }\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private static long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Check the duration of a task\n+     * @param start start time, in milliseconds\n+     * @param min minimum expected duration, in milliseconds\n+     * @param max maximum expected duration, in milliseconds\n+     * @return the duration (now - start), in milliseconds\n+     *\/\n+    private static long expectDuration(long start, long min, long max) {\n+        long duration = millisTime() - start;\n+        assertTrue(duration >= min,\n+                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max,\n+                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n+        return duration;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":1248,"deletions":0,"binary":false,"changes":1248,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8284199\n+ * @summary Test thread dumps with StructuredTaskScope\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @library \/test\/lib\n+ * @run testng\/othervm StructuredThreadDumpTest\n+ *\/\n+\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.Stream;\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import com.sun.management.HotSpotDiagnosticMXBean.ThreadDumpFormat;\n+import jdk.test.lib.threaddump.ThreadDump;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class StructuredThreadDumpTest {\n+\n+    \/**\n+     * Test that a thread dump with a tree of task scopes contains a thread grouping for\n+     * each task scope.\n+     *\/\n+    @Test\n+    public void testTree() throws Exception {\n+        ThreadFactory factory = Thread.ofVirtual().factory();\n+        try (var scope = new StructuredTaskScope<>(\"scope\", factory)) {\n+            Thread thread1 = fork(scope, \"child-scope-A\");\n+            Thread thread2 = fork(scope, \"child-scope-B\");\n+            try {\n+                ThreadDump threadDump = threadDump();\n+\n+                \/\/ thread dump should have a thread container for each scope\n+                var rootContainer = threadDump.rootThreadContainer();\n+                var container1 = threadDump.findThreadContainer(\"scope\").orElseThrow();\n+                var container2 = threadDump.findThreadContainer(\"child-scope-A\").orElseThrow();\n+                var container3 = threadDump.findThreadContainer(\"child-scope-B\").orElseThrow();\n+\n+                \/\/ check parents\n+                assertFalse(rootContainer.parent().isPresent());\n+                assertTrue(container1.parent().get() == rootContainer);\n+                assertTrue(container2.parent().get() == container1);\n+                assertTrue(container3.parent().get() == container1);\n+\n+                \/\/ check owners\n+                assertFalse(rootContainer.owner().isPresent());\n+                assertTrue(container1.owner().getAsLong() == Thread.currentThread().threadId());\n+                assertTrue(container2.owner().getAsLong() == thread1.threadId());\n+                assertTrue(container3.owner().getAsLong() == thread2.threadId());\n+\n+                \/\/ thread1 and threads2 should be in threads array of \"scope\"\n+                container1.findThread(thread1.threadId()).orElseThrow();\n+                container1.findThread(thread2.threadId()).orElseThrow();\n+\n+            } finally {\n+                scope.shutdown();\n+                scope.join();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that a thread dump with nested tasks scopes contains a thread grouping for\n+     * each task scope.\n+     *\/\n+    @Test\n+    public void testNested() throws Exception {\n+        ThreadFactory factory = Thread.ofVirtual().factory();\n+        try (var scope1 = new StructuredTaskScope<>(\"scope-A\", factory)) {\n+            Thread thread1 = fork(scope1);\n+\n+            try (var scope2 = new StructuredTaskScope<>(\"scope-B\", factory)) {\n+                Thread thread2 = fork(scope2);\n+                try {\n+                    ThreadDump threadDump = threadDump();\n+\n+                    \/\/ thread dump should have a thread container for both scopes\n+                    var rootContainer = threadDump.rootThreadContainer();\n+                    var container1 = threadDump.findThreadContainer(\"scope-A\").orElseThrow();\n+                    var container2 = threadDump.findThreadContainer(\"scope-B\").orElseThrow();\n+\n+                    \/\/ check parents\n+                    assertFalse(rootContainer.parent().isPresent());\n+                    assertTrue(container1.parent().get() == rootContainer);\n+                    assertTrue(container2.parent().get() == container1);\n+\n+                    \/\/ check owners\n+                    long tid = Thread.currentThread().threadId();\n+                    assertFalse(rootContainer.owner().isPresent());\n+                    assertTrue(container1.owner().getAsLong() == tid);\n+                    assertTrue(container2.owner().getAsLong() == tid);\n+\n+                    \/\/ thread1 should be in threads array of \"scope-A\"\n+                    container1.findThread(thread1.threadId()).orElseThrow();\n+\n+                    \/\/ thread2 should be in threads array of \"scope-B\"\n+                    container2.findThread(thread2.threadId()).orElseThrow();\n+\n+                } finally {\n+                    scope2.shutdown();\n+                    scope2.join();\n+                }\n+            } finally {\n+                scope1.shutdown();\n+                scope1.join();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Generates a JSON formatted thread dump to a temporary file, prints it to standard\n+     * output, parses the JSON text and returns a ThreadDump object for the thread dump.\n+     *\/\n+    private static ThreadDump threadDump() throws IOException {\n+        Path dir = Path.of(\".\").toAbsolutePath();\n+        Path file = Files.createTempFile(dir, \"threadump\", \"json\");\n+        Files.delete(file);\n+        ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n+                .dumpThreads(file.toString(), ThreadDumpFormat.JSON);\n+\n+        try (Stream<String> stream = Files.lines(file)) {\n+            stream.forEach(System.out::println);\n+        }\n+\n+        String jsonText = Files.readString(file);\n+        return ThreadDump.parse(jsonText);\n+    }\n+\n+    \/**\n+     * Forks a subtask in the given scope that parks, returning the Thread that executes\n+     * the subtask.\n+     *\/\n+    private static Thread fork(StructuredTaskScope<Object> scope) throws Exception {\n+        var ref = new AtomicReference<Thread>();\n+        scope.fork(() -> {\n+            ref.set(Thread.currentThread());\n+            LockSupport.park();\n+            return null;\n+        });\n+        Thread thread;\n+        while ((thread = ref.get()) == null) {\n+            Thread.sleep(10);\n+        }\n+        return thread;\n+    }\n+\n+    \/**\n+     * Forks a subtask in the given scope. The subtask creates a new child scope with\n+     * the given name, then parks. This method returns Thread that executes the subtask.\n+     *\/\n+    private static Thread fork(StructuredTaskScope<Object> scope,\n+                               String childScopeName) throws Exception {\n+        var ref = new AtomicReference<Thread>();\n+        scope.fork(() -> {\n+            ThreadFactory factory = Thread.ofVirtual().factory();\n+            try (var childScope = new StructuredTaskScope<Object>(childScopeName, factory)) {\n+                ref.set(Thread.currentThread());\n+                LockSupport.park();\n+            }\n+            return null;\n+        });\n+        Thread thread;\n+        while ((thread = ref.get()) == null) {\n+            Thread.sleep(10);\n+        }\n+        return thread;\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredThreadDumpTest.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"}]}