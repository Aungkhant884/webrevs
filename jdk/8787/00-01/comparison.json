{"files":[{"patch":"@@ -40,1 +40,1 @@\n-     * Constructs an {@code StructureViolationException} with no detail message.\n+     * Constructs a {@code StructureViolationException} with no detail message.\n@@ -47,1 +47,1 @@\n-     * Constructs an {@code StructureViolationException} with the specified\n+     * Constructs a {@code StructureViolationException} with the specified\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructureViolationException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,6 +54,6 @@\n- * A basic API for <em>structured concurrency<\/em>. StructuredTaskScope supports cases\n- * where a task splits into several concurrent sub-tasks, to be executed in their own\n- * threads, and where the sub-tasks must complete before the main task continues. A\n- * StructuredTaskScope can be used to ensure that the lifetime of a concurrent operation\n- * is confined by a <em>syntax block<\/em>, just like that of a sequential operation in\n- * structured programming.\n+ * A basic API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports\n+ * cases where a task splits into several concurrent subtasks, to be executed in their\n+ * own threads, and where the subtasks must complete before the main task continues. A\n+ * {@code StructuredTaskScope} can be used to ensure that the lifetime of a concurrent\n+ * operation is confined by a <em>syntax block<\/em>, just like that of a sequential\n+ * operation in structured programming.\n@@ -63,1 +63,1 @@\n- * A StructuredTaskScope is created with one of its public constructors. It defines\n+ * A {@code StructuredTaskScope} is created with one of its public constructors. It defines\n@@ -68,1 +68,1 @@\n- * the {@code fork} method to fork threads to execute the sub-tasks, wait for the threads\n+ * the {@code fork} method to fork threads to execute the subtasks, wait for the threads\n@@ -84,1 +84,1 @@\n- * by the <em>owner<\/em> (the thread that opened\/created the StructuredTaskScope), and the\n+ * by the <em>owner<\/em> (the thread that opened\/created the task scope}, and the\n@@ -88,6 +88,7 @@\n- * <p> StructuredTaskScope defines the {@link #shutdown() shutdown} method to shut down a\n- * task scope without closing it. Shutdown is useful for cases where a task completes with\n- * a result (or exception) and the results of other unfinished tasks are no longer needed.\n- * Invoking {@code shutdown} while the owner is waiting in the {@code join} method will\n- * cause {@code join} to wakeup. It also interrupts all unfinished threads and prevents\n- * new threads from starting in the task scope.\n+ * <p> {@code StructuredTaskScope} defines the {@link #shutdown() shutdown} method to shut\n+ * down a task scope without closing it. Shutdown is useful for cases where a subtask\n+ * completes with a result (or exception) and the results of other unfinished subtasks are\n+ * no longer needed. If a subtask invokes {@code shutdown} while the owner is waiting in\n+ * the {@code join} method then it will cause {@code join} to wakeup, all unfinished\n+ * threads to be {@linkplain Thread#interrupt() interrupted} and prevents new threads\n+ * from starting in the task scope.\n@@ -97,1 +98,2 @@\n- * Two subclasses of StructuredTaskScope are defined to implement policy for common cases:\n+ * Two subclasses of {@code StructuredTaskScope} are defined to implement policy for\n+ * common cases:\n@@ -101,3 +103,3 @@\n- *   class is intended for cases where the result of any task will do (\"invoke any\") and\n- *   where there is no need to wait for results of other unfinished tasks. It defines\n- *   methods to get the first result or throw an exception if all tasks fail.\n+ *   class is intended for cases where the result of any subtask will do (\"invoke any\")\n+ *   and where there is no need to wait for results of other unfinished tasks. It defines\n+ *   methods to get the first result or throw an exception if all subtasks fail.\n@@ -106,3 +108,3 @@\n- *   tasks are required (\"invoke all\"); if any task fails then the results of other\n- *   unfinished tasks are no longer needed. If defines methods to throw an exception if\n- *   any of the tasks fail.\n+ *   subtasks are required (\"invoke all\"); if any subtask fails then the results of other\n+ *   unfinished subtasks are no longer needed. If defines methods to throw an exception if\n+ *   any of the subtasks fail.\n@@ -112,7 +114,8 @@\n- * tasks are forked to fetch resources from two URL locations \"left\" and \"right\". The first\n- * example creates a ShutdownOnSuccess object to capture the result of the first task to\n- * complete normally, cancelling the other by way of shutting down the task scope. The main\n- * task waits in {@code join} until either task completes with a result or both tasks fail.\n- * It invokes {@link ShutdownOnSuccess#result(Function) result(Function)} method to get the\n- * captured result. If both tasks fail then this method throws WebApplicationException with\n- * the exception from one of the tasks as the cause.\n+ * subtasks are forked to fetch resources from two URL locations \"left\" and \"right\". The\n+ * first example creates a ShutdownOnSuccess object to capture the result of the first\n+ * subtask to complete normally, cancelling the other by way of shutting down the task\n+ * scope. The main task waits in {@code join} until either subtask completes with a result\n+ * or both subtasks fail. It invokes {@link ShutdownOnSuccess#result(Function)\n+ * result(Function)} method to get the captured result. If both subtasks fail then this\n+ * method throws a {@code WebApplicationException} with the exception from one of the\n+ * subtasks as the cause.\n@@ -134,3 +137,3 @@\n- * first task to fail, cancelling the other by way of shutting down the task scope. The\n- * main task waits in {@link #joinUntil(Instant)} until both tasks complete with a result,\n- * either fails, or a deadline is reached. It invokes {@link\n+ * first subtask to fail, cancelling the other by way of shutting down the task scope. The\n+ * main task waits in {@link #joinUntil(Instant)} until both subtasks complete with a\n+ * result, either fails, or a deadline is reached. It invokes {@link\n@@ -138,2 +141,3 @@\n- * when either task fails. This method is a no-op if no tasks fail. The main task uses\n- * {@code Future}'s {@link Future#resultNow() resultNow()} method to retrieve the results.\n+ * when either subtask fails. This method is a no-op if no subtasks fail. The main task\n+ * uses {@code Future}'s {@link Future#resultNow() resultNow()} method to retrieve the\n+ * results.\n@@ -154,1 +158,1 @@\n- *         \/\/ both tasks completed successfully\n+ *         \/\/ both subtasks completed successfully\n@@ -166,6 +170,7 @@\n- * StructuredTaskScope can be extended, and the {@link #handleComplete(Future) handleComplete}\n- * overridden, to implement policies other than those implemented by {@code ShutdownOnSuccess}\n- * and {@code ShutdownOnFailure}. The method may be overridden to, for example, collect\n- * the results of tasks that complete with a result and ignore tasks that fail. It may\n- * collect exceptions when tasks fail. It may invoke the {@link #shutdown() shutdown}\n- * method to shut down and cause {@link #join() join} to wakeup when some condition arises.\n+ * {@code StructuredTaskScope} can be extended, and the {@link #handleComplete(Future)\n+ * handleComplete} overridden, to implement policies other than those implemented by\n+ * {@code ShutdownOnSuccess} and {@code ShutdownOnFailure}. The method may be overridden\n+ * to, for example, collect the results of subtasks that complete with a result and ignore\n+ * subtasks that fail. It may collect exceptions when subtasks fail. It may invoke the\n+ * {@link #shutdown() shutdown} method to shut down and cause {@link #join() join} to\n+ * wakeup when some condition arises.\n@@ -175,3 +180,3 @@\n- * results and ignores tasks that fail may define a method that returns a collection of\n- * results. A subclass that implements a policy to shut down when a task fails may define\n- * a method to retrieve the exception of the first task to fail.\n+ * results and ignores subtasks that fail may define a method that returns a collection of\n+ * results. A subclass that implements a policy to shut down when a subtask fails may\n+ * define a method to retrieve the exception of the first subtask to fail.\n@@ -179,3 +184,3 @@\n- * <p> The following is an example of a StructuredTaskScope implementation that collects the\n- * results of tasks that complete successfully. It defines the method <b>{@code results()}<\/b>\n- * to be used by the main task to retrieve the results.\n+ * <p> The following is an example of a {@code StructuredTaskScope} implementation that\n+ * collects the results of subtasks that complete successfully. It defines the method\n+ * <b>{@code results()}<\/b> to be used by the main task to retrieve the results.\n@@ -200,1 +205,1 @@\n- *         \/\/ Returns a stream of results from tasks that completed successfully.\n+ *         \/\/ Returns a stream of results from the subtasks that completed successfully\n@@ -223,2 +228,2 @@\n- * descendant scopes. StructuredTaskScope does not define APIs that exposes the tree\n- * structure at this time.\n+ * descendant scopes. {@code StructuredTaskScope} does not define APIs that exposes the\n+ * tree structure at this time.\n@@ -231,1 +236,1 @@\n- * <p>Actions in the owner thread of, or a thread contained in, the task scope prior to\n+ * <p> Actions in the owner thread of, or a thread contained in, the task scope prior to\n@@ -238,0 +243,2 @@\n+ * @jls 17.4.5 Happens-before Order\n+ *\n@@ -352,2 +359,2 @@\n-     * <p> The {@code handleComplete} method should be thread safe. It may be\n-     * invoked by several threads at around the same.\n+     * <p> The {@code handleComplete} method should be thread safe. It may be invoked by\n+     * several threads concurrently.\n@@ -357,1 +364,1 @@\n-     * @param future the Future for the completed task\n+     * @param future the completed task\n@@ -376,1 +383,1 @@\n-     * of shutting down) then {@code fork} returns a Future representing a {@link\n+     * of shutting down) then {@code fork} returns a {@code Future} representing a {@link\n@@ -461,1 +468,1 @@\n-     * {@link #handleComplete(Future) handleComplete} method), or the {@link #shutdown()\n+     * {@link #handleComplete(Future) handleComplete} method), the {@link #shutdown()\n@@ -463,1 +470,1 @@\n-     * is interrupted.\n+     * is {@linkplain Thread#interrupt() interrupted}.\n@@ -486,1 +493,2 @@\n-     * the current thread is interrupted, or the deadline is reached.\n+     * the current thread is {@linkplain Thread#interrupt() interrupted}, or the deadline\n+     * is reached.\n@@ -573,1 +581,1 @@\n-     * results of unfinished tasks are no longer needed.\n+     * results of unfinished subtasks are no longer needed.\n@@ -586,3 +594,3 @@\n-     * <p> When this method completes then the Future objects for all tasks will be\n-     * {@linkplain Future#isDone() done}, normally or abnormally. There may still be\n-     * threads that have not finished because they are executing code that did not\n+     * <p> When this method completes then the {@code Future} objects for all tasks will\n+     * be {@linkplain Future#isDone() done}, normally or abnormally. There may still\n+     * be threads that have not finished because they are executing code that did not\n@@ -618,5 +626,5 @@\n-     * <p> A StructuredTaskScope is intended to be used in a <em>structured manner<\/em>.\n-     * If this method is called to close a task scope before nested task scopes are closed\n-     * then it closes the underlying construct of each nested task scope (in the reverse\n-     * order that they were created in), closes this task scope, and then throws {@link\n-     * StructureViolationException}.\n+     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n+     * manner<\/em>. If this method is called to close a task scope before nested task\n+     * scopes are closed then it closes the underlying construct of each nested task scope\n+     * (in the reverse order that they were created in), closes this task scope, and then\n+     * throws {@link StructureViolationException}.\n@@ -783,2 +791,2 @@\n-     * A StructuredTaskScope that captures the result of the first task to complete\n-     * successfully. Once captured, it invokes the {@linkplain #shutdown() shutdown}\n+     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n+     * complete successfully. Once captured, it invokes the {@linkplain #shutdown() shutdown}\n@@ -786,3 +794,3 @@\n-     * implemented by this class is intended for cases where the result of any task will\n-     * do (\"invoke any\") and where the results of other unfinished tasks are no longer\n-     * needed.\n+     * implemented by this class is intended for cases where the result of any subtask\n+     * will do (\"invoke any\") and where the results of other unfinished subtask are no\n+     * longer needed.\n@@ -809,1 +817,1 @@\n-         * Constructs a new ShutdownOnSuccess with the given name and thread factory.\n+         * Constructs a new {@code ShutdownOnSuccess} with the given name and thread factory.\n@@ -823,1 +831,1 @@\n-         * Constructs a new unnamed ShutdownOnSuccess that creates virtual threads.\n+         * Constructs a new unnamed {@code ShutdownOnSuccess} that creates virtual threads.\n@@ -833,2 +841,2 @@\n-         * Shut down the given task scope when invoked for the first time with a task\n-         * that completed with a result.\n+         * Shut down the given task scope when invoked for the first time with a {@code\n+         * Future} for a task that completed with a result.\n@@ -885,1 +893,1 @@\n-         * {@return the result of the first task that completed with a result}\n+         * {@return the result of the first subtask that completed with a result}\n@@ -887,4 +895,5 @@\n-         * <p> When no task completed with a result but a task completed with an exception\n-         * then {@code ExecutionException} is thrown with the exception as the {@linkplain\n-         * Throwable#getCause() cause}. If only cancelled tasks were notified to the {@code\n-         * handle} method then {@code CancellationException} is thrown.\n+         * <p> When no subtask completed with a result but a task completed with an\n+         * exception then {@code ExecutionException} is thrown with the exception as the\n+         * {@linkplain Throwable#getCause() cause}. If only cancelled subtasks were\n+         * notified to the {@code handleComplete} method then {@code CancellationException}\n+         * is thrown.\n@@ -895,1 +904,1 @@\n-         * the join is done.\n+         * the {@code join} is invoked.\n@@ -897,1 +906,1 @@\n-         * @throws ExecutionException if no tasks completed with a result but a task\n+         * @throws ExecutionException if no subtasks completed with a result but a subtask\n@@ -899,1 +908,1 @@\n-         * @throws CancellationException if all tasks were cancelled\n+         * @throws CancellationException if all subtasks were cancelled\n@@ -901,1 +910,1 @@\n-         * completed task\n+         * completed subtask\n@@ -906,1 +915,1 @@\n-                throw new IllegalStateException(\"No completed tasks\");\n+                throw new IllegalStateException(\"No completed subtasks\");\n@@ -918,1 +927,1 @@\n-         * Returns the result of the first task that completed with a result, otherwise\n+         * Returns the result of the first subtask that completed with a result, otherwise\n@@ -921,5 +930,4 @@\n-         * <p> When no task completed with a result but a task completed with an\n-         * exception then the exception supplying function is invoked with the\n-         * exception. If only cancelled tasks were notified to the {@code handleComplete}\n-         * method then the exception supplying function is invoked with a\n-         * {@code CancellationException}.\n+         * <p> When no subtask completed with a result but a subtask completed with an\n+         * exception then the exception supplying function is invoked with the exception.\n+         * If only cancelled subtasks were notified to the {@code handleComplete} method\n+         * then the exception supplying function is invoked with a {@code CancellationException}.\n@@ -930,1 +938,1 @@\n-         * the join is done.\n+         * the {@code join} is invoked.\n@@ -934,2 +942,2 @@\n-         * @return the result of the first task that completed with a result\n-         * @throws X if no task completed with a result\n+         * @return the result of the first subtask that completed with a result\n+         * @throws X if no subtask completed with a result\n@@ -937,1 +945,1 @@\n-         * completed task\n+         * completed subtask\n@@ -943,1 +951,1 @@\n-                throw new IllegalStateException(\"No completed tasks\");\n+                throw new IllegalStateException(\"No completed subtasks\");\n@@ -960,5 +968,6 @@\n-     * A StructuredTaskScope that captures the exception of the first task to complete\n-     * abnormally. Once captured, it invokes the {@linkplain #shutdown() shutdown} method\n-     * to interrupt unfinished threads and wakeup the owner. The policy implemented by this\n-     * class is intended for cases where the results for all tasks are required (\"invoke all\");\n-     * if any task fails then the results of other unfinished tasks are no longer needed.\n+     * A {@code StructuredTaskScope} that captures the exception of the first subtask to\n+     * complete abnormally. Once captured, it invokes the {@linkplain #shutdown() shutdown}\n+     * method to interrupt unfinished threads and wakeup the owner. The policy implemented\n+     * by this class is intended for cases where the results for all subtasks are required\n+     * (\"invoke all\"); if any subtask fails then the results of other unfinished subtasks\n+     * are no longer needed.\n@@ -984,1 +993,1 @@\n-         * Constructs a new ShutdownOnSuccess with the given name and thread factory.\n+         * Constructs a new {@code ShutdownOnFailure} with the given name and thread factory.\n@@ -987,2 +996,2 @@\n-         * threads when tasks are {@linkplain #fork(Callable) forked}. The task scope is\n-         * owned by the current thread.\n+         * threads when tasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n@@ -998,1 +1007,1 @@\n-         * Constructs a new unnamed ShutdownOnFailure that creates virtual threads.\n+         * Constructs a new unnamed {@code ShutdownOnFailure} that creates virtual threads.\n@@ -1008,2 +1017,2 @@\n-         * Shut down the given task scope when invoked for the first time with a task\n-         * that completed abnormally (exception or cancelled).\n+         * Shut down the given task scope when invoked for the first time with a {@code\n+         * Future} for a task that completed abnormally (exception or cancelled).\n@@ -1064,2 +1073,2 @@\n-         * Returns the exception for the first task that completed with an exception.\n-         * If no task completed with an exception but cancelled tasks were notified\n+         * Returns the exception for the first subtask that completed with an exception.\n+         * If no subtask completed with an exception but cancelled subtasks were notified\n@@ -1067,1 +1076,1 @@\n-         * is returned. If no tasks completed abnormally then an empty {@code Optional}\n+         * is returned. If no subtasks completed abnormally then an empty {@code Optional}\n@@ -1073,1 +1082,1 @@\n-         * the join is done.\n+         * the {@code join} is invoked.\n@@ -1075,2 +1084,2 @@\n-         * @return the exception for a task that completed abnormally or an empty\n-         * optional if no tasks completed abnormally\n+         * @return the exception for a subtask that completed abnormally or an empty\n+         * optional if no subtasks completed abnormally\n@@ -1091,4 +1100,4 @@\n-         * Throws if a task completed abnormally. If any task completed with an exception\n-         * then {@code ExecutionException} is thrown with the exception of the first task\n-         * to fail as the {@linkplain Throwable#getCause() cause}.\n-         * If no task completed with an exception but cancelled tasks were notified to the\n+         * Throws if a subtask completed abnormally. If any subtask completed with an\n+         * exception then {@code ExecutionException} is thrown with the exception of the\n+         * first subtask to fail as the {@linkplain Throwable#getCause() cause}. If no\n+         * subtask completed with an exception but cancelled subtasks were notified to the\n@@ -1096,1 +1105,1 @@\n-         * This method does nothing if no tasks completed abnormally.\n+         * This method does nothing if no subtasks completed abnormally.\n@@ -1101,1 +1110,1 @@\n-         * the join is done.\n+         * the {@code join} is invoked.\n@@ -1103,3 +1112,3 @@\n-         * @throws ExecutionException if a task completed with an exception\n-         * @throws CancellationException if no tasks completed with an exception but\n-         * tasks were cancelled\n+         * @throws ExecutionException if a subtask completed with an exception\n+         * @throws CancellationException if no subtasks completed with an exception but\n+         * subtasks were cancelled\n@@ -1120,4 +1129,4 @@\n-         * a task completed abnormally. If any task completed with an exception then\n-         * the function is invoked with the exception of the first task to fail.\n-         * If no task completed with an exception but cancelled tasks were notified to\n-         * the {@code handleComplete} method then the function is called with a {@code\n+         * a subtask completed abnormally. If any subtask completed with an exception then\n+         * the function is invoked with the exception of the first subtask to fail.\n+         * If no subtask completed with an exception but cancelled subtasks were notified\n+         * to the {@code handleComplete} method then the function is called with a {@code\n@@ -1125,1 +1134,1 @@\n-         * This method does nothing if no tasks completed abnormally.\n+         * This method does nothing if no subtasks completed abnormally.\n@@ -1130,1 +1139,1 @@\n-         * the join is done.\n+         * the {@code join} is invoked.\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":138,"deletions":129,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/PreviewFeaturesNotEnabled.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug JDK-8284199\n+ * @bug 8284199\n@@ -502,1 +502,1 @@\n-            checkDuration(startMillis, 1900, 4000);\n+            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n@@ -523,1 +523,1 @@\n-                checkDuration(startMillis, 1900, 4000);\n+                expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n@@ -1240,1 +1240,1 @@\n-    private static long checkDuration(long start, long min, long max) {\n+    private static long expectDuration(long start, long min, long max) {\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- * @ignore \/\/ waiting for JDK-8287008\n@@ -201,1 +200,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredThreadDumpTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}