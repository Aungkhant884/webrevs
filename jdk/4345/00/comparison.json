{"files":[{"patch":"@@ -420,1 +420,1 @@\n-            StringBuilder sig = typeSig.getParameterSignature(msym.type);\n+            StringBuilder sig = typeSig.getParameterSignature(msym.type, true);\n@@ -545,1 +545,1 @@\n-        StringBuilder getParameterSignature(Type mType)\n+        StringBuilder getParameterSignature(Type mType, boolean useFlatname)\n@@ -549,1 +549,1 @@\n-                result.append(getJvmSignature(pType));\n+                result.append(getJvmSignature(pType, useFlatname));\n@@ -556,1 +556,1 @@\n-            return getJvmSignature(mType.getReturnType());\n+            return getJvmSignature(mType.getReturnType(), false);\n@@ -561,1 +561,1 @@\n-            sb.append(\"(\").append(getParameterSignature(mType)).append(\")\");\n+            sb.append(\"(\").append(getParameterSignature(mType, false)).append(\")\");\n@@ -570,0 +570,6 @@\n+            private final boolean useFlatname;\n+\n+            JvmTypeVisitor(boolean useFlatname) {\n+                super();\n+                this.useFlatname = useFlatname;\n+            }\n@@ -592,1 +598,2 @@\n-                    String classname = t.tsym.getQualifiedName().toString();\n+                    String classname = useFlatname ? t.tsym.flatName().toString()\n+                            : t.tsym.getQualifiedName().toString();\n@@ -614,1 +621,1 @@\n-        StringBuilder getJvmSignature(Type type) {\n+        StringBuilder getJvmSignature(Type type, boolean useFlatname) {\n@@ -617,1 +624,1 @@\n-            JvmTypeVisitor jv = new JvmTypeVisitor();\n+            JvmTypeVisitor jv = new JvmTypeVisitor(useFlatname);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/JNIWriter.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8232948\n+ * @summary Make sure inner classes are correctly encoded\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ * @modules jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.JavacTask toolbox.TestRunner toolbox.ToolBox\n+ * @run main EncodeInnerClassNameTest\n+ *\/\n+\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class EncodeInnerClassNameTest {\n+    private final ToolBox toolBox = new ToolBox();\n+    private final String source = \"\"\"\n+    package p.q;\n+    public class Outer {\n+        public class Inner {\n+            native Inner aMethod();\n+            native void aMethod(Inner i);\n+            native void aMethod(Inner i, Inner j);\n+        }\n+    }\n+    \"\"\";\n+    private final String expected = \"\"\"\n+            \/* DO NOT EDIT THIS FILE - it is machine generated *\/\n+            #include <jni.h>\n+            \/* Header for class p_q_Outer_Inner *\/\n+\n+            #ifndef _Included_p_q_Outer_Inner\n+            #define _Included_p_q_Outer_Inner\n+            #ifdef __cplusplus\n+            extern \"C\" {\n+            #endif\n+            \/*\n+             * Class:     p_q_Outer_Inner\n+             * Method:    aMethod\n+             * Signature: ()Lp\/q\/Outer\/Inner;\n+             *\/\n+            JNIEXPORT jobject JNICALL Java_p_q_Outer_00024Inner_aMethod__\n+              (JNIEnv *, jobject);\n+\n+            \/*\n+             * Class:     p_q_Outer_Inner\n+             * Method:    aMethod\n+             * Signature: (Lp\/q\/Outer\/Inner;)V\n+             *\/\n+            JNIEXPORT void JNICALL Java_p_q_Outer_00024Inner_aMethod__Lp_q_Outer_00024Inner_2\n+              (JNIEnv *, jobject, jobject);\n+\n+            \/*\n+             * Class:     p_q_Outer_Inner\n+             * Method:    aMethod\n+             * Signature: (Lp\/q\/Outer\/Inner;Lp\/q\/Outer\/Inner;)V\n+             *\/\n+            JNIEXPORT void JNICALL Java_p_q_Outer_00024Inner_aMethod__Lp_q_Outer_00024Inner_2Lp_q_Outer_00024Inner_2\n+              (JNIEnv *, jobject, jobject, jobject);\n+\n+            #ifdef __cplusplus\n+            }\n+            #endif\n+            #endif\n+            \"\"\";\n+\n+    public static void main(String... args) throws Exception {\n+        new EncodeInnerClassNameTest().runTest();\n+    }\n+\n+    public void runTest() throws Exception {\n+        JavacTask task = new JavacTask(toolBox);\n+        task.outdir(\".\")\n+                .sources(source)\n+                .options(\"-h\", \".\")\n+                .run()\n+                .writeAll();\n+\n+        String res = Files.readString(Path.of(\".\", \"p_q_Outer_Inner.h\"));\n+\n+        if (!res.equals(expected)) {\n+            System.err.println(\"Result:\\n\" + res);\n+            System.err.println(\"\\nExpected:\\n\" + expected);\n+\n+            throw new RuntimeException(\"Output does not match expected result.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nativeHeaders\/EncodeInnerClassNameTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}