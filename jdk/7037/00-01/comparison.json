{"files":[{"patch":"@@ -246,1 +246,1 @@\n-                && PBEKeySpec.class.isAssignableFrom(keySpecCl)) {\n+                    && keySpecCl.isAssignableFrom(PBEKeySpec.class)) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKeyFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-                && PBEKeySpec.class.isAssignableFrom(keySpecCl)) {\n+                    && keySpecCl.isAssignableFrom(PBEKeySpec.class)) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.crypto.provider;\n-\n-import java.security.InvalidKeyException;\n-import java.security.spec.KeySpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.util.Arrays;\n-import javax.crypto.SecretKey;\n-import javax.crypto.SecretKeyFactorySpi;\n-import javax.crypto.spec.PBEKeySpec;\n-\n-\/**\n- * This class implements a key factory for PBE keys derived using\n- * PBKDF2 with HmacSHA1 psuedo random function(PRF) as defined in\n- * PKCS#5 v2.0.\n- *\n- * @author Valerie Peng\n- *\n- *\/\n-public final class PBKDF2HmacSHA1Factory extends SecretKeyFactorySpi {\n-\n-    \/**\n-     * Empty constructor\n-     *\/\n-    public PBKDF2HmacSHA1Factory() {\n-    }\n-\n-    \/**\n-     * Generates a <code>SecretKey<\/code> object from the provided key\n-     * specification (key material).\n-     *\n-     * @param keySpec the specification (key material) of the secret key\n-     *\n-     * @return the secret key\n-     *\n-     * @exception InvalidKeySpecException if the given key specification\n-     * is inappropriate for this key factory to produce a public key.\n-     *\/\n-    protected SecretKey engineGenerateSecret(KeySpec keySpec)\n-        throws InvalidKeySpecException\n-    {\n-        if (!(keySpec instanceof PBEKeySpec)) {\n-            throw new InvalidKeySpecException(\"Invalid key spec\");\n-        }\n-        PBEKeySpec ks = (PBEKeySpec) keySpec;\n-        return new PBKDF2KeyImpl(ks, \"HmacSHA1\");\n-    }\n-\n-    \/**\n-     * Returns a specification (key material) of the given key\n-     * in the requested format.\n-     *\n-     * @param key the key\n-     *\n-     * @param keySpecCl the requested format in which the key material shall be\n-     * returned\n-     *\n-     * @return the underlying key specification (key material) in the\n-     * requested format\n-     *\n-     * @exception InvalidKeySpecException if the requested key\n-     * specification is inappropriate for the given key, or the\n-     * given key cannot be processed (e.g., the given key has an\n-     * unrecognized algorithm or format).\n-     *\/\n-    protected KeySpec engineGetKeySpec(SecretKey key, Class<?> keySpecCl)\n-        throws InvalidKeySpecException {\n-        if (key instanceof javax.crypto.interfaces.PBEKey) {\n-            \/\/ Check if requested key spec is amongst the valid ones\n-            if ((keySpecCl != null)\n-                && PBEKeySpec.class.isAssignableFrom(keySpecCl)) {\n-                javax.crypto.interfaces.PBEKey pKey =\n-                    (javax.crypto.interfaces.PBEKey) key;\n-                char[] passwd = pKey.getPassword();\n-                byte[] encoded = pKey.getEncoded();\n-                try {\n-                    return new PBEKeySpec(passwd, pKey.getSalt(),\n-                            pKey.getIterationCount(), encoded.length * 8);\n-                } finally {\n-                    if (passwd != null) {\n-                        Arrays.fill(passwd, (char) 0);\n-                    }\n-                    Arrays.fill(encoded, (byte)0);\n-                }\n-            } else {\n-                throw new InvalidKeySpecException(\"Invalid key spec\");\n-            }\n-        } else {\n-            throw new InvalidKeySpecException(\"Invalid key \" +\n-                                               \"format\/algorithm\");\n-        }\n-    }\n-\n-    \/**\n-     * Translates a <code>SecretKey<\/code> object, whose provider may be\n-     * unknown or potentially untrusted, into a corresponding\n-     * <code>SecretKey<\/code> object of this key factory.\n-     *\n-     * @param key the key whose provider is unknown or untrusted\n-     *\n-     * @return the translated key\n-     *\n-     * @exception InvalidKeyException if the given key cannot be processed by\n-     * this key factory.\n-     *\/\n-    protected SecretKey engineTranslateKey(SecretKey key)\n-        throws InvalidKeyException {\n-        if ((key != null) &&\n-            (key.getAlgorithm().equalsIgnoreCase(\"PBKDF2WithHmacSHA1\")) &&\n-            (key.getFormat().equalsIgnoreCase(\"RAW\"))) {\n-\n-            \/\/ Check if key originates from this factory\n-            if (key instanceof com.sun.crypto.provider.PBKDF2KeyImpl) {\n-                return key;\n-            }\n-            \/\/ Check if key implements the PBEKey\n-            if (key instanceof javax.crypto.interfaces.PBEKey) {\n-                javax.crypto.interfaces.PBEKey pKey =\n-                    (javax.crypto.interfaces.PBEKey) key;\n-                char[] password = pKey.getPassword();\n-                byte[] encoding = pKey.getEncoded();\n-                PBEKeySpec spec =\n-                        new PBEKeySpec(password,\n-                                pKey.getSalt(),\n-                                pKey.getIterationCount(),\n-                                encoding.length*8);\n-                try {\n-                    return new PBKDF2KeyImpl(spec, \"HmacSHA1\");\n-                } catch (InvalidKeySpecException re) {\n-                    throw new InvalidKeyException\n-                        (\"Invalid key component(s)\", re);\n-                } finally {\n-                    if (password != null) {\n-                        Arrays.fill(password, (char) 0);\n-                        spec.clearPassword();\n-                    }\n-                    Arrays.fill(encoding, (byte)0);\n-                }\n-            }\n-        }\n-        throw new InvalidKeyException(\"Invalid key format\/algorithm\");\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2HmacSHA1Factory.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -26,0 +26,3 @@\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.DESKeySpec;\n+import javax.crypto.spec.DESedeKeySpec;\n@@ -30,0 +33,1 @@\n+import javax.crypto.spec.PBEKeySpec;\n@@ -32,0 +36,1 @@\n+import javax.crypto.spec.SecretKeySpec;\n@@ -39,0 +44,1 @@\n+import java.security.spec.KeySpec;\n@@ -51,6 +57,8 @@\n-        test(\"AES\", new IvParameterSpec(new byte[16]));\n-        test(\"ChaCha20-Poly1305\", new IvParameterSpec(new byte[12]));\n-        test(\"DiffieHellman\", new DHParameterSpec(BigInteger.ONE, BigInteger.TWO));\n-        test(\"GCM\", new GCMParameterSpec(96, new byte[16]));\n-        test(\"OAEP\", OAEPParameterSpec.DEFAULT);\n-        test(\"PBEWithSHA1AndDESede\", new PBEParameterSpec(\n+\n+        \/\/ AlgorithmParameters\n+        testAlgSpec(\"AES\", new IvParameterSpec(new byte[16]));\n+        testAlgSpec(\"ChaCha20-Poly1305\", new IvParameterSpec(new byte[12]));\n+        testAlgSpec(\"DiffieHellman\", new DHParameterSpec(BigInteger.ONE, BigInteger.TWO));\n+        testAlgSpec(\"GCM\", new GCMParameterSpec(96, new byte[16]));\n+        testAlgSpec(\"OAEP\", OAEPParameterSpec.DEFAULT);\n+        testAlgSpec(\"PBEWithSHA1AndDESede\", new PBEParameterSpec(\n@@ -58,1 +66,1 @@\n-        test(\"PBEWithHmacSHA256AndAES_256\", new PBEParameterSpec(\n+        testAlgSpec(\"PBEWithHmacSHA256AndAES_256\", new PBEParameterSpec(\n@@ -61,2 +69,2 @@\n-        test(\"RC2\", new RC2ParameterSpec(256, new byte[32]));\n-        test(\"DSA\", new DSAParameterSpec(\n+        testAlgSpec(\"RC2\", new RC2ParameterSpec(256, new byte[32]));\n+        testAlgSpec(\"DSA\", new DSAParameterSpec(\n@@ -64,3 +72,3 @@\n-        test(\"RSASSA-PSS\", PSSParameterSpec.DEFAULT);\n-        test(\"EC\", new ECGenParameterSpec(\"secp256r1\"));\n-        test(\"EC\", CurveDB.lookup(\"secp256r1\"),\n+        testAlgSpec(\"RSASSA-PSS\", PSSParameterSpec.DEFAULT);\n+        testAlgSpec(\"EC\", new ECGenParameterSpec(\"secp256r1\"));\n+        testAlgSpec(\"EC\", CurveDB.lookup(\"secp256r1\"),\n@@ -68,0 +76,14 @@\n+\n+        \/\/ SecretKeyFactory\n+        var spec = new PBEKeySpec(\n+                \"password\".toCharArray(),\n+                \"saltsalt\".getBytes(StandardCharsets.UTF_8),\n+                10000,\n+                32);\n+\n+        testKeySpec(\"PBE\", spec, PBEKeySpec.class);\n+        testKeySpec(\"PBEWithHmacSHA256AndAES_256\", spec, PBEKeySpec.class);\n+        testKeySpec(\"PBKDF2WithHmacSHA1\", spec, PBEKeySpec.class);\n+\n+        testKeySpec(\"DES\", new SecretKeySpec(new byte[8], \"DES\"), DESKeySpec.class);\n+        testKeySpec(\"DESede\", new SecretKeySpec(new byte[24], \"DESede\"), DESedeKeySpec.class);\n@@ -70,1 +92,2 @@\n-    static void test(String algorithm, AlgorithmParameterSpec spec,\n+\n+    static void testAlgSpec(String algorithm, AlgorithmParameterSpec spec,\n@@ -72,0 +95,1 @@\n+        System.out.println(algorithm);\n@@ -84,0 +108,9 @@\n+\n+    static void testKeySpec(String algorithm, KeySpec spec, Class<?> clazz)\n+            throws Exception {\n+        System.out.println(algorithm);\n+        var kf = SecretKeyFactory.getInstance(algorithm);\n+        var key = kf.generateSecret(spec);\n+        kf.getKeySpec(key, KeySpec.class);\n+        kf.getKeySpec(key, clazz);\n+    }\n","filename":"test\/jdk\/java\/security\/spec\/IsAssignableFromOrder.java","additions":46,"deletions":13,"binary":false,"changes":59,"status":"modified"}]}