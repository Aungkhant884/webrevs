{"files":[{"patch":"@@ -3247,1 +3247,1 @@\n-void MacroAssembler::vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len) {\n+void MacroAssembler::vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n@@ -3249,2 +3249,1 @@\n-  bool aligned_adr = (((intptr_t)src.target() & 15) == 0);\n-  assert((UseAVX > 0) || aligned_adr, \"SSE mode requires address alignment 16 bytes\");\n+  assert((UseAVX > 0), \"SSE mode requires address alignment 16 bytes\");\n@@ -3254,2 +3253,2 @@\n-    lea(rscratch1, src);\n-    Assembler::vpmulld(dst, nds, Address(rscratch1, 0), vector_len);\n+    lea(scratch_reg, src);\n+    Assembler::vpmulld(dst, nds, Address(scratch_reg, 0), vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1322,1 +1322,1 @@\n-  void vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);\n+  void vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);\n@@ -1780,0 +1780,1 @@\n+  void updateBytesAdler32(Register adler32, Register buf, Register length, XMMRegister shuf0, XMMRegister shuf1, ExternalAddress scale);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+* Copyright (c) 2016, Intel Corporation.\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+\n+\n+void MacroAssembler::updateBytesAdler32(Register init_d, Register data, Register size, XMMRegister yshuf0, XMMRegister yshuf1, ExternalAddress ascaletab)\n+{\n+      const int LIMIT = 5552;\n+      const int BASE = 65521;\n+      const int CHUNKSIZE =  16;\n+      const int CHUNKSIZE_M1 = CHUNKSIZE - 1;\n+\n+      const Register s = r11;\n+      const Register a_d = r12; \/\/r12d\n+      const Register b_d = r8; \/\/r8d\n+      const Register end = r13;\n+\n+      const XMMRegister ya = xmm0;\n+      const XMMRegister yb = xmm1;\n+      const XMMRegister ydata0 = xmm2;\n+      const XMMRegister ydata1 = xmm3;\n+      const XMMRegister ysa = xmm4;\n+      const XMMRegister ydata = ysa;\n+      const XMMRegister ytmp0 = ydata0;\n+      const XMMRegister ytmp1 = ydata1;\n+      const XMMRegister ytmp2 = xmm5;\n+      const XMMRegister xa = xmm0;\n+      const XMMRegister xb = xmm1;\n+      const XMMRegister xtmp0 = xmm2;\n+      const XMMRegister xtmp1 = xmm3;\n+      const XMMRegister xsa = xmm4;\n+      const XMMRegister xtmp2 = xmm5;\n+      assert_different_registers(init_d, data, size, s, a_d, b_d, end, rax);\n+\n+      Label SLOOP1, SLOOP1A, SKIP_LOOP_1A, FINISH, LT64, DO_FINAL, FINAL_LOOP, ZERO_SIZE, END;\n+\n+      push(r12);\n+      push(r13);\n+      push(r14);\n+      movl(b_d, init_d); \/\/adler\n+      shrl(b_d, 16);\n+      andl(init_d, 0xFFFF);\n+      cmpl(size, 32);\n+      jcc(Assembler::below, LT64);\n+      movdl(xa, init_d); \/\/vmovd - 32bit\n+      vpxor(yb, yb, yb, Assembler::AVX_256bit);\n+\n+      bind(SLOOP1);\n+      movl(s, LIMIT);\n+      cmpl(s, size);\n+      cmovl(Assembler::above, s, size); \/\/ s = min(size, LIMIT)\n+      lea(end, Address(s, data, Address::times_1, -CHUNKSIZE_M1));\n+      cmpptr(data, end);\n+      jcc(Assembler::aboveEqual, SKIP_LOOP_1A);\n+\n+      bind(SLOOP1A);\n+      vbroadcastf128(ydata, Address(data, 0), Assembler::AVX_256bit);\n+      addptr(data, CHUNKSIZE);\n+      vpshufb(ydata0, ydata, yshuf0, Assembler::AVX_256bit);\n+      vpaddd(ya, ya, ydata0, Assembler::AVX_256bit);\n+      vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n+      vpshufb(ydata1, ydata, yshuf1, Assembler::AVX_256bit);\n+      vpaddd(ya, ya, ydata1, Assembler::AVX_256bit);\n+      vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n+      cmpptr(data, end);\n+      jcc(Assembler::below, SLOOP1A);\n+\n+      bind(SKIP_LOOP_1A);\n+      addptr(end, CHUNKSIZE_M1);\n+      testl(s, CHUNKSIZE_M1);\n+      jcc(Assembler::notEqual, DO_FINAL);\n+\n+      \/\/ either we're done, or we just did LIMIT\n+      subl(size, s);\n+\n+      \/\/ reduce\n+      vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n+      vpmulld(ysa, ya, ascaletab, Assembler::AVX_256bit, r14);\n+\n+      \/\/ compute horizontal sums of ya, yb, ysa\n+      vextracti128(xtmp0, ya, 1);\n+      vextracti128(xtmp1, yb, 1);\n+      vextracti128(xtmp2, ysa, 1);\n+      vpaddd(xa, xa, xtmp0, Assembler::AVX_256bit);\n+      vpaddd(xb, xb, xtmp1, Assembler::AVX_256bit);\n+      vpaddd(xsa, xsa, xtmp2, Assembler::AVX_256bit);\n+      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+\n+      movdl(rax, xa);\n+      xorl(rdx, rdx);\n+      movl(rcx, BASE);\n+      divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n+      movl(a_d, rdx);\n+\n+      vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n+      movdl(rax, xb);\n+      addl(rax, b_d);\n+      xorl(rdx, rdx);\n+      movl(rcx, BASE);\n+      divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n+      movl(b_d, rdx);\n+\n+      testl(size, size);\n+      jcc(Assembler::zero, FINISH);\n+\n+      \/\/ continue loop\n+      movdl(xa, a_d);\n+      vpxor(yb, yb, yb, Assembler::AVX_256bit);\n+      jmp(SLOOP1);\n+\n+      bind(FINISH);\n+      movl(rax, b_d);\n+      shll(rax, 16);\n+      orl(rax, a_d);\n+      jmp(END);\n+\n+      bind(LT64);\n+      movl(a_d, init_d);\n+      lea(end, Address(data, size, Address::times_1));\n+      testl(size, size);\n+      jcc(Assembler::notZero, FINAL_LOOP);\n+      jmp(ZERO_SIZE);\n+\n+      \/\/ handle remaining 1...15 bytes\n+      bind(DO_FINAL);\n+      \/\/ reduce\n+      vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n+      vpmulld(ysa, ya, ascaletab, Assembler::AVX_256bit, r14); \/\/scaled a\n+\n+      vextracti128(xtmp0, ya, 1);\n+      vextracti128(xtmp1, yb, 1);\n+      vextracti128(xtmp2, ysa, 1);\n+      vpaddd(xa, xa, xtmp0, Assembler::AVX_128bit);\n+      vpaddd(xb, xb, xtmp1, Assembler::AVX_128bit);\n+      vpaddd(xsa, xsa, xtmp2, Assembler::AVX_128bit);\n+      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+      vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n+\n+      movdl(a_d, xa);\n+      movdl(rax, xb);\n+      addl(b_d, rax);\n+\n+      bind(FINAL_LOOP);\n+      movzbl(rax, Address(data, 0)); \/\/movzx   eax, byte[data]\n+      addl(a_d, rax);\n+      incl(data);\n+      addl(b_d, a_d);\n+      cmpptr(data, end);\n+      jcc(Assembler::below, FINAL_LOOP);\n+\n+      bind(ZERO_SIZE);\n+\n+      movl(rax, a_d);\n+      xorl(rdx, rdx);\n+      movl(rcx, BASE);\n+      divl(rcx); \/\/ div ecx -- divide edx:eax by ecx, quot->eax, rem->edx\n+      movl(a_d, rdx);\n+\n+      movl(rax, b_d);\n+      xorl(rdx, rdx);\n+      movl(rcx, BASE);\n+      divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n+      shll(rdx, 16);\n+      orl(rdx, a_d);\n+      movl(rax, rdx);\n+\n+      bind(END);\n+      pop(r14);\n+      pop(r13);\n+      pop(r12);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_adler.cpp","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -5814,6 +5814,0 @@\n-      const int LIMIT = 5552;\n-      const int BASE = 65521;\n-      const int CHUNKSIZE =  16;\n-      const int CHUNKSIZE_M1 = CHUNKSIZE - 1;\n-\n-      const Register init_d = c_rarg0; \/\/init adler\n@@ -5822,20 +5816,1 @@\n-      const Register s = r11;\n-      const Register a_d = r12; \/\/r12d\n-      const Register b_d = r8; \/\/r8d\n-      const Register end = r13;\n-\n-      const XMMRegister ya = xmm0;\n-      const XMMRegister yb = xmm1;\n-      const XMMRegister ydata0 = xmm2;\n-      const XMMRegister ydata1 = xmm3;\n-      const XMMRegister ysa = xmm4;\n-      const XMMRegister ydata = ysa;\n-      const XMMRegister ytmp0 = ydata0;\n-      const XMMRegister ytmp1 = ydata1;\n-      const XMMRegister ytmp2 = xmm5;\n-      const XMMRegister xa = xmm0;\n-      const XMMRegister xb = xmm1;\n-      const XMMRegister xtmp0 = xmm2;\n-      const XMMRegister xtmp1 = xmm3;\n-      const XMMRegister xsa = xmm4;\n-      const XMMRegister xtmp2 = xmm5;\n+\n@@ -5844,3 +5819,1 @@\n-      assert_different_registers(init_d, c_rarg1, c_rarg2, data, size, s, a_d, b_d, end, rax);\n-\n-      Label SLOOP1, SLOOP1A, SKIP_LOOP_1A, FINISH, LT64, DO_FINAL, FINAL_LOOP, ZERO_SIZE, END;\n+      assert_different_registers(c_rarg0, c_rarg1, c_rarg2, data, size);\n@@ -5851,2 +5824,0 @@\n-      __ push(r12);\n-      __ push(r13);\n@@ -5857,140 +5828,1 @@\n-      __ movl(b_d, init_d); \/\/adler\n-      __ shrl(b_d, 16);\n-      __ andl(init_d, 0xFFFF);\n-      __ cmpl(size, 32);\n-      __ jcc(Assembler::below, LT64);\n-      __ movdl(xa, init_d); \/\/vmovd - 32bit\n-      __ vpxor(yb, yb, yb, Assembler::AVX_256bit);\n-\n-      __ BIND(SLOOP1);\n-      __ movl(s, LIMIT);\n-      __ cmpl(s, size);\n-      __ cmovl(Assembler::above, s, size); \/\/ s = min(size, LIMIT)\n-      __ lea(end, Address(s, data, Address::times_1, -CHUNKSIZE_M1));\n-      __ cmpq(data, end);\n-      __ jcc(Assembler::aboveEqual, SKIP_LOOP_1A);\n-\n-      __ BIND(SLOOP1A);\n-      __ vbroadcastf128(ydata, Address(data, 0), Assembler::AVX_256bit);\n-      __ addptr(data, CHUNKSIZE);\n-      __ vpshufb(ydata0, ydata, yshuf0, Assembler::AVX_256bit);\n-      __ vpaddd(ya, ya, ydata0, Assembler::AVX_256bit);\n-      __ vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n-      __ vpshufb(ydata1, ydata, yshuf1, Assembler::AVX_256bit);\n-      __ vpaddd(ya, ya, ydata1, Assembler::AVX_256bit);\n-      __ vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n-      __ cmpptr(data, end);\n-      __ jcc(Assembler::below, SLOOP1A);\n-\n-      __ BIND(SKIP_LOOP_1A);\n-      __ addptr(end, CHUNKSIZE_M1);\n-      __ testl(s, CHUNKSIZE_M1);\n-      __ jcc(Assembler::notEqual, DO_FINAL);\n-\n-      \/\/ either we're done, or we just did LIMIT\n-      __ subl(size, s);\n-\n-      \/\/ reduce\n-      __ vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n-      __ vpmulld(ysa, ya, ExternalAddress((address) StubRoutines::x86::_adler32_ascale_table), Assembler::AVX_256bit); \/\/need scratch register??\n-\n-      \/\/ compute horizontal sums of ya, yb, ysa\n-      __ vextracti128(xtmp0, ya, 1);\n-      __ vextracti128(xtmp1, yb, 1);\n-      __ vextracti128(xtmp2, ysa, 1);\n-      __ vpaddd(xa, xa, xtmp0, Assembler::AVX_256bit);\n-      __ vpaddd(xb, xb, xtmp1, Assembler::AVX_256bit);\n-      __ vpaddd(xsa, xsa, xtmp2, Assembler::AVX_256bit);\n-      __ vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n-      __ vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n-      __ vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n-      __ vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n-      __ vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n-      __ vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n-\n-      __ movdl(rax, xa);\n-      __ xorl(rdx, rdx);\n-      __ movl(rcx, BASE);\n-      __ divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n-      __ movl(a_d, rdx);\n-\n-      __ vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n-      __ movdl(rax, xb);\n-      __ addl(rax, b_d);\n-      __ xorl(rdx, rdx);\n-      __ movl(rcx, BASE);\n-      __ divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n-      __ movl(b_d, rdx);\n-\n-      __ testl(size, size);\n-      __ jcc(Assembler::zero, FINISH);\n-\n-      \/\/ continue loop\n-      __ movdl(xa, a_d);\n-      __ vpxor(yb, yb, yb, Assembler::AVX_256bit);\n-      __ jmp(SLOOP1);\n-\n-      __ BIND(FINISH);\n-      __ movl(rax, b_d);\n-      __ shll(rax, 16);\n-      __ orl(rax, a_d);\n-      __ jmp(END);\n-\n-      __ BIND(LT64);\n-      __ movl(a_d, init_d);\n-      __ lea(end, Address(data, size, Address::times_1));\n-      __ testl(size, size);\n-      __ jcc(Assembler::notZero, FINAL_LOOP);\n-      __ jmp(ZERO_SIZE);\n-\n-      \/\/ handle remaining 1...15 bytes\n-      __ BIND(DO_FINAL);\n-      \/\/ reduce\n-      __ vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n-      __ vpmulld(ysa, ya, ExternalAddress((address) StubRoutines::x86::_adler32_ascale_table), Assembler::AVX_256bit); \/\/scaled a\n-\n-      __ vextracti128(xtmp0, ya, 1);\n-      __ vextracti128(xtmp1, yb, 1);\n-      __ vextracti128(xtmp2, ysa, 1);\n-      __ vpaddd(xa, xa, xtmp0, Assembler::AVX_128bit);\n-      __ vpaddd(xb, xb, xtmp1, Assembler::AVX_128bit);\n-      __ vpaddd(xsa, xsa, xtmp2, Assembler::AVX_128bit);\n-      __ vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n-      __ vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n-      __ vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n-      __ vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n-      __ vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n-      __ vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n-      __ vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n-\n-      __ movdl(a_d, xa);\n-      __ movdl(rax, xb);\n-      __ addl(b_d, rax);\n-\n-      __ BIND(FINAL_LOOP);\n-      __ movzbl(rax, Address(data, 0)); \/\/movzx   eax, byte[data]\n-      __ addl(a_d, rax);\n-      __ incl(data);\n-      __ addl(b_d, a_d);\n-      __ cmpptr(data, end);\n-      __ jcc(Assembler::below, FINAL_LOOP);\n-\n-      __ BIND(ZERO_SIZE);\n-\n-      __ movl(rax, a_d);\n-      __ xorl(rdx, rdx);\n-      __ movl(rcx, BASE);\n-      __ divl(rcx); \/\/ div ecx -- divide edx:eax by ecx, quot->eax, rem->edx\n-      __ movl(a_d, rdx);\n-\n-      __ movl(rax, b_d);\n-      __ xorl(rdx, rdx);\n-      __ movl(rcx, BASE);\n-      __ divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n-      __ shll(rdx, 16);\n-      __ orl(rdx, a_d);\n-      __ movl(rax, rdx);\n-\n-      __ BIND(END);\n-      __ pop(r13);\n-      __ pop(r12);\n+      __ updateBytesAdler32(c_rarg0, data, size, yshuf0, yshuf1, ExternalAddress((address) StubRoutines::x86::_adler32_ascale_table));\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":171,"binary":false,"changes":174,"status":"modified"}]}