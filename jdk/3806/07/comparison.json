{"files":[{"patch":"@@ -7857,0 +7857,12 @@\n+void Assembler::vbroadcastf128(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  assert(vector_len == AVX_256bit, \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T4, \/* input_size_in_bits *\/ EVEX_32bit);\n+  \/\/ swap src<->dst for encoding\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x1A);\n+  emit_operand(dst, src);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2397,1 +2397,1 @@\n-  \/\/ scalar single\/double precision replicate\n+  \/\/ scalar single\/double\/128bit precision replicate\n@@ -2402,0 +2402,1 @@\n+  void vbroadcastf128(XMMRegister dst, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3247,0 +3247,10 @@\n+void MacroAssembler::vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+  assert((UseAVX > 0), \"AVX support is needed\");\n+  if (reachable(src)) {\n+    Assembler::vpmulld(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(scratch_reg, src);\n+    Assembler::vpmulld(dst, nds, Address(scratch_reg, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1316,0 +1316,7 @@\n+  void vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+    Assembler::vpmulld(dst, nds, src, vector_len);\n+  };\n+  void vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+    Assembler::vpmulld(dst, nds, src, vector_len);\n+  }\n+  void vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);\n@@ -1773,0 +1780,1 @@\n+  void updateBytesAdler32(Register adler32, Register buf, Register length, XMMRegister shuf0, XMMRegister shuf1, ExternalAddress scale);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+* Copyright (c) 2021, Intel Corporation.\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+\n+#ifdef _LP64\n+void MacroAssembler::updateBytesAdler32(Register init_d, Register data, Register size, XMMRegister yshuf0, XMMRegister yshuf1, ExternalAddress ascaletab)\n+{\n+      const int LIMIT = 5552;\n+      const int BASE = 65521;\n+      const int CHUNKSIZE =  16;\n+      const int CHUNKSIZE_M1 = CHUNKSIZE - 1;\n+\n+      const Register s = r11;\n+      const Register a_d = r12; \/\/r12d\n+      const Register b_d = r8; \/\/r8d\n+      const Register end = r13;\n+\n+      const XMMRegister ya = xmm0;\n+      const XMMRegister yb = xmm1;\n+      const XMMRegister ydata0 = xmm2;\n+      const XMMRegister ydata1 = xmm3;\n+      const XMMRegister ysa = xmm4;\n+      const XMMRegister ydata = ysa;\n+      const XMMRegister ytmp0 = ydata0;\n+      const XMMRegister ytmp1 = ydata1;\n+      const XMMRegister ytmp2 = xmm5;\n+      const XMMRegister xa = xmm0;\n+      const XMMRegister xb = xmm1;\n+      const XMMRegister xtmp0 = xmm2;\n+      const XMMRegister xtmp1 = xmm3;\n+      const XMMRegister xsa = xmm4;\n+      const XMMRegister xtmp2 = xmm5;\n+      assert_different_registers(init_d, data, size, s, a_d, b_d, end, rax);\n+\n+      Label SLOOP1, SLOOP1A, SKIP_LOOP_1A, FINISH, LT64, DO_FINAL, FINAL_LOOP, ZERO_SIZE, END;\n+\n+      push(r12);\n+      push(r13);\n+      push(r14);\n+      movl(b_d, init_d); \/\/adler\n+      shrl(b_d, 16);\n+      andl(init_d, 0xFFFF);\n+      cmpl(size, 32);\n+      jcc(Assembler::below, LT64);\n+      movdl(xa, init_d); \/\/vmovd - 32bit\n+      vpxor(yb, yb, yb, Assembler::AVX_256bit);\n+\n+      bind(SLOOP1);\n+      movl(s, LIMIT);\n+      cmpl(s, size);\n+      cmovl(Assembler::above, s, size); \/\/ s = min(size, LIMIT)\n+      lea(end, Address(s, data, Address::times_1, -CHUNKSIZE_M1));\n+      cmpptr(data, end);\n+      jcc(Assembler::aboveEqual, SKIP_LOOP_1A);\n+\n+      align(32);\n+      bind(SLOOP1A);\n+      vbroadcastf128(ydata, Address(data, 0), Assembler::AVX_256bit);\n+      addptr(data, CHUNKSIZE);\n+      vpshufb(ydata0, ydata, yshuf0, Assembler::AVX_256bit);\n+      vpaddd(ya, ya, ydata0, Assembler::AVX_256bit);\n+      vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n+      vpshufb(ydata1, ydata, yshuf1, Assembler::AVX_256bit);\n+      vpaddd(ya, ya, ydata1, Assembler::AVX_256bit);\n+      vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n+      cmpptr(data, end);\n+      jcc(Assembler::below, SLOOP1A);\n+\n+      bind(SKIP_LOOP_1A);\n+      addptr(end, CHUNKSIZE_M1);\n+      testl(s, CHUNKSIZE_M1);\n+      jcc(Assembler::notEqual, DO_FINAL);\n+\n+      \/\/ either we're done, or we just did LIMIT\n+      subl(size, s);\n+\n+      \/\/ reduce\n+      vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n+      vpmulld(ysa, ya, ascaletab, Assembler::AVX_256bit, r14);\n+\n+      \/\/ compute horizontal sums of ya, yb, ysa\n+      vextracti128(xtmp0, ya, 1);\n+      vextracti128(xtmp1, yb, 1);\n+      vextracti128(xtmp2, ysa, 1);\n+      vpaddd(xa, xa, xtmp0, Assembler::AVX_128bit);\n+      vpaddd(xb, xb, xtmp1, Assembler::AVX_128bit);\n+      vpaddd(xsa, xsa, xtmp2, Assembler::AVX_128bit);\n+      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+\n+      movdl(rax, xa);\n+      xorl(rdx, rdx);\n+      movl(rcx, BASE);\n+      divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n+      movl(a_d, rdx);\n+\n+      vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n+      movdl(rax, xb);\n+      addl(rax, b_d);\n+      xorl(rdx, rdx);\n+      movl(rcx, BASE);\n+      divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n+      movl(b_d, rdx);\n+\n+      testl(size, size);\n+      jcc(Assembler::zero, FINISH);\n+\n+      \/\/ continue loop\n+      movdl(xa, a_d);\n+      vpxor(yb, yb, yb, Assembler::AVX_256bit);\n+      jmp(SLOOP1);\n+\n+      bind(FINISH);\n+      movl(rax, b_d);\n+      shll(rax, 16);\n+      orl(rax, a_d);\n+      jmp(END);\n+\n+      bind(LT64);\n+      movl(a_d, init_d);\n+      lea(end, Address(data, size, Address::times_1));\n+      testl(size, size);\n+      jcc(Assembler::notZero, FINAL_LOOP);\n+      jmp(ZERO_SIZE);\n+\n+      \/\/ handle remaining 1...15 bytes\n+      bind(DO_FINAL);\n+      \/\/ reduce\n+      vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n+      vpmulld(ysa, ya, ascaletab, Assembler::AVX_256bit, r14); \/\/scaled a\n+\n+      vextracti128(xtmp0, ya, 1);\n+      vextracti128(xtmp1, yb, 1);\n+      vextracti128(xtmp2, ysa, 1);\n+      vpaddd(xa, xa, xtmp0, Assembler::AVX_128bit);\n+      vpaddd(xb, xb, xtmp1, Assembler::AVX_128bit);\n+      vpaddd(xsa, xsa, xtmp2, Assembler::AVX_128bit);\n+      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+      vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n+\n+      movdl(a_d, xa);\n+      movdl(rax, xb);\n+      addl(b_d, rax);\n+\n+      align(32);\n+      bind(FINAL_LOOP);\n+      movzbl(rax, Address(data, 0)); \/\/movzx   eax, byte[data]\n+      addl(a_d, rax);\n+      addptr(data, 1);\n+      addl(b_d, a_d);\n+      cmpptr(data, end);\n+      jcc(Assembler::below, FINAL_LOOP);\n+\n+      bind(ZERO_SIZE);\n+\n+      movl(rax, a_d);\n+      xorl(rdx, rdx);\n+      movl(rcx, BASE);\n+      divl(rcx); \/\/ div ecx -- divide edx:eax by ecx, quot->eax, rem->edx\n+      movl(a_d, rdx);\n+\n+      movl(rax, b_d);\n+      xorl(rdx, rdx);\n+      movl(rcx, BASE);\n+      divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n+      shll(rdx, 16);\n+      orl(rdx, a_d);\n+      movl(rax, rdx);\n+\n+      bind(END);\n+      pop(r14);\n+      pop(r13);\n+      pop(r12);\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_adler.cpp","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -5793,0 +5793,41 @@\n+\n+  \/***\n+   *  Arguments:\n+   *\n+   *  Inputs:\n+   *   c_rarg0   - int   adler\n+   *   c_rarg1   - byte* buff\n+   *   c_rarg2   - int   len\n+   *\n+   * Output:\n+   *   rax   - int adler result\n+   *\/\n+\n+  address generate_updateBytesAdler32() {\n+      assert(UseAdler32Intrinsics, \"need AVX2\");\n+\n+      __ align(CodeEntryAlignment);\n+      StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+\n+      address start = __ pc();\n+\n+      const Register data = r9;\n+      const Register size = r10;\n+\n+      const XMMRegister yshuf0 = xmm6;\n+      const XMMRegister yshuf1 = xmm7;\n+      assert_different_registers(c_rarg0, c_rarg1, c_rarg2, data, size);\n+\n+      BLOCK_COMMENT(\"Entry:\");\n+      __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+      __ vmovdqu(yshuf0, ExternalAddress((address) StubRoutines::x86::_adler32_shuf0_table), r9);\n+      __ vmovdqu(yshuf1, ExternalAddress((address) StubRoutines::x86::_adler32_shuf1_table), r9);\n+      __ movptr(data, c_rarg1); \/\/data\n+      __ movl(size, c_rarg2); \/\/length\n+      __ updateBytesAdler32(c_rarg0, data, size, yshuf0, yshuf1, ExternalAddress((address) StubRoutines::x86::_adler32_ascale_table));\n+      __ leave();\n+      __ ret(0);\n+      return start;\n+  }\n+\n@@ -6757,0 +6798,5 @@\n+\n+    if (UseAdler32Intrinsics) {\n+       StubRoutines::_updateBytesAdler32 = generate_updateBytesAdler32();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -227,0 +227,19 @@\n+\n+juint StubRoutines::x86::_adler32_ascale_table[] =\n+{\n+    0x00000000UL, 0x00000001UL, 0x00000002UL, 0x00000003UL,\n+    0x00000004UL, 0x00000005UL, 0x00000006UL, 0x00000007UL\n+};\n+\n+juint StubRoutines::x86::_adler32_shuf0_table[] =\n+{\n+    0xFFFFFF00UL, 0xFFFFFF01UL, 0xFFFFFF02UL, 0xFFFFFF03UL,\n+    0xFFFFFF04UL, 0xFFFFFF05UL, 0xFFFFFF06UL, 0xFFFFFF07UL\n+};\n+\n+juint StubRoutines::x86::_adler32_shuf1_table[] =\n+{\n+    0xFFFFFF08UL, 0xFFFFFF09, 0xFFFFFF0AUL, 0xFFFFFF0BUL,\n+    0xFFFFFF0CUL, 0xFFFFFF0D, 0xFFFFFF0EUL, 0xFFFFFF0FUL\n+};\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -122,0 +122,3 @@\n+  static juint    _adler32_shuf0_table[];\n+  static juint    _adler32_shuf1_table[];\n+  static juint    _adler32_ascale_table[];\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -901,0 +901,17 @@\n+#ifdef _LP64\n+  if (supports_avx2()) {\n+    if (FLAG_IS_DEFAULT(UseAdler32Intrinsics)) {\n+      UseAdler32Intrinsics = true;\n+    }\n+  } else if (UseAdler32Intrinsics) {\n+    if (!FLAG_IS_DEFAULT(UseAdler32Intrinsics))\n+      warning(\"Adler32 Intrinsics requires avx2 instructions (not available on this CPU)\");\n+    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n+  }\n+#else\n+  if (UseAdler32Intrinsics) {\n+    warning(\"Adler32Intrinsics not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n+  }\n+#endif\n+\n@@ -996,5 +1013,0 @@\n-  if (UseAdler32Intrinsics) {\n-    warning(\"Adler32Intrinsics not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+  case vmIntrinsics::_updateBytesAdler32:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+  do_bool_flag(UseAdler32Intrinsics)                                       \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -578,0 +578,1 @@\n+     static_field(StubRoutines,                _updateBytesAdler32,                           address)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}