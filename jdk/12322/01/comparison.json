{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  assert(info != NULL, \"must have info\");\n+  assert(info != nullptr, \"must have info\");\n@@ -68,1 +68,1 @@\n-  assert(info != NULL, \"must have info\");\n+  assert(info != nullptr, \"must have info\");\n@@ -348,1 +348,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -243,1 +243,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -256,1 +256,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -266,1 +266,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -405,1 +405,1 @@\n-  assert((src->as_constant_ptr()->type() == T_OBJECT && src->as_constant_ptr()->as_jobject() == NULL),\"cannot handle otherwise\");\n+  assert((src->as_constant_ptr()->type() == T_OBJECT && src->as_constant_ptr()->as_jobject() == nullptr),\"cannot handle otherwise\");\n@@ -411,1 +411,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -499,1 +499,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -550,1 +550,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -559,1 +559,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -568,1 +568,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -608,1 +608,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -612,1 +612,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -701,1 +701,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -705,1 +705,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -759,1 +759,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -768,1 +768,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -777,1 +777,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -817,1 +817,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -864,4 +864,4 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  _branch_target_blocks.append(op->block());\n-  if (op->ublock() != NULL) _branch_target_blocks.append(op->ublock());\n-  assert(op->info() == NULL, \"CodeEmitInfo?\");\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  _branch_target_blocks.append(op->block());\n+  if (op->ublock() != nullptr) _branch_target_blocks.append(op->ublock());\n+  assert(op->info() == nullptr, \"CodeEmitInfo?\");\n@@ -1024,1 +1024,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -1026,1 +1026,1 @@\n-  assert(data != NULL,       \"need data for checkcast\");\n+  assert(data != nullptr,       \"need data for checkcast\");\n@@ -1039,1 +1039,1 @@\n-  assert(method != NULL, \"Should have method\");\n+  assert(method != nullptr, \"Should have method\");\n@@ -1514,1 +1514,1 @@\n-  assert(info == NULL, \"unused on this code path\");\n+  assert(info == nullptr, \"unused on this code path\");\n@@ -1791,1 +1791,1 @@\n-          assert(opr2->as_constant_ptr()->as_jobject() == NULL, \"cannot handle otherwise\");\n+          assert(opr2->as_constant_ptr()->as_jobject() == nullptr, \"cannot handle otherwise\");\n@@ -1796,1 +1796,1 @@\n-          assert(opr2->as_constant_ptr()->as_metadata() == NULL, \"cannot handle otherwise\");\n+          assert(opr2->as_constant_ptr()->as_metadata() == nullptr, \"cannot handle otherwise\");\n@@ -1944,1 +1944,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -1950,1 +1950,1 @@\n-  InlinedMetadata metadata_literal(NULL);\n+  InlinedMetadata metadata_literal(nullptr);\n@@ -2104,1 +2104,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -2108,1 +2108,1 @@\n-  if (default_type == NULL) {\n+  if (default_type == nullptr) {\n@@ -2117,1 +2117,1 @@\n-    assert(copyfunc_addr != NULL, \"generic arraycopy stub required\");\n+    assert(copyfunc_addr != nullptr, \"generic arraycopy stub required\");\n@@ -2142,1 +2142,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass() && default_type->is_loaded(),\n+  assert(default_type != nullptr && default_type->is_array_klass() && default_type->is_loaded(),\n@@ -2147,1 +2147,1 @@\n-  \/\/ Check for NULL\n+  \/\/ Check for null\n@@ -2255,1 +2255,1 @@\n-      __ check_klass_subtype_fast_path(tmp, tmp2, R6, altFP_7_11, &cont, copyfunc_addr == NULL ? stub->entry() : &slow, NULL);\n+      __ check_klass_subtype_fast_path(tmp, tmp2, R6, altFP_7_11, &cont, copyfunc_addr == nullptr ? stub->entry() : &slow, nullptr);\n@@ -2266,1 +2266,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ use stub if available\n+      if (copyfunc_addr != nullptr) { \/\/ use stub if available\n@@ -2435,1 +2435,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2443,1 +2443,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2459,1 +2459,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2477,1 +2477,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2479,1 +2479,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -2505,1 +2505,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -2534,1 +2534,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -2637,1 +2637,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2682,1 +2682,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2749,1 +2749,1 @@\n-        assert(cmp != NULL, \"cmp LIR instruction is not an op2\");\n+        assert(cmp != nullptr, \"cmp LIR instruction is not an op2\");\n@@ -2753,1 +2753,1 @@\n-          if (cmove != NULL && cmove->code() == lir_cmove) {\n+          if (cmove != nullptr && cmove->code() == lir_cmove) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-  if (v->type()->as_IntConstant() != NULL) {\n+  if (v->type()->as_IntConstant() != nullptr) {\n@@ -129,1 +129,1 @@\n-  } else if (v->type()->as_ObjectConstant() != NULL) {\n+  } else if (v->type()->as_ObjectConstant() != nullptr) {\n@@ -131,1 +131,1 @@\n-  } else if (v->type()->as_FloatConstant() != NULL) {\n+  } else if (v->type()->as_FloatConstant() != nullptr) {\n@@ -133,1 +133,1 @@\n-  } else if (v->type()->as_DoubleConstant() != NULL) {\n+  } else if (v->type()->as_DoubleConstant() != nullptr) {\n@@ -415,1 +415,1 @@\n-  CodeEmitInfo* info_for_exception = NULL;\n+  CodeEmitInfo* info_for_exception = nullptr;\n@@ -443,1 +443,1 @@\n-  address runtime_func = NULL;\n+  address runtime_func = nullptr;\n@@ -450,2 +450,2 @@\n-  if (runtime_func != NULL) {\n-    set_result(x, call_runtime(x->x(), runtime_func, x->type(), NULL));\n+  if (runtime_func != nullptr) {\n+    set_result(x, call_runtime(x->x(), runtime_func, x->type(), nullptr));\n@@ -517,1 +517,1 @@\n-  LIR_Opr result = call_runtime(x->x(), x->y(), runtime_func, x->type(), NULL);\n+  LIR_Opr result = call_runtime(x->x(), x->y(), runtime_func, x->type(), nullptr);\n@@ -531,1 +531,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -560,1 +560,1 @@\n-      LIR_Opr result = call_runtime(x->y(), x->x(), entry, x->type(), NULL);\n+      LIR_Opr result = call_runtime(x->y(), x->x(), entry, x->type(), nullptr);\n@@ -571,1 +571,1 @@\n-      arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), NULL);\n+      arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), nullptr);\n@@ -661,1 +661,1 @@\n-    assert(count.type()->as_IntConstant() != NULL, \"should be\");\n+    assert(count.type()->as_IntConstant() != nullptr, \"should be\");\n@@ -715,1 +715,1 @@\n-  LIR_Opr result = call_runtime(x->x(), x->y(), runtime_func, x->type(), NULL);\n+  LIR_Opr result = call_runtime(x->x(), x->y(), runtime_func, x->type(), nullptr);\n@@ -832,1 +832,1 @@\n-    result = call_runtime(x->argument_at(0), runtime_func, x->type(), NULL);\n+    result = call_runtime(x->argument_at(0), runtime_func, x->type(), nullptr);\n@@ -835,1 +835,1 @@\n-    result = call_runtime(x->argument_at(0), x->argument_at(1), runtime_func, x->type(), NULL);\n+    result = call_runtime(x->argument_at(0), x->argument_at(1), runtime_func, x->type(), nullptr);\n@@ -924,1 +924,1 @@\n-      __ convert(x->op(), value.result(), reg, NULL);\n+      __ convert(x->op(), value.result(), reg, nullptr);\n@@ -929,1 +929,1 @@\n-  LIR_Opr result = call_runtime(x->value(), runtime_func, x->type(), NULL);\n+  LIR_Opr result = call_runtime(x->value(), runtime_func, x->type(), nullptr);\n@@ -989,1 +989,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1018,1 +1018,1 @@\n-  LIRItemList* items = new LIRItemList(i, i, NULL);\n+  LIRItemList* items = new LIRItemList(i, i, nullptr);\n@@ -1025,1 +1025,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1072,1 +1072,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1085,1 +1085,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1089,1 +1089,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1110,1 +1110,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1208,1 +1208,1 @@\n-  LIR_Opr result = call_runtime(x->x(), x->y(), runtime_func, intType, NULL);\n+  LIR_Opr result = call_runtime(x->x(), x->y(), runtime_func, intType, nullptr);\n@@ -1298,1 +1298,1 @@\n-    LIR_Address* store_addr = NULL;\n+    LIR_Address* store_addr = nullptr;\n@@ -1317,1 +1317,1 @@\n-    LIR_Address* load_addr = NULL;\n+    LIR_Address* load_addr = nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,1 @@\n-  \/\/ If hdr is NULL, we've got recursive locking and there's nothing more to do\n+  \/\/ If hdr is null, we've got recursive locking and there's nothing more to do\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  void null_check(Register r, Label *Lnull = NULL) { MacroAssembler::null_check(r); }\n+  void null_check(Register r, Label *Lnull = nullptr) { MacroAssembler::null_check(r); }\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,1 +291,1 @@\n-  OopMap* oop_map = NULL;\n+  OopMap* oop_map = nullptr;\n@@ -382,1 +382,1 @@\n-  assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+  assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -404,1 +404,1 @@\n-  OopMapSet* oop_maps = NULL;\n+  OopMapSet* oop_maps = nullptr;\n@@ -667,1 +667,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -713,1 +713,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_Runtime1_arm.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,1 +144,1 @@\n-  \/\/ If hdr is NULL, we've got recursive locking and there's nothing more to do\n+  \/\/ If hdr is null, we've got recursive locking and there's nothing more to do\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  if (mark == NULL) {\n+  if (mark == nullptr) {\n@@ -52,2 +52,2 @@\n-  if (base == NULL) {\n-    return NULL;  \/\/ CodeBuffer::expand failed\n+  if (base == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n@@ -59,1 +59,1 @@\n-  InlinedMetadata object_literal(NULL);\n+  InlinedMetadata object_literal(nullptr);\n@@ -106,1 +106,1 @@\n-  guarantee(stub != NULL, \"stub not found\");\n+  guarantee(stub != nullptr, \"stub not found\");\n@@ -133,1 +133,1 @@\n-  assert(stub != NULL, \"stub not found\");\n+  assert(stub != nullptr, \"stub not found\");\n@@ -153,1 +153,1 @@\n-  assert(stub != NULL, \"no stub found for static call\");\n+  assert(stub != nullptr, \"no stub found for static call\");\n","filename":"src\/hotspot\/cpu\/arm\/compiledIC_arm.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -45,1 +45,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -78,1 +78,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -84,1 +84,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -89,1 +89,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -98,1 +98,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -103,1 +103,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -112,1 +112,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -117,1 +117,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -122,1 +122,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -127,1 +127,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/continuationHelper_arm.inline.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  static address decode_instruction0(address here, outputStream* st, address virtual_begin = NULL) {\n+  static address decode_instruction0(address here, outputStream* st, address virtual_begin = nullptr) {\n","filename":"src\/hotspot\/cpu\/arm\/disassembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  if (_cb != NULL ) {\n+  if (_cb != nullptr ) {\n@@ -99,2 +99,2 @@\n-    intptr_t* sender_sp = NULL;\n-    address   sender_pc = NULL;\n+    intptr_t* sender_sp = nullptr;\n+    address   sender_pc = nullptr;\n@@ -127,1 +127,1 @@\n-    if (sender_pc == NULL || sender_blob == NULL) {\n+    if (sender_pc == nullptr || sender_blob == nullptr) {\n@@ -213,1 +213,1 @@\n-  if ((address) this->fp()[return_addr_offset] == NULL) return false;\n+  if ((address) this->fp()[return_addr_offset] == nullptr) return false;\n@@ -233,1 +233,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -303,1 +303,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -311,1 +311,1 @@\n-  if (jfa->last_Java_pc() != NULL) {\n+  if (jfa->last_Java_pc() != nullptr) {\n@@ -361,2 +361,2 @@\n-  CompiledMethod* sender_cm = (_cb == NULL) ? NULL : _cb->as_compiled_method_or_null();\n-  if (sender_cm != NULL) {\n+  CompiledMethod* sender_cm = (_cb == nullptr) ? nullptr : _cb->as_compiled_method_or_null();\n+  if (sender_cm != nullptr) {\n@@ -549,1 +549,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,5 +36,5 @@\n-  _pc = NULL;\n-  _sp = NULL;\n-  _unextended_sp = NULL;\n-  _fp = NULL;\n-  _cb = NULL;\n+  _pc = nullptr;\n+  _sp = nullptr;\n+  _unextended_sp = nullptr;\n+  _fp = nullptr;\n+  _cb = nullptr;\n@@ -43,1 +43,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -56,1 +56,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -62,1 +62,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -71,1 +71,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -83,1 +83,1 @@\n-  assert(sp != NULL, \"null SP?\");\n+  assert(sp != nullptr, \"null SP?\");\n@@ -101,1 +101,1 @@\n-\/\/ identity and younger\/older relationship. NULL represents an invalid (incomparable)\n+\/\/ identity and younger\/older relationship. null represents an invalid (incomparable)\n@@ -106,1 +106,1 @@\n-inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != NULL && id != NULL, \"NULL frame id\");\n+inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != nullptr && id != nullptr, \"null frame id\");\n@@ -113,1 +113,1 @@\n-  return os::is_readable_pointer(ptr) ? *ptr : NULL;\n+  return os::is_readable_pointer(ptr) ? *ptr : nullptr;\n@@ -162,1 +162,1 @@\n-  if (last_sp == NULL ) {\n+  if (last_sp == nullptr ) {\n@@ -206,1 +206,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -212,1 +212,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -222,2 +222,2 @@\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n+  if (_cb == nullptr) return nullptr;\n+  if (_cb->oop_maps() != nullptr) {\n@@ -225,1 +225,1 @@\n-    if (nop != NULL && nop->displacement() != 0) {\n+    if (nop != nullptr && nop->displacement() != 0) {\n@@ -232,1 +232,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -274,1 +274,1 @@\n-  if (_cb != NULL) return sender_for_compiled_frame(map);\n+  if (_cb != nullptr) return sender_for_compiled_frame(map);\n@@ -281,1 +281,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -299,1 +299,1 @@\n-    if (_cb->oop_maps() != NULL) {\n+    if (_cb->oop_maps() != nullptr) {\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-  \/\/ crosses regions, storing NULL?\n+  \/\/ crosses regions, storing null?\n@@ -217,1 +217,1 @@\n-  \/\/ storing region crossing non-NULL, is card already dirty?\n+  \/\/ storing region crossing non-null, is card already dirty?\n@@ -233,1 +233,1 @@\n-  \/\/ storing a region crossing, non-NULL oop, card is clean.\n+  \/\/ storing a region crossing, non-null oop, card is clean.\n@@ -479,1 +479,1 @@\n-  \/\/ storing region crossing non-NULL, card is clean.\n+  \/\/ storing region crossing non-null, card is clean.\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,1 +209,1 @@\n-  if (bs_nm == NULL) {\n+  if (bs_nm == nullptr) {\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-define_pd_global(bool,  UncommonNullCast,         true);  \/\/ Uncommon-trap NULLs past to check cast\n+define_pd_global(bool,  UncommonNullCast,         true);  \/\/ Uncommon-trap nulls past to check cast\n","filename":"src\/hotspot\/cpu\/arm\/globals_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    stop(\"InterpreterMacroAssembler::call_VM_helper: last_sp != NULL\");\n+    stop(\"InterpreterMacroAssembler::call_VM_helper: last_sp != nullptr\");\n@@ -163,1 +163,1 @@\n-    cbz(thread_state, L); \/\/ if (thread->jvmti_thread_state() == NULL) exit;\n+    cbz(thread_state, L); \/\/ if (thread->jvmti_thread_state() == nullptr) exit;\n@@ -1031,1 +1031,1 @@\n-  \/\/ Test MDO to avoid the call if it is NULL.\n+  \/\/ Test MDO to avoid the call if it is null.\n@@ -1363,1 +1363,1 @@\n-  \/\/ observed the receiver[start_row] is NULL.\n+  \/\/ observed the receiver[start_row] is null.\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-      \/\/ NULL last_sp until next java call\n+      \/\/ null last_sp until next java call\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,1 @@\n-    *_to++ = (*(intptr_t*)from_addr == 0) ? (intptr_t)NULL : from_addr;\n+    *_to++ = (*(intptr_t*)from_addr == 0) ? (intptr_t)nullptr : from_addr;\n@@ -309,1 +309,1 @@\n-      _toGP[_last_gp++] = (*(intptr_t*)from_addr == 0) ? NULL : from_addr;\n+      _toGP[_last_gp++] = (*(intptr_t*)from_addr == 0) ? nullptr : from_addr;\n@@ -311,1 +311,1 @@\n-      *_to++ = (*(intptr_t*)from_addr == 0) ? NULL : from_addr;\n+      *_to++ = (*(intptr_t*)from_addr == 0) ? nullptr : from_addr;\n","filename":"src\/hotspot\/cpu\/arm\/interpreterRT_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    _last_Java_sp = NULL;\n+    _last_Java_sp = nullptr;\n@@ -44,2 +44,2 @@\n-    _last_Java_fp = NULL;\n-    _last_Java_pc = NULL;\n+    _last_Java_fp = nullptr;\n+    _last_Java_pc = nullptr;\n@@ -53,1 +53,1 @@\n-    \/\/ To act like previous version (pd_cache_state) don't NULL _last_Java_sp\n+    \/\/ To act like previous version (pd_cache_state) don't null _last_Java_sp\n@@ -57,1 +57,1 @@\n-      _last_Java_sp = NULL;\n+      _last_Java_sp = nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/javaFrameAnchor_arm.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-  const char* name = NULL;\n-  address slow_case_addr = NULL;\n+  const char* name = nullptr;\n+  address slow_case_addr = nullptr;\n@@ -223,1 +223,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/jniFastGetField_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/jvmciCodeInstaller_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,2 +110,2 @@\n-  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg, temp_reg2, &L_success, &L_failure, NULL);\n-  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, temp_reg2, temp_reg3, &L_success, NULL);\n+  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg, temp_reg2, &L_success, &L_failure, nullptr);\n+  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, temp_reg2, temp_reg3, &L_success, nullptr);\n@@ -128,4 +128,4 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  if (L_slow_path == NULL) { L_slow_path = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  if (L_slow_path == nullptr) { L_slow_path = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -208,3 +208,3 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -633,1 +633,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -654,1 +654,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -845,1 +845,1 @@\n-  const char* msg_buffer = NULL;\n+  const char* msg_buffer = nullptr;\n@@ -887,1 +887,1 @@\n-  const char* msg_buffer = NULL;\n+  const char* msg_buffer = nullptr;\n@@ -943,1 +943,1 @@\n-             (! (ciEnv::current()->task() == NULL)) ||\n+             (! (ciEnv::current()->task() == nullptr)) ||\n@@ -1107,1 +1107,1 @@\n-  const char* buf = NULL;\n+  const char* buf = nullptr;\n@@ -1252,1 +1252,1 @@\n-  if (counter_addr != NULL) {\n+  if (counter_addr != nullptr) {\n@@ -1289,1 +1289,1 @@\n-  cbz(value, done);           \/\/ Use NULL as-is.\n+  cbz(value, done);           \/\/ Use null as-is.\n@@ -1322,1 +1322,1 @@\n-  cbz(value, done);           \/\/ Use NULL as-is.\n+  cbz(value, done);           \/\/ Use null as-is.\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-      _target(NULL)\n+      _target(nullptr)\n@@ -288,1 +288,1 @@\n-  \/\/ One of the three labels can be NULL, meaning take the fall-through.\n+  \/\/ One of the three labels can be null, meaning take the fall-through.\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -488,2 +488,2 @@\n-  bool has_mh = (strstr(adaptername, \"\/static\") == NULL &&\n-                 strstr(adaptername, \"linkTo\") == NULL);    \/\/ static linkers don't have MH\n+  bool has_mh = (strstr(adaptername, \"\/static\") == nullptr &&\n+                 strstr(adaptername, \"linkTo\") == nullptr);    \/\/ static linkers don't have MH\n@@ -504,1 +504,1 @@\n-  if (last_sp != saved_sp && last_sp != NULL) {\n+  if (last_sp != saved_sp && last_sp != nullptr) {\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,2 +137,2 @@\n-  oop* oop_addr = NULL;\n-  Metadata** metadata_addr = NULL;\n+  oop* oop_addr = nullptr;\n+  Metadata** metadata_addr = nullptr;\n@@ -140,1 +140,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -142,1 +142,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -165,1 +165,1 @@\n-  } else if (oop_addr == NULL & metadata_addr == NULL) {\n+  } else if (oop_addr == nullptr & metadata_addr == nullptr) {\n@@ -175,1 +175,1 @@\n-    address addr = oop_addr != NULL ? (address)oop_addr : (address)metadata_addr;\n+    address addr = oop_addr != nullptr ? (address)oop_addr : (address)metadata_addr;\n@@ -306,1 +306,1 @@\n-  if (nm == NULL) {\n+  if (nm == nullptr) {\n@@ -308,1 +308,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -327,1 +327,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -331,1 +331,1 @@\n-  return (raw_call_for(return_address) != NULL);\n+  return (raw_call_for(return_address) != nullptr);\n@@ -336,1 +336,1 @@\n-  assert(call != NULL, \"must be\");\n+  assert(call != nullptr, \"must be\");\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -451,1 +451,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -467,1 +467,1 @@\n-    assert(instr != NULL, \"\");\n+    assert(instr != nullptr, \"\");\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-  \/\/ Since there is none, we just return NULL.\n+  \/\/ Since there is none, we just return null.\n@@ -37,1 +37,1 @@\n-  address pd_location(VMReg reg) const {return NULL;}\n+  address pd_location(VMReg reg) const {return nullptr;}\n","filename":"src\/hotspot\/cpu\/arm\/registerMap_arm.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  if (orig_addr != NULL) {\n+  if (orig_addr != nullptr) {\n@@ -72,1 +72,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/relocInfo_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,1 +259,1 @@\n-  assert(regs2 == NULL, \"not needed on arm\");\n+  assert(regs2 == nullptr, \"not needed on arm\");\n@@ -370,1 +370,1 @@\n-  return c_calling_convention(sig_bt, regs, NULL, total_args_passed);\n+  return c_calling_convention(sig_bt, regs, nullptr, total_args_passed);\n@@ -774,1 +774,1 @@\n-                                       (OopMapSet*)NULL);\n+                                       (OopMapSet*)nullptr);\n@@ -799,1 +799,1 @@\n-  int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);\n+  int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n@@ -878,1 +878,1 @@\n-  assert(bs != NULL, \"Sanity\");\n+  assert(bs != nullptr, \"Sanity\");\n@@ -1400,1 +1400,1 @@\n-  \/\/ Force return value to NULL to avoid confusing the escape analysis\n+  \/\/ Force return value to null to avoid confusing the escape analysis\n@@ -1737,1 +1737,1 @@\n-  _uncommon_trap_blob = UncommonTrapBlob::create(&buffer, NULL, 2 \/* LR+FP *\/);\n+  _uncommon_trap_blob = UncommonTrapBlob::create(&buffer, nullptr, 2 \/* LR+FP *\/);\n@@ -1749,1 +1749,1 @@\n-  assert(StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert(StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -1819,1 +1819,1 @@\n-  assert(StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert(StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -80,1 +80,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/smallRegisterMap_arm.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -55,1 +55,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -61,1 +61,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -67,1 +67,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/stackChunkFrameStream_arm.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -819,1 +819,1 @@\n-    __ cbz(oop, exit);                           \/\/ if obj is NULL it is ok\n+    __ cbz(oop, exit);                           \/\/ if obj is null it is ok\n@@ -833,1 +833,1 @@\n-    __ cbz(klass, error);                        \/\/ if klass is NULL it is broken\n+    __ cbz(klass, error);                        \/\/ if klass is null it is broken\n@@ -873,2 +873,2 @@\n-    assert(no_overlap_target != NULL, \"must be generated\");\n-    array_overlap_test(no_overlap_target, NULL, log2_elem_size, tmp1, tmp2);\n+    assert(no_overlap_target != nullptr, \"must be generated\");\n+    array_overlap_test(no_overlap_target, nullptr, log2_elem_size, tmp1, tmp2);\n@@ -877,1 +877,1 @@\n-    array_overlap_test(NULL, &L_no_overlap, log2_elem_size, tmp1, tmp2);\n+    array_overlap_test(nullptr, &L_no_overlap, log2_elem_size, tmp1, tmp2);\n@@ -895,1 +895,1 @@\n-    if (NOLp == NULL)\n+    if (NOLp == nullptr)\n@@ -900,1 +900,1 @@\n-    if (NOLp == NULL)\n+    if (NOLp == nullptr)\n@@ -1977,1 +1977,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2001,1 +2001,1 @@\n-  address generate_primitive_copy(bool aligned, const char * name, bool status, int bytes_per_count, bool disjoint, address nooverlap_target = NULL) {\n+  address generate_primitive_copy(bool aligned, const char * name, bool status, int bytes_per_count, bool disjoint, address nooverlap_target = nullptr) {\n@@ -2019,1 +2019,1 @@\n-      assert (nooverlap_target != NULL, \"must be specified for conjoint case\");\n+      assert (nooverlap_target != nullptr, \"must be specified for conjoint case\");\n@@ -2175,1 +2175,1 @@\n-  address generate_oop_copy(bool aligned, const char * name, bool status, bool disjoint, address nooverlap_target = NULL) {\n+  address generate_oop_copy(bool aligned, const char * name, bool status, bool disjoint, address nooverlap_target = nullptr) {\n@@ -2194,1 +2194,1 @@\n-      assert (nooverlap_target != NULL, \"must be specified for conjoint case\");\n+      assert (nooverlap_target != nullptr, \"must be specified for conjoint case\");\n@@ -2511,1 +2511,1 @@\n-    __ cbz(R5, store_element); \/\/ NULL\n+    __ cbz(R5, store_element); \/\/ null\n@@ -2643,1 +2643,1 @@\n-    \/\/ (5) src klass and dst klass should be the same and not NULL.\n+    \/\/ (5) src klass and dst klass should be the same and not null.\n@@ -2649,1 +2649,1 @@\n-    \/\/  if (src == NULL) return -1;\n+    \/\/  if (src == nullptr) return -1;\n@@ -2656,1 +2656,1 @@\n-    \/\/  if (dst == NULL) return -1;\n+    \/\/  if (dst == nullptr) return -1;\n@@ -3143,1 +3143,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n@@ -3174,1 +3174,1 @@\n-  if (UnsafeCopyMemory::_table == NULL) {\n+  if (UnsafeCopyMemory::_table == nullptr) {\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-address StubRoutines::Arm::_idiv_irem_entry = NULL;\n+address StubRoutines::Arm::_idiv_irem_entry = nullptr;\n@@ -32,1 +32,1 @@\n-address StubRoutines::Arm::_partial_subtype_check = NULL;\n+address StubRoutines::Arm::_partial_subtype_check = nullptr;\n@@ -34,2 +34,2 @@\n-address StubRoutines::_atomic_load_long_entry = NULL;\n-address StubRoutines::_atomic_store_long_entry = NULL;\n+address StubRoutines::_atomic_load_long_entry = nullptr;\n+address StubRoutines::_atomic_store_long_entry = nullptr;\n@@ -37,1 +37,1 @@\n-address StubRoutines::Arm::_method_entry_barrier = NULL;\n+address StubRoutines::Arm::_method_entry_barrier = nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutines_arm.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n+  if (!InlineIntrinsics) return nullptr; \/\/ Generate a vanilla entry\n@@ -127,1 +127,1 @@\n-  address entry_point = NULL;\n+  address entry_point = nullptr;\n@@ -184,1 +184,1 @@\n-  if (entry_point != NULL) {\n+  if (entry_point != nullptr) {\n@@ -230,1 +230,1 @@\n-    fn = NULL; \/\/ silence \"maybe uninitialized\" compiler warnings\n+    fn = nullptr; \/\/ silence \"maybe uninitialized\" compiler warnings\n@@ -310,1 +310,1 @@\n-  assert(!pass_oop || message == NULL, \"either oop or message but not both\");\n+  assert(!pass_oop || message == nullptr, \"either oop or message but not both\");\n@@ -330,1 +330,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -344,1 +344,1 @@\n-  if (!pass_oop && (message != NULL)) {\n+  if (!pass_oop && (message != nullptr)) {\n@@ -358,1 +358,1 @@\n-  \/\/ and NULL it as marker that SP is now tos until next java call\n+  \/\/ and null it as marker that SP is now tos until next java call\n@@ -392,1 +392,1 @@\n-  \/\/ The stack is not extended by deopt but we must NULL last_sp as this\n+  \/\/ The stack is not extended by deopt but we must null last_sp as this\n@@ -411,1 +411,1 @@\n-  if (continuation == NULL) {\n+  if (continuation == nullptr) {\n@@ -500,2 +500,2 @@\n-  \/\/ indicating if the counter overflow occurs at a backwards branch (non-NULL bcp).\n-  \/\/ The call returns the address of the verified entry point for the method or NULL\n+  \/\/ indicating if the counter overflow occurs at a backwards branch (non-null bcp).\n+  \/\/ The call returns the address of the verified entry point for the method or null\n@@ -760,1 +760,1 @@\n-  \/\/ Check if local 0 != NULL\n+  \/\/ Check if local 0 != nullptr\n@@ -783,3 +783,3 @@\n-address TemplateInterpreterGenerator::generate_CRC32_update_entry() { return NULL; }\n-address TemplateInterpreterGenerator::generate_CRC32_updateBytes_entry(AbstractInterpreter::MethodKind kind) { return NULL; }\n-address TemplateInterpreterGenerator::generate_CRC32C_updateBytes_entry(AbstractInterpreter::MethodKind kind) { return NULL; }\n+address TemplateInterpreterGenerator::generate_CRC32_update_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_CRC32_updateBytes_entry(AbstractInterpreter::MethodKind kind) { return nullptr; }\n+address TemplateInterpreterGenerator::generate_CRC32C_updateBytes_entry(AbstractInterpreter::MethodKind kind) { return nullptr; }\n@@ -1433,1 +1433,1 @@\n-    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.\n+    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or null.\n@@ -1624,1 +1624,1 @@\n-  assert(Interpreter::trace_code(t->tos_in()) != NULL,\n+  assert(Interpreter::trace_code(t->tos_in()) != nullptr,\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,1 @@\n-\/\/ Store an oop (or NULL) at the address described by obj.\n+\/\/ Store an oop (or null) at the address described by obj.\n@@ -465,1 +465,1 @@\n-    __ mov(result, 0);  \/\/ NULL object reference\n+    __ mov(result, 0);  \/\/ null object reference\n@@ -1227,1 +1227,1 @@\n-  \/\/ do array store check - check for NULL value first\n+  \/\/ do array store check - check for null value first\n@@ -1254,1 +1254,1 @@\n-  \/\/ Have a NULL in Rvalue_2, store NULL at array[index].\n+  \/\/ Have a null in Rvalue_2, store null at array[index].\n@@ -1258,1 +1258,1 @@\n-  \/\/ Store a NULL\n+  \/\/ Store a null\n@@ -2124,1 +2124,1 @@\n-    \/\/ R0: osr nmethod (osr ok) or NULL (osr not possible)\n+    \/\/ R0: osr nmethod (osr ok) or null (osr not possible)\n@@ -2678,1 +2678,1 @@\n-      __ mov(R1, 0);        \/\/ NULL object reference\n+      __ mov(R1, 0);        \/\/ null object reference\n@@ -2685,1 +2685,1 @@\n-    \/\/ R1: object pointer or NULL\n+    \/\/ R1: object pointer or null\n@@ -2994,1 +2994,1 @@\n-    \/\/ R1: object pointer set up above (NULL if static)\n+    \/\/ R1: object pointer set up above (null if static)\n@@ -4068,1 +4068,1 @@\n-  \/\/ Collect counts on whether this check-cast sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this check-cast sees nulls a lot or not.\n@@ -4081,2 +4081,2 @@\n-  \/\/ result = 0: obj == NULL or  obj is not an instanceof the specified klass\n-  \/\/ result = 1: obj != NULL and obj is     an instanceof the specified klass\n+  \/\/ result = 0: obj == nullptr or  obj is not an instanceof the specified klass\n+  \/\/ result = 1: obj != nullptr and obj is     an instanceof the specified klass\n@@ -4139,1 +4139,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -4214,1 +4214,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n@@ -4222,1 +4222,1 @@\n-  __ mov(Rentry, 0);                             \/\/ points to free slot or NULL\n+  __ mov(Rentry, 0);                             \/\/ points to free slot or null\n@@ -4325,1 +4325,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-  if (stub_blob == NULL) {\n+  if (stub_blob == nullptr) {\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,3 +54,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -124,3 +124,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -206,1 +206,1 @@\n-  assert(SharedRuntime::get_handle_wrong_method_stub() != NULL, \"check initialization order\");\n+  assert(SharedRuntime::get_handle_wrong_method_stub() != nullptr, \"check initialization order\");\n","filename":"src\/hotspot\/cpu\/arm\/vtableStubs_arm.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}