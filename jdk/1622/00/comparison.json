{"files":[{"patch":"@@ -147,7 +147,1 @@\n-vmTestbase\/vm\/mlvm\/meth\/func\/java\/throwException\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/deoptimize\/Test.java#id1 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/sequences\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/gc\/callSequencesDuringGC\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/java\/sequences\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/jdi\/breakpointInCompiledCode\/Test.java 8058176 generic-all\n+vmTestbase\/vm\/mlvm\/meth\/stress\/jdi\/breakpointInCompiledCode\/Test.java 8257761 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+import vm.mlvm.share.DefaultThrowableTolerance;\n+import vm.mlvm.share.Env;\n@@ -59,0 +61,1 @@\n+import vm.mlvm.share.ThrowableTolerance;\n@@ -62,1 +65,2 @@\n-    public static void main(String[] args) { MlvmTest.launch(args); }\n+    private static final ThrowableTolerance THROWABLE_TOLERANCE =\n+        DefaultThrowableTolerance.CODE_CACHE_OOME_ALLOWED;\n@@ -108,0 +112,4 @@\n+            if (THROWABLE_TOLERANCE.isAcceptable(t)) {\n+                return true;\n+            }\n+\n@@ -113,0 +121,11 @@\n+\n+    public static void main(String[] args) {\n+        Env.setThrowableTolerance(THROWABLE_TOLERANCE);\n+\n+        try {\n+            MlvmTest.launch(args);\n+        } catch (Throwable t) {\n+            THROWABLE_TOLERANCE.ignoreOrRethrow(t);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/func\/java\/throwException\/Test.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+import vm.mlvm.share.DefaultThrowableTolerance;\n@@ -170,1 +171,10 @@\n-    public static void main(String[] args) { MlvmTest.launch(args); }\n+    public static void main(String[] args) {\n+        var throwableTolerance = DefaultThrowableTolerance.CODE_CACHE_OOME_ALLOWED;\n+        Env.setThrowableTolerance(throwableTolerance);\n+\n+        try {\n+            MlvmTest.launch(args);\n+        } catch (Throwable t) {\n+            throwableTolerance.ignoreOrRethrow(t);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/deoptimize\/Test.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import vm.mlvm.share.DefaultThrowableTolerance;\n@@ -69,0 +70,3 @@\n+import vm.mlvm.share.MultiThreadedTest;\n+\n+import nsk.share.ArgumentParser;\n@@ -72,5 +76,1 @@\n-\/\/ TODO: use multi-threaded test framework\n-public class Test extends MlvmTest {\n-\n-    private static final int THREADS\n-            = Runtime.getRuntime().availableProcessors();\n+public class Test extends MultiThreadedTest {\n@@ -109,2 +109,0 @@\n-    volatile A intermediateTarget;\n-\n@@ -115,2 +113,1 @@\n-    CyclicBarrier startBarrier = new CyclicBarrier(THREADS + 1);\n-\n+    private int threadsQty;\n@@ -118,0 +115,6 @@\n+    MHMacroTF tLists[];\n+    MethodHandle mhM;\n+    Argument[] finalArgs;\n+    Argument finalRetVal;\n+    MethodHandle mhB;\n+    volatile A intermediateTarget;\n@@ -121,0 +124,2 @@\n+        threadsQty = calcThreadNum();\n+        tLists = new MHMacroTF[threadsQty - 1];\n@@ -122,1 +127,1 @@\n-        final MethodHandle mhB = MethodHandles.lookup().findVirtual(Test.class,\n+        mhB = MethodHandles.lookup().findVirtual(Test.class,\n@@ -125,1 +130,1 @@\n-        final Argument finalRetVal = Argument.fromValue(new Integer(0));\n+        finalRetVal = Argument.fromValue(new Integer(0));\n@@ -128,1 +133,1 @@\n-        this.intermediateTarget = new A(\n+        intermediateTarget = new A(\n@@ -132,1 +137,1 @@\n-        final MethodHandle mhM = MethodHandles.lookup().findVirtual(Test.class,\n+        mhM = MethodHandles.lookup().findVirtual(Test.class,\n@@ -135,26 +140,22 @@\n-        final Argument[] finalArgs = RandomArgumentsGen.createRandomArgs(true,\n-                mhM.type());\n-\n-        Thread[] threads = new Thread[THREADS];\n-        for (int t = 0; t < THREADS; t++) {\n-            (threads[t] = new Thread(\"Stresser \" + t) {\n-\n-                public void run() {\n-                    try {\n-                        MHMacroTF tList = MHTransformationGen.createSequence(\n-                                finalRetVal, Test.this, mhM, finalArgs);\n-                        Test.this.startBarrier.await();\n-                        while ( ! Test.this.testDone) {\n-                            int e = (Integer) Test.this.intermediateTarget.m();\n-                            int r = (Integer) MHTransformationGen.callSequence(\n-                                    tList, false);\n-                            if (r != e)\n-                                Env.traceNormal(\"Wrong result in thread \"\n-                                        + getName() + \", but this is OK\");\n-                        }\n-                        Env.traceVerbose(\"Thread \" + getName()+ \": work done\");\n-                    } catch (Throwable t) {\n-                        markTestFailed(\"Exception in thread \" + getName(), t);\n-                    }\n-                }\n-            }).start();\n+        finalArgs = RandomArgumentsGen.createRandomArgs(true, mhM.type());\n+\n+        return super.run();\n+    }\n+\n+    @Override\n+    protected void prepareThread(int threadNum) throws Throwable {\n+        if (isStresserThread(threadNum)) {\n+            Thread.currentThread().setName(\"Stresser \" + threadNum);\n+            tLists[threadNum] = MHTransformationGen.createSequence(\n+                    finalRetVal, Test.this, mhM, finalArgs);\n+        } else {\n+            Thread.currentThread().setName(\"Controller\");\n+        }\n+    };\n+\n+    @Override\n+    public boolean runThread(int t) throws Throwable {\n+        if (isStresserThread(t)) {\n+            runStresserThread(t);\n+        } else {\n+            runControllerThread();\n@@ -163,2 +164,18 @@\n-        this.startBarrier.await();\n-        Env.traceImportant(\"Threads started\");\n+        \/\/ It's exceptions and errors are what we're hunting for, not some\n+        \/\/ correct values. Hence always true\n+        return true;\n+    }\n+\n+    private boolean isStresserThread(int threadNum) { return threadNum < threadsQty - 1; }\n+\n+    private void runStresserThread(int t) throws Throwable {\n+        while ( ! Test.this.testDone) {\n+            int e = (Integer) Test.this.intermediateTarget.m();\n+            int r = (Integer) MHTransformationGen.callSequence(\n+                    tLists[t], false);\n+            if (r != e)\n+                Env.traceNormal(\"Wrong result in thread \"\n+                        + getName() + \", but this is OK\");\n+        }\n+        Env.traceVerbose(\"Thread \" + getName()+ \": work done\");\n+    }\n@@ -166,1 +183,3 @@\n-        Thread.sleep(3000);\n+    private void runControllerThread() {\n+        try {\n+            Env.traceImportant(\"Threads started\");\n@@ -168,4 +187,1 @@\n-        Env.traceImportant(\"Deoptimizing\");\n-        \/\/ Force deoptimization in uncommon trap logic\n-        this.intermediateTarget = (A) Test.class.getClassLoader().loadClass(\n-                Test.class.getName() + \"$B\").newInstance();\n+            Thread.sleep(3000);\n@@ -173,1 +189,4 @@\n-        Thread.sleep(3000);\n+            Env.traceImportant(\"Deoptimizing\");\n+            \/\/ Force deoptimization in uncommon trap logic\n+            this.intermediateTarget = (A) Test.class.getClassLoader().loadClass(\n+                    Test.class.getName() + \"$B\").newInstance();\n@@ -175,3 +194,5 @@\n-        this.testDone = true;\n-        for (int t = 0; t < THREADS; t++)  {\n-            threads[t].join();\n+            Thread.sleep(3000);\n+        } catch (Throwable t) {\n+            Env.getThrowableTolerance().ignoreOrRethrow(t);\n+        } finally {\n+            this.testDone = true;\n@@ -179,1 +200,0 @@\n-        return true;\n@@ -183,1 +203,13 @@\n-        MlvmTest.launch(args);\n+        var parser = new ArgumentParser(args);\n+        if (!parser.getOptions().containsKey(\"threadsPerCpu\")) {\n+            parser.setOption(\"-\", \"threadsPerCpu\", \"1\");\n+        }\n+\n+        var throwableTolerance = DefaultThrowableTolerance.CODE_CACHE_OOME_ALLOWED;\n+        Env.setThrowableTolerance(throwableTolerance);\n+\n+        try {\n+            MlvmTest.launch(parser);\n+        } catch (Throwable t) {\n+            throwableTolerance.ignoreOrRethrow(t);\n+        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java","additions":84,"deletions":52,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+import vm.mlvm.share.DefaultThrowableTolerance;\n+import vm.mlvm.share.Env;\n@@ -108,1 +110,10 @@\n-    public static void main(String[] args) { MlvmTest.launch(args); }\n+    public static void main(String[] args) {\n+        var throwableTolerance = DefaultThrowableTolerance.CODE_CACHE_OOME_ALLOWED;\n+        Env.setThrowableTolerance(throwableTolerance);\n+\n+        try {\n+            MlvmTest.launch(args);\n+        } catch (Throwable t) {\n+            throwableTolerance.ignoreOrRethrow(t);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/sequences\/Test.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+import vm.mlvm.share.DefaultThrowableTolerance;\n+import vm.mlvm.share.Env;\n@@ -68,4 +70,0 @@\n-    public static void main(String[] args) {\n-        MlvmTest.launch(args);\n-    }\n-\n@@ -142,0 +140,12 @@\n+\n+    public static void main(String[] args) {\n+        var throwableTolerance = DefaultThrowableTolerance.CODE_CACHE_OOME_ALLOWED;\n+        Env.setThrowableTolerance(throwableTolerance);\n+\n+        try {\n+            MlvmTest.launch(args);\n+        } catch (Throwable t) {\n+            throwableTolerance.ignoreOrRethrow(t);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/gc\/callSequencesDuringGC\/Test.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+import vm.mlvm.share.DefaultThrowableTolerance;\n+import vm.mlvm.share.Env;\n@@ -67,4 +69,0 @@\n-    public static void main(String[] args) {\n-        MlvmTest.launch(args);\n-    }\n-\n@@ -119,0 +117,11 @@\n+\n+    public static void main(String[] args) {\n+        var throwableTolerance = DefaultThrowableTolerance.CODE_CACHE_OOME_ALLOWED;\n+        Env.setThrowableTolerance(throwableTolerance);\n+\n+        try {\n+            MlvmTest.launch(args);\n+        } catch (Throwable t) {\n+            throwableTolerance.ignoreOrRethrow(t);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/java\/sequences\/Test.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package vm.mlvm.share;\n+\n+\/**\n+ * A collection of default implementations for {@link ThrowableTolerance}.\n+ *\/\n+public class DefaultThrowableTolerance {\n+\n+    \/**\n+     * Does not accept any Throwable\n+     *\n+     * @param ignored Added to satisfy the interface API, always ignored.\n+     * @return Always false\n+     *\/\n+    public static final ThrowableTolerance INTOLERANT = (Throwable ignored) -> { return false; };\n+\n+    \/**\n+     * Accepts only OutOfMemoryError with cause having 'Out of space' substring.\n+     *\n+     * Is useful for Code Cache depletion errors, for example. Scans the Throwable\n+     * hierarchy in search for acceptable Throwable as an underlying cause.\n+     * @param what Added to satisfy the interface API, is ignored.\n+     * @return Always false\n+     *\/\n+    public static final ThrowableTolerance CODE_CACHE_OOME_ALLOWED = (Throwable what) -> {\n+        Throwable cause = what;\n+        do {\n+            if (cause instanceof VirtualMachineError\n+                    && cause.getMessage().matches(\".*[Oo]ut of space.*\")) {\n+                return true;\n+            }\n+            cause = cause != null ? cause.getCause() : null;\n+        } while (cause != null && cause != what);\n+        return false;\n+    };\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/DefaultThrowableTolerance.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+        public static ThrowableTolerance throwableTolerance = DefaultThrowableTolerance.INTOLERANT;\n@@ -53,0 +54,8 @@\n+    public static ThrowableTolerance getThrowableTolerance() {\n+        return StaticHolder.throwableTolerance;\n+    }\n+\n+    public static void setThrowableTolerance(ThrowableTolerance to) {\n+        StaticHolder.throwableTolerance = to;\n+    }\n+\n@@ -172,1 +181,3 @@\n-        getLog().complain(new LazyFormatString(msg, args), t);\n+        if (!StaticHolder.throwableTolerance.isAcceptable(t)) {\n+           getLog().complain(new LazyFormatString(msg, args), t);\n+        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/Env.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-                if (expectedExceptions.size() == 0) {\n+                try {\n@@ -383,3 +383,1 @@\n-                } else {\n-                    try {\n-                        instance.run();\n+                    if (!expectedExceptions.isEmpty()) {\n@@ -388,7 +386,7 @@\n-                    } catch (Throwable e) {\n-                        if (checkExpectedException(expectedExceptions, e)) {\n-                            instancePassed = true;\n-                        } else {\n-                            Env.complain(e, \"Expected exceptions: \" + expectedExceptions + \", but caught: \");\n-                            instancePassed = false;\n-                        }\n+                    }\n+                } catch (Throwable t) {\n+                    if (checkExpectedException(expectedExceptions, t)) {\n+                        instancePassed = true;\n+                    } else {\n+                        Env.complain(t, \"Expected exceptions: \" + expectedExceptions + \", but caught: \");\n+                        instancePassed = false;\n@@ -471,1 +469,1 @@\n-        return false;\n+        return Env.getThrowableTolerance().isAcceptable(caught);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/MlvmTestExecutor.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    protected void prepareThread(int threadNum) throws Throwable { };\n@@ -69,0 +70,1 @@\n+                boolean needToTriggerBarrier = true;\n@@ -70,0 +72,1 @@\n+                    prepareThread(ii);\n@@ -71,0 +74,1 @@\n+                    needToTriggerBarrier = false;\n@@ -78,2 +82,11 @@\n-                    Env.complain(e, \"Caught exception in %s\",\n-                            Thread.currentThread());\n+                    if (Env.getThrowableTolerance().isAcceptable(e)) {\n+                        passed = true;\n+                        if (needToTriggerBarrier) try {\n+                            startBarrier.await();\n+                        } catch (Throwable tt) {\n+                            Env.getThrowableTolerance().ignoreOrRethrow(tt);\n+                        }\n+                    } else {\n+                        Env.complain(e, \"Caught exception in %s\",\n+                                Thread.currentThread());\n+                    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/MultiThreadedTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package vm.mlvm.share;\n+\n+\/**\n+ * A utility interface for allowing to control ignored or acceptable exceptions\n+ *\/\n+public interface ThrowableTolerance {\n+\n+    \/**\n+     * Checks if passed Throwable is acceptable.\n+     * @param what Exception to check\n+     * @return Whether the exception is acceptable or not.\n+     *\/\n+    boolean isAcceptable(Throwable what);\n+\n+    \/**\n+     * Checks if passed Throwable is acceptable and ignores it, or rethrows otherwise.\n+     * @param what Exception to check\n+     *\/\n+    default void ignoreOrRethrow(Throwable what) {\n+        if (!isAcceptable(what)) {\n+            Env.throwAsUncheckedException(what); \/\/ Report inacceptable exception\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/ThrowableTolerance.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}