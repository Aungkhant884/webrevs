{"files":[{"patch":"@@ -329,1 +329,1 @@\n-    if (!CompilationModeFlag::disable_intermediate() && TieredStopAtLevel == CompLevel_full_optimization && level != CompLevel_full_optimization)  {\n+    if (CompilerConfig::is_tiered() && !CompilationModeFlag::disable_intermediate() && is_c1_compile(level))  {\n@@ -512,0 +512,11 @@\n+  if (TieredCompilation && level > TieredStopAtLevel) {\n+    return false;\n+  }\n+  \/\/ Check if there is a compiler to process the requested level\n+  if (!CompilerConfig::is_c1_enabled() && is_c1_compile(level)) {\n+    return false;\n+  }\n+  if (!CompilerConfig::is_c2_or_jvmci_compiler_enabled() && is_c2_compile(level)) {\n+    return false;\n+  }\n+\n@@ -531,1 +542,2 @@\n-  CompLevel max_level = CompLevel_none;\n+  CompLevel level = CompLevel_none;\n+  \/\/ Setup the maximum level availible for the current compiler configuration.\n@@ -534,1 +546,1 @@\n-      max_level = CompLevel_full_optimization;\n+      level = CompLevel_full_optimization;\n@@ -537,1 +549,1 @@\n-        max_level = CompLevel_simple;\n+        level = CompLevel_simple;\n@@ -539,1 +551,1 @@\n-        max_level = CompLevel_full_profile;\n+        level = CompLevel_full_profile;\n@@ -542,12 +554,0 @@\n-    max_level = MAX2(max_level, (CompLevel) TieredStopAtLevel);\n-  }\n-  return max_level;\n-}\n-\n-CompLevel CompilationPolicy::limit_level(CompLevel level) {\n-  if (CompilationModeFlag::quick_only()) {\n-    level = MIN2(level, CompLevel_simple);\n-  }\n-  assert(verify_level(level), \"Invalid compilation level %d\", level);\n-  if (level <= TieredStopAtLevel) {\n-    return level;\n@@ -555,11 +555,3 @@\n-  \/\/ Some compilation levels are not valid depending on a compilation mode:\n-  \/\/ a) quick_only - levels 2,3,4 are invalid; levels -1,0,1 are valid;\n-  \/\/ b) high_only - levels 1,2,3 are invalid; levels -1,0,4 are valid;\n-  \/\/ c) high_only_quick_internal - levels 2,3 are invalid; levels -1,0,1,4 are valid.\n-  \/\/ The invalid levels are actually sequential so a single comparison is sufficient.\n-  \/\/ Down here we already have (level > TieredStopAtLevel), which also implies that\n-  \/\/ (TieredStopAtLevel < Highest Possible Level), so we need to return a level that is:\n-  \/\/ a) a max level that is strictly less than the highest for a given compilation mode\n-  \/\/ b) less or equal to TieredStopAtLevel\n-  if (CompilationModeFlag::normal() || CompilationModeFlag::quick_only()) {\n-    return (CompLevel)TieredStopAtLevel;\n+  \/\/ Clamp the maximum level with TieredStopAtLevel.\n+  if (TieredCompilation) {\n+    level = MIN2(level, (CompLevel) TieredStopAtLevel);\n@@ -568,2 +560,20 @@\n-  if (CompilationModeFlag::high_only() || CompilationModeFlag::high_only_quick_internal()) {\n-    return MIN2(CompLevel_none, (CompLevel)TieredStopAtLevel);\n+  \/\/ Fix it up if after the clamping it has become invalid.\n+  \/\/ Bring it monotonically down depending on the next available level for\n+  \/\/ the compilation mode.\n+  if (!CompilationModeFlag::normal()) {\n+    \/\/ a) quick_only - levels 2,3,4 are invalid; levels -1,0,1 are valid;\n+    \/\/ b) high_only - levels 1,2,3 are invalid; levels -1,0,4 are valid;\n+    \/\/ c) high_only_quick_internal - levels 2,3 are invalid; levels -1,0,1,4 are valid.\n+    if (CompilationModeFlag::quick_only()) {\n+      if (level == CompLevel_limited_profile || level == CompLevel_full_profile || level == CompLevel_full_optimization) {\n+        level = CompLevel_simple;\n+      }\n+    } else if (CompilationModeFlag::high_only()) {\n+      if (level == CompLevel_simple || level == CompLevel_limited_profile || level == CompLevel_full_profile) {\n+        level = CompLevel_none;\n+      }\n+    } else if (CompilationModeFlag::high_only_quick_internal()) {\n+      if (level == CompLevel_limited_profile || level == CompLevel_full_profile) {\n+        level = CompLevel_simple;\n+      }\n+    }\n@@ -572,2 +582,8 @@\n-  ShouldNotReachHere();\n-  return CompLevel_any;\n+  assert(verify_level(level), \"Invalid highest compilation level: %d\", level);\n+  return level;\n+}\n+\n+CompLevel CompilationPolicy::limit_level(CompLevel level) {\n+  level = MIN2(level, highest_compile_level());\n+  assert(verify_level(level), \"Invalid compilation level: %d\", level);\n+  return level;\n@@ -743,1 +759,1 @@\n-  assert(verify_level(level) && level <= TieredStopAtLevel, \"Invalid compilation level %d\", level);\n+  assert(verify_level(level), \"Invalid compilation level requested: %d\", level);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":49,"deletions":33,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-      const bool tiered_degraded_to_c1_only = TieredStopAtLevel >= CompLevel_simple && TieredStopAtLevel < CompLevel_full_optimization;\n+      const bool tiered_degraded_to_c1_only = TieredCompilation && TieredStopAtLevel >= CompLevel_simple && TieredStopAtLevel < CompLevel_full_optimization;\n@@ -180,1 +180,1 @@\n-      const bool tiered_degraded_to_level_1 = TieredStopAtLevel == CompLevel_simple;\n+      const bool tiered_degraded_to_level_1 = TieredCompilation && TieredStopAtLevel == CompLevel_simple;\n@@ -182,1 +182,2 @@\n-      return tiered_degraded_to_level_1 || c1_only_compilation_mode;\n+      const bool tiered_off = !TieredCompilation;\n+      return tiered_degraded_to_level_1 || c1_only_compilation_mode || tiered_off;\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestEnqueueMethodForCompilation\n+ * @summary If TieredCompilation is disabled, TieredStopAtLevel should have no effect.\n+ * @requires vm.flavor == \"server\"\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:TieredStopAtLevel=1 -XX:-TieredCompilation\n+ *                   compiler.tiered.TestEnqueueMethodForCompilation\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:TieredStopAtLevel=2 -XX:-TieredCompilation\n+ *                   compiler.tiered.TestEnqueueMethodForCompilation\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:TieredStopAtLevel=3 -XX:-TieredCompilation\n+ *                   compiler.tiered.TestEnqueueMethodForCompilation\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:TieredStopAtLevel=4 -XX:-TieredCompilation\n+ *                   compiler.tiered.TestEnqueueMethodForCompilation\n+ *\/\n+\n+package compiler.tiered;\n+\n+import java.lang.reflect.Method;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class TestEnqueueMethodForCompilation {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public void test() { }\n+\n+    public static void main(String[] args) throws Exception {\n+        Method method = TestEnqueueMethodForCompilation.class.getMethod(\"test\");\n+        boolean success = WHITE_BOX.enqueueMethodForCompilation(method, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!success) {\n+            throw new RuntimeException(\"Method could not be enqueued for compilation at level \" + CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/tiered\/TestEnqueueMethodForCompilation.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}