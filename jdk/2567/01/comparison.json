{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -348,2 +348,4 @@\n-  AutoJavaString objectName_cstr(env, objectName);\n-  CHECK_EXCEPTION_(0);\n+  \/\/ Note, objectName is ignored, and may in fact be NULL.\n+  \/\/ lookup_symbol will always search all objects\/libs\n+  \/\/AutoJavaString objectName_cstr(env, objectName);\n+  \/\/CHECK_EXCEPTION_(0);\n@@ -353,1 +355,1 @@\n-  addr = (jlong) lookup_symbol(ph, objectName_cstr, symbolName_cstr);\n+  addr = (jlong) lookup_symbol(ph, NULL, symbolName_cstr);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/LinuxDebuggerLocal.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,2 @@\n+import sun.jvm.hotspot.debugger.cdbg.CDebugger;\n+import sun.jvm.hotspot.debugger.cdbg.LoadObject;\n@@ -610,0 +612,34 @@\n+        new Command(\"findsym\", \"findsym name\", false) {\n+            public void doit(Tokens t) {\n+                if (t.countTokens() != 1) {\n+                    usage();\n+                } else {\n+                    String symbol = t.nextToken();\n+                    Address addr = VM.getVM().getDebugger().lookup(null, symbol);\n+                    if (addr == null && VM.getVM().getDebugger().getOS().equals(\"win32\")) {\n+                        \/\/ On win32 symbols are prefixed with the dll name. Do the user\n+                        \/\/ a favor and see if this is a symbol in jvm.dll or java.dll.\n+                        addr = VM.getVM().getDebugger().lookup(null, \"jvm!\" + symbol);\n+                        if (addr == null) {\n+                            addr = VM.getVM().getDebugger().lookup(null, \"java!\" + symbol);\n+                        }\n+                    }\n+                    if (addr == null) {\n+                        out.println(\"Symbol not found\");\n+                        return;\n+                    }\n+                    out.print(addr);  \/\/ Print the address of the symbol.\n+                    CDebugger cdbg = VM.getVM().getDebugger().getCDebugger();\n+                    LoadObject loadObject = cdbg.loadObjectContainingPC(addr);\n+                    \/\/ Print the shared library path and the offset of the symbol.\n+                    if (loadObject != null) {\n+                        out.print(\": \" + loadObject.getName());\n+                        long diff = addr.minus(loadObject.getBase());\n+                        if (diff != 0L) {\n+                            out.print(\" + 0x\" + Long.toHexString(diff));\n+                        }\n+                    }\n+                    out.println();\n+                }\n+            }\n+        },\n@@ -895,1 +931,1 @@\n-            \/\/ Do a full dump of the nodes reachabile from root in each compiler thread.\n+            \/\/ Do a full dump of the nodes reachable from root in each compiler thread.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+            String linesep = System.getProperty(\"line.separator\");\n@@ -221,1 +222,1 @@\n-            String value = parts[1];\n+            String value = parts[1].split(linesep)[0];\n@@ -232,1 +233,1 @@\n-                } else { \/\/ symbol lookups not supported with OSX live process\n+                } else { \/\/ address -> symbol lookups not supported with OSX live process\n@@ -238,1 +239,37 @@\n-            runTest(withCore, cmds, expStrMap);\n+            String findpcOutput = runTest(withCore, cmds, expStrMap);\n+\n+            \/\/ Determine if we have symbol support. Currently we assume yes except on windows.\n+            boolean hasSymbols = true;\n+            if (Platform.isWindows()) {\n+                if (findpcOutput.indexOf(\"jvm!JavaThread::`vftable'\") == -1) {\n+                    hasSymbols = false;\n+                }\n+            }\n+\n+            \/\/ Run \"findsym MaxJNILocalCapacity\". The output should look something like:\n+            \/\/   0x00007eff8e1a0da0: <jdk-dir>\/lib\/server\/libjvm.so + 0x1d81da0\n+            String symbol = \"MaxJNILocalCapacity\";\n+            cmds = List.of(\"findsym \" + symbol);\n+            expStrMap = new HashMap<>();\n+            if (!hasSymbols) {\n+                expStrMap.put(cmdStr, List.of(\"Symbol not found\"));\n+            }\n+            String findsymOutput = runTest(withCore, cmds, expStrMap);\n+            \/\/ Run findpc on the result of \"findsym MaxJNILocalCapacity\". The output\n+            \/\/ should look something like:\n+            \/\/   Address 0x00007eff8e1a0da0: MaxJNILocalCapacity\n+            if (hasSymbols) {\n+                parts = findsymOutput.split(\"findsym \" + symbol + linesep);\n+                parts = parts[1].split(\":\");\n+                String findsymAddress = parts[0].split(linesep)[0];\n+                cmdStr = \"findpc \" + findsymAddress;\n+                cmds = List.of(cmdStr);\n+                expStrMap = new HashMap<>();\n+                if (Platform.isOSX() && !withCore) {\n+                    \/\/ address -> symbol lookups not supported with OSX live process\n+                    expStrMap.put(cmdStr, List.of(\"Address \" + findsymAddress + \": In unknown location\"));\n+                } else {\n+                    expStrMap.put(cmdStr, List.of(\"Address \" + findsymAddress + \": .*\" + symbol));\n+                }\n+                runTest(withCore, cmds, expStrMap);\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"}]}