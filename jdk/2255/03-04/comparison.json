{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -43,1 +42,1 @@\n- *  . maximum size. Replacements are made in FIFO order.\n+ *  . maximum size. Replacements are made in LRU order.\n@@ -252,0 +251,1 @@\n+    private long nextExpirationTime = Long.MAX_VALUE;\n@@ -263,1 +263,1 @@\n-        this.lifetime = TimeUnit.SECONDS.toNanos(lifetime);\n+        this.lifetime = lifetime * 1000;\n@@ -269,1 +269,1 @@\n-        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, false);\n+        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, true);\n@@ -291,0 +291,4 @@\n+            if (key == null) {\n+                \/\/ key is null, entry has already been removed\n+                continue;\n+            }\n@@ -308,1 +312,1 @@\n-     * Scan entries and remove expired ones.\n+     * Scan all entries and remove all expired ones.\n@@ -316,1 +320,5 @@\n-        long time = System.nanoTime();\n+        long time = System.currentTimeMillis();\n+        if (nextExpirationTime > time) {\n+            return;\n+        }\n+        nextExpirationTime = Long.MAX_VALUE;\n@@ -320,1 +328,1 @@\n-            if (entry.isValid(time, lifetime) == false) {\n+            if (entry.isValid(time) == false) {\n@@ -323,2 +331,2 @@\n-            } else {\n-                break;\n+            } else if (nextExpirationTime > entry.getExpirationTime()) {\n+                nextExpirationTime = entry.getExpirationTime();\n@@ -341,1 +349,0 @@\n-        cacheMap.clear();\n@@ -343,0 +350,5 @@\n+            \/\/ if this is a SoftReference cache, first invalidate() all\n+            \/\/ entries so that GC does not have to enqueue them\n+            for (CacheEntry<K,V> entry : cacheMap.values()) {\n+                entry.invalidate();\n+            }\n@@ -347,0 +359,1 @@\n+        cacheMap.clear();\n@@ -350,3 +363,7 @@\n-        expungeExpiredEntries();\n-        long insertionTime = System.nanoTime();\n-        CacheEntry<K,V> newEntry = newEntry(key, value, insertionTime, queue);\n+        emptyQueue();\n+        long expirationTime = (lifetime == 0) ? 0 :\n+                                        System.currentTimeMillis() + lifetime;\n+        if (expirationTime < nextExpirationTime) {\n+            nextExpirationTime = expirationTime;\n+        }\n+        CacheEntry<K,V> newEntry = newEntry(key, value, expirationTime, queue);\n@@ -355,0 +372,1 @@\n+            oldEntry.invalidate();\n@@ -358,5 +376,10 @@\n-            Iterator<CacheEntry<K,V>> t = cacheMap.values().iterator();\n-            CacheEntry<K,V> lruEntry = t.next();\n-            if (DEBUG) {\n-                System.out.println(\"** Overflow removal \"\n-                    + lruEntry.getKey() + \" | \" + lruEntry.getValue());\n+            expungeExpiredEntries();\n+            if (cacheMap.size() > maxSize) { \/\/ still too large?\n+                Iterator<CacheEntry<K,V>> t = cacheMap.values().iterator();\n+                CacheEntry<K,V> lruEntry = t.next();\n+                if (DEBUG) {\n+                    System.out.println(\"** Overflow removal \"\n+                        + lruEntry.getKey() + \" | \" + lruEntry.getValue());\n+                }\n+                t.remove();\n+                lruEntry.invalidate();\n@@ -364,1 +387,0 @@\n-            t.remove();\n@@ -374,1 +396,2 @@\n-        if (entry.isValid(System.nanoTime(), lifetime) == false) {\n+        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+        if (entry.isValid(time) == false) {\n@@ -386,1 +409,4 @@\n-        cacheMap.remove(key);\n+        CacheEntry<K,V> entry = cacheMap.remove(key);\n+        if (entry != null) {\n+            entry.invalidate();\n+        }\n@@ -400,0 +426,1 @@\n+                lruEntry.invalidate();\n@@ -412,1 +439,1 @@\n-        lifetime = timeout > 0 ? TimeUnit.SECONDS.toNanos(timeout) : 0L;\n+        lifetime = timeout > 0 ? timeout * 1000L : 0L;\n@@ -438,1 +465,1 @@\n-            long insertionTime, ReferenceQueue<V> queue) {\n+            long expirationTime, ReferenceQueue<V> queue) {\n@@ -440,1 +467,1 @@\n-            return new SoftCacheEntry<>(key, value, insertionTime, queue);\n+            return new SoftCacheEntry<>(key, value, expirationTime, queue);\n@@ -442,1 +469,1 @@\n-            return new HardCacheEntry<>(key, value, insertionTime);\n+            return new HardCacheEntry<>(key, value, expirationTime);\n@@ -448,1 +475,3 @@\n-        boolean isValid(long currentTime, long lifetime);\n+        boolean isValid(long currentTime);\n+\n+        void invalidate();\n@@ -454,0 +483,1 @@\n+        long getExpirationTime();\n@@ -460,1 +490,1 @@\n-        private long insertionTime;\n+        private long expirationTime;\n@@ -462,1 +492,1 @@\n-        HardCacheEntry(K key, V value, long insertionTime) {\n+        HardCacheEntry(K key, V value, long expirationTime) {\n@@ -465,1 +495,1 @@\n-            this.insertionTime = insertionTime;\n+            this.expirationTime = expirationTime;\n@@ -476,2 +506,9 @@\n-        public boolean isValid(long currentTime, long lifetime) {\n-            boolean valid = (lifetime == 0) || (currentTime - insertionTime <= lifetime);\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime);\n+            if (valid == false) {\n+                invalidate();\n+            }\n@@ -480,0 +517,6 @@\n+\n+        public void invalidate() {\n+            key = null;\n+            value = null;\n+            expirationTime = -1;\n+        }\n@@ -487,1 +530,1 @@\n-        private long insertionTime;\n+        private long expirationTime;\n@@ -489,1 +532,1 @@\n-        SoftCacheEntry(K key, V value, long insertionTime,\n+        SoftCacheEntry(K key, V value, long expirationTime,\n@@ -493,1 +536,1 @@\n-            this.insertionTime = insertionTime;\n+            this.expirationTime = expirationTime;\n@@ -504,2 +547,9 @@\n-        public boolean isValid(long currentTime, long lifetime) {\n-            boolean valid = ((lifetime == 0) || (currentTime - insertionTime <= lifetime)) && (get() != null);\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime) && (get() != null);\n+            if (valid == false) {\n+                invalidate();\n+            }\n@@ -508,0 +558,6 @@\n+\n+        public void invalidate() {\n+            clear();\n+            key = null;\n+            expirationTime = -1;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":93,"deletions":37,"binary":false,"changes":130,"status":"modified"}]}