{"files":[{"patch":"@@ -630,1 +630,1 @@\n-  MemJFRReporter::sendTypeEvents();\n+  MemJFRReporter::send_type_events();\n@@ -634,1 +634,1 @@\n-  MemJFRReporter::sendTotalEvent();\n+  MemJFRReporter::send_total_event();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"services\/memReporter.hpp\"\n+#include \"services\/memSnapshot.hpp\"\n@@ -33,2 +33,2 @@\n-Ticks MemJFRBaseline::_baseline_timestamp;\n-MemBaseline MemJFRBaseline::_baseline;\n+Ticks MemJFRSnapshot::_snapshot_timestamp;\n+MemSnapshot* MemJFRSnapshot::_snapshot = nullptr;\n@@ -36,7 +36,9 @@\n-MemBaseline& MemJFRBaseline::getBaseline() {\n-  Tickspan since_baselined = Ticks::now() - _baseline_timestamp;\n-  if (since_baselined.milliseconds() > BaselineAgeThreshold ||\n-      _baseline.baseline_type() == MemBaseline::Not_baselined) {\n-    \/\/ Summary only baseline.\n-    _baseline.baseline(true);\n-    _baseline_timestamp.stamp();\n+MemSnapshot* MemJFRSnapshot::get_snapshot() {\n+  Tickspan since_baselined = Ticks::now() - _snapshot_timestamp;\n+\n+  if (_snapshot == nullptr) {\n+    \/\/ No previous snapshot taken, create one.\n+    _snapshot = new MemSnapshot(MemSnapshot::OptionsNoTS);\n+  } else if (since_baselined.milliseconds() < BaselineAgeThreshold) {\n+    \/\/ There is a recent enough snapshot, return it.\n+    return _snapshot;\n@@ -45,1 +47,5 @@\n-  return _baseline;\n+  \/\/ Refresh existing snapshot.\n+  _snapshot->snap();\n+  _snapshot_timestamp.stamp();\n+\n+  return _snapshot;\n@@ -48,2 +54,2 @@\n-Ticks MemJFRBaseline::getTimestamp() {\n-  return _baseline_timestamp;\n+Ticks MemJFRSnapshot::get_timestamp() {\n+  return _snapshot_timestamp;\n@@ -52,1 +58,1 @@\n-void MemJFRReporter::sendTotalEvent() {\n+void MemJFRReporter::send_total_event() {\n@@ -57,9 +63,2 @@\n-  MemBaseline& usage = MemJFRBaseline::getBaseline();\n-  Ticks timestamp = MemJFRBaseline::getTimestamp();\n-\n-  const size_t malloced_memory = usage.malloc_memory_snapshot()->total();\n-  const size_t reserved_memory = usage.virtual_memory_snapshot()->total_reserved();\n-  const size_t committed_memory = usage.virtual_memory_snapshot()->total_committed();\n-\n-  const size_t reserved = malloced_memory + reserved_memory;\n-  const size_t committed = malloced_memory + committed_memory;\n+  MemSnapshot* usage = MemJFRSnapshot::get_snapshot();\n+  Ticks timestamp = MemJFRSnapshot::get_timestamp();\n@@ -69,2 +68,2 @@\n-  event.set_reserved(reserved);\n-  event.set_committed(committed);\n+  event.set_reserved(usage->total_reserved());\n+  event.set_committed(usage->total_committed());\n@@ -74,1 +73,1 @@\n-void MemJFRReporter::sendTypeEvent(const Ticks& starttime, const char* type, size_t reserved, size_t committed) {\n+void MemJFRReporter::send_type_event(const Ticks& starttime, const char* type, size_t reserved, size_t committed) {\n@@ -83,1 +82,1 @@\n-void MemJFRReporter::sendTypeEvents() {\n+void MemJFRReporter::send_type_events() {\n@@ -88,2 +87,2 @@\n-  MemBaseline& usage = MemJFRBaseline::getBaseline();\n-  Ticks timestamp = MemJFRBaseline::getTimestamp();\n+  MemSnapshot* usage = MemJFRSnapshot::get_snapshot();\n+  Ticks timestamp = MemJFRSnapshot::get_timestamp();\n@@ -93,22 +92,3 @@\n-    MallocMemory* malloc_memory = usage.malloc_memory(flag);\n-    VirtualMemory* virtual_memory = usage.virtual_memory(flag);\n-\n-    size_t reserved = MemReporterBase::reserved_total(malloc_memory, virtual_memory);\n-    size_t committed = MemReporterBase::committed_total(malloc_memory, virtual_memory);\n-\n-    \/\/ Some special cases to get accounting correct\n-    if (flag == mtThread) {\n-      \/\/ Count thread's native stack in \"Thread\" category\n-      if (ThreadStackTracker::track_as_vm()) {\n-        VirtualMemory* thread_stack_usage = usage.virtual_memory(mtThreadStack);\n-        reserved += thread_stack_usage->reserved();\n-        committed += thread_stack_usage->committed();\n-      } else {\n-        MallocMemory* thread_stack_usage = usage.malloc_memory(mtThreadStack);\n-        reserved += thread_stack_usage->malloc_size();\n-        committed += thread_stack_usage->malloc_size();\n-      }\n-    } else if (flag == mtNMT) {\n-      \/\/ Count malloc headers in \"NMT\" category\n-      reserved += usage.malloc_memory_snapshot()->malloc_overhead();\n-      committed += usage.malloc_memory_snapshot()->malloc_overhead();\n+    if (flag == mtNone) {\n+      \/\/ Skip mtNone since it is not really used.\n+      continue;\n@@ -116,1 +96,1 @@\n-    sendTypeEvent(timestamp, NMTUtil::flag_to_name(flag), reserved, committed);\n+    send_type_event(timestamp, NMTUtil::flag_to_name(flag), usage->reserved(flag), usage->committed(flag));\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.cpp","additions":32,"deletions":52,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"services\/memBaseline.hpp\"\n+#include \"services\/memSnapshot.hpp\"\n@@ -37,1 +37,1 @@\n-  static void sendTypeEvent(const Ticks& starttime, const char* tag, size_t reserved, size_t committed);\n+  static void send_type_event(const Ticks& starttime, const char* tag, size_t reserved, size_t committed);\n@@ -39,2 +39,2 @@\n-  static void sendTotalEvent();\n-  static void sendTypeEvents();\n+  static void send_total_event();\n+  static void send_type_events();\n@@ -45,1 +45,1 @@\n-class MemJFRBaseline : public AllStatic {\n+class MemJFRSnapshot : public AllStatic {\n@@ -51,2 +51,2 @@\n-  static Ticks _baseline_timestamp;\n-  static MemBaseline _baseline;\n+  static Ticks _snapshot_timestamp;\n+  static MemSnapshot* _snapshot;\n@@ -55,2 +55,2 @@\n-  static MemBaseline& getBaseline();\n-  static Ticks getTimestamp();\n+  static MemSnapshot* get_snapshot();\n+  static Ticks get_timestamp();\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/threadCritical.hpp\"\n+#include \"services\/memSnapshot.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"services\/threadStackTracker.hpp\"\n+#include \"services\/virtualMemoryTracker.hpp\"\n+\n+\/\/ Enabled all options for snapshot.\n+const MemSnapshotOptions MemSnapshot::OptionsAll = { true, true, true };\n+\/\/ Skip expensive thread stacks for snapshot.\n+const MemSnapshotOptions MemSnapshot::OptionsNoTS = { false, true, true };\n+\n+MemSnapshot::MemSnapshot(MemSnapshotOptions options) :\n+    _malloc_snapshot(),\n+    _malloc_total(),\n+    _vm_snapshot(),\n+    _vm_total(),\n+    _snapshot_options(options) { }\n+\n+void MemSnapshot::walk_thread_stacks() {\n+  \/\/ If backed by virtual memory, snapping the thread stacks involves walking\n+  \/\/ them to to figure out how much memory is committed if they are backed by\n+  \/\/ virtual memory. This needs ot happen before we take the snapshot of the\n+  \/\/ virtual memory since it will update this information.\n+  if (ThreadStackTracker::track_as_vm()) {\n+    VirtualMemoryTracker::snapshot_thread_stacks();\n+  }\n+}\n+\n+void MemSnapshot::update_malloc_snapshot() {\n+  \/\/ Thread critical needed keep values in sync, total area size\n+  \/\/ is deducted from mtChunk in the end to give correct values.\n+  ThreadCritical tc;\n+  MallocMemorySnapshot* ms = MallocMemorySummary::as_snapshot();\n+\n+  size_t total_arena_size = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    MallocMemory* mm = ms->by_type(flag);\n+    _malloc_snapshot[i] = mm->malloc_size() + mm->arena_size();\n+    total_arena_size +=  mm->arena_size();\n+  }\n+  assert(total_arena_size == ms->total_arena(), \"Mismatch in accounting\");\n+\n+  \/\/ Total malloc size.\n+  _malloc_total = ms->total();\n+\n+  \/\/ Adjustment due to mtChunk double counting.\n+  _malloc_snapshot[NMTUtil::flag_to_index(mtChunk)] -= total_arena_size;\n+  _malloc_total -= total_arena_size;\n+\n+  \/\/ Adjust mtNMT to include malloc overhead.\n+  _malloc_snapshot[NMTUtil::flag_to_index(mtNMT)] += ms->malloc_overhead();\n+}\n+\n+void MemSnapshot::update_vm_snapshot() {\n+  VirtualMemorySnapshot* vms = VirtualMemorySummary::as_snapshot();\n+\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    VirtualMemory* vm = vms->by_type(flag);\n+    _vm_snapshot[i].reserved = vm->reserved();\n+    _vm_snapshot[i].committed = vm->committed();\n+  }\n+\n+  \/\/ Total virtual memory size.\n+  _vm_total.reserved = vms->total_reserved();\n+  _vm_total.committed = vms->total_committed();\n+}\n+\n+void MemSnapshot::snap() {\n+  if (_snapshot_options.update_thread_stacks) {\n+    walk_thread_stacks();\n+  }\n+\n+  if (_snapshot_options.include_malloc) {\n+    update_malloc_snapshot();\n+  }\n+\n+  if (_snapshot_options.include_vm) {\n+    update_vm_snapshot();\n+  }\n+}\n+\n+size_t MemSnapshot::total_reserved() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t MemSnapshot::total_committed() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t MemSnapshot::reserved(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_snapshot[index] + _vm_snapshot[index].reserved;\n+}\n+\n+size_t MemSnapshot::committed(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_snapshot[index] + _vm_snapshot[index].committed;\n+}\n","filename":"src\/hotspot\/share\/services\/memSnapshot.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMSNAPSHOT_HPP\n+#define SHARE_SERVICES_MEMSNAPSHOT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+struct MemSnapshotPair {\n+  size_t reserved;\n+  size_t committed;\n+};\n+\n+struct MemSnapshotOptions {\n+  bool update_thread_stacks;\n+  bool include_malloc;\n+  bool include_vm;\n+};\n+\n+class MemSnapshot : public CHeapObj<mtNMT> {\n+private:\n+  size_t _malloc_snapshot[mt_number_of_types];\n+  size_t _malloc_total;\n+  MemSnapshotPair _vm_snapshot[mt_number_of_types];\n+  MemSnapshotPair _vm_total;\n+\n+  MemSnapshotOptions _snapshot_options;\n+\n+  void walk_thread_stacks();\n+  void update_malloc_snapshot();\n+  void update_vm_snapshot();\n+\n+public:\n+  static const MemSnapshotOptions OptionsAll;\n+  static const MemSnapshotOptions OptionsNoTS;\n+\n+  MemSnapshot(MemSnapshotOptions options = OptionsAll);\n+  void snap();\n+\n+  size_t total_reserved() const;\n+  size_t total_committed() const;\n+  size_t reserved(MEMFLAGS flag) const;\n+  size_t committed(MEMFLAGS flag) const;\n+};\n+\n+#endif \/\/ SHARE_SERVICES_MEMSNAPSHOT_HPP\n","filename":"src\/hotspot\/share\/services\/memSnapshot.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}