{"files":[{"patch":"@@ -709,0 +709,13 @@\n+  <Event name=\"NativeMemoryUsagePart\" category=\"Java Virtual Machine, Memory\" label=\"Component Native Memory Usage\" description=\"Native memory usage for a component\" stackTrace=\"false\" thread=\"false\"\n+    startTime=\"false\" period=\"everyChunk\">\n+    <Field type=\"string\" name=\"type\" label=\"Memory Type\" description=\"Component allocating the native memory\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Reserved bytes by this component\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Committed bytes by this component\" \/>\n+  <\/Event>\n+\n+  <Event name=\"NativeMemoryUsage\" category=\"Java Virtual Machine, Memory\" label=\"Total Native Memory Usage\" description=\"Total Native Memory Usage\" stackTrace=\"false\" thread=\"false\"\n+    startTime=\"false\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Reserved bytes for this component\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Committed bytes for this component\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"services\/memReporter.hpp\"\n@@ -627,0 +628,8 @@\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsagePart) {\n+  MemJFRReporter::sendTypeEvents();\n+}\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsage) {\n+  MemJFRReporter::sendTotalEvent();\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"jfr\/jfrEvents.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"services\/memTracker.hpp\"\n@@ -34,1 +36,1 @@\n-size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n@@ -38,1 +40,1 @@\n-size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n@@ -823,0 +825,65 @@\n+\n+void MemJFRReporter::sendTotalEvent() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  MemBaseline usage;\n+  usage.baseline(true);\n+\n+  const size_t malloced_memory = usage.malloc_memory_snapshot()->total();\n+  const size_t reserved_memory = usage.virtual_memory_snapshot()->total_reserved();\n+  const size_t committed_memory = usage.virtual_memory_snapshot()->total_committed();\n+\n+  const size_t reserved = malloced_memory + reserved_memory;\n+  const size_t committed = malloced_memory + committed_memory;\n+\n+  EventNativeMemoryUsage event;\n+  event.set_reserved(reserved);\n+  event.set_committed(committed);\n+  event.commit();\n+}\n+\n+void MemJFRReporter::sendTypeEvent(const char* type, size_t reserved, size_t committed) {\n+  EventNativeMemoryUsagePart event;\n+  event.set_type(type);\n+  event.set_reserved(reserved);\n+  event.set_committed(committed);\n+  event.commit();\n+}\n+\n+void MemJFRReporter::sendTypeEvents() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  MemBaseline usage;\n+  usage.baseline(true);\n+  for (int index = 0; index < mt_number_of_types; index ++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n+    MallocMemory* malloc_memory = usage.malloc_memory(flag);\n+    VirtualMemory* virtual_memory = usage.virtual_memory(flag);\n+\n+    size_t reserved = MemReporterBase::reserved_total(malloc_memory, virtual_memory);\n+    size_t committed = MemReporterBase::committed_total(malloc_memory, virtual_memory);\n+\n+    \/\/ Some special cases to get accounting correct\n+    if (flag == mtThread) {\n+      \/\/ Count thread's native stack in \"Thread\" category\n+      if (ThreadStackTracker::track_as_vm()) {\n+        VirtualMemory* thread_stack_usage = usage.virtual_memory(mtThreadStack);\n+        reserved += thread_stack_usage->reserved();\n+        committed += thread_stack_usage->committed();\n+      } else {\n+        MallocMemory* thread_stack_usage = usage.malloc_memory(mtThreadStack);\n+        reserved += thread_stack_usage->malloc_size();\n+        committed += thread_stack_usage->malloc_size();\n+      }\n+    } else if (flag == mtNMT) {\n+      \/\/ Count malloc headers in \"NMT\" category\n+      reserved += usage.malloc_memory_snapshot()->malloc_overhead();\n+      committed += usage.malloc_memory_snapshot()->malloc_overhead();\n+    }\n+    sendTypeEvent(NMTUtil::flag_to_name(flag), reserved, committed);\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":69,"deletions":2,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+class MemJFRReporter;\n+\n@@ -52,0 +54,5 @@\n+  \/\/ Helper functions\n+  \/\/ Calculate total reserved and committed amount\n+  static size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+  static size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+\n@@ -76,5 +83,0 @@\n-  \/\/ Helper functions\n-  \/\/ Calculate total reserved and committed amount\n-  size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-  size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-\n@@ -240,0 +242,9 @@\n+class MemJFRReporter : public AllStatic {\n+private:\n+  static void sendTypeEvent(const char* type, size_t reserved, size_t committed);\n+ public:\n+  static void sendTotalEvent();\n+  static void sendTypeEvents();\n+};\n+\n+\n","filename":"src\/hotspot\/share\/services\/memReporter.hpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsagePart\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsagePart\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.opt.NativeMemoryTracking == null\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\n+ *          jdk.management\n+ * @run main\/othervm -XX:NativeMemoryTracking=summary -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents true\n+ * @run main\/othervm -XX:NativeMemoryTracking=off -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents false\n+ *\/\n+public class TestNativeMemoryUsageEvents {\n+    private final static String UsagePartEvent = EventNames.NativeMemoryUsagePart;\n+    private final static String UsageEvent = EventNames.NativeMemoryUsage;\n+\n+    private final static int UsagePeriod = 1000;\n+    private final static int K = 1024;\n+\n+    private final static String[] UsagePartEventTypes = {\n+        \"Java Heap\",\n+        \"Class\",\n+        \"Thread\",\n+        \"Thread Stack\",\n+        \"Code\",\n+        \"GC\",\n+        \"GCCardSet\",\n+        \"Compiler\",\n+        \"JVMCI\",\n+        \"Internal\",\n+        \"Other\",\n+        \"Symbol\",\n+        \"Native Memory Tracking\",\n+        \"Shared class space\",\n+        \"Arena Chunk\",\n+        \"Test\",\n+        \"Tracing\",\n+        \"Logging\",\n+        \"Statistics\",\n+        \"Arguments\",\n+        \"Module\",\n+        \"Safepoint\",\n+        \"Synchronization\",\n+        \"Serviceability\",\n+        \"Metaspace\",\n+        \"String Deduplication\",\n+        \"Object Monitors\"\n+    };\n+\n+    private static ArrayList<byte[]> data = new ArrayList<byte[]>();\n+\n+    private static void generateHeapContents() {\n+        for (int i = 0 ; i < 64; i++) {\n+            for (int j = 0; j < K; j++) {\n+                data.add(new byte[K]);\n+            }\n+        }\n+    }\n+\n+    private static void generateEvents(Recording recording) throws Exception {\n+        \/\/ Enable the two types of events for \"everyChunk\", it will give\n+        \/\/ an event att the beginning of the chunk as well as the end.\n+        recording.enable(UsagePartEvent).with(\"period\", \"everyChunk\");\n+        recording.enable(UsageEvent).with(\"period\", \"everyChunk\");\n+\n+        recording.start();\n+\n+        \/\/ Generate data to force heap to grow.\n+        generateHeapContents();\n+\n+        recording.stop();\n+    }\n+\n+    private static void verifyExpectedEventTypes(List<RecordedEvent> events) throws Exception {\n+        \/\/ First verify that the number of total usage events is greater than 0.\n+        long numberOfTotal = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .count();\n+\n+        assertGreaterThan(numberOfTotal, 0L, \"Should exist events of type: \" + UsageEvent);\n+\n+        \/\/ Now verify that we got the expected events.\n+        List<String> uniqueEventTypes = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsagePartEvent))\n+                .map(e -> e.getString(\"type\"))\n+                .distinct()\n+                .toList();\n+        for (String type : UsagePartEventTypes) {\n+            assertTrue(uniqueEventTypes.contains(type), \"Events should include: \" + type);\n+        }\n+    }\n+\n+    private static void verifyHeapGrowth(List<RecordedEvent> events) throws Exception {\n+        List<Long> javaHeapCommitted = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsagePartEvent))\n+                .filter(e -> e.getString(\"type\").equals(\"Java Heap\"))\n+                .map(e -> e.getLong(\"committed\"))\n+                .toList();\n+\n+        \/\/ Verify that the heap has grown between the first and last sample.\n+        long firstSample = javaHeapCommitted.get(0);\n+        long lastSample = javaHeapCommitted.get(javaHeapCommitted.size() - 1);\n+        assertGreaterThan(lastSample, firstSample, \"heap should have grown and NMT should show that\");\n+    }\n+\n+    private static void verifyNoUsageEvents(List<RecordedEvent> events) throws Exception {\n+        Events.hasNotEvent(events, UsageEvent);\n+        Events.hasNotEvent(events, UsagePartEvent);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ The tests takes a single boolean argument that states wether or not\n+        \/\/ it is run with -XX:NativeMemoryTracking=summary. When tracking is\n+        \/\/ enabled the tests verifies that the correct events are sent and\n+        \/\/ the other way around when turned off.\n+        assertTrue(args.length == 1, \"Must have a single argument\");\n+        boolean nmtEnabled = Boolean.parseBoolean(args[0]);\n+\n+        try (Recording recording = new Recording()) {\n+            generateEvents(recording);\n+\n+            var events = Events.fromRecording(recording);\n+            if (nmtEnabled) {\n+                verifyExpectedEventTypes(events);\n+                verifyHeapGrowth(events);\n+            } else {\n+                verifyNoUsageEvents(events);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeMemoryUsageEvents.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -89,0 +89,2 @@\n+    public static final String NativeMemoryUsagePart = PREFIX + \"NativeMemoryUsagePart\";\n+    public static final String NativeMemoryUsage = PREFIX + \"NativeMemoryUsage\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}