{"files":[{"patch":"@@ -709,0 +709,13 @@\n+  <Event name=\"NativeMemoryUsage\" category=\"Java Virtual Machine, Memory\" label=\"Native Memory Usage Per Type\"\n+    description=\"Native memory usage for a given memory type in the JVM\" period=\"everyChunk\">\n+    <Field type=\"string\" name=\"type\" label=\"Memory Type\" description=\"Type used for the native memory allocation\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Reserved bytes for this type\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Committed bytes for this type\" \/>\n+  <\/Event>\n+\n+  <Event name=\"NativeMemoryUsageTotal\" category=\"Java Virtual Machine, Memory\" label=\"Total Native Memory Usage\"\n+    description=\"Total native memory usage for the JVM. Might not be the exact sum of the NativeMemoryUsage events due to timeing.\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Total amount of reserved bytes for the JVM\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Total amount of committed bytes for the JVM\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"services\/memJfrReporter.hpp\"\n@@ -627,0 +628,8 @@\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsage) {\n+  MemJFRReporter::send_type_events();\n+}\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsageTotal) {\n+  MemJFRReporter::send_total_event();\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -149,1 +149,6 @@\n-  inline MallocMemory*  by_type(MEMFLAGS flags) {\n+  inline MallocMemory* by_type(MEMFLAGS flags) {\n+    int index = NMTUtil::flag_to_index(flags);\n+    return &_malloc[index];\n+  }\n+\n+  inline const MallocMemory* by_type(MEMFLAGS flags) const {\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"services\/memJfrReporter.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+Ticks MemJFRCurrentUsage::_timestamp;\n+NMTUsage* MemJFRCurrentUsage::_usage = nullptr;\n+\n+\n+NMTUsage* MemJFRCurrentUsage::get_usage() {\n+  Tickspan since_baselined = Ticks::now() - _timestamp;\n+\n+  if (_usage == nullptr) {\n+    \/\/ First time, create a new NMTUsage.\n+    _usage = new NMTUsage(NMTUsage::OptionsNoTS);\n+  } else if (since_baselined.milliseconds() < AgeThreshold) {\n+    \/\/ There is recent enough usage information, return it.\n+    return _usage;\n+  }\n+\n+  \/\/ Refresh the usage information.\n+  _usage->refresh();\n+  _timestamp.stamp();\n+\n+  return _usage;\n+}\n+\n+Ticks MemJFRCurrentUsage::get_timestamp() {\n+  return _timestamp;\n+}\n+\n+void MemJFRReporter::send_total_event() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  NMTUsage* usage = MemJFRCurrentUsage::get_usage();\n+  Ticks timestamp = MemJFRCurrentUsage::get_timestamp();\n+\n+  EventNativeMemoryUsageTotal event;\n+  event.set_starttime(timestamp);\n+  event.set_reserved(usage->total_reserved());\n+  event.set_committed(usage->total_committed());\n+  event.commit();\n+}\n+\n+void MemJFRReporter::send_type_event(const Ticks& starttime, const char* type, size_t reserved, size_t committed) {\n+  EventNativeMemoryUsage event;\n+  event.set_starttime(starttime);\n+  event.set_type(type);\n+  event.set_reserved(reserved);\n+  event.set_committed(committed);\n+  event.commit();\n+}\n+\n+void MemJFRReporter::send_type_events() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  NMTUsage* usage = MemJFRCurrentUsage::get_usage();\n+  Ticks timestamp = MemJFRCurrentUsage::get_timestamp();\n+\n+  for (int index = 0; index < mt_number_of_types; index ++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n+    if (flag == mtNone) {\n+      \/\/ Skip mtNone since it is not really used.\n+      continue;\n+    }\n+    send_type_event(timestamp, NMTUtil::flag_to_name(flag), usage->reserved(flag), usage->committed(flag));\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMJFRREPORTER_HPP\n+#define SHARE_SERVICES_MEMJFRREPORTER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ The MemJFRReporter and MemJFRCurrentUsage classes are only to be used from the\n+\/\/ thread sending periodic JFR events. So no synchronization is needed.\n+class MemJFRReporter : public AllStatic {\n+private:\n+  static void send_type_event(const Ticks& starttime, const char* tag, size_t reserved, size_t committed);\n+ public:\n+  static void send_total_event();\n+  static void send_type_events();\n+};\n+\n+\/\/ Helper class to avoid refreshing the NMTUsage to often and allow\n+\/\/ the two JFR events to use the same data.\n+class MemJFRCurrentUsage : public AllStatic {\n+private:\n+  \/\/ The age threshold in milliseconds. If older that this refresh the usage.\n+  static const uint64_t AgeThreshold = 50;\n+\n+  static Ticks _timestamp;\n+  static NMTUsage* _usage;\n+\n+public:\n+  static NMTUsage* get_usage();\n+  static Ticks get_timestamp();\n+};\n+\n+#endif \/\/SHARE_SERVICES_MEMJFRREPORTER_HPP\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n@@ -38,1 +38,1 @@\n-size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+  \/\/ Helper functions\n+  \/\/ Calculate total reserved and committed amount\n+  static size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+  static size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+\n@@ -76,5 +81,0 @@\n-  \/\/ Helper functions\n-  \/\/ Calculate total reserved and committed amount\n-  size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-  size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-\n","filename":"src\/hotspot\/share\/services\/memReporter.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/threadCritical.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"services\/threadStackTracker.hpp\"\n+#include \"services\/virtualMemoryTracker.hpp\"\n+\n+\/\/ Enabled all options for snapshot.\n+const NMTUsageOptions NMTUsage::OptionsAll = { true, true, true };\n+\/\/ Skip expensive thread stacks when refreshing usage.\n+const NMTUsageOptions NMTUsage::OptionsNoTS = { false, true, true };\n+\n+NMTUsage::NMTUsage(NMTUsageOptions options) :\n+    _malloc_by_type(),\n+    _malloc_total(),\n+    _vm_by_type(),\n+    _vm_total(),\n+    _usage_options(options) { }\n+\n+void NMTUsage::walk_thread_stacks() {\n+  \/\/ If backed by virtual memory, snapping the thread stacks involves walking\n+  \/\/ them to to figure out how much memory is committed if they are backed by\n+  \/\/ virtual memory. This needs ot happen before we take the snapshot of the\n+  \/\/ virtual memory since it will update this information.\n+  if (ThreadStackTracker::track_as_vm()) {\n+    VirtualMemoryTracker::snapshot_thread_stacks();\n+  }\n+}\n+\n+void NMTUsage::update_malloc_usage() {\n+  \/\/ Thread critical needed keep values in sync, total area size\n+  \/\/ is deducted from mtChunk in the end to give correct values.\n+  ThreadCritical tc;\n+  const MallocMemorySnapshot* ms = MallocMemorySummary::as_snapshot();\n+\n+  size_t total_arena_size = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    const MallocMemory* mm = ms->by_type(flag);\n+    _malloc_by_type[i] = mm->malloc_size() + mm->arena_size();\n+    total_arena_size +=  mm->arena_size();\n+  }\n+\n+  \/\/ Total malloc size.\n+  _malloc_total = ms->total();\n+\n+  \/\/ Adjustment due to mtChunk double counting.\n+  _malloc_by_type[NMTUtil::flag_to_index(mtChunk)] -= total_arena_size;\n+  _malloc_total -= total_arena_size;\n+\n+  \/\/ Adjust mtNMT to include malloc overhead.\n+  _malloc_by_type[NMTUtil::flag_to_index(mtNMT)] += ms->malloc_overhead();\n+}\n+\n+void NMTUsage::update_vm_usage() {\n+  const VirtualMemorySnapshot* vms = VirtualMemorySummary::as_snapshot();\n+\n+  \/\/ Reset total to allow recalculation.\n+  _vm_total.committed = 0;\n+  _vm_total.reserved = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    const VirtualMemory* vm = vms->by_type(flag);\n+\n+    _vm_by_type[i].reserved = vm->reserved();\n+    _vm_by_type[i].committed = vm->committed();\n+    _vm_total.reserved += vm->reserved();\n+    _vm_total.committed += vm->committed();\n+  }\n+}\n+\n+void NMTUsage::refresh() {\n+  if (_usage_options.include_malloc) {\n+    update_malloc_usage();\n+  }\n+\n+  if (_usage_options.include_vm) {\n+    \/\/ Thread stacks only makes sense if virtual memory\n+    \/\/ is also included. It must be executed before the\n+    \/\/ over all usage is calculated.\n+    if (_usage_options.update_thread_stacks) {\n+      walk_thread_stacks();\n+    }\n+    update_vm_usage();\n+  }\n+}\n+\n+size_t NMTUsage::total_reserved() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t NMTUsage::total_committed() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t NMTUsage::reserved(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_by_type[index] + _vm_by_type[index].reserved;\n+}\n+\n+size_t NMTUsage::committed(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_by_type[index] + _vm_by_type[index].committed;\n+}\n","filename":"src\/hotspot\/share\/services\/nmtUsage.cpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_NMTUSAGE_HPP\n+#define SHARE_SERVICES_NMTUSAGE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+struct NMTUsagePair {\n+  size_t reserved;\n+  size_t committed;\n+};\n+\n+struct NMTUsageOptions {\n+  bool update_thread_stacks;\n+  bool include_malloc;\n+  bool include_vm;\n+};\n+\n+class NMTUsage : public CHeapObj<mtNMT> {\n+private:\n+  size_t _malloc_by_type[mt_number_of_types];\n+  size_t _malloc_total;\n+  NMTUsagePair _vm_by_type[mt_number_of_types];\n+  NMTUsagePair _vm_total;\n+\n+  NMTUsageOptions _usage_options;\n+\n+  void walk_thread_stacks();\n+  void update_malloc_usage();\n+  void update_vm_usage();\n+\n+public:\n+  static const NMTUsageOptions OptionsAll;\n+  static const NMTUsageOptions OptionsNoTS;\n+\n+  NMTUsage(NMTUsageOptions options = OptionsAll);\n+  void refresh();\n+\n+  size_t total_reserved() const;\n+  size_t total_committed() const;\n+  size_t reserved(MEMFLAGS flag) const;\n+  size_t committed(MEMFLAGS flag) const;\n+};\n+\n+#endif \/\/ SHARE_SERVICES_NMTUSAGE_HPP\n","filename":"src\/hotspot\/share\/services\/nmtUsage.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -100,0 +100,5 @@\n+  inline const VirtualMemory* by_type(MEMFLAGS flag) const {\n+    int index = NMTUtil::flag_to_index(flag);\n+    return &_virtual_memory[index];\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.opt.NativeMemoryTracking == null\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\n+ *          jdk.management\n+ * @run main\/othervm -XX:NativeMemoryTracking=summary -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents true\n+ * @run main\/othervm -XX:NativeMemoryTracking=off -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents false\n+ *\/\n+public class TestNativeMemoryUsageEvents {\n+    private final static String UsageTotalEvent = EventNames.NativeMemoryUsageTotal;\n+    private final static String UsageEvent = EventNames.NativeMemoryUsage;\n+\n+    private final static int UsagePeriod = 1000;\n+    private final static int K = 1024;\n+\n+    private final static String[] UsageEventTypes = {\n+        \"Java Heap\",\n+        \"Class\",\n+        \"Thread\",\n+        \"Thread Stack\",\n+        \"Code\",\n+        \"GC\",\n+        \"GCCardSet\",\n+        \"Compiler\",\n+        \"JVMCI\",\n+        \"Internal\",\n+        \"Other\",\n+        \"Symbol\",\n+        \"Native Memory Tracking\",\n+        \"Shared class space\",\n+        \"Arena Chunk\",\n+        \"Test\",\n+        \"Tracing\",\n+        \"Logging\",\n+        \"Statistics\",\n+        \"Arguments\",\n+        \"Module\",\n+        \"Safepoint\",\n+        \"Synchronization\",\n+        \"Serviceability\",\n+        \"Metaspace\",\n+        \"String Deduplication\",\n+        \"Object Monitors\"\n+    };\n+\n+    private static ArrayList<byte[]> data = new ArrayList<byte[]>();\n+\n+    private static void generateHeapContents() {\n+        for (int i = 0 ; i < 64; i++) {\n+            for (int j = 0; j < K; j++) {\n+                data.add(new byte[K]);\n+            }\n+        }\n+    }\n+\n+    private static void generateEvents(Recording recording) throws Exception {\n+        \/\/ Enable the two types of events for \"everyChunk\", it will give\n+        \/\/ an event att the beginning of the chunk as well as the end.\n+        recording.enable(UsageEvent).with(\"period\", \"everyChunk\");\n+        recording.enable(UsageTotalEvent).with(\"period\", \"everyChunk\");\n+\n+        recording.start();\n+\n+        \/\/ Generate data to force heap to grow.\n+        generateHeapContents();\n+\n+        recording.stop();\n+    }\n+\n+    private static void verifyExpectedEventTypes(List<RecordedEvent> events) throws Exception {\n+        \/\/ First verify that the number of total usage events is greater than 0.\n+        long numberOfTotal = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageTotalEvent))\n+                .count();\n+\n+        assertGreaterThan(numberOfTotal, 0L, \"Should exist events of type: \" + UsageTotalEvent);\n+\n+        \/\/ Now verify that we got the expected events.\n+        List<String> uniqueEventTypes = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .map(e -> e.getString(\"type\"))\n+                .distinct()\n+                .toList();\n+        for (String type : UsageEventTypes) {\n+            assertTrue(uniqueEventTypes.contains(type), \"Events should include: \" + type);\n+        }\n+    }\n+\n+    private static void verifyHeapGrowth(List<RecordedEvent> events) throws Exception {\n+        List<Long> javaHeapCommitted = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .filter(e -> e.getString(\"type\").equals(\"Java Heap\"))\n+                .map(e -> e.getLong(\"committed\"))\n+                .toList();\n+\n+        \/\/ Verify that the heap has grown between the first and last sample.\n+        long firstSample = javaHeapCommitted.get(0);\n+        long lastSample = javaHeapCommitted.get(javaHeapCommitted.size() - 1);\n+        assertGreaterThan(lastSample, firstSample, \"heap should have grown and NMT should show that\");\n+    }\n+\n+    private static void verifyNoUsageEvents(List<RecordedEvent> events) throws Exception {\n+        Events.hasNotEvent(events, UsageEvent);\n+        Events.hasNotEvent(events, UsageTotalEvent);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ The tests takes a single boolean argument that states wether or not\n+        \/\/ it is run with -XX:NativeMemoryTracking=summary. When tracking is\n+        \/\/ enabled the tests verifies that the correct events are sent and\n+        \/\/ the other way around when turned off.\n+        assertTrue(args.length == 1, \"Must have a single argument\");\n+        boolean nmtEnabled = Boolean.parseBoolean(args[0]);\n+\n+        try (Recording recording = new Recording()) {\n+            generateEvents(recording);\n+\n+            var events = Events.fromRecording(recording);\n+            if (nmtEnabled) {\n+                verifyExpectedEventTypes(events);\n+                verifyHeapGrowth(events);\n+            } else {\n+                verifyNoUsageEvents(events);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeMemoryUsageEvents.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -89,0 +89,2 @@\n+    public static final String NativeMemoryUsage = PREFIX + \"NativeMemoryUsage\";\n+    public static final String NativeMemoryUsageTotal = PREFIX + \"NativeMemoryUsageTotal\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}