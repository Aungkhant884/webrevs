{"files":[{"patch":"@@ -149,1 +149,6 @@\n-  inline MallocMemory*  by_type(MEMFLAGS flags) {\n+  inline MallocMemory* by_type(MEMFLAGS flags) {\n+    int index = NMTUtil::flag_to_index(flags);\n+    return &_malloc[index];\n+  }\n+\n+  inline const MallocMemory* by_type(MEMFLAGS flags) const {\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"services\/memSnapshot.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"services\/nmtUsage.hpp\"\n@@ -33,2 +33,2 @@\n-Ticks MemJFRSnapshot::_snapshot_timestamp;\n-MemSnapshot* MemJFRSnapshot::_snapshot = nullptr;\n+Ticks MemJFRCurrentUsage::_timestamp;\n+NMTUsage* MemJFRCurrentUsage::_usage = nullptr;\n@@ -36,2 +36,0 @@\n-MemSnapshot* MemJFRSnapshot::get_snapshot() {\n-  Tickspan since_baselined = Ticks::now() - _snapshot_timestamp;\n@@ -39,6 +37,9 @@\n-  if (_snapshot == nullptr) {\n-    \/\/ No previous snapshot taken, create one.\n-    _snapshot = new MemSnapshot(MemSnapshot::OptionsNoTS);\n-  } else if (since_baselined.milliseconds() < BaselineAgeThreshold) {\n-    \/\/ There is a recent enough snapshot, return it.\n-    return _snapshot;\n+NMTUsage* MemJFRCurrentUsage::get_usage() {\n+  Tickspan since_baselined = Ticks::now() - _timestamp;\n+\n+  if (_usage == nullptr) {\n+    \/\/ First time, create a new NMTUsage.\n+    _usage = new NMTUsage(NMTUsage::OptionsNoTS);\n+  } else if (since_baselined.milliseconds() < AgeThreshold) {\n+    \/\/ There is recent enough usage information, return it.\n+    return _usage;\n@@ -47,3 +48,3 @@\n-  \/\/ Refresh existing snapshot.\n-  _snapshot->snap();\n-  _snapshot_timestamp.stamp();\n+  \/\/ Refresh the usage information.\n+  _usage->refresh();\n+  _timestamp.stamp();\n@@ -51,1 +52,1 @@\n-  return _snapshot;\n+  return _usage;\n@@ -54,2 +55,2 @@\n-Ticks MemJFRSnapshot::get_timestamp() {\n-  return _snapshot_timestamp;\n+Ticks MemJFRCurrentUsage::get_timestamp() {\n+  return _timestamp;\n@@ -63,2 +64,2 @@\n-  MemSnapshot* usage = MemJFRSnapshot::get_snapshot();\n-  Ticks timestamp = MemJFRSnapshot::get_timestamp();\n+  NMTUsage* usage = MemJFRCurrentUsage::get_usage();\n+  Ticks timestamp = MemJFRCurrentUsage::get_timestamp();\n@@ -87,2 +88,2 @@\n-  MemSnapshot* usage = MemJFRSnapshot::get_snapshot();\n-  Ticks timestamp = MemJFRSnapshot::get_timestamp();\n+  NMTUsage* usage = MemJFRCurrentUsage::get_usage();\n+  Ticks timestamp = MemJFRCurrentUsage::get_timestamp();\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.cpp","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"services\/memSnapshot.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n@@ -33,1 +33,1 @@\n-\/\/ The MemJFRReporter and MemJFRBaseline classes are only to be used from the\n+\/\/ The MemJFRReporter and MemJFRCurrentUsage classes are only to be used from the\n@@ -43,3 +43,3 @@\n-\/\/ Helper class to avoid taking multiple NMT baselines for\n-\/\/ the two JFR events that are using the same data.\n-class MemJFRSnapshot : public AllStatic {\n+\/\/ Helper class to avoid refreshing the NMTUsage to often and allow\n+\/\/ the two JFR events to use the same data.\n+class MemJFRCurrentUsage : public AllStatic {\n@@ -47,3 +47,2 @@\n-  \/\/ The baseline age threshold in millie seconds. If older\n-  \/\/ that this we will make a new baseline.\n-  static const uint64_t BaselineAgeThreshold = 50;\n+  \/\/ The age threshold in milliseconds. If older that this refresh the usage.\n+  static const uint64_t AgeThreshold = 50;\n@@ -51,2 +50,2 @@\n-  static Ticks _snapshot_timestamp;\n-  static MemSnapshot* _snapshot;\n+  static Ticks _timestamp;\n+  static NMTUsage* _usage;\n@@ -55,1 +54,1 @@\n-  static MemSnapshot* get_snapshot();\n+  static NMTUsage* get_usage();\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"runtime\/threadCritical.hpp\"\n-#include \"services\/memSnapshot.hpp\"\n-#include \"services\/nmtCommon.hpp\"\n-#include \"services\/mallocTracker.hpp\"\n-#include \"services\/threadStackTracker.hpp\"\n-#include \"services\/virtualMemoryTracker.hpp\"\n-\n-\/\/ Enabled all options for snapshot.\n-const MemSnapshotOptions MemSnapshot::OptionsAll = { true, true, true };\n-\/\/ Skip expensive thread stacks for snapshot.\n-const MemSnapshotOptions MemSnapshot::OptionsNoTS = { false, true, true };\n-\n-MemSnapshot::MemSnapshot(MemSnapshotOptions options) :\n-    _malloc_snapshot(),\n-    _malloc_total(),\n-    _vm_snapshot(),\n-    _vm_total(),\n-    _snapshot_options(options) { }\n-\n-void MemSnapshot::walk_thread_stacks() {\n-  \/\/ If backed by virtual memory, snapping the thread stacks involves walking\n-  \/\/ them to to figure out how much memory is committed if they are backed by\n-  \/\/ virtual memory. This needs ot happen before we take the snapshot of the\n-  \/\/ virtual memory since it will update this information.\n-  if (ThreadStackTracker::track_as_vm()) {\n-    VirtualMemoryTracker::snapshot_thread_stacks();\n-  }\n-}\n-\n-void MemSnapshot::update_malloc_snapshot() {\n-  \/\/ Thread critical needed keep values in sync, total area size\n-  \/\/ is deducted from mtChunk in the end to give correct values.\n-  ThreadCritical tc;\n-  MallocMemorySnapshot* ms = MallocMemorySummary::as_snapshot();\n-\n-  size_t total_arena_size = 0;\n-  for (int i = 0; i < mt_number_of_types; i++) {\n-    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n-    MallocMemory* mm = ms->by_type(flag);\n-    _malloc_snapshot[i] = mm->malloc_size() + mm->arena_size();\n-    total_arena_size +=  mm->arena_size();\n-  }\n-  assert(total_arena_size == ms->total_arena(), \"Mismatch in accounting\");\n-\n-  \/\/ Total malloc size.\n-  _malloc_total = ms->total();\n-\n-  \/\/ Adjustment due to mtChunk double counting.\n-  _malloc_snapshot[NMTUtil::flag_to_index(mtChunk)] -= total_arena_size;\n-  _malloc_total -= total_arena_size;\n-\n-  \/\/ Adjust mtNMT to include malloc overhead.\n-  _malloc_snapshot[NMTUtil::flag_to_index(mtNMT)] += ms->malloc_overhead();\n-}\n-\n-void MemSnapshot::update_vm_snapshot() {\n-  VirtualMemorySnapshot* vms = VirtualMemorySummary::as_snapshot();\n-\n-  for (int i = 0; i < mt_number_of_types; i++) {\n-    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n-    VirtualMemory* vm = vms->by_type(flag);\n-    _vm_snapshot[i].reserved = vm->reserved();\n-    _vm_snapshot[i].committed = vm->committed();\n-  }\n-\n-  \/\/ Total virtual memory size.\n-  _vm_total.reserved = vms->total_reserved();\n-  _vm_total.committed = vms->total_committed();\n-}\n-\n-void MemSnapshot::snap() {\n-  if (_snapshot_options.update_thread_stacks) {\n-    walk_thread_stacks();\n-  }\n-\n-  if (_snapshot_options.include_malloc) {\n-    update_malloc_snapshot();\n-  }\n-\n-  if (_snapshot_options.include_vm) {\n-    update_vm_snapshot();\n-  }\n-}\n-\n-size_t MemSnapshot::total_reserved() const {\n-  return _malloc_total + _vm_total.reserved;\n-}\n-\n-size_t MemSnapshot::total_committed() const {\n-  return _malloc_total + _vm_total.reserved;\n-}\n-\n-size_t MemSnapshot::reserved(MEMFLAGS flag) const {\n-  int index = NMTUtil::flag_to_index(flag);\n-  return _malloc_snapshot[index] + _vm_snapshot[index].reserved;\n-}\n-\n-size_t MemSnapshot::committed(MEMFLAGS flag) const {\n-  int index = NMTUtil::flag_to_index(flag);\n-  return _malloc_snapshot[index] + _vm_snapshot[index].committed;\n-}\n","filename":"src\/hotspot\/share\/services\/memSnapshot.cpp","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_SERVICES_MEMSNAPSHOT_HPP\n-#define SHARE_SERVICES_MEMSNAPSHOT_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-struct MemSnapshotPair {\n-  size_t reserved;\n-  size_t committed;\n-};\n-\n-struct MemSnapshotOptions {\n-  bool update_thread_stacks;\n-  bool include_malloc;\n-  bool include_vm;\n-};\n-\n-class MemSnapshot : public CHeapObj<mtNMT> {\n-private:\n-  size_t _malloc_snapshot[mt_number_of_types];\n-  size_t _malloc_total;\n-  MemSnapshotPair _vm_snapshot[mt_number_of_types];\n-  MemSnapshotPair _vm_total;\n-\n-  MemSnapshotOptions _snapshot_options;\n-\n-  void walk_thread_stacks();\n-  void update_malloc_snapshot();\n-  void update_vm_snapshot();\n-\n-public:\n-  static const MemSnapshotOptions OptionsAll;\n-  static const MemSnapshotOptions OptionsNoTS;\n-\n-  MemSnapshot(MemSnapshotOptions options = OptionsAll);\n-  void snap();\n-\n-  size_t total_reserved() const;\n-  size_t total_committed() const;\n-  size_t reserved(MEMFLAGS flag) const;\n-  size_t committed(MEMFLAGS flag) const;\n-};\n-\n-#endif \/\/ SHARE_SERVICES_MEMSNAPSHOT_HPP\n","filename":"src\/hotspot\/share\/services\/memSnapshot.hpp","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/threadCritical.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"services\/threadStackTracker.hpp\"\n+#include \"services\/virtualMemoryTracker.hpp\"\n+\n+\/\/ Enabled all options for snapshot.\n+const NMTUsageOptions NMTUsage::OptionsAll = { true, true, true };\n+\/\/ Skip expensive thread stacks when refreshing usage.\n+const NMTUsageOptions NMTUsage::OptionsNoTS = { false, true, true };\n+\n+NMTUsage::NMTUsage(NMTUsageOptions options) :\n+    _malloc_by_type(),\n+    _malloc_total(),\n+    _vm_by_type(),\n+    _vm_total(),\n+    _usage_options(options) { }\n+\n+void NMTUsage::walk_thread_stacks() {\n+  \/\/ If backed by virtual memory, snapping the thread stacks involves walking\n+  \/\/ them to to figure out how much memory is committed if they are backed by\n+  \/\/ virtual memory. This needs ot happen before we take the snapshot of the\n+  \/\/ virtual memory since it will update this information.\n+  if (ThreadStackTracker::track_as_vm()) {\n+    VirtualMemoryTracker::snapshot_thread_stacks();\n+  }\n+}\n+\n+void NMTUsage::update_malloc_usage() {\n+  \/\/ Thread critical needed keep values in sync, total area size\n+  \/\/ is deducted from mtChunk in the end to give correct values.\n+  ThreadCritical tc;\n+  const MallocMemorySnapshot* ms = MallocMemorySummary::as_snapshot();\n+\n+  size_t total_arena_size = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    const MallocMemory* mm = ms->by_type(flag);\n+    _malloc_by_type[i] = mm->malloc_size() + mm->arena_size();\n+    total_arena_size +=  mm->arena_size();\n+  }\n+\n+  \/\/ Total malloc size.\n+  _malloc_total = ms->total();\n+\n+  \/\/ Adjustment due to mtChunk double counting.\n+  _malloc_by_type[NMTUtil::flag_to_index(mtChunk)] -= total_arena_size;\n+  _malloc_total -= total_arena_size;\n+\n+  \/\/ Adjust mtNMT to include malloc overhead.\n+  _malloc_by_type[NMTUtil::flag_to_index(mtNMT)] += ms->malloc_overhead();\n+}\n+\n+void NMTUsage::update_vm_usage() {\n+  const VirtualMemorySnapshot* vms = VirtualMemorySummary::as_snapshot();\n+\n+  \/\/ Reset total to allow recalculation.\n+  _vm_total.committed = 0;\n+  _vm_total.reserved = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    const VirtualMemory* vm = vms->by_type(flag);\n+\n+    _vm_by_type[i].reserved = vm->reserved();\n+    _vm_by_type[i].committed = vm->committed();\n+    _vm_total.reserved += vm->reserved();\n+    _vm_total.committed += vm->committed();\n+  }\n+}\n+\n+void NMTUsage::refresh() {\n+  if (_usage_options.include_malloc) {\n+    update_malloc_usage();\n+  }\n+\n+  if (_usage_options.include_vm) {\n+    \/\/ Thread stacks only makes sense if virtual memory\n+    \/\/ is also included. It must be executed before the\n+    \/\/ over all usage is calculated.\n+    if (_usage_options.update_thread_stacks) {\n+      walk_thread_stacks();\n+    }\n+    update_vm_usage();\n+  }\n+}\n+\n+size_t NMTUsage::total_reserved() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t NMTUsage::total_committed() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t NMTUsage::reserved(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_by_type[index] + _vm_by_type[index].reserved;\n+}\n+\n+size_t NMTUsage::committed(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_by_type[index] + _vm_by_type[index].committed;\n+}\n","filename":"src\/hotspot\/share\/services\/nmtUsage.cpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_NMTUSAGE_HPP\n+#define SHARE_SERVICES_NMTUSAGE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+struct NMTUsagePair {\n+  size_t reserved;\n+  size_t committed;\n+};\n+\n+struct NMTUsageOptions {\n+  bool update_thread_stacks;\n+  bool include_malloc;\n+  bool include_vm;\n+};\n+\n+class NMTUsage : public CHeapObj<mtNMT> {\n+private:\n+  size_t _malloc_by_type[mt_number_of_types];\n+  size_t _malloc_total;\n+  NMTUsagePair _vm_by_type[mt_number_of_types];\n+  NMTUsagePair _vm_total;\n+\n+  NMTUsageOptions _usage_options;\n+\n+  void walk_thread_stacks();\n+  void update_malloc_usage();\n+  void update_vm_usage();\n+\n+public:\n+  static const NMTUsageOptions OptionsAll;\n+  static const NMTUsageOptions OptionsNoTS;\n+\n+  NMTUsage(NMTUsageOptions options = OptionsAll);\n+  void refresh();\n+\n+  size_t total_reserved() const;\n+  size_t total_committed() const;\n+  size_t reserved(MEMFLAGS flag) const;\n+  size_t committed(MEMFLAGS flag) const;\n+};\n+\n+#endif \/\/ SHARE_SERVICES_NMTUSAGE_HPP\n","filename":"src\/hotspot\/share\/services\/nmtUsage.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -100,0 +100,5 @@\n+  inline const VirtualMemory* by_type(MEMFLAGS flag) const {\n+    int index = NMTUtil::flag_to_index(flag);\n+    return &_virtual_memory[index];\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}