{"files":[{"patch":"@@ -709,5 +709,5 @@\n-  <Event name=\"NativeMemoryUsagePart\" category=\"Java Virtual Machine, Memory\" label=\"Component Native Memory Usage\" description=\"Native memory usage for a component\" stackTrace=\"false\" thread=\"false\"\n-    startTime=\"false\" period=\"everyChunk\">\n-    <Field type=\"string\" name=\"type\" label=\"Memory Type\" description=\"Component allocating the native memory\" \/>\n-    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Reserved bytes by this component\" \/>\n-    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Committed bytes by this component\" \/>\n+  <Event name=\"NativeMemoryUsage\" category=\"Java Virtual Machine, Memory\" label=\"Native Memory Usage Per Type\"\n+    description=\"Native memory usage for a given memory type in the JVM\" period=\"everyChunk\">\n+    <Field type=\"string\" name=\"type\" label=\"Memory Type\" description=\"Type used for the native memory allocation\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Reserved bytes for this type\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Committed bytes for this type\" \/>\n@@ -716,4 +716,4 @@\n-  <Event name=\"NativeMemoryUsage\" category=\"Java Virtual Machine, Memory\" label=\"Total Native Memory Usage\" description=\"Total Native Memory Usage\" stackTrace=\"false\" thread=\"false\"\n-    startTime=\"false\" period=\"everyChunk\">\n-    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Reserved bytes for this component\" \/>\n-    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Committed bytes for this component\" \/>\n+  <Event name=\"NativeMemoryUsageTotal\" category=\"Java Virtual Machine, Memory\" label=\"Total Native Memory Usage\"\n+    description=\"Total native memory usage for the JVM. Might not be the exact sum of the NativeMemoryUsage events due to timeing.\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Total amount of reserved bytes for the JVM\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Total amount of committed bytes for the JVM\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-#include \"services\/memReporter.hpp\"\n+#include \"services\/memJfrReporter.hpp\"\n@@ -629,1 +629,1 @@\n-TRACE_REQUEST_FUNC(NativeMemoryUsagePart) {\n+TRACE_REQUEST_FUNC(NativeMemoryUsage) {\n@@ -633,1 +633,1 @@\n-TRACE_REQUEST_FUNC(NativeMemoryUsage) {\n+TRACE_REQUEST_FUNC(NativeMemoryUsageTotal) {\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"services\/memJfrReporter.hpp\"\n+#include \"services\/memReporter.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+Ticks MemJFRBaseline::_baseline_timestamp;\n+MemBaseline MemJFRBaseline::_baseline;\n+\n+MemBaseline& MemJFRBaseline::getBaseline() {\n+  Tickspan since_baselined = Ticks::now() - _baseline_timestamp;\n+  if (since_baselined.milliseconds() > BaselineAgeThreshold ||\n+      _baseline.baseline_type() == MemBaseline::Not_baselined) {\n+    \/\/ Summary only baseline.\n+    _baseline.baseline(true);\n+    _baseline_timestamp.stamp();\n+  }\n+\n+  return _baseline;\n+}\n+\n+Ticks MemJFRBaseline::getTimestamp() {\n+  return _baseline_timestamp;\n+}\n+\n+void MemJFRReporter::sendTotalEvent() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  MemBaseline& usage = MemJFRBaseline::getBaseline();\n+  Ticks timestamp = MemJFRBaseline::getTimestamp();\n+\n+  const size_t malloced_memory = usage.malloc_memory_snapshot()->total();\n+  const size_t reserved_memory = usage.virtual_memory_snapshot()->total_reserved();\n+  const size_t committed_memory = usage.virtual_memory_snapshot()->total_committed();\n+\n+  const size_t reserved = malloced_memory + reserved_memory;\n+  const size_t committed = malloced_memory + committed_memory;\n+\n+  EventNativeMemoryUsageTotal event;\n+  event.set_starttime(timestamp);\n+  event.set_reserved(reserved);\n+  event.set_committed(committed);\n+  event.commit();\n+}\n+\n+void MemJFRReporter::sendTypeEvent(const Ticks& starttime, const char* type, size_t reserved, size_t committed) {\n+  EventNativeMemoryUsage event;\n+  event.set_starttime(starttime);\n+  event.set_type(type);\n+  event.set_reserved(reserved);\n+  event.set_committed(committed);\n+  event.commit();\n+}\n+\n+void MemJFRReporter::sendTypeEvents() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  MemBaseline& usage = MemJFRBaseline::getBaseline();\n+  Ticks timestamp = MemJFRBaseline::getTimestamp();\n+\n+  for (int index = 0; index < mt_number_of_types; index ++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n+    MallocMemory* malloc_memory = usage.malloc_memory(flag);\n+    VirtualMemory* virtual_memory = usage.virtual_memory(flag);\n+\n+    size_t reserved = MemReporterBase::reserved_total(malloc_memory, virtual_memory);\n+    size_t committed = MemReporterBase::committed_total(malloc_memory, virtual_memory);\n+\n+    \/\/ Some special cases to get accounting correct\n+    if (flag == mtThread) {\n+      \/\/ Count thread's native stack in \"Thread\" category\n+      if (ThreadStackTracker::track_as_vm()) {\n+        VirtualMemory* thread_stack_usage = usage.virtual_memory(mtThreadStack);\n+        reserved += thread_stack_usage->reserved();\n+        committed += thread_stack_usage->committed();\n+      } else {\n+        MallocMemory* thread_stack_usage = usage.malloc_memory(mtThreadStack);\n+        reserved += thread_stack_usage->malloc_size();\n+        committed += thread_stack_usage->malloc_size();\n+      }\n+    } else if (flag == mtNMT) {\n+      \/\/ Count malloc headers in \"NMT\" category\n+      reserved += usage.malloc_memory_snapshot()->malloc_overhead();\n+      committed += usage.malloc_memory_snapshot()->malloc_overhead();\n+    }\n+    sendTypeEvent(timestamp, NMTUtil::flag_to_name(flag), reserved, committed);\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.cpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMJFRREPORTER_HPP\n+#define SHARE_SERVICES_MEMJFRREPORTER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"services\/memBaseline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ The MemJFRReporter and MemJFRBaseline classes are only to be used from the\n+\/\/ thread sending periodic JFR events. So no synchronization is needed.\n+class MemJFRReporter : public AllStatic {\n+private:\n+  static void sendTypeEvent(const Ticks& starttime, const char* tag, size_t reserved, size_t committed);\n+ public:\n+  static void sendTotalEvent();\n+  static void sendTypeEvents();\n+};\n+\n+\/\/ Helper class to avoid taking multiple NMT baselines for\n+\/\/ the two JFR events that are using the same data.\n+class MemJFRBaseline : public AllStatic {\n+private:\n+  \/\/ The baseline age threshold in millie seconds. If older\n+  \/\/ that this we will make a new baseline.\n+  static const uint64_t BaselineAgeThreshold = 50;\n+\n+  static Ticks _baseline_timestamp;\n+  static MemBaseline _baseline;\n+\n+public:\n+  static MemBaseline& getBaseline();\n+  static Ticks getTimestamp();\n+};\n+\n+#endif \/\/SHARE_SERVICES_MEMJFRREPORTER_HPP\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.hpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfr\/jfrEvents.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"services\/memTracker.hpp\"\n@@ -825,65 +823,0 @@\n-\n-void MemJFRReporter::sendTotalEvent() {\n-  if (!MemTracker::enabled()) {\n-    return;\n-  }\n-\n-  MemBaseline usage;\n-  usage.baseline(true);\n-\n-  const size_t malloced_memory = usage.malloc_memory_snapshot()->total();\n-  const size_t reserved_memory = usage.virtual_memory_snapshot()->total_reserved();\n-  const size_t committed_memory = usage.virtual_memory_snapshot()->total_committed();\n-\n-  const size_t reserved = malloced_memory + reserved_memory;\n-  const size_t committed = malloced_memory + committed_memory;\n-\n-  EventNativeMemoryUsage event;\n-  event.set_reserved(reserved);\n-  event.set_committed(committed);\n-  event.commit();\n-}\n-\n-void MemJFRReporter::sendTypeEvent(const char* type, size_t reserved, size_t committed) {\n-  EventNativeMemoryUsagePart event;\n-  event.set_type(type);\n-  event.set_reserved(reserved);\n-  event.set_committed(committed);\n-  event.commit();\n-}\n-\n-void MemJFRReporter::sendTypeEvents() {\n-  if (!MemTracker::enabled()) {\n-    return;\n-  }\n-\n-  MemBaseline usage;\n-  usage.baseline(true);\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n-    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n-    MallocMemory* malloc_memory = usage.malloc_memory(flag);\n-    VirtualMemory* virtual_memory = usage.virtual_memory(flag);\n-\n-    size_t reserved = MemReporterBase::reserved_total(malloc_memory, virtual_memory);\n-    size_t committed = MemReporterBase::committed_total(malloc_memory, virtual_memory);\n-\n-    \/\/ Some special cases to get accounting correct\n-    if (flag == mtThread) {\n-      \/\/ Count thread's native stack in \"Thread\" category\n-      if (ThreadStackTracker::track_as_vm()) {\n-        VirtualMemory* thread_stack_usage = usage.virtual_memory(mtThreadStack);\n-        reserved += thread_stack_usage->reserved();\n-        committed += thread_stack_usage->committed();\n-      } else {\n-        MallocMemory* thread_stack_usage = usage.malloc_memory(mtThreadStack);\n-        reserved += thread_stack_usage->malloc_size();\n-        committed += thread_stack_usage->malloc_size();\n-      }\n-    } else if (flag == mtNMT) {\n-      \/\/ Count malloc headers in \"NMT\" category\n-      reserved += usage.malloc_memory_snapshot()->malloc_overhead();\n-      committed += usage.malloc_memory_snapshot()->malloc_overhead();\n-    }\n-    sendTypeEvent(NMTUtil::flag_to_name(flag), reserved, committed);\n-  }\n-}\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":0,"deletions":67,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-class MemJFRReporter;\n-\n@@ -242,9 +240,0 @@\n-class MemJFRReporter : public AllStatic {\n-private:\n-  static void sendTypeEvent(const char* type, size_t reserved, size_t committed);\n- public:\n-  static void sendTotalEvent();\n-  static void sendTypeEvents();\n-};\n-\n-\n","filename":"src\/hotspot\/share\/services\/memReporter.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -520,1 +520,1 @@\n-    <event name=\"jdk.NativeMemoryUsagePart\">\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -520,1 +520,1 @@\n-    <event name=\"jdk.NativeMemoryUsagePart\">\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private final static String UsagePartEvent = EventNames.NativeMemoryUsagePart;\n+    private final static String UsageTotalEvent = EventNames.NativeMemoryUsageTotal;\n@@ -55,1 +55,1 @@\n-    private final static String[] UsagePartEventTypes = {\n+    private final static String[] UsageEventTypes = {\n@@ -98,1 +98,0 @@\n-        recording.enable(UsagePartEvent).with(\"period\", \"everyChunk\");\n@@ -100,0 +99,1 @@\n+        recording.enable(UsageTotalEvent).with(\"period\", \"everyChunk\");\n@@ -112,1 +112,1 @@\n-                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .filter(e -> e.getEventType().getName().equals(UsageTotalEvent))\n@@ -115,1 +115,1 @@\n-        assertGreaterThan(numberOfTotal, 0L, \"Should exist events of type: \" + UsageEvent);\n+        assertGreaterThan(numberOfTotal, 0L, \"Should exist events of type: \" + UsageTotalEvent);\n@@ -119,1 +119,1 @@\n-                .filter(e -> e.getEventType().getName().equals(UsagePartEvent))\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n@@ -123,1 +123,1 @@\n-        for (String type : UsagePartEventTypes) {\n+        for (String type : UsageEventTypes) {\n@@ -130,1 +130,1 @@\n-                .filter(e -> e.getEventType().getName().equals(UsagePartEvent))\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n@@ -143,1 +143,1 @@\n-        Events.hasNotEvent(events, UsagePartEvent);\n+        Events.hasNotEvent(events, UsageTotalEvent);\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeMemoryUsageEvents.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-    public static final String NativeMemoryUsagePart = PREFIX + \"NativeMemoryUsagePart\";\n@@ -91,0 +90,1 @@\n+    public static final String NativeMemoryUsageTotal = PREFIX + \"NativeMemoryUsageTotal\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}