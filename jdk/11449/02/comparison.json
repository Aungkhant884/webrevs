{"files":[{"patch":"@@ -709,0 +709,13 @@\n+  <Event name=\"NativeMemoryUsage\" category=\"Java Virtual Machine, Memory\" label=\"Native Memory Usage Per Type\"\n+    description=\"Native memory usage for a given memory type in the JVM\" period=\"everyChunk\">\n+    <Field type=\"string\" name=\"type\" label=\"Memory Type\" description=\"Type used for the native memory allocation\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Reserved bytes for this type\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Committed bytes for this type\" \/>\n+  <\/Event>\n+\n+  <Event name=\"NativeMemoryUsageTotal\" category=\"Java Virtual Machine, Memory\" label=\"Total Native Memory Usage\"\n+    description=\"Total native memory usage for the JVM. Might not be the exact sum of the NativeMemoryUsage events due to timeing.\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Total amount of reserved bytes for the JVM\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Total amount of committed bytes for the JVM\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"services\/memJfrReporter.hpp\"\n@@ -627,0 +628,8 @@\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsage) {\n+  MemJFRReporter::send_type_events();\n+}\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsageTotal) {\n+  MemJFRReporter::send_total_event();\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"services\/memJfrReporter.hpp\"\n+#include \"services\/memSnapshot.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+Ticks MemJFRSnapshot::_snapshot_timestamp;\n+MemSnapshot* MemJFRSnapshot::_snapshot = nullptr;\n+\n+MemSnapshot* MemJFRSnapshot::get_snapshot() {\n+  Tickspan since_baselined = Ticks::now() - _snapshot_timestamp;\n+\n+  if (_snapshot == nullptr) {\n+    \/\/ No previous snapshot taken, create one.\n+    _snapshot = new MemSnapshot(MemSnapshot::OptionsNoTS);\n+  } else if (since_baselined.milliseconds() < BaselineAgeThreshold) {\n+    \/\/ There is a recent enough snapshot, return it.\n+    return _snapshot;\n+  }\n+\n+  \/\/ Refresh existing snapshot.\n+  _snapshot->snap();\n+  _snapshot_timestamp.stamp();\n+\n+  return _snapshot;\n+}\n+\n+Ticks MemJFRSnapshot::get_timestamp() {\n+  return _snapshot_timestamp;\n+}\n+\n+void MemJFRReporter::send_total_event() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  MemSnapshot* usage = MemJFRSnapshot::get_snapshot();\n+  Ticks timestamp = MemJFRSnapshot::get_timestamp();\n+\n+  EventNativeMemoryUsageTotal event;\n+  event.set_starttime(timestamp);\n+  event.set_reserved(usage->total_reserved());\n+  event.set_committed(usage->total_committed());\n+  event.commit();\n+}\n+\n+void MemJFRReporter::send_type_event(const Ticks& starttime, const char* type, size_t reserved, size_t committed) {\n+  EventNativeMemoryUsage event;\n+  event.set_starttime(starttime);\n+  event.set_type(type);\n+  event.set_reserved(reserved);\n+  event.set_committed(committed);\n+  event.commit();\n+}\n+\n+void MemJFRReporter::send_type_events() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  MemSnapshot* usage = MemJFRSnapshot::get_snapshot();\n+  Ticks timestamp = MemJFRSnapshot::get_timestamp();\n+\n+  for (int index = 0; index < mt_number_of_types; index ++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n+    if (flag == mtNone) {\n+      \/\/ Skip mtNone since it is not really used.\n+      continue;\n+    }\n+    send_type_event(timestamp, NMTUtil::flag_to_name(flag), usage->reserved(flag), usage->committed(flag));\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.cpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMJFRREPORTER_HPP\n+#define SHARE_SERVICES_MEMJFRREPORTER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"services\/memSnapshot.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ The MemJFRReporter and MemJFRBaseline classes are only to be used from the\n+\/\/ thread sending periodic JFR events. So no synchronization is needed.\n+class MemJFRReporter : public AllStatic {\n+private:\n+  static void send_type_event(const Ticks& starttime, const char* tag, size_t reserved, size_t committed);\n+ public:\n+  static void send_total_event();\n+  static void send_type_events();\n+};\n+\n+\/\/ Helper class to avoid taking multiple NMT baselines for\n+\/\/ the two JFR events that are using the same data.\n+class MemJFRSnapshot : public AllStatic {\n+private:\n+  \/\/ The baseline age threshold in millie seconds. If older\n+  \/\/ that this we will make a new baseline.\n+  static const uint64_t BaselineAgeThreshold = 50;\n+\n+  static Ticks _snapshot_timestamp;\n+  static MemSnapshot* _snapshot;\n+\n+public:\n+  static MemSnapshot* get_snapshot();\n+  static Ticks get_timestamp();\n+};\n+\n+#endif \/\/SHARE_SERVICES_MEMJFRREPORTER_HPP\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.hpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n@@ -38,1 +38,1 @@\n-size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+  \/\/ Helper functions\n+  \/\/ Calculate total reserved and committed amount\n+  static size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+  static size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+\n@@ -76,5 +81,0 @@\n-  \/\/ Helper functions\n-  \/\/ Calculate total reserved and committed amount\n-  size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-  size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-\n","filename":"src\/hotspot\/share\/services\/memReporter.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/threadCritical.hpp\"\n+#include \"services\/memSnapshot.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"services\/threadStackTracker.hpp\"\n+#include \"services\/virtualMemoryTracker.hpp\"\n+\n+\/\/ Enabled all options for snapshot.\n+const MemSnapshotOptions MemSnapshot::OptionsAll = { true, true, true };\n+\/\/ Skip expensive thread stacks for snapshot.\n+const MemSnapshotOptions MemSnapshot::OptionsNoTS = { false, true, true };\n+\n+MemSnapshot::MemSnapshot(MemSnapshotOptions options) :\n+    _malloc_snapshot(),\n+    _malloc_total(),\n+    _vm_snapshot(),\n+    _vm_total(),\n+    _snapshot_options(options) { }\n+\n+void MemSnapshot::walk_thread_stacks() {\n+  \/\/ If backed by virtual memory, snapping the thread stacks involves walking\n+  \/\/ them to to figure out how much memory is committed if they are backed by\n+  \/\/ virtual memory. This needs ot happen before we take the snapshot of the\n+  \/\/ virtual memory since it will update this information.\n+  if (ThreadStackTracker::track_as_vm()) {\n+    VirtualMemoryTracker::snapshot_thread_stacks();\n+  }\n+}\n+\n+void MemSnapshot::update_malloc_snapshot() {\n+  \/\/ Thread critical needed keep values in sync, total area size\n+  \/\/ is deducted from mtChunk in the end to give correct values.\n+  ThreadCritical tc;\n+  MallocMemorySnapshot* ms = MallocMemorySummary::as_snapshot();\n+\n+  size_t total_arena_size = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    MallocMemory* mm = ms->by_type(flag);\n+    _malloc_snapshot[i] = mm->malloc_size() + mm->arena_size();\n+    total_arena_size +=  mm->arena_size();\n+  }\n+  assert(total_arena_size == ms->total_arena(), \"Mismatch in accounting\");\n+\n+  \/\/ Total malloc size.\n+  _malloc_total = ms->total();\n+\n+  \/\/ Adjustment due to mtChunk double counting.\n+  _malloc_snapshot[NMTUtil::flag_to_index(mtChunk)] -= total_arena_size;\n+  _malloc_total -= total_arena_size;\n+\n+  \/\/ Adjust mtNMT to include malloc overhead.\n+  _malloc_snapshot[NMTUtil::flag_to_index(mtNMT)] += ms->malloc_overhead();\n+}\n+\n+void MemSnapshot::update_vm_snapshot() {\n+  VirtualMemorySnapshot* vms = VirtualMemorySummary::as_snapshot();\n+\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    VirtualMemory* vm = vms->by_type(flag);\n+    _vm_snapshot[i].reserved = vm->reserved();\n+    _vm_snapshot[i].committed = vm->committed();\n+  }\n+\n+  \/\/ Total virtual memory size.\n+  _vm_total.reserved = vms->total_reserved();\n+  _vm_total.committed = vms->total_committed();\n+}\n+\n+void MemSnapshot::snap() {\n+  if (_snapshot_options.update_thread_stacks) {\n+    walk_thread_stacks();\n+  }\n+\n+  if (_snapshot_options.include_malloc) {\n+    update_malloc_snapshot();\n+  }\n+\n+  if (_snapshot_options.include_vm) {\n+    update_vm_snapshot();\n+  }\n+}\n+\n+size_t MemSnapshot::total_reserved() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t MemSnapshot::total_committed() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t MemSnapshot::reserved(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_snapshot[index] + _vm_snapshot[index].reserved;\n+}\n+\n+size_t MemSnapshot::committed(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_snapshot[index] + _vm_snapshot[index].committed;\n+}\n","filename":"src\/hotspot\/share\/services\/memSnapshot.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMSNAPSHOT_HPP\n+#define SHARE_SERVICES_MEMSNAPSHOT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+struct MemSnapshotPair {\n+  size_t reserved;\n+  size_t committed;\n+};\n+\n+struct MemSnapshotOptions {\n+  bool update_thread_stacks;\n+  bool include_malloc;\n+  bool include_vm;\n+};\n+\n+class MemSnapshot : public CHeapObj<mtNMT> {\n+private:\n+  size_t _malloc_snapshot[mt_number_of_types];\n+  size_t _malloc_total;\n+  MemSnapshotPair _vm_snapshot[mt_number_of_types];\n+  MemSnapshotPair _vm_total;\n+\n+  MemSnapshotOptions _snapshot_options;\n+\n+  void walk_thread_stacks();\n+  void update_malloc_snapshot();\n+  void update_vm_snapshot();\n+\n+public:\n+  static const MemSnapshotOptions OptionsAll;\n+  static const MemSnapshotOptions OptionsNoTS;\n+\n+  MemSnapshot(MemSnapshotOptions options = OptionsAll);\n+  void snap();\n+\n+  size_t total_reserved() const;\n+  size_t total_committed() const;\n+  size_t reserved(MEMFLAGS flag) const;\n+  size_t committed(MEMFLAGS flag) const;\n+};\n+\n+#endif \/\/ SHARE_SERVICES_MEMSNAPSHOT_HPP\n","filename":"src\/hotspot\/share\/services\/memSnapshot.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.opt.NativeMemoryTracking == null\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\n+ *          jdk.management\n+ * @run main\/othervm -XX:NativeMemoryTracking=summary -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents true\n+ * @run main\/othervm -XX:NativeMemoryTracking=off -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents false\n+ *\/\n+public class TestNativeMemoryUsageEvents {\n+    private final static String UsageTotalEvent = EventNames.NativeMemoryUsageTotal;\n+    private final static String UsageEvent = EventNames.NativeMemoryUsage;\n+\n+    private final static int UsagePeriod = 1000;\n+    private final static int K = 1024;\n+\n+    private final static String[] UsageEventTypes = {\n+        \"Java Heap\",\n+        \"Class\",\n+        \"Thread\",\n+        \"Thread Stack\",\n+        \"Code\",\n+        \"GC\",\n+        \"GCCardSet\",\n+        \"Compiler\",\n+        \"JVMCI\",\n+        \"Internal\",\n+        \"Other\",\n+        \"Symbol\",\n+        \"Native Memory Tracking\",\n+        \"Shared class space\",\n+        \"Arena Chunk\",\n+        \"Test\",\n+        \"Tracing\",\n+        \"Logging\",\n+        \"Statistics\",\n+        \"Arguments\",\n+        \"Module\",\n+        \"Safepoint\",\n+        \"Synchronization\",\n+        \"Serviceability\",\n+        \"Metaspace\",\n+        \"String Deduplication\",\n+        \"Object Monitors\"\n+    };\n+\n+    private static ArrayList<byte[]> data = new ArrayList<byte[]>();\n+\n+    private static void generateHeapContents() {\n+        for (int i = 0 ; i < 64; i++) {\n+            for (int j = 0; j < K; j++) {\n+                data.add(new byte[K]);\n+            }\n+        }\n+    }\n+\n+    private static void generateEvents(Recording recording) throws Exception {\n+        \/\/ Enable the two types of events for \"everyChunk\", it will give\n+        \/\/ an event att the beginning of the chunk as well as the end.\n+        recording.enable(UsageEvent).with(\"period\", \"everyChunk\");\n+        recording.enable(UsageTotalEvent).with(\"period\", \"everyChunk\");\n+\n+        recording.start();\n+\n+        \/\/ Generate data to force heap to grow.\n+        generateHeapContents();\n+\n+        recording.stop();\n+    }\n+\n+    private static void verifyExpectedEventTypes(List<RecordedEvent> events) throws Exception {\n+        \/\/ First verify that the number of total usage events is greater than 0.\n+        long numberOfTotal = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageTotalEvent))\n+                .count();\n+\n+        assertGreaterThan(numberOfTotal, 0L, \"Should exist events of type: \" + UsageTotalEvent);\n+\n+        \/\/ Now verify that we got the expected events.\n+        List<String> uniqueEventTypes = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .map(e -> e.getString(\"type\"))\n+                .distinct()\n+                .toList();\n+        for (String type : UsageEventTypes) {\n+            assertTrue(uniqueEventTypes.contains(type), \"Events should include: \" + type);\n+        }\n+    }\n+\n+    private static void verifyHeapGrowth(List<RecordedEvent> events) throws Exception {\n+        List<Long> javaHeapCommitted = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .filter(e -> e.getString(\"type\").equals(\"Java Heap\"))\n+                .map(e -> e.getLong(\"committed\"))\n+                .toList();\n+\n+        \/\/ Verify that the heap has grown between the first and last sample.\n+        long firstSample = javaHeapCommitted.get(0);\n+        long lastSample = javaHeapCommitted.get(javaHeapCommitted.size() - 1);\n+        assertGreaterThan(lastSample, firstSample, \"heap should have grown and NMT should show that\");\n+    }\n+\n+    private static void verifyNoUsageEvents(List<RecordedEvent> events) throws Exception {\n+        Events.hasNotEvent(events, UsageEvent);\n+        Events.hasNotEvent(events, UsageTotalEvent);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ The tests takes a single boolean argument that states wether or not\n+        \/\/ it is run with -XX:NativeMemoryTracking=summary. When tracking is\n+        \/\/ enabled the tests verifies that the correct events are sent and\n+        \/\/ the other way around when turned off.\n+        assertTrue(args.length == 1, \"Must have a single argument\");\n+        boolean nmtEnabled = Boolean.parseBoolean(args[0]);\n+\n+        try (Recording recording = new Recording()) {\n+            generateEvents(recording);\n+\n+            var events = Events.fromRecording(recording);\n+            if (nmtEnabled) {\n+                verifyExpectedEventTypes(events);\n+                verifyHeapGrowth(events);\n+            } else {\n+                verifyNoUsageEvents(events);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeMemoryUsageEvents.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -89,0 +89,2 @@\n+    public static final String NativeMemoryUsage = PREFIX + \"NativeMemoryUsage\";\n+    public static final String NativeMemoryUsageTotal = PREFIX + \"NativeMemoryUsageTotal\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}