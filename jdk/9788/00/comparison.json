{"files":[{"patch":"@@ -34,1 +34,0 @@\n-#include \"classfile\/javaThreadStatus.hpp\"\n@@ -77,1 +76,0 @@\n-#include \"runtime\/javaThread.hpp\"\n@@ -82,1 +80,0 @@\n-#include \"runtime\/threadSMR.hpp\"\n@@ -1631,610 +1628,0 @@\n-\n-\/\/ Note: JDK1.1 and before had a privateInfo_offset field which was used for the\n-\/\/       platform thread structure, and a eetop offset which was used for thread\n-\/\/       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures\n-\/\/       merged, so in the HotSpot VM we just use the eetop field for the thread\n-\/\/       instead of the privateInfo_offset.\n-\/\/\n-\/\/ Note: The stackSize field is only present starting in 1.4.\n-\n-int java_lang_Thread_FieldHolder::_group_offset;\n-int java_lang_Thread_FieldHolder::_priority_offset;\n-int java_lang_Thread_FieldHolder::_stackSize_offset;\n-int java_lang_Thread_FieldHolder::_stillborn_offset;\n-int java_lang_Thread_FieldHolder::_daemon_offset;\n-int java_lang_Thread_FieldHolder::_thread_status_offset;\n-\n-#define THREAD_FIELD_HOLDER_FIELDS_DO(macro) \\\n-  macro(_group_offset,         k, vmSymbols::group_name(),    threadgroup_signature, false); \\\n-  macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature,         false); \\\n-  macro(_stackSize_offset,     k, \"stackSize\",                long_signature,        false); \\\n-  macro(_stillborn_offset,     k, \"stillborn\",                bool_signature,        false); \\\n-  macro(_daemon_offset,        k, vmSymbols::daemon_name(),   bool_signature,        false); \\\n-  macro(_thread_status_offset, k, \"threadStatus\",             int_signature,         false)\n-\n-void java_lang_Thread_FieldHolder::compute_offsets() {\n-  assert(_group_offset == 0, \"offsets should be initialized only once\");\n-\n-  InstanceKlass* k = vmClasses::Thread_FieldHolder_klass();\n-  THREAD_FIELD_HOLDER_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_lang_Thread_FieldHolder::serialize_offsets(SerializeClosure* f) {\n-  THREAD_FIELD_HOLDER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-oop java_lang_Thread_FieldHolder::threadGroup(oop holder) {\n-  return holder->obj_field(_group_offset);\n-}\n-\n-ThreadPriority java_lang_Thread_FieldHolder::priority(oop holder) {\n-  return (ThreadPriority)holder->int_field(_priority_offset);\n-}\n-\n-void java_lang_Thread_FieldHolder::set_priority(oop holder, ThreadPriority priority) {\n-  holder->int_field_put(_priority_offset, priority);\n-}\n-\n-jlong java_lang_Thread_FieldHolder::stackSize(oop holder) {\n-  return holder->long_field(_stackSize_offset);\n-}\n-\n-bool java_lang_Thread_FieldHolder::is_stillborn(oop holder) {\n-  return holder->bool_field(_stillborn_offset) != 0;\n-}\n-\n-void java_lang_Thread_FieldHolder::set_stillborn(oop holder) {\n-  holder->bool_field_put(_stillborn_offset, true);\n-}\n-\n-bool java_lang_Thread_FieldHolder::is_daemon(oop holder) {\n-  return holder->bool_field(_daemon_offset) != 0;\n-}\n-\n-void java_lang_Thread_FieldHolder::set_daemon(oop holder) {\n-  holder->bool_field_put(_daemon_offset, true);\n-}\n-\n-void java_lang_Thread_FieldHolder::set_thread_status(oop holder, JavaThreadStatus status) {\n-  holder->int_field_put(_thread_status_offset, static_cast<int>(status));\n-}\n-\n-JavaThreadStatus java_lang_Thread_FieldHolder::get_thread_status(oop holder) {\n-  return static_cast<JavaThreadStatus>(holder->int_field(_thread_status_offset));\n-}\n-\n-\n-int java_lang_Thread_Constants::_static_VTHREAD_GROUP_offset = 0;\n-int java_lang_Thread_Constants::_static_NOT_SUPPORTED_CLASSLOADER_offset = 0;\n-\n-#define THREAD_CONSTANTS_STATIC_FIELDS_DO(macro) \\\n-  macro(_static_VTHREAD_GROUP_offset,             k, \"VTHREAD_GROUP\",             threadgroup_signature, true); \\\n-  macro(_static_NOT_SUPPORTED_CLASSLOADER_offset, k, \"NOT_SUPPORTED_CLASSLOADER\", classloader_signature, true);\n-\n-void java_lang_Thread_Constants::compute_offsets() {\n-  assert(_static_VTHREAD_GROUP_offset == 0, \"offsets should be initialized only once\");\n-\n-  InstanceKlass* k = vmClasses::Thread_Constants_klass();\n-  THREAD_CONSTANTS_STATIC_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_lang_Thread_Constants::serialize_offsets(SerializeClosure* f) {\n-  THREAD_CONSTANTS_STATIC_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-oop java_lang_Thread_Constants::get_VTHREAD_GROUP() {\n-  InstanceKlass* k = vmClasses::Thread_Constants_klass();\n-  oop base = k->static_field_base_raw();\n-  return base->obj_field(_static_VTHREAD_GROUP_offset);\n-}\n-\n-oop java_lang_Thread_Constants::get_NOT_SUPPORTED_CLASSLOADER() {\n-  InstanceKlass* k = vmClasses::Thread_Constants_klass();\n-  oop base = k->static_field_base_raw();\n-  return base->obj_field(_static_NOT_SUPPORTED_CLASSLOADER_offset);\n-}\n-\n-int java_lang_Thread::_holder_offset;\n-int java_lang_Thread::_name_offset;\n-int java_lang_Thread::_contextClassLoader_offset;\n-int java_lang_Thread::_inheritedAccessControlContext_offset;\n-int java_lang_Thread::_eetop_offset;\n-int java_lang_Thread::_jvmti_thread_state_offset;\n-int java_lang_Thread::_interrupted_offset;\n-int java_lang_Thread::_tid_offset;\n-int java_lang_Thread::_continuation_offset;\n-int java_lang_Thread::_park_blocker_offset;\n-int java_lang_Thread::_extentLocalBindings_offset;\n-JFR_ONLY(int java_lang_Thread::_jfr_epoch_offset;)\n-\n-#define THREAD_FIELDS_DO(macro) \\\n-  macro(_holder_offset,        k, \"holder\", thread_fieldholder_signature, false); \\\n-  macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \\\n-  macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \\\n-  macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \\\n-  macro(_eetop_offset,         k, \"eetop\", long_signature, false); \\\n-  macro(_interrupted_offset,   k, \"interrupted\", bool_signature, false); \\\n-  macro(_tid_offset,           k, \"tid\", long_signature, false); \\\n-  macro(_park_blocker_offset,  k, \"parkBlocker\", object_signature, false); \\\n-  macro(_continuation_offset,  k, \"cont\", continuation_signature, false); \\\n-  macro(_extentLocalBindings_offset, k, \"extentLocalBindings\", object_signature, false);\n-\n-void java_lang_Thread::compute_offsets() {\n-  assert(_holder_offset == 0, \"offsets should be initialized only once\");\n-\n-  InstanceKlass* k = vmClasses::Thread_klass();\n-  THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-  THREAD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_lang_Thread::serialize_offsets(SerializeClosure* f) {\n-  THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-  THREAD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-JavaThread* java_lang_Thread::thread(oop java_thread) {\n-  return (JavaThread*)java_thread->address_field(_eetop_offset);\n-}\n-\n-void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {\n-  java_thread->address_field_put(_eetop_offset, (address)thread);\n-}\n-\n-JvmtiThreadState* java_lang_Thread::jvmti_thread_state(oop java_thread) {\n-  return (JvmtiThreadState*)java_thread->address_field(_jvmti_thread_state_offset);\n-}\n-\n-void java_lang_Thread::set_jvmti_thread_state(oop java_thread, JvmtiThreadState* state) {\n-  java_thread->address_field_put(_jvmti_thread_state_offset, (address)state);\n-}\n-\n-void java_lang_Thread::clear_extentLocalBindings(oop java_thread) {\n-  java_thread->obj_field_put(_extentLocalBindings_offset, NULL);\n-}\n-\n-oop java_lang_Thread::holder(oop java_thread) {\n-    return java_thread->obj_field(_holder_offset);\n-}\n-\n-bool java_lang_Thread::interrupted(oop java_thread) {\n-  \/\/ Make sure the caller can safely access oops.\n-  assert(Thread::current()->is_VM_thread() ||\n-         (JavaThread::current()->thread_state() != _thread_blocked &&\n-          JavaThread::current()->thread_state() != _thread_in_native),\n-         \"Unsafe access to oop\");\n-  return java_thread->bool_field_volatile(_interrupted_offset);\n-}\n-\n-void java_lang_Thread::set_interrupted(oop java_thread, bool val) {\n-  \/\/ Make sure the caller can safely access oops.\n-  assert(Thread::current()->is_VM_thread() ||\n-         (JavaThread::current()->thread_state() != _thread_blocked &&\n-          JavaThread::current()->thread_state() != _thread_in_native),\n-         \"Unsafe access to oop\");\n-  java_thread->bool_field_put_volatile(_interrupted_offset, val);\n-}\n-\n-\n-oop java_lang_Thread::name(oop java_thread) {\n-  return java_thread->obj_field(_name_offset);\n-}\n-\n-\n-void java_lang_Thread::set_name(oop java_thread, oop name) {\n-  java_thread->obj_field_put(_name_offset, name);\n-}\n-\n-\n-ThreadPriority java_lang_Thread::priority(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::priority(holder);\n-}\n-\n-\n-void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_priority(holder, priority);\n-}\n-\n-\n-oop java_lang_Thread::threadGroup(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::threadGroup(holder);\n-}\n-\n-\n-bool java_lang_Thread::is_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::is_stillborn(holder);\n-}\n-\n-\n-\/\/ We never have reason to turn the stillborn bit off\n-void java_lang_Thread::set_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_stillborn(holder);\n-}\n-\n-\n-bool java_lang_Thread::is_alive(oop java_thread) {\n-  JavaThread* thr = java_lang_Thread::thread(java_thread);\n-  return (thr != NULL);\n-}\n-\n-\n-bool java_lang_Thread::is_daemon(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::is_daemon(holder);\n-}\n-\n-\n-void java_lang_Thread::set_daemon(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_daemon(holder);\n-}\n-\n-oop java_lang_Thread::context_class_loader(oop java_thread) {\n-  return java_thread->obj_field(_contextClassLoader_offset);\n-}\n-\n-oop java_lang_Thread::inherited_access_control_context(oop java_thread) {\n-  return java_thread->obj_field(_inheritedAccessControlContext_offset);\n-}\n-\n-\n-jlong java_lang_Thread::stackSize(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::stackSize(holder);\n-}\n-\n-\/\/ Write the thread status value to threadStatus field in java.lang.Thread java class.\n-void java_lang_Thread::set_thread_status(oop java_thread, JavaThreadStatus status) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_thread_status(holder, status);\n-}\n-\n-\/\/ Read thread status value from threadStatus field in java.lang.Thread java class.\n-JavaThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {\n-  \/\/ Make sure the caller is operating on behalf of the VM or is\n-  \/\/ running VM code (state == _thread_in_vm).\n-  assert(Threads_lock->owned_by_self() || Thread::current()->is_VM_thread() ||\n-         JavaThread::current()->thread_state() == _thread_in_vm,\n-         \"Java Thread is not running in vm\");\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  if (holder == NULL) {\n-    return JavaThreadStatus::NEW;  \/\/ Java Thread not initialized\n-  } else {\n-    return java_lang_Thread_FieldHolder::get_thread_status(holder);\n-  }\n-}\n-\n-ByteSize java_lang_Thread::thread_id_offset() {\n-  return in_ByteSize(_tid_offset);\n-}\n-\n-oop java_lang_Thread::park_blocker(oop java_thread) {\n-  return java_thread->obj_field(_park_blocker_offset);\n-}\n-\n-oop java_lang_Thread::async_get_stack_trace(oop java_thread, TRAPS) {\n-  ThreadsListHandle tlh(JavaThread::current());\n-  JavaThread* thread;\n-  bool is_virtual = java_lang_VirtualThread::is_instance(java_thread);\n-  if (is_virtual) {\n-    oop carrier_thread = java_lang_VirtualThread::carrier_thread(java_thread);\n-    if (carrier_thread == NULL) {\n-      return NULL;\n-    }\n-    thread = java_lang_Thread::thread(carrier_thread);\n-  } else {\n-    thread = java_lang_Thread::thread(java_thread);\n-  }\n-  if (thread == NULL) {\n-    return NULL;\n-  }\n-\n-  class GetStackTraceClosure : public HandshakeClosure {\n-  public:\n-    const Handle _java_thread;\n-    int _depth;\n-    bool _retry_handshake;\n-    GrowableArray<Method*>* _methods;\n-    GrowableArray<int>*     _bcis;\n-\n-    GetStackTraceClosure(Handle java_thread) :\n-        HandshakeClosure(\"GetStackTraceClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false) {\n-      \/\/ Pick some initial length\n-      int init_length = MaxJavaStackTraceDepth \/ 2;\n-      _methods = new GrowableArray<Method*>(init_length);\n-      _bcis = new GrowableArray<int>(init_length);\n-    }\n-\n-    bool read_reset_retry() {\n-      bool ret = _retry_handshake;\n-      \/\/ If we re-execute the handshake this method need to return false\n-      \/\/ when the handshake cannot be performed. (E.g. thread terminating)\n-      _retry_handshake = false;\n-      return ret;\n-    }\n-\n-    void do_thread(Thread* th) {\n-      if (!Thread::current()->is_Java_thread()) {\n-        _retry_handshake = true;\n-        return;\n-      }\n-\n-      JavaThread* thread = JavaThread::cast(th);\n-\n-      if (!thread->has_last_Java_frame()) {\n-        return;\n-      }\n-\n-      bool carrier = false;\n-      if (java_lang_VirtualThread::is_instance(_java_thread())) {\n-        \/\/ if (thread->vthread() != _java_thread()) \/\/ We might be inside a System.executeOnCarrierThread\n-        const ContinuationEntry* ce = thread->vthread_continuation();\n-        if (ce == nullptr || ce->cont_oop() != java_lang_VirtualThread::continuation(_java_thread())) {\n-          return; \/\/ not mounted\n-        }\n-      } else {\n-        carrier = (thread->vthread_continuation() != NULL);\n-      }\n-\n-      const int max_depth = MaxJavaStackTraceDepth;\n-      const bool skip_hidden = !ShowHiddenFrames;\n-\n-      int total_count = 0;\n-      for (vframeStream vfst(thread, false, false, carrier); \/\/ we don't process frames as we don't care about oops\n-           !vfst.at_end() && (max_depth == 0 || max_depth != total_count);\n-           vfst.next()) {\n-\n-        if (skip_hidden && (vfst.method()->is_hidden() ||\n-                            vfst.method()->is_continuation_enter_intrinsic())) {\n-          continue;\n-        }\n-\n-        _methods->push(vfst.method());\n-        _bcis->push(vfst.bci());\n-        total_count++;\n-      }\n-\n-      _depth = total_count;\n-    }\n-  };\n-\n-  \/\/ Handshake with target\n-  ResourceMark rm(THREAD);\n-  HandleMark   hm(THREAD);\n-  GetStackTraceClosure gstc(Handle(THREAD, java_thread));\n-  do {\n-   Handshake::execute(&gstc, &tlh, thread);\n-  } while (gstc.read_reset_retry());\n-\n-  \/\/ Stop if no stack trace is found.\n-  if (gstc._depth == 0) {\n-    return NULL;\n-  }\n-\n-  \/\/ Convert to StackTraceElement array\n-  InstanceKlass* k = vmClasses::StackTraceElement_klass();\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n-  if (k->should_be_initialized()) {\n-    k->initialize(CHECK_NULL);\n-  }\n-  objArrayHandle trace = oopFactory::new_objArray_handle(k, gstc._depth, CHECK_NULL);\n-\n-  for (int i = 0; i < gstc._depth; i++) {\n-    methodHandle method(THREAD, gstc._methods->at(i));\n-    oop element = java_lang_StackTraceElement::create(method,\n-                                                      gstc._bcis->at(i),\n-                                                      CHECK_NULL);\n-    trace->obj_at_put(i, element);\n-  }\n-\n-  return trace();\n-}\n-\n-const char* java_lang_Thread::thread_status_name(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  JavaThreadStatus status = java_lang_Thread_FieldHolder::get_thread_status(holder);\n-  switch (status) {\n-    case JavaThreadStatus::NEW                      : return \"NEW\";\n-    case JavaThreadStatus::RUNNABLE                 : return \"RUNNABLE\";\n-    case JavaThreadStatus::SLEEPING                 : return \"TIMED_WAITING (sleeping)\";\n-    case JavaThreadStatus::IN_OBJECT_WAIT           : return \"WAITING (on object monitor)\";\n-    case JavaThreadStatus::IN_OBJECT_WAIT_TIMED     : return \"TIMED_WAITING (on object monitor)\";\n-    case JavaThreadStatus::PARKED                   : return \"WAITING (parking)\";\n-    case JavaThreadStatus::PARKED_TIMED             : return \"TIMED_WAITING (parking)\";\n-    case JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER : return \"BLOCKED (on object monitor)\";\n-    case JavaThreadStatus::TERMINATED               : return \"TERMINATED\";\n-    default                       : return \"UNKNOWN\";\n-  };\n-}\n-int java_lang_ThreadGroup::_parent_offset;\n-int java_lang_ThreadGroup::_name_offset;\n-int java_lang_ThreadGroup::_maxPriority_offset;\n-int java_lang_ThreadGroup::_daemon_offset;\n-int java_lang_ThreadGroup::_ngroups_offset;\n-int java_lang_ThreadGroup::_groups_offset;\n-int java_lang_ThreadGroup::_nweaks_offset;\n-int java_lang_ThreadGroup::_weaks_offset;\n-\n-oop  java_lang_ThreadGroup::parent(oop java_thread_group) {\n-  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n-  return java_thread_group->obj_field(_parent_offset);\n-}\n-\n-\/\/ (\"name as oop\" accessor is not necessary)\n-\n-const char* java_lang_ThreadGroup::name(oop java_thread_group) {\n-  oop name = java_thread_group->obj_field(_name_offset);\n-  \/\/ ThreadGroup.name can be null\n-  if (name != NULL) {\n-    return java_lang_String::as_utf8_string(name);\n-  }\n-  return NULL;\n-}\n-\n-ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {\n-  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n-  return (ThreadPriority) java_thread_group->int_field(_maxPriority_offset);\n-}\n-\n-bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {\n-  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n-  return java_thread_group->bool_field(_daemon_offset) != 0;\n-}\n-\n-int java_lang_ThreadGroup::ngroups(oop java_thread_group) {\n-  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n-  return java_thread_group->int_field(_ngroups_offset);\n-}\n-\n-objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {\n-  oop groups = java_thread_group->obj_field(_groups_offset);\n-  assert(groups == NULL || groups->is_objArray(), \"just checking\"); \/\/ Todo: Add better type checking code\n-  return objArrayOop(groups);\n-}\n-\n-int java_lang_ThreadGroup::nweaks(oop java_thread_group) {\n-  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n-  return java_thread_group->int_field(_nweaks_offset);\n-}\n-\n-objArrayOop java_lang_ThreadGroup::weaks(oop java_thread_group) {\n-  oop weaks = java_thread_group->obj_field(_weaks_offset);\n-  assert(weaks == NULL || weaks->is_objArray(), \"just checking\");\n-  return objArrayOop(weaks);\n-}\n-\n-#define THREADGROUP_FIELDS_DO(macro) \\\n-  macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,         false); \\\n-  macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,              false); \\\n-  macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,                 false); \\\n-  macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,                false); \\\n-  macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,                 false); \\\n-  macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature,   false); \\\n-  macro(_nweaks_offset,      k, vmSymbols::nweaks_name(),      int_signature,                 false); \\\n-  macro(_weaks_offset,       k, vmSymbols::weaks_name(),       weakreference_array_signature, false);\n-\n-void java_lang_ThreadGroup::compute_offsets() {\n-  assert(_parent_offset == 0, \"offsets should be initialized only once\");\n-\n-  InstanceKlass* k = vmClasses::ThreadGroup_klass();\n-  THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {\n-  THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-\n-\/\/ java_lang_VirtualThread\n-\n-int java_lang_VirtualThread::static_notify_jvmti_events_offset;\n-int java_lang_VirtualThread::static_vthread_scope_offset;\n-int java_lang_VirtualThread::_carrierThread_offset;\n-int java_lang_VirtualThread::_continuation_offset;\n-int java_lang_VirtualThread::_state_offset;\n-\n-#define VTHREAD_FIELDS_DO(macro) \\\n-  macro(static_notify_jvmti_events_offset, k, \"notifyJvmtiEvents\",  bool_signature,              true);  \\\n-  macro(static_vthread_scope_offset,       k, \"VTHREAD_SCOPE\",      continuationscope_signature, true);  \\\n-  macro(_carrierThread_offset,             k, \"carrierThread\",      thread_signature,            false); \\\n-  macro(_continuation_offset,              k, \"cont\",               continuation_signature,      false); \\\n-  macro(_state_offset,                     k, \"state\",              int_signature,               false)\n-\n-static bool vthread_notify_jvmti_events = JNI_FALSE;\n-\n-void java_lang_VirtualThread::compute_offsets() {\n-  InstanceKlass* k = vmClasses::VirtualThread_klass();\n-  VTHREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-void java_lang_VirtualThread::init_static_notify_jvmti_events() {\n-  if (vthread_notify_jvmti_events) {\n-    InstanceKlass* ik = vmClasses::VirtualThread_klass();\n-    oop base = ik->static_field_base_raw();\n-    base->release_bool_field_put(static_notify_jvmti_events_offset, vthread_notify_jvmti_events);\n-  }\n-}\n-\n-bool java_lang_VirtualThread::is_instance(oop obj) {\n-  return obj != NULL && is_subclass(obj->klass());\n-}\n-\n-oop java_lang_VirtualThread::carrier_thread(oop vthread) {\n-  oop thread = vthread->obj_field(_carrierThread_offset);\n-  return thread;\n-}\n-\n-oop java_lang_VirtualThread::continuation(oop vthread) {\n-  oop cont = vthread->obj_field(_continuation_offset);\n-  return cont;\n-}\n-\n-int java_lang_VirtualThread::state(oop vthread) {\n-  return vthread->int_field_acquire(_state_offset);\n-}\n-\n-JavaThreadStatus java_lang_VirtualThread::map_state_to_thread_status(int state) {\n-  JavaThreadStatus status = JavaThreadStatus::NEW;\n-  switch (state) {\n-    case NEW :\n-      status = JavaThreadStatus::NEW;\n-      break;\n-    case STARTED :\n-    case RUNNABLE :\n-    case RUNNABLE_SUSPENDED :\n-    case RUNNING :\n-    case PARKING :\n-    case YIELDING :\n-      status = JavaThreadStatus::RUNNABLE;\n-      break;\n-    case PARKED :\n-    case PARKED_SUSPENDED :\n-    case PINNED :\n-      status = JavaThreadStatus::PARKED;\n-      break;\n-    case TERMINATED :\n-      status = JavaThreadStatus::TERMINATED;\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-  return status;\n-}\n-\n-#if INCLUDE_CDS\n-void java_lang_VirtualThread::serialize_offsets(SerializeClosure* f) {\n-   VTHREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-bool java_lang_VirtualThread::notify_jvmti_events() {\n-  return vthread_notify_jvmti_events == JNI_TRUE;\n-}\n-\n-void java_lang_VirtualThread::set_notify_jvmti_events(bool enable) {\n-  vthread_notify_jvmti_events = enable;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":613,"binary":false,"changes":613,"status":"modified"},{"patch":"@@ -336,236 +336,0 @@\n-\/\/ Interface to java.lang.Thread objects\n-\n-#define THREAD_INJECTED_FIELDS(macro)                                  \\\n-  macro(java_lang_Thread, jvmti_thread_state, intptr_signature, false) \\\n-  JFR_ONLY(macro(java_lang_Thread, jfr_epoch, short_signature, false))\n-\n-class java_lang_Thread : AllStatic {\n-  friend class java_lang_VirtualThread;\n- private:\n-  \/\/ Note that for this class the layout changed between JDK1.2 and JDK1.3,\n-  \/\/ so we compute the offsets at startup rather than hard-wiring them.\n-  static int _holder_offset;\n-  static int _name_offset;\n-  static int _contextClassLoader_offset;\n-  static int _inheritedAccessControlContext_offset;\n-  static int _eetop_offset;\n-  static int _jvmti_thread_state_offset;\n-  static int _interrupted_offset;\n-  static int _tid_offset;\n-  static int _continuation_offset;\n-  static int _park_blocker_offset;\n-  static int _extentLocalBindings_offset;\n-  JFR_ONLY(static int _jfr_epoch_offset;)\n-\n-  static void compute_offsets();\n-\n- public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n-  \/\/ Returns the JavaThread associated with the thread obj\n-  static JavaThread* thread(oop java_thread);\n-  \/\/ Set JavaThread for instance\n-  static void set_thread(oop java_thread, JavaThread* thread);\n-  \/\/ FieldHolder\n-  static oop holder(oop java_thread);\n-  \/\/ Interrupted status\n-  static bool interrupted(oop java_thread);\n-  static void set_interrupted(oop java_thread, bool val);\n-  \/\/ Name\n-  static oop name(oop java_thread);\n-  static void set_name(oop java_thread, oop name);\n-  \/\/ Priority\n-  static ThreadPriority priority(oop java_thread);\n-  static void set_priority(oop java_thread, ThreadPriority priority);\n-  \/\/ Thread group\n-  static oop  threadGroup(oop java_thread);\n-  \/\/ Stillborn\n-  static bool is_stillborn(oop java_thread);\n-  static void set_stillborn(oop java_thread);\n-  \/\/ Alive (NOTE: this is not really a field, but provides the correct\n-  \/\/ definition without doing a Java call)\n-  static bool is_alive(oop java_thread);\n-  \/\/ Daemon\n-  static bool is_daemon(oop java_thread);\n-  static void set_daemon(oop java_thread);\n-  \/\/ Context ClassLoader\n-  static oop context_class_loader(oop java_thread);\n-  \/\/ Control context\n-  static oop inherited_access_control_context(oop java_thread);\n-  \/\/ Stack size hint\n-  static jlong stackSize(oop java_thread);\n-  \/\/ Thread ID\n-  static int64_t thread_id(oop java_thread);\n-  static ByteSize thread_id_offset();\n-  \/\/ Continuation\n-  static inline oop continuation(oop java_thread);\n-\n-  static JvmtiThreadState* jvmti_thread_state(oop java_thread);\n-  static void set_jvmti_thread_state(oop java_thread, JvmtiThreadState* state);\n-\n-  \/\/ Clear all extent local bindings on error\n-  static void clear_extentLocalBindings(oop java_thread);\n-\n-  \/\/ Blocker object responsible for thread parking\n-  static oop park_blocker(oop java_thread);\n-\n-  \/\/ Write thread status info to threadStatus field of java.lang.Thread.\n-  static void set_thread_status(oop java_thread_oop, JavaThreadStatus status);\n-  \/\/ Read thread status info from threadStatus field of java.lang.Thread.\n-  static JavaThreadStatus get_thread_status(oop java_thread_oop);\n-\n-  static const char*  thread_status_name(oop java_thread_oop);\n-\n-  \/\/ Fill in current stack trace, can cause GC\n-  static oop async_get_stack_trace(oop java_thread, TRAPS);\n-\n-  JFR_ONLY(static u2 jfr_epoch(oop java_thread);)\n-  JFR_ONLY(static void set_jfr_epoch(oop java_thread, u2 epoch);)\n-  JFR_ONLY(static int jfr_epoch_offset() { CHECK_INIT(_jfr_epoch_offset); })\n-\n-  \/\/ Debugging\n-  friend class JavaClasses;\n-};\n-\n-\/\/ Interface to java.lang.Thread$FieldHolder objects\n-\n-class java_lang_Thread_FieldHolder : AllStatic {\n- private:\n-  static int _group_offset;\n-  static int _priority_offset;\n-  static int _stackSize_offset;\n-  static int _stillborn_offset;\n-  static int _daemon_offset;\n-  static int _thread_status_offset;\n-\n-  static void compute_offsets();\n-\n- public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n-  static oop threadGroup(oop holder);\n-\n-  static ThreadPriority priority(oop holder);\n-  static void set_priority(oop holder, ThreadPriority priority);\n-\n-  static jlong stackSize(oop holder);\n-\n-  static bool is_stillborn(oop holder);\n-  static void set_stillborn(oop holder);\n-\n-  static bool is_daemon(oop holder);\n-  static void set_daemon(oop holder);\n-\n-  static void set_thread_status(oop holder, JavaThreadStatus);\n-  static JavaThreadStatus get_thread_status(oop holder);\n-\n-  friend class JavaClasses;\n-};\n-\n-\/\/ Interface to java.lang.Thread$Constants objects\n-\n-class java_lang_Thread_Constants : AllStatic {\n- private:\n-  static int _static_VTHREAD_GROUP_offset;\n-  static int _static_NOT_SUPPORTED_CLASSLOADER_offset;\n-\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n- public:\n-  static oop get_VTHREAD_GROUP();\n-  static oop get_NOT_SUPPORTED_CLASSLOADER();\n-\n-  friend class JavaClasses;\n-};\n-\n-\/\/ Interface to java.lang.ThreadGroup objects\n-\n-class java_lang_ThreadGroup : AllStatic {\n- private:\n-  static int _parent_offset;\n-  static int _name_offset;\n-  static int _maxPriority_offset;\n-  static int _daemon_offset;\n-\n-  static int _ngroups_offset;\n-  static int _groups_offset;\n-  static int _nweaks_offset;\n-  static int _weaks_offset;\n-\n-  static void compute_offsets();\n-\n- public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n-  \/\/ parent ThreadGroup\n-  static oop parent(oop java_thread_group);\n-  \/\/ name\n-  static const char* name(oop java_thread_group);\n-  \/\/ maxPriority in group\n-  static ThreadPriority maxPriority(oop java_thread_group);\n-  \/\/ Daemon\n-  static bool is_daemon(oop java_thread_group);\n-\n-  \/\/ Number of strongly reachable thread groups\n-  static int ngroups(oop java_thread_group);\n-  \/\/ Strongly reachable thread groups\n-  static objArrayOop groups(oop java_thread_group);\n-  \/\/ Number of weakly reachable thread groups\n-  static int nweaks(oop java_thread_group);\n-  \/\/ Weakly reachable thread groups\n-  static objArrayOop weaks(oop java_thread_group);\n-\n-  \/\/ Debugging\n-  friend class JavaClasses;\n-};\n-\n-\n-\/\/ Interface to java.lang.VirtualThread objects\n-\n-class java_lang_VirtualThread : AllStatic {\n- private:\n-  static int static_notify_jvmti_events_offset;\n-  static int static_vthread_scope_offset;\n-  static int _carrierThread_offset;\n-  static int _continuation_offset;\n-  static int _state_offset;\n-  JFR_ONLY(static int _jfr_epoch_offset;)\n- public:\n-  enum {\n-    NEW          = 0,\n-    STARTED      = 1,\n-    RUNNABLE     = 2,\n-    RUNNING      = 3,\n-    PARKING      = 4,\n-    PARKED       = 5,\n-    PINNED       = 6,\n-    YIELDING     = 7,\n-    TERMINATED   = 99,\n-\n-    \/\/ can be suspended from scheduling when unmounted\n-    SUSPENDED    = 1 << 8,\n-    RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED),\n-    PARKED_SUSPENDED   = (PARKED | SUSPENDED)\n-  };\n-\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n-  \/\/ Testers\n-  static bool is_subclass(Klass* klass) {\n-    return klass->is_subclass_of(vmClasses::VirtualThread_klass());\n-  }\n-  static bool is_instance(oop obj);\n-\n-  static oop vthread_scope();\n-  static oop carrier_thread(oop vthread);\n-  static oop continuation(oop vthread);\n-  static int state(oop vthread);\n-  static JavaThreadStatus map_state_to_thread_status(int state);\n-  static bool notify_jvmti_events();\n-  static void set_notify_jvmti_events(bool enable);\n-  static void init_static_notify_jvmti_events();\n-};\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":236,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -198,24 +198,0 @@\n-inline oop java_lang_Thread::continuation(oop java_thread) {\n-  return java_thread->obj_field(_continuation_offset);\n-}\n-\n-inline int64_t java_lang_Thread::thread_id(oop java_thread) {\n-  return java_thread->long_field(_tid_offset);\n-}\n-\n-inline oop java_lang_VirtualThread::vthread_scope() {\n-  oop base = vmClasses::VirtualThread_klass()->static_field_base_raw();\n-  return base->obj_field(static_vthread_scope_offset);\n-}\n-\n-#if INCLUDE_JFR\n-inline u2 java_lang_Thread::jfr_epoch(oop ref) {\n-  return ref->short_field(_jfr_epoch_offset);\n-}\n-\n-inline void java_lang_Thread::set_jfr_epoch(oop ref, u2 epoch) {\n-  ref->short_field_put(_jfr_epoch_offset, epoch);\n-}\n-#endif \/\/ INCLUDE_JFR\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/threadJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/javaClassesImpl.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -67,0 +66,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadId.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/threadJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"classfile\/javaThreadStatus.hpp\"\n@@ -84,0 +83,1 @@\n+#include \"runtime\/javaThreadStatus.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/threadJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n-#include \"classfile\/javaThreadStatus.hpp\"\n@@ -72,0 +70,1 @@\n+#include \"runtime\/javaThreadStatus.hpp\"\n@@ -83,0 +82,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -41,0 +41,1 @@\n+#include \"runtime\/threadJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n-#ifndef SHARE_CLASSFILE_JAVATHREADSTATUS_HPP\n-#define SHARE_CLASSFILE_JAVATHREADSTATUS_HPP\n+#ifndef SHARE_RUNTIME_JAVATHREADSTATUS_HPP\n+#define SHARE_RUNTIME_JAVATHREADSTATUS_HPP\n@@ -62,1 +62,1 @@\n-#endif \/\/ SHARE_CLASSFILE_JAVATHREADSTATUS_HPP\n+#endif \/\/ SHARE_RUNTIME_JAVATHREADSTATUS_HPP\n","filename":"src\/hotspot\/share\/runtime\/javaThreadStatus.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/hotspot\/share\/classfile\/javaThreadStatus.hpp","status":"renamed"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/javaThreadStatus.hpp\"\n@@ -41,0 +39,1 @@\n+#include \"runtime\/javaThreadStatus.hpp\"\n@@ -47,0 +46,1 @@\n+#include \"runtime\/threadJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,649 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClassesImpl.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/continuationJavaClasses.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/javaThreadStatus.hpp\"\n+#include \"runtime\/threadJavaClasses.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+\n+\n+\/\/ Note: JDK1.1 and before had a privateInfo_offset field which was used for the\n+\/\/       platform thread structure, and a eetop offset which was used for thread\n+\/\/       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures\n+\/\/       merged, so in the HotSpot VM we just use the eetop field for the thread\n+\/\/       instead of the privateInfo_offset.\n+\/\/\n+\/\/ Note: The stackSize field is only present starting in 1.4.\n+\n+int java_lang_Thread_FieldHolder::_group_offset;\n+int java_lang_Thread_FieldHolder::_priority_offset;\n+int java_lang_Thread_FieldHolder::_stackSize_offset;\n+int java_lang_Thread_FieldHolder::_stillborn_offset;\n+int java_lang_Thread_FieldHolder::_daemon_offset;\n+int java_lang_Thread_FieldHolder::_thread_status_offset;\n+\n+#define THREAD_FIELD_HOLDER_FIELDS_DO(macro) \\\n+  macro(_group_offset,         k, vmSymbols::group_name(),    threadgroup_signature, false); \\\n+  macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature,         false); \\\n+  macro(_stackSize_offset,     k, \"stackSize\",                long_signature,        false); \\\n+  macro(_stillborn_offset,     k, \"stillborn\",                bool_signature,        false); \\\n+  macro(_daemon_offset,        k, vmSymbols::daemon_name(),   bool_signature,        false); \\\n+  macro(_thread_status_offset, k, \"threadStatus\",             int_signature,         false)\n+\n+void java_lang_Thread_FieldHolder::compute_offsets() {\n+  assert(_group_offset == 0, \"offsets should be initialized only once\");\n+\n+  InstanceKlass* k = vmClasses::Thread_FieldHolder_klass();\n+  THREAD_FIELD_HOLDER_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_Thread_FieldHolder::serialize_offsets(SerializeClosure* f) {\n+  THREAD_FIELD_HOLDER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+oop java_lang_Thread_FieldHolder::threadGroup(oop holder) {\n+  return holder->obj_field(_group_offset);\n+}\n+\n+ThreadPriority java_lang_Thread_FieldHolder::priority(oop holder) {\n+  return (ThreadPriority)holder->int_field(_priority_offset);\n+}\n+\n+void java_lang_Thread_FieldHolder::set_priority(oop holder, ThreadPriority priority) {\n+  holder->int_field_put(_priority_offset, priority);\n+}\n+\n+jlong java_lang_Thread_FieldHolder::stackSize(oop holder) {\n+  return holder->long_field(_stackSize_offset);\n+}\n+\n+bool java_lang_Thread_FieldHolder::is_stillborn(oop holder) {\n+  return holder->bool_field(_stillborn_offset) != 0;\n+}\n+\n+void java_lang_Thread_FieldHolder::set_stillborn(oop holder) {\n+  holder->bool_field_put(_stillborn_offset, true);\n+}\n+\n+bool java_lang_Thread_FieldHolder::is_daemon(oop holder) {\n+  return holder->bool_field(_daemon_offset) != 0;\n+}\n+\n+void java_lang_Thread_FieldHolder::set_daemon(oop holder) {\n+  holder->bool_field_put(_daemon_offset, true);\n+}\n+\n+void java_lang_Thread_FieldHolder::set_thread_status(oop holder, JavaThreadStatus status) {\n+  holder->int_field_put(_thread_status_offset, static_cast<int>(status));\n+}\n+\n+JavaThreadStatus java_lang_Thread_FieldHolder::get_thread_status(oop holder) {\n+  return static_cast<JavaThreadStatus>(holder->int_field(_thread_status_offset));\n+}\n+\n+\n+int java_lang_Thread_Constants::_static_VTHREAD_GROUP_offset = 0;\n+int java_lang_Thread_Constants::_static_NOT_SUPPORTED_CLASSLOADER_offset = 0;\n+\n+#define THREAD_CONSTANTS_STATIC_FIELDS_DO(macro) \\\n+  macro(_static_VTHREAD_GROUP_offset,             k, \"VTHREAD_GROUP\",             threadgroup_signature, true); \\\n+  macro(_static_NOT_SUPPORTED_CLASSLOADER_offset, k, \"NOT_SUPPORTED_CLASSLOADER\", classloader_signature, true);\n+\n+void java_lang_Thread_Constants::compute_offsets() {\n+  assert(_static_VTHREAD_GROUP_offset == 0, \"offsets should be initialized only once\");\n+\n+  InstanceKlass* k = vmClasses::Thread_Constants_klass();\n+  THREAD_CONSTANTS_STATIC_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_Thread_Constants::serialize_offsets(SerializeClosure* f) {\n+  THREAD_CONSTANTS_STATIC_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+oop java_lang_Thread_Constants::get_VTHREAD_GROUP() {\n+  InstanceKlass* k = vmClasses::Thread_Constants_klass();\n+  oop base = k->static_field_base_raw();\n+  return base->obj_field(_static_VTHREAD_GROUP_offset);\n+}\n+\n+oop java_lang_Thread_Constants::get_NOT_SUPPORTED_CLASSLOADER() {\n+  InstanceKlass* k = vmClasses::Thread_Constants_klass();\n+  oop base = k->static_field_base_raw();\n+  return base->obj_field(_static_NOT_SUPPORTED_CLASSLOADER_offset);\n+}\n+\n+int java_lang_Thread::_holder_offset;\n+int java_lang_Thread::_name_offset;\n+int java_lang_Thread::_contextClassLoader_offset;\n+int java_lang_Thread::_inheritedAccessControlContext_offset;\n+int java_lang_Thread::_eetop_offset;\n+int java_lang_Thread::_jvmti_thread_state_offset;\n+int java_lang_Thread::_interrupted_offset;\n+int java_lang_Thread::_tid_offset;\n+int java_lang_Thread::_continuation_offset;\n+int java_lang_Thread::_park_blocker_offset;\n+int java_lang_Thread::_extentLocalBindings_offset;\n+JFR_ONLY(int java_lang_Thread::_jfr_epoch_offset;)\n+\n+#define THREAD_FIELDS_DO(macro) \\\n+  macro(_holder_offset,        k, \"holder\", thread_fieldholder_signature, false); \\\n+  macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \\\n+  macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \\\n+  macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \\\n+  macro(_eetop_offset,         k, \"eetop\", long_signature, false); \\\n+  macro(_interrupted_offset,   k, \"interrupted\", bool_signature, false); \\\n+  macro(_tid_offset,           k, \"tid\", long_signature, false); \\\n+  macro(_park_blocker_offset,  k, \"parkBlocker\", object_signature, false); \\\n+  macro(_continuation_offset,  k, \"cont\", continuation_signature, false); \\\n+  macro(_extentLocalBindings_offset, k, \"extentLocalBindings\", object_signature, false);\n+\n+void java_lang_Thread::compute_offsets() {\n+  assert(_holder_offset == 0, \"offsets should be initialized only once\");\n+\n+  InstanceKlass* k = vmClasses::Thread_klass();\n+  THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+  THREAD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_Thread::serialize_offsets(SerializeClosure* f) {\n+  THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+  THREAD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+JavaThread* java_lang_Thread::thread(oop java_thread) {\n+  return (JavaThread*)java_thread->address_field(_eetop_offset);\n+}\n+\n+void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {\n+  java_thread->address_field_put(_eetop_offset, (address)thread);\n+}\n+\n+JvmtiThreadState* java_lang_Thread::jvmti_thread_state(oop java_thread) {\n+  return (JvmtiThreadState*)java_thread->address_field(_jvmti_thread_state_offset);\n+}\n+\n+void java_lang_Thread::set_jvmti_thread_state(oop java_thread, JvmtiThreadState* state) {\n+  java_thread->address_field_put(_jvmti_thread_state_offset, (address)state);\n+}\n+\n+void java_lang_Thread::clear_extentLocalBindings(oop java_thread) {\n+  java_thread->obj_field_put(_extentLocalBindings_offset, NULL);\n+}\n+\n+oop java_lang_Thread::holder(oop java_thread) {\n+    return java_thread->obj_field(_holder_offset);\n+}\n+\n+bool java_lang_Thread::interrupted(oop java_thread) {\n+  \/\/ Make sure the caller can safely access oops.\n+  assert(Thread::current()->is_VM_thread() ||\n+         (JavaThread::current()->thread_state() != _thread_blocked &&\n+          JavaThread::current()->thread_state() != _thread_in_native),\n+         \"Unsafe access to oop\");\n+  return java_thread->bool_field_volatile(_interrupted_offset);\n+}\n+\n+void java_lang_Thread::set_interrupted(oop java_thread, bool val) {\n+  \/\/ Make sure the caller can safely access oops.\n+  assert(Thread::current()->is_VM_thread() ||\n+         (JavaThread::current()->thread_state() != _thread_blocked &&\n+          JavaThread::current()->thread_state() != _thread_in_native),\n+         \"Unsafe access to oop\");\n+  java_thread->bool_field_put_volatile(_interrupted_offset, val);\n+}\n+\n+\n+oop java_lang_Thread::name(oop java_thread) {\n+  return java_thread->obj_field(_name_offset);\n+}\n+\n+\n+void java_lang_Thread::set_name(oop java_thread, oop name) {\n+  java_thread->obj_field_put(_name_offset, name);\n+}\n+\n+\n+ThreadPriority java_lang_Thread::priority(oop java_thread) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  return java_lang_Thread_FieldHolder::priority(holder);\n+}\n+\n+\n+void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  java_lang_Thread_FieldHolder::set_priority(holder, priority);\n+}\n+\n+\n+oop java_lang_Thread::threadGroup(oop java_thread) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  return java_lang_Thread_FieldHolder::threadGroup(holder);\n+}\n+\n+\n+bool java_lang_Thread::is_stillborn(oop java_thread) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  return java_lang_Thread_FieldHolder::is_stillborn(holder);\n+}\n+\n+\n+\/\/ We never have reason to turn the stillborn bit off\n+void java_lang_Thread::set_stillborn(oop java_thread) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  java_lang_Thread_FieldHolder::set_stillborn(holder);\n+}\n+\n+\n+bool java_lang_Thread::is_alive(oop java_thread) {\n+  JavaThread* thr = java_lang_Thread::thread(java_thread);\n+  return (thr != NULL);\n+}\n+\n+\n+bool java_lang_Thread::is_daemon(oop java_thread) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  return java_lang_Thread_FieldHolder::is_daemon(holder);\n+}\n+\n+\n+void java_lang_Thread::set_daemon(oop java_thread) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  java_lang_Thread_FieldHolder::set_daemon(holder);\n+}\n+\n+oop java_lang_Thread::context_class_loader(oop java_thread) {\n+  return java_thread->obj_field(_contextClassLoader_offset);\n+}\n+\n+oop java_lang_Thread::inherited_access_control_context(oop java_thread) {\n+  return java_thread->obj_field(_inheritedAccessControlContext_offset);\n+}\n+\n+\n+jlong java_lang_Thread::stackSize(oop java_thread) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  return java_lang_Thread_FieldHolder::stackSize(holder);\n+}\n+\n+\/\/ Write the thread status value to threadStatus field in java.lang.Thread java class.\n+void java_lang_Thread::set_thread_status(oop java_thread, JavaThreadStatus status) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  java_lang_Thread_FieldHolder::set_thread_status(holder, status);\n+}\n+\n+\/\/ Read thread status value from threadStatus field in java.lang.Thread java class.\n+JavaThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {\n+  \/\/ Make sure the caller is operating on behalf of the VM or is\n+  \/\/ running VM code (state == _thread_in_vm).\n+  assert(Threads_lock->owned_by_self() || Thread::current()->is_VM_thread() ||\n+         JavaThread::current()->thread_state() == _thread_in_vm,\n+         \"Java Thread is not running in vm\");\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  if (holder == NULL) {\n+    return JavaThreadStatus::NEW;  \/\/ Java Thread not initialized\n+  } else {\n+    return java_lang_Thread_FieldHolder::get_thread_status(holder);\n+  }\n+}\n+\n+ByteSize java_lang_Thread::thread_id_offset() {\n+  return in_ByteSize(_tid_offset);\n+}\n+\n+oop java_lang_Thread::park_blocker(oop java_thread) {\n+  return java_thread->obj_field(_park_blocker_offset);\n+}\n+\n+oop java_lang_Thread::async_get_stack_trace(oop java_thread, TRAPS) {\n+  ThreadsListHandle tlh(JavaThread::current());\n+  JavaThread* thread;\n+  bool is_virtual = java_lang_VirtualThread::is_instance(java_thread);\n+  if (is_virtual) {\n+    oop carrier_thread = java_lang_VirtualThread::carrier_thread(java_thread);\n+    if (carrier_thread == NULL) {\n+      return NULL;\n+    }\n+    thread = java_lang_Thread::thread(carrier_thread);\n+  } else {\n+    thread = java_lang_Thread::thread(java_thread);\n+  }\n+  if (thread == NULL) {\n+    return NULL;\n+  }\n+\n+  class GetStackTraceClosure : public HandshakeClosure {\n+  public:\n+    const Handle _java_thread;\n+    int _depth;\n+    bool _retry_handshake;\n+    GrowableArray<Method*>* _methods;\n+    GrowableArray<int>*     _bcis;\n+\n+    GetStackTraceClosure(Handle java_thread) :\n+        HandshakeClosure(\"GetStackTraceClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false) {\n+      \/\/ Pick some initial length\n+      int init_length = MaxJavaStackTraceDepth \/ 2;\n+      _methods = new GrowableArray<Method*>(init_length);\n+      _bcis = new GrowableArray<int>(init_length);\n+    }\n+\n+    bool read_reset_retry() {\n+      bool ret = _retry_handshake;\n+      \/\/ If we re-execute the handshake this method need to return false\n+      \/\/ when the handshake cannot be performed. (E.g. thread terminating)\n+      _retry_handshake = false;\n+      return ret;\n+    }\n+\n+    void do_thread(Thread* th) {\n+      if (!Thread::current()->is_Java_thread()) {\n+        _retry_handshake = true;\n+        return;\n+      }\n+\n+      JavaThread* thread = JavaThread::cast(th);\n+\n+      if (!thread->has_last_Java_frame()) {\n+        return;\n+      }\n+\n+      bool carrier = false;\n+      if (java_lang_VirtualThread::is_instance(_java_thread())) {\n+        \/\/ if (thread->vthread() != _java_thread()) \/\/ We might be inside a System.executeOnCarrierThread\n+        const ContinuationEntry* ce = thread->vthread_continuation();\n+        if (ce == nullptr || ce->cont_oop() != java_lang_VirtualThread::continuation(_java_thread())) {\n+          return; \/\/ not mounted\n+        }\n+      } else {\n+        carrier = (thread->vthread_continuation() != NULL);\n+      }\n+\n+      const int max_depth = MaxJavaStackTraceDepth;\n+      const bool skip_hidden = !ShowHiddenFrames;\n+\n+      int total_count = 0;\n+      for (vframeStream vfst(thread, false, false, carrier); \/\/ we don't process frames as we don't care about oops\n+           !vfst.at_end() && (max_depth == 0 || max_depth != total_count);\n+           vfst.next()) {\n+\n+        if (skip_hidden && (vfst.method()->is_hidden() ||\n+                            vfst.method()->is_continuation_enter_intrinsic())) {\n+          continue;\n+        }\n+\n+        _methods->push(vfst.method());\n+        _bcis->push(vfst.bci());\n+        total_count++;\n+      }\n+\n+      _depth = total_count;\n+    }\n+  };\n+\n+  \/\/ Handshake with target\n+  ResourceMark rm(THREAD);\n+  HandleMark   hm(THREAD);\n+  GetStackTraceClosure gstc(Handle(THREAD, java_thread));\n+  do {\n+   Handshake::execute(&gstc, &tlh, thread);\n+  } while (gstc.read_reset_retry());\n+\n+  \/\/ Stop if no stack trace is found.\n+  if (gstc._depth == 0) {\n+    return NULL;\n+  }\n+\n+  \/\/ Convert to StackTraceElement array\n+  InstanceKlass* k = vmClasses::StackTraceElement_klass();\n+  assert(k != NULL, \"must be loaded in 1.4+\");\n+  if (k->should_be_initialized()) {\n+    k->initialize(CHECK_NULL);\n+  }\n+  objArrayHandle trace = oopFactory::new_objArray_handle(k, gstc._depth, CHECK_NULL);\n+\n+  for (int i = 0; i < gstc._depth; i++) {\n+    methodHandle method(THREAD, gstc._methods->at(i));\n+    oop element = java_lang_StackTraceElement::create(method,\n+                                                      gstc._bcis->at(i),\n+                                                      CHECK_NULL);\n+    trace->obj_at_put(i, element);\n+  }\n+\n+  return trace();\n+}\n+\n+const char* java_lang_Thread::thread_status_name(oop java_thread) {\n+  oop holder = java_lang_Thread::holder(java_thread);\n+  assert(holder != NULL, \"Java Thread not initialized\");\n+  JavaThreadStatus status = java_lang_Thread_FieldHolder::get_thread_status(holder);\n+  switch (status) {\n+    case JavaThreadStatus::NEW                      : return \"NEW\";\n+    case JavaThreadStatus::RUNNABLE                 : return \"RUNNABLE\";\n+    case JavaThreadStatus::SLEEPING                 : return \"TIMED_WAITING (sleeping)\";\n+    case JavaThreadStatus::IN_OBJECT_WAIT           : return \"WAITING (on object monitor)\";\n+    case JavaThreadStatus::IN_OBJECT_WAIT_TIMED     : return \"TIMED_WAITING (on object monitor)\";\n+    case JavaThreadStatus::PARKED                   : return \"WAITING (parking)\";\n+    case JavaThreadStatus::PARKED_TIMED             : return \"TIMED_WAITING (parking)\";\n+    case JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER : return \"BLOCKED (on object monitor)\";\n+    case JavaThreadStatus::TERMINATED               : return \"TERMINATED\";\n+    default                       : return \"UNKNOWN\";\n+  };\n+}\n+int java_lang_ThreadGroup::_parent_offset;\n+int java_lang_ThreadGroup::_name_offset;\n+int java_lang_ThreadGroup::_maxPriority_offset;\n+int java_lang_ThreadGroup::_daemon_offset;\n+int java_lang_ThreadGroup::_ngroups_offset;\n+int java_lang_ThreadGroup::_groups_offset;\n+int java_lang_ThreadGroup::_nweaks_offset;\n+int java_lang_ThreadGroup::_weaks_offset;\n+\n+oop  java_lang_ThreadGroup::parent(oop java_thread_group) {\n+  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n+  return java_thread_group->obj_field(_parent_offset);\n+}\n+\n+\/\/ (\"name as oop\" accessor is not necessary)\n+\n+const char* java_lang_ThreadGroup::name(oop java_thread_group) {\n+  oop name = java_thread_group->obj_field(_name_offset);\n+  \/\/ ThreadGroup.name can be null\n+  if (name != NULL) {\n+    return java_lang_String::as_utf8_string(name);\n+  }\n+  return NULL;\n+}\n+\n+ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {\n+  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n+  return (ThreadPriority) java_thread_group->int_field(_maxPriority_offset);\n+}\n+\n+bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {\n+  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n+  return java_thread_group->bool_field(_daemon_offset) != 0;\n+}\n+\n+int java_lang_ThreadGroup::ngroups(oop java_thread_group) {\n+  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n+  return java_thread_group->int_field(_ngroups_offset);\n+}\n+\n+objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {\n+  oop groups = java_thread_group->obj_field(_groups_offset);\n+  assert(groups == NULL || groups->is_objArray(), \"just checking\"); \/\/ Todo: Add better type checking code\n+  return objArrayOop(groups);\n+}\n+\n+int java_lang_ThreadGroup::nweaks(oop java_thread_group) {\n+  assert(oopDesc::is_oop(java_thread_group), \"thread group must be oop\");\n+  return java_thread_group->int_field(_nweaks_offset);\n+}\n+\n+objArrayOop java_lang_ThreadGroup::weaks(oop java_thread_group) {\n+  oop weaks = java_thread_group->obj_field(_weaks_offset);\n+  assert(weaks == NULL || weaks->is_objArray(), \"just checking\");\n+  return objArrayOop(weaks);\n+}\n+\n+#define THREADGROUP_FIELDS_DO(macro) \\\n+  macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,         false); \\\n+  macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,              false); \\\n+  macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,                 false); \\\n+  macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,                false); \\\n+  macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,                 false); \\\n+  macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature,   false); \\\n+  macro(_nweaks_offset,      k, vmSymbols::nweaks_name(),      int_signature,                 false); \\\n+  macro(_weaks_offset,       k, vmSymbols::weaks_name(),       weakreference_array_signature, false);\n+\n+void java_lang_ThreadGroup::compute_offsets() {\n+  assert(_parent_offset == 0, \"offsets should be initialized only once\");\n+\n+  InstanceKlass* k = vmClasses::ThreadGroup_klass();\n+  THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {\n+  THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+\n+\/\/ java_lang_VirtualThread\n+\n+int java_lang_VirtualThread::static_notify_jvmti_events_offset;\n+int java_lang_VirtualThread::static_vthread_scope_offset;\n+int java_lang_VirtualThread::_carrierThread_offset;\n+int java_lang_VirtualThread::_continuation_offset;\n+int java_lang_VirtualThread::_state_offset;\n+\n+#define VTHREAD_FIELDS_DO(macro) \\\n+  macro(static_notify_jvmti_events_offset, k, \"notifyJvmtiEvents\",  bool_signature,              true);  \\\n+  macro(static_vthread_scope_offset,       k, \"VTHREAD_SCOPE\",      continuationscope_signature, true);  \\\n+  macro(_carrierThread_offset,             k, \"carrierThread\",      thread_signature,            false); \\\n+  macro(_continuation_offset,              k, \"cont\",               continuation_signature,      false); \\\n+  macro(_state_offset,                     k, \"state\",              int_signature,               false)\n+\n+static bool vthread_notify_jvmti_events = JNI_FALSE;\n+\n+void java_lang_VirtualThread::compute_offsets() {\n+  InstanceKlass* k = vmClasses::VirtualThread_klass();\n+  VTHREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+void java_lang_VirtualThread::init_static_notify_jvmti_events() {\n+  if (vthread_notify_jvmti_events) {\n+    InstanceKlass* ik = vmClasses::VirtualThread_klass();\n+    oop base = ik->static_field_base_raw();\n+    base->release_bool_field_put(static_notify_jvmti_events_offset, vthread_notify_jvmti_events);\n+  }\n+}\n+\n+bool java_lang_VirtualThread::is_instance(oop obj) {\n+  return obj != NULL && is_subclass(obj->klass());\n+}\n+\n+oop java_lang_VirtualThread::carrier_thread(oop vthread) {\n+  oop thread = vthread->obj_field(_carrierThread_offset);\n+  return thread;\n+}\n+\n+oop java_lang_VirtualThread::continuation(oop vthread) {\n+  oop cont = vthread->obj_field(_continuation_offset);\n+  return cont;\n+}\n+\n+int java_lang_VirtualThread::state(oop vthread) {\n+  return vthread->int_field_acquire(_state_offset);\n+}\n+\n+JavaThreadStatus java_lang_VirtualThread::map_state_to_thread_status(int state) {\n+  JavaThreadStatus status = JavaThreadStatus::NEW;\n+  switch (state) {\n+    case NEW :\n+      status = JavaThreadStatus::NEW;\n+      break;\n+    case STARTED :\n+    case RUNNABLE :\n+    case RUNNABLE_SUSPENDED :\n+    case RUNNING :\n+    case PARKING :\n+    case YIELDING :\n+      status = JavaThreadStatus::RUNNABLE;\n+      break;\n+    case PARKED :\n+    case PARKED_SUSPENDED :\n+    case PINNED :\n+      status = JavaThreadStatus::PARKED;\n+      break;\n+    case TERMINATED :\n+      status = JavaThreadStatus::TERMINATED;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  return status;\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_VirtualThread::serialize_offsets(SerializeClosure* f) {\n+   VTHREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+bool java_lang_VirtualThread::notify_jvmti_events() {\n+  return vthread_notify_jvmti_events == JNI_TRUE;\n+}\n+\n+void java_lang_VirtualThread::set_notify_jvmti_events(bool enable) {\n+  vthread_notify_jvmti_events = enable;\n+}\n+\n+bool java_lang_VirtualThread::is_subclass(Klass* klass) {\n+  return klass->is_subclass_of(vmClasses::VirtualThread_klass());\n+}\n","filename":"src\/hotspot\/share\/runtime\/threadJavaClasses.cpp","additions":649,"deletions":0,"binary":false,"changes":649,"status":"added"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_THREADJAVACLASSES_HPP\n+#define SHARE_RUNTIME_THREADJAVACLASSES_HPP\n+\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/vmEnums.hpp\"\n+\n+class JvmtiThreadState;\n+class SerializeClosure;\n+\n+#define CHECK_INIT(offset)  assert(offset != 0, \"should be initialized\"); return offset;\n+\n+\/\/ Interface to java.lang.Thread objects\n+\n+#define THREAD_INJECTED_FIELDS(macro)                                  \\\n+  macro(java_lang_Thread, jvmti_thread_state, intptr_signature, false) \\\n+  JFR_ONLY(macro(java_lang_Thread, jfr_epoch, short_signature, false))\n+\n+class java_lang_Thread : AllStatic {\n+  friend class java_lang_VirtualThread;\n+ private:\n+  \/\/ Note that for this class the layout changed between JDK1.2 and JDK1.3,\n+  \/\/ so we compute the offsets at startup rather than hard-wiring them.\n+  static int _holder_offset;\n+  static int _name_offset;\n+  static int _contextClassLoader_offset;\n+  static int _inheritedAccessControlContext_offset;\n+  static int _eetop_offset;\n+  static int _jvmti_thread_state_offset;\n+  static int _interrupted_offset;\n+  static int _tid_offset;\n+  static int _continuation_offset;\n+  static int _park_blocker_offset;\n+  static int _extentLocalBindings_offset;\n+  JFR_ONLY(static int _jfr_epoch_offset;)\n+\n+  static void compute_offsets();\n+\n+ public:\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ Returns the JavaThread associated with the thread obj\n+  static JavaThread* thread(oop java_thread);\n+  \/\/ Set JavaThread for instance\n+  static void set_thread(oop java_thread, JavaThread* thread);\n+  \/\/ FieldHolder\n+  static oop holder(oop java_thread);\n+  \/\/ Interrupted status\n+  static bool interrupted(oop java_thread);\n+  static void set_interrupted(oop java_thread, bool val);\n+  \/\/ Name\n+  static oop name(oop java_thread);\n+  static void set_name(oop java_thread, oop name);\n+  \/\/ Priority\n+  static ThreadPriority priority(oop java_thread);\n+  static void set_priority(oop java_thread, ThreadPriority priority);\n+  \/\/ Thread group\n+  static oop  threadGroup(oop java_thread);\n+  \/\/ Stillborn\n+  static bool is_stillborn(oop java_thread);\n+  static void set_stillborn(oop java_thread);\n+  \/\/ Alive (NOTE: this is not really a field, but provides the correct\n+  \/\/ definition without doing a Java call)\n+  static bool is_alive(oop java_thread);\n+  \/\/ Daemon\n+  static bool is_daemon(oop java_thread);\n+  static void set_daemon(oop java_thread);\n+  \/\/ Context ClassLoader\n+  static oop context_class_loader(oop java_thread);\n+  \/\/ Control context\n+  static oop inherited_access_control_context(oop java_thread);\n+  \/\/ Stack size hint\n+  static jlong stackSize(oop java_thread);\n+  \/\/ Thread ID\n+  static int64_t thread_id(oop java_thread);\n+  static ByteSize thread_id_offset();\n+  \/\/ Continuation\n+  static inline oop continuation(oop java_thread);\n+\n+  static JvmtiThreadState* jvmti_thread_state(oop java_thread);\n+  static void set_jvmti_thread_state(oop java_thread, JvmtiThreadState* state);\n+\n+  \/\/ Clear all extent local bindings on error\n+  static void clear_extentLocalBindings(oop java_thread);\n+\n+  \/\/ Blocker object responsible for thread parking\n+  static oop park_blocker(oop java_thread);\n+\n+  \/\/ Write thread status info to threadStatus field of java.lang.Thread.\n+  static void set_thread_status(oop java_thread_oop, JavaThreadStatus status);\n+  \/\/ Read thread status info from threadStatus field of java.lang.Thread.\n+  static JavaThreadStatus get_thread_status(oop java_thread_oop);\n+\n+  static const char*  thread_status_name(oop java_thread_oop);\n+\n+  \/\/ Fill in current stack trace, can cause GC\n+  static oop async_get_stack_trace(oop java_thread, TRAPS);\n+\n+  JFR_ONLY(static u2 jfr_epoch(oop java_thread);)\n+  JFR_ONLY(static void set_jfr_epoch(oop java_thread, u2 epoch);)\n+  JFR_ONLY(static int jfr_epoch_offset() { CHECK_INIT(_jfr_epoch_offset); })\n+\n+  \/\/ Debugging\n+  friend class JavaClasses;\n+};\n+\n+\/\/ Interface to java.lang.Thread$FieldHolder objects\n+\n+class java_lang_Thread_FieldHolder : AllStatic {\n+ private:\n+  static int _group_offset;\n+  static int _priority_offset;\n+  static int _stackSize_offset;\n+  static int _stillborn_offset;\n+  static int _daemon_offset;\n+  static int _thread_status_offset;\n+\n+  static void compute_offsets();\n+\n+ public:\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  static oop threadGroup(oop holder);\n+\n+  static ThreadPriority priority(oop holder);\n+  static void set_priority(oop holder, ThreadPriority priority);\n+\n+  static jlong stackSize(oop holder);\n+\n+  static bool is_stillborn(oop holder);\n+  static void set_stillborn(oop holder);\n+\n+  static bool is_daemon(oop holder);\n+  static void set_daemon(oop holder);\n+\n+  static void set_thread_status(oop holder, JavaThreadStatus);\n+  static JavaThreadStatus get_thread_status(oop holder);\n+\n+  friend class JavaClasses;\n+};\n+\n+\/\/ Interface to java.lang.Thread$Constants objects\n+\n+class java_lang_Thread_Constants : AllStatic {\n+ private:\n+  static int _static_VTHREAD_GROUP_offset;\n+  static int _static_NOT_SUPPORTED_CLASSLOADER_offset;\n+\n+  static void compute_offsets();\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+ public:\n+  static oop get_VTHREAD_GROUP();\n+  static oop get_NOT_SUPPORTED_CLASSLOADER();\n+\n+  friend class JavaClasses;\n+};\n+\n+\/\/ Interface to java.lang.ThreadGroup objects\n+\n+class java_lang_ThreadGroup : AllStatic {\n+ private:\n+  static int _parent_offset;\n+  static int _name_offset;\n+  static int _maxPriority_offset;\n+  static int _daemon_offset;\n+\n+  static int _ngroups_offset;\n+  static int _groups_offset;\n+  static int _nweaks_offset;\n+  static int _weaks_offset;\n+\n+  static void compute_offsets();\n+\n+ public:\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ parent ThreadGroup\n+  static oop parent(oop java_thread_group);\n+  \/\/ name\n+  static const char* name(oop java_thread_group);\n+  \/\/ maxPriority in group\n+  static ThreadPriority maxPriority(oop java_thread_group);\n+  \/\/ Daemon\n+  static bool is_daemon(oop java_thread_group);\n+\n+  \/\/ Number of strongly reachable thread groups\n+  static int ngroups(oop java_thread_group);\n+  \/\/ Strongly reachable thread groups\n+  static objArrayOop groups(oop java_thread_group);\n+  \/\/ Number of weakly reachable thread groups\n+  static int nweaks(oop java_thread_group);\n+  \/\/ Weakly reachable thread groups\n+  static objArrayOop weaks(oop java_thread_group);\n+\n+  \/\/ Debugging\n+  friend class JavaClasses;\n+};\n+\n+\n+\/\/ Interface to java.lang.VirtualThread objects\n+\n+class java_lang_VirtualThread : AllStatic {\n+ private:\n+  static int static_notify_jvmti_events_offset;\n+  static int static_vthread_scope_offset;\n+  static int _carrierThread_offset;\n+  static int _continuation_offset;\n+  static int _state_offset;\n+  JFR_ONLY(static int _jfr_epoch_offset;)\n+ public:\n+  enum {\n+    NEW          = 0,\n+    STARTED      = 1,\n+    RUNNABLE     = 2,\n+    RUNNING      = 3,\n+    PARKING      = 4,\n+    PARKED       = 5,\n+    PINNED       = 6,\n+    YIELDING     = 7,\n+    TERMINATED   = 99,\n+\n+    \/\/ can be suspended from scheduling when unmounted\n+    SUSPENDED    = 1 << 8,\n+    RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED),\n+    PARKED_SUSPENDED   = (PARKED | SUSPENDED)\n+  };\n+\n+  static void compute_offsets();\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ Testers\n+  static bool is_subclass(Klass* klass);\n+  static bool is_instance(oop obj);\n+\n+  static oop vthread_scope();\n+  static oop carrier_thread(oop vthread);\n+  static oop continuation(oop vthread);\n+  static int state(oop vthread);\n+  static JavaThreadStatus map_state_to_thread_status(int state);\n+  static bool notify_jvmti_events();\n+  static void set_notify_jvmti_events(bool enable);\n+  static void init_static_notify_jvmti_events();\n+};\n+\n+\n+#undef CHECK_INIT\n+\n+#endif \/\/ SHARE_RUNTIME_THREADJAVACLASSES_HPP\n","filename":"src\/hotspot\/share\/runtime\/threadJavaClasses.hpp","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_THREADJAVACLASSES_INLINE_HPP\n+#define SHARE_RUNTIME_THREADJAVACLASSES_INLINE_HPP\n+\n+#include \"runtime\/threadJavaClasses.hpp\"\n+\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\n+inline oop java_lang_Thread::continuation(oop java_thread) {\n+  return java_thread->obj_field(_continuation_offset);\n+}\n+\n+inline int64_t java_lang_Thread::thread_id(oop java_thread) {\n+  return java_thread->long_field(_tid_offset);\n+}\n+\n+inline oop java_lang_VirtualThread::vthread_scope() {\n+  oop base = vmClasses::VirtualThread_klass()->static_field_base_raw();\n+  return base->obj_field(static_vthread_scope_offset);\n+}\n+\n+#if INCLUDE_JFR\n+inline u2 java_lang_Thread::jfr_epoch(oop ref) {\n+  return ref->short_field(_jfr_epoch_offset);\n+}\n+\n+inline void java_lang_Thread::set_jfr_epoch(oop ref, u2 epoch) {\n+  ref->short_field_put(_jfr_epoch_offset, epoch);\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n+\n+\n+#endif \/\/ SHARE_RUNTIME_THREADJAVACLASSES_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/threadJavaClasses.inline.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"classfile\/javaThreadStatus.hpp\"\n@@ -67,0 +66,1 @@\n+#include \"runtime\/javaThreadStatus.hpp\"\n@@ -82,1 +82,0 @@\n-#include \"services\/threadIdTable.hpp\"\n@@ -92,0 +91,1 @@\n+#include \"services\/threadIdTable.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/javaThreadStatus.hpp\"\n@@ -46,0 +45,1 @@\n+#include \"runtime\/javaThreadStatus.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"classfile\/javaThreadStatus.hpp\"\n@@ -95,0 +94,1 @@\n+#include \"runtime\/javaThreadStatus.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/threadJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"runtime\/threadJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/services\/threadIdTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/javaThreadStatus.hpp\"\n@@ -34,0 +32,1 @@\n+#include \"runtime\/javaThreadStatus.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"runtime\/threadJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/threadJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}