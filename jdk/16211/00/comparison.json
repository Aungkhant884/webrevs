{"files":[{"patch":"@@ -333,0 +333,4 @@\n+  ++_total_added;\n+  if (_size > _peak_size) {\n+    _peak_size = _size;\n+  }\n@@ -489,0 +493,1 @@\n+  ++_total_removed;\n@@ -518,0 +523,8 @@\n+CompileQueue* CompileBroker::c1_compile_queue() {\n+  return _c1_compile_queue;\n+}\n+\n+CompileQueue* CompileBroker::c2_compile_queue() {\n+  return _c2_compile_queue;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -91,0 +91,3 @@\n+  int _peak_size;\n+  uint _total_added;\n+  uint _total_removed;\n@@ -99,0 +102,3 @@\n+    _total_added = 0;\n+    _total_removed = 0;\n+    _peak_size = 0;\n@@ -115,0 +121,3 @@\n+  int         get_peak_size()     const          { return _peak_size; }\n+  int         get_total_added()   const          { return _total_added; }\n+  int         get_total_removed() const          { return _total_removed; }\n@@ -305,0 +314,3 @@\n+  static CompileQueue* c1_compile_queue();\n+  static CompileQueue* c2_compile_queue();\n+\n@@ -402,0 +414,2 @@\n+  static int get_c1_thread_count() {                return _compilers[0]->num_compiler_threads(); }\n+  static int get_c2_thread_count() {                return _compilers[1]->num_compiler_threads(); }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -851,0 +851,13 @@\n+  <Event name=\"CompilerQueueUtilization\" category=\"Java Virtual Machine, Compiler\" label=\"Compiler Queue Utilization\" period=\"everyChunk\">\n+    <Field type=\"CompilerType\" name=\"compiler\" label=\"Compiler\" \/>\n+    <Field type=\"long\" contentType=\"hertz\" name=\"ingress\" label=\"Ingress\" description=\"Number of added requests per second\"\/>\n+    <Field type=\"long\" contentType=\"hertz\" name=\"egress\" label=\"Egress\" description=\"Number of removed requests per second\"\/>\n+    <Field type=\"long\" contentType=\"count\" name=\"size\" label=\"Size\" description=\"Current queue size\"\/>\n+    <Field type=\"long\" contentType=\"count\" name=\"peak\" label=\"Peak Size\" description=\"Peak queue size\"\/>\n+    <Field type=\"long\" contentType=\"count\" name=\"added\" label=\"Added\" description=\"Added requests\"\/>\n+    <Field type=\"long\" contentType=\"count\" name=\"removed\" label=\"Removed\" description=\"Removed requests\"\/>\n+    <Field type=\"long\" contentType=\"count\" name=\"totalAdded\" label=\"Total Added\" description=\"Total requests\"\/>\n+    <Field type=\"long\" contentType=\"count\" name=\"totalRemoved\" label=\"Total Removed\" description=\"Total removed requests\"\/>\n+    <Field type=\"int\" name=\"compilerThreadCount\" label=\"Number of Compiler Threads for this queue\"\/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/periodic\/jfrCompilerQueueUtilization.hpp\"\n+\n+enum {\n+    c1_compiler_queue_id = 1,\n+    c2_compiler_queue_id = 2,\n+    num_compiler_queues = 2\n+};\n+\n+typedef int (*GET_COMPILER_THREAD_COUNT)();\n+\n+struct CompilerQueueEntry {\n+  CompileQueue* compilerQueue;\n+  u8 compiler_queue_id;\n+  GET_COMPILER_THREAD_COUNT get_compiler_thread_count;\n+  uint64_t added;\n+  uint64_t removed;\n+};\n+\n+\/\/ If current counters are less than previous, we assume the interface has been reset\n+\/\/ If no bytes have been either sent or received, we'll also skip the event\n+static uint64_t rate_per_second(uint64_t current, uint64_t old, const JfrTickspan& interval) {\n+  assert(interval.value() > 0, \"invariant\");\n+  if (current <= old) {\n+    return 0;\n+  }\n+  return ((current - old) * NANOSECS_PER_SEC) \/ interval.nanoseconds();\n+}\n+\n+void JfrCompilerQueueUtilization::send_events() {\n+  static CompilerQueueEntry compilerQueueEntries[num_compiler_queues] = {\n+    {CompileBroker::c1_compile_queue(), c1_compiler_queue_id, &CompileBroker::get_c1_thread_count, 0, 0},\n+    {CompileBroker::c2_compile_queue(), c2_compiler_queue_id, &CompileBroker::get_c2_thread_count, 0, 0}};\n+\n+  const JfrTicks cur_time = JfrTicks::now();\n+  static JfrTicks last_sample_instant;\n+  const JfrTickspan interval = cur_time - last_sample_instant;\n+  for (int i = 0; i < num_compiler_queues; i ++) {\n+    CompilerQueueEntry* entry = &compilerQueueEntries[i];\n+    if (entry->compilerQueue != NULL) {\n+      const uint64_t current_added = entry->compilerQueue->get_total_added();\n+      const uint64_t current_removed = entry->compilerQueue->get_total_removed();\n+      const uint64_t ingress = rate_per_second(current_added, entry->added, interval);\n+      const uint64_t egress = rate_per_second(current_removed, entry->removed, interval);\n+\n+      EventCompilerQueueUtilization event;\n+      event.set_compiler(entry->compiler_queue_id);\n+      event.set_ingress(ingress);\n+      event.set_egress(egress);\n+      event.set_size(entry->compilerQueue->size());\n+      event.set_peak(entry->compilerQueue->get_peak_size());\n+      event.set_added(current_added - entry->added);\n+      event.set_removed(current_removed - entry->removed);\n+      event.set_totalAdded(current_added);\n+      event.set_totalRemoved(current_removed);\n+      event.set_compilerThreadCount(entry->get_compiler_thread_count());\n+      event.commit();\n+\n+      entry->added = current_added;\n+      entry->removed = current_removed;\n+    }\n+\n+    last_sample_instant = cur_time;\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrCompilerQueueUtilization.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_PERIODIC_JFRCOMPILERQUEUEUTILIZATION_HPP\n+#define SHARE_JFR_PERIODIC_JFRCOMPILERQUEUEUTILIZATION_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+class JfrCompilerQueueUtilization : public AllStatic {\n+public:\n+  static void send_events();\n+};\n+\n+#endif \/\/ SHARE_JFR_PERIODIC_JFRCOMPILERQUEUEUTILIZATION_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrCompilerQueueUtilization.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"jfr\/periodic\/jfrCompilerQueueUtilization.hpp\"\n@@ -224,0 +225,4 @@\n+TRACE_REQUEST_FUNC(CompilerQueueUtilization) {\n+  JfrCompilerQueueUtilization::send_events();\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -666,0 +666,5 @@\n+    <event name=\"jdk.CompilerQueueUtilization\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">10 s<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -666,0 +666,5 @@\n+    <event name=\"jdk.CompilerQueueUtilization\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">5 s<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.compiler;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @requires vm.compMode!=\"Xint\"\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.compiler.TestCompilerQueueUtilization\n+ *\/\n+public class TestCompilerQueueUtilization {\n+    private final static String EVENT_NAME = EventNames.CompilerQueueUtilization;\n+\n+    public static void main(String[] args) throws Exception {\n+        Recording recording = new Recording();\n+        recording.enable(EVENT_NAME);\n+        recording.start();\n+        recording.stop();\n+\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n+        Events.hasEvents(events);\n+        for (RecordedEvent event : events) {\n+            System.out.println(\"Event:\" + event);\n+            Events.assertField(event, \"compiler\").notEmpty();\n+            Events.assertField(event, \"ingress\").atLeast(0L);\n+            Events.assertField(event, \"egress\").atLeast(0L);\n+            Events.assertField(event, \"size\").atLeast(0L);\n+            Events.assertField(event, \"peak\").atLeast(0L);\n+            Events.assertField(event, \"added\").atLeast(0L);\n+            Events.assertField(event, \"removed\").atLeast(0L);\n+            Events.assertField(event, \"totalAdded\").atLeast(0L);\n+            Events.assertField(event, \"totalRemoved\").atLeast(0L);\n+            Events.assertField(event, \"compilerThreadCount\").atLeast(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCompilerQueueUtilization.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -163,0 +163,1 @@\n+    public static final String CompilerQueueUtilization = PREFIX + \"CompilerQueueUtilization\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}