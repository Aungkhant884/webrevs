{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import java.util.HexFormat;\n@@ -478,0 +479,1 @@\n+                        HexFormat hex = HexFormat.of();\n@@ -479,2 +481,2 @@\n-                                 \" recorded in %s\", dn, toHexString(actualHash),\n-                                 toHexString(recordedHash), descriptor.name());\n+                                 \" recorded in %s\", dn, hex.formatHex(actualHash),\n+                                hex.formatHex(recordedHash), descriptor.name());\n@@ -488,9 +490,0 @@\n-    private static String toHexString(byte[] ba) {\n-        StringBuilder sb = new StringBuilder(ba.length * 2);\n-        for (byte b: ba) {\n-            sb.append(String.format(\"%02x\", b & 0xff));\n-        }\n-        return sb.toString();\n-    }\n-\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/Resolver.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,1020 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ * Converts between bytes and chars and hex-encoded strings which may include additional\n+ * formatting markup such as prefixes, suffixes, and delimiters.\n+ * <p>\n+ * There are two factories of {@code HexFormat} with preset parameters {@link #of()} and\n+ * {@link #ofDelimiter(String) of(delimiter)}. For other parameter combinations\n+ * the {@code withXXX} methods return copies of {@code HexFormat} modified\n+ * {@link #withPrefix(String)}, {@link #withSuffix(String)}, {@link #withDelimiter(String)}\n+ * or choice of {@link #withUpperCase()} or {@link #withLowerCase()} parameters using\n+ * a fluent builder style.\n+ * <p>\n+ * For primitive to hexadecimal string conversions the {@code toHexDigits}\n+ * methods include {@link #toHexDigits(byte)}, {@link #toHexDigits(int)}, and\n+ * {@link #toHexDigits(long)}, etc.\n+ * For conversions producing uppercase hexadecimal strings use {@link #withUpperCase()}.\n+ *\n+ * <p>\n+ * For hexadecimal string to primitive conversions the {@code fromHexDigits}\n+ * methods include {@link #fromHexDigits(CharSequence) fromHexDigits(string)},\n+ * {@link #fromHexDigitsToLong(CharSequence) fromHexDigitsToLong(string)}, and\n+ * {@link #fromHexDigit(int) fromHexDigit(int)} converts a single character or codepoint.\n+ *\n+ * <p>\n+ * For byte array to formatted hexadecimal string conversions\n+ * the {@code formatHex} methods include {@link #formatHex(byte[]) formatHex(byte[])}\n+ * and {@link #formatHex(Appendable, byte[]) formatHex(Appendable, byte[])}.\n+ * The formatted output can be appended to {@link StringBuilder}, {@link System#out},\n+ * {@link java.io.Writer}, and {@link java.io.PrintStream}, all of which are {@link Appendable}s.\n+ * Each byte value is formatted as the prefix, two hexadecimal characters from the\n+ * uppercase or lowercase digits, and the suffix.\n+ * A delimiter appears after each formatted value, except the last.\n+ * For conversions producing uppercase hexadecimal strings use {@link #withUpperCase()}.\n+ *\n+ * <p>\n+ * For formatted hexadecimal string to byte array conversions the\n+ * {@code parseHex} methods include {@link #parseHex(CharSequence) parseHex(string)} and\n+ * {@link #parseHex(char[], int, int) parseHex(char[], offset, length)}.\n+ * Each byte value is parsed as the prefix, two hexadecimal characters from the\n+ * uppercase or lowercase digits, and the suffix.\n+ * The delimiter is required after each formatted value, except the last.\n+ *\n+ * @apiNote\n+ * For example, an individual byte is converted to a string of hexadecimal digits using\n+ * {@link HexFormat#toHexDigits(int) toHexDigits(int)} and converted from a string to a\n+ * primitive value using {@link HexFormat#fromHexDigits(CharSequence) fromHexDigits(string)}.\n+ * <pre>{@code\n+ *     HexFormat hex = HexFormat.of();\n+ *     byte b = 127;\n+ *     String byteStr = hex.toHexDigits(b);\n+ *\n+ *     int byteVal = hex.fromHexDigits(byteStr);\n+ *     assert(byteStr.equals(\"7f\"));\n+ *     assert(b == byteVal);\n+ *\n+ *     \/\/ The hexadecimal digits are: \"7f\"\n+ * }<\/pre>\n+ * <p>\n+ * For a comma ({@code \", \"}) separated format with a prefix ({@code \"#\"})\n+ * using lowercase hex digits the {@code HexFormat} is:\n+ * <pre>{@code\n+ *     HexFormat commaFormat = HexFormat.ofDelimiter(\", \").withPrefix(\"#\");\n+ *     byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+ *     String str = commaFormat.formatHex(bytes);\n+ *\n+ *     byte[] parsed = commaFormat.parseHex(str);\n+ *     assert(Arrays.equals(bytes, parsed));\n+ *\n+ *     \/\/ The formatted string is: \"#00, #01, #02, #03, #7c, #7d, #7e, #7f\"\n+ * }<\/pre>\n+ * <p>\n+ * For a fingerprint of byte values that uses the delimiter colon ({@code \":\"})\n+ * and uppercase letters the {@code HexFormat} is:\n+ * <pre>{@code\n+ *     HexFormat formatFingerprint = HexFormat.ofDelimiter(\":\").withUpperCase();\n+ *     byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+ *     String str = formatFingerprint.formatHex(bytes);\n+ *     byte[] parsed = formatFingerprint.parseHex(str);\n+ *     assert(Arrays.equals(bytes, parsed));\n+ *\n+ *     \/\/ The formatted string is: \"00:01:02:03:7C:7D:7E:7F\"\n+ * }<\/pre>\n+ *\n+ * <p>\n+ * This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n+ * class; use of identity-sensitive operations (including reference equality\n+ * ({@code ==}), identity hash code, or synchronization) on instances of\n+ * {@code HexFormat} may have unpredictable results and should be avoided.\n+ * The {@code equals} method should be used for comparisons.\n+ *\n+ * @implSpec\n+ * This class is immutable and thread-safe.\n+ * <p>\n+ * Unless otherwise noted, passing a null argument to any method will cause a\n+ * {@link java.lang.NullPointerException NullPointerException} to be thrown.\n+ *\n+ * @since 16\n+ *\/\n+\n+\n+public final class HexFormat {\n+\n+    \/\/ Access to create strings from a byte array.\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n+    private static final byte[] UPPERCASE_DIGITS = {\n+            '0', '1', '2', '3', '4', '5', '6', '7',\n+            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',\n+    };\n+    private static final byte[] LOWERCASE_DIGITS = {\n+            '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7',\n+            '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f',\n+    };\n+\n+    \/**\n+     * Format each byte of an array as a pair of hex digits.\n+     * The hex characters are from lowercase alpha digits.\n+     *\/\n+    private static final HexFormat HEX_FORMAT =\n+            new HexFormat(\"\", \"\", \"\", LOWERCASE_DIGITS);\n+\n+    private static final byte[] emptyBytes = new byte[0];\n+    private final String delimiter;\n+    private final String prefix;\n+    private final String suffix;\n+    private final byte[] digits;\n+\n+    \/**\n+     * Returns a HexFormat with a delimiter, prefix, suffix, and array of digits.\n+     *\n+     * @param delimiter a delimiter, non-null\n+     * @param prefix a prefix, non-null\n+     * @param suffix a suffix, non-null\n+     * @param digits byte array of digits indexed by low nibble, non-null\n+     * @throws NullPointerException if any argument is null\n+     *\/\n+    private HexFormat(String delimiter, String prefix, String suffix, byte[] digits) {\n+        this.delimiter = Objects.requireNonNull(delimiter, \"delimiter\");\n+        this.prefix = Objects.requireNonNull(prefix, \"prefix\");\n+        this.suffix = Objects.requireNonNull(suffix, \"suffix\");\n+        this.digits = Objects.requireNonNull(digits, \"digits\");\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal formatter with no delimiter and lowercase characters.\n+     * The hex characters are lowercase and the delimiter, prefix, and suffix are empty.\n+     * The methods {@link #withDelimiter(String) withDelimiter},\n+     * {@link #withUpperCase() withUpperCase}, {@link #withLowerCase() withLowerCase},\n+     * {@link #withPrefix(String) withPrefix}, and {@link #withSuffix(String) withSuffix}\n+     * return copies of formatters with new parameters.\n+     *\n+     * @return a hex formatter\n+     *\/\n+    public static HexFormat of() {\n+        return HEX_FORMAT;\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal formatter with a delimiter and lowercase letters.\n+     * The prefix and suffix are empty.\n+     * The methods {@link #withDelimiter(String) withDelimiter},\n+     * {@link #withUpperCase() withUpperCase}, {@link #withLowerCase() withLowerCase},\n+     * {@link #withPrefix(String) withPrefix}, and {@link #withSuffix(String) withSuffix}\n+     * return copies of formatters with new parameters.\n+     *\n+     * @param delimiter a delimiter, non-null, may be empty\n+     * @return a {@link HexFormat} with the delimiter and lowercase letters\n+     *\/\n+    public static HexFormat ofDelimiter(String delimiter) {\n+        return new HexFormat(delimiter, \"\", \"\", LOWERCASE_DIGITS);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} with the delimiter.\n+     * @param delimiter the delimiter, non-null, may be empty\n+     * @return a copy of this {@code HexFormat} with the delimiter\n+     *\/\n+    public HexFormat withDelimiter(String delimiter) {\n+        return new HexFormat(delimiter, this.prefix, this.suffix, this.digits);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} with the prefix.\n+     *\n+     * @param prefix a prefix, non-null, may be empty\n+     * @return a copy of this {@code HexFormat} with the prefix\n+     *\/\n+    public HexFormat withPrefix(String prefix) {\n+        return new HexFormat(this.delimiter, prefix, this.suffix, this.digits);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} with the suffix.\n+     *\n+     * @param suffix a suffix, non-null, may be empty\n+     * @return a copy of this {@code HexFormat} with the suffix\n+     *\/\n+    public HexFormat withSuffix(String suffix) {\n+        return new HexFormat(this.delimiter, this.prefix, suffix, this.digits);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} to use uppercase hex characters.\n+     * The uppercase hexadecimal characters are {@code \"0-9\", \"A-F\"}.\n+     *\n+     * @return a copy of this {@code HexFormat} with uppercase hexadecimal characters\n+     *\/\n+    public HexFormat withUpperCase() {\n+        return new HexFormat(this.delimiter, this.prefix, this.suffix, UPPERCASE_DIGITS);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} to use lowercase hex characters.\n+     * The lowercase hexadecimal characters are {@code \"0-9\", \"a-f\"}.\n+     *\n+     * @return a copy of this {@code HexFormat} with lowercase hex characters\n+     *\/\n+    public HexFormat withLowerCase() {\n+        return new HexFormat(this.delimiter, this.prefix, this.suffix, LOWERCASE_DIGITS);\n+    }\n+\n+    \/**\n+     * Returns the delimiter between hexadecimal values in a formatted byte array.\n+     *\n+     * @return return the delimiter, non-null, may be empty {@code \"\"}\n+     *\/\n+    public String delimiter() {\n+        return delimiter;\n+    }\n+\n+    \/**\n+     * Returns the prefix used for each hexadecimal value in a formatted byte array.\n+     *\n+     * @return returns the prefix\n+     *\/\n+    public String prefix() {\n+        return prefix;\n+    }\n+\n+    \/**\n+     * Returns the suffix used for each hexadecimal value in a formatted byte array.\n+     *\n+     * @return returns the suffix\n+     *\/\n+    public String suffix() {\n+        return suffix;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the hexadecimal digits will be uppercase,\n+     *          otherwise {@code false}.\n+     * @return returns {@code true} if the hexadecimal digits will be uppercase,\n+     *          otherwise {@code false}\n+     *\/\n+    public boolean isUpperCase() {\n+        return Arrays.equals(digits, UPPERCASE_DIGITS);\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string formatted from a byte array.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter appears after each formatted value, except the last.\n+     *\n+     * The behavior is equivalent to\n+     * {@link #formatHex(byte[], int, int) format(bytes, 0, bytes.length))}.\n+     *\n+     * @param bytes a non-null array of bytes\n+     * @return a string hexadecimal formatting of the byte array\n+     *\/\n+    public String formatHex(byte[] bytes) {\n+        return formatHex(bytes, 0, bytes.length);\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string formatted from a byte array range.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter appears after each formatted value, except the last.\n+     *\n+     * @param bytes a non-null array of bytes\n+     * @param index the starting index\n+     * @param length the number of bytes to format\n+     * @return a string hex formatting each byte of the array range\n+     * @throws IndexOutOfBoundsException if the array range is out of bounds\n+     *\/\n+    public String formatHex(byte[] bytes, int index, int length) {\n+        Objects.requireNonNull(bytes,\"bytes\");\n+        Objects.checkFromIndexSize(index, length, bytes.length);\n+        if (length == 0) {\n+            return \"\";\n+        }\n+        \/\/ Format efficiently if possible\n+        String s = formatOptDelimiter(bytes, index, length);\n+        if (s == null) {\n+            StringBuilder sb = new StringBuilder(bytes.length *\n+                    (delimiter.length() + prefix.length() + suffix.length()) - delimiter.length());\n+            formatHex(sb, bytes, index, length);\n+            s = sb.toString();\n+        }\n+        return s;\n+    }\n+\n+    \/**\n+     * Appends a hexadecimal string formatted from a byte array to the {@link Appendable}.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter appears after each formatted value, except the last.\n+     * The behavior is equivalent to\n+     * {@link #formatHex(byte[]) out.append(format(bytes))}.\n+     *\n+     * @param <A> The type of Appendable\n+     * @param out an Appendable, non-null\n+     * @param bytes a byte array\n+     * @return the {@code Appendable}\n+     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     *\/\n+    public <A extends Appendable> A formatHex(A out, byte[] bytes) {\n+        return formatHex(out, bytes, 0, bytes.length);\n+    }\n+\n+    \/**\n+     * Appends a hexadecimal string formatted from a byte array range to the {@link Appendable}.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter appears after each formatted value, except the last.\n+     * The behavior is equivalent to\n+     * {@link #formatHex(byte[], int, int)  out.append(format(bytes, index, length))}.\n+     *\n+     * @param <A> The type of Appendable\n+     * @param out an Appendable, non-null\n+     * @param bytes a byte array, non-null\n+     * @param index the starting index\n+     * @param length the number of bytes to format\n+     * @return the {@code Appendable}\n+     * @throws IndexOutOfBoundsException if the array range is out of bounds\n+     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     *\/\n+    public <A extends Appendable> A formatHex(A out, byte[] bytes, int index, int length) {\n+        Objects.requireNonNull(out, \"out\");\n+        Objects.requireNonNull(bytes, \"bytes\");\n+        Objects.checkFromIndexSize(index, length, bytes.length);\n+\n+        if (length > 0) {\n+            try {\n+                String between = suffix + delimiter + prefix;\n+                out.append(prefix);\n+                toHexDigits(out, bytes[0]);\n+                if (between.isEmpty()) {\n+                    for (int i = 1; i < bytes.length; i++) {\n+                        toHexDigits(out, bytes[i]);\n+                    }\n+                } else {\n+                    for (int i = 1; i < bytes.length; i++) {\n+                        out.append(between);\n+                        toHexDigits(out, bytes[i]);\n+                    }\n+                }\n+                out.append(suffix);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe.getMessage(), ioe);\n+            }\n+        }\n+        return out;\n+    }\n+\n+    \/**\n+     * Returns a string formatting of the range of bytes optimized\n+     * for a single allocation.\n+     * Prefix and suffix must be empty and the delimiter\n+     * must be empty or a single byte character, otherwise null is returned.\n+     *\n+     * @param bytes the bytes, non-null\n+     * @param index the starting index\n+     * @param length the length\n+     * @return a String formatting or null for non-single byte formatting\n+    *\/\n+    private String formatOptDelimiter(byte[] bytes, int index, int length) {\n+        byte[] rep;\n+        if (!prefix.isEmpty() || !suffix.isEmpty()) {\n+            return null;\n+        }\n+        if (delimiter.isEmpty()) {\n+            \/\/ Allocate the byte array and fill in the hex pairs for each byte\n+            rep = new byte[length * 2];\n+            for (int i = 0; i < length; i++) {\n+                rep[i * 2] = (byte)toHighHexDigit(bytes[index + i]);\n+                rep[i * 2 + 1] = (byte)toLowHexDigit(bytes[index + i]);\n+            }\n+        } else if (delimiter.length() == 1 && delimiter.charAt(0) < 256) {\n+            \/\/ Allocate the byte array and fill in the characters for the first byte\n+            \/\/ Then insert the delimiter and hex characters for each of the remaining bytes\n+            char sep = delimiter.charAt(0);\n+            rep = new byte[bytes.length * 3 - 1];\n+            rep[0] = (byte) toHighHexDigit(bytes[0]);\n+            rep[1] = (byte) toLowHexDigit(bytes[0]);\n+            for (int i = 1; i < bytes.length; i++) {\n+                rep[i * 3 - 1] = (byte) sep;\n+                rep[i * 3    ] = (byte) toHighHexDigit(bytes[i]);\n+                rep[i * 3 + 1] = (byte) toLowHexDigit(bytes[i]);\n+            }\n+        } else {\n+            \/\/ Delimiter formatting not to a single byte\n+            return null;\n+        }\n+        try {\n+            \/\/ Return a new string using the bytes without making a copy\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a byte array containing hexadecimal values parsed from the string.\n+     *\n+     * Each byte value is parsed as the prefix, two hexadecimal characters from the\n+     * uppercase or lowercase digits, and the suffix.\n+     * A delimiters, prefixes, and suffixes appears after each formatted value, except the last.\n+     * The delimiters, prefixes, and suffixes strings must be present; they may be empty strings.\n+     * A valid string consists only of the above format.\n+     *\n+     * @param string a string containing the byte values with prefix, hexadecimal digits, suffix,\n+     *            and delimiters\n+     * @return a byte array\n+     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n+     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *          after all but the last byte value.\n+     *\/\n+    public byte[] parseHex(CharSequence string) {\n+        return parseHex(string, 0, string.length());\n+    }\n+\n+    \/**\n+     * Returns a byte array containing hexadecimal values parsed from a range of the string.\n+     *\n+     * Each byte value is parsed as the prefix, two hexadecimal characters from the\n+     * uppercase or lowercase digits, and the suffix.\n+     * A delimiter appears after each formatted value, except the last.\n+     * The delimiters, prefixes, and suffixes strings must be present; they may be empty strings.\n+     * A valid string consists only of the above format.\n+     *\n+     * @param string a string range containing hex digits,\n+     *           delimiters, prefix, and suffix.\n+     * @param index of the start of the character range\n+     * @param length of the character range\n+     * @return a byte array\n+     * @throws IllegalArgumentException if the string length is not valid or\n+     *          the string contains non-hex characters,\n+     *          or the delimiter, prefix, or suffix are not found\n+     * @throws IndexOutOfBoundsException if the string range is out of bounds\n+     *\/\n+    public byte[] parseHex(CharSequence string, int index, int length) {\n+        Objects.requireNonNull(string, \"string\");\n+        Objects.checkFromIndexSize(index, length, string.length());\n+\n+        if (index != 0 || length != string.length()) {\n+            string = string.subSequence(index, length);\n+        }\n+\n+        if (string.length() == 0)\n+            return emptyBytes;\n+        if (delimiter.isEmpty() && prefix.isEmpty() && suffix.isEmpty())\n+            return parseNoDelimiter(string);\n+\n+        int valueChars = prefix.length() + 2 + suffix.length();\n+        int stride = valueChars + delimiter.length();\n+        if (string.length() < valueChars || (string.length() - valueChars) % stride != 0)\n+            throw new IllegalArgumentException(\"extra or missing delimiters \" +\n+                    \"or values consisting of prefix, two hex digits, and suffix\");\n+\n+        checkLiteral(string, 0, prefix);\n+        checkLiteral(string, string.length() - suffix.length(), suffix);\n+        String between = suffix + delimiter + prefix;\n+        final int len = (string.length() - valueChars) \/ stride + 1;\n+        byte[] bytes = new byte[len];\n+        int i, offset;\n+        for (i = 0, offset = prefix.length(); i < len - 1; i++, offset += 2 + between.length()) {\n+            int v = fromHexDigits(string, offset);\n+            if (v < 0)\n+                throw new IllegalArgumentException(\"input contains non-hex characters\");\n+            bytes[i] = (byte) v;\n+            checkLiteral(string, offset + 2, between);\n+        }\n+        int v = fromHexDigits(string, offset);\n+        if (v < 0)\n+            throw new IllegalArgumentException(\"input contains non-hex characters\");\n+        bytes[i] = (byte) v;\n+\n+        return bytes;\n+    }\n+\n+    \/**\n+     * Returns a byte array containing hexadecimal values parsed from\n+     * a range of the character array.\n+     *\n+     * Each byte value is parsed as the prefix, two hexadecimal characters from the\n+     * uppercase or lowercase digits, and the suffix.\n+     * A delimiter appears after each formatted value, except the last.\n+     * The delimiters, prefixes, and suffixes strings must be present; they may be empty strings.\n+     * A valid string consists only of the above format.\n+     *\n+     * @param chars a char array range containing an even number of hex digits,\n+     *          delimiters, prefix, and suffix.\n+     * @param index the starting index\n+     * @param length the length to parse\n+     * @return a byte array\n+     * @throws IllegalArgumentException if the string length is not valid or\n+     *          the character array contains non-hex characters,\n+     *          or the delimiter, prefix, or suffix are not found\n+     * @throws IndexOutOfBoundsException if the char array range is out of bounds\n+     *\/\n+    public byte[] parseHex(char[] chars, int index, int length) {\n+        Objects.requireNonNull(chars, \"chars\");\n+        Objects.checkFromIndexSize(index, length, chars.length);\n+        CharBuffer cb = CharBuffer.wrap(chars, index, index + length);\n+        return parseHex(cb);\n+    }\n+\n+    \/**\n+     * Compare the literal and throw an exception if it does not match.\n+     *\n+     * @param string a CharSequence\n+     * @param index the index of the literal in the CharSequence\n+     * @param literal the expected literal\n+     * @throws IllegalArgumentException if the literal is not present\n+     *\/\n+    private static void checkLiteral(CharSequence string, int index, String literal) {\n+        if (literal.isEmpty() ||\n+                (literal.length() == 1 && literal.charAt(0) == string.charAt(index))) {\n+            return;\n+        }\n+        for (int i = 0; i < literal.length(); i++) {\n+            if (string.charAt(index + i) != literal.charAt(i)) {\n+                throw new IllegalArgumentException(escapeNL(\"found: \\\"\" +\n+                        string.subSequence(index, index + literal.length()) +\n+                        \"\\\", expected: \\\"\" + literal + \"\\\"\"));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Expands new line characters to escaped newlines for display.\n+     *\n+     * @param string a string\n+     * @return a string with newline characters escaped\n+     *\/\n+    private static String escapeNL(String string) {\n+        return string.replace(\"\\n\", \"\\\\n\")\n+                .replace(\"\\r\", \"\\\\r\");\n+    }\n+\n+    \/**\n+     * Returns the hex character for the low 4 bits of the value considering it to be a byte.\n+     * If the parameter {@link #isUpperCase()} is {@code true} the\n+     * character returned for values {@code 10-15} is uppercase {@code \"A-F\"},\n+     * otherwise the character returned is lowercase {@code \"a-f\"}.\n+     * The values in the range {@code 0-9} are returned as {@code \"0-9\"}.\n+     *\n+     * @param value a value, only the low 4 bits {@code 0-3} of the value are used\n+     * @return the hex character for the low 4 bits {@code 0-3} of the value\n+     *\/\n+    public char toLowHexDigit(int value) {\n+        return (char)digits[value & 0xf];\n+    }\n+\n+    \/**\n+     * Returns the hex character for the high 4 bits of the value considering it to be a byte.\n+     * If the parameter {@link #isUpperCase()} is {@code true} the\n+     * character returned for values {@code 10-15} is uppercase {@code \"A-F\"},\n+     * otherwise the character returned is lowercase {@code \"a-f\"}.\n+     * The values in the range {@code 0-9} are returned as {@code \"0-9\"}.\n+     *\n+     * @param value a value, only bits {@code 4-7} of the value are used\n+     * @return the hex character for the bits {@code 4-7} of the value are used\n+     *\/\n+    public char toHighHexDigit(int value) {\n+        return (char)digits[(value >> 4) & 0xf];\n+    }\n+\n+    \/**\n+     * Returns the two hex characters for the {@code byte} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value a byte value\n+     * @return the two hex characters for the byte value\n+     *\/\n+    public String toHexDigits(byte value) {\n+        byte[] rep = new byte[2];\n+        rep[0] = (byte)toHighHexDigit(value);\n+        rep[1] = (byte)toLowHexDigit(value);\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Appends two hex characters for the byte value to the {@link Appendable}.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The behavior is equivalent to\n+     * {@link #toHexDigits(byte) out.append(toHexDigits((byte)value))}.\n+     *\n+     * @param out an Appendable, non-null\n+     * @param value a byte value\n+     * @return the {@code Appendable}\n+     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     *\/\n+    public Appendable toHexDigits(Appendable out, byte value) {\n+        Objects.requireNonNull(out, \"out\");\n+        try {\n+            out.append(toHighHexDigit(value));\n+            out.append(toLowHexDigit(value));\n+            return out;\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe.getMessage(), ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the four hex characters for the {@code char} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value a {@code char} value\n+     * @return the four hex characters for the {@code char} value\n+     *\/\n+    public String toHexDigits(char value) {\n+        return toHexDigits((short)value);\n+    }\n+\n+    \/**\n+     * Returns the four hex characters for the {@code short} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value a {@code short} value\n+     * @return the four hex characters for the {@code short} value\n+     *\/\n+    public String toHexDigits(short value) {\n+        byte[] rep = new byte[4];\n+        rep[0] = (byte)toHighHexDigit((byte)(value >> 8));\n+        rep[1] = (byte)toLowHexDigit((byte)(value >> 8));\n+        rep[2] = (byte)toHighHexDigit((byte)value);\n+        rep[3] = (byte)toLowHexDigit((byte)value);\n+\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the eight hex characters for the {@code int} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value an {@code int} value\n+     * @return the eight hex characters for the {@code int} value\n+     *\/\n+    public String toHexDigits(int value) {\n+        byte[] rep = new byte[8];\n+        rep[0] = (byte)toHighHexDigit((byte)(value >> 24));\n+        rep[1] = (byte)toLowHexDigit((byte)(value >> 24));\n+        rep[2] = (byte)toHighHexDigit((byte)(value >> 16));\n+        rep[3] = (byte)toLowHexDigit((byte)(value >> 16));\n+        rep[4] = (byte)toHighHexDigit((byte)(value >> 8));\n+        rep[5] = (byte)toLowHexDigit((byte)(value >> 8));\n+        rep[6] = (byte)toHighHexDigit((byte)value);\n+        rep[7] = (byte)toLowHexDigit((byte)value);\n+\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the sixteen hex characters for the {@code long} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value a {@code long} value\n+     * @return the sixteen hex characters for the {@code long} value\n+     *\/\n+    public String toHexDigits(long value) {\n+        byte[] rep = new byte[16];\n+        rep[0] = (byte)toHighHexDigit((byte)(value >>> 56));\n+        rep[1] = (byte)toLowHexDigit((byte)(value >>> 56));\n+        rep[2] = (byte)toHighHexDigit((byte)(value >>> 48));\n+        rep[3] = (byte)toLowHexDigit((byte)(value >>> 48));\n+        rep[4] = (byte)toHighHexDigit((byte)(value >>> 40));\n+        rep[5] = (byte)toLowHexDigit((byte)(value >>> 40));\n+        rep[6] = (byte)toHighHexDigit((byte)(value >>> 32));\n+        rep[7] = (byte)toLowHexDigit((byte)(value >>> 32));\n+        rep[8] = (byte)toHighHexDigit((byte)(value >>> 24));\n+        rep[9] = (byte)toLowHexDigit((byte)(value >>> 24));\n+        rep[10] = (byte)toHighHexDigit((byte)(value >>> 16));\n+        rep[11] = (byte)toLowHexDigit((byte)(value >>> 16));\n+        rep[12] = (byte)toHighHexDigit((byte)(value >>> 8));\n+        rep[13] = (byte)toLowHexDigit((byte)(value >>> 8));\n+        rep[14] = (byte)toHighHexDigit((byte)value);\n+        rep[15] = (byte)toLowHexDigit((byte)value);\n+\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Returns up to sixteen hex characters for the {@code long} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value an {@code long} value\n+     * @param digits the number of hexadecimal digits to return, 0 to 16\n+     * @return the hex characters for the {@code long} value\n+     * @throws  IllegalArgumentException if {@code digits} is negative or greater than 16\n+     *\/\n+    public String toHexDigits(long value, int digits) {\n+        if (digits < 0 || digits > 16)\n+            throw new IllegalArgumentException(\"number of digits: \" + digits);\n+        if (digits == 0)\n+            return \"\";\n+        byte[] rep = new byte[digits];\n+        for (int i = rep.length - 1; i >= 0; i--) {\n+            rep[i] = (byte)toLowHexDigit((byte)(value));\n+            value = value >>> 4;\n+        }\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a byte array containing the parsed hex digits.\n+     * A valid string consists only of an even number of hex digits.\n+     *\n+     * @param string a string containing an even number of only hex digits\n+     * @return a byte array\n+     * @throws IllegalArgumentException if the string length is not valid or\n+     *          the string contains non-hex characters\n+     *\/\n+    private byte[] parseNoDelimiter(CharSequence string) {\n+        if ((string.length() & 1) != 0)\n+            throw new IllegalArgumentException(\"string length not even: \" +\n+                    string.length());\n+\n+        byte[] bytes = new byte[string.length() \/ 2];\n+        int illegal = 0;        \/\/ Accumulate logical-or of all bytes\n+        for (int i = 0; i < bytes.length; i++) {\n+            int v = fromHexDigits(string, i * 2);\n+            bytes[i] = (byte) v;\n+            illegal |= v;\n+        }\n+        \/\/ check if any character was an illegal character\n+        if (illegal < 0)\n+            throw new IllegalArgumentException(\"input contains non-hex characters\");\n+\n+        return bytes;\n+    }\n+\n+    \/**\n+     * Check the number of requested digits against a limit.\n+     *\n+     * @param digits the number of digits requested\n+     * @param limit the maximum allowed\n+     *\/\n+    private static void checkDigitCount(int digits, int limit) {\n+        if (digits > limit)\n+            throw new IllegalArgumentException(\"digits greater than \" + limit + \": \" + digits);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the character is a valid hex character or codepoint.\n+     * A character is a valid hexadecimal character if\n+     * {@link Character#digit(int, int) Character.digit(int, 16)} returns\n+     * a positive value.\n+     *\n+     * @param ch a codepoint\n+     * @return {@code true} if the character is valid a hexadecimal character,\n+     *          otherwise {@code false}\n+     *\/\n+    public boolean isHexDigit(int ch) {\n+        return Character.digit(ch, 16) >= 0;\n+    }\n+\n+    \/**\n+     * Returns the value for the hexadecimal character or codepoint.\n+     * The characters {@code \"0-9\", \"A-F\", \"a-f\"} are parsed\n+     * using {@link Character#digit(int, int) Character.digit(int, 16)}.\n+     *\n+     * @param ch a character or codepoint\n+     * @return the value {@code 0..15}\n+     * @throws  NumberFormatException if the codepoint is not a hexadecimal character\n+     *\/\n+    public int fromHexDigit(int ch) {\n+        int value = Character.digit(ch, 16);\n+        if (value < 0)\n+            throw new NumberFormatException(\"not a hexadecimal digit: \\\"\" + (char)ch + \"\\\"\");\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns a value parsed from two hex characters in a string.\n+     * The characters in the range from {@code index} to {@code index + 1} ,\n+     * inclusive, must be valid hex digits according to {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing the characters\n+     * @param index the index of the first character of the range\n+     * @return the value parsed from the string range\n+     * @throws  NumberFormatException if any of the characters in the range\n+     *          is not a hexadecimal character\n+     * @throws  IndexOutOfBoundsException if the sub-range is out of bounds\n+     *          for the {@code CharSequence}\n+     *\/\n+    private int fromHexDigits(CharSequence string, int index) {\n+        Objects.requireNonNull(string, \"string\");\n+        int high = fromHexDigit(string.charAt(index));\n+        int low = fromHexDigit(string.charAt(index + 1));\n+        return (high << 4) | low;\n+    }\n+\n+    \/**\n+     * Returns the {@code int} value parsed from a string of up to eight hexadecimal characters.\n+     * The hexadecimal characters are parsed from most significant to least significant\n+     * using {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing up to eight hex characters\n+     * @return the value parsed from the string\n+     * @throws  IllegalArgumentException if the string length is greater than eight (8) or\n+     *      if any of the characters is not a hexadecimal character\n+     *\/\n+    public int fromHexDigits(CharSequence string) {\n+        Objects.requireNonNull(string, \"string\");\n+        int len = string.length();\n+        checkDigitCount(len, 8);\n+        int value = 0;\n+        for (int i = 0; i < len; i++) {\n+            value = (value << 4) + fromHexDigit(string.charAt(i));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the {@code int} value parsed from a string range of up to eight hexadecimal\n+     * characters.\n+     * The characters in the range from {@code index} to {@code index + length - 1}, inclusive,\n+     * are parsed from most significant to least significant using {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing the characters\n+     * @param index the index of the first character of the range\n+     * @param length the number of hexadecimal digits to parse\n+     * @return the value parsed from the string range\n+     * @throws  IndexOutOfBoundsException if the sub-range is out of bounds\n+     *          for the {@code CharSequence}\n+     * @throws  IllegalArgumentException if length is greater than eight (8) or if\n+     *          any of the characters is not a hexadecimal character\n+     *\/\n+    public int fromHexDigits(CharSequence string, int index, int length) {\n+        Objects.requireNonNull(string, \"string\");\n+        checkDigitCount(length, 8);\n+        Objects.checkFromIndexSize(index, length, string.length());\n+        int value = 0;\n+        for (int i = 0; i < length; i++) {\n+            value = (value << 4) + fromHexDigit(string.charAt(index + i));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the long value parsed from a string of up to sixteen hexadecimal characters.\n+     * The hexadecimal characters are parsed from most significant to least significant\n+     * using {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing up to sixteen hex characters\n+     * @return the value parsed from the string\n+     * @throws  IllegalArgumentException if the string length is greater than sixteen (16) or\n+     *         if any of the characters is not a hexadecimal character\n+     *\/\n+    public long fromHexDigitsToLong(CharSequence string) {\n+        Objects.requireNonNull(string, \"string\");\n+        int len = string.length();\n+        checkDigitCount(len, 16);\n+        long value = 0L;\n+        for (int i = 0; i < len; i++) {\n+            value = (value << 4) + fromHexDigit(string.charAt(i));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the long value parsed parsed from a string range of up to sixteen hexadecimal\n+     * characters.\n+     * The characters in the range from {@code index} to {@code index + length - 1}, inclusive,\n+     * are parsed from most significant to least significant using {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing the characters\n+     * @param index the index of the first character of the range\n+     * @param length the number of hexadecimal digits to parse\n+     * @return the value parsed from the string range\n+     * @throws  IndexOutOfBoundsException if the sub-range is out of bounds\n+     *          for the {@code CharSequence}\n+     * @throws  IllegalArgumentException if {@code length} is greater than sixteen (16) or\n+     *          if any of the characters is not a hexadecimal character\n+     *\/\n+    public long fromHexDigitsToLong(CharSequence string, int index, int length) {\n+        Objects.requireNonNull(string, \"string\");\n+        checkDigitCount(length, 16);\n+        Objects.checkFromIndexSize(index, length, string.length());\n+        long value = 0L;\n+        for (int i = 0; i < length; i++) {\n+            value = (value << 4) + fromHexDigit(string.charAt(index + i));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the other object is a {@code HexFormat}\n+     * with the same parameters.\n+     *\n+     * @param o an object, may be null\n+     * @return {@code true} if the other object is a {@code HexFormat} and the parameters\n+     *         uppercase, delimiter, prefix, and suffix are equal;\n+     *         otherwise {@code false}\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+        HexFormat otherHex = (HexFormat) o;\n+        return delimiter.equals(otherHex.delimiter) &&\n+                prefix.equals(otherHex.prefix) &&\n+                suffix.equals(otherHex.suffix) &&\n+                Arrays.equals(digits, otherHex.digits);\n+    }\n+\n+    \/**\n+     * Returns a hashcode for this {@code HexFormat}.\n+     *\n+     * @return a hashcode for this {@code HexFormat}\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        int result = Objects.hash(delimiter, prefix, suffix);\n+        result = 31 * result + Boolean.hashCode(Arrays.equals(digits, UPPERCASE_DIGITS));\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns a description of the formatter parameters for uppercase,\n+     * delimiter, prefix, and suffix.\n+     *\n+     * @return return a description of this {@code HexFormat}\n+     *\/\n+    @Override\n+    public String toString() {\n+        return escapeNL(\"uppercase: \" + Arrays.equals(digits, UPPERCASE_DIGITS) +\n+                \", delimiter: \\\"\" + delimiter +\n+                \"\\\", prefix: \\\"\" + prefix +\n+                \"\\\", suffix: \\\"\" + suffix + \"\\\"\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":1020,"deletions":0,"binary":false,"changes":1020,"status":"added"},{"patch":"@@ -704,1 +704,1 @@\n-\n+        HexFormat hex = HexFormat.of().withUpperCase();\n@@ -739,6 +739,2 @@\n-                        outBuffer.append('\\\\');\n-                        outBuffer.append('u');\n-                        outBuffer.append(toHex((aChar >> 12) & 0xF));\n-                        outBuffer.append(toHex((aChar >>  8) & 0xF));\n-                        outBuffer.append(toHex((aChar >>  4) & 0xF));\n-                        outBuffer.append(toHex( aChar        & 0xF));\n+                        outBuffer.append(\"\\\\u\");\n+                        outBuffer.append(hex.toHexDigits(aChar));\n@@ -755,0 +751,1 @@\n+        HexFormat hex = HexFormat.of().withUpperCase();\n@@ -759,3 +756,0 @@\n-        char[] uu = new char[6];\n-        uu[0] = '\\\\';\n-        uu[1] = 'u';\n@@ -768,5 +762,2 @@\n-                    uu[2] = toHex((c >> 12) & 0xf);\n-                    uu[3] = toHex((c >>  8) & 0xf);\n-                    uu[4] = toHex((c >>  4) & 0xf);\n-                    uu[5] = toHex( c        & 0xf);\n-                    bw.write(new String(uu));\n+                    bw.write(\"\\\\u\");\n+                    bw.write(hex.toHexDigits(c));\n@@ -1274,13 +1265,0 @@\n-    \/**\n-     * Convert a nibble to a hex character\n-     * @param   nibble  the nibble to convert.\n-     *\/\n-    private static char toHex(int nibble) {\n-        return hexDigit[(nibble & 0xF)];\n-    }\n-\n-    \/** A table of hex digits *\/\n-    private static final char[] hexDigit = {\n-        '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'\n-    };\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/Properties.java","additions":6,"deletions":28,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.HexFormat;\n@@ -55,3 +56,0 @@\n-    \/\/ the hex digitals\n-    private static final char[] HEXES = \"0123456789ABCDEF\".toCharArray();\n-\n@@ -195,16 +193,1 @@\n-\n-        StringBuilder sb = new StringBuilder(bytes.length * 3 - 1);\n-        boolean isInitial = true;\n-        for (byte b : bytes) {\n-            if (isInitial) {\n-                isInitial = false;\n-            } else {\n-                sb.append(':');\n-            }\n-\n-            int k = b & 0xFF;\n-            sb.append(HEXES[k >>> 4]);\n-            sb.append(HEXES[k & 0xF]);\n-        }\n-\n-        return sb.toString();\n+        return HexFormat.ofDelimiter(\":\").withUpperCase().formatHex(bytes);\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SNIServerName.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.HexFormat;\n@@ -50,0 +51,2 @@\n+    private static final HexFormat HEX_UPPERCASE = HexFormat.of().withUpperCase();\n+\n@@ -518,5 +521,0 @@\n-    private static final char[] hexDigits = {\n-        '0', '1', '2', '3', '4', '5', '6', '7',\n-        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n-\n@@ -525,2 +523,1 @@\n-        sb.append(hexDigits[(b >> 4) & 0x0f]);\n-        sb.append(hexDigits[(b >> 0) & 0x0f]);\n+        HEX_UPPERCASE.toHexDigits(sb, b);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/ParseUtil.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.HexFormat;\n@@ -104,0 +105,1 @@\n+        HexFormat hex = HexFormat.of().withUpperCase();\n@@ -110,2 +112,1 @@\n-               sb.append(hexDigits[(c >> 4) & 0x0f]);\n-               sb.append(hexDigits[(c) & 0x0f]);\n+               hex.toHexDigits(sb, (byte)c);\n@@ -241,5 +242,0 @@\n-\n-   private static final char[] hexDigits = {\n-        '0', '1', '2', '3', '4', '5', '6', '7',\n-        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUriUtils.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -192,18 +192,0 @@\n-    \/**\n-     * convert character 'c' that represents a hexadecimal digit to an integer.\n-     * if 'c' is not a hexadecimal digit [0-9A-Fa-f], -1 is returned.\n-     * otherwise the converted value is returned.\n-     *\/\n-    private static int hexchar2int( byte c ) {\n-        if ( c >= '0' && c <= '9' ) {\n-            return( c - '0' );\n-        }\n-        if ( c >= 'A' && c <= 'F' ) {\n-            return( c - 'A' + 10 );\n-        }\n-        if ( c >= 'a' && c <= 'f' ) {\n-            return( c - 'a' + 10 );\n-        }\n-        return( -1 );\n-    }\n-\n@@ -228,1 +210,1 @@\n-                if ((ival = hexchar2int(ch)) < 0) {\n+                if ((ival = Character.digit(ch, 16)) < 0) {\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Filter.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.HexFormat;\n@@ -469,20 +470,0 @@\n-    \/\/ Writes the hex representation of a byte to a StringBuffer.\n-    private static void hexDigit(StringBuffer buf, byte x) {\n-        char c;\n-\n-        c = (char) ((x >> 4) & 0xf);\n-        if (c > 9)\n-            c = (char) ((c-10) + 'A');\n-        else\n-            c = (char)(c + '0');\n-\n-        buf.append(c);\n-        c = (char) (x & 0xf);\n-        if (c > 9)\n-            c = (char)((c-10) + 'A');\n-        else\n-            c = (char)(c + '0');\n-        buf.append(c);\n-    }\n-\n-\n@@ -509,0 +490,1 @@\n+            HexFormat hex = HexFormat.of().withUpperCase().withPrefix(\"\\\\\");\n@@ -510,6 +492,1 @@\n-            StringBuffer b1 = new StringBuffer(bytes.length*3);\n-            for (int i = 0; i < bytes.length; i++) {\n-                b1.append('\\\\');\n-                hexDigit(b1, bytes[i]);\n-            }\n-            return b1.toString();\n+            return hex.formatHex(bytes);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/toolkit\/dir\/SearchFilter.java","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import java.util.HexFormat;\n@@ -1088,11 +1089,0 @@\n-    private static final char[] hexDigits = {\n-            '0', '1', '2', '3', '4', '5', '6', '7',\n-            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n-\n-    private static void appendEscape(StringBuilder sb, byte b) {\n-        sb.append('%');\n-        sb.append(hexDigits[(b >> 4) & 0x0f]);\n-        sb.append(hexDigits[(b >> 0) & 0x0f]);\n-    }\n-\n@@ -1126,0 +1116,1 @@\n+        HexFormat format = HexFormat.of().withUpperCase();\n@@ -1129,4 +1120,6 @@\n-            if (b >= 0x80)\n-                appendEscape(sb, (byte)b);\n-            else\n-                sb.append((char)b);\n+            if (b >= 0x80) {\n+                sb.append('%');\n+                format.toHexDigits(sb, (byte)b);\n+            } else {\n+                sb.append((char) b);\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.HexFormat;\n+\n@@ -404,1 +406,2 @@\n-        StringBuffer sb = new StringBuffer();\n+        HexFormat format = HexFormat.of();\n+        StringBuilder sb = new StringBuilder();\n@@ -409,4 +412,1 @@\n-            if (c < 0x10) sb.append('0');\n-            if (c < 0x100) sb.append('0');\n-            if (c < 0x1000) sb.append('0');\n-            sb.append(Integer.toHexString(c));\n+            sb.append(format.toHexDigits(c));\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/Supplementary.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,482 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.Locale;\n+\n+\/*\n+ * @test\n+ * @summary Check Hex formatting and parsing\n+ * @run testng HexFormatTest\n+ *\/\n+\n+@Test\n+public class HexFormatTest {\n+\n+    @DataProvider(name = \"HexFormattersParsers\")\n+    Object[][] hexFormattersParsers() {\n+        String codeDelim = \", \";\n+        String codePrefix = \"0x\";\n+        String codeSuffix = \"\";\n+        return new Object[][]{\n+                {\"\", \"\", \"\", true,\n+                        HexFormat.of().withUpperCase()},\n+                {\", \", \"#\", \"L\", false,\n+                        HexFormat.ofDelimiter(\", \").withPrefix(\"#\").withSuffix(\"L\")},\n+                {\"\", \"\", \"\", false,\n+                        HexFormat.of().withPrefix(\"\").withSuffix(\"\")},\n+                {\".\", \"\", \"\", false,\n+                        HexFormat.ofDelimiter(\".\").withPrefix(\"\").withSuffix(\"\")},\n+                {\",\", \"0x\", \"\", true,\n+                        HexFormat.ofDelimiter(\",\").withUpperCase().withPrefix(\"0x\").withSuffix(\"\")},\n+                {codeDelim, codePrefix, codeSuffix, false,\n+                        HexFormat.ofDelimiter(codeDelim).withPrefix(codePrefix).withSuffix(codeSuffix)},\n+\n+        };\n+    }\n+\n+    @DataProvider(name = \"HexStringsThrowing\")\n+    Object[][] HexStringsThrowing() {\n+        return new Object[][]{\n+                {\"0\", \":\", \"\", \"\"},         \/\/ wrong string length\n+                {\"01:\", \":\", \"\", \"\"},       \/\/ wrong string length\n+                {\"01:0\", \":\", \"\", \"\"},      \/\/ wrong string length\n+                {\"0\", \",\", \"\", \"\"},         \/\/ wrong length and separator\n+                {\"01:\", \",\", \"\", \"\"},       \/\/ wrong length and separator\n+                {\"01:0\", \",\", \"\", \"\"},      \/\/ wrong length and separator\n+                {\"01:00\", \",\", \"\", \"\"},     \/\/ wrong separator\n+                {\"00]\", \",\", \"[\", \"]\"},     \/\/ missing prefix\n+                {\"[00\", \",\", \"[\", \"]\"},     \/\/ missing suffix\n+                {\"]\", \",\", \"[\", \"]\"},       \/\/ missing prefix\n+                {\"[\", \",\", \"[\", \"]\"},       \/\/ missing suffix\n+                {\"00\", \",\", \"abc\", \"\"},     \/\/ Prefix longer than string\n+                {\"01\", \",\", \"\", \"def\"},     \/\/ Suffix longer than string\n+                {\"abc00,\", \",\", \"abc\", \"\"},     \/\/ Prefix and delim but not another value\n+                {\"01def,\", \",\", \"\", \"def\"},     \/\/ Suffix and delim but not another value\n+        };\n+    }\n+\n+    @DataProvider(name = \"BadBytesThrowing\")\n+    Object[][] badBytesThrowing() {\n+        return new Object[][]{\n+                {new byte[1], 0, 2},        \/\/ bad length\n+                {new byte[1], 1, 1},        \/\/ bad offset + length\n+                {new byte[1], -1, 2},       \/\/ bad length\n+                {new byte[1], -1, 1},       \/\/ bad offset + length\n+                {new byte[1], 0, -1},       \/\/ bad length\n+                {new byte[1], 1, -1},       \/\/ bad offset + length\n+        };\n+    }\n+\n+    @DataProvider(name = \"BadParseHexThrowing\")\n+    Object[][] badParseHexThrowing() {\n+        return new Object[][]{\n+                {\"a\", 0, 2, IndexOutOfBoundsException.class},        \/\/ bad length\n+                {\"b\", 1, 1, IndexOutOfBoundsException.class},        \/\/ bad offset + length\n+                {\"a\", -1, 2, IndexOutOfBoundsException.class},       \/\/ bad length\n+                {\"b\", -1, 1, IndexOutOfBoundsException.class},       \/\/ bad offset + length\n+                {\"a\", 0, -1, IndexOutOfBoundsException.class},       \/\/ bad length\n+                {\"b\", 1, -1, IndexOutOfBoundsException.class},       \/\/ bad offset + length\n+                {\"76543210\", 0, 7, IllegalArgumentException.class},  \/\/ odd number of digits\n+        };\n+    }\n+\n+    @DataProvider(name = \"BadFromHexDigitsThrowing\")\n+    Object[][] badHexDigitsThrowing() {\n+        return new Object[][]{\n+                {\"a\", 0, 2, IndexOutOfBoundsException.class},        \/\/ bad length\n+                {\"b\", 1, 1, IndexOutOfBoundsException.class},        \/\/ bad offset + length\n+                {\"a\", -1, 2, IndexOutOfBoundsException.class},       \/\/ bad length\n+                {\"b\", -1, 1, IndexOutOfBoundsException.class},       \/\/ bad offset + length\n+                {\"a\", 0, -1, IndexOutOfBoundsException.class},       \/\/ bad length\n+                {\"b\", 1, -1, IndexOutOfBoundsException.class},       \/\/ bad offset + length\n+        };\n+    }\n+\n+    static byte[] genBytes(int origin, int len) {\n+        byte[] bytes = new byte[len];\n+        for (int i = 0; i < len; i++)\n+            bytes[i] = (byte) (origin + i);\n+        return bytes;\n+    }\n+\n+    @Test\n+    static void testToHex() {\n+        HexFormat hex = HexFormat.of();\n+        for (int i = 0; i < 32; i++) {\n+            char c = hex.toLowHexDigit((byte)i);\n+            String expected = Integer.toHexString(i & 0xf);\n+            Assert.assertEquals(c, expected.charAt(0), \"toHex formatting\");\n+        }\n+    }\n+\n+    @Test\n+    static void testToHexPair() {\n+        HexFormat hex = HexFormat.of();\n+        for (int i = 0; i < 256; i++) {\n+            String actual = hex.toHexDigits((byte)i);\n+            int expected = hex.fromHexDigits(actual);\n+            Assert.assertEquals(expected, i, \"byteFromHex formatting\");\n+            Assert.assertEquals(actual.charAt(0), hex.toHighHexDigit((byte)i),\n+                    \"first char mismatch\");\n+            Assert.assertEquals(actual.charAt(1), hex.toLowHexDigit((byte)i),\n+                    \"second char mismatch\");\n+        }\n+    }\n+\n+    @Test\n+    static void testFromHex() {\n+        HexFormat hex = HexFormat.of();\n+        String chars = \"0123456789ABCDEF0123456789abcdef\";\n+        for (int i = 0; i < chars.length(); i++) {\n+            int v = hex.fromHexDigit(chars.charAt(i));\n+            Assert.assertEquals(v, i & 0xf, \"fromHex decode\");\n+        }\n+    }\n+\n+    @Test\n+    static void testFromHexInvalid() {\n+        HexFormat hex = HexFormat.of();\n+        \/\/ An assortment of invalid characters\n+        String chars = \"\\u0000 \/:\\u0040G\\u0060g\\u007f\";\n+        for (int i = 0; i < chars.length(); i++) {\n+            char ch = chars.charAt(i);\n+            Throwable ex = Assert.expectThrows(NumberFormatException.class,\n+                    () -> hex.fromHexDigit(ch));\n+            System.out.println(ex);\n+        }\n+    }\n+\n+    @Test\n+    static void testAppendHexByte() {\n+        HexFormat hex = HexFormat.of();\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < 256; i++) {\n+            sb.setLength(0);\n+            hex.toHexDigits(sb, (byte)i);\n+            Assert.assertEquals(sb.length(), 2, \"wrong length after append: \" + i);\n+            Assert.assertEquals(sb.charAt(0), hex.toHighHexDigit((byte)i), \"MSB converted wrong\");\n+            Assert.assertEquals(sb.charAt(1), hex.toLowHexDigit((byte)i), \"LSB converted wrong\");\n+\n+            Assert.assertEquals(hex.fromHexDigits(sb), i, \"hex.format(sb, byte) wrong\");\n+        }\n+    }\n+\n+    @Test\n+    static void testFromHexPairInvalid() {\n+                HexFormat hex = HexFormat.of();\n+\n+        \/\/ An assortment of invalid characters\n+        String chars = \"-0--0-\";\n+        for (int i = 0; i < chars.length(); i += 2) {\n+            final int ndx = i;\n+            Throwable ex = Assert.expectThrows(NumberFormatException.class,\n+                    () -> hex.fromHexDigits(chars.subSequence(ndx, ndx+2)));\n+            System.out.println(ex);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"HexStringsThrowing\")\n+    static void testToBytesThrowing(String value, String sep, String prefix, String suffix) {\n+        HexFormat hex = HexFormat.ofDelimiter(sep).withPrefix(prefix).withSuffix(suffix);\n+        Throwable ex = Assert.expectThrows(IllegalArgumentException.class,\n+                () -> {\n+                    byte[] v = hex.parseHex(value);\n+                    System.out.println(\"str: \" + value + \", actual: \" + v + \", bytes: \" +\n+                                    Arrays.toString(v));\n+                });\n+        System.out.println(\"ex: \" + ex);\n+    }\n+\n+    @Test\n+    static void testFactoryNPE() {\n+        Assert.assertThrows(NullPointerException.class, () -> HexFormat.ofDelimiter(null));\n+        Assert.assertThrows(NullPointerException.class, () -> HexFormat.of().withDelimiter(null));\n+        Assert.assertThrows(NullPointerException.class, () -> HexFormat.of().withPrefix(null));\n+        Assert.assertThrows(NullPointerException.class, () -> HexFormat.of().withSuffix(null));\n+    }\n+\n+    @Test\n+    static void testFormatHexNPE() {\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().formatHex(null));\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().formatHex(null, 0, 1));\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().formatHex(null, null));\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().formatHex(null, null, 0, 0));\n+        StringBuilder sb = new StringBuilder();\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().formatHex(sb, null));\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().formatHex(sb, null, 0, 1));\n+    }\n+\n+    @Test\n+    static void testParseHexNPE() {\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().parseHex(null));\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().parseHex((String)null, 0, 0));\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().parseHex((char[])null, 0, 0));\n+    }\n+\n+    @Test\n+    static void testFromHexNPE() {\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().fromHexDigits(null));\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().fromHexDigits(null, 0, 0));\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().fromHexDigitsToLong(null));\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().fromHexDigitsToLong(null, 0, 0));\n+    }\n+\n+    @Test\n+    static void testToHexDigitsNPE() {\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> HexFormat.of().toHexDigits(null, (byte)0));\n+    }\n+\n+    @Test(dataProvider = \"BadParseHexThrowing\")\n+    static void badParseHex(String string, int offset, int length,\n+                            Class<? extends Throwable> exClass) {\n+        Assert.assertThrows(exClass,\n+                () -> HexFormat.of().parseHex(string, offset, length));\n+        char[] chars = string.toCharArray();\n+        Assert.assertThrows(exClass,\n+                () -> HexFormat.of().parseHex(chars, offset, length));\n+    }\n+\n+    @Test(dataProvider = \"BadFromHexDigitsThrowing\")\n+    static void badFromHexDigits(String string, int offset, int length,\n+                           Class<? extends Throwable> exClass) {\n+        Assert.assertThrows(exClass,\n+                () -> HexFormat.of().fromHexDigits(string, offset, length));\n+        Assert.assertThrows(exClass,\n+                () -> HexFormat.of().fromHexDigitsToLong(string, offset, length));\n+    }\n+\n+    \/\/ Verify IAE for strings that are too long for the target primitive type\n+    \/\/ or the number of requested digits is too large.\n+    @Test\n+    static void wrongNumberDigits() {\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                () -> HexFormat.of().fromHexDigits(\"9876543210\"));\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                () -> HexFormat.of().fromHexDigits(\"9876543210\", 0, 9));\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                () -> HexFormat.of().fromHexDigitsToLong(\"98765432109876543210\"));\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                () -> HexFormat.of().fromHexDigitsToLong(\"98765432109876543210\", 0, 17));\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatter(String delimiter, String prefix, String suffix,\n+                                   boolean uppercase,\n+                                   HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        String res = hex.formatHex(expected);\n+        Assert.assertTrue(res.startsWith(prefix), \"Prefix not found\");\n+        Assert.assertTrue(res.endsWith(suffix), \"Suffix not found\");\n+        int expectedLen = expected.length * (2 + prefix.length() +\n+                delimiter.length() + suffix.length()) - delimiter.length();\n+        Assert.assertEquals(res.length(), expectedLen, \"String length\");\n+\n+        if (expected.length > 1) {\n+            \/\/ check prefix and suffix is present for each hex pair\n+            for (int i = 0; i < expected.length; i++) {\n+                int valueChars = prefix.length() + 2 + suffix.length();\n+                int offset = i * (valueChars + delimiter.length());\n+                String value = res.substring(offset, offset + valueChars);\n+                Assert.assertTrue(value.startsWith(prefix), \"wrong prefix\");\n+                Assert.assertTrue(value.endsWith(suffix), \"wrong suffix\");\n+\n+                \/\/ Check case of digits\n+                String cc = value.substring(prefix.length(), prefix.length() + 2);\n+                Assert.assertEquals(cc,\n+                        (uppercase) ? cc.toUpperCase(Locale.ROOT) : cc.toLowerCase(Locale.ROOT),\n+                        \"Case mismatch\");\n+                if (i < expected.length - 1 && !delimiter.isEmpty()) {\n+                    \/\/ Check the delimiter is present for each pair except the last\n+                    Assert.assertEquals(res.substring(offset + valueChars,\n+                            offset + valueChars + delimiter.length()), delimiter);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testDecoderString(String unused1, String unused2, String unused3,\n+                                   boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        String s = hex.formatHex(expected);\n+        System.out.println(\"    formatted: \" + s);\n+\n+        byte[] actual = hex.parseHex(s);\n+        System.out.println(\"    parsed as: \" + Arrays.toString(expected));\n+        int mismatch = Arrays.mismatch(expected, actual);\n+        Assert.assertEquals(actual, expected, \"encode\/decode cycle failed, mismatch: \" + mismatch);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testDecoderCharArray(String unused1, String unused2, String unused3,\n+                                     boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        String s = hex.formatHex(expected);\n+        System.out.println(\"    formatted: \" + s);\n+\n+        char[] chars = s.toCharArray();\n+        byte[] actual = hex.parseHex(chars, 0, chars.length);\n+        System.out.println(\"    parsed as: \" + Arrays.toString(expected));\n+        int mismatch = Arrays.mismatch(expected, actual);\n+        Assert.assertEquals(actual, expected, \"format\/parse cycle failed, mismatch: \" + mismatch);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatterToString(String delimiter, String prefix, String suffix,\n+                                    boolean uppercase,\n+                                    HexFormat hex) {\n+        String actual = String.format(\n+                \"uppercase: %s, delimiter: \\\"%s\\\", prefix: \\\"%s\\\", suffix: \\\"%s\\\"\",\n+                uppercase, escapeNL(delimiter), escapeNL(prefix), escapeNL(suffix));\n+        System.out.println(\"    hex: \" + actual);\n+        Assert.assertEquals(actual, hex.toString(), \"Formatter toString mismatch\");\n+    }\n+\n+    private static String escapeNL(String string) {\n+        return string.replace(\"\\n\", \"\\\\n\")\n+                .replace(\"\\r\", \"\\\\r\");\n+    }\n+\n+    @Test\n+    static void testVariableLength() {\n+        HexFormat hex = HexFormat.of();\n+\n+        String allHex = \"fedcba9876543210\";\n+        final long orig = 0xfedcba9876543210L;\n+        for (int digits = 0; digits <= 16; digits++) {\n+            String s = hex.toHexDigits(orig, digits);\n+            long actual = hex.fromHexDigitsToLong(s, 0, digits);\n+            System.out.printf(\"    digits: %2d, formatted: \\\"%s\\\", parsed as: 0x%016xL%n\",\n+                    digits, s, actual);\n+            Assert.assertEquals(s, allHex.substring(16 - digits, 16));\n+            long expected = (digits < 16) ? orig & ~(0xffffffffffffffffL << (4 * digits)) : orig;\n+            Assert.assertEquals(actual, expected);\n+        }\n+    }\n+\n+    \/**\n+     * Example code from the HexFormat javadoc.\n+     * Showing simple usage of the API using \"assert\" to express the correct results\n+     * when shown in the javadoc.\n+     * The additional TestNG asserts verify the correctness of the same code.\n+     *\/\n+    @Test\n+    private static void samples() {\n+        {\n+            \/\/ Primitive formatting and parsing.\n+            HexFormat hex = HexFormat.of();\n+\n+            byte b = 127;\n+            String byteStr = hex.toHexDigits(b);\n+            System.out.println(\"    \" + byteStr);\n+\n+            int byteVal = hex.fromHexDigits(byteStr);\n+            assert(byteStr.equals(\"7f\"));\n+            assert(b == byteVal);\n+            Assert.assertTrue(byteStr.equals(\"7f\"));\n+            Assert.assertTrue(b == byteVal);\n+\n+\n+            char c = 'A';\n+            String charStr = hex.toHexDigits(c);\n+            System.out.println(\"    \" + charStr);\n+            int charVal = hex.fromHexDigits(charStr);\n+            assert(c == charVal);\n+            Assert.assertTrue(c == charVal);\n+\n+            int i = 12345;\n+            String intStr = hex.toHexDigits(i);\n+            System.out.println(\"    \" + intStr);\n+            int intVal = hex.fromHexDigits(intStr);\n+            assert(i == intVal);\n+            Assert.assertTrue(i == intVal);\n+\n+            long l = Long.MAX_VALUE;\n+            String longStr = hex.toHexDigits(l, 16);\n+            long longVal = hex.fromHexDigitsToLong(longStr, 0, 16);\n+            System.out.println(\"    \" + longStr + \", \" + longVal);\n+            assert(l == longVal);\n+            Assert.assertTrue(l == longVal);\n+        }\n+\n+        {\n+            \/\/ RFC 4752 Fingerprint\n+            HexFormat formatFingerprint = HexFormat.ofDelimiter(\":\").withUpperCase();\n+            byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+            String str = formatFingerprint.formatHex(bytes);\n+            System.out.println(\"    Formatted: \" + str);\n+\n+            byte[] parsed = formatFingerprint.parseHex(str);\n+            System.out.println(\"    Parsed: \" + Arrays.toString(parsed));\n+            assert(Arrays.equals(bytes, parsed));\n+            Assert.assertTrue(Arrays.equals(bytes, parsed));\n+        }\n+\n+        {\n+            \/\/ Comma separated formatting\n+            HexFormat commaFormat = HexFormat.ofDelimiter(\",\");\n+            byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+            String str = commaFormat.formatHex(bytes);\n+            System.out.println(\"    Formatted: \" + str);\n+\n+            byte[] parsed = commaFormat.parseHex(str);\n+            System.out.println(\"    Parsed: \" + Arrays.toString(parsed));\n+            assert(Arrays.equals(bytes, parsed));\n+            Assert.assertTrue(Arrays.equals(bytes, parsed));\n+        }\n+        {\n+            \/\/ Text formatting\n+            HexFormat commaFormat = HexFormat.ofDelimiter(\", \").withPrefix(\"#\");\n+            byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+            String str = commaFormat.formatHex(bytes);\n+            System.out.println(\"    Formatted: \" + str);\n+\n+            byte[] parsed = commaFormat.parseHex(str);\n+            System.out.println(\"    Parsed:    \" + Arrays.toString(parsed));\n+            assert(Arrays.equals(bytes, parsed));\n+            Assert.assertTrue(Arrays.equals(bytes, parsed));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/HexFormat\/HexFormatTest.java","additions":482,"deletions":0,"binary":false,"changes":482,"status":"added"},{"patch":"@@ -36,5 +36,0 @@\n-    char[] hex = {'0', '1', '2', '3',\n-                  '4', '5', '6', '7',\n-                  '8', '9', 'A', 'B',\n-                  'C', 'D', 'E', 'F'};\n-\n@@ -46,20 +41,0 @@\n-    String toHex(String str) {\n-        StringBuffer buff = new StringBuffer();\n-        int y=0;\n-        for(int x=0; x < str.length(); ++x) {\n-            buff.append(\"\\\\u\");\n-            buff.append(toHex(str.charAt(x)));\n-        }\n-        return buff.toString();\n-    }\n-\n-    String toHex(char ch) {\n-        StringBuffer buff = new StringBuffer();\n-        buff.append(hex[ch>>12]);\n-        buff.append(hex[(ch>>8) & 0x0F]);\n-        buff.append(hex[(ch>>4) & 0x0F]);\n-        buff.append(hex[ch & 0x0F]);\n-        return buff.toString();\n-    }\n-\n-\n","filename":"test\/jdk\/java\/util\/Locale\/ThaiGov.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"}]}