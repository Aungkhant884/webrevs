{"files":[{"patch":"@@ -262,1 +262,1 @@\n-     * {@link java.util.HexFormat} provides formatting and parsing\n+     * The {@link java.util.HexFormat} class provides formatting and parsing\n@@ -264,1 +264,1 @@\n-     * HexFormat formats and parses uppercase or lowercase hexadecimal characters,\n+     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-     * {@link java.util.HexFormat} provides formatting and parsing\n+     * The {@link java.util.HexFormat} class provides formatting and parsing\n@@ -299,1 +299,1 @@\n-     * HexFormat formats and parses uppercase or lowercase hexadecimal characters,\n+     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n- * Converts between bytes and chars and hex-encoded strings which may include additional\n- * formatting markup such as prefixes, suffixes, and delimiters.\n+ * {@code HexFormat} converts between bytes and chars and hex-encoded strings which may include\n+ * additional formatting markup such as prefixes, suffixes, and delimiters.\n@@ -75,1 +75,1 @@\n- * Each byte value is parsed as the prefix, two case insensitive hexadecimal characters,\n+ * Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n@@ -171,1 +171,2 @@\n-    private static final byte[] emptyBytes = new byte[0];\n+    private static final byte[] EMPTY_BYTES = new byte[0];\n+\n@@ -346,2 +347,3 @@\n-            StringBuilder sb = new StringBuilder((toIndex - fromIndex) *\n-                    (delimiter.length() + prefix.length() + 2 + suffix.length()) - delimiter.length());\n+            long stride = prefix.length() + 2L + suffix.length() + delimiter.length();\n+            int capacity = checkMaxArraySize((toIndex - fromIndex) * stride - delimiter.length());\n+            StringBuilder sb = new StringBuilder(capacity);\n@@ -361,2 +363,2 @@\n-     * @param <A> The type of Appendable\n-     * @param out an Appendable, non-null\n+     * @param <A> The type of {@code Appendable}\n+     * @param out an {@code Appendable}, non-null\n@@ -378,2 +380,2 @@\n-     * @param <A> The type of Appendable\n-     * @param out an Appendable, non-null\n+     * @param <A> The type of {@code Appendable}\n+     * @param out an {@code Appendable}, non-null\n@@ -436,1 +438,1 @@\n-            rep = new byte[length * 2];\n+            rep = new byte[checkMaxArraySize(length * 2L)];\n@@ -445,1 +447,1 @@\n-            rep = new byte[length * 3 - 1];\n+            rep = new byte[checkMaxArraySize(length * 3L - 1L)];\n@@ -465,0 +467,14 @@\n+    \/**\n+     * Checked that the requested size for the result string is less than the max array size.\n+     *\n+     * @param length the requested size of a byte array.\n+     * @return the length\n+     * @throws OutOfMemoryError if the size is larger than Integer.MAX_VALUE\n+     *\/\n+    private static int checkMaxArraySize(long length) {\n+        if (length > Integer.MAX_VALUE)\n+            throw new OutOfMemoryError(\"String size \" + length +\n+                    \" exceeds maximum \" + (Integer.MAX_VALUE));\n+        return (int)length;\n+    }\n+\n@@ -468,1 +484,1 @@\n-     * Each byte value is parsed as the prefix, two case insensitive hexadecimal characters,\n+     * Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n@@ -487,1 +503,1 @@\n-     * Each byte value is parsed as the prefix, two case insensitive hexadecimal characters,\n+     * Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n@@ -511,1 +527,1 @@\n-            return emptyBytes;\n+            return EMPTY_BYTES;\n@@ -515,2 +531,3 @@\n-        int valueChars = prefix.length() + 2 + suffix.length();\n-        int stride = valueChars + delimiter.length();\n+        \/\/ avoid overflow for max length prefix or suffix\n+        long valueChars = prefix.length() + 2L + suffix.length();\n+        long stride = valueChars + delimiter.length();\n@@ -524,1 +541,1 @@\n-        final int len = (string.length() - valueChars) \/ stride + 1;\n+        final int len = (int)((string.length() - valueChars) \/ stride + 1L);\n@@ -546,1 +563,1 @@\n-     * Each byte value is parsed as the prefix, two case insensitive hexadecimal characters,\n+     * Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n@@ -659,2 +676,2 @@\n-     * @param <A> The type of Appendable\n-     * @param out an Appendable, non-null\n+     * @param <A> The type of {@code Appendable}\n+     * @param out an {@code Appendable}, non-null\n@@ -740,2 +757,1 @@\n-     * Returns the sixteen hexadecimal characters for the {@code long} value\n-     * considering it to be unsigned.\n+     * Returns the sixteen hexadecimal characters for the {@code long} value.\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":39,"deletions":23,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run testng HexFormatTest\n+ * @run testng\/othervm HexFormatTest\n@@ -625,0 +625,18 @@\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testOOME(String delimiter, String prefix, String suffix, boolean uppercase,\n+                         HexFormat hex) {\n+        \/\/ compute the size of byte array that will exceed the buffer\n+        long valueChars = prefix.length() + 2 + suffix.length();\n+        long stride = valueChars + delimiter.length();\n+        long max = Integer.MAX_VALUE & 0xFFFFFFFFL;\n+        long len = max \/ stride;\n+        long remainder = max - ((len - 1) * stride);\n+        if (remainder > valueChars) {\n+            len++;\n+        }\n+        byte[] bytes = new byte[(int)len];\n+        Throwable ex = expectThrows(OutOfMemoryError.class,\n+                () -> hex.formatHex(bytes));\n+        System.out.println(\"ex: \" + ex);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/HexFormat\/HexFormatTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}