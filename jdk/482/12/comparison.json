{"files":[{"patch":"@@ -260,0 +260,7 @@\n+     * <p>\n+     * @apiNote\n+     * The {@link java.util.HexFormat} class provides formatting and parsing\n+     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n+     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n+     * with leading zeros and for byte arrays includes for each byte\n+     * a delimiter, prefix, and suffix.\n@@ -264,0 +271,1 @@\n+     * @see java.util.HexFormat\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -295,0 +295,7 @@\n+     * <p>\n+     * @apiNote\n+     * The {@link java.util.HexFormat} class provides formatting and parsing\n+     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n+     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n+     * with leading zeros and for byte arrays includes for each byte\n+     * a delimiter, prefix, and suffix.\n@@ -300,0 +307,1 @@\n+     * @see java.util.HexFormat\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.HexFormat;\n@@ -478,0 +479,1 @@\n+                        HexFormat hex = HexFormat.of();\n@@ -479,2 +481,2 @@\n-                                 \" recorded in %s\", dn, toHexString(actualHash),\n-                                 toHexString(recordedHash), descriptor.name());\n+                                 \" recorded in %s\", dn, hex.formatHex(actualHash),\n+                                hex.formatHex(recordedHash), descriptor.name());\n@@ -488,9 +490,0 @@\n-    private static String toHexString(byte[] ba) {\n-        StringBuilder sb = new StringBuilder(ba.length * 2);\n-        for (byte b: ba) {\n-            sb.append(String.format(\"%02x\", b & 0xff));\n-        }\n-        return sb.toString();\n-    }\n-\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/Resolver.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,1063 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ * {@code HexFormat} converts between bytes and chars and hex-encoded strings which may include\n+ * additional formatting markup such as prefixes, suffixes, and delimiters.\n+ * <p>\n+ * There are two factories of {@code HexFormat} with preset parameters {@link #of()} and\n+ * {@link #ofDelimiter(String) ofDelimiter(delimiter)}. For other parameter combinations\n+ * the {@code withXXX} methods return copies of {@code HexFormat} modified\n+ * {@link #withPrefix(String)}, {@link #withSuffix(String)}, {@link #withDelimiter(String)}\n+ * or choice of {@link #withUpperCase()} or {@link #withLowerCase()} parameters.\n+ * <p>\n+ * For primitive to hexadecimal string conversions the {@code toHexDigits}\n+ * methods include {@link #toHexDigits(byte)}, {@link #toHexDigits(int)}, and\n+ * {@link #toHexDigits(long)}, etc. The default is to use lowercase characters {@code \"0-9\",\"a-f\"}.\n+ * For conversions producing uppercase hexadecimal the characters are {@code \"0-9\",\"A-F\"}.\n+ *\n+ * <p>\n+ * For hexadecimal string to primitive conversions the {@code fromHexDigits}\n+ * methods include {@link #fromHexDigits(CharSequence) fromHexDigits(string)},\n+ * {@link #fromHexDigitsToLong(CharSequence) fromHexDigitsToLong(string)}, and\n+ * {@link #fromHexDigit(int) fromHexDigit(int)} converts a single character or codepoint.\n+ * For conversions from hexadecimal characters the digits and uppercase and lowercase\n+ * characters in {@code \"0-9\", \"a-f\", and \"A-F\"} are converted to corresponding values\n+ * {@code 0-15}.\n+ * <p>\n+ * For byte array to formatted hexadecimal string conversions\n+ * the {@code formatHex} methods include {@link #formatHex(byte[]) formatHex(byte[])}\n+ * and {@link #formatHex(Appendable, byte[]) formatHex(Appendable, byte[])}.\n+ * The formatted output is a string or is appended to an {@link Appendable} such as\n+ * {@link StringBuilder} or {@link java.io.PrintStream}.\n+ * Each byte value is formatted as the prefix, two hexadecimal characters from the\n+ * uppercase or lowercase digits, and the suffix.\n+ * A delimiter follows each formatted value, except the last.\n+ * For conversions producing uppercase hexadecimal strings use {@link #withUpperCase()}.\n+ *\n+ * <p>\n+ * For formatted hexadecimal string to byte array conversions the\n+ * {@code parseHex} methods include {@link #parseHex(CharSequence) parseHex(CharSequence)} and\n+ * {@link #parseHex(char[], int, int) parseHex(char[], offset, length)}.\n+ * Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n+ * and the suffix. A delimiter follows each formatted value, except the last.\n+ *\n+ * @apiNote\n+ * For example, an individual byte is converted to a string of hexadecimal digits using\n+ * {@link HexFormat#toHexDigits(int) toHexDigits(int)} and converted from a string to a\n+ * primitive value using {@link HexFormat#fromHexDigits(CharSequence) fromHexDigits(string)}.\n+ * <pre>{@code\n+ *     HexFormat hex = HexFormat.of();\n+ *     byte b = 127;\n+ *     String byteStr = hex.toHexDigits(b);\n+ *\n+ *     byte byteVal = (byte)hex.fromHexDigits(byteStr);\n+ *     assert(byteStr.equals(\"7f\"));\n+ *     assert(b == byteVal);\n+ *\n+ *     \/\/ The hexadecimal digits are: \"7f\"\n+ * }<\/pre>\n+ * <p>\n+ * For a comma ({@code \", \"}) separated format with a prefix ({@code \"#\"})\n+ * using lowercase hex digits the {@code HexFormat} is:\n+ * <pre>{@code\n+ *     HexFormat commaFormat = HexFormat.ofDelimiter(\", \").withPrefix(\"#\");\n+ *     byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+ *     String str = commaFormat.formatHex(bytes);\n+ *\n+ *     byte[] parsed = commaFormat.parseHex(str);\n+ *     assert(Arrays.equals(bytes, parsed));\n+ *\n+ *     \/\/ The formatted string is: \"#00, #01, #02, #03, #7c, #7d, #7e, #7f\"\n+ * }<\/pre>\n+ * <p>\n+ * For a fingerprint of byte values that uses the delimiter colon ({@code \":\"})\n+ * and uppercase characters the {@code HexFormat} is:\n+ * <pre>{@code\n+ *     HexFormat formatFingerprint = HexFormat.ofDelimiter(\":\").withUpperCase();\n+ *     byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+ *     String str = formatFingerprint.formatHex(bytes);\n+ *     byte[] parsed = formatFingerprint.parseHex(str);\n+ *     assert(Arrays.equals(bytes, parsed));\n+ *\n+ *     \/\/ The formatted string is: \"00:01:02:03:7C:7D:7E:7F\"\n+ * }<\/pre>\n+ *\n+ * <p>\n+ * This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n+ * class; use of identity-sensitive operations (including reference equality\n+ * ({@code ==}), identity hash code, or synchronization) on instances of\n+ * {@code HexFormat} may have unpredictable results and should be avoided.\n+ * The {@code equals} method should be used for comparisons.\n+ * <p>\n+ * This class is immutable and thread-safe.\n+ * <p>\n+ * Unless otherwise noted, passing a null argument to any method will cause a\n+ * {@link java.lang.NullPointerException NullPointerException} to be thrown.\n+ *\n+ * @since 16\n+ *\/\n+\n+\n+public final class HexFormat {\n+\n+    \/\/ Access to create strings from a byte array.\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n+    private static final byte[] UPPERCASE_DIGITS = {\n+            '0', '1', '2', '3', '4', '5', '6', '7',\n+            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',\n+    };\n+    private static final byte[] LOWERCASE_DIGITS = {\n+            '0', '1', '2', '3', '4', '5', '6', '7',\n+            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n+    };\n+    \/\/ Analysis has shown that generating the whole array allows the JIT to generate\n+    \/\/ better code compared to a slimmed down array, such as one cutting off after 'f'\n+    private static final byte[] DIGITS = new byte[] {\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1,\n+            -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12,\n+            13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };\n+    \/**\n+     * Format each byte of an array as a pair of hexadecimal digits.\n+     * The hexadecimal characters are from lowercase alpha digits.\n+     *\/\n+    private static final HexFormat HEX_FORMAT =\n+            new HexFormat(\"\", \"\", \"\", LOWERCASE_DIGITS);\n+\n+    private static final byte[] EMPTY_BYTES = new byte[0];\n+\n+    private final String delimiter;\n+    private final String prefix;\n+    private final String suffix;\n+    private final byte[] digits;\n+\n+    \/**\n+     * Returns a HexFormat with a delimiter, prefix, suffix, and array of digits.\n+     *\n+     * @param delimiter a delimiter, non-null\n+     * @param prefix a prefix, non-null\n+     * @param suffix a suffix, non-null\n+     * @param digits byte array of digits indexed by low nibble, non-null\n+     * @throws NullPointerException if any argument is null\n+     *\/\n+    private HexFormat(String delimiter, String prefix, String suffix, byte[] digits) {\n+        this.delimiter = Objects.requireNonNull(delimiter, \"delimiter\");\n+        this.prefix = Objects.requireNonNull(prefix, \"prefix\");\n+        this.suffix = Objects.requireNonNull(suffix, \"suffix\");\n+        this.digits = Objects.requireNonNull(digits, \"digits\");\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal formatter with no delimiter and lowercase characters.\n+     * The delimiter, prefix, and suffix are empty.\n+     * The methods {@link #withDelimiter(String) withDelimiter},\n+     * {@link #withUpperCase() withUpperCase}, {@link #withLowerCase() withLowerCase},\n+     * {@link #withPrefix(String) withPrefix}, and {@link #withSuffix(String) withSuffix}\n+     * return copies of formatters with new parameters.\n+     *\n+     * @return a hexadecimal formatter with no delimiter and lowercase characters\n+     *\/\n+    public static HexFormat of() {\n+        return HEX_FORMAT;\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal formatter with the delimiter and lowercase characters.\n+     * The prefix and suffix are empty.\n+     * The methods {@link #withDelimiter(String) withDelimiter},\n+     * {@link #withUpperCase() withUpperCase}, {@link #withLowerCase() withLowerCase},\n+     * {@link #withPrefix(String) withPrefix}, and {@link #withSuffix(String) withSuffix}\n+     * return copies of formatters with new parameters.\n+     *\n+     * @param delimiter a delimiter, non-null, may be empty\n+     * @return a {@link HexFormat} with the delimiter and lowercase characters\n+     *\/\n+    public static HexFormat ofDelimiter(String delimiter) {\n+        return new HexFormat(delimiter, \"\", \"\", LOWERCASE_DIGITS);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} with the delimiter.\n+     * @param delimiter the delimiter, non-null, may be empty\n+     * @return a copy of this {@code HexFormat} with the delimiter\n+     *\/\n+    public HexFormat withDelimiter(String delimiter) {\n+        return new HexFormat(delimiter, this.prefix, this.suffix, this.digits);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} with the prefix.\n+     *\n+     * @param prefix a prefix, non-null, may be empty\n+     * @return a copy of this {@code HexFormat} with the prefix\n+     *\/\n+    public HexFormat withPrefix(String prefix) {\n+        return new HexFormat(this.delimiter, prefix, this.suffix, this.digits);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} with the suffix.\n+     *\n+     * @param suffix a suffix, non-null, may be empty\n+     * @return a copy of this {@code HexFormat} with the suffix\n+     *\/\n+    public HexFormat withSuffix(String suffix) {\n+        return new HexFormat(this.delimiter, this.prefix, suffix, this.digits);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} to use uppercase hexadecimal characters.\n+     * The uppercase hexadecimal characters are {@code \"0-9\", \"A-F\"}.\n+     *\n+     * @return a copy of this {@code HexFormat} with uppercase hexadecimal characters\n+     *\/\n+    public HexFormat withUpperCase() {\n+        return new HexFormat(this.delimiter, this.prefix, this.suffix, UPPERCASE_DIGITS);\n+    }\n+\n+    \/**\n+     * Returns a copy of this {@code HexFormat} to use lowercase hexadecimal characters.\n+     * The lowercase hexadecimal characters are {@code \"0-9\", \"a-f\"}.\n+     *\n+     * @return a copy of this {@code HexFormat} with lowercase hexadecimal characters\n+     *\/\n+    public HexFormat withLowerCase() {\n+        return new HexFormat(this.delimiter, this.prefix, this.suffix, LOWERCASE_DIGITS);\n+    }\n+\n+    \/**\n+     * Returns the delimiter between hexadecimal values in formatted hexadecimal strings.\n+     *\n+     * @return the delimiter, non-null, may be empty {@code \"\"}\n+     *\/\n+    public String delimiter() {\n+        return delimiter;\n+    }\n+\n+    \/**\n+     * Returns the prefix used for each hexadecimal value in formatted hexadecimal strings.\n+     *\n+     * @return the prefix, non-null, may be empty {@code \"\"}\n+     *\/\n+    public String prefix() {\n+        return prefix;\n+    }\n+\n+    \/**\n+     * Returns the suffix used for each hexadecimal value in formatted hexadecimal strings.\n+     *\n+     * @return the suffix, non-null, may be empty {@code \"\"}\n+     *\/\n+    public String suffix() {\n+        return suffix;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the hexadecimal digits are uppercase,\n+     * otherwise {@code false}.\n+     *\n+     * @return {@code true} if the hexadecimal digits are uppercase,\n+     *          otherwise {@code false}\n+     *\/\n+    public boolean isUpperCase() {\n+        return Arrays.equals(digits, UPPERCASE_DIGITS);\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string formatted from a byte array.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter follows each formatted value, except the last.\n+     *\n+     * The behavior is equivalent to\n+     * {@link #formatHex(byte[], int, int) formatHex(bytes, 0, bytes.length))}.\n+     *\n+     * @param bytes a non-null array of bytes\n+     * @return a string hexadecimal formatting of the byte array\n+     *\/\n+    public String formatHex(byte[] bytes) {\n+        return formatHex(bytes, 0, bytes.length);\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string formatted from a byte array range.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter follows each formatted value, except the last.\n+     *\n+     * @param bytes a non-null array of bytes\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex the final index of the range, exclusive\n+     * @return a string hexadecimal formatting each byte of the array range\n+     * @throws IndexOutOfBoundsException if the array range is out of bounds\n+     *\/\n+    public String formatHex(byte[] bytes, int fromIndex, int toIndex) {\n+        Objects.requireNonNull(bytes,\"bytes\");\n+        Objects.checkFromToIndex(fromIndex, toIndex, bytes.length);\n+        if (toIndex - fromIndex == 0) {\n+            return \"\";\n+        }\n+        \/\/ Format efficiently if possible\n+        String s = formatOptDelimiter(bytes, fromIndex, toIndex);\n+        if (s == null) {\n+            long stride = prefix.length() + 2L + suffix.length() + delimiter.length();\n+            int capacity = checkMaxArraySize((toIndex - fromIndex) * stride - delimiter.length());\n+            StringBuilder sb = new StringBuilder(capacity);\n+            formatHex(sb, bytes, fromIndex, toIndex);\n+            s = sb.toString();\n+        }\n+        return s;\n+    }\n+\n+    \/**\n+     * Appends formatted hexadecimal strings from a byte array to the {@link Appendable}.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter follows each formatted value, except the last.\n+     * The formatted hexadecimal strings are appended in zero or more calls to the {@link Appendable} methods.\n+     *\n+     * @param <A> The type of {@code Appendable}\n+     * @param out an {@code Appendable}, non-null\n+     * @param bytes a byte array\n+     * @return the {@code Appendable}\n+     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     *\/\n+    public <A extends Appendable> A formatHex(A out, byte[] bytes) {\n+        return formatHex(out, bytes, 0, bytes.length);\n+    }\n+\n+    \/**\n+     * Appends formatted hexadecimal strings from a byte array range to the {@link Appendable}.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter follows each formatted value, except the last.\n+     * The formatted hexadecimal strings are appended in zero or more calls to the {@link Appendable} methods.\n+     *\n+     * @param <A> The type of {@code Appendable}\n+     * @param out an {@code Appendable}, non-null\n+     * @param bytes a byte array, non-null\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex the final index of the range, exclusive.\n+     * @return the {@code Appendable}\n+     * @throws IndexOutOfBoundsException if the array range is out of bounds\n+     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     *\/\n+    public <A extends Appendable> A formatHex(A out, byte[] bytes, int fromIndex, int toIndex) {\n+        Objects.requireNonNull(out, \"out\");\n+        Objects.requireNonNull(bytes, \"bytes\");\n+        Objects.checkFromToIndex(fromIndex, toIndex, bytes.length);\n+\n+        int length = toIndex - fromIndex;\n+        if (length > 0) {\n+            try {\n+                String between = suffix + delimiter + prefix;\n+                out.append(prefix);\n+                toHexDigits(out, bytes[fromIndex]);\n+                if (between.isEmpty()) {\n+                    for (int i = 1; i < length; i++) {\n+                        toHexDigits(out, bytes[fromIndex + i]);\n+                    }\n+                } else {\n+                    for (int i = 1; i < length; i++) {\n+                        out.append(between);\n+                        toHexDigits(out, bytes[fromIndex + i]);\n+                    }\n+                }\n+                out.append(suffix);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe.getMessage(), ioe);\n+            }\n+        }\n+        return out;\n+    }\n+\n+    \/**\n+     * Returns a string formatting of the range of bytes optimized\n+     * for a single allocation.\n+     * Prefix and suffix must be empty and the delimiter\n+     * must be empty or a single byte character, otherwise null is returned.\n+     *\n+     * @param bytes the bytes, non-null\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex the final index of the range, exclusive.\n+     * @return a String formatted or null for non-single byte delimiter\n+     *         or non-empty prefix or suffix\n+     *\/\n+    private String formatOptDelimiter(byte[] bytes, int fromIndex, int toIndex) {\n+        byte[] rep;\n+        if (!prefix.isEmpty() || !suffix.isEmpty()) {\n+            return null;\n+        }\n+        int length = toIndex - fromIndex;\n+        if (delimiter.isEmpty()) {\n+            \/\/ Allocate the byte array and fill in the hex pairs for each byte\n+            rep = new byte[checkMaxArraySize(length * 2L)];\n+            for (int i = 0; i < length; i++) {\n+                rep[i * 2] = (byte)toHighHexDigit(bytes[fromIndex + i]);\n+                rep[i * 2 + 1] = (byte)toLowHexDigit(bytes[fromIndex + i]);\n+            }\n+        } else if (delimiter.length() == 1 && delimiter.charAt(0) < 256) {\n+            \/\/ Allocate the byte array and fill in the characters for the first byte\n+            \/\/ Then insert the delimiter and hexadecimal characters for each of the remaining bytes\n+            char sep = delimiter.charAt(0);\n+            rep = new byte[checkMaxArraySize(length * 3L - 1L)];\n+            rep[0] = (byte) toHighHexDigit(bytes[fromIndex]);\n+            rep[1] = (byte) toLowHexDigit(bytes[fromIndex]);\n+            for (int i = 1; i < length; i++) {\n+                rep[i * 3 - 1] = (byte) sep;\n+                rep[i * 3    ] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n+                rep[i * 3 + 1] = (byte) toLowHexDigit(bytes[fromIndex + i]);\n+            }\n+        } else {\n+            \/\/ Delimiter formatting not to a single byte\n+            return null;\n+        }\n+        try {\n+            \/\/ Return a new string using the bytes without making a copy\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Checked that the requested size for the result string is less than the max array size.\n+     *\n+     * @param length the requested size of a byte array.\n+     * @return the length\n+     * @throws OutOfMemoryError if the size is larger than Integer.MAX_VALUE\n+     *\/\n+    private static int checkMaxArraySize(long length) {\n+        if (length > Integer.MAX_VALUE)\n+            throw new OutOfMemoryError(\"String size \" + length +\n+                    \" exceeds maximum \" + (Integer.MAX_VALUE));\n+        return (int)length;\n+    }\n+\n+    \/**\n+     * Returns a byte array containing hexadecimal values parsed from the string.\n+     *\n+     * Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n+     * and the suffix. A delimiter follows each formatted value, except the last.\n+     * The delimiters, prefixes, and suffixes strings must be present; they may be empty strings.\n+     * A valid string consists only of the above format.\n+     *\n+     * @param string a string containing the byte values with prefix, hexadecimal digits, suffix,\n+     *            and delimiters\n+     * @return a byte array with the values parsed from the string\n+     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n+     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *          after all but the last byte value\n+     *\/\n+    public byte[] parseHex(CharSequence string) {\n+        return parseHex(string, 0, string.length());\n+    }\n+\n+    \/**\n+     * Returns a byte array containing hexadecimal values parsed from a range of the string.\n+     *\n+     * Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n+     * and the suffix. A delimiter follows each formatted value, except the last.\n+     * The delimiters, prefixes, and suffixes strings must be present; they may be empty strings.\n+     * A valid string consists only of the above format.\n+     *\n+     * @param string a string range containing hexadecimal digits,\n+     *           delimiters, prefix, and suffix.\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex the final index of the range, exclusive.\n+     * @return a byte array with the values parsed from the string range\n+     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n+     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *          after all but the last byte value\n+     * @throws IndexOutOfBoundsException if the string range is out of bounds\n+     *\/\n+    public byte[] parseHex(CharSequence string, int fromIndex, int toIndex) {\n+        Objects.requireNonNull(string, \"string\");\n+        Objects.checkFromToIndex(fromIndex, toIndex, string.length());\n+\n+        if (fromIndex != 0 || toIndex != string.length()) {\n+            string = string.subSequence(fromIndex, toIndex);\n+        }\n+\n+        if (string.length() == 0)\n+            return EMPTY_BYTES;\n+        if (delimiter.isEmpty() && prefix.isEmpty() && suffix.isEmpty())\n+            return parseNoDelimiter(string);\n+\n+        \/\/ avoid overflow for max length prefix or suffix\n+        long valueChars = prefix.length() + 2L + suffix.length();\n+        long stride = valueChars + delimiter.length();\n+        if (string.length() < valueChars || (string.length() - valueChars) % stride != 0)\n+            throw new IllegalArgumentException(\"extra or missing delimiters \" +\n+                    \"or values consisting of prefix, two hexadecimal digits, and suffix\");\n+\n+        checkLiteral(string, 0, prefix);\n+        checkLiteral(string, string.length() - suffix.length(), suffix);\n+        String between = suffix + delimiter + prefix;\n+        final int len = (int)((string.length() - valueChars) \/ stride + 1L);\n+        byte[] bytes = new byte[len];\n+        int i, offset;\n+        for (i = 0, offset = prefix.length(); i < len - 1; i++, offset += 2 + between.length()) {\n+            int v = fromHexDigits(string, offset);\n+            if (v < 0)\n+                throw new IllegalArgumentException(\"input contains non-hexadecimal characters\");\n+            bytes[i] = (byte) v;\n+            checkLiteral(string, offset + 2, between);\n+        }\n+        int v = fromHexDigits(string, offset);\n+        if (v < 0)\n+            throw new IllegalArgumentException(\"input contains non-hexadecimal characters\");\n+        bytes[i] = (byte) v;\n+\n+        return bytes;\n+    }\n+\n+    \/**\n+     * Returns a byte array containing hexadecimal values parsed from\n+     * a range of the character array.\n+     *\n+     * Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n+     * and the suffix. A delimiter follows each formatted value, except the last.\n+     * The delimiters, prefixes, and suffixes strings must be present; they may be empty strings.\n+     * A valid character array range consists only of the above format.\n+     *\n+     * @param chars a character array range containing an even number of hexadecimal digits,\n+     *          delimiters, prefix, and suffix.\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex the final index of the range, exclusive.\n+     * @return a byte array with the values parsed from the character array range\n+     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n+     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *          after all but the last byte value\n+     * @throws IndexOutOfBoundsException if the character array range is out of bounds\n+     *\/\n+    public byte[] parseHex(char[] chars, int fromIndex, int toIndex) {\n+        Objects.requireNonNull(chars, \"chars\");\n+        Objects.checkFromToIndex(fromIndex, toIndex, chars.length);\n+        CharBuffer cb = CharBuffer.wrap(chars, fromIndex, toIndex - fromIndex);\n+        return parseHex(cb);\n+    }\n+\n+    \/**\n+     * Compare the literal and throw an exception if it does not match.\n+     * Pre-condition:  {@code index + literal.length() <= string.length()}.\n+     *\n+     * @param string a CharSequence\n+     * @param index the index of the literal in the CharSequence\n+     * @param literal the expected literal\n+     * @throws IllegalArgumentException if the literal is not present\n+     *\/\n+    private static void checkLiteral(CharSequence string, int index, String literal) {\n+        assert index <= string.length() - literal.length()  : \"pre-checked invariant error\";\n+        if (literal.isEmpty() ||\n+                (literal.length() == 1 && literal.charAt(0) == string.charAt(index))) {\n+            return;\n+        }\n+        for (int i = 0; i < literal.length(); i++) {\n+            if (string.charAt(index + i) != literal.charAt(i)) {\n+                throw new IllegalArgumentException(escapeNL(\"found: \\\"\" +\n+                        string.subSequence(index, index + literal.length()) +\n+                        \"\\\", expected: \\\"\" + literal + \"\\\", index: \" + index +\n+                        \" ch: \" + (int)string.charAt(index + i)));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Expands new line characters to escaped newlines for display.\n+     *\n+     * @param string a string\n+     * @return a string with newline characters escaped\n+     *\/\n+    private static String escapeNL(String string) {\n+        return string.replace(\"\\n\", \"\\\\n\")\n+                .replace(\"\\r\", \"\\\\r\");\n+    }\n+\n+    \/**\n+     * Returns the hexadecimal character for the low 4 bits of the value considering it to be a byte.\n+     * If the parameter {@link #isUpperCase()} is {@code true} the\n+     * character returned for values {@code 10-15} is uppercase {@code \"A-F\"},\n+     * otherwise the character returned is lowercase {@code \"a-f\"}.\n+     * The values in the range {@code 0-9} are returned as {@code \"0-9\"}.\n+     *\n+     * @param value a value, only the low 4 bits {@code 0-3} of the value are used\n+     * @return the hexadecimal character for the low 4 bits {@code 0-3} of the value\n+     *\/\n+    public char toLowHexDigit(int value) {\n+        return (char)digits[value & 0xf];\n+    }\n+\n+    \/**\n+     * Returns the hexadecimal character for the high 4 bits of the value considering it to be a byte.\n+     * If the parameter {@link #isUpperCase()} is {@code true} the\n+     * character returned for values {@code 10-15} is uppercase {@code \"A-F\"},\n+     * otherwise the character returned is lowercase {@code \"a-f\"}.\n+     * The values in the range {@code 0-9} are returned as {@code \"0-9\"}.\n+     *\n+     * @param value a value, only bits {@code 4-7} of the value are used\n+     * @return the hexadecimal character for the bits {@code 4-7} of the value\n+     *\/\n+    public char toHighHexDigit(int value) {\n+        return (char)digits[(value >> 4) & 0xf];\n+    }\n+\n+    \/**\n+     * Returns the two hexadecimal characters for the {@code byte} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value a byte value\n+     * @return the two hexadecimal characters for the byte value\n+     *\/\n+    public String toHexDigits(byte value) {\n+        byte[] rep = new byte[2];\n+        rep[0] = (byte)toHighHexDigit(value);\n+        rep[1] = (byte)toLowHexDigit(value);\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Appends two hexadecimal characters for the byte value to the {@link Appendable}.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The hexadecimal characters are appended in one or more calls to the\n+     * {@link Appendable} methods.\n+     *\n+     * @param <A> The type of {@code Appendable}\n+     * @param out an {@code Appendable}, non-null\n+     * @param value a byte value\n+     * @return the {@code Appendable}\n+     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     *\/\n+    public <A extends Appendable> A toHexDigits(A out, byte value) {\n+        Objects.requireNonNull(out, \"out\");\n+        try {\n+            out.append(toHighHexDigit(value));\n+            out.append(toLowHexDigit(value));\n+            return out;\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe.getMessage(), ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the four hexadecimal characters for the {@code char} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value a {@code char} value\n+     * @return the four hexadecimal characters for the {@code char} value\n+     *\/\n+    public String toHexDigits(char value) {\n+        return toHexDigits((short)value);\n+    }\n+\n+    \/**\n+     * Returns the four hexadecimal characters for the {@code short} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value a {@code short} value\n+     * @return the four hexadecimal characters for the {@code short} value\n+     *\/\n+    public String toHexDigits(short value) {\n+        byte[] rep = new byte[4];\n+        rep[0] = (byte)toHighHexDigit((byte)(value >> 8));\n+        rep[1] = (byte)toLowHexDigit((byte)(value >> 8));\n+        rep[2] = (byte)toHighHexDigit((byte)value);\n+        rep[3] = (byte)toLowHexDigit((byte)value);\n+\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the eight hexadecimal characters for the {@code int} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value an {@code int} value\n+     * @return the eight hexadecimal characters for the {@code int} value\n+     *\/\n+    public String toHexDigits(int value) {\n+        byte[] rep = new byte[8];\n+        rep[0] = (byte)toHighHexDigit((byte)(value >> 24));\n+        rep[1] = (byte)toLowHexDigit((byte)(value >> 24));\n+        rep[2] = (byte)toHighHexDigit((byte)(value >> 16));\n+        rep[3] = (byte)toLowHexDigit((byte)(value >> 16));\n+        rep[4] = (byte)toHighHexDigit((byte)(value >> 8));\n+        rep[5] = (byte)toLowHexDigit((byte)(value >> 8));\n+        rep[6] = (byte)toHighHexDigit((byte)value);\n+        rep[7] = (byte)toLowHexDigit((byte)value);\n+\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the sixteen hexadecimal characters for the {@code long} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value a {@code long} value\n+     * @return the sixteen hexadecimal characters for the {@code long} value\n+     *\/\n+    public String toHexDigits(long value) {\n+        byte[] rep = new byte[16];\n+        rep[0] = (byte)toHighHexDigit((byte)(value >>> 56));\n+        rep[1] = (byte)toLowHexDigit((byte)(value >>> 56));\n+        rep[2] = (byte)toHighHexDigit((byte)(value >>> 48));\n+        rep[3] = (byte)toLowHexDigit((byte)(value >>> 48));\n+        rep[4] = (byte)toHighHexDigit((byte)(value >>> 40));\n+        rep[5] = (byte)toLowHexDigit((byte)(value >>> 40));\n+        rep[6] = (byte)toHighHexDigit((byte)(value >>> 32));\n+        rep[7] = (byte)toLowHexDigit((byte)(value >>> 32));\n+        rep[8] = (byte)toHighHexDigit((byte)(value >>> 24));\n+        rep[9] = (byte)toLowHexDigit((byte)(value >>> 24));\n+        rep[10] = (byte)toHighHexDigit((byte)(value >>> 16));\n+        rep[11] = (byte)toLowHexDigit((byte)(value >>> 16));\n+        rep[12] = (byte)toHighHexDigit((byte)(value >>> 8));\n+        rep[13] = (byte)toLowHexDigit((byte)(value >>> 8));\n+        rep[14] = (byte)toHighHexDigit((byte)value);\n+        rep[15] = (byte)toLowHexDigit((byte)value);\n+\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Returns up to sixteen hexadecimal characters for the {@code long} value.\n+     * Each nibble (4 bits) from most significant to least significant of the value\n+     * is formatted as if by {@link #toLowHexDigit(int) toLowHexDigit(nibble)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param value a {@code long} value\n+     * @param digits the number of hexadecimal digits to return, 0 to 16\n+     * @return the hexadecimal characters for the {@code long} value\n+     * @throws  IllegalArgumentException if {@code digits} is negative or greater than 16\n+     *\/\n+    public String toHexDigits(long value, int digits) {\n+        if (digits < 0 || digits > 16)\n+            throw new IllegalArgumentException(\"number of digits: \" + digits);\n+        if (digits == 0)\n+            return \"\";\n+        byte[] rep = new byte[digits];\n+        for (int i = rep.length - 1; i >= 0; i--) {\n+            rep[i] = (byte)toLowHexDigit((byte)(value));\n+            value = value >>> 4;\n+        }\n+        try {\n+            return jla.newStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a byte array containing the parsed hex digits.\n+     * A valid string consists only of an even number of hex digits.\n+     *\n+     * @param string a string containing an even number of only hex digits\n+     * @return a byte array\n+     * @throws IllegalArgumentException if the string length is not valid or\n+     *          the string contains non-hexadecimal characters\n+     *\/\n+    private byte[] parseNoDelimiter(CharSequence string) {\n+        if ((string.length() & 1) != 0)\n+            throw new IllegalArgumentException(\"string length not even: \" +\n+                    string.length());\n+\n+        byte[] bytes = new byte[string.length() \/ 2];\n+        int illegal = 0;        \/\/ Accumulate logical-or of all bytes\n+        for (int i = 0; i < bytes.length; i++) {\n+            int v = fromHexDigits(string, i * 2);\n+            bytes[i] = (byte) v;\n+            illegal |= v;\n+        }\n+        \/\/ check if any character was an illegal character\n+        if (illegal < 0)\n+            throw new IllegalArgumentException(\"input contains non-hexadecimal characters\");\n+\n+        return bytes;\n+    }\n+\n+    \/**\n+     * Check the number of requested digits against a limit.\n+     *\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex the final index of the range, exclusive.\n+     * @param limit the maximum allowed\n+     * @return the length of the range\n+     *\/\n+    private static int checkDigitCount(int fromIndex, int toIndex, int limit) {\n+        int length = toIndex - fromIndex;\n+        if (length > limit)\n+            throw new IllegalArgumentException(\"string length greater than \" +\n+                    limit + \": \" + length);\n+        return length;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the character is a valid hexadecimal character or codepoint.\n+     * The valid hexadecimal characters are:\n+     * <ul>\n+     * <li>{@code '0' ('\\u005Cu0030')} through {@code '9' ('\\u005Cu0039')} inclusive,\n+     * <li>{@code 'A' ('\\u005Cu0041')} through {@code 'F' ('\\u005Cu0046')} inclusive, and\n+     * <li>{@code 'a' ('\\u005Cu0061')} through {@code 'f' ('\\u005Cu0066')} inclusive.\n+     * <\/ul>\n+     * @param ch a codepoint\n+     * @return {@code true} if the character is valid a hexadecimal character,\n+     *          otherwise {@code false}\n+     *\/\n+    public boolean isHexDigit(int ch) {\n+        return ((ch >>> 8) == 0 && DIGITS[ch] >= 0);\n+    }\n+\n+    \/**\n+     * Returns the value for the hexadecimal character or codepoint.\n+     * The value is:\n+     * <ul>\n+     * <li>{@code (ch - '0')} for {@code '0'} through {@code '9'} inclusive,\n+     * <li>{@code (ch - 'A' + 10)} for {@code 'A'} through {@code 'F'} inclusive, and\n+     * <li>{@code (ch - 'a' + 10)} for {@code 'a'} through {@code 'f'} inclusive.\n+     * <\/ul>\n+     * @param ch a character or codepoint\n+     * @return the value {@code 0-15}\n+     * @throws  NumberFormatException if the codepoint is not a hexadecimal character\n+     *\/\n+    public int fromHexDigit(int ch) {\n+        int value;\n+        if ((ch >>> 8) == 0 && (value = DIGITS[ch]) >= 0) {\n+            return value;\n+        }\n+        throw new NumberFormatException(\"not a hexadecimal digit: \\\"\" + (char) ch + \"\\\" = \" + ch);\n+    }\n+\n+    \/**\n+     * Returns a value parsed from two hexadecimal characters in a string.\n+     * The characters in the range from {@code index} to {@code index + 1},\n+     * inclusive, must be valid hex digits according to {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing the characters\n+     * @param index the index of the first character of the range\n+     * @return the value parsed from the string range\n+     * @throws  NumberFormatException if any of the characters in the range\n+     *          is not a hexadecimal character\n+     * @throws  IndexOutOfBoundsException if the range is out of bounds\n+     *          for the {@code CharSequence}\n+     *\/\n+    private int fromHexDigits(CharSequence string, int index) {\n+        Objects.requireNonNull(string, \"string\");\n+        int high = fromHexDigit(string.charAt(index));\n+        int low = fromHexDigit(string.charAt(index + 1));\n+        return (high << 4) | low;\n+    }\n+\n+    \/**\n+     * Returns the {@code int} value parsed from a string of up to eight hexadecimal characters.\n+     * The hexadecimal characters are parsed from most significant to least significant\n+     * using {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing up to eight hexadecimal characters\n+     * @return the value parsed from the string\n+     * @throws  IllegalArgumentException if the string length is greater than eight (8) or\n+     *      if any of the characters is not a hexadecimal character\n+     *\/\n+    public int fromHexDigits(CharSequence string) {\n+        Objects.requireNonNull(string, \"string\");\n+        int length = checkDigitCount(0, string.length(), 8);\n+        int value = 0;\n+        for (int i = 0; i < length; i++) {\n+            value = (value << 4) + fromHexDigit(string.charAt(i));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the {@code int} value parsed from a string range of up to eight hexadecimal\n+     * characters.\n+     * The characters in the range {@code fromIndex} to {@code toIndex}, exclusive,\n+     * are parsed from most significant to least significant using {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing the characters\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex the final index of the range, exclusive.\n+     * @return the value parsed from the string range\n+     * @throws  IndexOutOfBoundsException if the range is out of bounds\n+     *          for the {@code CharSequence}\n+     * @throws  IllegalArgumentException if length of the range is greater than eight (8) or\n+     *          if any of the characters is not a hexadecimal character\n+     *\/\n+    public int fromHexDigits(CharSequence string, int fromIndex, int toIndex) {\n+        Objects.requireNonNull(string, \"string\");\n+        Objects.checkFromToIndex(fromIndex, toIndex, string.length());\n+        int length = checkDigitCount(fromIndex, toIndex, 8);\n+        int value = 0;\n+        for (int i = 0; i < length; i++) {\n+            value = (value << 4) + fromHexDigit(string.charAt(fromIndex + i));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the long value parsed from a string of up to sixteen hexadecimal characters.\n+     * The hexadecimal characters are parsed from most significant to least significant\n+     * using {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing up to sixteen hexadecimal characters\n+     * @return the value parsed from the string\n+     * @throws  IllegalArgumentException if the string length is greater than sixteen (16) or\n+     *         if any of the characters is not a hexadecimal character\n+     *\/\n+    public long fromHexDigitsToLong(CharSequence string) {\n+        Objects.requireNonNull(string, \"string\");\n+        int length = checkDigitCount(0, string.length(), 16);\n+        long value = 0L;\n+        for (int i = 0; i < length; i++) {\n+            value = (value << 4) + fromHexDigit(string.charAt(i));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the long value parsed from a string range of up to sixteen hexadecimal\n+     * characters.\n+     * The characters in the range {@code fromIndex} to {@code toIndex}, exclusive,\n+     * are parsed from most significant to least significant using {@link #fromHexDigit(int)}.\n+     * The delimiter, prefix and suffix are not used.\n+     *\n+     * @param string a CharSequence containing the characters\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex the final index of the range, exclusive.\n+     * @return the value parsed from the string range\n+     * @throws  IndexOutOfBoundsException if the range is out of bounds\n+     *          for the {@code CharSequence}\n+     * @throws  IllegalArgumentException if the length of the range is greater than sixteen (16) or\n+     *          if any of the characters is not a hexadecimal character\n+     *\/\n+    public long fromHexDigitsToLong(CharSequence string, int fromIndex, int toIndex) {\n+        Objects.requireNonNull(string, \"string\");\n+        Objects.checkFromToIndex(fromIndex, toIndex, string.length());\n+        int length = checkDigitCount(fromIndex, toIndex, 16);\n+        long value = 0L;\n+        for (int i = 0; i < length; i++) {\n+            value = (value << 4) + fromHexDigit(string.charAt(fromIndex + i));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the other object is a {@code HexFormat}\n+     * with the same parameters.\n+     *\n+     * @param o an object, may be null\n+     * @return {@code true} if the other object is a {@code HexFormat} and the parameters\n+     *         uppercase, delimiter, prefix, and suffix are equal;\n+     *         otherwise {@code false}\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+        HexFormat otherHex = (HexFormat) o;\n+        return delimiter.equals(otherHex.delimiter) &&\n+                prefix.equals(otherHex.prefix) &&\n+                suffix.equals(otherHex.suffix) &&\n+                Arrays.equals(digits, otherHex.digits);\n+    }\n+\n+    \/**\n+     * Returns a hashcode for this {@code HexFormat}.\n+     *\n+     * @return a hashcode for this {@code HexFormat}\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        int result = Objects.hash(delimiter, prefix, suffix);\n+        result = 31 * result + Boolean.hashCode(Arrays.equals(digits, UPPERCASE_DIGITS));\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns a description of the formatter parameters for uppercase,\n+     * delimiter, prefix, and suffix.\n+     *\n+     * @return a description of this {@code HexFormat}\n+     *\/\n+    @Override\n+    public String toString() {\n+        return escapeNL(\"uppercase: \" + Arrays.equals(digits, UPPERCASE_DIGITS) +\n+                \", delimiter: \\\"\" + delimiter +\n+                \"\\\", prefix: \\\"\" + prefix +\n+                \"\\\", suffix: \\\"\" + suffix + \"\\\"\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":1063,"deletions":0,"binary":false,"changes":1063,"status":"added"},{"patch":"@@ -704,1 +704,1 @@\n-\n+        HexFormat hex = HexFormat.of().withUpperCase();\n@@ -739,6 +739,2 @@\n-                        outBuffer.append('\\\\');\n-                        outBuffer.append('u');\n-                        outBuffer.append(toHex((aChar >> 12) & 0xF));\n-                        outBuffer.append(toHex((aChar >>  8) & 0xF));\n-                        outBuffer.append(toHex((aChar >>  4) & 0xF));\n-                        outBuffer.append(toHex( aChar        & 0xF));\n+                        outBuffer.append(\"\\\\u\");\n+                        outBuffer.append(hex.toHexDigits(aChar));\n@@ -755,0 +751,1 @@\n+        HexFormat hex = HexFormat.of().withUpperCase();\n@@ -759,3 +756,0 @@\n-        char[] uu = new char[6];\n-        uu[0] = '\\\\';\n-        uu[1] = 'u';\n@@ -768,5 +762,2 @@\n-                    uu[2] = toHex((c >> 12) & 0xf);\n-                    uu[3] = toHex((c >>  8) & 0xf);\n-                    uu[4] = toHex((c >>  4) & 0xf);\n-                    uu[5] = toHex( c        & 0xf);\n-                    bw.write(new String(uu));\n+                    bw.write(\"\\\\u\");\n+                    bw.write(hex.toHexDigits(c));\n@@ -1274,13 +1265,0 @@\n-    \/**\n-     * Convert a nibble to a hex character\n-     * @param   nibble  the nibble to convert.\n-     *\/\n-    private static char toHex(int nibble) {\n-        return hexDigit[(nibble & 0xF)];\n-    }\n-\n-    \/** A table of hex digits *\/\n-    private static final char[] hexDigit = {\n-        '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'\n-    };\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/Properties.java","additions":6,"deletions":28,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.HexFormat;\n@@ -55,3 +56,0 @@\n-    \/\/ the hex digitals\n-    private static final char[] HEXES = \"0123456789ABCDEF\".toCharArray();\n-\n@@ -195,16 +193,1 @@\n-\n-        StringBuilder sb = new StringBuilder(bytes.length * 3 - 1);\n-        boolean isInitial = true;\n-        for (byte b : bytes) {\n-            if (isInitial) {\n-                isInitial = false;\n-            } else {\n-                sb.append(':');\n-            }\n-\n-            int k = b & 0xFF;\n-            sb.append(HEXES[k >>> 4]);\n-            sb.append(HEXES[k & 0xF]);\n-        }\n-\n-        return sb.toString();\n+        return HexFormat.ofDelimiter(\":\").withUpperCase().formatHex(bytes);\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SNIServerName.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.HexFormat;\n@@ -50,0 +51,2 @@\n+    private static final HexFormat HEX_UPPERCASE = HexFormat.of().withUpperCase();\n+\n@@ -518,5 +521,0 @@\n-    private static final char[] hexDigits = {\n-        '0', '1', '2', '3', '4', '5', '6', '7',\n-        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n-\n@@ -525,2 +523,1 @@\n-        sb.append(hexDigits[(b >> 4) & 0x0f]);\n-        sb.append(hexDigits[(b >> 0) & 0x0f]);\n+        HEX_UPPERCASE.toHexDigits(sb, b);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/ParseUtil.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.HexFormat;\n@@ -105,0 +106,1 @@\n+        HexFormat hex = HexFormat.of().withUpperCase();\n@@ -111,2 +113,1 @@\n-               sb.append(hexDigits[(c >> 4) & 0x0f]);\n-               sb.append(hexDigits[(c) & 0x0f]);\n+               hex.toHexDigits(sb, (byte)c);\n@@ -245,5 +246,0 @@\n-\n-   private static final char[] hexDigits = {\n-        '0', '1', '2', '3', '4', '5', '6', '7',\n-        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUriUtils.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,18 +192,0 @@\n-    \/**\n-     * convert character 'c' that represents a hexadecimal digit to an integer.\n-     * if 'c' is not a hexadecimal digit [0-9A-Fa-f], -1 is returned.\n-     * otherwise the converted value is returned.\n-     *\/\n-    private static int hexchar2int( byte c ) {\n-        if ( c >= '0' && c <= '9' ) {\n-            return( c - '0' );\n-        }\n-        if ( c >= 'A' && c <= 'F' ) {\n-            return( c - 'A' + 10 );\n-        }\n-        if ( c >= 'a' && c <= 'f' ) {\n-            return( c - 'a' + 10 );\n-        }\n-        return( -1 );\n-    }\n-\n@@ -228,1 +210,1 @@\n-                if ((ival = hexchar2int(ch)) < 0) {\n+                if ((ival = Character.digit(ch, 16)) < 0) {\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Filter.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.HexFormat;\n@@ -469,20 +470,0 @@\n-    \/\/ Writes the hex representation of a byte to a StringBuffer.\n-    private static void hexDigit(StringBuffer buf, byte x) {\n-        char c;\n-\n-        c = (char) ((x >> 4) & 0xf);\n-        if (c > 9)\n-            c = (char) ((c-10) + 'A');\n-        else\n-            c = (char)(c + '0');\n-\n-        buf.append(c);\n-        c = (char) (x & 0xf);\n-        if (c > 9)\n-            c = (char)((c-10) + 'A');\n-        else\n-            c = (char)(c + '0');\n-        buf.append(c);\n-    }\n-\n-\n@@ -509,0 +490,1 @@\n+            HexFormat hex = HexFormat.of().withUpperCase().withPrefix(\"\\\\\");\n@@ -510,6 +492,1 @@\n-            StringBuffer b1 = new StringBuffer(bytes.length*3);\n-            for (int i = 0; i < bytes.length; i++) {\n-                b1.append('\\\\');\n-                hexDigit(b1, bytes[i]);\n-            }\n-            return b1.toString();\n+            return hex.formatHex(bytes);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/toolkit\/dir\/SearchFilter.java","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import java.util.HexFormat;\n@@ -1088,11 +1089,0 @@\n-    private static final char[] hexDigits = {\n-            '0', '1', '2', '3', '4', '5', '6', '7',\n-            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n-\n-    private static void appendEscape(StringBuilder sb, byte b) {\n-        sb.append('%');\n-        sb.append(hexDigits[(b >> 4) & 0x0f]);\n-        sb.append(hexDigits[(b >> 0) & 0x0f]);\n-    }\n-\n@@ -1126,0 +1116,1 @@\n+        HexFormat format = HexFormat.of().withUpperCase();\n@@ -1129,4 +1120,6 @@\n-            if (b >= 0x80)\n-                appendEscape(sb, (byte)b);\n-            else\n-                sb.append((char)b);\n+            if (b >= 0x80) {\n+                sb.append('%');\n+                format.toHexDigits(sb, (byte)b);\n+            } else {\n+                sb.append((char) b);\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.util.HexFormat;\n+\n@@ -404,1 +406,2 @@\n-        StringBuffer sb = new StringBuffer();\n+        HexFormat format = HexFormat.of();\n+        StringBuilder sb = new StringBuilder();\n@@ -409,4 +412,1 @@\n-            if (c < 0x10) sb.append('0');\n-            if (c < 0x100) sb.append('0');\n-            if (c < 0x1000) sb.append('0');\n-            sb.append(Integer.toHexString(c));\n+            sb.append(format.toHexDigits(c));\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/Supplementary.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,746 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.CharArrayWriter;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.CharBuffer;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.Locale;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertSame;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n+\n+\/*\n+ * @test\n+ * @summary Check HexFormat formatting and parsing\n+ * @run testng\/othervm HexFormatTest\n+ *\/\n+\n+@Test\n+public class HexFormatTest {\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+\n+    @DataProvider(name = \"HexFormattersParsers\")\n+    Object[][] hexFormattersParsers() {\n+        return new Object[][]{\n+                {\"\", \"\", \"\", true,\n+                        HexFormat.of().withUpperCase()},\n+                {\", \", \"#\", \"L\", false,\n+                        HexFormat.ofDelimiter(\", \").withPrefix(\"#\").withSuffix(\"L\")},\n+                {\"\", \"\", \"\", false,\n+                        HexFormat.of().withPrefix(\"\").withSuffix(\"\")},\n+                {\".\", \"\", \"\", false,\n+                        HexFormat.ofDelimiter(\".\").withPrefix(\"\").withSuffix(\"\")},\n+                {\", \", \"0x\", \"\", true,\n+                        HexFormat.ofDelimiter(\", \").withUpperCase().withPrefix(\"0x\")},\n+                {\"\\u0202\", \"\\u0203\", \"\\u0204\", false,\n+                        HexFormat.ofDelimiter(\"\\u0202\").withPrefix(\"\\u0203\").withSuffix(\"\\u0204\")},\n+                {\"\\u0202\", \"\", \"\", false,\n+                        HexFormat.ofDelimiter(\"\\u0202\")},\n+\n+        };\n+    }\n+\n+    @DataProvider(name = \"HexStringsThrowing\")\n+    Object[][] HexStringsThrowing() {\n+        return new Object[][]{\n+                {\"0\", \":\", \"\", \"\"},         \/\/ wrong string length\n+                {\"01:\", \":\", \"\", \"\"},       \/\/ wrong string length\n+                {\"01:0\", \":\", \"\", \"\"},      \/\/ wrong string length\n+                {\"0\", \",\", \"\", \"\"},         \/\/ wrong length and separator\n+                {\"01:\", \",\", \"\", \"\"},       \/\/ wrong length and separator\n+                {\"01:0\", \",\", \"\", \"\"},      \/\/ wrong length and separator\n+                {\"01:00\", \",\", \"\", \"\"},     \/\/ wrong separator\n+                {\"00]\", \",\", \"[\", \"]\"},     \/\/ missing prefix\n+                {\"[00\", \",\", \"[\", \"]\"},     \/\/ missing suffix\n+                {\"]\", \",\", \"[\", \"]\"},       \/\/ missing prefix\n+                {\"[\", \",\", \"[\", \"]\"},       \/\/ missing suffix\n+                {\"00\", \",\", \"abc\", \"\"},     \/\/ Prefix longer than string\n+                {\"01\", \",\", \"\", \"def\"},     \/\/ Suffix longer than string\n+                {\"abc00,\", \",\", \"abc\", \"\"},     \/\/ Prefix and delim but not another value\n+                {\"01def,\", \",\", \"\", \"def\"},     \/\/ Suffix and delim but not another value\n+        };\n+    }\n+\n+    @DataProvider(name = \"BadBytesThrowing\")\n+    Object[][] badBytesThrowing() {\n+        return new Object[][]{\n+                {new byte[1], 0, 2},        \/\/ bad toIndex\n+                {new byte[1], 1, 2},        \/\/ bad fromIndex + toIndex\n+                {new byte[1], -1, 2},       \/\/ bad fromIndex\n+                {new byte[1], -1, 1},       \/\/ bad fromIndex\n+                {new byte[1], 0, -1},       \/\/ bad toIndex\n+                {new byte[1], 1, -1},       \/\/ bad toIndex\n+        };\n+    }\n+\n+    @DataProvider(name = \"BadParseHexThrowing\")\n+    Object[][] badParseHexThrowing() {\n+        return new Object[][]{\n+                {\"a\", 0, 2, IndexOutOfBoundsException.class},        \/\/ bad toIndex\n+                {\"b\", 1, 2, IndexOutOfBoundsException.class},        \/\/ bad toIndex\n+                {\"a\", -1, 2, IndexOutOfBoundsException.class},       \/\/ bad fromIndex\n+                {\"b\", -1, 1, IndexOutOfBoundsException.class},       \/\/ bad fromIndex\n+                {\"a\", 0, -1, IndexOutOfBoundsException.class},       \/\/ bad toIndex\n+                {\"b\", 1, -1, IndexOutOfBoundsException.class},       \/\/ bad fromIndex + toIndex\n+                {\"76543210\", 0, 7, IllegalArgumentException.class},  \/\/ odd number of digits\n+                {\"zz00\", 0, 4, IllegalArgumentException.class},      \/\/ non-hex digits\n+                {\"00zz\", 0, 4, IllegalArgumentException.class},      \/\/ non-hex digits\n+        };\n+    }\n+\n+    @DataProvider(name = \"BadFromHexDigitsThrowing\")\n+    Object[][] badHexDigitsThrowing() {\n+        return new Object[][]{\n+                {\"a\", 0, 2, IndexOutOfBoundsException.class},        \/\/ bad toIndex\n+                {\"b\", 1, 2, IndexOutOfBoundsException.class},        \/\/ bad fromIndex + toIndex\n+                {\"a\", -1, 2, IndexOutOfBoundsException.class},       \/\/ bad toIndex\n+                {\"b\", -1, 1, IndexOutOfBoundsException.class},       \/\/ bad fromIndex + toIndex\n+                {\"a\", 0, -1, IndexOutOfBoundsException.class},       \/\/ bad toIndex\n+                {\"b\", 1, -1, IndexOutOfBoundsException.class},       \/\/ bad fromIndex + toIndex\n+        };\n+    }\n+\n+    static byte[] genBytes(int origin, int len) {\n+        byte[] bytes = new byte[len];\n+        for (int i = 0; i < len; i++)\n+            bytes[i] = (byte) (origin + i);\n+        return bytes;\n+    }\n+\n+    @Test\n+    static void testToHex() {\n+        HexFormat hex = HexFormat.of();\n+        for (int i = 0; i < 32; i++) {\n+            char c = hex.toLowHexDigit((byte)i);\n+            String expected = Integer.toHexString(i & 0xf);\n+            assertEquals(c, expected.charAt(0), \"toHex formatting\");\n+        }\n+    }\n+\n+    @Test\n+    static void testToHexDigits() {\n+        HexFormat hex = HexFormat.of();\n+        for (int i = 0; i < 256; i++) {\n+            String actual = hex.toHexDigits((byte)i);\n+            int expected = hex.fromHexDigits(actual);\n+            assertEquals(expected, i, \"fromHexDigits\");\n+            assertEquals(actual.charAt(0), hex.toHighHexDigit((byte)i),\n+                    \"first char mismatch\");\n+            assertEquals(actual.charAt(1), hex.toLowHexDigit((byte)i),\n+                    \"second char mismatch\");\n+        }\n+    }\n+\n+    @Test\n+    static void testIsHexDigit() {\n+        HexFormat hex = HexFormat.of();\n+        for (int i = 0; i < 0x3ff; i++) {\n+            boolean actual = hex.isHexDigit(i);\n+            boolean expected = Character.digit(i, 16) >= 0;\n+            assertEquals(actual, expected, \"isHexDigit: \" + i);\n+        }\n+    }\n+\n+    @Test\n+    static void testFromHexDigit() {\n+        HexFormat hex = HexFormat.of();\n+        String chars = \"0123456789ABCDEF0123456789abcdef\";\n+        for (int i = 0; i < chars.length(); i++) {\n+            int v = hex.fromHexDigit(chars.charAt(i));\n+            assertEquals(v, i & 0xf, \"fromHex decode\");\n+        }\n+    }\n+\n+    @Test\n+    static void testFromHexInvalid() {\n+        HexFormat hex = HexFormat.of();\n+        for (int i = 0; i < 65536; i++) {\n+            char ch = (char)i;\n+            if (ch > 0xff || Character.digit(ch, 16) < 0) {\n+                assertFalse(hex.isHexDigit(ch), \"isHexDigit incorrect for '\" + ch + \"'  = \" + i);\n+                expectThrows(NumberFormatException.class,\n+                        () -> hex.fromHexDigit(ch));\n+\n+            }\n+        }\n+    }\n+\n+    @Test\n+    static void testAppendHexByteWithStringBuilder() {\n+        HexFormat hex = HexFormat.of();\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < 256; i++) {\n+            sb.setLength(0);\n+            StringBuilder sb1 = hex.toHexDigits(sb, (byte)i);\n+            assertSame(sb1, sb, \"toHexDigits returned different StringBuilder\");\n+            assertEquals(sb.length(), 2, \"wrong length after append: \" + i);\n+            assertEquals(sb.charAt(0), hex.toHighHexDigit((byte)i), \"MSB converted wrong\");\n+            assertEquals(sb.charAt(1), hex.toLowHexDigit((byte)i), \"LSB converted wrong\");\n+\n+            assertEquals(hex.fromHexDigits(sb), i, \"hex.format(sb, byte) wrong\");\n+        }\n+    }\n+\n+    @Test\n+    static void testAppendHexByteWithCharBuffer() {\n+        HexFormat hex = HexFormat.of();\n+        CharBuffer cb = CharBuffer.allocate(256);\n+        for (int i = 1; i <= 128; i++) {\n+            CharBuffer cb1 = hex.toHexDigits(cb, (byte)i);\n+            assertTrue(cb1 == cb);\n+            assertEquals(cb.position(), i * 2);\n+        }\n+        assertEquals(cb.remaining(), 0);\n+    }\n+\n+    @Test\n+    static void testAppendHexByteWithCharArrayWriter() {\n+        HexFormat hex = HexFormat.of();\n+        CharArrayWriter caw = new CharArrayWriter();\n+        for (int i = 1; i <= 128; i++) {\n+            CharArrayWriter caw1 = hex.toHexDigits(caw, (byte)i);\n+            assertTrue(caw1 == caw);\n+            assertEquals(caw.size(), i * 2);\n+        }\n+    }\n+\n+    @Test\n+    static void testFromHexPairInvalid() {\n+        HexFormat hex = HexFormat.of();\n+\n+        \/\/ An assortment of invalid characters\n+        String chars = \"-0--0-\";\n+        for (int i = 0; i < chars.length(); i += 2) {\n+            final int ndx = i;\n+            Throwable ex = expectThrows(NumberFormatException.class,\n+                    () -> hex.fromHexDigits(chars.subSequence(ndx, ndx+2)));\n+            System.out.println(ex);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"HexStringsThrowing\")\n+    static void testToBytesThrowing(String value, String sep, String prefix, String suffix) {\n+        HexFormat hex = HexFormat.ofDelimiter(sep).withPrefix(prefix).withSuffix(suffix);\n+        Throwable ex = expectThrows(IllegalArgumentException.class,\n+                () -> {\n+                    byte[] v = hex.parseHex(value);\n+                    System.out.println(\"str: \" + value + \", actual: \" + v + \", bytes: \" +\n+                                    Arrays.toString(v));\n+                });\n+        System.out.println(\"ex: \" + ex);\n+    }\n+\n+    @Test\n+    static void testFactoryNPE() {\n+        assertThrows(NPE, () -> HexFormat.ofDelimiter(null));\n+        assertThrows(NPE, () -> HexFormat.of().withDelimiter(null));\n+        assertThrows(NPE, () -> HexFormat.of().withPrefix(null));\n+        assertThrows(NPE, () -> HexFormat.of().withSuffix(null));\n+    }\n+\n+    @Test\n+    static void testFormatHexNPE() {\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(null, 0, 1));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(null, null));\n+        assertThrows(NPE,  () -> HexFormat.of().formatHex(null, null, 0, 0));\n+        StringBuilder sb = new StringBuilder();\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(sb, null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(sb, null, 0, 1));\n+    }\n+\n+    @Test\n+    static void testParseHexNPE() {\n+        assertThrows(NPE, () -> HexFormat.of().parseHex(null));\n+        assertThrows(NPE, () -> HexFormat.of().parseHex((String)null, 0, 0));\n+        assertThrows(NPE, () -> HexFormat.of().parseHex((char[])null, 0, 0));\n+    }\n+\n+    @Test\n+    static void testFromHexNPE() {\n+        assertThrows(NPE, () -> HexFormat.of().fromHexDigits(null));\n+        assertThrows(NPE, () -> HexFormat.of().fromHexDigits(null, 0, 0));\n+        assertThrows(NPE, () -> HexFormat.of().fromHexDigitsToLong(null));\n+        assertThrows(NPE, () -> HexFormat.of().fromHexDigitsToLong(null, 0, 0));\n+    }\n+\n+    @Test\n+    static void testToHexDigitsNPE() {\n+        assertThrows(NPE, () -> HexFormat.of().toHexDigits(null, (byte)0));\n+    }\n+\n+    @Test(dataProvider = \"BadParseHexThrowing\")\n+    static void badParseHex(String string, int offset, int length,\n+                            Class<? extends Throwable> exClass) {\n+        assertThrows(exClass,\n+                () -> HexFormat.of().parseHex(string, offset, length));\n+        char[] chars = string.toCharArray();\n+        assertThrows(exClass,\n+                () -> HexFormat.of().parseHex(chars, offset, length));\n+    }\n+\n+    @Test(dataProvider = \"BadFromHexDigitsThrowing\")\n+    static void badFromHexDigits(String string, int fromIndex, int toIndex,\n+                           Class<? extends Throwable> exClass) {\n+        assertThrows(exClass,\n+                () -> HexFormat.of().fromHexDigits(string, fromIndex, toIndex));\n+        assertThrows(exClass,\n+                () -> HexFormat.of().fromHexDigitsToLong(string, fromIndex, toIndex));\n+    }\n+\n+    \/\/ Verify IAE for strings that are too long for the target primitive type\n+    \/\/ or the number of requested digits is too large.\n+    @Test\n+    static void wrongNumberDigits() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> HexFormat.of().fromHexDigits(\"9876543210\"));\n+        assertThrows(IllegalArgumentException.class,\n+                () -> HexFormat.of().fromHexDigits(\"9876543210\", 0, 9));\n+        assertThrows(IllegalArgumentException.class,\n+                () -> HexFormat.of().fromHexDigitsToLong(\"98765432109876543210\"));\n+        assertThrows(IllegalArgumentException.class,\n+                () -> HexFormat.of().fromHexDigitsToLong(\"98765432109876543210\", 0, 17));\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatter(String delimiter, String prefix, String suffix,\n+                                   boolean uppercase,\n+                                   HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        String res = hex.formatHex(expected);\n+        assertTrue(res.startsWith(prefix), \"Prefix not found\");\n+        assertTrue(res.endsWith(suffix), \"Suffix not found\");\n+        int expectedLen = expected.length * (2 + prefix.length() +\n+                delimiter.length() + suffix.length()) - delimiter.length();\n+        assertEquals(res.length(), expectedLen, \"String length\");\n+\n+        if (expected.length > 1) {\n+            \/\/ check prefix and suffix is present for each hex pair\n+            for (int i = 0; i < expected.length; i++) {\n+                int valueChars = prefix.length() + 2 + suffix.length();\n+                int offset = i * (valueChars + delimiter.length());\n+                String value = res.substring(offset, offset + valueChars);\n+                assertTrue(value.startsWith(prefix), \"wrong prefix\");\n+                assertTrue(value.endsWith(suffix), \"wrong suffix\");\n+\n+                \/\/ Check case of digits\n+                String cc = value.substring(prefix.length(), prefix.length() + 2);\n+                assertEquals(cc,\n+                        (uppercase) ? cc.toUpperCase(Locale.ROOT) : cc.toLowerCase(Locale.ROOT),\n+                        \"Case mismatch\");\n+                if (i < expected.length - 1 && !delimiter.isEmpty()) {\n+                    \/\/ Check the delimiter is present for each pair except the last\n+                    assertEquals(res.substring(offset + valueChars,\n+                            offset + valueChars + delimiter.length()), delimiter);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatHexString(String unused1, String unused2, String unused3,\n+                                   boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        String s = hex.formatHex(expected);\n+        System.out.println(\"    formatted: \" + s);\n+\n+        byte[] actual = hex.parseHex(s);\n+        System.out.println(\"    parsed as: \" + Arrays.toString(actual));\n+        int mismatch = Arrays.mismatch(expected, actual);\n+        assertEquals(actual, expected, \"format\/parse cycle failed, mismatch: \" + mismatch);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testParseHexStringRange(String delimiter, String prefix, String suffix,\n+                                   boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        String s = hex.formatHex(expected);\n+\n+        \/\/ Parse values 2, 3, 4 from the generated string\n+        int low = 2;\n+        int high = 5;\n+        int stride = prefix.length() + 2 + suffix.length() + delimiter.length();\n+        System.out.println(\"    formatted subrange: \" +\n+                s.substring(low * stride, high * stride - delimiter.length()));\n+        byte[] actual = hex.parseHex(s, low * stride,\n+                high * stride - delimiter.length());\n+        System.out.println(\"    parsed as: \" + Arrays.toString(actual));\n+\n+        assertEquals(actual.length, (high - low), \"array length\");\n+        int mismatch = Arrays.mismatch(expected, low, high, actual, 0, high - low);\n+        assertEquals(mismatch, -1, \"format\/parse cycle failed, mismatch: \" + mismatch);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testParseHexEmptyString(String delimiter, String prefix, String suffix,\n+                                        boolean unused4, HexFormat hex) {\n+        byte[] actual = hex.parseHex(\"\");\n+        assertEquals(actual.length, 0, \"empty string parse\");\n+        actual = hex.parseHex(\"abc\", 0, 0);\n+        assertEquals(actual.length, 0, \"empty string range parse\");\n+        actual = hex.parseHex(new char[1], 0, 0);\n+        assertEquals(actual.length, 0, \"empty char array subrange empty parse\");\n+    }\n+\n+        @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatHexRangeString(String unused1, String unused2, String unused3,\n+                                   boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        int low = 1;\n+        int high = expected.length - 2;\n+        String s = hex.formatHex(expected, low, high);\n+        System.out.println(\"    formatted: \" + s);\n+\n+        byte[] actual = hex.parseHex(s);\n+        System.out.println(\"    parsed as: \" + Arrays.toString(actual));\n+        int mismatch = Arrays.mismatch(expected, low, high, actual, 0, high - low);\n+        assertEquals(mismatch, -1, \"format\/parse cycle failed, mismatch: \" + mismatch);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatHexAppendable(String unused1, String unused2, String unused3,\n+                                     boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        StringBuilder sb = new StringBuilder();\n+        StringBuilder s = hex.formatHex(sb, expected);\n+        assertEquals(s, sb, \"formatHex returned unknown StringBuilder\");\n+        System.out.println(\"    formatted: \" + s);\n+\n+        byte[] actual = hex.parseHex(s.toString());\n+        System.out.println(\"    parsed as: \" + Arrays.toString(actual));\n+        int mismatch = Arrays.mismatch(expected, actual);\n+        assertEquals(actual, expected, \"format\/parse cycle failed, mismatch: \" + mismatch);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatHexRangeAppendable(String unused1, String unused2, String unused3,\n+                                     boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        int low = 1;\n+        int high = expected.length - 2;\n+        StringBuilder sb = new StringBuilder();\n+        StringBuilder s = hex.formatHex(sb, expected, low, high);\n+        assertEquals(s, sb, \"formatHex returned unknown StringBuilder\");\n+        System.out.println(\"    formatted: \" + s);\n+\n+        byte[] actual = hex.parseHex(s.toString());\n+        System.out.println(\"    parsed as: \" + Arrays.toString(actual));\n+        byte[] sub = Arrays.copyOfRange(expected, low, high);\n+        System.out.println(\"actual: \" + Arrays.toString(actual));\n+        System.out.println(\"sub   : \" + Arrays.toString(sub));\n+        int mismatch = Arrays.mismatch(expected, low, high, actual, 0, high - low);\n+\n+        assertEquals(actual, sub, \"format\/parse cycle failed, mismatch: \" + mismatch);\n+        assertEquals(mismatch, -1, \"format\/parse cycle failed, mismatch: \" + mismatch);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatHexCharArray(String unused1, String unused2, String unused3,\n+                                     boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        String s = hex.formatHex(expected);\n+        System.out.println(\"    formatted: \" + s);\n+\n+        char[] chars = s.toCharArray();\n+        byte[] actual = hex.parseHex(chars, 0, chars.length);\n+        System.out.println(\"    parsed as: \" + Arrays.toString(actual));\n+        int mismatch = Arrays.mismatch(expected, actual);\n+        assertEquals(actual, expected, \"format\/parse cycle failed, mismatch: \" + mismatch);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatHexCharArrayIndexed(String delimiter, String prefix, String suffix,\n+                                              boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        String s = hex.formatHex(expected);\n+        System.out.println(\"    formatted: \" + s);\n+\n+\n+        \/\/ Parse values 2, 3, 4 from the generated string\n+        int low = 2;\n+        int high = 5;\n+        int stride = prefix.length() + 2 + suffix.length() + delimiter.length();\n+        System.out.println(\"    formatted subrange: \" +\n+                s.substring(low * stride, high * stride - delimiter.length()));\n+        char[] chars = s.toCharArray();\n+        byte[] actual = hex.parseHex(chars, low * stride,\n+                high * stride - delimiter.length());\n+        System.out.println(\"    parsed as: \" + Arrays.toString(actual));\n+\n+        assertEquals(actual.length, (high - low), \"array length\");\n+        int mismatch = Arrays.mismatch(expected, low, high, actual, 0, high - low);\n+        assertEquals(mismatch, -1, \"format\/parse cycle failed, mismatch: \" + mismatch);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatterToString(String delimiter, String prefix, String suffix,\n+                                    boolean uppercase,\n+                                    HexFormat hex) {\n+        String actual = String.format(\n+                \"uppercase: %s, delimiter: \\\"%s\\\", prefix: \\\"%s\\\", suffix: \\\"%s\\\"\",\n+                uppercase, escapeNL(delimiter), escapeNL(prefix), escapeNL(suffix));\n+        System.out.println(\"    hex: \" + actual);\n+        assertEquals(actual, hex.toString(), \"Formatter toString mismatch\");\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatterParameterMethods(String delimiter, String prefix, String suffix,\n+                                    boolean uppercase,\n+                                    HexFormat hex) {\n+        assertEquals(hex.delimiter(), delimiter);\n+        assertEquals(hex.prefix(), prefix);\n+        assertEquals(hex.suffix(), suffix);\n+        assertEquals(hex.isUpperCase(), uppercase);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatterTestEquals(String delimiter, String prefix, String suffix,\n+                                    boolean uppercase,\n+                                    HexFormat expected) {\n+        HexFormat actual = HexFormat.of()\n+                .withDelimiter(delimiter)\n+                .withPrefix(prefix)\n+                .withSuffix(suffix);\n+        actual = uppercase ? actual.withUpperCase() : actual.withLowerCase();\n+\n+        assertEquals(actual.delimiter(), delimiter, \"delimiter\");\n+        assertEquals(actual.prefix(), prefix, \"prefix\");\n+        assertEquals(actual.suffix(), suffix, \"suffix\");\n+        assertEquals(actual.isUpperCase(), uppercase, \"uppercase\");\n+        assertTrue(actual.equals(expected), \"equals method\");\n+        assertEquals(actual.hashCode(), expected.hashCode(), \"hashCode\");\n+\n+        assertTrue(actual.equals(actual));   \/\/ equals self\n+        assertFalse(actual.equals(null));    \/\/ never equals null\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testZeroLength(String delimiter, String prefix, String suffix, boolean uppercase,\n+                                HexFormat hex) {\n+        \/\/ Test formatting of zero length byte arrays, should produce no output\n+        StringBuilder sb = new StringBuilder();\n+        assertEquals(hex.formatHex(new byte[0]), \"\", \"Zero length\");\n+        assertEquals(hex.formatHex(new byte[0], 0, 0), \"\", \"Zero length\");\n+\n+        hex.formatHex(sb, new byte[0]);\n+        assertEquals(sb.length(), 0, \"length should not change\");\n+        hex.formatHex(sb, new byte[0], 0, 0);\n+        assertEquals(sb.length(), 0, \"length should not change\");\n+\n+    }\n+    private static String escapeNL(String string) {\n+        return string.replace(\"\\n\", \"\\\\n\")\n+                .replace(\"\\r\", \"\\\\r\");\n+    }\n+\n+    @Test\n+    static void testfromHexDigitsToInt() {\n+        HexFormat hex = HexFormat.of();\n+\n+        String allHex = \"76543210\";\n+        final int orig = 0x76543210;\n+        for (int digits = 0; digits <= 8; digits++) {\n+            String s = hex.toHexDigits(orig, digits);\n+            long actual = hex.fromHexDigits(s, 0, digits);\n+            System.out.printf(\"    digits: %2d, formatted: \\\"%s\\\", parsed as: 0x%08x%n\",\n+                    digits, s, actual);\n+            assertEquals(s, allHex.substring(8 - digits, 8));\n+            long expected = (digits < 8) ? orig & ~(0xffffffff << (4 * digits)) : orig;\n+            assertEquals(actual, expected);\n+        }\n+    }\n+\n+    @Test\n+    static void testfromHexDigitsToLong() {\n+        HexFormat hex = HexFormat.of();\n+\n+        String allHex = \"fedcba9876543210\";\n+        final long orig = 0xfedcba9876543210L;\n+        for (int digits = 0; digits <= 16; digits++) {\n+            String s = hex.toHexDigits(orig, digits);\n+            long actual = hex.fromHexDigitsToLong(s, 0, digits);\n+            System.out.printf(\"    digits: %2d, formatted: \\\"%s\\\", parsed as: 0x%016xL%n\",\n+                    digits, s, actual);\n+            assertEquals(s, allHex.substring(16 - digits, 16));\n+            long expected = (digits < 16) ? orig & ~(0xffffffffffffffffL << (4 * digits)) : orig;\n+            assertEquals(actual, expected);\n+        }\n+    }\n+\n+    @Test\n+    static void testToHexDigitsLong() {\n+        HexFormat hex = HexFormat.of();\n+\n+        String allHex = \"fedcba9876543210\";\n+        final long expected = 0xfedcba9876543210L;\n+        String s = hex.toHexDigits(expected);\n+        long actual = hex.fromHexDigitsToLong(s);\n+        System.out.printf(\"    formatted: \\\"%s\\\", parsed as: 0x%016xL%n\", s, actual);\n+        assertEquals(s, allHex);\n+        assertEquals(actual, expected);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testIOException(String delimiter, String prefix, String suffix, boolean uppercase,\n+                               HexFormat hex) {\n+        Appendable throwingAppendable = new ThrowingAppendable();\n+        assertThrows(UncheckedIOException.class,\n+                () -> hex.formatHex(throwingAppendable, new byte[1]));\n+        assertThrows(UncheckedIOException.class,\n+                () -> hex.formatHex(throwingAppendable, new byte[1], 0, 1));\n+        assertThrows(UncheckedIOException.class,\n+                () -> hex.toHexDigits(throwingAppendable, (byte)1));\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testOOME(String delimiter, String prefix, String suffix, boolean uppercase,\n+                         HexFormat hex) {\n+        \/\/ compute the size of byte array that will exceed the buffer\n+        long valueChars = prefix.length() + 2 + suffix.length();\n+        long stride = valueChars + delimiter.length();\n+        long max = Integer.MAX_VALUE & 0xFFFFFFFFL;\n+        long len = max \/ stride;\n+        long remainder = max - ((len - 1) * stride);\n+        if (remainder > valueChars) {\n+            len++;\n+        }\n+        byte[] bytes = new byte[(int)len];\n+        Throwable ex = expectThrows(OutOfMemoryError.class,\n+                () -> hex.formatHex(bytes));\n+        System.out.println(\"ex: \" + ex);\n+    }\n+\n+    \/**\n+     * Example code from the HexFormat javadoc.\n+     * Showing simple usage of the API using \"assert\" to express the correct results\n+     * when shown in the javadoc.\n+     * The additional TestNG asserts verify the correctness of the same code.\n+     *\/\n+    @Test\n+    private static void samples() {\n+        {\n+            \/\/ Primitive formatting and parsing.\n+            HexFormat hex = HexFormat.of();\n+\n+            byte b = 127;\n+            String byteStr = hex.toHexDigits(b);\n+            System.out.println(\"    \" + byteStr);\n+\n+            byte byteVal = (byte)hex.fromHexDigits(byteStr);\n+            assert(byteStr.equals(\"7f\"));\n+            assert(b == byteVal);\n+            assertTrue(byteStr.equals(\"7f\"));\n+            assertTrue(b == byteVal);\n+\n+\n+            char c = 'A';\n+            String charStr = hex.toHexDigits(c);\n+            System.out.println(\"    \" + charStr);\n+            int charVal = hex.fromHexDigits(charStr);\n+            assert(c == charVal);\n+            assertTrue(c == charVal);\n+\n+            int i = 12345;\n+            String intStr = hex.toHexDigits(i);\n+            System.out.println(\"    \" + intStr);\n+            int intVal = hex.fromHexDigits(intStr);\n+            assert(i == intVal);\n+            assertTrue(i == intVal);\n+\n+            long l = Long.MAX_VALUE;\n+            String longStr = hex.toHexDigits(l, 16);\n+            long longVal = hex.fromHexDigitsToLong(longStr, 0, 16);\n+            System.out.println(\"    \" + longStr + \", \" + longVal);\n+            assert(l == longVal);\n+            assertTrue(l == longVal);\n+        }\n+\n+        {\n+            \/\/ RFC 4752 Fingerprint\n+            HexFormat formatFingerprint = HexFormat.ofDelimiter(\":\").withUpperCase();\n+            byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+            String str = formatFingerprint.formatHex(bytes);\n+            System.out.println(\"    Formatted: \" + str);\n+\n+            byte[] parsed = formatFingerprint.parseHex(str);\n+            System.out.println(\"    Parsed: \" + Arrays.toString(parsed));\n+            assert(Arrays.equals(bytes, parsed));\n+            assertTrue(Arrays.equals(bytes, parsed));\n+        }\n+\n+        {\n+            \/\/ Comma separated formatting\n+            HexFormat commaFormat = HexFormat.ofDelimiter(\",\");\n+            byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+            String str = commaFormat.formatHex(bytes);\n+            System.out.println(\"    Formatted: \" + str);\n+\n+            byte[] parsed = commaFormat.parseHex(str);\n+            System.out.println(\"    Parsed: \" + Arrays.toString(parsed));\n+            assert(Arrays.equals(bytes, parsed));\n+            assertTrue(Arrays.equals(bytes, parsed));\n+        }\n+        {\n+            \/\/ Text formatting\n+            HexFormat commaFormat = HexFormat.ofDelimiter(\", \").withPrefix(\"#\");\n+            byte[] bytes = {0, 1, 2, 3, 124, 125, 126, 127};\n+            String str = commaFormat.formatHex(bytes);\n+            System.out.println(\"    Formatted: \" + str);\n+\n+            byte[] parsed = commaFormat.parseHex(str);\n+            System.out.println(\"    Parsed:    \" + Arrays.toString(parsed));\n+            assert(Arrays.equals(bytes, parsed));\n+            assertTrue(Arrays.equals(bytes, parsed));\n+        }\n+    }\n+\n+    \/**\n+     * A test implementation of Appendable that throws IOException on all methods.\n+     *\/\n+    static class ThrowingAppendable implements Appendable {\n+        @Override\n+        public Appendable append(CharSequence csq) throws IOException {\n+            throw new IOException(\".append(CharSequence) always throws\");\n+        }\n+\n+        @Override\n+        public Appendable append(CharSequence csq, int start, int end) throws IOException {\n+            throw new IOException(\".append(CharSequence, start, end) always throws\");\n+        }\n+\n+        @Override\n+        public Appendable append(char c) throws IOException {\n+            throw new IOException(\".append(char) always throws\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/HexFormat\/HexFormatTest.java","additions":746,"deletions":0,"binary":false,"changes":746,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,5 +36,0 @@\n-    char[] hex = {'0', '1', '2', '3',\n-                  '4', '5', '6', '7',\n-                  '8', '9', 'A', 'B',\n-                  'C', 'D', 'E', 'F'};\n-\n@@ -46,20 +41,0 @@\n-    String toHex(String str) {\n-        StringBuffer buff = new StringBuffer();\n-        int y=0;\n-        for(int x=0; x < str.length(); ++x) {\n-            buff.append(\"\\\\u\");\n-            buff.append(toHex(str.charAt(x)));\n-        }\n-        return buff.toString();\n-    }\n-\n-    String toHex(char ch) {\n-        StringBuffer buff = new StringBuffer();\n-        buff.append(hex[ch>>12]);\n-        buff.append(hex[(ch>>8) & 0x0F]);\n-        buff.append(hex[(ch>>4) & 0x0F]);\n-        buff.append(hex[ch & 0x0F]);\n-        return buff.toString();\n-    }\n-\n-\n","filename":"test\/jdk\/java\/util\/Locale\/ThaiGov.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"}]}