{"files":[{"patch":"@@ -498,24 +498,23 @@\n-        private record ProxyClassContext(Module module, String pkg, int accessFlags) { }\n-\n-        private static Class<?> defineProxyClass(ProxyClassContext context, List<Class<?>> interfaces) {\n-            String proxyPkg = context.pkg;\n-            int accessFlags = context.accessFlags;\n-            Module m = context.module;\n-\n-            if (Modifier.isPublic(accessFlags)) {\n-                \/\/ all proxy interfaces are public\n-                if (!m.isNamed())\n-                    throw new InternalError(\"unnamed module: \" + m);\n-            }\n-\n-            if (proxyPkg.isEmpty() && m.isNamed()) {\n-                \/\/ Per JLS 7.4.2, unnamed package can only exist in unnamed modules.\n-                \/\/ This means a package-private superinterface exist in the unnamed\n-                \/\/ package of a named module.\n-                throw new IllegalArgumentException(\n-                        \"Unnamed package cannot be added to \" + m);\n-            }\n-\n-            if (m.isNamed()) {\n-                if (!m.getDescriptor().packages().contains(proxyPkg)) {\n-                    throw new InternalError(proxyPkg + \" not exist in \" + m.getName());\n+        private record ProxyClassContext(Module module, String pkg, int accessFlags) {\n+            private ProxyClassContext {\n+                if (module.isNamed()) {\n+                    if (pkg.isEmpty()) {\n+                        \/\/ Per JLS 7.4.2, unnamed package can only exist in unnamed modules.\n+                        \/\/ This means a package-private superinterface exist in the unnamed\n+                        \/\/ package of a named module.\n+                        throw new InternalError(\"Unnamed package cannot be added to \" + module);\n+                    }\n+\n+                    if (!module.getDescriptor().packages().contains(pkg)) {\n+                        throw new InternalError(pkg + \" not exist in \" + module.getName());\n+                    }\n+\n+                    if (!module.isOpen(pkg, Proxy.class.getModule())) {\n+                        \/\/ Required for default method invocation\n+                        throw new InternalError(pkg + \" not open to \" + Proxy.class.getModule());\n+                    }\n+                } else {\n+                    if (Modifier.isPublic(accessFlags)) {\n+                        \/\/ All proxy superinterfaces are public, must be in named dynamic module\n+                        throw new InternalError(\"proxy in unnamed module: \" + module);\n+                    }\n@@ -524,0 +523,1 @@\n+        }\n@@ -525,0 +525,1 @@\n+        private static Class<?> defineProxyClass(ProxyClassContext context, List<Class<?>> interfaces) {\n@@ -529,1 +530,1 @@\n-            String proxyName = proxyPkg.isEmpty()\n+            String proxyName = context.pkg().isEmpty()\n@@ -531,1 +532,1 @@\n-                                    : proxyPkg + \".\" + proxyClassNamePrefix + num;\n+                                    : context.pkg() + \".\" + proxyClassNamePrefix + num;\n@@ -533,2 +534,2 @@\n-            ClassLoader loader = getLoader(m);\n-            trace(proxyName, m, loader, interfaces);\n+            ClassLoader loader = getLoader(context.module());\n+            trace(proxyName, context.module(), loader, interfaces);\n@@ -540,1 +541,1 @@\n-                                                                      accessFlags | Modifier.FINAL);\n+                                                                      context.accessFlags() | Modifier.FINAL);\n@@ -634,1 +635,1 @@\n-            assert getLoader(context.module) == loader;\n+            assert getLoader(context.module()) == loader;\n@@ -653,2 +654,0 @@\n-            Module module = context.module;\n-            assert !module.isNamed() || module.isOpen(proxyClass.getPackageName(), Proxy.class.getModule());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":31,"deletions":32,"binary":false,"changes":63,"status":"modified"}]}