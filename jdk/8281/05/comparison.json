{"files":[{"patch":"@@ -498,4 +498,9 @@\n-        private static Class<?> defineProxyClass(Module m, List<Class<?>> interfaces) {\n-            String proxyPkg = null;     \/\/ package to define proxy class in\n-            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n-            boolean nonExported = false;\n+        private record ProxyClassContext(Module module, String packageName, int accessFlags) {\n+            private ProxyClassContext {\n+                if (module.isNamed()) {\n+                    if (packageName.isEmpty()) {\n+                        \/\/ Per JLS 7.4.2, unnamed package can only exist in unnamed modules.\n+                        \/\/ This means a package-private superinterface exist in the unnamed\n+                        \/\/ package of a named module.\n+                        throw new InternalError(\"Unnamed package cannot be added to \" + module);\n+                    }\n@@ -503,15 +508,7 @@\n-            \/*\n-             * Record the package of a non-public proxy interface so that the\n-             * proxy class will be defined in the same package.  Verify that\n-             * all non-public proxy interfaces are in the same package.\n-             *\/\n-            for (Class<?> intf : interfaces) {\n-                int flags = intf.getModifiers();\n-                if (!Modifier.isPublic(flags)) {\n-                    accessFlags = Modifier.FINAL;  \/\/ non-public, final\n-                    String pkg = intf.getPackageName();\n-                    if (proxyPkg == null) {\n-                        proxyPkg = pkg;\n-                    } else if (!pkg.equals(proxyPkg)) {\n-                        throw new IllegalArgumentException(\n-                                \"non-public interfaces from different packages\");\n+                    if (!module.getDescriptor().packages().contains(packageName)) {\n+                        throw new InternalError(packageName + \" not exist in \" + module.getName());\n+                    }\n+\n+                    if (!module.isOpen(packageName, Proxy.class.getModule())) {\n+                        \/\/ Required for default method invocation\n+                        throw new InternalError(packageName + \" not open to \" + Proxy.class.getModule());\n@@ -520,3 +517,3 @@\n-                    if (!intf.getModule().isExported(intf.getPackageName())) {\n-                        \/\/ module-private types\n-                        nonExported = true;\n+                    if (Modifier.isPublic(accessFlags)) {\n+                        \/\/ All proxy superinterfaces are public, must be in named dynamic module\n+                        throw new InternalError(\"public proxy in unnamed module: \" + module);\n@@ -525,1 +522,0 @@\n-            }\n@@ -527,14 +523,2 @@\n-            if (proxyPkg == null) {\n-                \/\/ all proxy interfaces are public and exported\n-                if (!m.isNamed())\n-                    throw new InternalError(\"unnamed module: \" + m);\n-                proxyPkg = nonExported ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n-                                       : m.getName();\n-            } else if (proxyPkg.isEmpty() && m.isNamed()) {\n-                throw new IllegalArgumentException(\n-                        \"Unnamed package cannot be added to \" + m);\n-            }\n-\n-            if (m.isNamed()) {\n-                if (!m.getDescriptor().packages().contains(proxyPkg)) {\n-                    throw new InternalError(proxyPkg + \" not exist in \" + m.getName());\n+                if ((accessFlags & ~Modifier.PUBLIC) != 0) {\n+                    throw new InternalError(\"proxy access flags must be Modifier.PUBLIC or 0\");\n@@ -543,0 +527,1 @@\n+        }\n@@ -544,0 +529,1 @@\n+        private static Class<?> defineProxyClass(ProxyClassContext context, List<Class<?>> interfaces) {\n@@ -548,1 +534,1 @@\n-            String proxyName = proxyPkg.isEmpty()\n+            String proxyName = context.packageName().isEmpty()\n@@ -550,1 +536,1 @@\n-                                    : proxyPkg + \".\" + proxyClassNamePrefix + num;\n+                                    : context.packageName() + \".\" + proxyClassNamePrefix + num;\n@@ -552,2 +538,2 @@\n-            ClassLoader loader = getLoader(m);\n-            trace(proxyName, m, loader, interfaces);\n+            ClassLoader loader = getLoader(context.module());\n+            trace(proxyName, context.module(), loader, interfaces);\n@@ -558,1 +544,2 @@\n-            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces, accessFlags);\n+            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces,\n+                                                                      context.accessFlags() | Modifier.FINAL);\n@@ -578,1 +565,1 @@\n-         * {@link #defineProxyClass(Module, List)}\n+         * {@link #defineProxyClass(ProxyClassContext, List)}\n@@ -634,1 +621,1 @@\n-        private final Module module;\n+        private final ProxyClassContext context;\n@@ -651,2 +638,2 @@\n-            this.module = mapToModule(loader, interfaces, refTypes);\n-            assert getLoader(module) == loader;\n+            this.context = proxyClassContext(loader, interfaces, refTypes);\n+            assert getLoader(context.module()) == loader;\n@@ -670,2 +657,1 @@\n-            Class<?> proxyClass = defineProxyClass(module, interfaces);\n-            assert !module.isNamed() || module.isOpen(proxyClass.getPackageName(), Proxy.class.getModule());\n+            Class<?> proxyClass = defineProxyClass(context, interfaces);\n@@ -771,1 +757,2 @@\n-         * Returns the module that the generated proxy class belongs to.\n+         * Returns the context for the generated proxy class, including the\n+         * module and the package it belongs to and whether it is package-private.\n@@ -774,1 +761,1 @@\n-         * is in the same module of the package-private interface.\n+         * is in the same package and module as the package-private interface.\n@@ -788,3 +775,3 @@\n-        private static Module mapToModule(ClassLoader loader,\n-                                          List<Class<?>> interfaces,\n-                                          Set<Class<?>> refTypes) {\n+        private static ProxyClassContext proxyClassContext(ClassLoader loader,\n+                                                           List<Class<?>> interfaces,\n+                                                           Set<Class<?>> refTypes) {\n@@ -792,0 +779,2 @@\n+            boolean nonExported = false;\n+\n@@ -796,0 +785,5 @@\n+                } else {\n+                    if (!intf.getModule().isExported(intf.getPackageName())) {\n+                        \/\/ module-private types\n+                        nonExported = true;\n+                    }\n@@ -841,1 +835,1 @@\n-                return targetModule;\n+                return new ProxyClassContext(targetModule, targetPackageName, 0);\n@@ -855,1 +849,4 @@\n-            return targetModule;\n+\n+            var pkgName = nonExported ? PROXY_PACKAGE_PREFIX + '.' + targetModule.getName()\n+                                      : targetModule.getName();\n+            return new ProxyClassContext(targetModule, pkgName, Modifier.PUBLIC);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":52,"deletions":55,"binary":false,"changes":107,"status":"modified"}]}