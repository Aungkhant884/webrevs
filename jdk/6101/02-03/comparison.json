{"files":[{"patch":"@@ -1534,2 +1534,2 @@\n-  \/\/ Change x + Integer.MIN_VALUE <=> y + Integer.MIN_VALUE into x u<=> y\n-  \/\/ and x + Integer.MIN_VALUE <=> c into x u<=> c + Integer.MIN_VALUE\n+  \/\/ Change \"cmp (add X min_jint) (add Y min_jint)\" into \"cmpu X Y\"\n+  \/\/ and    \"cmp (add X min_jint) c\" into \"cmpu X (c + min_jint)\"\n@@ -1537,1 +1537,0 @@\n-      (_test.is_less() || _test.is_greater()) &&\n@@ -1541,2 +1540,2 @@\n-      Node *ncmp2 = phase->intcon(java_add(cmp2->get_int(), min_jint));\n-      Node *ncmp = phase->transform(new CmpUNode(cmp1->in(1), ncmp2));\n+      Node* ncmp2 = phase->intcon(java_add(cmp2->get_int(), min_jint));\n+      Node* ncmp = phase->transform(new CmpUNode(cmp1->in(1), ncmp2));\n@@ -1546,1 +1545,1 @@\n-      Node *ncmp = phase->transform(new CmpUNode(cmp1->in(1), cmp2->in(1)));\n+      Node* ncmp = phase->transform(new CmpUNode(cmp1->in(1), cmp2->in(1)));\n@@ -1551,2 +1550,2 @@\n-  \/\/ Change x + Long.MIN_VALUE <=> y + Long.MIN_VALUE into x u<=> y\n-  \/\/ and x + Long.MIN_VALUE <=> c into x u<=> c + Long.MIN_VALUE\n+  \/\/ Change \"cmp (add X min_jlong) (add Y min_jlong)\" into \"cmpu X Y\"\n+  \/\/ and    \"cmp (add X min_jlong) c\" into \"cmpu X (c + min_jlong)\"\n@@ -1554,1 +1553,0 @@\n-      (_test.is_less() || _test.is_greater()) &&\n@@ -1558,2 +1556,2 @@\n-      Node *ncmp2 = phase->longcon(java_add(cmp2->get_long(), min_jlong));\n-      Node *ncmp = phase->transform(new CmpULNode(cmp1->in(1), ncmp2));\n+      Node* ncmp2 = phase->longcon(java_add(cmp2->get_long(), min_jlong));\n+      Node* ncmp = phase->transform(new CmpULNode(cmp1->in(1), ncmp2));\n@@ -1563,1 +1561,1 @@\n-      Node *ncmp = phase->transform(new CmpULNode(cmp1->in(1), cmp2->in(1)));\n+      Node* ncmp = phase->transform(new CmpULNode(cmp1->in(1), cmp2->in(1)));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8276162\n+ * @summary Test that unsigned comparison transformation works as intended.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestUnsignedComparison\n+ *\/\n+public class TestUnsignedComparison {\n+    private static final String CMP_REGEX = \"(\\\\d+(\\\\s){2}(\" + \"Cmp(I|L)\" + \".*)+(\\\\s){2}===.*)\";\n+    private static final String CMPU_REGEX = \"(\\\\d+(\\\\s){2}(\" + \"Cmp(U|UL)\" + \".*)+(\\\\s){2}===.*)\";\n+    private static final String ADD_REGEX = \"(\\\\d+(\\\\s){2}(\" + \"Add(I|L)\" + \".*)+(\\\\s){2}===.*)\";\n+\n+    private static final int INT_MIN = Integer.MIN_VALUE;\n+    private static final long LONG_MIN = Long.MIN_VALUE;\n+\n+    \/\/ Integers are sorted in unsignedly increasing order\n+    private static final int[] INT_DATA = {\n+        0,\n+        1,\n+        2,\n+        3,\n+        0x8000_0000,\n+        0x8000_0001,\n+        0x8000_0002,\n+        0x8000_0003,\n+        0xFFFF_FFFE,\n+        0xFFFF_FFFF,\n+    };\n+\n+    \/\/ Longs are sorted in unsignedly increasing order\n+    private static final long[] LONG_DATA = {\n+        0L,\n+        1L,\n+        2L,\n+        3L,\n+        0x00000000_80000000L,\n+        0x00000000_FFFFFFFFL,\n+        0x00000001_00000000L,\n+        0x80000000_00000000L,\n+        0x80000000_00000001L,\n+        0x80000000_00000002L,\n+        0x80000000_00000003L,\n+        0x80000000_80000000L,\n+        0xFFFFFFFF_FFFFFFFEL,\n+        0xFFFFFFFF_FFFFFFFFL,\n+    };\n+\n+    \/\/ Constants to compare against, add MIN_VALUE beforehand for convenience\n+    private static final int CONST_INDEX = 6;\n+    private static final int INT_CONST = INT_DATA[CONST_INDEX] + INT_MIN;\n+    private static final long LONG_CONST = LONG_DATA[CONST_INDEX] + LONG_MIN;\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+        framework.start();\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarEQ(int x, int y) {\n+        return x + INT_MIN == y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarNE(int x, int y) {\n+        return x + INT_MIN != y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarLT(int x, int y) {\n+        return x + INT_MIN < y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarLE(int x, int y) {\n+        return x + INT_MIN <= y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarGT(int x, int y) {\n+        return x + INT_MIN > y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarGE(int x, int y) {\n+        return x + INT_MIN >= y + INT_MIN;\n+    }\n+\n+    @Run(test = {\"testIntVarEQ\", \"testIntVarNE\",\n+                 \"testIntVarLT\", \"testIntVarLE\",\n+                 \"testIntVarGT\", \"testIntVarGE\"})\n+    public void checkTestIntVar() {\n+        \/\/ Verify the transformation \"cmp (add X min_jint) (add Y min_jint)\"\n+        \/\/ to \"cmpu X Y\"\n+        for (int i = 0; i < INT_DATA.length; i++) {\n+            for (int j = 0; j < INT_DATA.length; j++) {\n+                Asserts.assertEquals(testIntVarEQ(INT_DATA[i], INT_DATA[j]),\n+                                     i == j);\n+                Asserts.assertEquals(testIntVarNE(INT_DATA[i], INT_DATA[j]),\n+                                     i != j);\n+                Asserts.assertEquals(testIntVarLT(INT_DATA[i], INT_DATA[j]),\n+                                     i <  j);\n+                Asserts.assertEquals(testIntVarLE(INT_DATA[i], INT_DATA[j]),\n+                                     i <= j);\n+                Asserts.assertEquals(testIntVarGT(INT_DATA[i], INT_DATA[j]),\n+                                     i >  j);\n+                Asserts.assertEquals(testIntVarGE(INT_DATA[i], INT_DATA[j]),\n+                                     i >= j);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConEQ(int x) {\n+        return x + INT_MIN == INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConNE(int x) {\n+        return x + INT_MIN != INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConLT(int x) {\n+        return x + INT_MIN < INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConLE(int x) {\n+        return x + INT_MIN <= INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConGT(int x) {\n+        return x + INT_MIN > INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConGE(int x) {\n+        return x + INT_MIN >= INT_CONST;\n+    }\n+\n+    @Run(test = {\"testIntConEQ\", \"testIntConNE\",\n+                 \"testIntConLT\", \"testIntConLE\",\n+                 \"testIntConGT\", \"testIntConGE\"})\n+    public void checkTestIntCon() {\n+        \/\/ Verify the transformation \"cmp (add X min_jint) c\"\n+        \/\/ to \"cmpu X (c + min_jint)\"\n+        for (int i = 0; i < INT_DATA.length; i++) {\n+            Asserts.assertEquals(testIntConEQ(INT_DATA[i]),\n+                                 i == CONST_INDEX);\n+            Asserts.assertEquals(testIntConNE(INT_DATA[i]),\n+                                 i != CONST_INDEX);\n+            Asserts.assertEquals(testIntConLT(INT_DATA[i]),\n+                                 i <  CONST_INDEX);\n+            Asserts.assertEquals(testIntConLE(INT_DATA[i]),\n+                                 i <= CONST_INDEX);\n+            Asserts.assertEquals(testIntConGT(INT_DATA[i]),\n+                                 i >  CONST_INDEX);\n+            Asserts.assertEquals(testIntConGE(INT_DATA[i]),\n+                                 i >= CONST_INDEX);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarEQ(long x, long y) {\n+        return x + LONG_MIN == y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarNE(long x, long y) {\n+        return x + LONG_MIN != y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarLT(long x, long y) {\n+        return x + LONG_MIN < y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarLE(long x, long y) {\n+        return x + LONG_MIN <= y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarGT(long x, long y) {\n+        return x + LONG_MIN > y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarGE(long x, long y) {\n+        return x + LONG_MIN >= y + LONG_MIN;\n+    }\n+\n+    @Run(test = {\"testLongVarEQ\", \"testLongVarNE\",\n+                 \"testLongVarLT\", \"testLongVarLE\",\n+                 \"testLongVarGT\", \"testLongVarGE\"})\n+    public void checkTestLongVar() {\n+        \/\/ Verify the transformation \"cmp (add X min_jlong) (add Y min_jlong)\"\n+        \/\/ to \"cmpu X Y\"\n+        for (int i = 0; i < LONG_DATA.length; i++) {\n+            for (int j = 0; j < LONG_DATA.length; j++) {\n+                Asserts.assertEquals(testLongVarEQ(LONG_DATA[i], LONG_DATA[j]),\n+                                     i == j);\n+                Asserts.assertEquals(testLongVarNE(LONG_DATA[i], LONG_DATA[j]),\n+                                     i != j);\n+                Asserts.assertEquals(testLongVarLT(LONG_DATA[i], LONG_DATA[j]),\n+                                     i <  j);\n+                Asserts.assertEquals(testLongVarLE(LONG_DATA[i], LONG_DATA[j]),\n+                                     i <= j);\n+                Asserts.assertEquals(testLongVarGT(LONG_DATA[i], LONG_DATA[j]),\n+                                     i >  j);\n+                Asserts.assertEquals(testLongVarGE(LONG_DATA[i], LONG_DATA[j]),\n+                                     i >= j);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConEQ(long x) {\n+        return x + LONG_MIN == LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConNE(long x) {\n+        return x + LONG_MIN != LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConLT(long x) {\n+        return x + LONG_MIN < LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConLE(long x) {\n+        return x + LONG_MIN <= LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConGT(long x) {\n+        return x + LONG_MIN > LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConGE(long x) {\n+        return x + LONG_MIN >= LONG_CONST;\n+    }\n+\n+    @Run(test = {\"testLongConEQ\", \"testLongConNE\",\n+                 \"testLongConLT\", \"testLongConLE\",\n+                 \"testLongConGT\", \"testLongConGE\"})\n+    public void checkTestLongConGE() {\n+        \/\/ Verify the transformation \"cmp (add X min_jlong) c\"\n+        \/\/ to \"cmpu X (c + min_jlong)\"\n+        for (int i = 0; i < LONG_DATA.length; i++) {\n+            Asserts.assertEquals(testLongConEQ(LONG_DATA[i]),\n+                                 i == CONST_INDEX);\n+            Asserts.assertEquals(testLongConNE(LONG_DATA[i]),\n+                                 i != CONST_INDEX);\n+            Asserts.assertEquals(testLongConLT(LONG_DATA[i]),\n+                                 i <  CONST_INDEX);\n+            Asserts.assertEquals(testLongConLE(LONG_DATA[i]),\n+                                 i <= CONST_INDEX);\n+            Asserts.assertEquals(testLongConGT(LONG_DATA[i]),\n+                                 i >  CONST_INDEX);\n+            Asserts.assertEquals(testLongConGE(LONG_DATA[i]),\n+                                 i >= CONST_INDEX);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestUnsignedComparison.java","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -27,1 +27,2 @@\n-import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n@@ -30,0 +31,4 @@\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n@@ -34,0 +39,2 @@\n+@Fork(2)\n+@State(Scope.Thread)\n@@ -35,3 +42,32 @@\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public long compareInt(int arg0, int arg1) {\n-        return arg0 + Integer.MIN_VALUE < arg1 + Integer.MIN_VALUE ? 1 : 0;\n+    private static final int ITERATIONS = 1000;\n+\n+    private static final int CONST_OPERAND = 4;\n+    private static final int INT_MIN = Integer.MIN_VALUE;\n+    private static final long LONG_MIN = Long.MIN_VALUE;\n+\n+    int arg0 = 0, arg1 = 4;\n+\n+    @Setup(Level.Invocation)\n+    public void toggle() {\n+        arg0 = (arg0 + 1) & 7;\n+    }\n+\n+    @Benchmark\n+    public void intVarDirect(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(arg0 + INT_MIN < arg1 + INT_MIN);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVarLibLT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Integer.compareUnsigned(arg0, arg1) < 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVarLibGT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Integer.compareUnsigned(arg0, arg1) > 0);\n+        }\n@@ -40,3 +76,47 @@\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public long compareLong(long arg0, long arg1) {\n-        return arg0 + Long.MIN_VALUE < arg1 + Long.MIN_VALUE ? 1 : 0;\n+    @Benchmark\n+    public void intConDirect(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(arg0 + INT_MIN < CONST_OPERAND + INT_MIN);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intConLibLT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Integer.compareUnsigned(arg0, CONST_OPERAND) < 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intConLibGT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Integer.compareUnsigned(arg0, CONST_OPERAND) > 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVarDirect(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(arg0 + LONG_MIN < arg1 + LONG_MIN);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVarLibLT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Long.compareUnsigned(arg0, arg1) < 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVarLibGT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Long.compareUnsigned(arg0, arg1) > 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longConDirect(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(arg0 + LONG_MIN < CONST_OPERAND + LONG_MIN);\n+        }\n@@ -46,3 +126,4 @@\n-    public void runInt() {\n-        compareInt(0, -1);\n-        compareInt(-1, 0);\n+    public void longConLibLT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Long.compareUnsigned(arg0, CONST_OPERAND) < 0);\n+        }\n@@ -52,3 +133,4 @@\n-    public void runLong() {\n-        compareLong(0L, -1L);\n-        compareLong(-1L, 0L);\n+    public void longConLibGT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Long.compareUnsigned(arg0, CONST_OPERAND) > 0);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/UnsignedComparison.java","additions":95,"deletions":13,"binary":false,"changes":108,"status":"modified"}]}