{"files":[{"patch":"@@ -1483,0 +1483,3 @@\n+  const int cmp1_op = cmp1->Opcode();\n+  const int cmp2_op = cmp2->Opcode();\n+\n@@ -1485,1 +1488,0 @@\n-  uint op2 = cmp2->Opcode();\n@@ -1489,1 +1491,1 @@\n-  if( con->is_Con() && !cmp2->is_Con() && op2 != Op_Opaque1 &&\n+  if( con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_Opaque1 &&\n@@ -1507,1 +1509,1 @@\n-      cmp1->Opcode() == Op_AndI && cmp2->Opcode() == Op_ConI &&\n+      cmp1_op == Op_AndI && cmp2_op == Op_ConI &&\n@@ -1521,1 +1523,1 @@\n-      cmp1->Opcode() == Op_AndL && cmp2->Opcode() == Op_ConL &&\n+      cmp1_op == Op_AndL && cmp2_op == Op_ConL &&\n@@ -1532,0 +1534,32 @@\n+  \/\/ Change \"cmp (add X min_jint) (add Y min_jint)\" into \"cmpu X Y\"\n+  \/\/ and    \"cmp (add X min_jint) c\" into \"cmpu X (c + min_jint)\"\n+  if (cop == Op_CmpI &&\n+      cmp1_op == Op_AddI &&\n+      phase->type(cmp1->in(2)) == TypeInt::MIN) {\n+    if (cmp2_op == Op_ConI) {\n+      Node* ncmp2 = phase->intcon(java_add(cmp2->get_int(), min_jint));\n+      Node* ncmp = phase->transform(new CmpUNode(cmp1->in(1), ncmp2));\n+      return new BoolNode(ncmp, _test._test);\n+    } else if (cmp2_op == Op_AddI &&\n+               phase->type(cmp2->in(2)) == TypeInt::MIN) {\n+      Node* ncmp = phase->transform(new CmpUNode(cmp1->in(1), cmp2->in(1)));\n+      return new BoolNode(ncmp, _test._test);\n+    }\n+  }\n+\n+  \/\/ Change \"cmp (add X min_jlong) (add Y min_jlong)\" into \"cmpu X Y\"\n+  \/\/ and    \"cmp (add X min_jlong) c\" into \"cmpu X (c + min_jlong)\"\n+  if (cop == Op_CmpL &&\n+      cmp1_op == Op_AddL &&\n+      phase->type(cmp1->in(2)) == TypeLong::MIN) {\n+    if (cmp2_op == Op_ConL) {\n+      Node* ncmp2 = phase->longcon(java_add(cmp2->get_long(), min_jlong));\n+      Node* ncmp = phase->transform(new CmpULNode(cmp1->in(1), ncmp2));\n+      return new BoolNode(ncmp, _test._test);\n+    } else if (cmp2_op == Op_AddL &&\n+               phase->type(cmp2->in(2)) == TypeLong::MIN) {\n+      Node* ncmp = phase->transform(new CmpULNode(cmp1->in(1), cmp2->in(1)));\n+      return new BoolNode(ncmp, _test._test);\n+    }\n+  }\n+\n@@ -1535,1 +1569,0 @@\n-  int cmp1_op = cmp1->Opcode();\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8276162\n+ * @summary Test that unsigned comparison transformation works as intended.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestUnsignedComparison\n+ *\/\n+public class TestUnsignedComparison {\n+    private static final String CMP_REGEX = \"(\\\\d+(\\\\s){2}(\" + \"Cmp(I|L)\" + \".*)+(\\\\s){2}===.*)\";\n+    private static final String CMPU_REGEX = \"(\\\\d+(\\\\s){2}(\" + \"Cmp(U|UL)\" + \".*)+(\\\\s){2}===.*)\";\n+    private static final String ADD_REGEX = \"(\\\\d+(\\\\s){2}(\" + \"Add(I|L)\" + \".*)+(\\\\s){2}===.*)\";\n+\n+    private static final int INT_MIN = Integer.MIN_VALUE;\n+    private static final long LONG_MIN = Long.MIN_VALUE;\n+\n+    \/\/ Integers are sorted in unsignedly increasing order\n+    private static final int[] INT_DATA = {\n+        0,\n+        1,\n+        2,\n+        3,\n+        0x8000_0000,\n+        0x8000_0001,\n+        0x8000_0002,\n+        0x8000_0003,\n+        0xFFFF_FFFE,\n+        0xFFFF_FFFF,\n+    };\n+\n+    \/\/ Longs are sorted in unsignedly increasing order\n+    private static final long[] LONG_DATA = {\n+        0L,\n+        1L,\n+        2L,\n+        3L,\n+        0x00000000_80000000L,\n+        0x00000000_FFFFFFFFL,\n+        0x00000001_00000000L,\n+        0x80000000_00000000L,\n+        0x80000000_00000001L,\n+        0x80000000_00000002L,\n+        0x80000000_00000003L,\n+        0x80000000_80000000L,\n+        0xFFFFFFFF_FFFFFFFEL,\n+        0xFFFFFFFF_FFFFFFFFL,\n+    };\n+\n+    \/\/ Constants to compare against, add MIN_VALUE beforehand for convenience\n+    private static final int CONST_INDEX = 6;\n+    private static final int INT_CONST = INT_DATA[CONST_INDEX] + INT_MIN;\n+    private static final long LONG_CONST = LONG_DATA[CONST_INDEX] + LONG_MIN;\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+        framework.start();\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarEQ(int x, int y) {\n+        return x + INT_MIN == y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarNE(int x, int y) {\n+        return x + INT_MIN != y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarLT(int x, int y) {\n+        return x + INT_MIN < y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarLE(int x, int y) {\n+        return x + INT_MIN <= y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarGT(int x, int y) {\n+        return x + INT_MIN > y + INT_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntVarGE(int x, int y) {\n+        return x + INT_MIN >= y + INT_MIN;\n+    }\n+\n+    @Run(test = {\"testIntVarEQ\", \"testIntVarNE\",\n+                 \"testIntVarLT\", \"testIntVarLE\",\n+                 \"testIntVarGT\", \"testIntVarGE\"})\n+    public void checkTestIntVar() {\n+        \/\/ Verify the transformation \"cmp (add X min_jint) (add Y min_jint)\"\n+        \/\/ to \"cmpu X Y\"\n+        for (int i = 0; i < INT_DATA.length; i++) {\n+            for (int j = 0; j < INT_DATA.length; j++) {\n+                Asserts.assertEquals(testIntVarEQ(INT_DATA[i], INT_DATA[j]),\n+                                     i == j);\n+                Asserts.assertEquals(testIntVarNE(INT_DATA[i], INT_DATA[j]),\n+                                     i != j);\n+                Asserts.assertEquals(testIntVarLT(INT_DATA[i], INT_DATA[j]),\n+                                     i <  j);\n+                Asserts.assertEquals(testIntVarLE(INT_DATA[i], INT_DATA[j]),\n+                                     i <= j);\n+                Asserts.assertEquals(testIntVarGT(INT_DATA[i], INT_DATA[j]),\n+                                     i >  j);\n+                Asserts.assertEquals(testIntVarGE(INT_DATA[i], INT_DATA[j]),\n+                                     i >= j);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConEQ(int x) {\n+        return x + INT_MIN == INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConNE(int x) {\n+        return x + INT_MIN != INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConLT(int x) {\n+        return x + INT_MIN < INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConLE(int x) {\n+        return x + INT_MIN <= INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConGT(int x) {\n+        return x + INT_MIN > INT_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testIntConGE(int x) {\n+        return x + INT_MIN >= INT_CONST;\n+    }\n+\n+    @Run(test = {\"testIntConEQ\", \"testIntConNE\",\n+                 \"testIntConLT\", \"testIntConLE\",\n+                 \"testIntConGT\", \"testIntConGE\"})\n+    public void checkTestIntCon() {\n+        \/\/ Verify the transformation \"cmp (add X min_jint) c\"\n+        \/\/ to \"cmpu X (c + min_jint)\"\n+        for (int i = 0; i < INT_DATA.length; i++) {\n+            Asserts.assertEquals(testIntConEQ(INT_DATA[i]),\n+                                 i == CONST_INDEX);\n+            Asserts.assertEquals(testIntConNE(INT_DATA[i]),\n+                                 i != CONST_INDEX);\n+            Asserts.assertEquals(testIntConLT(INT_DATA[i]),\n+                                 i <  CONST_INDEX);\n+            Asserts.assertEquals(testIntConLE(INT_DATA[i]),\n+                                 i <= CONST_INDEX);\n+            Asserts.assertEquals(testIntConGT(INT_DATA[i]),\n+                                 i >  CONST_INDEX);\n+            Asserts.assertEquals(testIntConGE(INT_DATA[i]),\n+                                 i >= CONST_INDEX);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarEQ(long x, long y) {\n+        return x + LONG_MIN == y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarNE(long x, long y) {\n+        return x + LONG_MIN != y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarLT(long x, long y) {\n+        return x + LONG_MIN < y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarLE(long x, long y) {\n+        return x + LONG_MIN <= y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarGT(long x, long y) {\n+        return x + LONG_MIN > y + LONG_MIN;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongVarGE(long x, long y) {\n+        return x + LONG_MIN >= y + LONG_MIN;\n+    }\n+\n+    @Run(test = {\"testLongVarEQ\", \"testLongVarNE\",\n+                 \"testLongVarLT\", \"testLongVarLE\",\n+                 \"testLongVarGT\", \"testLongVarGE\"})\n+    public void checkTestLongVar() {\n+        \/\/ Verify the transformation \"cmp (add X min_jlong) (add Y min_jlong)\"\n+        \/\/ to \"cmpu X Y\"\n+        for (int i = 0; i < LONG_DATA.length; i++) {\n+            for (int j = 0; j < LONG_DATA.length; j++) {\n+                Asserts.assertEquals(testLongVarEQ(LONG_DATA[i], LONG_DATA[j]),\n+                                     i == j);\n+                Asserts.assertEquals(testLongVarNE(LONG_DATA[i], LONG_DATA[j]),\n+                                     i != j);\n+                Asserts.assertEquals(testLongVarLT(LONG_DATA[i], LONG_DATA[j]),\n+                                     i <  j);\n+                Asserts.assertEquals(testLongVarLE(LONG_DATA[i], LONG_DATA[j]),\n+                                     i <= j);\n+                Asserts.assertEquals(testLongVarGT(LONG_DATA[i], LONG_DATA[j]),\n+                                     i >  j);\n+                Asserts.assertEquals(testLongVarGE(LONG_DATA[i], LONG_DATA[j]),\n+                                     i >= j);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConEQ(long x) {\n+        return x + LONG_MIN == LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConNE(long x) {\n+        return x + LONG_MIN != LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConLT(long x) {\n+        return x + LONG_MIN < LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConLE(long x) {\n+        return x + LONG_MIN <= LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConGT(long x) {\n+        return x + LONG_MIN > LONG_CONST;\n+    }\n+\n+    @Test\n+    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n+    @IR(counts = {CMPU_REGEX, \"1\"})\n+    public boolean testLongConGE(long x) {\n+        return x + LONG_MIN >= LONG_CONST;\n+    }\n+\n+    @Run(test = {\"testLongConEQ\", \"testLongConNE\",\n+                 \"testLongConLT\", \"testLongConLE\",\n+                 \"testLongConGT\", \"testLongConGE\"})\n+    public void checkTestLongConGE() {\n+        \/\/ Verify the transformation \"cmp (add X min_jlong) c\"\n+        \/\/ to \"cmpu X (c + min_jlong)\"\n+        for (int i = 0; i < LONG_DATA.length; i++) {\n+            Asserts.assertEquals(testLongConEQ(LONG_DATA[i]),\n+                                 i == CONST_INDEX);\n+            Asserts.assertEquals(testLongConNE(LONG_DATA[i]),\n+                                 i != CONST_INDEX);\n+            Asserts.assertEquals(testLongConLT(LONG_DATA[i]),\n+                                 i <  CONST_INDEX);\n+            Asserts.assertEquals(testLongConLE(LONG_DATA[i]),\n+                                 i <= CONST_INDEX);\n+            Asserts.assertEquals(testLongConGT(LONG_DATA[i]),\n+                                 i >  CONST_INDEX);\n+            Asserts.assertEquals(testLongConGE(LONG_DATA[i]),\n+                                 i >= CONST_INDEX);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestUnsignedComparison.java","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(2)\n+@State(Scope.Thread)\n+public class UnsignedComparison {\n+    private static final int ITERATIONS = 1000;\n+\n+    private static final int CONST_OPERAND = 4;\n+    private static final int INT_MIN = Integer.MIN_VALUE;\n+    private static final long LONG_MIN = Long.MIN_VALUE;\n+\n+    int arg0 = 0, arg1 = 4;\n+\n+    @Setup(Level.Invocation)\n+    public void toggle() {\n+        arg0 = (arg0 + 1) & 7;\n+    }\n+\n+    @Benchmark\n+    public void intVarDirect(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(arg0 + INT_MIN < arg1 + INT_MIN);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVarLibLT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Integer.compareUnsigned(arg0, arg1) < 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVarLibGT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Integer.compareUnsigned(arg0, arg1) > 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intConDirect(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(arg0 + INT_MIN < CONST_OPERAND + INT_MIN);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intConLibLT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Integer.compareUnsigned(arg0, CONST_OPERAND) < 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intConLibGT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Integer.compareUnsigned(arg0, CONST_OPERAND) > 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVarDirect(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(arg0 + LONG_MIN < arg1 + LONG_MIN);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVarLibLT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Long.compareUnsigned(arg0, arg1) < 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longVarLibGT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Long.compareUnsigned(arg0, arg1) > 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longConDirect(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(arg0 + LONG_MIN < CONST_OPERAND + LONG_MIN);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longConLibLT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Long.compareUnsigned(arg0, CONST_OPERAND) < 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longConLibGT(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            bh.consume(Long.compareUnsigned(arg0, CONST_OPERAND) > 0);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/UnsignedComparison.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"}]}