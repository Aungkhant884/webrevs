{"files":[{"patch":"@@ -2211,5 +2211,3 @@\n-C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong handle))\n-  if (handle != 0) {\n-    JVMCIENV->runtime()->destroy_oop_handle(handle);\n-  }\n-}\n+C2V_VMENTRY(void, releaseClearedOopHandles, (JNIEnv* env, jobject))\n+  JVMCIENV->runtime()->release_cleared_oop_handles();\n+C2V_END\n@@ -2906,1 +2904,1 @@\n-  {CC \"deleteGlobalHandle\",                           CC \"(J)V\",                                                                            FN_PTR(deleteGlobalHandle)},\n+  {CC \"releaseClearedOopHandles\",                     CC \"()V\",                                                                             FN_PTR(releaseClearedOopHandles)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -846,10 +846,2 @@\n-  oop* ptr = object_handles()->allocate();\n-  jlong res = 0;\n-  if (ptr != nullptr) {\n-    assert(*ptr == nullptr, \"invariant\");\n-    NativeAccess<>::oop_store(ptr, obj());\n-    res = (jlong) ptr;\n-  } else {\n-    vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,\n-                          \"Cannot create JVMCI oop handle\");\n-  }\n+\n+  oop* ptr = OopHandle(object_handles(), obj()).ptr_raw();\n@@ -858,1 +850,1 @@\n-  return res;\n+  return (jlong) ptr;\n@@ -861,36 +853,3 @@\n-bool JVMCIRuntime::probe_oop_handle(jlong handle, int index) {\n-  oop* key = (oop*) handle;\n-  if (key == _oop_handles.at(index)) {\n-    _last_found_oop_handle_index = index;\n-    return true;\n-  }\n-  return false;\n-}\n-\n-int JVMCIRuntime::find_oop_handle(jlong handle) {\n-  int len = _oop_handles.length();\n-  int next = _last_found_oop_handle_index + 1;\n-  int prev = MAX2(_last_found_oop_handle_index, 0) - 1;\n-\n-  \/\/ Search \"outwards\" from the index of the last found\n-  \/\/ entry. Experimentation shows that this significantly\n-  \/\/ reduces the amount of searching performed.\n-  do {\n-    if (next < len) {\n-      if (probe_oop_handle(handle, next)) {\n-        return next;\n-      }\n-      next++;\n-    }\n-    if (prev >= 0) {\n-      if (probe_oop_handle(handle, prev)) {\n-        return prev;\n-      }\n-      prev--;\n-    }\n-  } while (next - (prev + 1) < len);\n-  return -1;\n-}\n-\n-int JVMCIRuntime::release_and_clear_globals() {\n-  int released = 0;\n+int JVMCIRuntime::release_and_clear_oop_handles() {\n+  guarantee(_num_attached_threads == cannot_be_attached, \"only call during JVMCI runtime shutdown\");\n+  int released = release_cleared_oop_handles();\n@@ -898,2 +857,0 @@\n-    \/\/ Squash non-null JNI handles to front of _oop_handles for\n-    \/\/ the bulk release operation\n@@ -902,7 +859,5 @@\n-      if (oop_ptr != nullptr) {\n-        \/\/ Satisfy OopHandles::release precondition that all\n-        \/\/ handles being released are null.\n-        NativeAccess<>::oop_store(oop_ptr, (oop) NULL);\n-\n-        _oop_handles.at_put(released++, oop_ptr);\n-      }\n+      guarantee(oop_ptr != nullptr, \"release_cleared_oop_handles left null entry in _oop_handles\");\n+      guarantee(*oop_ptr != nullptr, \"unexpected cleared handle\");\n+      \/\/ Satisfy OopHandles::release precondition that all\n+      \/\/ handles being released are null.\n+      NativeAccess<>::oop_store(oop_ptr, (oop) NULL);\n@@ -910,0 +865,1 @@\n+\n@@ -911,1 +867,2 @@\n-    object_handles()->release(_oop_handles.adr_at(0), released);\n+    object_handles()->release(_oop_handles.adr_at(0), _oop_handles.length());\n+    released += _oop_handles.length();\n@@ -914,1 +871,0 @@\n-  _last_found_oop_handle_index = -1;\n@@ -918,6 +874,3 @@\n-void JVMCIRuntime::destroy_oop_handle(jlong handle) {\n-  \/\/ Assert before nulling out, for better debugging.\n-  assert(is_oop_handle(handle), \"precondition\");\n-  oop* oop_ptr = (oop*) handle;\n-  NativeAccess<>::oop_store(oop_ptr, (oop) nullptr);\n-  object_handles()->release(oop_ptr);\n+static bool is_referent_non_null(oop* handle) {\n+  return handle != nullptr && *handle != nullptr;\n+}\n@@ -925,4 +878,5 @@\n-  MutexLocker ml(_lock);\n-  int index = find_oop_handle(handle);\n-  guarantee(index != -1, \"global not allocated in JVMCI runtime %d: \" INTPTR_FORMAT, id(), handle);\n-  _oop_handles.at_put(index, nullptr);\n+\/\/ Swaps the elements in `array` at index `a` and index `b`\n+static void swap(GrowableArray<oop*>* array, int a, int b) {\n+  oop* tmp = array->at(a);\n+  array->at_put(a, array->at(b));\n+  array->at_put(b, tmp);\n@@ -931,3 +885,62 @@\n-bool JVMCIRuntime::is_oop_handle(jlong handle) {\n-  const oop* ptr = (oop*) handle;\n-  return object_handles()->allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;\n+int JVMCIRuntime::release_cleared_oop_handles() {\n+  \/\/ Despite this lock, it's possible for another thread\n+  \/\/ to clear a handle's referent concurrently (e.g., a thread\n+  \/\/ executing IndirectHotSpotObjectConstantImpl.clear()).\n+  \/\/ This is benign - it means there can still be cleared\n+  \/\/ handles in _oop_handles when this method returns.\n+  MutexLocker ml(_lock);\n+\n+  int next = 0;\n+  if (_oop_handles.length() != 0) {\n+    \/\/ Key for _oop_handles contents in example below:\n+    \/\/   H: handle with non-null referent\n+    \/\/   h: handle with clear (i.e., null) referent\n+    \/\/   -: null entry\n+\n+    \/\/ Shuffle all handles with non-null referents to the front of the list\n+    \/\/ Example: Before: 0HHh-Hh-\n+    \/\/           After: HHHh--h-\n+    for (int i = 0; i < _oop_handles.length(); i++) {\n+      oop* handle = _oop_handles.at(i);\n+      if (is_referent_non_null(handle)) {\n+        if (i != next && !is_referent_non_null(_oop_handles.at(next))) {\n+          \/\/ Swap elements at index `next` and `i`\n+          swap(&_oop_handles, next, i);\n+        }\n+        next++;\n+      }\n+    }\n+\n+    \/\/ `next` is now the index of the first null handle or handle with a null referent\n+    int num_alive = next;\n+\n+    \/\/ Shuffle all null handles to the end of the list\n+    \/\/ Example: Before: HHHh--h-\n+    \/\/           After: HHHhh---\n+    \/\/       num_alive: 3\n+    for (int i = next; i < _oop_handles.length(); i++) {\n+      oop* handle = _oop_handles.at(i);\n+      if (handle != nullptr) {\n+        if (i != next && _oop_handles.at(next) == nullptr) {\n+          \/\/ Swap elements at index `next` and `i`\n+          swap(&_oop_handles, next, i);\n+        }\n+        next++;\n+      }\n+    }\n+    int to_release = next - num_alive;\n+\n+    \/\/ `next` is now the index of the first null handle\n+    \/\/ Example: to_release: 2\n+\n+    \/\/ Bulk release the handles with a null referent\n+    object_handles()->release(_oop_handles.adr_at(num_alive), to_release);\n+\n+    \/\/ Truncate oop handles to only those with a non-null referent\n+    JVMCI_event_1(\"compacted oop handles in JVMCI runtime %d from %d to %d\", _id, _oop_handles.length(), num_alive);\n+    _oop_handles.trunc_to(num_alive);\n+    \/\/ Example: HHH\n+\n+    return to_release;\n+  }\n+  return 0;\n@@ -991,2 +1004,1 @@\n-  _for_compile_broker(for_compile_broker),\n-  _last_found_oop_handle_index(-1)\n+  _for_compile_broker(for_compile_broker)\n@@ -1172,1 +1184,1 @@\n-        int released = release_and_clear_globals();\n+        int released = release_and_clear_oop_handles();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":86,"deletions":74,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -226,5 +226,0 @@\n-  \/\/ Helpers for destroy_oop_handle\n-  int _last_found_oop_handle_index;\n-  bool probe_oop_handle(jlong handle, int index);\n-  int find_oop_handle(jlong handle);\n-\n@@ -232,2 +227,2 @@\n-  \/\/ the list. Returns the number of non-null entries prior to clearing.\n-  int release_and_clear_globals();\n+  \/\/ the list. Returns the number released handles.\n+  int release_and_clear_oop_handles();\n@@ -280,1 +275,0 @@\n-  bool is_oop_handle(jlong handle);\n@@ -282,2 +276,5 @@\n-  \/\/ Called from IndirectHotSpotObjectConstantImpl.clear(Object)\n-  void destroy_oop_handle(jlong handle);\n+  \/\/ Releases all the non-null entries in _oop_handles whose referent is null.\n+  \/\/ Returns the number of handles released by this call.\n+  \/\/ The method also resets _last_found_oop_handle_index to -1\n+  \/\/ and _null_oop_handles to 0.\n+  int release_cleared_oop_handles();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -100,0 +100,4 @@\n+     *\n+     * @returns true if the clean up action cleared the referent of an oop handle and requires a\n+     *          subsequent call to {@link CompilerToVM#releaseClearedOopHandles()} to reclaim the\n+     *          resources of the handle itself\n@@ -101,1 +105,1 @@\n-    abstract void doCleanup();\n+    abstract boolean doCleanup();\n@@ -108,0 +112,1 @@\n+        boolean oopHandleCleared = false;\n@@ -110,1 +115,3 @@\n-            c.doCleanup();\n+            if (c.doCleanup()) {\n+                oopHandleCleared = true;\n+            }\n@@ -113,0 +120,3 @@\n+        if (oopHandleCleared) {\n+            CompilerToVM.compilerToVM().releaseClearedOopHandles();\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/Cleaner.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1178,2 +1178,1 @@\n-     * Releases the resources backing the global JNI {@code handle}. This is equivalent to the\n-     * {@code DeleteGlobalRef} JNI function.\n+     * Releases all oop handles whose referent is null.\n@@ -1181,1 +1180,1 @@\n-    native void deleteGlobalHandle(long handle);\n+    native void releaseClearedOopHandles();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    void doCleanup() {\n+    boolean doCleanup() {\n@@ -62,4 +62,2 @@\n-            \/\/ The sentinel value used to denote a free handle is\n-            \/\/ an object on the HotSpot heap so we call into the\n-            \/\/ VM to set the target of an object handle to this value.\n-            CompilerToVM.compilerToVM().deleteGlobalHandle(handle);\n+            IndirectHotSpotObjectConstantImpl.clearHandle(handle);\n+            return true;\n@@ -72,0 +70,1 @@\n+            return false;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HandleCleaner.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+            CompilerToVM.compilerToVM().releaseClearedOopHandles();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstantScope.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-        void doCleanup() {\n+        boolean doCleanup() {\n@@ -363,0 +363,1 @@\n+            return false;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationLog.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n@@ -147,1 +148,0 @@\n-        CompilerToVM.compilerToVM().deleteGlobalHandle(objectHandle);\n@@ -151,0 +151,2 @@\n+\n+        clearHandle(objectHandle);\n@@ -154,0 +156,8 @@\n+    \/**\n+     * Sets the referent of {@code handle} to 0 so that it will be reclaimed when calling\n+     * {@link CompilerToVM#releaseClearedOopHandles}.\n+     *\/\n+    static void clearHandle(long handle) {\n+        UNSAFE.putLong(handle, 0);\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/IndirectHotSpotObjectConstantImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"}]}