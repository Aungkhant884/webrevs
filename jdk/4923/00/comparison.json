{"files":[{"patch":"@@ -1381,1 +1381,1 @@\n-  bool partial_peel( IdealLoopTree *loop, Node_List &old_new );\n+  bool partial_peel(IdealLoopTree* loop, Node_List& old_new);\n@@ -1383,0 +1383,3 @@\n+  \/\/ Move non-pinned data nodes into the not-peel region if possible.\n+  bool move_nodes_to_not_peel(IdealLoopTree* loop, const IfNode* new_peel_if, uint estimate, VectorSet& peel, VectorSet& not_peel,\n+                              Node_List& peel_list, Node_List& worklist, Node_List& sink_list, uint& cloned_for_outside_use);\n@@ -1384,10 +1387,12 @@\n-  void scheduled_nodelist( IdealLoopTree *loop, VectorSet& ctrl, Node_List &sched );\n-  \/\/ Has a use in the vector set\n-  bool has_use_in_set( Node* n, VectorSet& vset );\n-  \/\/ Has use internal to the vector set (ie. not in a phi at the loop head)\n-  bool has_use_internal_to_set( Node* n, VectorSet& vset, IdealLoopTree *loop );\n-  \/\/ clone \"n\" for uses that are outside of loop\n-  int  clone_for_use_outside_loop( IdealLoopTree *loop, Node* n, Node_List& worklist );\n-  \/\/ clone \"n\" for special uses that are in the not_peeled region\n-  void clone_for_special_use_inside_loop( IdealLoopTree *loop, Node* n,\n-                                          VectorSet& not_peel, Node_List& sink_list, Node_List& worklist );\n+  static void scheduled_nodelist(IdealLoopTree* loop, VectorSet& ctrl, Node_List& sched);\n+  \/\/ Has a use in the vector set?\n+  static bool has_use_in_set(Node* n, VectorSet& vset);\n+  \/\/ Has use internal to the vector set (i.e. not in a phi at the loop head)?\n+  static bool has_use_internal_to_set(Node* n, VectorSet& vset, IdealLoopTree* loop);\n+  \/\/ Clone \"n\" for uses that are outside of loop.\n+  int clone_for_use_outside_loop(IdealLoopTree* loop, Node* n, Node_List& worklist, Node_Array& initial_outside_uses_map);\n+  \/\/ Return a new or cached clone for the outside of the loop use.\n+  Node* get_clone_for_outside_use(const Node* n, Node* outside_use, Node_Array& outside_uses_map, Node_List& clones_of_n_for_use);\n+  \/\/ Clone \"n\" for special uses that are in the not_peeled region.\n+  void clone_for_special_use_inside_loop(IdealLoopTree* loop, Node* n, VectorSet& not_peel, Node_List& sink_list,\n+                                         Node_List& worklist);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2822,1 +2822,0 @@\n-\n@@ -2824,3 +2823,6 @@\n-\/\/ clone \"n\" for uses that are outside of loop\n-int PhaseIdealLoop::clone_for_use_outside_loop( IdealLoopTree *loop, Node* n, Node_List& worklist ) {\n-  int cloned = 0;\n+\/\/ Clone \"n\" for uses that are outside of 'loop'. Return the number of cloned nodes or -1 if there\n+\/\/ are not enough nodes left to create clones.\n+int PhaseIdealLoop::clone_for_use_outside_loop(IdealLoopTree* loop, Node* n, Node_List& worklist,\n+                                               Node_Array& initial_outside_uses_map) {\n+  uint cloned = 0;\n+  Node_List clones_of_n_for_use; \/\/ Mapping from outside use to cloned node\n@@ -2830,1 +2832,1 @@\n-    if( !loop->is_member(get_loop(has_ctrl(use) ? get_ctrl(use) : use)) ) {\n+    if (!loop->is_member(get_loop(has_ctrl(use) ? get_ctrl(use) : use))) {\n@@ -2840,3 +2842,5 @@\n-  while( worklist.size() ) {\n-    Node *use = worklist.pop();\n-    if (!has_node(use) || use->in(0) == C->top()) continue;\n+  while (worklist.size() > 0) {\n+    Node* outside_use = worklist.pop();\n+    if (!has_node(outside_use) || outside_use->in(0) == C->top()) {\n+      continue;\n+    }\n@@ -2844,2 +2848,4 @@\n-    for (j = 0; j < use->req(); j++) {\n-      if (use->in(j) == n) break;\n+    for (j = 0; j < outside_use->req(); j++) {\n+      if (outside_use->in(j) == n) {\n+        break;\n+      }\n@@ -2847,1 +2853,1 @@\n-    assert(j < use->req(), \"must be there\");\n+    assert(j < outside_use->req(), \"must be there\");\n@@ -2849,3 +2855,2 @@\n-    \/\/ clone \"n\" and insert it between the inputs of \"n\" and the use outside the loop\n-    Node* n_clone = n->clone();\n-    _igvn.replace_input_of(use, j, n_clone);\n+    Node* n_clone = get_clone_for_outside_use(n, outside_use, initial_outside_uses_map, clones_of_n_for_use);\n+    _igvn.replace_input_of(outside_use, j, n_clone);\n@@ -2854,2 +2859,2 @@\n-    if (!use->is_Phi()) {\n-      use_c = has_ctrl(use) ? get_ctrl(use) : use->in(0);\n+    if (!outside_use->is_Phi()) {\n+      use_c = has_ctrl(outside_use) ? get_ctrl(outside_use) : outside_use->in(0);\n@@ -2858,1 +2863,1 @@\n-      use_c = use->in(0)->in(j);\n+      use_c = outside_use->in(0)->in(j);\n@@ -2863,1 +2868,0 @@\n-    _igvn.register_new_node_with_optimizer(n_clone);\n@@ -2873,0 +2877,32 @@\n+\/\/ Return a newly created cloned node for an outside of the loop use of 'n' or a cached clone depending on whether\n+\/\/ 'outside_use' belongs to a chain of nodes for which a clone was already created in an earlier invocation of this\n+\/\/ method with the same node 'n'. This avoids the creation of unnecessary clones (see move_nodes_to_not_peel()).\n+Node* PhaseIdealLoop::get_clone_for_outside_use(const Node* n, Node* outside_use, Node_Array& outside_uses_map,\n+                                                Node_List& clones_of_n_for_use) {\n+  \/\/ Note: outside_uses_map is shared among different n's throughout the entire algorithm.\n+  Node* initial_outside_use = outside_uses_map[outside_use->_idx];\n+  if (initial_outside_use == NULL) {\n+    \/\/ outside_use is an outside of the loop use of a node of the initial peel region.\n+    initial_outside_use = outside_use;\n+    outside_uses_map.map(outside_use->_idx, outside_use);\n+  }\n+  \/\/ else: outside_use is a cloned node from the steps below which is now also not part of the loop anymore.\n+  \/\/       Use the cached initial outside of the loop use fetched from the outside_uses_map.\n+\n+  \/\/ Have we already cloned n for the initial_outside_use chain? If so directly use it and do not create another clone\n+  \/\/ for it. This ensures that we create at most u clones where u is the number of unique node uses outside of the loop\n+  \/\/ (i.e. an \"initial_outside_use chain\") of the initial peel_list (see move_nodes_to_not_peel()).\n+  \/\/ Note: clones_of_n_for_use is only used for a single node 'n' and is reset on the next invocation of this method with\n+  \/\/ a different 'n'.\n+  Node* n_clone = clones_of_n_for_use[initial_outside_use->_idx];\n+  if (n_clone == NULL) {\n+    \/\/ We have not cloned n, yet, for the chain of nodes belonging to the initial outside of the loop use initial_outside_use.\n+    \/\/ Clone n and insert it between the inputs of n and the use outside of the loop.\n+    n_clone = n->clone();\n+    _igvn.register_new_node_with_optimizer(n_clone);\n+    clones_of_n_for_use.map(initial_outside_use->_idx, n_clone);\n+    \/\/ Keep track of the initial outside of the loop use for this cloned node to access it later again when visiting the clone.\n+    outside_uses_map.map(n_clone->_idx, initial_outside_use);\n+  }\n+  return n_clone;\n+}\n@@ -3329,1 +3365,0 @@\n-  Node_List peel_list;\n@@ -3331,1 +3366,0 @@\n-  Node_List sink_list;\n@@ -3369,80 +3403,6 @@\n-  \/\/ Step 2: move operations from the peeled section down into the\n-  \/\/         not-peeled section\n-\n-  \/\/ Get a post order schedule of nodes in the peel region\n-  \/\/ Result in right-most operand.\n-  scheduled_nodelist(loop, peel, peel_list);\n-\n-  assert(is_valid_loop_partition(loop, peel, peel_list, not_peel), \"bad partition\");\n-\n-  \/\/ For future check for too many new phis\n-  uint old_phi_cnt = 0;\n-  for (DUIterator_Fast jmax, j = head->fast_outs(jmax); j < jmax; j++) {\n-    Node* use = head->fast_out(j);\n-    if (use->is_Phi()) old_phi_cnt++;\n-  }\n-\n-#ifndef PRODUCT\n-  if (TracePartialPeeling) {\n-    tty->print_cr(\"\\npeeled list\");\n-  }\n-#endif\n-\n-  \/\/ Evacuate nodes in peel region into the not_peeled region if possible\n-  bool too_many_clones = false;\n-  uint new_phi_cnt = 0;\n-  uint cloned_for_outside_use = 0;\n-  for (uint i = 0; i < peel_list.size();) {\n-    Node* n = peel_list.at(i);\n-#ifndef PRODUCT\n-  if (TracePartialPeeling) n->dump();\n-#endif\n-    bool incr = true;\n-    if (!n->is_CFG()) {\n-      if (has_use_in_set(n, not_peel)) {\n-        \/\/ If not used internal to the peeled region,\n-        \/\/ move \"n\" from peeled to not_peeled region.\n-        if (!has_use_internal_to_set(n, peel, loop)) {\n-          \/\/ if not pinned and not a load (which maybe anti-dependent on a store)\n-          \/\/ and not a CMove (Matcher expects only bool->cmove).\n-          if (n->in(0) == NULL && !n->is_Load() && !n->is_CMove()) {\n-            int new_clones = clone_for_use_outside_loop(loop, n, worklist);\n-            if (new_clones == -1) {\n-              too_many_clones = true;\n-              break;\n-            }\n-            cloned_for_outside_use += new_clones;\n-            sink_list.push(n);\n-            peel.remove(n->_idx);\n-            not_peel.set(n->_idx);\n-            peel_list.remove(i);\n-            incr = false;\n-#ifndef PRODUCT\n-            if (TracePartialPeeling) {\n-              tty->print_cr(\"sink to not_peeled region: %d newbb: %d\",\n-                            n->_idx, get_ctrl(n)->_idx);\n-            }\n-#endif\n-          }\n-        } else {\n-          \/\/ Otherwise check for special def-use cases that span\n-          \/\/ the peel\/not_peel boundary such as bool->if\n-          clone_for_special_use_inside_loop(loop, n, not_peel, sink_list, worklist);\n-          new_phi_cnt++;\n-        }\n-      }\n-    }\n-    if (incr) i++;\n-  }\n-\n-  estimate += cloned_for_outside_use + new_phi_cnt;\n-  bool exceed_node_budget = !may_require_nodes(estimate);\n-  bool exceed_phi_limit = new_phi_cnt > old_phi_cnt + PartialPeelNewPhiDelta;\n-\n-  if (too_many_clones || exceed_node_budget || exceed_phi_limit) {\n-#ifndef PRODUCT\n-    if (TracePartialPeeling && exceed_phi_limit) {\n-      tty->print_cr(\"\\nToo many new phis: %d  old %d new cmpi: %c\",\n-                    new_phi_cnt, old_phi_cnt, new_peel_if != NULL?'T':'F');\n-    }\n-#endif\n+  \/\/ Step 2: move operations from the peeled section down into the not-peeled section\n+  Node_List peel_list;\n+  Node_List sink_list;\n+  uint cloned_for_outside_use;\n+  if (!move_nodes_to_not_peel(loop, new_peel_if, estimate, peel, not_peel, peel_list, worklist, sink_list, cloned_for_outside_use)) {\n+    \/\/ Exceeded node or phi limit\n@@ -3623,0 +3583,113 @@\n+\/\/ Move non-pinned data nodes which are neither loads nor cmoves from the peel region ('peel_list'\/peel') into the not-peel\n+\/\/ ('not_peel') region if possible. This is done by walking through the peel region in post order. If a node has a use\n+\/\/ in the not-peel region and is not used in the peel region (ignoring loop phi nodes), then it can be moved to the not-peel\n+\/\/ region by cloning it into exit blocks.\n+bool PhaseIdealLoop::move_nodes_to_not_peel(IdealLoopTree* loop, const IfNode* new_peel_if, const uint estimate, VectorSet& peel, VectorSet& not_peel,\n+                                            Node_List& peel_list, Node_List& worklist, Node_List& sink_list,\n+                                            uint& cloned_for_outside_use) {\n+  \/\/ Get a post order schedule of nodes in the peel region\n+  \/\/ Result in right-most operand.\n+  scheduled_nodelist(loop, peel, peel_list);\n+  assert(is_valid_loop_partition(loop, peel, peel_list, not_peel), \"bad partition\");\n+\n+  \/\/ For future check for too many new phis\n+  const LoopNode* head = loop->_head->as_Loop();\n+  uint old_phi_cnt = 0;\n+  for (DUIterator_Fast jmax, j = head->fast_outs(jmax); j < jmax; j++) {\n+    Node* use = head->fast_out(j);\n+    if (use->is_Phi()) {\n+      old_phi_cnt++;\n+    }\n+  }\n+\n+  \/\/ Evacuate a node n in the peel region into the not_peeled region if n is not used in the peel region and\n+  \/\/ if it is not pinned and not a load nor a CMove. This is done by cloning n into the loop exit blocks\n+  \/\/ (done by clone_for_use_outside_loop()). We need to be careful to only clone a node at most u times where\n+  \/\/ u is the number of unique node uses outside of the loop of the initial peel_list. A straight forward visiting in\n+  \/\/ post order and continuous cloning of newly visited nodes is inefficient when processing a cycle\/diamond in the\n+  \/\/ graph. For example, assume a use U inside the not-peel region and a use O outside of the loop and nodes A, B, C, D\n+  \/\/ which we need to clone for the outside use O in order to sink them to the not-peel region:\n+  \/\/\n+  \/\/      A                        A                               A                        A   A2  A3  A4\n+  \/\/     \/ \\     cloning        \/      \\       cloning        \/  |   |  \\       cloning     |   |   |    |\n+  \/\/    B   C       D         B --\\  \/-- C       B,C         B   C  B2   C2        A        B   C   B2  C2\n+  \/\/     \\ \/      ====>       |    \\\/    |      ====>         \\ \/     \\ \/        ====>       \\ \/     \\ \/\n+  \/\/      D                   |    \/\\    |                     D       D2                     D       D2\n+  \/\/     \/ \\                  D --\/  \\-- D2                    |       |                      |       |\n+  \/\/    U   O                 |          |                     U       O                      U       O\n+  \/\/                          U          O\n+  \/\/\n+  \/\/ There are two redundant clones of A: A could be merged together with A2 and A3 with A4. This results in the optimal\n+  \/\/ cloning which requires at most #outside uses * #nodes = 1 * 4 = 4 clones (instead of 6 above).\n+  \/\/\n+  \/\/      A                           A         A2\n+  \/\/     \/ \\      optimal cloning    \/ \\       \/  \\\n+  \/\/    B   C        A,B,C,D        B   C     B2  C2\n+  \/\/     \\ \/         ======>         \\ \/       \\  \/\n+  \/\/      D                           D         D2\n+  \/\/     \/ \\                          |         |\n+  \/\/    U   O                         U         O\n+  \/\/\n+  \/\/ The less efficient cloning in the first example could lead to an exponential increase in the number of nodes\n+  \/\/ when processing a larger graph with many cycles\/diamonds. This is avoided in the algorithm used by\n+  \/\/ clone_for_use_outside_loop() which reuses already cloned nodes (\"merging nodes\" as mentioned above).\n+  uint new_phi_cnt = 0;\n+  cloned_for_outside_use = 0;\n+  Node_Array outside_uses_map(Thread::current()->resource_area());\n+\n+  for (uint i = 0; i < peel_list.size();) {\n+    Node* n = peel_list.at(i);\n+#ifndef PRODUCT\n+    if (TracePartialPeeling) {\n+      n->dump();\n+    }\n+#endif\n+    bool too_many_clones = false;\n+    bool incr = true;\n+    if (!n->is_CFG() && has_use_in_set(n, not_peel)) {\n+      \/\/ If not used internal to the peeled region,\n+      \/\/ move \"n\" from peeled to not_peeled region.\n+      if (!has_use_internal_to_set(n, peel, loop)) {\n+        \/\/ if not pinned and not a load (which maybe anti-dependent on a store)\n+        \/\/ and not a CMove (Matcher expects only bool->cmove).\n+        if (n->in(0) == NULL && !n->is_Load() && !n->is_CMove()) {\n+          int new_clones = clone_for_use_outside_loop(loop, n, worklist, outside_uses_map);\n+          if (new_clones == -1) {\n+            return false;\n+          }\n+          assert(new_clones >= 0, \"must be positive\");\n+          cloned_for_outside_use += new_clones;\n+          sink_list.push(n);\n+          peel.remove(n->_idx);\n+          not_peel.set(n->_idx);\n+          peel_list.remove(i);\n+          incr = false;\n+#ifndef PRODUCT\n+          if (TracePartialPeeling) {\n+            tty->print_cr(\"sink to not_peeled region: %d newbb: %d\", n->_idx, get_ctrl(n)->_idx);\n+          }\n+#endif\n+        }\n+      } else {\n+        \/\/ Otherwise check for special def-use cases that span\n+        \/\/ the peel\/not_peel boundary such as bool->if\n+        clone_for_special_use_inside_loop(loop, n, not_peel, sink_list, worklist);\n+        new_phi_cnt++;\n+      }\n+    }\n+    if (incr) {\n+      i++;\n+    }\n+  }\n+  bool exceed_node_budget = !may_require_nodes(cloned_for_outside_use + new_phi_cnt + estimate);\n+  bool exceed_phi_limit = new_phi_cnt > old_phi_cnt + PartialPeelNewPhiDelta;\n+  bool exceeded = exceed_node_budget || exceed_phi_limit;\n+#ifndef PRODUCT\n+  if (TracePartialPeeling && exceed_phi_limit) {\n+    tty->print_cr(\"\\nToo many new phis: %d  old %d new cmpi: %c\",\n+                  new_phi_cnt, old_phi_cnt, new_peel_if != NULL ? 'T' : 'F');\n+  }\n+#endif\n+  return !exceeded;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":173,"deletions":100,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8256934\n+ * @bug 8256934 8268744\n@@ -31,1 +31,1 @@\n- *                   compiler.loopopts.TestPartialPeelingSinkNodes\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure compiler.loopopts.TestPartialPeelingSinkNodes\n@@ -45,0 +45,3 @@\n+    \/\/ Edit 8268744: When increasing the node limit (default limit will bailout with 8256934), the old algorithm needs\n+    \/\/ significantly more time to execute where the new algorithm is much faster and only requires ~140 new nodes.\n+    \/\/ There is no compilation bailout anymore and -XX:+AbortVMOnCompilationFailure does not abort the VM.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPartialPeelingSinkNodes.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}