{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.vm.annotation.DontInline;\n@@ -36,0 +37,2 @@\n+import static java.lang.invoke.MethodHandleNatives.Constants.REF_invokeStatic;\n+\n@@ -42,0 +45,2 @@\n+    final Class<?> implClass;\n+\n@@ -48,0 +53,2 @@\n+        this.memberName_table = new MemberName[VarHandle.AccessMode.values().length];\n+        this.implClass = implClass;\n@@ -56,3 +63,0 @@\n-\n-        \/\/ TODO lazily calculate\n-        this.memberName_table = linkFromStatic(implClass);\n@@ -61,0 +65,1 @@\n+    \/\/ Used by IndirectVarHandle\n@@ -64,0 +69,1 @@\n+        this.implClass = null;\n@@ -68,0 +74,12 @@\n+        Class<?> erasedValue = MethodTypeForm.canonicalize(value, MethodTypeForm.ERASE);\n+        Class<?>[] erasedCoordinates = MethodTypeForm.canonicalizeAll(coordinates, MethodTypeForm.ERASE);\n+\n+        if (erasedValue != null) {\n+            value = erasedValue;\n+        }\n+        if (erasedCoordinates != null) {\n+            coordinates = erasedCoordinates;\n+        }\n+\n+        MethodType type = MethodType.methodType(value, coordinates);\n+\n@@ -69,2 +87,5 @@\n-        methodType_table[VarHandle.AccessType.GET.ordinal()] =\n-                MethodType.methodType(value, coordinates).erase();\n+        methodType_table[VarHandle.AccessType.GET.ordinal()] = type;\n+\n+        \/\/ (Receiver, <Intermediates>, Value)Value\n+        type = methodType_table[VarHandle.AccessType.GET_AND_UPDATE.ordinal()] =\n+                type.appendParameterTypes(value);\n@@ -73,2 +94,1 @@\n-        methodType_table[VarHandle.AccessType.SET.ordinal()] =\n-                MethodType.methodType(void.class, coordinates).appendParameterTypes(value).erase();\n+        methodType_table[VarHandle.AccessType.SET.ordinal()] = type.changeReturnType(void.class);\n@@ -76,3 +96,3 @@\n-        \/\/ (Receiver, <Intermediates>, Value)Value\n-        methodType_table[VarHandle.AccessType.GET_AND_UPDATE.ordinal()] =\n-                MethodType.methodType(value, coordinates).appendParameterTypes(value).erase();\n+        \/\/ (Receiver, <Intermediates>, Value, Value)Value\n+        type = methodType_table[VarHandle.AccessType.COMPARE_AND_EXCHANGE.ordinal()] =\n+                type.appendParameterTypes(value);\n@@ -82,5 +102,1 @@\n-                MethodType.methodType(boolean.class, coordinates).appendParameterTypes(value, value).erase();\n-\n-        \/\/ (Receiver, <Intermediates>, Value, Value)Value\n-        methodType_table[VarHandle.AccessType.COMPARE_AND_EXCHANGE.ordinal()] =\n-                MethodType.methodType(value, coordinates).appendParameterTypes(value, value).erase();\n+                type.changeReturnType(boolean.class);\n@@ -96,1 +112,0 @@\n-        \/\/ TODO calculate lazily\n@@ -99,1 +114,10 @@\n-            throw new UnsupportedOperationException();\n+            mn = resolveMemberName(mode, false);\n+        }\n+        return mn;\n+    }\n+\n+    @ForceInline\n+    final MemberName getMemberNameOrNull(int mode) {\n+        MemberName mn = memberName_table[mode];\n+        if (mn == null) {\n+            mn = resolveMemberName(mode, true);\n@@ -104,0 +128,17 @@\n+    @DontInline\n+    MemberName resolveMemberName(int mode, boolean graceful) {\n+        AccessMode value = AccessMode.values()[mode];\n+        String methodName = value.methodName();\n+        try {\n+            MethodType type = methodType_table[value.at.ordinal()].insertParameterTypes(0, VarHandle.class);\n+            return memberName_table[mode]\n+                = MethodHandles.Lookup.IMPL_LOOKUP\n+                    .resolveOrFail(REF_invokeStatic, implClass, methodName, type);\n+        } catch (ReflectiveOperationException e) {\n+            if (graceful) {\n+                return null;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n@@ -128,21 +169,0 @@\n-\n-\n-    \/**\n-     * Link all signature polymorphic methods.\n-     *\/\n-    private static MemberName[] linkFromStatic(Class<?> implClass) {\n-        MemberName[] table = new MemberName[AccessMode.values().length];\n-\n-        for (Class<?> c = implClass; c != VarHandle.class; c = c.getSuperclass()) {\n-            for (Method m : c.getDeclaredMethods()) {\n-                if (Modifier.isStatic(m.getModifiers())) {\n-                    AccessMode am = AccessMode.methodNameToAccessMode.get(m.getName());\n-                    if (am != null) {\n-                        assert table[am.ordinal()] == null;\n-                        table[am.ordinal()] = new MemberName(m);\n-                    }\n-                }\n-            }\n-        }\n-        return table;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarForm.java","additions":58,"deletions":38,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -1941,5 +1941,0 @@\n-\n-        @ForceInline\n-        static MemberName getMemberName(int ordinal, VarForm vform) {\n-            return vform.memberName_table[ordinal];\n-        }\n@@ -2048,1 +2043,1 @@\n-        return AccessMode.getMemberName(accessMode.ordinal(), vform) != null;\n+        return vform.getMemberNameOrNull(accessMode.ordinal()) != null;\n@@ -2071,2 +2066,1 @@\n-        MemberName mn = AccessMode.getMemberName(accessMode.ordinal(), vform);\n-        if (mn != null) {\n+        if (isAccessModeSupported(accessMode)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"}]}