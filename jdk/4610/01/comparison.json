{"files":[{"patch":"@@ -168,0 +168,37 @@\n+class NativeJccInstruction: public NativeInstruction {\n+public:\n+  enum Intel_specific_constants {\n+    je_opcode_b0            = 0x0F,\n+    je_opcode_b1            = 0x84,\n+    instruction_size        = 6,\n+    data_offset             = 2,\n+  };\n+  bool is_je() {\n+    u_char b0 = ubyte_at(0);\n+    u_char b1 = ubyte_at(1);\n+    return b0 == je_opcode_b0 && b1 == je_opcode_b1;\n+  }\n+  void patch_to_jmp() {\n+    jint offset = int_at(NativeJccInstruction::data_offset);\n+    assert(offset == NativeCall::instruction_size, \"jump over the call\");\n+\n+    set_char_at(0, static_cast<char>(NativeJump::instruction_code));\n+    set_int_at(NativeJump::data_offset, offset + NativeInstruction::nop_instruction_size);\n+    set_char_at(NativeJump::instruction_size, static_cast<char>(NativeInstruction::nop_instruction_code));\n+  }\n+  void patch_to_je() {\n+    u_char jmp_opcode = ubyte_at(0);\n+    u_char nop_opcode = ubyte_at(NativeJump::instruction_size);\n+    assert(jmp_opcode == NativeJump::instruction_code &&\n+        nop_opcode == NativeInstruction::nop_instruction_code, \"must equal\");\n+\n+    jint offset = int_at(NativeJump::data_offset);\n+    assert(offset == NativeCall::instruction_size + NativeInstruction::nop_instruction_size,\n+        \"jump over nop and call\");\n+\n+    set_char_at(0, static_cast<char>(je_opcode_b0));\n+    set_char_at(1, static_cast<char>(je_opcode_b1));\n+    set_int_at(2, offset - NativeInstruction::nop_instruction_size);\n+  }\n+};\n+\n@@ -177,0 +214,23 @@\n+void BarrierSetNMethod::fix_entry_barrier(nmethod* nm, bool bypass) {\n+  if (!supports_entry_barrier(nm)) {\n+    return;\n+  }\n+  address je_addr = nm->code_begin() + nm->frame_complete_offset() +\n+      entry_barrier_offset + NativeNMethodCmpBarrier::instruction_size;\n+#ifndef _LP64\n+  \/\/ there is a pop instruction after the cmpl instruction\n+  je_addr += NativePopReg::instruction_size;\n+#endif\n+  NativeJccInstruction* jcc = reinterpret_cast<NativeJccInstruction*>(je_addr);\n+  if (bypass) {\n+    if (jcc->is_je()) {\n+      jcc->patch_to_jmp();\n+    }\n+  } else {\n+    if (!jcc->is_je()) {\n+      \/\/ has been bypassed\n+      jcc->patch_to_je();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  void fix_entry_barrier(nmethod* nm, bool bypass) X86_ONLY(;) NOT_X86({})\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -166,0 +166,2 @@\n+  const ZNMethodDataOops* const oops = gc_data(nm)->oops();\n+  fix_entry_barrier(nm, nm->oops_count() == 1 && oops->immediates_count() == 0);\n@@ -207,0 +209,5 @@\n+void ZNMethod::fix_entry_barrier(nmethod* nm, bool bypass) {\n+  BarrierSetNMethod* const bs = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  bs->fix_entry_barrier(nm, bypass);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  static void fix_entry_barrier(nmethod* nm, bool bypass);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}