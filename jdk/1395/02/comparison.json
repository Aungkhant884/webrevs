{"files":[{"patch":"@@ -1708,0 +1708,3 @@\n+  \/\/ Initialize and schedule sampling task on service thread.\n+  _rem_set->initialize_sampling_task(service_thread());\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/g1\/g1Policy.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n@@ -491,1 +493,2 @@\n-  _hot_card_cache(hot_card_cache) {\n+  _hot_card_cache(hot_card_cache),\n+  _sampling_task(NULL) {\n@@ -496,0 +499,3 @@\n+  if (_sampling_task != NULL) {\n+    delete _sampling_task;\n+  }\n@@ -502,0 +508,76 @@\n+class G1YoungRemSetSamplingClosure : public HeapRegionClosure {\n+  SuspendibleThreadSetJoiner* _sts;\n+  size_t _regions_visited;\n+  size_t _sampled_rs_length;\n+public:\n+  G1YoungRemSetSamplingClosure(SuspendibleThreadSetJoiner* sts) :\n+    HeapRegionClosure(), _sts(sts), _regions_visited(0), _sampled_rs_length(0) { }\n+\n+  virtual bool do_heap_region(HeapRegion* r) {\n+    size_t rs_length = r->rem_set()->occupied();\n+    _sampled_rs_length += rs_length;\n+\n+    \/\/ Update the collection set policy information for this region\n+    G1CollectedHeap::heap()->collection_set()->update_young_region_prediction(r, rs_length);\n+\n+    _regions_visited++;\n+\n+    if (_regions_visited == 10) {\n+      if (_sts->should_yield()) {\n+        _sts->yield();\n+        \/\/ A gc may have occurred and our sampling data is stale and further\n+        \/\/ traversal of the collection set is unsafe\n+        return true;\n+      }\n+      _regions_visited = 0;\n+    }\n+    return false;\n+  }\n+\n+  size_t sampled_rs_length() const { return _sampled_rs_length; }\n+};\n+\n+\/\/ Task handling young gen remembered set sampling.\n+class G1RemSetSamplingTask : public G1ServiceTask {\n+  \/\/ Sample the current length of remembered sets for young.\n+  \/\/\n+  \/\/ At the end of the GC G1 determines the length of the young gen based on\n+  \/\/ how much time the next GC can take, and when the next GC may occur\n+  \/\/ according to the MMU.\n+  \/\/\n+  \/\/ The assumption is that a significant part of the GC is spent on scanning\n+  \/\/ the remembered sets (and many other components), so this thread constantly\n+  \/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n+  \/\/ G1Policy resizes the young gen. This may do a premature GC or even\n+  \/\/ increase the young gen size to keep pause time length goal.\n+  void sample_young_list_rs_length(){\n+    SuspendibleThreadSetJoiner sts;\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1Policy* policy = g1h->policy();\n+\n+    if (policy->use_adaptive_young_list_length()) {\n+      G1YoungRemSetSamplingClosure cl(&sts);\n+\n+      G1CollectionSet* g1cs = g1h->collection_set();\n+      g1cs->iterate(&cl);\n+\n+      if (cl.is_complete()) {\n+        policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());\n+      }\n+    }\n+  }\n+\n+public:\n+  G1RemSetSamplingTask(const char* name) : G1ServiceTask(name) { }\n+  virtual void execute() {\n+    sample_young_list_rs_length();\n+    schedule(G1ConcRefinementServiceIntervalMillis);\n+  }\n+};\n+\n+void G1RemSet::initialize_sampling_task(G1ServiceThread* thread) {\n+  assert(_sampling_task == NULL, \"Sampling task already initialized\");\n+  _sampling_task = new G1RemSetSamplingTask(\"Remembered Set Sampling Task\");\n+  thread->register_task(_sampling_task);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":83,"deletions":1,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+class G1ServiceTask;\n+class G1ServiceThread;\n@@ -68,0 +70,1 @@\n+  G1ServiceTask*         _sampling_task;\n@@ -84,0 +87,3 @@\n+  \/\/ Initialize and schedule young remembered set sampling task.\n+  void initialize_sampling_task(G1ServiceThread* thread);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/g1\/g1CollectionSet.hpp\"\n@@ -30,1 +29,0 @@\n-#include \"gc\/g1\/g1Policy.hpp\"\n@@ -32,3 +30,0 @@\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -103,69 +98,0 @@\n-class G1YoungRemSetSamplingClosure : public HeapRegionClosure {\n-  SuspendibleThreadSetJoiner* _sts;\n-  size_t _regions_visited;\n-  size_t _sampled_rs_length;\n-public:\n-  G1YoungRemSetSamplingClosure(SuspendibleThreadSetJoiner* sts) :\n-    HeapRegionClosure(), _sts(sts), _regions_visited(0), _sampled_rs_length(0) { }\n-\n-  virtual bool do_heap_region(HeapRegion* r) {\n-    size_t rs_length = r->rem_set()->occupied();\n-    _sampled_rs_length += rs_length;\n-\n-    \/\/ Update the collection set policy information for this region\n-    G1CollectedHeap::heap()->collection_set()->update_young_region_prediction(r, rs_length);\n-\n-    _regions_visited++;\n-\n-    if (_regions_visited == 10) {\n-      if (_sts->should_yield()) {\n-        _sts->yield();\n-        \/\/ A gc may have occurred and our sampling data is stale and further\n-        \/\/ traversal of the collection set is unsafe\n-        return true;\n-      }\n-      _regions_visited = 0;\n-    }\n-    return false;\n-  }\n-\n-  size_t sampled_rs_length() const { return _sampled_rs_length; }\n-};\n-\n-\/\/ Task handling young gen remembered set sampling.\n-class G1RemSetSamplingTask : public G1ServiceTask {\n-  \/\/ Sample the current length of remembered sets for young.\n-  \/\/\n-  \/\/ At the end of the GC G1 determines the length of the young gen based on\n-  \/\/ how much time the next GC can take, and when the next GC may occur\n-  \/\/ according to the MMU.\n-  \/\/\n-  \/\/ The assumption is that a significant part of the GC is spent on scanning\n-  \/\/ the remembered sets (and many other components), so this thread constantly\n-  \/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n-  \/\/ G1Policy resizes the young gen. This may do a premature GC or even\n-  \/\/ increase the young gen size to keep pause time length goal.\n-  void sample_young_list_rs_length(){\n-    SuspendibleThreadSetJoiner sts;\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-    G1Policy* policy = g1h->policy();\n-\n-    if (policy->use_adaptive_young_list_length()) {\n-      G1YoungRemSetSamplingClosure cl(&sts);\n-\n-      G1CollectionSet* g1cs = g1h->collection_set();\n-      g1cs->iterate(&cl);\n-\n-      if (cl.is_complete()) {\n-        policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());\n-      }\n-    }\n-  }\n-public:\n-  G1RemSetSamplingTask(const char* name) : G1ServiceTask(name) { }\n-  virtual void execute() {\n-    sample_young_list_rs_length();\n-    schedule(G1ConcRefinementServiceIntervalMillis);\n-  }\n-};\n-\n@@ -179,1 +105,0 @@\n-    _remset_task(new G1RemSetSamplingTask(\"Remembered Set Sampling Task\")),\n@@ -187,1 +112,0 @@\n-  delete _remset_task;\n@@ -298,1 +222,0 @@\n-  register_task(_remset_task);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class G1RemSetSamplingTask;\n@@ -109,1 +108,0 @@\n-  G1RemSetSamplingTask* _remset_task;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}