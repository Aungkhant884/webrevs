{"files":[{"patch":"@@ -553,1 +553,2 @@\n-  void sample_young_list_rs_length(SuspendibleThreadSetJoiner* sts){\n+  void sample_young_list_rs_length(){\n+    SuspendibleThreadSetJoiner sts;\n@@ -558,1 +559,1 @@\n-      G1YoungRemSetSamplingClosure cl(sts);\n+      G1YoungRemSetSamplingClosure cl(&sts);\n@@ -569,16 +570,0 @@\n-  \/\/ To avoid extensive rescheduling if the task is executed a bit early. The task is\n-  \/\/ only rescheduled if the expected time is more than 1ms away.\n-  bool should_reschedule() {\n-    return reschedule_delay_ms() > 1;\n-  }\n-\n-  \/\/ There is no reason to do the sampling if a GC occurred recently. We use the\n-  \/\/ G1ConcRefinementServiceIntervalMillis as the metric for recently and calculate\n-  \/\/ the diff to the last GC. If the last GC occurred longer ago than the interval\n-  \/\/ 0 is returned.\n-  jlong reschedule_delay_ms() {\n-    Tickspan since_last_gc = G1CollectedHeap::heap()->time_since_last_collection();\n-    jlong delay = (jlong) (G1ConcRefinementServiceIntervalMillis - since_last_gc.milliseconds());\n-    return MAX2<jlong>(0L, delay);\n-  }\n-\n@@ -588,11 +573,1 @@\n-    SuspendibleThreadSetJoiner sts;\n-\n-    \/\/ Reschedule if a GC happened too recently.\n-    if (should_reschedule()) {\n-      \/\/ Calculate the delay given the last GC and the interval.\n-      schedule(reschedule_delay_ms());\n-      return;\n-    }\n-\n-    \/\/ Do the actual sampling.\n-    sample_young_list_rs_length(&sts);\n+    sample_young_list_rs_length();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"}]}