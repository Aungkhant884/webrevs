{"files":[{"patch":"@@ -94,7 +94,2 @@\n- * overflow errors need to be detected, the methods {@code addExact},\n- * {@code subtractExact}, {@code multiplyExact}, {@code toIntExact},\n- * {@code incrementExact}, {@code decrementExact} and {@code negateExact}\n- * throw an {@code ArithmeticException} when the results overflow.\n- * For the arithmetic operations divide and absolute value, overflow\n- * occurs only with a specific minimum or maximum value and\n- * should be checked against the minimum or maximum as appropriate.\n+ * overflow errors need to be detected, the methods whose names end with\n+ * {@code Exact} throw an {@code ArithmeticException} when the results overflow.\n@@ -1010,0 +1005,47 @@\n+    \/**\n+     * Returns the quotient of the arguments, throwing an exception if the\n+     * result overflows an {@code int}.  Such overflow can occur if and only\n+     * if either {@code y} is zero, or both {@code x} is\n+     * {@link Integer#MIN_VALUE} and {@code y} is {@code -1}.  In contrast,\n+     * if {@code Integer.MIN_VALUE \/ -1} were evaluated directly, the result\n+     * would be {@code Integer.MIN_VALUE} and no exception would be thrown.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the quotient {@code x \/ y}\n+     * @throws ArithmeticException if the quotient overflows an int\n+     * @jls 15.17.2 Division Operator \/\n+     * @since 18\n+     *\/\n+    public static int divideExact(int x, int y) {\n+        \/\/ * This conditional is slower than the straightfoward one below.\n+        \/\/ HD 2nd. Ed. p. 44 section 2-13 Overflow Detection: Division\n+        \/\/ int z = (x ^ Integer.MIN_VALUE) | (y + 1);\n+        \/\/ if (((y | -y) & (z | -z)) >= 0)\n+\n+        if (x == Integer.MIN_VALUE && y == -1)\n+            throw new ArithmeticException(\"integer overflow\");\n+        return x \/ y; \/\/ if y == 0, ArithmeticException is thrown here\n+    }\n+\n+    \/**\n+     * Returns the quotient of the arguments, throwing an exception if the\n+     * result overflows a {@code long}.  Such overflow can occur if and only\n+     * if either {@code y} is zero, or both {@code x} is\n+     * {@link Long#MIN_VALUE} and {@code y} is {@code -1}.  In contrast,\n+     * if {@code Long.MIN_VALUE \/ -1} were evaluated directly, the result\n+     * would be {@code Long.MIN_VALUE} and no exception would be thrown.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the quotient {@code x \/ y}\n+     * @throws ArithmeticException if the quotient overflows a long\n+     * @jls 15.17.2 Division Operator \/\n+     * @since 18\n+     *\/\n+    public static long divideExact(long x, long y) {\n+        if (x == Long.MIN_VALUE && y == -1L)\n+            throw new ArithmeticException(\"long overflow\");\n+        return x \/ y; \/\/ if y == 0, ArithmeticException is thrown here\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":49,"deletions":7,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @bug 6708398\n+ * @bug 6708398 8075806\n@@ -135,0 +135,33 @@\n+        boolean exceptionExpected = false;\n+        try {\n+            \/\/ Test divideExact\n+            BigInteger q = null;\n+            try {\n+                q = BigInteger.valueOf(x).divide(BigInteger.valueOf(y));\n+            } catch (ArithmeticException e) {\n+                exceptionExpected = true;\n+            }\n+            int quotient = 0;\n+            if (q != null) {\n+                try {\n+                    quotient = q.intValueExact();\n+                } catch (ArithmeticException e) {\n+                    exceptionExpected = true;\n+                }\n+            }\n+            int z = Math.divideExact(x, y);\n+            if (exceptionExpected) {\n+                fail(\"FAIL: int Math.divideExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; expected ArithmeticException not thrown\");\n+            }\n+            if (z != quotient) {\n+                fail(\"FAIL: int Math.divideExact(\" + x + \" \/ \" + y + \") = \" +\n+                    z + \"; expected: \" + quotient);\n+            }\n+        } catch (ArithmeticException ex) {\n+            if (!exceptionExpected) {\n+                fail(\"FAIL: int Math.divideExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; Unexpected exception: \" + ex);\n+            }\n+        }\n+\n@@ -272,0 +305,20 @@\n+        try {\n+            \/\/ Test divideExact\n+            resultBig = null;\n+            try {\n+                resultBig = xBig.divide(yBig);\n+            } catch (ArithmeticException ex) {\n+            }\n+            long quotient = Math.divideExact(x, y);\n+            if (resultBig == null) {\n+                fail(\"FAIL: long Math.divideExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; expected ArithmeticException not thrown\");\n+            }\n+            checkResult(\"long Math.divideExact\", x, y, quotient, resultBig);\n+        } catch (ArithmeticException ex) {\n+            if (resultBig != null && inLongRange(resultBig)) {\n+                fail(\"FAIL: long Math.divideExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; Unexpected exception: \" + ex);\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/lang\/Math\/ExactArithTests.java","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"}]}