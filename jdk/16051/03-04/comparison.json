{"files":[{"patch":"@@ -42,4 +42,6 @@\n- * Returns the children of the requested pid and optionally each parent and\n- * start time. If requested pid is zero return all processes.\n- * Use getprocs64 to accumulate any process following the rule above.\n- * The resulting pids are stored into the array of longs.\n+ * Return pids of active processes, and optionally parent pids and\n+ * start times for each process.\n+ * For a specific non-zero pid, only the direct children are returned.\n+ * If the pid is zero, all active processes are returned.\n+ * Use getprocs64 to accumulate any process following the rules above.\n+ * The resulting pids are stored into an array of longs named jarray.\n@@ -47,2 +49,8 @@\n- * If the parentArray is non-null, store the parent pid.\n- * If the array is too short, excess pids are not stored and\n+ * If the parentArray is non-null, store also the parent pid.\n+ * In this case the parentArray must have the same length as the result pid array.\n+ * Of course in the case of a given non-zero pid all entries in the parentArray\n+ * will contain this pid, so this array does only make sense in the case of a given\n+ * zero pid.\n+ * If the jstimesArray is non-null, store also the start time of the pid.\n+ * In this case the jstimesArray must have the same length as the result pid array.\n+ * If the array(s) (is|are) too short, excess pids are not stored and\n@@ -109,4 +117,0 @@\n-                pid_t ppid = 0;\n-                jlong startTime = 0L;\n-\n-                \/* skip files that aren't numbers *\/\n@@ -114,3 +118,1 @@\n-                if ((int) childpid <= 0) {\n-                    continue;\n-                }\n+                pid_t ppid = (pid_t) ProcessBuffer[i].pi_ppid;\n@@ -119,3 +121,1 @@\n-                ppid = (pid_t) ProcessBuffer[i].pi_ppid;\n-                startTime = ((jlong) ProcessBuffer[i].pi_start) *1000;\n-                if (ppid >= 0 && (pid == 0 || ppid == pid)) {\n+                if (pid == 0 || ppid == pid) {\n@@ -132,1 +132,1 @@\n-                            stimes[count] = startTime;\n+                            stimes[count] = ((jlong) ProcessBuffer[i].pi_start) * 1000;;\n","filename":"src\/java.base\/aix\/native\/libjava\/ProcessHandleImpl_aix.c","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -494,4 +494,6 @@\n- * Returns the children of the requested pid and optionally each parent and\n- * start time.\n- * Reads \/proc and accumulates any process who parent pid matches.\n- * The resulting pids are stored into the array of longs.\n+ * Return pids of active processes, and optionally parent pids and\n+ * start times for each process.\n+ * For a specific non-zero pid, only the direct children are returned.\n+ * If the pid is zero, all active processes are returned.\n+ * Reads \/proc and accumulates any process following the rules above.\n+ * The resulting pids are stored into an array of longs named jarray.\n@@ -499,1 +501,9 @@\n- * If the array is too short, the negative of the desired length is returned.\n+ * If the parentArray is non-null, store also the parent pid.\n+ * In this case the parentArray must have the same length as the result pid array.\n+ * Of course in the case of a given non-zero pid all entries in the parentArray\n+ * will contain this pid, so this array does only make sense in the case of a given\n+ * zero pid.\n+ * If the jstimesArray is non-null, store also the start time of the pid.\n+ * In this case the jstimesArray must have the same length as the result pid array.\n+ * If the array(s) (is|are) too short, excess pids are not stored and\n+ * the desired length is returned.\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}