{"files":[{"patch":"@@ -83,3 +83,3 @@\n-    const int Chunk = 100;\n-    struct procentry64 ProcessBuffer[Chunk];\n-    pid_t IndexPointer = 0;\n+    const int chunk = 100;\n+    struct procentry64 ProcessBuffer[chunk];\n+    pid_t idxptr = 0;\n@@ -106,4 +106,5 @@\n-        while ((num = getprocs64(ProcessBuffer, sizeof(struct procentry64), NULL, sizeof(struct fdsinfo64), &IndexPointer, Chunk)) != -1) {\n-          for (i = 0; i < num; i++) {\n-            pid_t ppid = 0;\n-            jlong startTime = 0L;\n+        while ((num = getprocs64(ProcessBuffer, sizeof(struct procentry64), NULL,\n+                                 sizeof(struct fdsinfo64), &idxptr, chunk)) != -1) {\n+            for (i = 0; i < num; i++) {\n+                pid_t ppid = 0;\n+                jlong startTime = 0L;\n@@ -111,5 +112,5 @@\n-            \/* skip files that aren't numbers *\/\n-            pid_t childpid = (pid_t) ProcessBuffer[i].pi_pid;\n-            if ((int) childpid <= 0) {\n-                continue;\n-            }\n+                \/* skip files that aren't numbers *\/\n+                pid_t childpid = (pid_t) ProcessBuffer[i].pi_pid;\n+                if ((int) childpid <= 0) {\n+                    continue;\n+                }\n@@ -117,15 +118,16 @@\n-            \/\/ Get the parent pid, and start time\n-            ppid = (pid_t) ProcessBuffer[i].pi_ppid;\n-            startTime = ((jlong) ProcessBuffer[i].pi_start) *1000;\n-            if (ppid >= 0 && (pid == 0 || ppid == pid)) {\n-                if (count < arraySize) {\n-                    \/\/ Only store if it fits\n-                    pids[count] = (jlong) childpid;\n-\n-                    if (ppids != NULL) {\n-                        \/\/ Store the parentPid\n-                        ppids[count] = (jlong) ppid;\n-                    }\n-                    if (stimes != NULL) {\n-                        \/\/ Store the process start time\n-                        stimes[count] = startTime;\n+                \/\/ Get the parent pid, and start time\n+                ppid = (pid_t) ProcessBuffer[i].pi_ppid;\n+                startTime = ((jlong) ProcessBuffer[i].pi_start) *1000;\n+                if (ppid >= 0 && (pid == 0 || ppid == pid)) {\n+                    if (count < arraySize) {\n+                        \/\/ Only store if it fits\n+                        pids[count] = (jlong) childpid;\n+\n+                        if (ppids != NULL) {\n+                            \/\/ Store the parentPid\n+                            ppids[count] = (jlong) ppid;\n+                        }\n+                        if (stimes != NULL) {\n+                            \/\/ Store the process start time\n+                            stimes[count] = startTime;\n+                        }\n@@ -133,0 +135,1 @@\n+                    count++; \/\/ Count to tabulate size needed\n@@ -134,1 +137,0 @@\n-                count++; \/\/ Count to tabulate size needed\n@@ -136,3 +138,3 @@\n-          }\n-          if (num < Chunk)\n-            break;\n+            if (num < chunk) {\n+                break;\n+            }\n@@ -153,3 +155,3 @@\n-      JNU_ThrowByNameWithLastError(env,\n-          \"java\/lang\/RuntimeException\", \"Unable to retrieve Process info\");\n-      return -1;\n+        JNU_ThrowByNameWithLastError(env,\n+            \"java\/lang\/RuntimeException\", \"Unable to retrieve Process info\");\n+        return -1;\n","filename":"src\/java.base\/aix\/native\/libjava\/ProcessHandleImpl_aix.c","additions":36,"deletions":34,"binary":false,"changes":70,"status":"modified"}]}