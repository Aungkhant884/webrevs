{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"jni_util.h\"\n@@ -31,0 +32,1 @@\n+#include <procinfo.h>\n@@ -39,0 +41,10 @@\n+\/*\n+ * Returns the children of the requested pid and optionally each parent and\n+ * start time. If requested pid is zero return all processes.\n+ * Use getprocs64 to accumulate any process following the rule above.\n+ * The resulting pids are stored into the array of longs.\n+ * The number of pids is returned if they all fit.\n+ * If the parentArray is non-null, store the parent pid.\n+ * If the array is too short, excess pids are not stored and\n+ * the desired length is returned.\n+ *\/\n@@ -41,1 +53,107 @@\n-    return unix_getChildren(env, jpid, jarray, jparentArray, jstimesArray);\n+    pid_t pid = (pid_t) jpid;\n+    jlong* pids = NULL;\n+    jlong* ppids = NULL;\n+    jlong* stimes = NULL;\n+    jsize parentArraySize = 0;\n+    jsize arraySize = 0;\n+    jsize stimesSize = 0;\n+    jsize count = 0;\n+\n+    arraySize = (*env)->GetArrayLength(env, jarray);\n+    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+    if (jparentArray != NULL) {\n+        parentArraySize = (*env)->GetArrayLength(env, jparentArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != parentArraySize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+    if (jstimesArray != NULL) {\n+        stimesSize = (*env)->GetArrayLength(env, jstimesArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != stimesSize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+\n+    const int Chunk = 100;\n+    struct procentry64 ProcessBuffer[Chunk];\n+    pid_t IndexPointer = 0;\n+    int i, num = 0;\n+\n+    do { \/\/ Block to break out of on Exception\n+        pids = (*env)->GetLongArrayElements(env, jarray, NULL);\n+        if (pids == NULL) {\n+            break;\n+        }\n+        if (jparentArray != NULL) {\n+            ppids  = (*env)->GetLongArrayElements(env, jparentArray, NULL);\n+            if (ppids == NULL) {\n+                break;\n+            }\n+        }\n+        if (jstimesArray != NULL) {\n+            stimes  = (*env)->GetLongArrayElements(env, jstimesArray, NULL);\n+            if (stimes == NULL) {\n+                break;\n+            }\n+        }\n+\n+        while ((num = getprocs64(ProcessBuffer, sizeof(struct procentry64), NULL, sizeof(struct fdsinfo64), &IndexPointer, Chunk)) != -1) {\n+          for (i = 0; i < num; i++) {\n+            pid_t ppid = 0;\n+            jlong startTime = 0L;\n+\n+            \/* skip files that aren't numbers *\/\n+            pid_t childpid = (pid_t) ProcessBuffer[i].pi_pid;\n+            if ((int) childpid <= 0) {\n+                continue;\n+            }\n+\n+            \/\/ Get the parent pid, and start time\n+            ppid = (pid_t) ProcessBuffer[i].pi_ppid;\n+            startTime = ((jlong) ProcessBuffer[i].pi_start) *1000;\n+            if (ppid >= 0 && (pid == 0 || ppid == pid)) {\n+                if (count < arraySize) {\n+                    \/\/ Only store if it fits\n+                    pids[count] = (jlong) childpid;\n+\n+                    if (ppids != NULL) {\n+                        \/\/ Store the parentPid\n+                        ppids[count] = (jlong) ppid;\n+                    }\n+                    if (stimes != NULL) {\n+                        \/\/ Store the process start time\n+                        stimes[count] = startTime;\n+                    }\n+                }\n+                count++; \/\/ Count to tabulate size needed\n+            }\n+          }\n+          if (num < Chunk)\n+            break;\n+        }\n+    } while (0);\n+\n+    if (pids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jarray, pids, 0);\n+    }\n+    if (ppids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jparentArray, ppids, 0);\n+    }\n+    if (stimes != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jstimesArray, stimes, 0);\n+    }\n+\n+    if (num == -1) {\n+      JNU_ThrowByNameWithLastError(env,\n+          \"java\/lang\/RuntimeException\", \"Unable to retrieve Process info\");\n+      return -1;\n+    }\n+\n+    \/\/ If more pids than array had size for; count will be greater than array size\n+    return count;\n","filename":"src\/java.base\/aix\/native\/libjava\/ProcessHandleImpl_aix.c","additions":120,"deletions":2,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-#if defined (__linux__) || defined(_AIX)\n+#if defined (__linux__)\n@@ -610,1 +610,1 @@\n-#endif \/\/ defined (__linux__) || defined(_AIX)\n+#endif \/\/ defined (__linux__)\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}