{"files":[{"patch":"@@ -1271,0 +1271,53 @@\n+bool LoadNode::has_reinterpret_variant(const Type* rt) {\n+  BasicType bt = rt->basic_type();\n+  switch (Opcode()) {\n+    case Op_LoadI: return (bt == T_FLOAT);\n+    case Op_LoadL: return (bt == T_DOUBLE);\n+    case Op_LoadF: return (bt == T_INT);\n+    case Op_LoadD: return (bt == T_LONG);\n+\n+    default: return false;\n+  }\n+}\n+\n+Node* LoadNode::convert_to_reinterpret_load(PhaseGVN& gvn, const Type* rt) {\n+  BasicType bt = rt->basic_type();\n+  assert(has_reinterpret_variant(rt), \"no reinterpret variant: %s %s\", Name(), type2name(bt));\n+  bool is_mismatched = is_mismatched_access();\n+  const TypeRawPtr* raw_type = gvn.type(in(MemNode::Memory))->isa_rawptr();\n+  if (raw_type == NULL) {\n+    is_mismatched = true; \/\/ conservatively match all non-raw accesses as mismatched\n+  }\n+  return LoadNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address),\n+                        raw_adr_type(), rt, bt, _mo, _control_dependency,\n+                        is_unaligned_access(), is_mismatched);\n+}\n+\n+bool StoreNode::has_reinterpret_variant(const Type* vt) {\n+  BasicType bt = vt->basic_type();\n+  switch (Opcode()) {\n+    case Op_StoreI: return (bt == T_FLOAT);\n+    case Op_StoreL: return (bt == T_DOUBLE);\n+    case Op_StoreF: return (bt == T_INT);\n+    case Op_StoreD: return (bt == T_LONG);\n+\n+    default: return false;\n+  }\n+}\n+\n+Node* StoreNode::convert_to_reinterpret_store(PhaseGVN& gvn, Node* val, const Type* vt) {\n+  BasicType bt = vt->basic_type();\n+  assert(has_reinterpret_variant(vt), \"no reinterpret variant: %s %s\", Name(), type2name(bt));\n+  StoreNode* st = StoreNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address), raw_adr_type(), val, bt, _mo);\n+\n+  bool is_mismatched = is_mismatched_access();\n+  const TypeRawPtr* raw_type = gvn.type(in(MemNode::Memory))->isa_rawptr();\n+  if (raw_type == NULL) {\n+    is_mismatched = true; \/\/ conservatively match all non-raw accesses as mismatched\n+  }\n+  if (is_mismatched) {\n+    st->set_mismatched_access();\n+  }\n+  return st;\n+}\n+\n@@ -2551,0 +2604,1 @@\n+  Node* value   = in(MemNode::ValueIn);\n@@ -2614,0 +2668,13 @@\n+  \/\/ Fold reinterpret cast into memory operation:\n+  \/\/    StoreX mem (MoveY2X v) => StoreY mem v\n+  if (value->is_Move()) {\n+    const Type* vt = value->in(1)->bottom_type();\n+    if (has_reinterpret_variant(vt)) {\n+      if (phase->C->post_loop_opts_phase()) {\n+        return convert_to_reinterpret_store(*phase, value->in(1), vt);\n+      } else {\n+        phase->C->record_for_post_loop_opts_igvn(this); \/\/ attempt the transformation once loop opts are over\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -285,0 +285,3 @@\n+  bool  has_reinterpret_variant(const Type* rt);\n+  Node* convert_to_reinterpret_load(PhaseGVN& gvn, const Type* rt);\n+\n@@ -637,0 +640,3 @@\n+  bool  has_reinterpret_variant(const Type* vt);\n+  Node* convert_to_reinterpret_store(PhaseGVN& gvn, Node* val, const Type* vt);\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -355,0 +355,30 @@\n+\/\/------------------------------MoveNode------------------------------------------\n+\n+Node* MoveNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (can_reshape) {\n+    \/\/ Fold reinterpret cast into memory operation:\n+    \/\/    MoveX2Y (LoadX mem) => LoadY mem\n+    LoadNode* ld = in(1)->isa_Load();\n+    if (ld != NULL && (ld->outcnt() == 1)) { \/\/ replace only\n+      const Type* rt = bottom_type();\n+      if (ld->has_reinterpret_variant(rt)) {\n+        if (phase->C->post_loop_opts_phase()) {\n+          return ld->convert_to_reinterpret_load(*phase, rt);\n+        } else {\n+          phase->C->record_for_post_loop_opts_igvn(this); \/\/ attempt the transformation once loop opts are over\n+        }\n+      }\n+    }\n+  }\n+  return NULL;\n+}\n+\n+Node* MoveNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->is_Move()) {\n+    \/\/ Back-to-back moves: MoveX2Y (MoveY2X v) => v\n+    assert(bottom_type() == in(1)->in(1)->bottom_type(), \"sanity\");\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -101,1 +101,12 @@\n-class MoveI2FNode : public Node {\n+class MoveNode : public Node {\n+  protected:\n+  MoveNode(Node* value) : Node(NULL, value) {\n+    init_class_id(Class_Move);\n+  }\n+\n+  public:\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n+\n+class MoveI2FNode : public MoveNode {\n@@ -103,1 +114,1 @@\n-  MoveI2FNode( Node *value ) : Node(0,value) {}\n+  MoveI2FNode(Node* value) : MoveNode(value) {}\n@@ -105,1 +116,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* bottom_type() const { return Type::FLOAT; }\n@@ -111,1 +122,1 @@\n-class MoveL2DNode : public Node {\n+class MoveL2DNode : public MoveNode {\n@@ -113,1 +124,1 @@\n-  MoveL2DNode( Node *value ) : Node(0,value) {}\n+  MoveL2DNode(Node* value) : MoveNode(value) {}\n@@ -115,1 +126,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* bottom_type() const { return Type::DOUBLE; }\n@@ -121,1 +132,1 @@\n-class MoveF2INode : public Node {\n+class MoveF2INode : public MoveNode {\n@@ -123,1 +134,1 @@\n-  MoveF2INode( Node *value ) : Node(0,value) {}\n+  MoveF2INode(Node* value) : MoveNode(value) {}\n@@ -125,1 +136,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n@@ -131,1 +142,1 @@\n-class MoveD2LNode : public Node {\n+class MoveD2LNode : public MoveNode {\n@@ -133,1 +144,1 @@\n-  MoveD2LNode( Node *value ) : Node(0,value) {}\n+  MoveD2LNode(Node* value) : MoveNode(value) {}\n@@ -135,1 +146,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+class MoveNode;\n@@ -724,2 +725,3 @@\n-    DEFINE_CLASS_ID(Halt, Node, 15)\n-    DEFINE_CLASS_ID(Opaque1, Node, 16)\n+    DEFINE_CLASS_ID(Halt,     Node, 15)\n+    DEFINE_CLASS_ID(Opaque1,  Node, 16)\n+    DEFINE_CLASS_ID(Move,     Node, 17)\n@@ -727,1 +729,1 @@\n-    _max_classes  = ClassMask_Opaque1\n+    _max_classes  = ClassMask_Move\n@@ -873,0 +875,1 @@\n+  DEFINE_CLASS_QUERY(Move)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}