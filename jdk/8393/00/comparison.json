{"files":[{"patch":"@@ -492,4 +492,0 @@\n-    public Iterable<? extends Tree> pathFor(CompilationUnitTree unit, Tree node) {\n-        return TreeInfo.pathFor((JCTree) node, (JCTree.JCCompilationUnit) unit).reverse();\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskImpl.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -796,38 +796,0 @@\n-    public static Env<AttrContext> scopeFor(JCTree node, JCCompilationUnit unit) {\n-        return scopeFor(pathFor(node, unit));\n-    }\n-\n-    public static Env<AttrContext> scopeFor(List<JCTree> path) {\n-        \/\/ TODO: not implemented yet\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-\n-    public static List<JCTree> pathFor(final JCTree node, final JCCompilationUnit unit) {\n-        class Result extends Error {\n-            static final long serialVersionUID = -5942088234594905625L;\n-            @SuppressWarnings(\"serial\") \/\/ List not statically Serilizable\n-            List<JCTree> path;\n-            Result(List<JCTree> path) {\n-                this.path = path;\n-            }\n-        }\n-        class PathFinder extends TreeScanner {\n-            List<JCTree> path = List.nil();\n-            public void scan(JCTree tree) {\n-                if (tree != null) {\n-                    path = path.prepend(tree);\n-                    if (tree == node)\n-                        throw new Result(path);\n-                    super.scan(tree);\n-                    path = path.tail;\n-                }\n-            }\n-        }\n-        try {\n-            new PathFinder().scan(unit);\n-        } catch (Result result) {\n-            return result.path;\n-        }\n-        return List.nil();\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"}]}