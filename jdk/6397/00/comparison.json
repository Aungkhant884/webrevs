{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Optional;\n@@ -66,0 +67,32 @@\n+    public enum Language {\n+\n+        JAVA(\"java\"),\n+        PROPERTIES(\"properties\");\n+\n+        private static final Map<String, Language> languages;\n+\n+        static {\n+            Map<String, Language> tmp = new HashMap<>();\n+            for (var language : values()) {\n+                String id = Objects.requireNonNull(language.identifier);\n+                if (tmp.put(id, language) != null)\n+                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n+            }\n+            languages = Map.copyOf(tmp);\n+        }\n+\n+        Language(String id) {\n+            identifier = id;\n+        }\n+\n+        private final String identifier;\n+\n+        public static Optional<Language> of(String identifier) {\n+            if (identifier == null)\n+                return Optional.empty();\n+            return Optional.ofNullable(languages.get(identifier));\n+        }\n+\n+        public String getIdentifier() {return identifier;}\n+    }\n+\n@@ -220,0 +253,13 @@\n+        String lang = null;\n+        AttributeTree langAttr = attributes.get(\"lang\");\n+        if (langAttr != null) {\n+            lang = stringValueOf(langAttr);\n+        } else if (containsClass) {\n+            lang = \"java\";\n+        } else if (containsFile) {\n+            lang = languageFromFileName(fileObject.getName());\n+        }\n+\n+        Optional<Language> language = Language.of(lang);\n+\n+\n@@ -227,1 +273,1 @@\n-                inlineSnippet = parse(writer.configuration().getDocResources(), inlineContent);\n+                inlineSnippet = parse(writer.configuration().getDocResources(), language, inlineContent);\n@@ -242,1 +288,1 @@\n-                externalSnippet = parse(writer.configuration().getDocResources(), externalContent);\n+                externalSnippet = parse(writer.configuration().getDocResources(), language, externalContent);\n@@ -292,9 +338,0 @@\n-        String lang = null;\n-        AttributeTree langAttr = attributes.get(\"lang\");\n-        if (langAttr != null) {\n-            lang = stringValueOf(langAttr);\n-        } else if (containsClass) {\n-            lang = \"java\";\n-        } else if (containsFile) {\n-            lang = languageFromFileName(fileObject.getName());\n-        }\n@@ -329,2 +366,2 @@\n-    private StyledText parse(Resources resources, String content) throws ParseException {\n-        Parser.Result result = new Parser(resources).parse(content);\n+    private StyledText parse(Resources resources, Optional<Language> language, String content) throws ParseException {\n+        Parser.Result result = new Parser(resources).parse(language, content);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":50,"deletions":13,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.taglets.SnippetTaglet;\n@@ -79,1 +80,2 @@\n-    \/\/ next-line tag behaves as if it were specified on the next line\n+    \/\/ Without this interface regular expressions that describe comments would have to\n+    \/\/ to be standardized or needlessly complex.\n@@ -81,2 +83,38 @@\n-    private String eolMarker;\n-    private Matcher markedUpLine;\n+    private interface CoarseParser {\n+        boolean parse(String line);\n+        int payloadEnd();\n+        int markupStart();\n+    }\n+\n+    private final class JavaCommentCoarseParser implements CoarseParser {\n+        private final Matcher m = Pattern.compile(\"^(.*)(\/\/(\\\\s*@\\\\s*\\\\w+.+?))$\").matcher(\"\");\n+\n+        @Override\n+        public boolean parse(String line) {return m.reset(line).matches();}\n+\n+        @Override\n+        public int payloadEnd() {return m.end(1);}\n+\n+        @Override\n+        public int markupStart() {return m.start(3);}\n+    }\n+\n+    private final class PropertiesCommentCoarseParser implements CoarseParser {\n+\n+        private final Matcher m = Pattern.compile(\"^([ \\t]*[#!](.*[#!])?)(\\\\s*@\\\\s*\\\\w+.+?)$\").matcher(\"\");\n+\n+        @Override\n+        public boolean parse(String line) {\n+            return m.reset(line).matches();\n+        }\n+\n+        @Override\n+        public int payloadEnd() {\n+            return m.start(3) - 1;\n+        }\n+\n+        @Override\n+        public int markupStart() {\n+            return m.start(3);\n+        }\n+    }\n@@ -96,2 +134,7 @@\n-    public Result parse(String source) throws ParseException {\n-        return parse(\"\/\/\", source);\n+    public Result parse(Optional<SnippetTaglet.Language> language, String source) throws ParseException {\n+        SnippetTaglet.Language lang = language.orElse(SnippetTaglet.Language.JAVA);\n+        var p = switch (lang) {\n+            case JAVA -> new JavaCommentCoarseParser();\n+            case PROPERTIES -> new PropertiesCommentCoarseParser();\n+        };\n+        return parse(p, source);\n@@ -103,2 +146,2 @@\n-    public Result parse(String eolMarker, String source) throws ParseException {\n-        Objects.requireNonNull(eolMarker);\n+    private Result parse(CoarseParser parser, String source) throws ParseException {\n+        Objects.requireNonNull(parser);\n@@ -106,16 +149,0 @@\n-        if (!Objects.equals(eolMarker, this.eolMarker)) {\n-            if (eolMarker.length() < 1) {\n-                throw new IllegalArgumentException();\n-            }\n-            for (int i = 0; i < eolMarker.length(); i++) {\n-                switch (eolMarker.charAt(i)) {\n-                    case '\\f', '\\n', '\\r' -> throw new IllegalArgumentException();\n-                }\n-            }\n-            this.eolMarker = eolMarker;\n-            \/\/ capture the rightmost eolMarker (e.g. \"\/\/\")\n-            \/\/ The below Pattern.compile should never throw PatternSyntaxException\n-            Pattern pattern = Pattern.compile(\"^(.*)(\" + Pattern.quote(eolMarker)\n-                    + \"(\\\\s*@\\\\s*\\\\w+.+?))$\");\n-            this.markedUpLine = pattern.matcher(\"\"); \/\/ reusable matcher\n-        }\n@@ -150,2 +177,1 @@\n-            markedUpLine.reset(rawLine);\n-            if (!markedUpLine.matches()) { \/\/ (1)\n+            if (!parser.parse(rawLine)) { \/\/ (1)\n@@ -154,1 +180,1 @@\n-                String maybeMarkup = markedUpLine.group(3);\n+                String maybeMarkup = rawLine.substring(parser.markupStart());\n@@ -160,1 +186,1 @@\n-                    throw new ParseException(e::getMessage, markedUpLine.start(3) + e.getPosition());\n+                    throw new ParseException(e::getMessage, parser.markupStart() + e.getPosition());\n@@ -164,1 +190,1 @@\n-                    t.markupLineOffset = markedUpLine.start(3);\n+                    t.markupLineOffset = parser.markupStart();\n@@ -179,1 +205,1 @@\n-                    String payload = markedUpLine.group(1);\n+                    String payload = rawLine.substring(0, parser.payloadEnd());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","additions":55,"deletions":29,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -108,0 +108,6 @@\n+    protected String getSnippetHtmlRepresentation(String pathToHtmlFile,\n+                                                  String content,\n+                                                  Optional<String> lang) {\n+        return getSnippetHtmlRepresentation(pathToHtmlFile, content, lang, Optional.empty());\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/SnippetTester.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import toolbox.ToolBox;\n+\n+\/*\n+ * @test\n+ * @bug 8266666\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestLangProperties\n+ *\/\n+public class TestLangProperties extends SnippetTester {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    private TestLangProperties() {}\n+\n+    public static void main(String... args) throws Exception {\n+        new TestLangProperties().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    @Test\n+    public void testPositiveOuterMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\")) {\n+                    String markup = whitespace1 + commentIndicator1\n+                            + whitespace2 + \"@highlight :\";\n+                    var t = new TestSnippetMarkup.TestCase(\n+                            \"\"\"\n+                                    %s\n+                                    coffee=espresso\n+                                    tea=black\n+                                    \"\"\".formatted(markup),\n+                            \"\"\"\n+\n+                                    <span class=\"bold\">coffee=espresso\n+                                    <\/span>tea=black\n+                                    \"\"\");\n+                    testCases.add(t);\n+                }\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveInnerMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\"))\n+                    for (String unrelatedComment : List.of(\"a comment\"))\n+                        for (String whitespace3 : List.of(\"\", \" \"))\n+                            for (String commentIndicator2 : List.of(\"#\", \"!\")) {\n+                                String payload = whitespace1 + commentIndicator1 + whitespace2 + unrelatedComment;\n+                                String markup = payload + whitespace3 + commentIndicator2 + \"@highlight :\";\n+                                var t = new TestSnippetMarkup.TestCase(\n+                                        \"\"\"\n+                                                %s\n+                                                coffee=espresso\n+                                                tea=black\n+                                                \"\"\".formatted(markup),\n+                                        \"\"\"\n+                                                %s\n+                                                <span class=\"bold\">coffee=espresso\n+                                                <\/span>tea=black\n+                                                \"\"\".formatted(payload));\n+                                testCases.add(t);\n+                            }\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveIneffectiveOuterMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\")) {\n+                    String ineffectiveMarkup = whitespace1\n+                            + commentIndicator1 + whitespace2\n+                            + \"@highlight :\";\n+                    var t = new TestSnippetMarkup.TestCase(\n+                            \"\"\"\n+                                    coffee=espresso%s\n+                                    tea=black\n+                                    \"\"\".formatted(ineffectiveMarkup),\n+                            \"\"\"\n+                                    coffee=espresso%s\n+                                    tea=black\n+                                    \"\"\".formatted(ineffectiveMarkup));\n+                    testCases.add(t);\n+                }\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveIneffectiveInnerMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\"))\n+                    for (String unrelatedComment : List.of(\"a comment\"))\n+                        for (String whitespace3 : List.of(\"\", \" \"))\n+                            for (String commentIndicator2 : List.of(\"#\", \"!\")) {\n+                                String ineffectiveMarkup = whitespace1\n+                                        + commentIndicator1 + whitespace2\n+                                        + unrelatedComment + whitespace3\n+                                        + commentIndicator2 + \"@highlight :\";\n+                                var t = new TestSnippetMarkup.TestCase(\n+                                        \"\"\"\n+                                                coffee=espresso%s\n+                                                tea=black\n+                                                \"\"\".formatted(ineffectiveMarkup),\n+                                        \"\"\"\n+                                                coffee=espresso%s\n+                                                tea=black\n+                                                \"\"\".formatted(ineffectiveMarkup));\n+                                testCases.add(t);\n+                            }\n+        testPositive(base, testCases);\n+    }\n+\n+    private void testPositive(Path base, List<TestSnippetMarkup.TestCase> testCases)\n+            throws IOException {\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(testCases, (i, n) -> {\n+            String r = i.region().isBlank() ? \"\" : \"region=\" + i.region();\n+            var methodDef = \"\"\"\n+\n+                    \/**\n+                    {@snippet lang=\"properties\" %s:\n+                    %s}*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(r, i.input(), n);\n+            methods.append(methodDef);\n+        });\n+        var classDef = \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classDef);\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.OK);\n+        checkNoCrashes();\n+        forEachNumbered(testCases, (t, index) -> {\n+            String html = \"\"\"\n+                    <span class=\"element-name\">case%s<\/span>()<\/div>\n+                    <div class=\"block\">\n+                    %s\n+                    <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\",\n+                    t.expectedOutput(), Optional.of(\"properties\")));\n+            checkOutput(\"A.html\", true, html);\n+        });\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestLangProperties.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -376,0 +376,3 @@\n+    \/\/ @replace on a blank line will not do anything bad!\n+\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetMarkup.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}