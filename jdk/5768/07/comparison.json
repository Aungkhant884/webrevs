{"files":[{"patch":"@@ -1131,4 +1131,0 @@\n-  if (mapinfo->header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    mapinfo->set_header_base_archive_name_size(strlen(Arguments::GetSharedArchivePath()) + 1);\n-    mapinfo->set_header_base_archive_is_default(FLAG_IS_DEFAULT(SharedArchiveFile));\n-  }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,9 +34,11 @@\n-  { \"CDSFileMapHeaderBase::_magic\",           offset_of(CDSFileMapHeaderBase, _magic)           },\n-  { \"CDSFileMapHeaderBase::_crc\",             offset_of(CDSFileMapHeaderBase, _crc)             },\n-  { \"CDSFileMapHeaderBase::_version\",         offset_of(CDSFileMapHeaderBase, _version)         },\n-  { \"CDSFileMapHeaderBase::_space[0]\",        offset_of(CDSFileMapHeaderBase, _space)           },\n-  { \"FileMapHeader::_jvm_ident\",              offset_of(FileMapHeader, _jvm_ident)              },\n-  { \"FileMapHeader::_base_archive_name_size\", offset_of(FileMapHeader, _base_archive_name_size) },\n-  { \"CDSFileMapRegion::_crc\",                 offset_of(CDSFileMapRegion, _crc)                 },\n-  { \"CDSFileMapRegion::_used\",                offset_of(CDSFileMapRegion, _used)                },\n-  { \"DynamicArchiveHeader::_base_region_crc\", offset_of(DynamicArchiveHeader, _base_region_crc) }\n+  { \"GenericCDSFileMapHeader::_magic\",                     offset_of(GenericCDSFileMapHeader, _magic)          },\n+  { \"GenericCDSFileMapHeader::_crc\",                       offset_of(GenericCDSFileMapHeader, _crc)            },\n+  { \"GenericCDSFileMapHeader::_version\",                   offset_of(GenericCDSFileMapHeader, _version)        },\n+  { \"GenericCDSFileMapHeader::_header_size\",               offset_of(GenericCDSFileMapHeader, _header_size)    },\n+  { \"GenericCDSFileMapHeader::_base_archive_path_offset\",  offset_of(GenericCDSFileMapHeader, _base_archive_path_offset) },\n+  { \"GenericCDSFileMapHeader::_base_archive_name_size\",    offset_of(GenericCDSFileMapHeader, _base_archive_name_size)   },\n+  { \"CDSFileMapHeaderBase::_space[0]\",                     offset_of(CDSFileMapHeaderBase, _space)             },\n+  { \"FileMapHeader::_jvm_ident\",                           offset_of(FileMapHeader, _jvm_ident)                },\n+  { \"CDSFileMapRegion::_crc\",                              offset_of(CDSFileMapRegion, _crc)                   },\n+  { \"CDSFileMapRegion::_used\",                             offset_of(CDSFileMapRegion, _used)                  },\n+  { \"DynamicArchiveHeader::_base_region_crc\",              offset_of(DynamicArchiveHeader, _base_region_crc)   }\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -183,0 +183,3 @@\n+  FileMapInfo* base_info = FileMapInfo::current_info();\n+  \/\/ header only be available after populate_header\n+  mapinfo->populate_header(base_info->core_region_alignment());\n@@ -185,1 +188,0 @@\n-  FileMapInfo* base_info = FileMapInfo::current_info();\n@@ -190,1 +192,0 @@\n-  _header->populate(base_info, base_info->core_region_alignment());\n@@ -328,1 +329,1 @@\n-                         \" [\" SIZE_FORMAT \" bytes header, \" SIZE_FORMAT \" bytes total]\",\n+                         \" [\" UINT32_FORMAT \" bytes header, \" SIZE_FORMAT \" bytes total]\",\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -172,2 +173,1 @@\n-  size_t header_size;\n-  if (is_static) {\n+  if (_is_static) {\n@@ -176,1 +176,0 @@\n-    header_size = sizeof(FileMapHeader);\n@@ -180,1 +179,0 @@\n-    header_size = sizeof(DynamicArchiveHeader);\n@@ -182,5 +180,0 @@\n-  _header = (FileMapHeader*)os::malloc(header_size, mtInternal);\n-  memset((void*)_header, 0, header_size);\n-  _header->set_header_size(header_size);\n-  _header->set_version(INVALID_CDS_ARCHIVE_VERSION);\n-  _header->set_has_platform_or_app_classes(true);\n@@ -202,6 +195,8 @@\n-  header()->populate(this, core_region_alignment);\n-}\n-\n-void FileMapHeader::populate(FileMapInfo* mapinfo, size_t core_region_alignment) {\n-  if (DynamicDumpSharedSpaces) {\n-    _magic = CDS_DYNAMIC_ARCHIVE_MAGIC;\n+  assert(_header == NULL, \"Sanity check\");\n+  size_t c_header_size;\n+  size_t header_size;\n+  size_t base_archive_name_size = 0;\n+  size_t base_archive_path_offset = 0;\n+  if (is_static()) {\n+    c_header_size = sizeof(FileMapHeader);\n+    header_size = c_header_size;\n@@ -209,1 +204,33 @@\n-    _magic = CDS_ARCHIVE_MAGIC;\n+    \/\/ dynamic header including base archive name for non-default base archive\n+    c_header_size = sizeof(DynamicArchiveHeader);\n+    header_size = c_header_size;\n+    if (!FLAG_IS_DEFAULT(SharedArchiveFile)) {\n+      base_archive_name_size = strlen(Arguments::GetSharedArchivePath()) + 1;\n+      header_size += base_archive_name_size;\n+      base_archive_path_offset = c_header_size;\n+    }\n+  }\n+  _header = (FileMapHeader*)os::malloc(header_size, mtInternal);\n+  memset((void*)_header, 0, header_size);\n+  _header->populate(this,\n+                    core_region_alignment,\n+                    header_size,\n+                    base_archive_name_size,\n+                    base_archive_path_offset);\n+}\n+\n+void FileMapHeader::populate(FileMapInfo *info, size_t core_region_alignment,\n+                             size_t header_size, size_t base_archive_name_size,\n+                             size_t base_archive_path_offset) {\n+  \/\/ 1. We require _generic_header._magic to be at the beginning of the file\n+  \/\/ 2. FileMapHeader also assumes that _generic_header is at the beginning of the file\n+  assert(offset_of(FileMapHeader, _generic_header) == 0, \"must be\");\n+  set_header_size((unsigned int)header_size);\n+  set_base_archive_path_offset((unsigned int)base_archive_path_offset);\n+  set_base_archive_name_size((unsigned int)base_archive_name_size);\n+  set_magic(DynamicDumpSharedSpaces ? CDS_DYNAMIC_ARCHIVE_MAGIC : CDS_ARCHIVE_MAGIC);\n+  set_version(CURRENT_CDS_ARCHIVE_VERSION);\n+\n+  if (!info->is_static() && base_archive_name_size != 0) {\n+    \/\/ copy base archive name\n+    copy_base_archive_name(Arguments::GetSharedArchivePath());\n@@ -211,1 +238,0 @@\n-  _version = CURRENT_CDS_ARCHIVE_VERSION;\n@@ -248,3 +274,0 @@\n-  \/\/ the following 2 fields will be set in write_header for dynamic archive header\n-  _base_archive_name_size = 0;\n-  _base_archive_is_default = false;\n@@ -253,1 +276,1 @@\n-    set_shared_path_table(mapinfo->_shared_path_table);\n+    set_shared_path_table(info->_shared_path_table);\n@@ -258,0 +281,7 @@\n+void FileMapHeader::copy_base_archive_name(const char* archive) {\n+  assert(base_archive_name_size() != 0, \"_base_archive_name_size not set\");\n+  assert(base_archive_path_offset() != 0, \"_base_archive_path_offset not set\");\n+  assert(header_size() > sizeof(*this), \"_base_archive_name_size not included in header size?\");\n+  memcpy((char*)this + base_archive_path_offset(), archive, base_archive_name_size());\n+}\n+\n@@ -261,3 +291,6 @@\n-  st->print_cr(\"- magic:                          0x%08x\", _magic);\n-  st->print_cr(\"- crc:                            0x%08x\", _crc);\n-  st->print_cr(\"- version:                        %d\", _version);\n+  st->print_cr(\"- magic:                          0x%08x\", magic());\n+  st->print_cr(\"- crc:                            0x%08x\", crc());\n+  st->print_cr(\"- version:                        %d\", version());\n+  st->print_cr(\"- header_size:                    \" UINT32_FORMAT, header_size());\n+  st->print_cr(\"- base_archive_path_offset:       \" UINT32_FORMAT, base_archive_path_offset());\n+  st->print_cr(\"- base_archive_name_size:         \" UINT32_FORMAT, base_archive_name_size());\n@@ -271,1 +304,0 @@\n-  st->print_cr(\"- header_size:                    \" SIZE_FORMAT, _header_size);\n@@ -286,1 +318,0 @@\n-  st->print_cr(\"- base_archive_is_default:        %d\", _base_archive_is_default);\n@@ -288,1 +319,0 @@\n-  st->print_cr(\"- base_archive_name_size:         \" SIZE_FORMAT, _base_archive_name_size);\n@@ -1015,0 +1045,62 @@\n+\/\/ a utility class for checking file header\n+class FileHeaderHelper {\n+  int _fd;\n+  GenericCDSFileMapHeader _header;\n+\n+public:\n+  FileHeaderHelper() {\n+    _fd = -1;\n+  }\n+\n+  ~FileHeaderHelper() {\n+    if (_fd != -1) {\n+      os::close(_fd);\n+    }\n+  }\n+\n+  bool initialize(const char* archive_name) {\n+    _fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n+    if (_fd < 0) {\n+      return false;\n+    }\n+    return initialize(_fd);\n+  }\n+\n+  \/\/ for an already opened file, do not set _fd\n+  bool initialize(int fd) {\n+    assert(fd != -1, \"Archive should be opened\");\n+    size_t size = sizeof(GenericCDSFileMapHeader);\n+    lseek(fd, 0, SEEK_SET);\n+    size_t n = os::read(fd, (void*)&_header, (unsigned int)size);\n+    if (n != size) {\n+      vm_exit_during_initialization(\"Unable to read generic CDS file map header from shared archive\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  GenericCDSFileMapHeader* get_generic_file_header() {\n+    return &_header;\n+  }\n+\n+  bool read_base_archive_name(char** target) {\n+    assert(_fd != -1, \"Archive should be open\");\n+    size_t name_size = (size_t)_header._base_archive_name_size;\n+    assert(name_size != 0, \"For non-default base archive, name size should be non-zero!\");\n+    *target = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n+    lseek(_fd, _header._base_archive_path_offset, SEEK_SET); \/\/ position to correct offset.\n+    size_t n = os::read(_fd, *target, (unsigned int)name_size);\n+    if (n != name_size) {\n+      log_info(cds)(\"Unable to read base archive name from archive\");\n+      FREE_C_HEAP_ARRAY(char, *target);\n+      return false;\n+    }\n+    if (!os::file_exists(*target)) {\n+      log_info(cds)(\"Base archive %s does not exist\", *target);\n+      FREE_C_HEAP_ARRAY(char, *target);\n+      return false;\n+    }\n+    return true;\n+  }\n+};\n+\n@@ -1016,2 +1108,2 @@\n-  int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n-  if (fd < 0) {\n+  FileHeaderHelper file_helper;\n+  if (!file_helper.initialize(archive_name)) {\n@@ -1024,10 +1116,1 @@\n-  size_t sz = is_static ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);\n-  void* header = os::malloc(sz, mtInternal);\n-  memset(header, 0, sz);\n-  size_t n = os::read(fd, header, (unsigned int)sz);\n-  if (n != sz) {\n-    os::free(header);\n-    os::close(fd);\n-    vm_exit_during_initialization(\"Unable to read header from shared archive\", archive_name);\n-    return false;\n-  }\n+  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n@@ -1035,4 +1118,1 @@\n-    FileMapHeader* static_header = (FileMapHeader*)header;\n-    if (static_header->magic() != CDS_ARCHIVE_MAGIC) {\n-      os::free(header);\n-      os::close(fd);\n+    if (header->_magic != CDS_ARCHIVE_MAGIC) {\n@@ -1042,0 +1122,5 @@\n+    if (header->_base_archive_path_offset != 0) {\n+      log_info(cds)(\"_base_archive_path_offset should be 0\");\n+      log_info(cds)(\"_base_archive_path_offset = \" UINT32_FORMAT, header->_base_archive_path_offset);\n+      return false;\n+    }\n@@ -1043,4 +1128,1 @@\n-    DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)header;\n-    if (dynamic_header->magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-      os::free(header);\n-      os::close(fd);\n+    if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n@@ -1050,0 +1132,15 @@\n+    unsigned int name_size = header->_base_archive_name_size;\n+    unsigned int path_offset = header->_base_archive_path_offset;\n+    unsigned int header_size = header->_header_size;\n+    if (path_offset + name_size != header_size) {\n+      log_info(cds)(\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\");\n+      log_info(cds)(\"  _base_archive_name_size   = \" UINT32_FORMAT, name_size);\n+      log_info(cds)(\"  _base_archive_path_offset = \" UINT32_FORMAT, path_offset);\n+      log_info(cds)(\"  _header_size              = \" UINT32_FORMAT, header_size);\n+      return false;\n+    }\n+    char* base_name = NULL;\n+    if (!file_helper.read_base_archive_name(&base_name)) {\n+      return false;\n+    }\n+    FREE_C_HEAP_ARRAY(char, base_name);\n@@ -1051,2 +1148,0 @@\n-  os::free(header);\n-  os::close(fd);\n@@ -1057,4 +1152,3 @@\n-                                                    int* size, char** base_archive_name) {\n-  int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n-  if (fd < 0) {\n-    *size = 0;\n+                                                    char** base_archive_name) {\n+  FileHeaderHelper file_helper;\n+  if (!file_helper.initialize(archive_name)) {\n@@ -1063,9 +1157,3 @@\n-\n-  \/\/ read the header as a dynamic archive header\n-  size_t sz = sizeof(DynamicArchiveHeader);\n-  DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)os::malloc(sz, mtInternal);\n-  size_t n = os::read(fd, dynamic_header, (unsigned int)sz);\n-  if (n != sz) {\n-    fail_continue(\"Unable to read the file header.\");\n-    os::free(dynamic_header);\n-    os::close(fd);\n+  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n+  if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    \/\/ Not a dynamic header, no need to proceed further.\n@@ -1074,5 +1162,4 @@\n-  if (dynamic_header->magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    \/\/ Not a dynamic header, no need to proceed further.\n-    *size = 0;\n-    os::free(dynamic_header);\n-    os::close(fd);\n+\n+  if ((header->_base_archive_name_size == 0 && header->_base_archive_path_offset != 0) ||\n+      (header->_base_archive_name_size != 0 && header->_base_archive_path_offset == 0)) {\n+    fail_continue(\"Default base archive not set correct\");\n@@ -1081,1 +1168,2 @@\n-  if (dynamic_header->base_archive_is_default()) {\n+  if (header->_base_archive_name_size == 0 &&\n+      header->_base_archive_path_offset == 0) {\n@@ -1085,11 +1173,1 @@\n-    size_t name_size = dynamic_header->base_archive_name_size();\n-    if (name_size == 0) {\n-      os::free(dynamic_header);\n-      os::close(fd);\n-      return false;\n-    }\n-    *base_archive_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n-    n = os::read(fd, *base_archive_name, (unsigned int)name_size);\n-    if (n != name_size) {\n-      fail_continue(\"Unable to read the base archive name from the header.\");\n-      FREE_C_HEAP_ARRAY(char, *base_archive_name);\n+    if (!file_helper.read_base_archive_name(base_archive_name)) {\n@@ -1097,2 +1175,0 @@\n-      os::free(dynamic_header);\n-      os::close(fd);\n@@ -1102,3 +1178,0 @@\n-\n-  os::free(dynamic_header);\n-  os::close(fd);\n@@ -1111,3 +1184,2 @@\n-  size_t sz = is_static() ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);\n-  size_t n = os::read(fd, header(), (unsigned int)sz);\n-  if (n != sz) {\n+  FileHeaderHelper file_helper;\n+  if (!file_helper.initialize(fd)) {\n@@ -1117,5 +1189,1 @@\n-\n-  if (!Arguments::has_jimage()) {\n-    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n-    return false;\n-  }\n+  GenericCDSFileMapHeader* gen_header = file_helper.get_generic_file_header();\n@@ -1124,1 +1192,1 @@\n-  if (header()->magic() != expected_magic) {\n+  if (gen_header->_magic != expected_magic) {\n@@ -1126,1 +1194,1 @@\n-    log_info(cds)(\"         actual: 0x%08x\", header()->magic());\n+    log_info(cds)(\"         actual: 0x%08x\", gen_header->_magic);\n@@ -1131,0 +1199,9 @@\n+  _header = (FileMapHeader*)os::malloc(gen_header->_header_size, mtInternal);\n+  lseek(fd, 0, SEEK_SET); \/\/ reset to begin of the archive\n+  size_t size = gen_header->_header_size;\n+  size_t n = os::read(fd, (void*)_header, (unsigned int)size);\n+  if (n != size) {\n+    fail_continue(\"Failed to read file header from the top archive file\\n\");\n+    return false;\n+  }\n+\n@@ -1138,5 +1215,11 @@\n-  if (header()->header_size() != sz) {\n-    log_info(cds)(\"_header_size expected: \" SIZE_FORMAT, sz);\n-    log_info(cds)(\"               actual: \" SIZE_FORMAT, header()->header_size());\n-    FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n-    return false;\n+  unsigned int base_offset = header()->base_archive_path_offset();\n+  unsigned int name_size = header()->base_archive_name_size();\n+  unsigned int header_size = header()->header_size();\n+  if (base_offset != 0 && name_size != 0) {\n+    if (header_size != base_offset + name_size) {\n+      log_info(cds)(\"_header_size: \" UINT32_FORMAT, header_size);\n+      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, name_size);\n+      log_info(cds)(\"base_archive_path_offset: \" UINT32_FORMAT, base_offset);\n+      FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n+      return false;\n+    }\n@@ -1172,1 +1255,1 @@\n-  _file_offset = n + header()->base_archive_name_size(); \/\/ accounts for the size of _base_archive_name\n+  _file_offset = header()->header_size(); \/\/ accounts for the size of _base_archive_name\n@@ -1256,3 +1339,0 @@\n-  if (header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    header_bytes += strlen(Arguments::GetSharedArchivePath()) + 1;\n-  }\n@@ -1265,1 +1345,0 @@\n-\n@@ -1273,7 +1352,0 @@\n-\n-  if (header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    char* base_archive_name = (char*)Arguments::GetSharedArchivePath();\n-    if (base_archive_name != NULL) {\n-      write_bytes(base_archive_name, header()->base_archive_name_size());\n-    }\n-  }\n@@ -2223,0 +2295,5 @@\n+  if (!Arguments::has_jimage()) {\n+    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n+    return false;\n+  }\n+\n@@ -2261,3 +2338,3 @@\n-  \/\/ start computing from the field after _crc\n-  char* buf = (char*)&_crc + sizeof(_crc);\n-  size_t sz = _header_size - (buf - start);\n+  \/\/ start computing from the field after _crc to end of base archive name.\n+  char* buf = (char*)&(_generic_header._crc) + sizeof(_generic_header._crc);\n+  size_t sz = header_size() - (buf - start);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":191,"deletions":114,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -187,2 +187,0 @@\n-  size_t _header_size;\n-\n@@ -206,1 +204,0 @@\n-  bool _base_archive_is_default;    \/\/ indicates if the base archive is the system default one\n@@ -213,2 +210,0 @@\n-  \/\/ size of the base archive name including NULL terminator\n-  size_t _base_archive_name_size;\n@@ -246,9 +241,14 @@\n-  \/\/ Accessors -- fields declared in CDSFileMapHeaderBase\n-  unsigned int magic()                    const { return _magic; }\n-  int crc()                               const { return _crc; }\n-  int version()                           const { return _version; }\n-\n-  void set_crc(int crc_value)                   { _crc = crc_value; }\n-  void set_version(int v)                       { _version = v; }\n-\n-  \/\/ Accessors -- fields declared in FileMapHeader\n+  \/\/ Accessors -- fields declared in GenericCDSFileMapHeader\n+  unsigned int magic()                    const { return _generic_header._magic;    }\n+  int crc()                               const { return _generic_header._crc;      }\n+  int version()                           const { return _generic_header._version;  }\n+  unsigned int header_size()              const { return _generic_header._header_size;              }\n+  unsigned int base_archive_path_offset() const { return _generic_header._base_archive_path_offset; }\n+  unsigned int base_archive_name_size()   const { return _generic_header._base_archive_name_size;   }\n+\n+  void set_magic(unsigned int m)                    { _generic_header._magic = m;       }\n+  void set_crc(int crc_value)                       { _generic_header._crc = crc_value; }\n+  void set_version(int v)                           { _generic_header._version = v;     }\n+  void set_header_size(unsigned int s)              { _generic_header._header_size = s;              }\n+  void set_base_archive_path_offset(unsigned int s) { _generic_header._base_archive_path_offset = s; }\n+  void set_base_archive_name_size(unsigned int s)   { _generic_header._base_archive_name_size = s;   }\n@@ -256,1 +256,0 @@\n-  size_t header_size()                     const { return _header_size; }\n@@ -270,1 +269,0 @@\n-  bool base_archive_is_default()           const { return _base_archive_is_default; }\n@@ -272,1 +270,0 @@\n-  size_t base_archive_name_size()          const { return _base_archive_name_size; }\n@@ -290,3 +287,0 @@\n-  void set_base_archive_name_size(size_t s)      { _base_archive_name_size = s; }\n-  void set_base_archive_is_default(bool b)       { _base_archive_is_default = b; }\n-  void set_header_size(size_t s)                 { _header_size = s; }\n@@ -296,0 +290,1 @@\n+  void copy_base_archive_name(const char* name);\n@@ -320,2 +315,2 @@\n-  void populate(FileMapInfo* info, size_t core_region_alignment);\n-\n+  void populate(FileMapInfo *info, size_t core_region_alignment, size_t header_size,\n+                size_t base_archive_name_size, size_t base_archive_path_offset);\n@@ -366,1 +361,1 @@\n-                                                int* size, char** base_archive_name);\n+                                                char** base_archive_name);\n@@ -401,3 +396,0 @@\n-  void   set_header_base_archive_name_size(size_t size)      { header()->set_base_archive_name_size(size); }\n-  void   set_header_base_archive_is_default(bool is_default) { header()->set_base_archive_is_default(is_default); }\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 11\n-#define INVALID_CDS_ARCHIVE_VERSION -1\n+#define CURRENT_CDS_ARCHIVE_VERSION 12\n@@ -44,1 +43,1 @@\n-struct CDSFileMapRegion {\n+typedef struct CDSFileMapRegion {\n@@ -61,1 +60,1 @@\n-};\n+} CDSFileMapRegion;\n@@ -63,6 +62,21 @@\n-struct CDSFileMapHeaderBase {\n-  unsigned int _magic;           \/\/ identify file type\n-  int          _crc;             \/\/ header crc checksum\n-  int          _version;         \/\/ must be CURRENT_CDS_ARCHIVE_VERSION\n-  struct CDSFileMapRegion _space[NUM_CDS_REGIONS];\n-};\n+\/\/ This portion of the archive file header must remain unchanged for _version >= 12.\n+\/\/ This makes it possible to read important information from a CDS archive created by\n+\/\/ a different version of HotSpot, so that we can automatically regenerate the archive as necessary.\n+typedef struct GenericCDSFileMapHeader {\n+  unsigned int _magic;                    \/\/ identification of file type\n+  int          _crc;                      \/\/ header crc checksum\n+  int          _version;                  \/\/ CURRENT_CDS_ARCHIVE_VERSION of the jdk that dumped the this archive\n+  unsigned int _header_size;              \/\/ total size of the header, in bytes\n+  unsigned int _base_archive_path_offset; \/\/ offset where the base archive name is stored\n+                                          \/\/   static archive:  0\n+                                          \/\/   dynamic archive:\n+                                          \/\/     0 for default base archive\n+                                          \/\/     non-zero for non-default base archive\n+                                          \/\/       (char*)this + _base_archive_path_offset\n+                                          \/\/       points to a 0-terminated string for the base archive name\n+  unsigned int _base_archive_name_size;   \/\/ size of base archive name including ending '\\0'\n+                                          \/\/   static:  0\n+                                          \/\/   dynamic:\n+                                          \/\/     0 for default base archive\n+                                          \/\/     non-zero for non-default base archive\n+} GenericCDSFileMapHeader;\n@@ -70,1 +84,8 @@\n-typedef struct CDSFileMapHeaderBase CDSFileMapHeaderBase;\n+\/\/ This type is used by the Serviceability Agent to access the contents of\n+\/\/ a memory-mapped CDS archive.\n+typedef struct CDSFileMapHeaderBase {\n+  \/\/ We cannot inherit from GenericCDSFileMapHeader as this type may be used\n+  \/\/ by both C and C++ code.\n+  GenericCDSFileMapHeader _generic_header;\n+  CDSFileMapRegion _space[NUM_CDS_REGIONS];\n+} CDSFileMapHeaderBase;\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -3534,1 +3534,0 @@\n-        int name_size;\n@@ -3536,1 +3535,1 @@\n-          FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &name_size, &SharedArchivePath);\n+          FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &SharedArchivePath);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -359,3 +359,4 @@\n-      memset(&header, 0, sizeof(CDSFileMapHeaderBase));\n-      if ((n = read(fd, &header, sizeof(CDSFileMapHeaderBase)))\n-           != sizeof(CDSFileMapHeaderBase)) {\n+      size_t header_size = sizeof(CDSFileMapHeaderBase);\n+      memset(&header, 0, header_size);\n+      if ((n = read(fd, &header, header_size))\n+           != header_size) {\n@@ -368,1 +369,1 @@\n-      if (header._magic != CDS_ARCHIVE_MAGIC) {\n+      if (header._generic_header._magic != CDS_ARCHIVE_MAGIC) {\n@@ -370,1 +371,1 @@\n-                    classes_jsa, header._magic, CDS_ARCHIVE_MAGIC);\n+                    classes_jsa, header._generic_header._magic, CDS_ARCHIVE_MAGIC);\n@@ -376,1 +377,1 @@\n-      if (header._version != CURRENT_CDS_ARCHIVE_VERSION) {\n+      if (header._generic_header._version != CURRENT_CDS_ARCHIVE_VERSION) {\n@@ -378,1 +379,1 @@\n-                     classes_jsa, header._version, CURRENT_CDS_ARCHIVE_VERSION);\n+                     classes_jsa, header._generic_header._version, CURRENT_CDS_ARCHIVE_VERSION);\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/ps_core_common.c","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+        \"UseSharedSpaces: Header checksum verification failed.\",\n+        \"The shared archive file has an incorrect header size.\",\n@@ -161,1 +163,1 @@\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic, -1);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic(), -1);\n@@ -173,1 +175,1 @@\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion, 0x00000000);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0x00000000);\n@@ -216,0 +218,1 @@\n+        \/\/ modify contents in random area\n@@ -221,0 +224,11 @@\n+\n+        \/\/ modify _base_archive_path_offet to non-zero\n+        System.out.println(\"\\n8. modify _base_archive_path_offset to non-zero\\n\");\n+        String baseArchivePathOffsetName = startNewArchive(\"base-arhive-path-offset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, baseArchivePathOffsetName);\n+        int baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        System.out.println(\"    baseArchivePathOffset = \" + baseArchivePathOffset);\n+        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetBaseArchivePathOffset(), 1024);\n+        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        System.out.println(\"new baseArchivePathOffset = \" + baseArchivePathOffset);\n+        testAndCheck(verifyExecArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -55,0 +56,25 @@\n+    static void runTwo(String base, String top,\n+                       String jarName, String mainClassName, int exitValue,\n+                       String ... checkMessages) throws Exception {\n+        CDSTestUtils.Result result = run2(base, top,\n+                \"-Xlog:cds\",\n+                \"-Xlog:cds+dynamic=debug\",\n+                \"-XX:+VerifySharedSpaces\",\n+                \"-cp\",\n+                jarName,\n+                mainClassName);\n+        if (exitValue == 0) {\n+            result.assertNormalExit( output -> {\n+                for (String s : checkMessages) {\n+                    output.shouldContain(s);\n+                }\n+            });\n+        } else {\n+            result.assertAbnormalExit( output -> {\n+                for (String s : checkMessages) {\n+                    output.shouldContain(s);\n+                }\n+            });\n+        }\n+    }\n+\n@@ -71,1 +97,2 @@\n-        \/\/ Modify the CRC values in the header of the top archive.\n+        \/\/ 1. Modify the CRC values in the header of the top archive.\n+        System.out.println(\"\\n1. Modify the CRC values in the header of the top archive\");\n@@ -76,10 +103,55 @@\n-        run2(baseArchiveName, modTop,\n-            \"-Xlog:class+load\",\n-            \"-Xlog:cds+dynamic=debug,cds=debug\",\n-            \"-XX:+VerifySharedSpaces\",\n-            \"-cp\", appJar, mainClass)\n-            .assertAbnormalExit(output -> {\n-                    output.shouldContain(\"Header checksum verification failed\")\n-                          .shouldContain(\"Unable to use shared archive\")\n-                          .shouldHaveExitValue(1);\n-                });\n+        runTwo(baseArchiveName, modTop,\n+               appJar, mainClass, 1,\n+               new String[] {\"Header checksum verification failed\",\n+                             \"Unable to use shared archive\"});\n+\n+        \/\/ 2. Make header size larger than the archive size\n+        System.out.println(\"\\n2. Make header size larger than the archive size\");\n+        String largerHeaderSize = getNewArchiveName(\"largerHeaderSize\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, largerHeaderSize);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetHeaderSize(),  (int)copiedJsa.length() + 1024);\n+        runTwo(baseArchiveName, largerHeaderSize,\n+               appJar, mainClass, 1,\n+               new String[] {\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\",\n+                             \"Unable to use shared archive\"});\n+\n+        \/\/ 3. Make base archive path offset beyond of header size\n+        System.out.println(\"\\n3. Make base archive path offset beyond of header size.\");\n+        String wrongBaseArchivePathOffset = getNewArchiveName(\"wrongBaseArchivePathOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseArchivePathOffset);\n+        int fileHeaderSize = (int)CDSArchiveUtils.fileHeaderSize(copiedJsa);\n+        int baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetBaseArchivePathOffset(), baseArchivePathOffset + 1024);\n+        runTwo(baseArchiveName, wrongBaseArchivePathOffset,\n+               appJar, mainClass, 1,\n+               new String[] {\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\",\n+                             \"The shared archive file has an incorrect header size\",\n+                             \"Unable to use shared archive\"});\n+\n+        \/\/ 4. Make base archive path offset points to middle of name size\n+        System.out.println(\"\\n4. Make base archive path offset points to middle of name size\");\n+        String wrongBasePathOffset = getNewArchiveName(\"wrongBasePathOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBasePathOffset);\n+        int baseArchiveNameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n+        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, baseArchivePathOffset,\n+                                             baseArchivePathOffset + baseArchiveNameSize\/2);\n+        runTwo(baseArchiveName, wrongBasePathOffset,\n+               appJar, mainClass, 1,\n+               new String[] {\"An error has occurred while processing the shared archive file.\",\n+                             \"Header checksum verification failed\",\n+                             \"Unable to use shared archive\"});\n+        \/\/ 5. Make base archive name not terminated with '\\0'\n+        System.out.println(\"\\n5. Make base archive name not terminated with '\\0'\");\n+        String wrongBaseName = getNewArchiveName(\"wrongBaseName\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseName);\n+        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        baseArchiveNameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n+        long offset = baseArchivePathOffset + baseArchiveNameSize - 1;  \/\/ end of line\n+        CDSArchiveUtils.writeData(copiedJsa, offset, new byte[] {(byte)'X'});\n+\n+        runTwo(baseArchiveName, wrongBaseName,\n+               appJar, mainClass, 1,\n+               new String[] {\"Base archive \" + baseArchiveName,\n+                             \" does not exist\",\n+                             \"Header checksum verification failed\"});\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":83,"deletions":11,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -49,7 +49,10 @@\n-    public static int offsetMagic;                \/\/ CDSFileMapHeaderBase::_magic\n-    public static int offsetVersion;              \/\/ CDSFileMapHeaderBase::_version\n-    public static int offsetJvmIdent;             \/\/ FileMapHeader::_jvm_ident\n-    public static int offsetBaseArchiveNameSize;  \/\/ FileMapHeader::_base_archive_name_size\n-    public static int spOffsetCrc;                \/\/ CDSFileMapRegion::_crc\n-    public static int spOffset;                   \/\/ offset of CDSFileMapRegion\n-    public static int spUsedOffset;               \/\/ offset of CDSFileMapRegion::_used\n+    private static int offsetMagic;                \/\/ offset of GenericCDSFileMapHeader::_magic\n+    private static int offsetCrc;                  \/\/ offset of GenericCDSFileMapHeader::_crc\n+    private static int offsetVersion;              \/\/ offset of GenericCDSFileMapHeader::_version\n+    private static int offsetHeaderSize;           \/\/ offset of GenericCDSFileMapHeader::_header_size\n+    private static int offsetBaseArchivePathOffset;\/\/ offset of GenericCDSFileMapHeader::_base_archive_path_offset\n+    private static int offsetBaseArchiveNameSize;  \/\/ offset of GenericCDSFileMapHeader::_base_archive_name_size\n+    private static int offsetJvmIdent;             \/\/ offset of FileMapHeader::_jvm_ident\n+    private static int spOffsetCrc;                \/\/ offset of CDSFileMapRegion::_crc\n+    private static int spOffset;                   \/\/ offset of CDSFileMapRegion\n+    private static int spUsedOffset;               \/\/ offset of CDSFileMapRegion::_used\n@@ -57,8 +60,8 @@\n-    public static int staticMagic;                \/\/ static magic value defined in hotspot\n-    public static int dynamicMagic;               \/\/ dyamic magic value defined in hotspot\n-    public static int sizetSize;                  \/\/ size of size_t\n-    public static int intSize;                    \/\/ size of int\n-    public static int staticArchiveHeaderSize;    \/\/ static archive file header size\n-    public static int dynamicArchiveHeaderSize;   \/\/ dynamic archive file header size\n-    public static int cdsFileMapRegionSize;       \/\/ size of CDSFileMapRegion\n-    public static long alignment;                 \/\/ MetaspaceShared::core_region_alignment\n+    private static int staticMagic;                \/\/ static magic value defined in hotspot\n+    private static int dynamicMagic;               \/\/ dyamic magic value defined in hotspot\n+    private static int sizetSize;                  \/\/ size of size_t\n+    private static int intSize;                    \/\/ size of int\n+    private static int staticArchiveHeaderSize;    \/\/ static archive file header size\n+    private static int dynamicArchiveHeaderSize;   \/\/ dynamic archive file header size\n+    private static int cdsFileMapRegionSize;       \/\/ size of CDSFileMapRegion\n+    private static long alignment;                 \/\/ MetaspaceShared::core_region_alignment\n@@ -67,1 +70,1 @@\n-    public static String[] shared_region_name = {\n+    private static String[] shared_region_name = {\n@@ -76,1 +79,1 @@\n-    public static int num_regions = shared_region_name.length;\n+    private static int num_regions = shared_region_name.length;\n@@ -83,2 +86,6 @@\n-            offsetMagic = wb.getCDSOffsetForName(\"CDSFileMapHeaderBase::_magic\");\n-            offsetVersion = wb.getCDSOffsetForName(\"CDSFileMapHeaderBase::_version\");\n+            offsetMagic = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_magic\");\n+            offsetCrc = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_crc\");\n+            offsetVersion = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_version\");\n+            offsetHeaderSize = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_header_size\");\n+            offsetBaseArchivePathOffset = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_base_archive_path_offset\");\n+            offsetBaseArchiveNameSize = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_base_archive_name_size\");\n@@ -86,1 +93,0 @@\n-            offsetBaseArchiveNameSize = wb.getCDSOffsetForName(\"FileMapHeader::_base_archive_name_size\");\n@@ -93,0 +99,1 @@\n+            \/\/ following two sizes are runtime values\n@@ -99,2 +106,0 @@\n-            \/\/ file_header_size is structure size, real size aligned with alignment\n-            \/\/ so must be calculated after alignment is available\n@@ -113,0 +118,23 @@\n+    \/\/ accessors\n+    \/\/ offsets\n+    public static int offsetMagic()                 { return offsetMagic;                 }\n+    public static int offsetCrc()                   { return offsetCrc;                   }\n+    public static int offsetVersion()               { return offsetVersion;               }\n+    public static int offsetHeaderSize()            { return offsetHeaderSize;            }\n+    public static int offsetBaseArchivePathOffset() { return offsetBaseArchivePathOffset; }\n+    public static int offsetBaseArchiveNameSize()   { return offsetBaseArchiveNameSize;   }\n+    public static int offsetJvmIdent()              { return offsetJvmIdent;              }\n+    public static int spOffsetCrc()                 { return spOffsetCrc;                 }\n+    public static int spOffset()                    { return spOffset;                    }\n+    public static int spUsedOffset()                { return spUsedOffset;                }\n+    \/\/ constants\n+    public static int staticMagic()                 { return staticMagic;                 }\n+    public static int dynamicMagic()                { return dynamicMagic;                }\n+    public static int sizetSize()                   { return sizetSize;                   }\n+    public static int staticArchiveHeaderSize()     { return staticArchiveHeaderSize;     }\n+    public static int dynamicArchiveHeaderSize()    { return dynamicArchiveHeaderSize;    }\n+    public static int cdsFileMapRegionSize()        { return cdsFileMapRegionSize;        }\n+    public static long alignment()                  { return alignment;                   }\n+\n+\n+\n@@ -114,10 +142,21 @@\n-      long magicValue = readInt(jsaFile, offsetMagic, 4);\n-      if (magicValue == staticMagic) {\n-          return alignUpWithAlignment((long)staticArchiveHeaderSize);\n-      } else if (magicValue == dynamicMagic) {\n-          \/\/ dynamic archive store base archive name after header, so we count it in header size.\n-          int baseArchiveNameSize = (int)readInt(jsaFile, (long)offsetBaseArchiveNameSize, 4);\n-          return alignUpWithAlignment((long)dynamicArchiveHeaderSize + baseArchiveNameSize);\n-      } else {\n-          throw new RuntimeException(\"Wrong magic value from archive file: \" + magicValue);\n-      }\n+        long  headerSize = readInt(jsaFile, offsetHeaderSize, 4);\n+        return headerSize;\n+    }\n+\n+    public static long fileHeaderSizeAligned(File jsaFile) throws Exception {\n+        long size = fileHeaderSize(jsaFile);\n+        return alignUpWithAlignment(size);\n+    }\n+\n+    public static int baseArchivePathOffset(File jsaFile) throws Exception {\n+        return (int)readInt(jsaFile, offsetBaseArchivePathOffset, 4);\n+    }\n+\n+    public static int baseArchiveNameSize(File jsaFile) throws Exception {\n+        return (int)readInt(jsaFile, offsetBaseArchiveNameSize, 4);\n+    }\n+\n+    public static String baseArchiveName(File jsaFile) throws Exception {\n+        int size = baseArchiveNameSize(jsaFile);\n+        int baseArchivePathOffset = (int)readInt(jsaFile, offsetBaseArchivePathOffset, 4);\n+        return readString(jsaFile, baseArchivePathOffset, size - 1); \/\/ exclude terminating '\\0'\n@@ -162,1 +201,1 @@\n-        start0 = fileHeaderSize(jsaFile);\n+        start0 = fileHeaderSizeAligned(jsaFile);\n@@ -191,1 +230,1 @@\n-        start0 = fileHeaderSize(jsaFile);\n+        start0 = fileHeaderSizeAligned(jsaFile);\n@@ -228,1 +267,1 @@\n-        long regionStartOffset = fileHeaderSize(jsaFile);\n+        long regionStartOffset = fileHeaderSizeAligned(jsaFile);\n@@ -233,1 +272,1 @@\n-                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - fileHeaderSize(jsaFile)) + \")\");\n+                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - fileHeaderSizeAligned(jsaFile)) + \")\");\n@@ -265,0 +304,4 @@\n+    public static void modifyFileHeaderSize(File jsaFile, int newHeaderSize) throws Exception {\n+        modifyHeaderIntField(jsaFile, offsetHeaderSize, newHeaderSize);\n+    }\n+\n@@ -271,4 +314,1 @@\n-        System.out.println(\"    offset \" + offset);\n-\n-        byte[] bytes = ByteBuffer.allocate(4).putInt(value).array();\n-        writeData(jsaFile, offset, bytes);\n+        writeData(jsaFile, offset, value);\n@@ -303,1 +343,1 @@\n-    public static long readInt(File file, long offset, int nBytes) throws Exception {\n+    private static long readInt(File file, long offset, int nBytes) throws Exception {\n@@ -305,2 +345,1 @@\n-            ByteBuffer bb = ByteBuffer.allocate(nBytes);\n-            bb.order(ByteOrder.nativeOrder());\n+            ByteBuffer bb = ByteBuffer.allocate(nBytes).order(ByteOrder.nativeOrder());\n@@ -309,0 +348,1 @@\n+            bb.rewind();\n@@ -313,0 +353,14 @@\n+    private static String readString(File file, long offset, int nBytes) throws Exception {\n+        try (FileChannel fc = getFileChannel(file, false \/*read only*\/)) {\n+            ByteBuffer bb = ByteBuffer.allocate(nBytes).order(ByteOrder.nativeOrder());\n+            fc.position(offset);\n+            fc.read(bb);\n+            byte[] arr = bb.flip().array();\n+            for (byte i : arr) {\n+                System.out.print((char)i);\n+            }\n+            System.out.println(\"\");\n+            return new String(arr);\n+        }\n+    }\n+\n@@ -321,0 +375,1 @@\n+            bbuf.order(ByteOrder.nativeOrder());\n@@ -327,1 +382,4 @@\n-            ByteBuffer bbuf = ByteBuffer.allocate(4).putInt(value).position(0);\n+            ByteBuffer bbuf = ByteBuffer.allocate(4)\n+                                        .order(ByteOrder.nativeOrder())\n+                                        .putInt(value)\n+                                        .rewind();\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":102,"deletions":44,"binary":false,"changes":146,"status":"modified"}]}