{"files":[{"patch":"@@ -183,0 +183,3 @@\n+  FileMapInfo* base_info = FileMapInfo::current_info();\n+  \/\/ header only be available after populate_header\n+  mapinfo->populate_header(base_info->core_region_alignment());\n@@ -185,1 +188,0 @@\n-  FileMapInfo* base_info = FileMapInfo::current_info();\n@@ -190,1 +192,0 @@\n-  _header->populate(base_info, base_info->core_region_alignment());\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -173,5 +173,1 @@\n-  size_t c_header_size;\n-  size_t header_size;\n-  size_t base_archive_name_size = 0;\n-  size_t base_archive_path_offset = 0;\n-  if (is_static) {\n+  if (_is_static) {\n@@ -180,2 +176,0 @@\n-    c_header_size = sizeof(FileMapHeader);\n-    header_size = c_header_size;\n@@ -185,24 +179,0 @@\n-    \/\/ dynamic header including base archive name\n-    c_header_size = sizeof(DynamicArchiveHeader);\n-    header_size = c_header_size;\n-    if (!FLAG_IS_DEFAULT(SharedArchiveFile)) {\n-      base_archive_name_size = strlen(Arguments::GetSharedArchivePath()) + 1;\n-      header_size += base_archive_name_size;\n-    }\n-  }\n-  _header = (FileMapHeader*)os::malloc(header_size, mtInternal);\n-  memset((void*)_header, 0, header_size);\n-  _header->set_base_archive_path_offset(0);\n-  _header->set_base_archive_name_size(0);\n-  _header->set_header_size((unsigned int)header_size);\n-  _header->set_has_platform_or_app_classes(true);\n-  if (!is_static) {\n-    _header->set_base_archive_is_default(FLAG_IS_DEFAULT(SharedArchiveFile));\n-    if (!_header->base_archive_is_default()) {\n-      assert(base_archive_name_size != 0, \"_base_archive_name_size should not be 0\");\n-      _header->set_header_size((unsigned int)header_size);\n-      _header->set_base_archive_path_offset((unsigned int)c_header_size);\n-      _header->set_base_archive_name_size((unsigned int)base_archive_name_size);\n-      \/\/ copy base archive name\n-      _header->set_base_archive_name(Arguments::GetSharedArchivePath());\n-    }\n@@ -210,1 +180,0 @@\n-\n@@ -226,6 +195,8 @@\n-  header()->populate(this, core_region_alignment);\n-}\n-\n-void FileMapHeader::populate(FileMapInfo* mapinfo, size_t core_region_alignment) {\n-  if (DynamicDumpSharedSpaces) {\n-    set_magic(CDS_DYNAMIC_ARCHIVE_MAGIC);\n+  assert(_header == NULL, \"Sanity check\");\n+  size_t c_header_size;\n+  size_t header_size;\n+  size_t base_archive_name_size = 0;\n+  size_t base_archive_path_offset = 0;\n+  if (is_static()) {\n+    c_header_size = sizeof(FileMapHeader);\n+    header_size = c_header_size;\n@@ -233,1 +204,8 @@\n-    set_magic(CDS_ARCHIVE_MAGIC);\n+    \/\/ dynamic header including base archive name for non-default base archive\n+    c_header_size = sizeof(DynamicArchiveHeader);\n+    header_size = c_header_size;\n+    if (!FLAG_IS_DEFAULT(SharedArchiveFile)) {\n+      base_archive_name_size = strlen(Arguments::GetSharedArchivePath()) + 1;\n+      header_size += base_archive_name_size;\n+      base_archive_path_offset = c_header_size;\n+    }\n@@ -235,0 +213,20 @@\n+  _header = (FileMapHeader*)os::malloc(header_size, mtInternal);\n+  memset((void*)_header, 0, header_size);\n+  _header->populate(this,\n+                    core_region_alignment,\n+                    header_size,\n+                    base_archive_name_size,\n+                    base_archive_path_offset);\n+}\n+\n+void FileMapHeader::populate(FileMapInfo *info, size_t core_region_alignment,\n+                             size_t header_size, size_t base_archive_name_size,\n+                             size_t base_archive_path_offset) {\n+  set_header_size((unsigned int)header_size);\n+  set_base_archive_path_offset((unsigned int)base_archive_path_offset);\n+  set_base_archive_name_size((unsigned int)base_archive_name_size);\n+  if (!info->is_static() && base_archive_name_size != 0) {\n+    \/\/ copy base archive name\n+    copy_base_archive_name(Arguments::GetSharedArchivePath());\n+  }\n+  set_magic(DynamicDumpSharedSpaces ? CDS_DYNAMIC_ARCHIVE_MAGIC : CDS_ARCHIVE_MAGIC);\n@@ -236,0 +234,1 @@\n+\n@@ -274,1 +273,1 @@\n-    set_shared_path_table(mapinfo->_shared_path_table);\n+    set_shared_path_table(info->_shared_path_table);\n@@ -280,1 +279,1 @@\n-void FileMapHeader::set_base_archive_name(const char* archive) {\n+void FileMapHeader::copy_base_archive_name(const char* archive) {\n@@ -317,1 +316,0 @@\n-  st->print_cr(\"- base_archive_is_default:        %d\", _base_archive_is_default);\n@@ -1045,0 +1043,70 @@\n+\/\/ a utility class for checking file header\n+class FileHeaderHelper {\n+  int _fd;\n+  GenericCDSFileMapHeader* _header;\n+\n+public:\n+  FileHeaderHelper() {\n+    _fd = -1;\n+    _header = NULL;\n+  }\n+\n+  ~FileHeaderHelper() {\n+    if (_fd != -1) {\n+      os::close(_fd);\n+    }\n+    if (_header != NULL) {\n+      os::free((void*)_header);\n+    }\n+  }\n+\n+  bool initialize(const char* archive_name) {\n+    _fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n+    if (_fd < 0) {\n+      return false;\n+    }\n+    return initialize(_fd);\n+  }\n+\n+  \/\/ for an already opened file, do not set _fd\n+  bool initialize(int fd) {\n+    assert(fd != -1, \"Archive should be opened\");\n+    assert(_header == NULL, \"_header alredy inited?\");\n+    size_t size = sizeof(GenericCDSFileMapHeader);\n+    _header = (GenericCDSFileMapHeader*)os::malloc(size, mtInternal);\n+    memset(_header, 0, size);\n+    lseek(fd, 0, SEEK_SET);\n+    size_t n = os::read(fd, (void*)_header, (unsigned int)size);\n+    if (n != size) {\n+      vm_exit_during_initialization(\"Unable to read generic CDS file map header from shared archive\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  GenericCDSFileMapHeader* get_generic_file_header() {\n+    return _header;\n+  }\n+\n+  bool read_base_archive_name(char** target) {\n+    assert(_fd != -1, \"Archive should be open\");\n+    assert(_header != NULL, \"Sanity check\");\n+    size_t name_size = (size_t)_header->_base_archive_name_size;\n+    assert(name_size != 0, \"For non-default base archive, name size should be non-zero!\");\n+    *target = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n+    lseek(_fd, _header->_base_archive_path_offset, SEEK_SET); \/\/ position to correct offset.\n+    size_t n = os::read(_fd, *target, (unsigned int)name_size);\n+    if (n != name_size) {\n+      log_info(cds)(\"Unable to read base archive name from archive\");\n+      FREE_C_HEAP_ARRAY(char, *target);\n+      return false;\n+    }\n+    if (!os::file_exists(*target)) {\n+      log_info(cds)(\"Base archive %s does not exist\", *target);\n+      FREE_C_HEAP_ARRAY(char, *target);\n+      return false;\n+    }\n+    return true;\n+  }\n+};\n+\n@@ -1046,2 +1114,2 @@\n-  int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n-  if (fd < 0) {\n+  FileHeaderHelper file_helper;\n+  if (!file_helper.initialize(archive_name)) {\n@@ -1054,11 +1122,1 @@\n-  size_t sz = sizeof(GenericCDSFileMapHeader);\n-  GenericCDSFileMapHeader* header = (GenericCDSFileMapHeader*)os::malloc(sz, mtInternal);\n-  memset((void*)header, 0, sz);\n-  size_t n = os::read(fd, (void*)header, (unsigned int)sz);\n-  if (n != sz) {\n-    os::free(header);\n-    os::close(fd);\n-    vm_exit_during_initialization(\"Unable to read header from shared archive\", archive_name);\n-    return false;\n-  }\n-\n+  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n@@ -1067,2 +1125,0 @@\n-      os::free(header);\n-      os::close(fd);\n@@ -1079,2 +1135,0 @@\n-      os::free(header);\n-      os::close(fd);\n@@ -1094,15 +1148,2 @@\n-    char* base_name = (char*)os::malloc(name_size, mtInternal);\n-    lseek(fd, header->_base_archive_path_offset, SEEK_SET);\n-    n = os::read(fd, base_name, name_size);\n-    if (n != name_size) {\n-      log_info(cds)(\"Read base archive name from %s failed\", archive_name);\n-      os::free(header);\n-      os::free(base_name);\n-      os::close(fd);\n-      return false;\n-    }\n-    if (!os::file_exists(base_name)) {\n-      log_info(cds)(\"Base archive %s does not exist\", base_name);\n-      os::free(header);\n-      os::free(base_name);\n-      os::close(fd);\n+    char* base_name = NULL;\n+    if (!file_helper.read_base_archive_name(&base_name)) {\n@@ -1111,1 +1152,1 @@\n-    os::free(base_name);\n+    FREE_C_HEAP_ARRAY(char, base_name);\n@@ -1113,2 +1154,0 @@\n-  os::free(header);\n-  os::close(fd);\n@@ -1120,12 +1159,2 @@\n-  int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n-  if (fd < 0) {\n-    return false;\n-  }\n-  \/\/ read the header as a dynamic archive header\n-  size_t sz = sizeof(GenericCDSFileMapHeader);\n-  GenericCDSFileMapHeader* header = (GenericCDSFileMapHeader*)os::malloc(sz, mtInternal);\n-  size_t n = os::read(fd, (void*)header, (unsigned int)sz);\n-  if (n != sz) {\n-    fail_continue(\"Unable to read the file header.\");\n-    os::free(header);\n-    os::close(fd);\n+  FileHeaderHelper file_helper;\n+  if (!file_helper.initialize(archive_name)) {\n@@ -1134,0 +1163,1 @@\n+  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n@@ -1136,2 +1166,0 @@\n-    os::free(header);\n-    os::close(fd);\n@@ -1144,2 +1172,0 @@\n-    os::free(header);\n-    os::close(fd);\n@@ -1153,16 +1179,1 @@\n-    size_t name_size = (size_t)header->_base_archive_name_size;\n-    assert(name_size != 0, \"For non-default base archive, name size should be non-zero!\");\n-    *base_archive_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n-    lseek(fd, header->_base_archive_path_offset, SEEK_SET); \/\/ position to correct offset.\n-    n = os::read(fd, *base_archive_name, (unsigned int)name_size);\n-    if (n != name_size) {\n-      fail_continue(\"Unable to read the base archive name from the header.\");\n-      FREE_C_HEAP_ARRAY(char, *base_archive_name);\n-      *base_archive_name = NULL;\n-      os::free(header);\n-      os::close(fd);\n-      return false;\n-    }\n-    if (!os::file_exists(*base_archive_name)) {\n-      log_info(cds)(\"Base archive file does not exist.\");\n-      FREE_C_HEAP_ARRAY(char, *base_archive_name);\n+    if (!file_helper.read_base_archive_name(base_archive_name)) {\n@@ -1170,2 +1181,0 @@\n-      os::free(header);\n-      os::close(fd);\n@@ -1175,3 +1184,0 @@\n-\n-  os::free(header);\n-  os::close(fd);\n@@ -1184,3 +1190,2 @@\n-  size_t runtime_header_size = is_static() ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);\n-  size_t n = os::read(fd, header(), (unsigned int)runtime_header_size);\n-  if (n != runtime_header_size) {\n+  FileHeaderHelper file_helper;\n+  if (!file_helper.initialize(fd)) {\n@@ -1190,5 +1195,1 @@\n-\n-  if (!Arguments::has_jimage()) {\n-    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n-    return false;\n-  }\n+  GenericCDSFileMapHeader* gen_header = file_helper.get_generic_file_header();\n@@ -1197,1 +1198,1 @@\n-  if (header()->magic() != expected_magic) {\n+  if (gen_header->_magic != expected_magic) {\n@@ -1199,1 +1200,1 @@\n-    log_info(cds)(\"         actual: 0x%08x\", header()->magic());\n+    log_info(cds)(\"         actual: 0x%08x\", gen_header->_magic);\n@@ -1204,11 +1205,7 @@\n-  \/\/ note for dynamic archive, the check for fields of GenericCDSFileMapHeader already done in check_archive\n-  if (!is_static() && header()->base_archive_path_offset() != 0) {\n-    unsigned int size = header()->base_archive_path_offset() + header()->base_archive_name_size();\n-    os::free(_header);\n-    _header = (FileMapHeader*)os::malloc(size, mtInternal);\n-    lseek(fd, 0, SEEK_SET); \/\/ reset to begin of the archive\n-    n = os::read(fd, (void*)_header, size);\n-    if (n != (size_t)size) {\n-      fail_continue(\"Failed to read file header from the top archive file\\n\");\n-      return false;\n-    }\n+  _header = (FileMapHeader*)os::malloc(gen_header->_header_size, mtInternal);\n+  lseek(fd, 0, SEEK_SET); \/\/ reset to begin of the archive\n+  size_t size = gen_header->_header_size;\n+  size_t n = os::read(fd, (void*)_header, (unsigned int)size);\n+  if (n != size) {\n+    fail_continue(\"Failed to read file header from the top archive file\\n\");\n+    return false;\n@@ -1224,6 +1221,11 @@\n-  if (header()->header_size() != (unsigned int)runtime_header_size + header()->base_archive_name_size()) {\n-    log_info(cds)(\"_header_size expected: \" SIZE_FORMAT, runtime_header_size + header()->base_archive_name_size());\n-    log_info(cds)(\"               actual: \" UINT32_FORMAT, header()->header_size());\n-    log_info(cds)(\"base_archive_name-size:\" UINT32_FORMAT, header()->base_archive_name_size());\n-    FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n-    return false;\n+  unsigned int base_offset = header()->base_archive_path_offset();\n+  unsigned int name_size = header()->base_archive_name_size();\n+  unsigned int header_size = header()->header_size();\n+  if (base_offset != 0 && name_size != 0) {\n+    if (header_size != base_offset + name_size) {\n+      log_info(cds)(\"_header_size: \" UINT32_FORMAT, header_size);\n+      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, name_size);\n+      log_info(cds)(\"base_archive_path_offset: \" UINT32_FORMAT, base_offset);\n+      FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n+      return false;\n+    }\n@@ -2299,0 +2301,5 @@\n+  if (!Arguments::has_jimage()) {\n+    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":148,"deletions":141,"binary":false,"changes":289,"status":"modified"},{"patch":"@@ -204,1 +204,0 @@\n-  bool _base_archive_is_default;    \/\/ indicates if the base archive is the system default one\n@@ -270,1 +269,0 @@\n-  bool base_archive_is_default()           const { return _base_archive_is_default; }\n@@ -289,1 +287,0 @@\n-  void set_base_archive_is_default(bool b)       { _base_archive_is_default = b; }\n@@ -293,1 +290,1 @@\n-  void set_base_archive_name(const char* name);\n+  void copy_base_archive_name(const char* name);\n@@ -318,2 +315,2 @@\n-  void populate(FileMapInfo* info, size_t core_region_alignment);\n-\n+  void populate(FileMapInfo *info, size_t core_region_alignment, size_t header_size,\n+                size_t base_archive_name_size, size_t base_archive_path_offset);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-        \/\/ any change to the header leads to checksum failed.\n@@ -128,2 +127,2 @@\n-               new String[] {\"An error has occurred while processing the shared archive file.\",\n-                             \"Header checksum verification failed\",\n+               new String[] {\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\",\n+                             \"The shared archive file has an incorrect header size\",\n@@ -140,1 +139,0 @@\n-        \/\/ any change to the header leads to checksum failed.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}