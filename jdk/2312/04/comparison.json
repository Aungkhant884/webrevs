{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.channels.MulticastChannel;\n@@ -84,1 +85,1 @@\n- *     <td> The size of the socket send buffer <\/td>\n+ *     <td> The size of the socket send buffer in bytes <\/td>\n@@ -88,1 +89,1 @@\n- *     <td> The size of the socket receive buffer <\/td>\n+ *     <td> The size of the socket receive buffer in bytes <\/td>\n@@ -105,4 +106,136 @@\n- * An implementation may also support additional options. In particular an implementation\n- * may support <a href=\"MulticastSocket.html#MulticastOptions\">multicast options<\/a> which\n- * can be useful when using a plain {@code DatagramSocket} to send datagrams to a\n- * multicast group.\n+ * <p> In addition, the {@code DatagramSocket} class defines methods to {@linkplain\n+ * #joinGroup(SocketAddress, NetworkInterface) join} and {@linkplain\n+ * #leaveGroup(SocketAddress, NetworkInterface) leave} a multicast group, and\n+ * supports <a href=\"DatagramSocket.html#MulticastOptions\">multicast options<\/a> which\n+ * are useful when {@linkplain #joinGroup(SocketAddress, NetworkInterface) joining},\n+ * {@linkplain #leaveGroup(SocketAddress, NetworkInterface) leaving}, or sending datagrams\n+ * to a multicast group.\n+ * The following multicast options are supported:\n+ * <blockquote>\n+ * <a id=\"MulticastOptions\"><\/a>\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Multicast options<\/caption>\n+ * <thead>\n+ *   <tr>\n+ *     <th scope=\"col\">Option Name<\/th>\n+ *     <th scope=\"col\">Description<\/th>\n+ *   <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#IP_MULTICAST_IF IP_MULTICAST_IF} <\/th>\n+ *     <td> The network interface for Internet Protocol (IP) multicast datagrams <\/td>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#IP_MULTICAST_TTL\n+ *       IP_MULTICAST_TTL} <\/th>\n+ *     <td> The <em>time-to-live<\/em> for Internet Protocol (IP) multicast\n+ *       datagrams <\/td>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP\n+ *       IP_MULTICAST_LOOP} <\/th>\n+ *     <td> Loopback for Internet Protocol (IP) multicast datagrams <\/td>\n+ *   <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <\/blockquote>\n+ * An implementation may also support additional options.\n+ *\n+ * @apiNote  <a id=\"Multicasting\"><\/a><b>Multicasting with DatagramSocket<\/b>\n+ *\n+ * <p> {@link DatagramChannel} implements the {@link MulticastChannel} interface\n+ * and provides an alternative API for sending and receiving multicast datagrams.\n+ * The {@link MulticastChannel} API supports both {@linkplain\n+ * MulticastChannel#join(InetAddress, NetworkInterface) any-source} and\n+ * {@linkplain MulticastChannel#join(InetAddress, NetworkInterface, InetAddress)\n+ * source-specific} multicast. Consider using {@code DatagramChannel} for\n+ * multicasting.\n+ *\n+ * <p> {@code DatagramSocket} can be used directly for multicasting. However,\n+ * contrarily to {@link MulticastSocket}, {@code DatagramSocket} doesn't call the\n+ * {@link DatagramSocket#setReuseAddress(boolean)} method to enable the SO_REUSEADDR\n+ * socket option by default. If creating a {@code DatagramSocket} intended to\n+ * later join a multicast group, the caller should consider explicitly enabling\n+ * the SO_REUSEADDR option.\n+ *\n+ * <p> An instance of {@code DatagramSocket} can be used to send or\n+ * receive multicast datagram packets. It is no necessary to join a multicast\n+ * group in order to send multicast datagrams. Before sending out multicast\n+ * datagram packets however, the default outgoing interface for sending\n+ * multicast datagram should first be configured using\n+ * {@link #setOption(SocketOption, Object) setOption} and\n+ * {@link StandardSocketOptions#IP_MULTICAST_IF}:\n+ *\n+ * <pre>{@code\n+ *    DatagramSocket sender = new DatagramSocket(new InetSocketAddress(0));\n+ *    NetworkInterface outgoingIf = NetworkInterface.getByName(\"en0\");\n+ *    sender.setOption(StandardSocketOptions.IP_MULTICAST_IF, outgoingIf);\n+ *\n+ *    \/\/ optionally configure multicast TTL; the TTL defines the scope of a\n+ *    \/\/ multicast datagram, for example, confining it to host local (0) or\n+ *    \/\/ link local (1) etc...\n+ *    int ttl = ...; \/\/ a number betwen 0 and 255\n+ *    sender.setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);\n+ *\n+ *    \/\/ send a packet to a multicast group\n+ *    byte[] msgBytes = ...;\n+ *    InetAddress mcastaddr = InetAddress.getByName(\"228.5.6.7\");\n+ *    int port = 6789;\n+ *    InetSocketAddress dest = new InetSocketAddress(mcastaddr, port);\n+ *    DatagramPacket hi = new DatagramPacket(msgBytes, msgBytes.length, dest);\n+ *    sender.send(hi);\n+ * }<\/pre>\n+ *\n+ * <p> An instance of {@code DatagramSocket} can also be used to receive\n+ * multicast datagram packets. A {@code DatagramSocket} that is created\n+ * with the intent of receiving multicast datagrams should be created\n+ * <i>unbound<\/i>. Before binding the socket, {@link #setReuseAddress(boolean)\n+ * setReuseAddress(true)} should be configured:\n+ *\n+ * <pre>{@code\n+ *    DatagramSocket socket = new DatagramSocket(null); \/\/ unbound\n+ *    socket.setReuseAddress(true); \/\/ set reuse address before binding\n+ *    socket.bind(new InetSocketAddress(6789)); \/\/ bind\n+ *\n+ *    \/\/ joinGroup 228.5.6.7\n+ *    InetAddress mcastaddr = InetAddress.getByName(\"228.5.6.7\");\n+ *    InetSocketAddress group = new InetSocketAddress(mcastaddr, 0);\n+ *    NetworkInterface netIf = NetworkInterface.getByName(\"en0\");\n+ *    socket.joinGroup(group, netIf);\n+ *    byte[] msgBytes = new byte[1024]; \/\/ up to 1024 bytes\n+ *    DatagramPacket packet = new DatagramPacket(msgBytes, msgBytes.length);\n+ *    socket.receive(packet);\n+ *    ....\n+ *    \/\/ eventually leave group\n+ *    socket.leaveGroup(group, netIf);\n+ * }<\/pre>\n+ *\n+ * <p><a id=\"PlatformDependencies\"><\/a><b>Platform dependencies<\/b>\n+ * <p>The multicast implementation is intended to map directly to the native\n+ * multicasting facility. Consequently, the following items should be considered\n+ * when developing an application that receives IP multicast datagrams:\n+ * <ol>\n+ *    <li> Contrarily to {@link DatagramChannel}, the constructors of {@code DatagramSocket}\n+ *        do not allow to specify the {@link ProtocolFamily} that corresponds\n+ *        to the address type of the multicast groups that the {@code DatagramSocket}\n+ *        will join. This is similar to a {@code DatagramChannel} that would be created\n+ *        using {@link DatagramChannel#open()}.\n+ *        <br>\n+ *        There is no guarantee that a {@code DatagramSocket} with an underlying\n+ *        socket created in one protocol family can join and receive multicast\n+ *        datagrams when the address of the multicast group corresponds to\n+ *        another protocol family. For example, it is implementation specific if a\n+ *        {@code DatagramSocket} to an IPv6 socket can join an IPv4 multicast group\n+ *        and receive multicast datagrams sent to the group.\n+ *    <\/li>\n+ *    <li> Before joining a multicast group, the {@code DatagramSocket} should be\n+ *        bound to the wildcard address.\n+ *        If the socket is bound to a specific address, rather than the wildcard address\n+ *        then it is implementation specific if multicast datagrams are received\n+ *        by the socket.\n+ *    <\/li>\n+ *    <li> The SO_REUSEADDR option should be enabled prior to binding the socket.\n+ *        This is required to allow multiple members of the group to bind to the same address.\n+ *    <\/li>\n+ * <\/ol>\n@@ -658,0 +791,5 @@\n+     * @apiNote\n+     * If {@code size > 0}, this method is equivalent to calling\n+     * {@link #setOption(SocketOption, Object)\n+     * setOption(StandardSocketOptions.SO_SNDBUF, size)}.\n+     *\n@@ -659,1 +797,1 @@\n-     * size. This value must be greater than 0.\n+     * size, in bytes. This value must be greater than 0.\n@@ -666,0 +804,1 @@\n+     * @see StandardSocketOptions#SO_SNDBUF\n@@ -674,1 +813,5 @@\n-     * buffer size used by the platform for output on this {@code DatagramSocket}.\n+     * buffer size, in bytes, used by the platform for output on this {@code DatagramSocket}.\n+     *\n+     * @apiNote\n+     * This method is equivalent to calling {@link #getOption(SocketOption)\n+     * getOption(StandardSocketOptions.SO_SNDBUF)}.\n@@ -680,0 +823,1 @@\n+     * @see StandardSocketOptions#SO_SNDBUF\n@@ -705,0 +849,5 @@\n+     * @apiNote\n+     * If {@code size > 0}, this method is equivalent to calling\n+     * {@link #setOption(SocketOption, Object)\n+     * setOption(StandardSocketOptions.SO_RCVBUF, size)}.\n+     *\n@@ -706,1 +855,1 @@\n-     * size. This value must be greater than 0.\n+     * size, in bytes. This value must be greater than 0.\n@@ -713,0 +862,1 @@\n+     * @see StandardSocketOptions#SO_RCVBUF\n@@ -721,1 +871,5 @@\n-     * buffer size used by the platform for input on this {@code DatagramSocket}.\n+     * buffer size, in bytes, used by the platform for input on this {@code DatagramSocket}.\n+     *\n+     * @apiNote\n+     * This method is equivalent to calling {@link #getOption(SocketOption)\n+     * getOption(StandardSocketOptions.SO_RCVBUF)}.\n@@ -726,0 +880,1 @@\n+     * @see StandardSocketOptions#SO_RCVBUF\n@@ -756,0 +911,4 @@\n+     * @apiNote\n+     * This method is equivalent to calling {@link #setOption(SocketOption, Object)\n+     * setOption(StandardSocketOptions.SO_REUSEADDR, on)}.\n+     *\n@@ -765,0 +924,1 @@\n+     * @see StandardSocketOptions#SO_REUSEADDR\n@@ -773,0 +933,4 @@\n+     * @apiNote\n+     * This method is equivalent to calling {@link #getOption(SocketOption)\n+     * getOption(StandardSocketOptions.SO_REUSEADDR)}.\n+     *\n@@ -778,0 +942,1 @@\n+     * @see StandardSocketOptions#SO_REUSEADDR\n@@ -790,0 +955,4 @@\n+     * @apiNote\n+     * This method is equivalent to calling {@link #setOption(SocketOption, Object)\n+     * setOption(StandardSocketOptions.SO_BROADCAST, on)}.\n+     *\n@@ -799,0 +968,1 @@\n+     * @see StandardSocketOptions#SO_BROADCAST\n@@ -806,0 +976,5 @@\n+     *\n+     * @apiNote\n+     * This method is equivalent to calling {@link #getOption(SocketOption)\n+     * getOption(StandardSocketOptions.SO_BROADCAST)}.\n+     *\n@@ -811,0 +986,1 @@\n+     * @see StandardSocketOptions#SO_BROADCAST\n@@ -847,0 +1023,4 @@\n+     * @apiNote\n+     * This method is equivalent to calling {@link #setOption(SocketOption, Object)\n+     * setOption(StandardSocketOptions.IP_TOS, tc)}.\n+     *\n@@ -852,0 +1032,1 @@\n+     * @see StandardSocketOptions#IP_TOS\n@@ -867,0 +1048,4 @@\n+     * @apiNote\n+     * This method is equivalent to calling {@link #getOption(SocketOption)\n+     * getOption(StandardSocketOptions.IP_TOS)}.\n+     *\n@@ -872,0 +1057,1 @@\n+     * @see StandardSocketOptions#IP_TOS\n@@ -1041,0 +1227,89 @@\n+    \/**\n+     * Joins the specified multicast group at the specified interface.\n+     *\n+     * <p> In order to join a multicast group, the caller should specify\n+     * the IP address of the multicast group to join, and the local\n+     * {@linkplain NetworkInterface network interface} to receive multicast\n+     * packets from.\n+     * <ul>\n+     *  <li> The {@code mcastaddr} argument indicates the IP address\n+     *   of the multicast group to join. For historical reasons this is\n+     *   specified as a {@code SocketAddress}.\n+     *   The default implementation only supports {@link InetSocketAddress} and\n+     *   the {@link InetSocketAddress#getPort() port} information is ignored.\n+     *  <\/li>\n+     *  <li> The {@code netIf} argument specifies the local interface to receive\n+     *       multicast datagram packets, or {@code null} to defer to the interface\n+     *       set for outgoing multicast datagrams.\n+     *       If {@code null}, and no interface has been set, the behaviour is\n+     *       unspecified: any interface may be selected or the operation may fail\n+     *       with a {@code SocketException}.\n+     *  <\/li>\n+     * <\/ul>\n+     *\n+     * <p>If there is a security manager, this method first\n+     * calls its {@code checkMulticast} method with the {@code mcastaddr}\n+     * argument as its argument.\n+     *\n+     * @apiNote The default interface for sending outgoing multicast datagrams\n+     * can be configured with {@link #setOption(SocketOption, Object)}\n+     * with {@link StandardSocketOptions#IP_MULTICAST_IF}.\n+     *\n+     * @param  mcastaddr indicates the multicast address to join.\n+     * @param  netIf specifies the local interface to receive multicast\n+     *         datagram packets, or {@code null}.\n+     * @throws IOException if there is an error joining, or when the address\n+     *         is not a multicast address, or the platform does not support\n+     *         multicasting\n+     * @throws SecurityException if a security manager exists and its\n+     *         {@code checkMulticast} method doesn't allow the join.\n+     * @throws IllegalArgumentException if mcastaddr is {@code null} or is a\n+     *         SocketAddress subclass not supported by this socket\n+     * @see    SecurityManager#checkMulticast(InetAddress)\n+     * @see    DatagramChannel#join(InetAddress, NetworkInterface)\n+     * @see    StandardSocketOptions#IP_MULTICAST_IF\n+     * @since  17\n+     *\/\n+    public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n+            throws IOException {\n+        delegate().joinGroup(mcastaddr, netIf);\n+    }\n+\n+    \/**\n+     * Leave a multicast group on a specified local interface.\n+     *\n+     * <p>If there is a security manager, this method first\n+     * calls its {@code checkMulticast} method with the\n+     * {@code mcastaddr} argument as its argument.\n+     *\n+     * @apiNote\n+     *     The {@code mcastaddr} and {@code netIf} arguments should identify\n+     *     a multicast group that was previously {@linkplain\n+     *     #joinGroup(SocketAddress, NetworkInterface) joined} by\n+     *     this {@code DatagramSocket}.\n+     *\n+     * @param  mcastaddr is the multicast address to leave. This should\n+     *         contain the same IP address than that used for {@linkplain\n+     *         #joinGroup(SocketAddress, NetworkInterface) joining}\n+     *         the group.\n+     * @param  netIf specifies the local interface or {@code null} to defer\n+     *         to the interface set for outgoing multicast datagrams.\n+     *         If {@code null}, and no interface has been set, the behaviour\n+     *         is unspecified: any interface may be selected or the operation\n+     *         may fail with a {@code SocketException}.\n+     * @throws IOException if there is an error leaving or when the address\n+     *         is not a multicast address.\n+     * @throws SecurityException if a security manager exists and its\n+     *         {@code checkMulticast} method doesn't allow the operation.\n+     * @throws IllegalArgumentException if mcastaddr is {@code null} or is a\n+     *         SocketAddress subclass not supported by this socket.\n+     * @see    SecurityManager#checkMulticast(InetAddress)\n+     * @see    #joinGroup(SocketAddress, NetworkInterface)\n+     * @see    StandardSocketOptions#IP_MULTICAST_IF\n+     * @since  17\n+     *\/\n+    public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n+            throws IOException {\n+        delegate().leaveGroup(mcastaddr, netIf);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":286,"deletions":11,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * <PRE>\n+ * <PRE>{@code\n@@ -68,1 +68,1 @@\n- * <\/PRE>\n+ * }<\/PRE>\n@@ -89,32 +89,2 @@\n- * In addition to the socket options supported by\n- * <a href=\"DatagramSocket.html#SocketOptions\">{@code DatagramSocket}<\/a>, a\n- * {@code MulticastSocket} supports the following socket options:\n- * <blockquote>\n- * <a id=\"MulticastOptions\"><\/a>\n- * <table class=\"striped\">\n- * <caption style=\"display:none\">Socket options<\/caption>\n- * <thead>\n- *   <tr>\n- *     <th scope=\"col\">Option Name<\/th>\n- *     <th scope=\"col\">Description<\/th>\n- *   <\/tr>\n- * <\/thead>\n- * <tbody>\n- *   <tr>\n- *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#IP_MULTICAST_IF IP_MULTICAST_IF} <\/th>\n- *     <td> The network interface for Internet Protocol (IP) multicast datagrams <\/td>\n- *   <\/tr>\n- *   <tr>\n- *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#IP_MULTICAST_TTL\n- *       IP_MULTICAST_TTL} <\/th>\n- *     <td> The <em>time-to-live<\/em> for Internet Protocol (IP) multicast\n- *       datagrams <\/td>\n- *   <\/tr>\n- *   <tr>\n- *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP\n- *       IP_MULTICAST_LOOP} <\/th>\n- *     <td> Loopback for Internet Protocol (IP) multicast datagrams <\/td>\n- *   <\/tr>\n- * <\/tbody>\n- * <\/table>\n- * <\/blockquote>\n+ * <a id=\"MulticastOptions\"><\/a>The set of supported socket options\n+ * is defined in <a href=\"DatagramSocket.html#SocketOptions\">{@code DatagramSocket}<\/a>.\n@@ -123,1 +93,3 @@\n- * @apiNote {@link DatagramChannel} implements the {@link MulticastChannel} interface\n+ * @apiNote {@link DatagramSocket} may be used directly for\n+ *          sending and receiving multicast datagrams.\n+ *          {@link DatagramChannel} implements the {@link MulticastChannel} interface\n@@ -128,1 +100,2 @@\n- *          source-specific} multicast.\n+ *          source-specific} multicast. Consider using {@link DatagramChannel} for\n+ *          multicasting.\n@@ -246,1 +219,1 @@\n-     * @deprecated use the setTimeToLive method instead, which uses\n+     * @deprecated use the {@link #setTimeToLive(int)} method instead, which uses\n@@ -265,0 +238,4 @@\n+     * @apiNote\n+     * This method is equivalent to calling {@link #setOption(SocketOption, Object)\n+     * setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl)}.\n+     *\n@@ -273,0 +250,1 @@\n+     * @see StandardSocketOptions#IP_MULTICAST_TTL\n@@ -286,2 +264,2 @@\n-     * @deprecated use the getTimeToLive method instead, which returns\n-     * an <b>int<\/b> instead of a <b>byte<\/b>.\n+     * @deprecated use the {@link #getTimeToLive()} method instead,\n+     * which returns an <b>int<\/b> instead of a <b>byte<\/b>.\n@@ -298,0 +276,5 @@\n+     *\n+     * @apiNote\n+     * This method is equivalent to calling {@link #getOption(SocketOption)\n+     * getOption(StandardSocketOptions.IP_MULTICAST_TTL)}.\n+     *\n@@ -302,0 +285,1 @@\n+     * @see StandardSocketOptions#IP_MULTICAST_TTL\n@@ -316,0 +300,5 @@\n+     * @apiNote\n+     * Calling this method is equivalent to calling\n+     * {@link #joinGroup(SocketAddress, NetworkInterface)\n+     * joinGroup(new InetSocketAddress(mcastaddr, 0), null)}.\n+     *\n@@ -340,0 +329,5 @@\n+     * @apiNote\n+     * Calling this method is equivalent to calling\n+     * {@link #leaveGroup(SocketAddress, NetworkInterface)\n+     * leaveGroup(new InetSocketAddress(mcastaddr, 0), null)}.\n+     *\n@@ -356,22 +350,4 @@\n-     * Joins the specified multicast group at the specified interface.\n-     *\n-     * <p>If there is a security manager, this method first\n-     * calls its {@code checkMulticast} method\n-     * with the {@code mcastaddr} argument\n-     * as its argument.\n-     *\n-     * @param  mcastaddr is the multicast address to join\n-     * @param  netIf specifies the local interface to receive multicast\n-     *         datagram packets, or {@code null} to defer to the interface set by\n-     *         {@link MulticastSocket#setInterface(InetAddress)} or\n-     *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.\n-     *         If {@code null}, and no interface has been set, the behaviour is\n-     *         unspecified: any interface may be selected or the operation may fail\n-     *         with a {@code SocketException}.\n-     * @throws IOException if there is an error joining, or when the address\n-     *         is not a multicast address, or the platform does not support\n-     *         multicasting\n-     * @throws SecurityException if a security manager exists and its\n-     *         {@code checkMulticast} method doesn't allow the join.\n-     * @throws IllegalArgumentException if mcastaddr is {@code null} or is a\n-     *         SocketAddress subclass not supported by this socket\n+     * {@inheritDoc}\n+     * @throws IOException {@inheritDoc}\n+     * @throws SecurityException {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n@@ -380,1 +356,4 @@\n-     * @since  1.4\n+     * @see    StandardSocketOptions#IP_MULTICAST_IF\n+     * @see    #setNetworkInterface(NetworkInterface)\n+     * @see    #setInterface(InetAddress)\n+     * @since 1.4\n@@ -382,0 +361,1 @@\n+    @Override\n@@ -383,2 +363,2 @@\n-        throws IOException {\n-        delegate().joinGroup(mcastaddr, netIf);\n+            throws IOException {\n+        super.joinGroup(mcastaddr, netIf);\n@@ -388,20 +368,5 @@\n-     * Leave a multicast group on a specified local interface.\n-     *\n-     * <p>If there is a security manager, this method first\n-     * calls its {@code checkMulticast} method with the\n-     * {@code mcastaddr} argument as its argument.\n-     *\n-     * @param  mcastaddr is the multicast address to leave\n-     * @param  netIf specifies the local interface or {@code null} to defer\n-     *         to the interface set by\n-     *         {@link MulticastSocket#setInterface(InetAddress)} or\n-     *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.\n-     *         If {@code null}, and no interface has been set, the behaviour\n-     *         is unspecified: any interface may be selected or the operation\n-     *         may fail with a {@code SocketException}.\n-     * @throws IOException if there is an error leaving or when the address\n-     *         is not a multicast address.\n-     * @throws SecurityException if a security manager exists and its\n-     *         {@code checkMulticast} method doesn't allow the operation.\n-     * @throws IllegalArgumentException if mcastaddr is {@code null} or is a\n-     *         SocketAddress subclass not supported by this socket.\n+     * {@inheritDoc}\n+     * @apiNote {@inheritDoc}\n+     * @throws IOException {@inheritDoc}\n+     * @throws SecurityException {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n@@ -409,1 +374,2 @@\n-     * @since  1.4\n+     * @see    #joinGroup(SocketAddress, NetworkInterface)\n+     * @since 1.4\n@@ -411,0 +377,1 @@\n+    @Override\n@@ -412,3 +379,3 @@\n-        throws IOException {\n-        delegate().leaveGroup(mcastaddr, netIf);\n-     }\n+            throws IOException {\n+        super.leaveGroup(mcastaddr, netIf);\n+    }\n@@ -458,0 +425,4 @@\n+     * @apiNote\n+     * This method is equivalent to calling {@link #setOption(SocketOption, Object)\n+     * setOption(StandardSocketOptions.IP_MULTICAST_IF, netIf)}.\n+     *\n@@ -462,0 +433,1 @@\n+     * @see StandardSocketOptions#IP_MULTICAST_IF\n@@ -470,1 +442,7 @@\n-     * Get the multicast network interface set.\n+     * Get the multicast network interface set for outgoing multicast\n+     * datagrams sent from this socket.\n+     *\n+     * @apiNote\n+     * When an interface is set, this method is equivalent\n+     * to calling {@link #getOption(SocketOption)\n+     * getOption(StandardSocketOptions.IP_MULTICAST_IF)}.\n@@ -478,0 +456,1 @@\n+     * @see    StandardSocketOptions#IP_MULTICAST_IF\n@@ -567,3 +546,3 @@\n-     *  ......\n-     *  int ttl = mcastSocket.getTimeToLive();\n-     *  mcastSocket.setTimeToLive(newttl);\n+     *  <pre>{@code   ......\n+     *  int ttl = mcastSocket.getOption(StandardSocketOptions.IP_MULTICAST_TTL);\n+     *  mcastSocket.setOption(StandardSocketOptions.IP_MULTICAST_TTL, newttl);\n@@ -571,2 +550,2 @@\n-     *  mcastSocket.setTimeToLive(ttl);\n-     *  ......\n+     *  mcastSocket.setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);\n+     *  ......}<\/pre>\n","filename":"src\/java.base\/share\/classes\/java\/net\/MulticastSocket.java","additions":74,"deletions":95,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,4 +100,3 @@\n-            if (!preferIPv4Stack && !isMulticast)\n-                return new DualStackPlainDatagramSocketImpl(exclusiveBind);\n-            else\n-                return new TwoStacksPlainDatagramSocketImpl(exclusiveBind && !isMulticast, isMulticast);\n+            \/\/ Always use TwoStacksPlainDatagramSocketImpl since we need\n+            \/\/ to support multicasting at DatagramSocket level\n+            return new TwoStacksPlainDatagramSocketImpl(exclusiveBind && !isMulticast, isMulticast);\n","filename":"src\/java.base\/windows\/classes\/java\/net\/DefaultDatagramSocketImplFactory.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8237352\n+ * @summary Verifies that the examples using DatagramSocket for\n+ * sending and receiving multicast datagrams are functional.\n+ * See \"Multicasting with DatagramSocket\" API note in\n+ * DatagramSocket.java\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.net.IPSupport\n+ * @run main\/othervm DatagramSocketExample\n+ * @run main\/othervm -Djava.net.preferIPv4Stack=true DatagramSocketExample\n+ * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true DatagramSocketExample\n+ * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true -Djava.net.preferIPv4Stack=true DatagramSocketExample\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.ProtocolFamily;\n+import java.net.SocketAddress;\n+import java.net.SocketException;\n+import java.net.SocketOption;\n+import java.net.SocketTimeoutException;\n+import java.net.StandardSocketOptions;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.NetworkConfiguration;\n+import jdk.test.lib.net.IPSupport;\n+\n+import static java.net.StandardProtocolFamily.INET;\n+import static java.net.StandardProtocolFamily.INET6;\n+import static java.net.StandardSocketOptions.IP_MULTICAST_IF;\n+import static java.net.StandardSocketOptions.IP_MULTICAST_LOOP;\n+import static java.net.StandardSocketOptions.IP_MULTICAST_TTL;\n+import static java.net.StandardSocketOptions.SO_REUSEADDR;\n+\n+public class DatagramSocketExample {\n+    static final ProtocolFamily UNSPEC = () -> \"UNSPEC\";\n+\n+    public static void main(String[] args) throws IOException {\n+        IPSupport.throwSkippedExceptionIfNonOperational();\n+\n+        \/\/ IPv4 and IPv6 interfaces that support multicasting\n+        NetworkConfiguration config = NetworkConfiguration.probe();\n+        List<NetworkInterface> ip4MulticastInterfaces = config.ip4MulticastInterfaces()\n+                .collect(Collectors.toList());\n+        List<NetworkInterface> ip6MulticastInterfaces = config.ip6MulticastInterfaces()\n+                .collect(Collectors.toList());\n+\n+        \/\/ multicast groups used for the test\n+        InetAddress ip4Group = InetAddress.getByName(\"225.4.5.6\");\n+        InetAddress ip6Group = InetAddress.getByName(\"ff02::a\");\n+\n+        for (NetworkInterface ni : ip4MulticastInterfaces) {\n+            test(INET, ip4Group, ni);\n+            if (IPSupport.hasIPv6()) {\n+                test(UNSPEC, ip4Group, ni);\n+                test(INET6, ip4Group, ni);\n+            }\n+        }\n+        for (NetworkInterface ni : ip6MulticastInterfaces) {\n+            test(UNSPEC, ip6Group, ni);\n+            test(INET6, ip6Group, ni);\n+        }\n+    }\n+\n+    static void test(ProtocolFamily family, InetAddress mcastaddr, NetworkInterface ni)\n+        throws IOException\n+    {\n+        System.out.format(\"Test family=%s, multicast group=%s, interface=%s%n\",\n+            family.name(), mcastaddr, ni.getName());\n+\n+        \/\/ An instance of DatagramSocket can also be used to receive\n+        \/\/ multicast datagram packets. A DatagramSocket that is created\n+        \/\/ with the intent of receiving multicast datagrams should be\n+        \/\/ created unbound. Before binding the socket, setReuseAddress(true)\n+        \/\/ should be configured:\n+        try (DatagramSocket socket = new DatagramSocket(null); \/\/ unbound\n+             DatagramSocket sender = new DatagramSocket(new InetSocketAddress(0))) {\n+\n+            socket.setReuseAddress(true);\n+            socket.bind(new InetSocketAddress(0));\n+\n+            \/\/ joinGroup\n+            \/\/ InetAddress mcastaddr = InetAddress.getByName(\"228.5.6.7\");\n+            InetSocketAddress group = new InetSocketAddress(mcastaddr, 0);\n+            \/\/ NetworkInterface netIf = NetworkInterface.getByName(\"en0\");\n+            NetworkInterface netIf = ni;\n+\n+            socket.joinGroup(group, netIf);\n+            try {\n+                byte[] rcvBytes = new byte[1024]; \/\/ up to 1024 bytes\n+                DatagramPacket packet = new DatagramPacket(rcvBytes, rcvBytes.length);\n+\n+                \/\/ An instance of DatagramSocket can be used to send or receive\n+                \/\/ multicast datagram packets. Before sending out datagram packets,\n+                \/\/ the default outgoing interface for sending datagram packets\n+                \/\/ should be configured first using setOption and\n+                \/\/ StandardSocketOptions.IP_MULTICAST_IF:\n+\n+                \/\/ DatagramSocket sender = new DatagramSocket(new InetSocketAddress(0));\n+                \/\/ NetworkInterface outgoingIf = NetworkInterface.getByName(\"en0\");\n+                NetworkInterface outgoingIf = ni;\n+                sender.setOption(StandardSocketOptions.IP_MULTICAST_IF, outgoingIf);\n+\n+                \/\/ optionally configure multicast TTL\n+                int ttl = 1; \/\/ a number betwen 0 and 255\n+                sender.setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);\n+\n+                \/\/ send a packet to a multicast group\n+                byte[] msgBytes = \"Hello\".getBytes(StandardCharsets.UTF_8);\n+                int port = socket.getLocalPort();\n+                InetSocketAddress dest = new InetSocketAddress(mcastaddr, port);\n+                DatagramPacket hi = new DatagramPacket(msgBytes, msgBytes.length, dest);\n+                sender.send(hi);\n+\n+                socket.receive(packet);\n+                byte[] bytes = Arrays.copyOfRange(packet.getData(), 0, packet.getLength());\n+                assertTrue(\"Hello\".equals(new String(bytes, StandardCharsets.UTF_8)));\n+            } finally {\n+                \/\/ eventually leave group\n+                socket.leaveGroup(group, netIf);\n+            }\n+        }\n+\n+    }\n+\n+    static void assertTrue(boolean e) {\n+        if (!e) throw new RuntimeException();\n+    }\n+\n+    interface ThrowableRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    static void assertThrows(java.lang.Class<?> exceptionClass, ThrowableRunnable task) {\n+        try {\n+            task.run();\n+            throw new RuntimeException(\"Exception not thrown\");\n+        } catch (Exception e) {\n+            if (!exceptionClass.isInstance(e)) {\n+                throw new RuntimeException(\"expected: \" + exceptionClass + \", actual: \" + e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramSocketExample.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,380 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8237352\n+ * @summary Test DatagramSocket for sending and receiving multicast datagrams\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.net.IPSupport\n+ * @run main\/othervm DatagramSocketMulticasting\n+ * @run main\/othervm -Djava.net.preferIPv4Stack=true DatagramSocketMulticasting\n+ * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true DatagramSocketMulticasting\n+ * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true -Djava.net.preferIPv4Stack=true DatagramSocketMulticasting\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.ProtocolFamily;\n+import java.net.SocketAddress;\n+import java.net.SocketException;\n+import java.net.SocketOption;\n+import java.net.SocketTimeoutException;\n+import java.nio.channels.DatagramChannel;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.NetworkConfiguration;\n+import jdk.test.lib.net.IPSupport;\n+\n+import static java.net.StandardProtocolFamily.INET;\n+import static java.net.StandardProtocolFamily.INET6;\n+import static java.net.StandardSocketOptions.IP_MULTICAST_IF;\n+import static java.net.StandardSocketOptions.IP_MULTICAST_LOOP;\n+import static java.net.StandardSocketOptions.IP_MULTICAST_TTL;\n+import static java.net.StandardSocketOptions.SO_REUSEADDR;\n+\n+public class DatagramSocketMulticasting {\n+    static final ProtocolFamily UNSPEC = () -> \"UNSPEC\";\n+\n+    public static void main(String[] args) throws IOException {\n+        IPSupport.throwSkippedExceptionIfNonOperational();\n+\n+        \/\/ IPv4 and IPv6 interfaces that support multicasting\n+        NetworkConfiguration config = NetworkConfiguration.probe();\n+        List<NetworkInterface> ip4MulticastInterfaces = config.ip4MulticastInterfaces()\n+                .collect(Collectors.toList());\n+        List<NetworkInterface> ip6MulticastInterfaces = config.ip6MulticastInterfaces()\n+                .collect(Collectors.toList());\n+\n+        \/\/ multicast groups used for the test\n+        InetAddress ip4Group = InetAddress.getByName(\"225.4.5.6\");\n+        InetAddress ip6Group = InetAddress.getByName(\"ff02::a\");\n+\n+        for (NetworkInterface ni : ip4MulticastInterfaces) {\n+            test(INET, ip4Group, ni);\n+            if (IPSupport.hasIPv6()) {\n+                test(UNSPEC, ip4Group, ni);\n+                test(INET6, ip4Group, ni);\n+            }\n+        }\n+        for (NetworkInterface ni : ip6MulticastInterfaces) {\n+            test(UNSPEC, ip6Group, ni);\n+            test(INET6, ip6Group, ni);\n+        }\n+    }\n+\n+    static void test(ProtocolFamily family, InetAddress group, NetworkInterface ni)\n+        throws IOException\n+    {\n+        System.out.format(\"Test family=%s, multicast group=%s, interface=%s%n\",\n+            family.name(), group, ni.getName());\n+\n+        \/\/ test 2-arg joinGroup\/leaveGroup\n+        try (DatagramSocket s = create()) {\n+            testJoinGroup2(family, s, group, ni);\n+        }\n+\n+        \/\/ test socket options\n+        try (DatagramSocket s = create()) {\n+            testNetworkInterface(s, ni);\n+            testTimeToLive(s);\n+            testLoopbackMode(s);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a MulticastSocket. The SO_REUSEADDR socket option is set and it\n+     * is bound to the wildcard address.\n+     *\/\n+    static DatagramSocket create() throws IOException {\n+        DatagramSocket ds = new DatagramSocket(null);\n+        try {\n+            ds.setOption(SO_REUSEADDR, true).bind(new InetSocketAddress(0));\n+        } catch (IOException ioe) {\n+            ds.close();\n+            throw ioe;\n+        }\n+        return ds;\n+    }\n+\n+    \/**\n+     * Test 2-arg joinGroup\/leaveGroup\n+     *\/\n+    static void testJoinGroup2(ProtocolFamily family,\n+                               DatagramSocket s,\n+                               InetAddress group,\n+                               NetworkInterface ni) throws IOException {\n+\n+        System.out.format(\"testJoinGroup2: local socket address: %s%n\", s.getLocalSocketAddress());\n+\n+        \/\/ check network interface not set\n+        assertTrue(s.getOption(IP_MULTICAST_IF) == null);\n+\n+        \/\/ join on default interface\n+        s.joinGroup(new InetSocketAddress(group, 0), null);\n+\n+        \/\/ join should not change the outgoing multicast interface\n+        assertTrue(s.getOption(IP_MULTICAST_IF) == null);\n+\n+        \/\/ already a member (exception not specified)\n+        assertThrows(SocketException.class,\n+                     () -> s.joinGroup(new InetSocketAddress(group, 0), null));\n+\n+        \/\/ leave\n+        s.leaveGroup(new InetSocketAddress(group, 0), null);\n+\n+        \/\/ not a member (exception not specified)\n+        assertThrows(SocketException.class,\n+                     () -> s.leaveGroup(new InetSocketAddress(group, 0), null));\n+\n+        \/\/ join on specified interface\n+        s.joinGroup(new InetSocketAddress(group, 0), ni);\n+\n+        \/\/ join should not change the outgoing multicast interface\n+        assertTrue(s.getOption(IP_MULTICAST_IF) == null);\n+\n+        \/\/ already a member (exception not specified)\n+        assertThrows(SocketException.class,\n+                     () -> s.joinGroup(new InetSocketAddress(group, 0), ni));\n+\n+        \/\/ leave\n+        s.leaveGroup(new InetSocketAddress(group, 0), ni);\n+\n+        \/\/ not a member (exception not specified)\n+        assertThrows(SocketException.class,\n+                     () -> s.leaveGroup(new InetSocketAddress(group, 0), ni));\n+\n+        \/\/ join\/leave with outgoing multicast interface set and check that\n+        \/\/ multicast datagrams can be sent and received\n+        s.setOption(IP_MULTICAST_IF, ni);\n+        s.joinGroup(new InetSocketAddress(group, 0), null);\n+        testSendReceive(s, group);\n+        s.leaveGroup(new InetSocketAddress(group, 0), null);\n+        testSendNoReceive(s, group);\n+        s.joinGroup(new InetSocketAddress(group, 0), ni);\n+        testSendReceive(s, group);\n+        s.leaveGroup(new InetSocketAddress(group, 0), ni);\n+        testSendNoReceive(s, group);\n+\n+        \/\/ not a multicast address\n+        var localHost = InetAddress.getLocalHost();\n+        assertThrows(SocketException.class,\n+                     () -> s.joinGroup(new InetSocketAddress(localHost, 0), null));\n+        assertThrows(SocketException.class,\n+                     () -> s.leaveGroup(new InetSocketAddress(localHost, 0), null));\n+        assertThrows(SocketException.class,\n+                     () -> s.joinGroup(new InetSocketAddress(localHost, 0), ni));\n+        assertThrows(SocketException.class,\n+                     () -> s.leaveGroup(new InetSocketAddress(localHost, 0), ni));\n+\n+        \/\/ not an InetSocketAddress\n+        var customSocketAddress = new SocketAddress() { };\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> s.joinGroup(customSocketAddress, null));\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> s.leaveGroup(customSocketAddress, null));\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> s.joinGroup(customSocketAddress, ni));\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> s.leaveGroup(customSocketAddress, ni));\n+\n+        \/\/ IPv4 socket cannot join IPv6 group\n+        if (family == INET && !IPSupport.hasIPv6()) {\n+            System.out.println(\"Test IPv4 can't join IPv6\");\n+            InetAddress ip6Group = InetAddress.getByName(\"ff02::a\");\n+            assertThrows(IllegalArgumentException.class,\n+                         () -> s.joinGroup(new InetSocketAddress(ip6Group, 0), null));\n+            assertThrows(IllegalArgumentException.class,\n+                         () -> s.joinGroup(new InetSocketAddress(ip6Group, 0), ni));\n+\n+            \/\/ not a member of IPv6 group (exception not specified)\n+            assertThrows(SocketException.class,\n+                         () -> s.leaveGroup(new InetSocketAddress(ip6Group, 0), null));\n+            assertThrows(SocketException.class,\n+                         () -> s.leaveGroup(new InetSocketAddress(ip6Group, 0), ni));\n+        }\n+\n+        \/\/ null\n+        assertThrows(IllegalArgumentException.class, () -> s.joinGroup(null, null));\n+        assertThrows(IllegalArgumentException.class, () -> s.leaveGroup(null, null));\n+        assertThrows(IllegalArgumentException.class, () -> s.joinGroup(null, ni));\n+        assertThrows(IllegalArgumentException.class, () -> s.leaveGroup(null, ni));\n+    }\n+\n+    \/**\n+     * Test getNetworkInterface\/setNetworkInterface\/getInterface\/setInterface\n+     * and IP_MULTICAST_IF socket option.\n+     *\/\n+    static void testNetworkInterface(DatagramSocket s,\n+                                     NetworkInterface ni) throws IOException {\n+        \/\/ default value\n+        assertTrue(s.getOption(IP_MULTICAST_IF) == null);\n+\n+        \/\/ setOption(IP_MULTICAST_IF)\n+        s.setOption(IP_MULTICAST_IF, ni);\n+        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n+\n+        \/\/ bad values for IP_MULTICAST_IF\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> s.setOption(IP_MULTICAST_IF, null));\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> s.setOption((SocketOption) IP_MULTICAST_IF, \"badValue\"));\n+    }\n+\n+    \/**\n+     * Test getTimeToLive\/setTimeToLive\/getTTL\/getTTL and IP_MULTICAST_TTL socket\n+     * option.\n+     *\/\n+    static void testTimeToLive(DatagramSocket s) throws IOException {\n+        \/\/ should be 1 by default\n+        assertTrue(s.getOption(IP_MULTICAST_TTL) == 1);\n+\n+        \/\/ setOption(IP_MULTICAST_TTL)\n+        for (int ttl = 0; ttl <= 2; ttl++) {\n+            s.setOption(IP_MULTICAST_TTL, ttl);\n+            assertTrue(s.getOption(IP_MULTICAST_TTL) == ttl);\n+        }\n+\n+        \/\/ bad values for IP_MULTICAST_TTL\n+        assertThrows(IllegalArgumentException.class,\n+                    () -> s.setOption(IP_MULTICAST_TTL, -1));\n+        assertThrows(IllegalArgumentException.class,\n+                    () -> s.setOption(IP_MULTICAST_TTL, null));\n+        assertThrows(IllegalArgumentException.class,\n+                    () -> s.setOption((SocketOption) IP_MULTICAST_TTL, \"badValue\"));\n+    }\n+\n+    \/**\n+     * Test getLoopbackMode\/setLoopbackMode and IP_MULTICAST_LOOP socket option.\n+     *\/\n+    static void testLoopbackMode(DatagramSocket s) throws IOException {\n+        \/\/ should be enabled by default\n+        assertTrue(s.getOption(IP_MULTICAST_LOOP) == true);\n+\n+        \/\/ setLoopbackMode\n+\n+        \/\/ setOption(IP_MULTICAST_LOOP)\n+        s.setOption(IP_MULTICAST_LOOP, false);   \/\/ disable\n+        assertTrue(s.getOption(IP_MULTICAST_LOOP) == false);\n+        s.setOption(IP_MULTICAST_LOOP, true);  \/\/ enable\n+        assertTrue(s.getOption(IP_MULTICAST_LOOP) == true);\n+\n+        \/\/ bad values for IP_MULTICAST_LOOP\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> s.setOption(IP_MULTICAST_LOOP, null));\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> s.setOption((SocketOption) IP_MULTICAST_LOOP, \"badValue\"));\n+    }\n+\n+    \/**\n+     * Send a datagram to the given multicast group and check that it is received.\n+     *\/\n+    static void testSendReceive(DatagramSocket s, InetAddress group) throws IOException {\n+\n+        System.out.println(\"testSendReceive\");\n+\n+        \/\/ outgoing multicast interface needs to be set\n+        assertTrue(s.getOption(IP_MULTICAST_IF) != null);\n+\n+        SocketAddress target = new InetSocketAddress(group, s.getLocalPort());\n+        byte[] message = \"hello\".getBytes(\"UTF-8\");\n+\n+        \/\/ send message to multicast group\n+        DatagramPacket p = new DatagramPacket(message, message.length);\n+        p.setSocketAddress(target);\n+        s.send(p);\n+\n+        \/\/ receive message\n+        s.setSoTimeout(0);\n+        p = new DatagramPacket(new byte[1024], 100);\n+        s.receive(p);\n+\n+        assertTrue(p.getLength() == message.length);\n+        assertTrue(p.getPort() == s.getLocalPort());\n+    }\n+\n+    \/**\n+     * Send a datagram to the given multicast group and check that it is not\n+     * received.\n+     *\/\n+    static void testSendNoReceive(DatagramSocket s, InetAddress group) throws IOException {\n+\n+        System.out.println(\"testSendNoReceive\");\n+\n+        \/\/ outgoing multicast interface needs to be set\n+        assertTrue(s.getOption(IP_MULTICAST_IF) != null);\n+\n+        SocketAddress target = new InetSocketAddress(group, s.getLocalPort());\n+        long nano = System.nanoTime();\n+        String text = nano + \": hello\";\n+        byte[] message = text.getBytes(\"UTF-8\");\n+\n+        \/\/ send datagram to multicast group\n+        DatagramPacket p = new DatagramPacket(message, message.length);\n+        p.setSocketAddress(target);\n+        s.send(p);\n+\n+        \/\/ datagram should not be received\n+        s.setSoTimeout(500);\n+        p = new DatagramPacket(new byte[1024], 100);\n+        while (true) {\n+            try {\n+                s.receive(p);\n+                if (Arrays.equals(p.getData(), p.getOffset(), p.getLength(), message, 0, message.length)) {\n+                    throw new RuntimeException(\"message shouldn't have been received\");\n+                } else {\n+                    System.out.format(\"Received unexpected message from %s%n\", p.getSocketAddress());\n+                }\n+            } catch (SocketTimeoutException expected) {\n+                break;\n+            }\n+        }\n+    }\n+\n+\n+    static void assertTrue(boolean e) {\n+        if (!e) throw new RuntimeException();\n+    }\n+\n+    interface ThrowableRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    static void assertThrows(Class<?> exceptionClass, ThrowableRunnable task) {\n+        try {\n+            task.run();\n+            throw new RuntimeException(\"Exception not thrown\");\n+        } catch (Exception e) {\n+            if (!exceptionClass.isInstance(e)) {\n+                throw new RuntimeException(\"expected: \" + exceptionClass + \", actual: \" + e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramSocketMulticasting.java","additions":380,"deletions":0,"binary":false,"changes":380,"status":"added"}]}