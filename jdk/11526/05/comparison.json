{"files":[{"patch":"@@ -30,0 +30,2 @@\n+#include \"metaprogramming\/removeCV.hpp\"\n+#include \"metaprogramming\/removePointer.hpp\"\n@@ -64,1 +66,1 @@\n-  static void free_metadata(ClassLoaderData* loader_data, T md) {\n+  static void free_metadata(ClassLoaderData* loader_data, T md, bool invoke_destructor = false) {\n@@ -72,1 +74,11 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size, md->is_klass());\n+      bool is_klass = md->is_klass();\n+      \/\/ If requested, call the destructor. This is currently used for MethodData which has a member\n+      \/\/ that needs to be destructed to release resources. Most Metadata derived classes have noop\n+      \/\/ destructors and\/or cleanup using deallocate_contents.\n+      if (invoke_destructor) {\n+        \/\/ T is a potentially const or volatile qualified pointer. Remove the pointer and any const\n+        \/\/ or volatile so we can call the destructor of the type T points to.\n+        using U = typename RemoveCV<typename RemovePointer<T>::type>::type;\n+        md->~U();\n+      }\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size, is_klass);\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  MetadataFactory::free_metadata(loader_data, method_data());\n+  MetadataFactory::free_metadata(loader_data, method_data(), \/*invoke_destructor*\/ true);\n@@ -147,2 +147,0 @@\n-    \/\/ Destroy MethodData\n-    method_data()->~MethodData();\n@@ -602,1 +600,1 @@\n-    MetadataFactory::free_metadata(loader_data, method_data);\n+    MetadataFactory::free_metadata(loader_data, method_data, \/*invoke_destructor*\/ true);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}