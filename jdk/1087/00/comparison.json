{"files":[{"patch":"@@ -18925,0 +18925,210 @@\n+instruct vsraa8B_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (8B)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 8) sh = 7;\n+    __ ssra(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src$$reg), sh);\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsraa16B_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 16);\n+  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (16B)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 8) sh = 7;\n+    __ ssra(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg), sh);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsraa4S_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (4H)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 16) sh = 15;\n+    __ ssra(as_FloatRegister($dst$$reg), __ T4H,\n+           as_FloatRegister($src$$reg), sh);\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsraa8S_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (8H)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 16) sh = 15;\n+    __ ssra(as_FloatRegister($dst$$reg), __ T8H,\n+           as_FloatRegister($src$$reg), sh);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsraa2I_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (2S)\" %}\n+  ins_encode %{\n+    __ ssra(as_FloatRegister($dst$$reg), __ T2S,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsraa4I_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (4S)\" %}\n+  ins_encode %{\n+    __ ssra(as_FloatRegister($dst$$reg), __ T4S,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsraa2L_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (AddVL dst (RShiftVL src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (2D)\" %}\n+  ins_encode %{\n+    __ ssra(as_FloatRegister($dst$$reg), __ T2D,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsrla8B_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (8B)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 8) {\n+      __ eor(as_FloatRegister($src$$reg), __ T8B,\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    } else {\n+      __ usra(as_FloatRegister($dst$$reg), __ T8B,\n+             as_FloatRegister($src$$reg), sh);\n+    }\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsrla16B_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 16);\n+  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (16B)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 8) {\n+      __ eor(as_FloatRegister($src$$reg), __ T16B,\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    } else {\n+      __ usra(as_FloatRegister($dst$$reg), __ T16B,\n+             as_FloatRegister($src$$reg), sh);\n+    }\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsrla4S_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (4H)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 16) {\n+      __ eor(as_FloatRegister($src$$reg), __ T8B,\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    } else {\n+      __ ushr(as_FloatRegister($dst$$reg), __ T4H,\n+             as_FloatRegister($src$$reg), sh);\n+    }\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsrla8S_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (8H)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 16) {\n+      __ eor(as_FloatRegister($src$$reg), __ T16B,\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    } else {\n+      __ usra(as_FloatRegister($dst$$reg), __ T8H,\n+             as_FloatRegister($src$$reg), sh);\n+    }\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsrla2I_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (2S)\" %}\n+  ins_encode %{\n+    __ usra(as_FloatRegister($dst$$reg), __ T2S,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsrla4I_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (4S)\" %}\n+  ins_encode %{\n+    __ usra(as_FloatRegister($dst$$reg), __ T4S,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsrla2L_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (AddVL dst (URShiftVL src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (2D)\" %}\n+  ins_encode %{\n+    __ usra(as_FloatRegister($dst$$reg), __ T2D,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":210,"deletions":0,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -2691,0 +2691,2 @@\n+  INSN(usra, 1, 0b000101, \/* isSHR = *\/ true);\n+  INSN(ssra, 0, 0b000101, \/* isSHAR =*\/ true);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2020, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class VectorShiftAccumulate {\n+    @Param({\"1028\"})\n+    public int count;\n+\n+    private byte[]  bytesA,  bytesB,  bytesD;\n+    private short[] shortsA, shortsB, shortsD;\n+    private char[]  charsA,  charsB,  charsD;\n+    private int[]   intsA,   intsB,   intsD;\n+    private long[]  longsA,  longsB,  longsD;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        bytesA  = new byte[count];\n+        shortsA = new short[count];\n+        charsA  = new char[count];\n+        intsA   = new int[count];\n+        longsA  = new long[count];\n+\n+        bytesB  = new byte[count];\n+        shortsB = new short[count];\n+        charsB  = new char[count];\n+        intsB   = new int[count];\n+        longsB  = new long[count];\n+\n+        bytesD  = new byte[count];\n+        shortsD = new short[count];\n+        charsD  = new char[count];\n+        intsD   = new int[count];\n+        longsD  = new long[count];\n+\n+        for (int i = 0; i < count; i++) {\n+            bytesA[i]  = (byte) r.nextInt();\n+            shortsA[i] = (short) r.nextInt();\n+            intsA[i]   = r.nextInt();\n+            longsA[i]  = r.nextLong();\n+\n+            bytesB[i]  = (byte) r.nextInt();\n+            shortsB[i] = (short) r.nextInt();\n+            intsB[i]   = r.nextInt();\n+            longsB[i]  = r.nextLong();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftRightAccumulateByte() {\n+        for (int i = 0; i < count; i++) {\n+            bytesD[i] = (byte) (bytesA[i] + (bytesB[i] >> 1));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftURightAccumulateByte() {\n+        for (int i = 0; i < count; i++) {\n+            bytesD[i] = (byte) (bytesA[i] + (((byte) (bytesB[i] >>> 3))));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftRightAccumulateShort() {\n+        for (int i = 0; i < count; i++) {\n+            shortsD[i] = (short) (shortsA[i] + (shortsB[i] >> 5));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftURightAccumulateChar() {\n+        for (int i = 0; i < count; i++) {\n+            charsD[i] = (char) (charsA[i] + (charsB[i] >>> 4));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftRightAccumulateInt() {\n+        for (int i = 0; i < count; i++) {\n+            intsD[i] = intsA[i] + (intsB[i] >> 2);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftURightAccumulateInt() {\n+        for (int i = 0; i < count; i++) {\n+            intsD[i] = (intsB[i] >>> 2) + intsA[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftRightAccumulateLong() {\n+        for (int i = 0; i < count; i++) {\n+            longsD[i] = longsA[i] + (longsB[i] >> 5);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftURightAccumulateLong() {\n+        for (int i = 0; i < count; i++) {\n+            longsD[i] = (longsB[i] >>> 2) + longsA[i];\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorShiftAccumulate.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}