{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import static java.math.BigInteger.*;\n@@ -51,0 +52,10 @@\n+    private static final BigInteger SQRT_2048;\n+    private static final BigInteger SQRT_3072;\n+    private static final BigInteger SQRT_4096;\n+\n+    static {\n+        SQRT_2048 = TWO.pow(2047).sqrt();\n+        SQRT_3072 = TWO.pow(3071).sqrt();\n+        SQRT_4096 = TWO.pow(4095).sqrt();\n+    }\n+\n@@ -63,0 +74,4 @@\n+    \/\/ whether to generate key pairs following the new guidelines from\n+    \/\/ FIPS 186-4 and later\n+    private boolean useNew;\n+\n@@ -89,1 +104,1 @@\n-        BigInteger tmpPublicExponent = rsaSpec.getPublicExponent();\n+        BigInteger tmpPubExp = rsaSpec.getPublicExponent();\n@@ -92,2 +107,6 @@\n-        if (tmpPublicExponent == null) {\n-            tmpPublicExponent = RSAKeyGenParameterSpec.F4;\n+        \/\/ use the new approach for even key sizes >= 2048 AND when the\n+        \/\/ public exponent is within FIPS valid range\n+        boolean useNew = (tmpKeySize >= 2048 && ((tmpKeySize & 1) == 0));\n+\n+        if (tmpPubExp == null) {\n+            tmpPubExp = RSAKeyGenParameterSpec.F4;\n@@ -95,1 +114,1 @@\n-            if (tmpPublicExponent.compareTo(RSAKeyGenParameterSpec.F0) < 0) {\n+            if (!tmpPubExp.testBit(0)) {\n@@ -97,1 +116,1 @@\n-                        (\"Public exponent must be 3 or larger\");\n+                    (\"Public exponent must be an odd number\");\n@@ -99,1 +118,6 @@\n-            if (!tmpPublicExponent.testBit(0)) {\n+            \/\/ current impl checks that  F0 <= e < 2^keysize\n+            \/\/ vs FIPS 186-4 checks that F4 <= e < 2^256\n+            \/\/ for backward compatibility, we keep the same checks\n+            BigInteger minValue = RSAKeyGenParameterSpec.F0;\n+            int maxBitLength = tmpKeySize;\n+            if (tmpPubExp.compareTo(RSAKeyGenParameterSpec.F0) < 0) {\n@@ -101,1 +125,1 @@\n-                        (\"Public exponent must be an odd number\");\n+                        (\"Public exponent must be \" + minValue + \" or larger\");\n@@ -103,1 +127,1 @@\n-            if (tmpPublicExponent.bitLength() > tmpKeySize) {\n+            if (tmpPubExp.bitLength() > maxBitLength) {\n@@ -105,1 +129,2 @@\n-                        (\"Public exponent must be smaller than key size\");\n+                        (\"Public exponent must be no longer than \" +\n+                        maxBitLength + \" bits\");\n@@ -107,0 +132,2 @@\n+            useNew &= ((tmpPubExp.compareTo(RSAKeyGenParameterSpec.F4) >= 0) &&\n+                    (tmpPubExp.bitLength() < 256));\n@@ -111,2 +138,2 @@\n-            RSAKeyFactory.checkKeyLengths(tmpKeySize, tmpPublicExponent,\n-                512, 64 * 1024);\n+            RSAKeyFactory.checkKeyLengths(tmpKeySize, tmpPubExp, 512,\n+                    64 * 1024);\n@@ -126,2 +153,3 @@\n-        this.publicExponent = tmpPublicExponent;\n-        this.random = random;\n+        this.publicExponent = tmpPubExp;\n+        this.random = (random == null? JCAUtil.getSecureRandom() : random);\n+        this.useNew = useNew;\n@@ -130,1 +158,2 @@\n-    \/\/ generate the keypair. See JCA doc\n+    \/\/ FIPS 186-4 B.3.3 \/ FIPS 186-5 A.1.3\n+    \/\/ Generation of Random Primes that are Probably Prime\n@@ -132,6 +161,0 @@\n-        \/\/ accommodate odd key sizes in case anybody wants to use them\n-        int lp = (keySize + 1) >> 1;\n-        int lq = keySize - lp;\n-        if (random == null) {\n-            random = JCAUtil.getSecureRandom();\n-        }\n@@ -139,0 +162,5 @@\n+        BigInteger minValue = (useNew? getSqrt(keySize) : ZERO);\n+        int lp = (keySize + 1) >> 1;;\n+        int lq = keySize - lp;\n+        int pqDiffSize = lp - 100;\n+\n@@ -140,10 +168,10 @@\n-            \/\/ generate two random primes of size lp\/lq\n-            BigInteger p = BigInteger.probablePrime(lp, random);\n-            BigInteger q, n;\n-            do {\n-                q = BigInteger.probablePrime(lq, random);\n-                \/\/ convention is for p > q\n-                if (p.compareTo(q) < 0) {\n-                    BigInteger tmp = p;\n-                    p = q;\n-                    q = tmp;\n+            BigInteger p = null;\n+            BigInteger q = null;\n+\n+            int i = 0;\n+            while (i++ < 10*lp) {\n+                BigInteger tmpP = BigInteger.probablePrime(lp, random);\n+                if ((!useNew || tmpP.compareTo(minValue) == 1) &&\n+                        isRelativePrime(e, tmpP.subtract(ONE))) {\n+                    p = tmpP;\n+                    break;\n@@ -151,15 +179,0 @@\n-                \/\/ modulus n = p * q\n-                n = p.multiply(q);\n-                \/\/ even with correctly sized p and q, there is a chance that\n-                \/\/ n will be one bit short. re-generate the smaller prime if so\n-            } while (n.bitLength() < keySize);\n-\n-            \/\/ phi = (p - 1) * (q - 1) must be relative prime to e\n-            \/\/ otherwise RSA just won't work ;-)\n-            BigInteger p1 = p.subtract(BigInteger.ONE);\n-            BigInteger q1 = q.subtract(BigInteger.ONE);\n-            BigInteger phi = p1.multiply(q1);\n-            \/\/ generate new p and q until they work. typically\n-            \/\/ the first try will succeed when using F4\n-            if (e.gcd(phi).equals(BigInteger.ONE) == false) {\n-                continue;\n@@ -167,0 +180,5 @@\n+            if (p == null) {\n+                throw new ProviderException(\"Cannot find prime P\");\n+            }\n+\n+            i = 0;\n@@ -168,21 +186,20 @@\n-            \/\/ private exponent d is the inverse of e mod phi\n-            BigInteger d = e.modInverse(phi);\n-\n-            \/\/ 1st prime exponent pe = d mod (p - 1)\n-            BigInteger pe = d.mod(p1);\n-            \/\/ 2nd prime exponent qe = d mod (q - 1)\n-            BigInteger qe = d.mod(q1);\n-\n-            \/\/ crt coefficient coeff is the inverse of q mod p\n-            BigInteger coeff = q.modInverse(p);\n-\n-            try {\n-                PublicKey publicKey = new RSAPublicKeyImpl(type, keyParams,\n-                        n, e);\n-                PrivateKey privateKey = new RSAPrivateCrtKeyImpl(type,\n-                        keyParams, n, e, d, p, q, pe, qe, coeff);\n-                return new KeyPair(publicKey, privateKey);\n-            } catch (InvalidKeyException exc) {\n-                \/\/ invalid key exception only thrown for keys < 512 bit,\n-                \/\/ will not happen here\n-                throw new RuntimeException(exc);\n+            while (i++ < 20*lq) {\n+                BigInteger tmpQ = BigInteger.probablePrime(lq, random);\n+\n+                if ((!useNew || tmpQ.compareTo(minValue) == 1) &&\n+                        (p.subtract(tmpQ).abs().compareTo\n+                                (TWO.pow(pqDiffSize)) == 1) &&\n+                        isRelativePrime(e, tmpQ.subtract(ONE))) {\n+                    q = tmpQ;\n+                    break;\n+                }\n+            }\n+            if (q == null) {\n+                throw new ProviderException(\"Cannot find prime Q\");\n+            }\n+\n+            BigInteger n = p.multiply(q);\n+            if (n.bitLength() != keySize) {\n+                \/\/ regenerate P, Q if n is not the right length; should\n+                \/\/ never happen for the new case but check it anyway\n+                continue;\n@@ -190,0 +207,69 @@\n+\n+            KeyPair kp = createKeyPair(type, keyParams, n, e, p, q);\n+            \/\/ done, return the generated keypair;\n+            if (kp != null) return kp;\n+        }\n+    }\n+\n+    private static BigInteger getSqrt(int keySize) {\n+        BigInteger sqrt = null;\n+        switch (keySize) {\n+            case 2048:\n+                sqrt = SQRT_2048;\n+                break;\n+            case 3072:\n+                sqrt = SQRT_3072;\n+                break;\n+            case 4096:\n+                sqrt = SQRT_4096;\n+                break;\n+            default:\n+                sqrt = TWO.pow(keySize-1).sqrt();\n+        }\n+        return sqrt;\n+    }\n+\n+    private static boolean isRelativePrime(BigInteger e, BigInteger bi) {\n+        \/\/ optimize for common known public exponent prime values\n+        if (e.compareTo(RSAKeyGenParameterSpec.F4) == 0 ||\n+                e.compareTo(RSAKeyGenParameterSpec.F0) == 0) {\n+            return !bi.mod(e).equals(ZERO);\n+        } else {\n+            return e.gcd(bi).equals(ONE);\n+        }\n+    }\n+\n+    private static KeyPair createKeyPair(KeyType type,\n+            AlgorithmParameterSpec keyParams,\n+            BigInteger n, BigInteger e, BigInteger p, BigInteger q) {\n+        \/\/ phi = (p - 1) * (q - 1) must be relative prime to e\n+        \/\/ otherwise RSA just won't work ;-)\n+        BigInteger p1 = p.subtract(ONE);\n+        BigInteger q1 = q.subtract(ONE);\n+        BigInteger phi = p1.multiply(q1);\n+\n+        BigInteger gcd = p1.gcd(q1);\n+        BigInteger lcm = (gcd.equals(ONE)?  phi : phi.divide(gcd));\n+\n+        BigInteger d = e.modInverse(lcm);\n+\n+        if (d.compareTo(TWO.pow(p.bitLength())) != 1) {\n+            return null;\n+        }\n+\n+        \/\/ 1st prime exponent pe = d mod (p - 1)\n+        BigInteger pe = d.mod(p1);\n+        \/\/ 2nd prime exponent qe = d mod (q - 1)\n+        BigInteger qe = d.mod(q1);\n+        \/\/ crt coefficient coeff is the inverse of q mod p\n+        BigInteger coeff = q.modInverse(p);\n+\n+        try {\n+            PublicKey publicKey = new RSAPublicKeyImpl(type, keyParams, n, e);\n+            PrivateKey privateKey = new RSAPrivateCrtKeyImpl(\n+                type, keyParams, n, e, d, p, q, pe, qe, coeff);\n+            return new KeyPair(publicKey, privateKey);\n+        } catch (InvalidKeyException exc) {\n+            \/\/ invalid key exception only thrown for keys < 512 bit,\n+            \/\/ will not happen here\n+            throw new RuntimeException(exc);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyPairGenerator.java","additions":152,"deletions":66,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main SpecTest 1024 3\n+ * @run main SpecTest 1024 167971\n","filename":"test\/jdk\/sun\/security\/rsa\/SpecTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}