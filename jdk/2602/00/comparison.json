{"files":[{"patch":"@@ -39,1 +39,0 @@\n-volatile bool GCLocker::_doing_gc       = false;\n@@ -130,6 +129,10 @@\n-  \/\/ Block entering threads if we know at least one thread is in a\n-  \/\/ JNI critical region and we need a GC.\n-  \/\/ We check that at least one thread is in a critical region before\n-  \/\/ blocking because blocked threads are woken up by a thread exiting\n-  \/\/ a JNI critical region.\n-  while (is_active_and_needs_gc() || _doing_gc) {\n+  \/\/ Block entering threads if there's a pending GC request.\n+  while (needs_gc()) {\n+    \/\/ There's at least one thread that has not left the critical region (CR)\n+    \/\/ completely. When that last thread (no new threads can enter CR due to the\n+    \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n+    \/\/ to false and wakes up all blocked threads.\n+    \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n+    \/\/ in the code, but it's too strong; it's possible that the last thread\n+    \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n+    \/\/ a GCCause::_gc_locker GC.\n@@ -157,1 +160,0 @@\n-    _doing_gc = true;\n@@ -165,1 +167,0 @@\n-    _doing_gc = false;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-                                         \/\/ note: bool is typedef'd as jint\n-  static volatile bool _doing_gc;        \/\/ unlock_critical() is doing a GC\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}