{"files":[{"patch":"@@ -55,0 +55,1 @@\n+#include \"gc\/g1\/g1PeriodicGCTask.hpp\"\n@@ -1393,0 +1394,1 @@\n+  _periodic_gc_task(NULL),\n@@ -1692,0 +1694,4 @@\n+  \/\/ Create and schedule the periodic gc task on the service thread.\n+  _periodic_gc_task = new G1PeriodicGCTask(\"Periodic GC Task\");\n+  _service_thread->register_task(_periodic_gc_task);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+class G1ServiceTask;\n@@ -157,0 +158,1 @@\n+  G1ServiceTask* _periodic_gc_task;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n+#include \"gc\/g1\/g1ConcurrentMarkThread.inline.hpp\"\n+#include \"gc\/g1\/g1PeriodicGCTask.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+bool G1PeriodicGCTask::should_start_periodic_gc() {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  \/\/ If we are currently in a concurrent mark we are going to uncommit memory soon.\n+  if (g1h->concurrent_mark()->cm_thread()->in_progress()) {\n+    log_debug(gc, periodic)(\"Concurrent cycle in progress. Skipping.\");\n+    return false;\n+  }\n+\n+  \/\/ Check if enough time has passed since the last GC.\n+  uintx time_since_last_gc = (uintx)g1h->time_since_last_collection().milliseconds();\n+  if ((time_since_last_gc < G1PeriodicGCInterval)) {\n+    log_debug(gc, periodic)(\"Last GC occurred \" UINTX_FORMAT \"ms before which is below threshold \" UINTX_FORMAT \"ms. Skipping.\",\n+                            time_since_last_gc, G1PeriodicGCInterval);\n+    return false;\n+  }\n+\n+  \/\/ Check if load is lower than max.\n+  double recent_load;\n+  if ((G1PeriodicGCSystemLoadThreshold > 0.0f) &&\n+      (os::loadavg(&recent_load, 1) == -1 || recent_load > G1PeriodicGCSystemLoadThreshold)) {\n+    log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n+                            recent_load, G1PeriodicGCSystemLoadThreshold);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void G1PeriodicGCTask::check_for_periodic_gc() {\n+  \/\/ If disabled, just return.\n+  if (G1PeriodicGCInterval == 0) {\n+    return;\n+  }\n+\n+  log_debug(gc, periodic)(\"Checking for periodic GC.\");\n+  if (should_start_periodic_gc()) {\n+    if (!G1CollectedHeap::heap()->try_collect(GCCause::_g1_periodic_collection)) {\n+      log_debug(gc, periodic)(\"GC request denied. Skipping.\");\n+    }\n+  }\n+}\n+\n+G1PeriodicGCTask::G1PeriodicGCTask(const char* name) :\n+  G1ServiceTask(name) { }\n+\n+void G1PeriodicGCTask::execute() {\n+  check_for_periodic_gc();\n+  \/\/ G1PeriodicGCInterval is a manageable flag and can be updated\n+  \/\/ during runtime. If no value is set, wait a second and run it\n+  \/\/ again to see if the value has been updated. Otherwise use the\n+  \/\/ real value provided.\n+  schedule(G1PeriodicGCInterval == 0 ? 1000 : G1PeriodicGCInterval);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.cpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1PERIODICGCTASK_HPP\n+#define SHARE_GC_G1_G1PERIODICGCTASK_HPP\n+\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ Task handling periodic GCs\n+class G1PeriodicGCTask : public G1ServiceTask {\n+  bool should_start_periodic_gc();\n+  void check_for_periodic_gc();\n+\n+public:\n+  G1PeriodicGCTask(const char* name);\n+  virtual void execute();\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1PERIODICGCTASK_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -26,3 +26,0 @@\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n-#include \"gc\/g1\/g1ConcurrentMarkThread.inline.hpp\"\n@@ -30,1 +27,1 @@\n-#include \"memory\/universe.hpp\"\n+#include \"logging\/log.hpp\"\n@@ -32,0 +29,1 @@\n+#include \"runtime\/timer.hpp\"\n@@ -43,55 +41,0 @@\n-\/\/ Task handling periodic GCs\n-class G1PeriodicGCTask : public G1ServiceTask {\n-  bool should_start_periodic_gc() {\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-    \/\/ If we are currently in a concurrent mark we are going to uncommit memory soon.\n-    if (g1h->concurrent_mark()->cm_thread()->in_progress()) {\n-      log_debug(gc, periodic)(\"Concurrent cycle in progress. Skipping.\");\n-      return false;\n-    }\n-\n-    \/\/ Check if enough time has passed since the last GC.\n-    uintx time_since_last_gc = (uintx)g1h->time_since_last_collection().milliseconds();\n-    if ((time_since_last_gc < G1PeriodicGCInterval)) {\n-      log_debug(gc, periodic)(\"Last GC occurred \" UINTX_FORMAT \"ms before which is below threshold \" UINTX_FORMAT \"ms. Skipping.\",\n-                              time_since_last_gc, G1PeriodicGCInterval);\n-      return false;\n-    }\n-\n-    \/\/ Check if load is lower than max.\n-    double recent_load;\n-    if ((G1PeriodicGCSystemLoadThreshold > 0.0f) &&\n-        (os::loadavg(&recent_load, 1) == -1 || recent_load > G1PeriodicGCSystemLoadThreshold)) {\n-      log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n-                              recent_load, G1PeriodicGCSystemLoadThreshold);\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  void check_for_periodic_gc(){\n-    \/\/ If disabled, just return.\n-    if (G1PeriodicGCInterval == 0) {\n-      return;\n-    }\n-\n-    log_debug(gc, periodic)(\"Checking for periodic GC.\");\n-    if (should_start_periodic_gc()) {\n-      if (!G1CollectedHeap::heap()->try_collect(GCCause::_g1_periodic_collection)) {\n-        log_debug(gc, periodic)(\"GC request denied. Skipping.\");\n-      }\n-    }\n-  }\n-public:\n-  G1PeriodicGCTask(const char* name) : G1ServiceTask(name) { }\n-\n-  virtual void execute() {\n-    check_for_periodic_gc();\n-    \/\/ G1PeriodicGCInterval is a manageable flag and can be updated\n-    \/\/ during runtime. If no value is set, wait a second and run it\n-    \/\/ again to see if the value has been updated. Otherwise use the\n-    \/\/ real value provided.\n-    schedule(G1PeriodicGCInterval == 0 ? 1000 : G1PeriodicGCInterval);\n-  }\n-};\n-\n@@ -105,1 +48,0 @@\n-    _periodic_gc_task(new G1PeriodicGCTask(\"Periodic GC Task\")),\n@@ -111,4 +53,0 @@\n-G1ServiceThread::~G1ServiceThread() {\n-  delete _periodic_gc_task;\n-}\n-\n@@ -220,3 +158,0 @@\n-  \/\/ Register the tasks handled by the service thread.\n-  register_task(_periodic_gc_task);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":2,"deletions":67,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-class G1PeriodicGCTask;\n@@ -108,2 +107,0 @@\n-  G1PeriodicGCTask* _periodic_gc_task;\n-\n@@ -134,1 +131,0 @@\n-  ~G1ServiceThread();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}