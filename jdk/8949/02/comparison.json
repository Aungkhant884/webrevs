{"files":[{"patch":"@@ -101,1 +101,2 @@\n-  friend class ClassLoaderDataGraphIterator;\n+  template <bool keep_alive>\n+  friend class ClassLoaderDataGraphIteratorBase;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -317,1 +317,2 @@\n-class ClassLoaderDataGraphIterator : public StackObj {\n+template <bool keep_alive = true>\n+class ClassLoaderDataGraphIteratorBase : public StackObj {\n@@ -321,1 +322,0 @@\n-  Handle           _holder;\n@@ -326,3 +326,6 @@\n-  ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n-    _thread = Thread::current();\n-    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  ClassLoaderDataGraphIteratorBase() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n+    if (keep_alive) {\n+      assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+    } else {\n+      assert_at_safepoint();\n+    }\n@@ -339,1 +342,3 @@\n-      _holder = Handle(_thread, cld->holder());\n+      if (keep_alive) {\n+        Handle(_thread, cld->holder());\n+      }\n@@ -348,0 +353,3 @@\n+using ClassLoaderDataGraphIterator = ClassLoaderDataGraphIteratorBase<true \/* keep_alive *\/>;\n+using ClassLoaderDataGraphIteratorNoKeepAlive = ClassLoaderDataGraphIteratorBase<false \/* keep_alive *\/>;\n+\n@@ -425,4 +433,0 @@\n-#define FOR_ALL_DICTIONARY(X)   ClassLoaderDataGraphIterator iter; \\\n-                                while (ClassLoaderData* X = iter.get_next()) \\\n-                                  if (X->dictionary() != NULL)\n-\n@@ -430,2 +434,5 @@\n-  FOR_ALL_DICTIONARY(cld) {\n-    cld->dictionary()->verify();\n+  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  while (ClassLoaderData* cld = iter.get_next()) {\n+    if (cld->dictionary() != nullptr) {\n+      cld->dictionary()->verify();\n+    }\n@@ -435,0 +442,4 @@\n+#define FOR_ALL_DICTIONARY(X)   ClassLoaderDataGraphIterator iter; \\\n+                                while (ClassLoaderData* X = iter.get_next()) \\\n+                                  if (X->dictionary() != NULL)\n+\n@@ -651,1 +662,1 @@\n-  ClassLoaderDataGraphIterator iter;\n+  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-  friend class ClassLoaderDataGraphIterator;\n+  template <bool keep_alive>\n+  friend class ClassLoaderDataGraphIteratorBase;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test Class unloading test with concurrent mark\n+ * @summary Make sure that verification during gc does not prevent class unloading\n+ * @bug 8280454\n+ * @requires vm.gc.G1\n+ * @requires vm.opt.final.ClassUnloading\n+ * @requires vm.opt.final.ClassUnloadingWithConcurrentMark\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @library classes\n+ * @build sun.hotspot.WhiteBox test.Empty\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xmn8m -XX:+UseG1GC -XX:+VerifyDuringGC -XX:+AlwaysTenure -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xlog:gc,class+unload=debug UnloadTestWithVerifyDuringGC\n+ *\/\n+import sun.hotspot.WhiteBox;\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+\n+\/**\n+ * Test that verifies that classes are unloaded using concurrent mark with G1 when they are no\n+ * longer reachable even when -XX:+VerifyDuringGC is enabled\n+ *\n+ * The test creates a class loader, uses the loader to load a class and creates an instance\n+ * of that class. The it nulls out all the references to the instance, class and class loader\n+ * and tries to trigger class unloading using a concurrent mark. Then it verifies that the class\n+ * is no longer loaded by the VM.\n+ *\/\n+public class UnloadTestWithVerifyDuringGC {\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    private static void waitUntilConcMarkFinished() throws Exception {\n+        while (wb.g1InConcurrentMark()) {\n+            try {\n+                Thread.sleep(1);\n+            } catch (InterruptedException e) {\n+                System.out.println(\"Got InterruptedException while waiting for concurrent mark to finish\");\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static void triggerUnloadingWithConcurrentMark() throws Exception {\n+        \/\/ Try to unload classes using concurrent mark. First wait for any currently running concurrent\n+        \/\/ cycle.\n+        waitUntilConcMarkFinished();\n+        wb.g1StartConcMarkCycle();\n+        waitUntilConcMarkFinished();\n+    }\n+\n+    private static String className = \"test.Empty\";\n+\n+    public static void main(String... args) throws Exception {\n+        ClassUnloadCommon.failIf(wb.isClassAlive(className), \"is not expected to be alive yet\");\n+\n+        ClassLoader cl = ClassUnloadCommon.newClassLoader();\n+        Class<?> c = cl.loadClass(className);\n+        Object o = c.newInstance();\n+\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(className), \"should be live here\");\n+\n+        String loaderName = cl.getName();\n+        int loadedRefcount = wb.getSymbolRefcount(loaderName);\n+        System.out.println(\"Refcount of symbol \" + loaderName + \" is \" + loadedRefcount);\n+\n+        \/\/ Move everything into the old gen so that concurrent mark can unload.\n+        wb.youngGC();\n+        cl = null; c = null; o = null;\n+        triggerUnloadingWithConcurrentMark();\n+\n+        ClassUnloadCommon.failIf(wb.isClassAlive(className), \"should have been unloaded\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassUnload\/UnloadTestWithVerifyDuringGC.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}