{"files":[{"patch":"@@ -1942,0 +1942,1 @@\n+  InvokeMethodKey key(signature, iid_as_int);\n@@ -1944,1 +1945,0 @@\n-    InvokeMethodKey key(signature, iid_as_int);\n@@ -1949,11 +1949,11 @@\n-\n-    bool throw_error = false;\n-    \/\/ This function could get an OOM but it is safe to call inside of a lock because\n-    \/\/ throwing OutOfMemoryError doesn't call Java code.\n-    methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n-    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n-        \/\/ Generate a compiled form of the MH intrinsic\n-        \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n-        AdapterHandlerLibrary::create_native_wrapper(m);\n-        \/\/ Check if have the compiled code.\n-        throw_error = (!m->has_compiled_code());\n+  } \/\/ release lock\n+\n+  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n+  if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n+    \/\/ Generate a compiled form of the MH intrinsic\n+    \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n+    AdapterHandlerLibrary::create_native_wrapper(m);\n+    \/\/ Check if have the compiled code.\n+    if (!m->has_compiled_code()) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n+                     \"Out of space in CodeCache for method handle intrinsic\");\n@@ -1961,0 +1961,1 @@\n+  }\n@@ -1962,8 +1963,12 @@\n-    if (!throw_error) {\n-      signature->make_permanent(); \/\/ The signature is never unloaded.\n-      bool created = _invoke_method_intrinsic_table.put(key, m());\n-      assert(created, \"must be since we still hold the lock\");\n-      assert(Arguments::is_interpreter_only() || (m->has_compiled_code() &&\n-             m->code()->entry_point() == m->from_compiled_entry()),\n-             \"MH intrinsic invariant\");\n-      return m();\n+  {\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    signature->make_permanent(); \/\/ The signature is never unloaded.\n+    bool created;\n+    Method** met = _invoke_method_intrinsic_table.put_if_absent(key, m(), &created);\n+    Method* result = *met;\n+    if (!created) {\n+      \/\/ There was already this method in the table.  Need to deallocate the one created here,\n+      \/\/ and its associated small constant pool.\n+      ClassLoaderData* method_cld = m->method_holder()->class_loader_data();\n+      method_cld->add_to_deallocate_list(m->constants());\n+      method_cld->add_to_deallocate_list(m());\n@@ -1971,0 +1976,4 @@\n+    assert(Arguments::is_interpreter_only() || (result->has_compiled_code() &&\n+           result->code()->entry_point() == result->from_compiled_entry()),\n+           \"MH intrinsic invariant\");\n+    return result;\n@@ -1972,4 +1981,0 @@\n-\n-  \/\/ Throw error outside of the lock.\n-  THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n-                 \"Out of space in CodeCache for method handle intrinsic\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -129,2 +129,0 @@\n-\/\/ Release Method*.  The nmethod will be gone when we get here because\n-\/\/ we've walked the code cache.\n@@ -138,2 +136,8 @@\n-  \/\/ The nmethod will be gone when we get here.\n-  if (code() != nullptr) _code = nullptr;\n+  \/\/ The nmethod will be gone when we get here for redefinition because\n+  \/\/ we've walked the code cache, but not for method handle intrinsics.\n+  \/\/ This is safe for method handle intrinsics because this method has\n+  \/\/ not been published so nothing has called through this nmethod.\n+  if (code() != nullptr) {\n+    ((nmethod*)_code)->flush();\n+    _code = nullptr;\n+  }\n@@ -1251,1 +1255,1 @@\n-  if (adapter == nullptr ) {\n+  if (adapter == nullptr) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+  MUTEX_DEFN(AdapterHandlerLibrary_lock      , PaddedMutex  , safepoint);\n@@ -347,1 +348,0 @@\n-  MUTEX_DEFL(AdapterHandlerLibrary_lock     , PaddedMutex  , InvokeMethodTable_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}