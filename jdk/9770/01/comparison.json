{"files":[{"patch":"@@ -314,7 +314,0 @@\n-void Assembler::ifence() {\n-  fence_i();\n-  if (UseConservativeFence) {\n-    fence(ir, ir);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -342,1 +342,0 @@\n-  void ifence();\n@@ -964,1 +963,0 @@\n-  INSN(fence_i, 0b0001111, 0b001, 0b000000000000);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-  \/\/ fence_i + fence* + (lui, addi, slli, addi, slli, addi) + (lui, addi, slli, addi, slli) + jalr\n-  return NativeFenceI::instruction_size() + 12 * NativeInstruction::instruction_size;\n+  \/\/ (lui, addi, slli, addi, slli, addi) + (lui, addi, slli, addi, slli) + jalr\n+  return 12 * NativeInstruction::instruction_size;\n@@ -101,1 +101,1 @@\n-    = nativeMovConstReg_at(stub + NativeFenceI::instruction_size());\n+    = nativeMovConstReg_at(stub);\n@@ -122,1 +122,1 @@\n-    = nativeMovConstReg_at(stub + NativeFenceI::instruction_size());\n+    = nativeMovConstReg_at(stub);\n@@ -142,1 +142,1 @@\n-    = nativeMovConstReg_at(stub + NativeFenceI::instruction_size());\n+    = nativeMovConstReg_at(stub);\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -91,2 +91,1 @@\n-          \"Extend i for r and o for w in the pred\/succ flags of fence;\"          \\\n-          \"Extend fence.i to fence.i + fence.\")                                  \\\n+          \"Extend i for r and o for w in the pred\/succ flags of fence\")          \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,8 @@\n+  \/\/ To make a store to instruction memory visible to all RISC-V harts,\n+  \/\/ the writing hart has to execute a data FENCE before requesting that\n+  \/\/ all remote RISC-V harts execute a FENCE.I.\n+  \/\/\n+  \/\/ No sush assurance is defined at the interface level of the builtin\n+  \/\/ method, and so we should make sure it works.\n+  __asm__ volatile(\"fence rw, rw\" : : : \"memory\");\n+\n","filename":"src\/hotspot\/cpu\/riscv\/icache_riscv.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -558,1 +558,0 @@\n-  ifence();\n@@ -1671,1 +1670,0 @@\n-  \/\/ Using immediate literals would necessitate fence.i.\n@@ -2749,1 +2747,0 @@\n-  verify_cross_modify_fence_not_required();\n@@ -2800,1 +2797,0 @@\n-  verify_cross_modify_fence_not_required();\n@@ -3984,26 +3980,0 @@\n-\n-void MacroAssembler::safepoint_ifence() {\n-  ifence();\n-#ifndef PRODUCT\n-  if (VerifyCrossModifyFence) {\n-    \/\/ Clear the thread state.\n-    sb(zr, Address(xthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n-  }\n-#endif\n-}\n-\n-#ifndef PRODUCT\n-void MacroAssembler::verify_cross_modify_fence_not_required() {\n-  if (VerifyCrossModifyFence) {\n-    \/\/ Check if thread needs a cross modify fence.\n-    lbu(t0, Address(xthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n-    Label fence_not_required;\n-    beqz(t0, fence_not_required);\n-    \/\/ If it does then fail.\n-    la(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::verify_cross_modify_fence_failure)));\n-    mv(c_rarg0, xthread);\n-    jalr(t0);\n-    bind(fence_not_required);\n-  }\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,3 +49,0 @@\n-  \/\/ Place a fence.i after code may have been modified due to a safepoint.\n-  void safepoint_ifence();\n-\n@@ -839,3 +836,0 @@\n-\n-  \/\/ Check the current thread doesn't need a cross modify fence.\n-  void verify_cross_modify_fence_not_required() PRODUCT_RETURN;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -557,8 +557,0 @@\n-class NativeFenceI : public NativeInstruction {\n-public:\n-  static inline int instruction_size() {\n-    \/\/ 2 for fence.i + fence\n-    return (UseConservativeFence ? 2 : 1) * NativeInstruction::instruction_size;\n-  }\n-};\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -357,4 +357,0 @@\n-  \/\/ Explicit fence.i required because fixup_callers_callsite may change the code\n-  \/\/ stream.\n-  __ safepoint_ifence();\n-\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,4 +57,0 @@\n-  asm volatile(\"fence.i\" : : : \"memory\");\n-  if (UseConservativeFence) {\n-    asm volatile(\"fence ir, ir\" : : : \"memory\");\n-  }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/orderAccess_linux_riscv.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}