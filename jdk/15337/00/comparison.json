{"files":[{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4992438 6633113\n+ * @bug 4992438 6633113 8314515\n@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -31,0 +32,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -32,2 +34,2 @@\n-import java.util.concurrent.locks.Condition;\n-import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -36,2 +38,1 @@\n-    private static void testFairness(boolean fair,\n-                                     final BlockingQueue<Integer> q)\n+    private static void testFairness(boolean fair, SynchronousQueue<Integer> q)\n@@ -40,5 +41,3 @@\n-        final ReentrantLock lock = new ReentrantLock();\n-        final Condition ready = lock.newCondition();\n-        final int threadCount = 10;\n-        final Throwable[] badness = new Throwable[1];\n-        lock.lock();\n+        int threadCount = ThreadLocalRandom.current().nextInt(2, 8);\n+        var badness = new AtomicReference<Throwable>();\n+        var ts = new ArrayList<Thread>();\n@@ -46,2 +45,3 @@\n-            final Integer I = i;\n-            Thread t = new Thread() { public void run() {\n+            final Integer finali = i;\n+            CountDownLatch ready = new CountDownLatch(1);\n+            Runnable put = () -> {\n@@ -49,5 +49,5 @@\n-                    lock.lock();\n-                    ready.signal();\n-                    lock.unlock();\n-                    q.put(I);\n-                } catch (Throwable t) { badness[0] = t; }}};\n+                    ready.countDown();\n+                    q.put(finali);\n+                } catch (Throwable fail) { badness.set(fail); }\n+            };\n+            Thread t = new Thread(put);\n@@ -55,0 +55,1 @@\n+            ts.add(t);\n@@ -56,1 +57,2 @@\n-            \/\/ Probably unnecessary, but should be bullet-proof\n+            \/\/ Force queueing order by waiting for each thread to block in q.put\n+            \/\/ before starting the next\n@@ -62,1 +64,2 @@\n-            \/\/ Non-fair queues are lifo in our implementation\n+            \/\/ Fair queues are specified to be FIFO.\n+            \/\/ Non-fair queues are LIFO in our implementation.\n@@ -64,2 +67,2 @@\n-                throw new Error(String.format(\"fair=%b i=%d j=%d%n\",\n-                                              fair, i, j));\n+                throw new Error(String.format(\"fair=%b i=%d\/%d j=%d%n\",\n+                                              fair, i, threadCount, j));\n@@ -67,1 +70,2 @@\n-        if (badness[0] != null) throw new Error(badness[0]);\n+        for (Thread t : ts) t.join();\n+        if (badness.get() != null) throw new Error(badness.get());\n","filename":"test\/jdk\/java\/util\/concurrent\/SynchronousQueue\/Fairness.java","additions":26,"deletions":22,"binary":false,"changes":48,"status":"modified"}]}