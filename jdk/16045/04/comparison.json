{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import javax.xml.catalog.CatalogResolver.NotFoundAction;\n@@ -62,2 +63,2 @@\n-    \/\/Value of the resolve attribute\n-    ResolveType resolveType = ResolveType.STRICT;\n+    \/\/Value of the resolve attribute mapped to the resolver's action type\n+    NotFoundAction resolveType = NotFoundAction.STRICT;\n@@ -262,1 +263,1 @@\n-        resolveType = ResolveType.getType(value);\n+        resolveType = NotFoundAction.getType(value);\n@@ -270,1 +271,1 @@\n-    public final ResolveType getResolve() {\n+    public final NotFoundAction getResolve() {\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/CatalogImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,6 @@\n+     * @apiNote The {@code CatalogResolver} created by this method delegates to\n+     * the underlying {@code catalog}'s RESOLVE property. The {@code CatalogResolver}\n+     * created by {@link #catalogResolver(Catalog, CatalogResolver.NotFoundAction)\n+     * catalogResover(Catalog, CatalogResolver.NotFoundAction)} is based on the\n+     * specified action type when it is unable to resolve a reference.\n+     *\n@@ -88,0 +94,22 @@\n+    \/**\n+     * Creates a {@code CatalogResolver} that resolves external references with the given\n+     * {@code catalog} and {@link CatalogResolver.NotFoundAction action} type\n+     * that determines the behavior when unable to resolve a reference.\n+     * <p>\n+     * The {@link CatalogResolver.NotFoundAction action} types are mapped to the values\n+     * of the {@link CatalogFeatures.Feature#RESOLVE RESOLVE} property.\n+     *\n+     * @param catalog the catalog instance\n+     * @param action the action to be taken when unable to resolve a reference\n+     *\n+     * @return a {@code CatalogResolver} with the {@code catalog} and {@code action} type\n+     *\n+     * @since 22\n+     *\/\n+    public static CatalogResolver catalogResolver(Catalog catalog, CatalogResolver.NotFoundAction action) {\n+        if (catalog == null) CatalogMessages.reportNPEOnNull(\"catalog\", null);\n+        if (action == null) CatalogMessages.reportNPEOnNull(\"action\", null);\n+\n+        return new CatalogResolverImpl(catalog, action);\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/CatalogManager.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-                        resolve = catalog.getResolve().literal;\n+                        resolve = catalog.getResolve().toString();\n@@ -175,1 +175,1 @@\n-                group = new GroupEntry(catalog, base, prefer);\n+                group = new GroupEntry(catalog, Util.getAbsoluteURI(catalog.systemId, base), prefer);\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/CatalogReader.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,0 +238,49 @@\n+    \/**\n+     * Defines the actions that a CatalogResolver may take when it is unable to\n+     * resolve an external reference. The actions are mapped to the string values\n+     * of the {@link CatalogFeatures.Feature#RESOLVE RESOLVE} property.\n+     *\n+     * @since 22\n+     *\/\n+    public static enum NotFoundAction {\n+        \/**\n+         * Indicates that the processing should continue as defined by the\n+         * {@link CatalogFeatures.Feature#RESOLVE RESOLVE} property.\n+         *\/\n+        CONTINUE {\n+            @Override\n+            public String toString() { return \"continue\"; }\n+        },\n+        \/**\n+         * Indicates that the reference is skipped as defined by the\n+         * {@link CatalogFeatures.Feature#RESOLVE RESOLVE} property.\n+         *\/\n+        IGNORE {\n+            @Override\n+            public String toString() { return \"ignore\"; }\n+        },\n+        \/**\n+         * Indicates that the resolver should throw a CatalogException as defined\n+         * by the {@link CatalogFeatures.Feature#RESOLVE RESOLVE} property.\n+         *\/\n+        STRICT {\n+            @Override\n+            public String toString() { return \"strict\"; }\n+        };\n+\n+        \/**\n+         * Returns the action type mapped to the specified\n+         * {@link CatalogFeatures.Feature#RESOLVE resolve} property.\n+         *\n+         * @param resolve the value of the RESOLVE property\n+         * @return the action type\n+         *\/\n+        static public NotFoundAction getType(String resolve) {\n+            for (NotFoundAction type : NotFoundAction.values()) {\n+                if (type.toString().equals(resolve)) {\n+                    return type;\n+                }\n+            }\n+            return null;\n+        }\n+    }\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/CatalogResolver.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,2 @@\n+    \/\/ resolution action type\n+    NotFoundAction resolveType;\n@@ -61,1 +63,1 @@\n-        this.catalog = catalog;\n+        this(catalog, null);\n@@ -64,0 +66,16 @@\n+    \/**\n+     * Construct an instance of the CatalogResolver from a Catalog and the\n+     * {@link CatalogResolver.NotFoundAction action} type.\n+     *\n+     * @param catalog a Catalog object\n+     * @param action the action type\n+     *\/\n+    public CatalogResolverImpl(Catalog catalog, NotFoundAction action) {\n+        this.catalog = catalog;\n+        \/\/ Note: can only happen in this impl\n+        if (action == null) {\n+            resolveType = ((CatalogImpl) catalog).getResolve();\n+        } else {\n+            resolveType = action;\n+        }\n+    }\n@@ -94,1 +112,0 @@\n-        GroupEntry.ResolveType resolveType = ((CatalogImpl) catalog).getResolve();\n@@ -148,1 +165,0 @@\n-            GroupEntry.ResolveType resolveType = c.getResolve();\n@@ -232,1 +248,0 @@\n-        GroupEntry.ResolveType resolveType = ((CatalogImpl) catalog).getResolve();\n@@ -253,1 +268,0 @@\n-        GroupEntry.ResolveType resolveType = ((CatalogImpl) catalog).getResolve();\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/CatalogResolverImpl.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,28 +110,0 @@\n-    \/**\n-     * PreferType represents possible values of the resolve property\n-     *\/\n-    public static enum ResolveType {\n-        STRICT(CatalogFeatures.RESOLVE_STRICT),\n-        CONTINUE(CatalogFeatures.RESOLVE_CONTINUE),\n-        IGNORE(CatalogFeatures.RESOLVE_IGNORE);\n-\n-        final String literal;\n-\n-        ResolveType(String literal) {\n-            this.literal = literal;\n-        }\n-\n-        static public ResolveType getType(String resolveType) {\n-            for (ResolveType type : ResolveType.values()) {\n-                if (type.isType(resolveType)) {\n-                    return type;\n-                }\n-            }\n-            return null;\n-        }\n-\n-        public boolean isType(String type) {\n-            return literal.equals(type);\n-        }\n-    }\n-\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/GroupEntry.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.net.URL;\n@@ -270,0 +271,28 @@\n+\n+    \/**\n+     * Returns the absolute form of the specified uri after resolving it against\n+     * the base. Returns the uri as is if it's already absolute.\n+     *\n+     * @param base the base, that is the system id of the catalog within the\n+     * Catalog implementation\n+     * @param uri the specified uri\n+     * @return the absolute form of the specified uri\n+     *\/\n+    @SuppressWarnings(\"deprecation\")\n+    static String getAbsoluteURI(String base, String uri) {\n+        String temp = \"\";\n+        try {\n+            URL baseURL = new URL(base);\n+            URI specURI = URI.create(uri);\n+\n+            if (specURI.isAbsolute()) {\n+                temp = specURI.toURL().toString();\n+            } else {\n+                temp = (new URL(baseURL, uri)).toString();\n+            }\n+        } catch (MalformedURLException ex) {\n+            \/\/ shouldn't happen since inputs are validated, report error in case\n+            CatalogMessages.reportError(CatalogMessages.ERR_INVALID_CATALOG);\n+        }\n+        return temp;\n+    }\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/Util.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package catalog;\n+\n+import java.net.URI;\n+import java.nio.file.Paths;\n+import javax.xml.catalog.Catalog;\n+import javax.xml.catalog.CatalogException;\n+import javax.xml.catalog.CatalogFeatures;\n+import javax.xml.catalog.CatalogManager;\n+import javax.xml.catalog.CatalogResolver;\n+import javax.xml.catalog.CatalogResolver.NotFoundAction;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+import org.xml.sax.InputSource;\n+\n+\/*\n+ * @test\n+ * @bug 8316996\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm catalog.CatalogResolverTest\n+ * @summary Tests CatalogResolver functions. See CatalogTest for existing basic\n+ * functional tests.\n+ *\/\n+@Listeners({jaxp.library.FilePolicy.class})\n+public class CatalogResolverTest extends CatalogSupportBase {\n+    static final String KEY_FILES = \"javax.xml.catalog.files\";\n+    static final String SYSTEM_ID = \"http:\/\/openjdk_java_net\/xml\/catalog\/dtd\/system.dtd\";\n+\n+    \/*\n+     * Initializing fields\n+     *\/\n+    @BeforeClass\n+    public void setUpClass() throws Exception {\n+        super.setUp();\n+    }\n+\n+    \/*\n+       DataProvider: data used to verify the RESOLVE property, including the valid\n+                     values and the effect of overriding that on the Catalog.\n+        Data columns:\n+        resolve property for the Catalog, resolve property for the CatalogResolver,\n+        system ID to be resolved, expected result, expected exception\n+     *\/\n+    @DataProvider(name = \"factoryMethodInput\")\n+    public Object[][] getInputs() throws Exception {\n+\n+        return new Object[][]{\n+            \/\/ Valid values and overriding verification\n+            \/\/ RESOLVE=strict but expected match\n+            {\"continue\", NotFoundAction.STRICT, SYSTEM_ID, \"system.dtd\", null},\n+            \/\/ RESOLVE=strict plus no match: expect exception\n+            {\"continue\", NotFoundAction.STRICT, \"bogusID\", \"\", CatalogException.class},\n+            \/\/ RESOLVE=ignore, continue: expect no match but without an exception\n+            \/\/ Note that these tests do not differentiate empty InputSource from\n+            \/\/ null, in both cases, the returned ID is null\n+            {\"strict\", NotFoundAction.IGNORE, \"bogusID\", null, null},\n+            {\"strict\", NotFoundAction.CONTINUE, \"bogusID\", null, null},\n+         };\n+    }\n+\n+    @DataProvider(name = \"NPETest\")\n+    public Object[][] getNPETest() throws Exception {\n+        return new Object[][]{\n+            {null, null},\n+            {getCatalog(\"ignore\"), null},\n+         };\n+    }\n+\n+    \/**\n+     * Tests the factory method for creating CatalogResolver with an\n+     * {@link javax.xml.catalog.CatalogResolver.NotFoundAction action} type.\n+     * The 2-arg {@link javax.xml.catalog.CatalogManager#catalogResolver(\n+     * javax.xml.catalog.Catalog, javax.xml.catalog.CatalogResolver.NotFoundAction)\n+     * catalogResolver} method adds the action type to be used for determining\n+     * the behavior instead of relying on the underlying catalog.\n+     *\n+     * @param cResolve the resolve property set on the Catalog object\n+     * @param action the resolve property set on the CatalogResolver to override\n+     *                  that of the Catalog\n+     * @param systemId the system ID to be resolved\n+     * @param expectedResult the expected result\n+     * @param expectedThrow the expected exception\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"factoryMethodInput\")\n+    public void testResolveProperty(String cResolve, NotFoundAction action,\n+            String systemId, String expectedResult, Class<Throwable> expectedThrow)\n+            throws Exception {\n+        Catalog c = getCatalog(cResolve);\n+\n+        if (expectedThrow != null) {\n+            Assert.assertThrows(expectedThrow,\n+                () -> resolveRef(c, action, systemId));\n+        } else {\n+\n+            String sysId = resolveRef(c, action, systemId);\n+            System.out.println(sysId);\n+            Assert.assertEquals(sysId,\n+                    (expectedResult == null) ? null : Paths.get(filepath + expectedResult).toUri().toString().replace(\"\/\/\/\", \"\/\"),\n+                    \"System ID match not right\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that the catalogResolver method throws NullPointerException if\n+     * any of the parameters is null.\n+     *\/\n+    @Test(dataProvider = \"NPETest\", expectedExceptions = NullPointerException.class)\n+    public void testCatalogProperty(Catalog c, NotFoundAction action) {\n+        CatalogManager.catalogResolver(c, action);\n+    }\n+\n+    private String resolveRef(Catalog c, NotFoundAction action, String systemId) throws Exception {\n+        CatalogResolver cr = CatalogManager.catalogResolver(c, action);\n+        InputSource is = cr.resolveEntity(\"\", systemId);\n+        return is == null ? null : is.getSystemId();\n+    }\n+\n+    private Catalog getCatalog(String cResolve) throws Exception {\n+        URI catalogFile = getClass().getResource(\"catalog.xml\").toURI();\n+        Catalog c = CatalogManager.catalog(\n+                CatalogFeatures.builder().with(CatalogFeatures.Feature.RESOLVE, cResolve).build(),\n+                catalogFile);\n+        return c;\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/CatalogResolverTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -509,1 +509,1 @@\n-        CatalogResolver resolver = CatalogManager.catalogResolver(null, null);\n+        CatalogResolver resolver = CatalogManager.catalogResolver((CatalogFeatures)null, (URI)null);\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/CatalogTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}