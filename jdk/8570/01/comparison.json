{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import sun.invoke.util.VerifyType;\n@@ -632,1 +631,1 @@\n-        if (ftype.isPrimitive())\n+        if (ftype.isPrimitive()) {\n@@ -634,1 +633,2 @@\n-        else if (VerifyType.isNullReferenceConversion(Object.class, ftype))\n+        } else if (ftype.isInterface() || ftype.isAssignableFrom(Object.class)) {\n+            \/\/ retyping can be done without a cast\n@@ -636,1 +636,1 @@\n-        else\n+        } else {\n@@ -638,0 +638,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,13 +88,0 @@\n-    \/**\n-     * Specialization of isNullConversion to reference types.\n-     * @param src the type of a stacked value\n-     * @param dst the reference type by which we'd like to treat it\n-     * @return whether the retyping can be done without a cast\n-     *\/\n-    public static boolean isNullReferenceConversion(Class<?> src, Class<?> dst) {\n-        assert(!dst.isPrimitive());\n-        if (dst.isInterface())  return true;   \/\/ verifier allows this\n-        if (isNullType(src))    return true;\n-        return dst.isAssignableFrom(src);\n-    }\n-\n@@ -131,71 +118,0 @@\n-\n-    \/**\n-     * Determine if the JVM verifier allows a value of type call to be\n-     * passed to a formal parameter (or return variable) of type recv.\n-     * Returns 1 if the verifier allows the types to match without conversion.\n-     * Returns -1 if the types can be made to match by a JVM-supported adapter.\n-     * Cases supported are:\n-     * <ul><li>checkcast\n-     * <\/li><li>conversion between any two integral types (but not floats)\n-     * <\/li><li>unboxing from a wrapper to its corresponding primitive type\n-     * <\/li><li>conversion in either direction between float and double\n-     * <\/li><\/ul>\n-     * (Autoboxing is not supported here; it must be done via Java code.)\n-     * Returns 0 otherwise.\n-     *\/\n-    public static int canPassUnchecked(Class<?> src, Class<?> dst) {\n-        if (src == dst)\n-            return 1;\n-\n-        if (dst.isPrimitive()) {\n-            if (dst == void.class)\n-                \/\/ Return anything to a caller expecting void.\n-                \/\/ This is a property of the implementation, which links\n-                \/\/ return values via a register rather than via a stack push.\n-                \/\/ This makes it possible to ignore cleanly.\n-                return 1;\n-            if (src == void.class)\n-                return 0;  \/\/ void-to-something?\n-            if (!src.isPrimitive())\n-                \/\/ Cannot pass a reference to any primitive type (exc. void).\n-                return 0;\n-            Wrapper sw = Wrapper.forPrimitiveType(src);\n-            Wrapper dw = Wrapper.forPrimitiveType(dst);\n-            if (sw.isSubwordOrInt() && dw.isSubwordOrInt()) {\n-                if (sw.bitWidth() >= dw.bitWidth())\n-                    return -1;   \/\/ truncation may be required\n-                if (!dw.isSigned() && sw.isSigned())\n-                    return -1;   \/\/ sign elimination may be required\n-                return 1;\n-            }\n-            if (src == float.class || dst == float.class) {\n-                if (src == double.class || dst == double.class)\n-                    return -1;   \/\/ floating conversion may be required\n-                else\n-                    return 0;    \/\/ other primitive conversions NYI\n-            } else {\n-                \/\/ all fixed-point conversions are supported\n-                return 0;\n-            }\n-        } else if (src.isPrimitive()) {\n-            \/\/ Cannot pass a primitive to any reference type.\n-            \/\/ (Maybe allow null.class?)\n-            return 0;\n-        }\n-\n-        \/\/ Handle reference types in the rest of the block:\n-\n-        \/\/ The verifier treats interfaces exactly like Object.\n-        if (isNullReferenceConversion(src, dst))\n-            \/\/ pass any reference to object or an arb. interface\n-            return 1;\n-        \/\/ else it's a definite \"maybe\" (cast is required)\n-        return -1;\n-    }\n-\n-    public static boolean isSpreadArgType(Class<?> spreadArg) {\n-        return spreadArg.isArray();\n-    }\n-    public static Class<?> spreadArgElementType(Class<?> spreadArg, int i) {\n-        return spreadArg.getComponentType();\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyType.java","additions":1,"deletions":85,"binary":false,"changes":86,"status":"modified"}]}