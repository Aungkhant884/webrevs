{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import static jdk.internal.net.http.common.Utils.ProxyHeaders;\n@@ -50,1 +51,1 @@\n-                             HttpHeaders proxyHeaders)\n+                             ProxyHeaders proxyHeaders)\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLTunnelConnection.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import static jdk.internal.net.http.common.Utils.ProxyHeaders;\n@@ -354,8 +355,4 @@\n-    private static HttpHeaders proxyTunnelHeaders(HttpRequestImpl request) {\n-        Map<String, List<String>> combined = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n-        combined.putAll(request.getSystemHeadersBuilder().map());\n-        combined.putAll(request.headers().map()); \/\/ let user override system\n-\n-        \/\/ keep only proxy-* - and also strip authorization headers\n-        \/\/ for disabled schemes\n-        return HttpHeaders.of(combined, Utils.PROXY_TUNNEL_FILTER);\n+    private static ProxyHeaders proxyTunnelHeaders(HttpRequestImpl request) {\n+        HttpHeaders userHeaders = HttpHeaders.of(request.headers().map(), Utils.PROXY_TUNNEL_FILTER);\n+        HttpHeaders systemHeaders = HttpHeaders.of(request.getSystemHeadersBuilder().map(), Utils.PROXY_TUNNEL_FILTER);\n+        return new ProxyHeaders(userHeaders, systemHeaders);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static jdk.internal.net.http.common.Utils.ProxyHeaders;\n@@ -206,1 +207,1 @@\n-    HttpRequestImpl(String method, InetSocketAddress authority, HttpHeaders headers) {\n+    HttpRequestImpl(String method, InetSocketAddress authority, ProxyHeaders headers) {\n@@ -213,1 +214,2 @@\n-        this.userHeaders = headers;\n+        this.systemHeadersBuilder.map().putAll(headers.systemHeaders().map());\n+        this.userHeaders = headers.userHeaders();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import static jdk.internal.net.http.common.Utils.ProxyHeaders;\n@@ -50,1 +51,1 @@\n-    final HttpHeaders proxyHeaders;\n+    final ProxyHeaders proxyHeaders;\n@@ -57,1 +58,1 @@\n-                                       HttpHeaders proxyHeaders) {\n+                                       ProxyHeaders proxyHeaders) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainTunnelingConnection.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -178,3 +178,3 @@\n-        return (k, v) -> client.authenticator() == null ||\n-                ! (k.equalsIgnoreCase(\"Authorization\")\n-                        && k.equalsIgnoreCase(\"Proxy-Authorization\"));\n+        return (k, v) -> !client.authenticator().isPresent() ||\n+                (!k.equalsIgnoreCase(\"Authorization\")\n+                        && !k.equalsIgnoreCase(\"Proxy-Authorization\"));\n@@ -182,0 +182,3 @@\n+\n+    public record ProxyHeaders(HttpHeaders userHeaders, HttpHeaders systemHeaders) {}\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.Headers;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+\n+import java.io.*;\n+import java.net.Authenticator;\n+import java.net.InetSocketAddress;\n+import java.net.ProxySelector;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.channels.*;\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ * @test\n+ * @bug 8263442\n+ * @summary Potential bug in jdk.internal.net.http.common.Utils.CONTEXT_RESTRICTED\n+ * @run main\/othervm AuthFilter\n+ *\/\n+\n+public class AuthFilter {\n+    static class Auth extends Authenticator {\n+    }\n+\n+    static HttpServer createServer() throws IOException {\n+        HttpServer server = HttpServer.create(new InetSocketAddress(0), 5);\n+        HttpHandler handler = (HttpExchange e) -> {\n+            InputStream is = e.getRequestBody();\n+            is.readAllBytes();\n+            is.close();\n+            Headers reqh = e.getRequestHeaders();\n+            if (reqh.containsKey(\"authorization\")) {\n+                e.sendResponseHeaders(500, -1);\n+            } else {\n+                e.sendResponseHeaders(200, -1);\n+            }\n+        };\n+        server.createContext(\"\/\", handler);\n+        return server;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        test(false);\n+        test(true);\n+    }\n+\n+    \/**\n+     *  Fake proxy. Just looks for Proxy-Authorization header\n+     *  and returns error if seen. Returns 200 OK if not.\n+     *  Does not actually forward the request\n+     *\/\n+    static class ProxyServer extends Thread {\n+\n+        final ServerSocketChannel server;\n+        final int port;\n+        volatile SocketChannel c;\n+\n+        ProxyServer() throws IOException {\n+            server = ServerSocketChannel.open();\n+            server.bind(new InetSocketAddress(0));\n+            if (server.getLocalAddress() instanceof InetSocketAddress isa) {\n+                port = isa.getPort();\n+            } else {\n+                port = -1;\n+            }\n+        }\n+\n+        int getPort() {\n+            return port;\n+        }\n+\n+        static String ok = \"HTTP\/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n+        static String notok1 = \"HTTP\/1.1 500 Internal Server Error\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n+        static String notok2 = \"HTTP\/1.1 501 Not Implemented\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n+\n+        static void reply(String msg, Writer writer) throws IOException {\n+            writer.write(msg);\n+            writer.flush();\n+        }\n+\n+        public void run() {\n+            try {\n+                c = server.accept();\n+                var cs = StandardCharsets.US_ASCII;\n+                LineNumberReader reader = new LineNumberReader(Channels.newReader(c, cs));\n+                Writer writer = Channels.newWriter(c, cs);\n+\n+                String line;\n+                while ((line=reader.readLine()) != null) {\n+                    if (line.indexOf(\"Proxy-Authorization\") != -1) {\n+                        reply(notok1, writer);\n+                        return;\n+                    }\n+                    if (line.equals(\"\")) {\n+                        \/\/ end of headers\n+                        reply(ok, writer);\n+                        return;\n+                    }\n+                }\n+                reply(notok2, writer);\n+            } catch (IOException e) {\n+            }\n+            try {\n+                server.close();\n+                c.close();\n+            } catch (IOException ee) {}\n+        }\n+    }\n+\n+    public static void test(boolean useProxy) throws Exception {\n+        HttpServer server = createServer();\n+        int port = server.getAddress().getPort();\n+        ProxyServer proxy;\n+\n+        InetSocketAddress proxyAddr=null;\n+        String authHdr;\n+        if (useProxy) {\n+            proxy = new ProxyServer();\n+            proxyAddr = new InetSocketAddress(\"127.0.0.1\", proxy.getPort());\n+            proxy.start();\n+            authHdr = \"Proxy-Authorization\";\n+        } else {\n+            authHdr = \"Authorization\";\n+        }\n+\n+        server.start();\n+\n+        HttpClient.Builder builder = HttpClient\n+                .newBuilder()\n+                .authenticator(new Auth());\n+\n+        if (useProxy) {\n+            builder.proxy(ProxySelector.of(proxyAddr));\n+        }\n+        HttpClient client = builder.build();\n+\n+        URI uri = new URI(\"http:\/\/127.0.0.1:\" + Integer.toString(port));\n+\n+        HttpRequest request = HttpRequest.newBuilder(uri)\n+                .header(authHdr, \"nonsense\")\n+                .GET()\n+                .build();\n+\n+        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+        int r = response.statusCode();\n+        System.out.println(r);\n+        server.stop(0);\n+        if (r != 200)\n+            throw new RuntimeException(\"Test failed : \" + r);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilter.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"}]}