{"files":[{"patch":"@@ -153,1 +153,1 @@\n-        if (inLen < 0 || inLen % blockSize != 0) {\n+        if (inLen < 0) {\n@@ -202,2 +202,1 @@\n-        if (!src.isDirect() && !dst.isDirect() &&\n-            !src.isReadOnly() && !dst.isReadOnly()) {\n+        if (src.hasArray() && dst.hasArray()) {\n@@ -218,0 +217,1 @@\n+            checkBlock();\n@@ -219,1 +219,0 @@\n-                checkBlock();\n@@ -258,8 +257,9 @@\n-        update(in, inOfs, completeBlkLen, out, outOfs);\n-        if (lastBlockSize != 0) {\n-            \/\/ do the last partial block\n-            checkBlock();\n-            embeddedCipher.encryptBlock(counter, 0, block, 0);\n-            for (int n = 0; n < lastBlockSize; n++) {\n-                out[outOfs + completeBlkLen + n] =\n-                    (byte) ((in[inOfs + completeBlkLen + n] ^ block[n]));\n+        try {\n+            update(in, inOfs, completeBlkLen, out, outOfs);\n+            if (lastBlockSize != 0) {\n+                \/\/ do the last partial block\n+                checkBlock();\n+                embeddedCipher.encryptBlock(counter, 0, block, 0);\n+                for (int n = 0; n < lastBlockSize; n++) {\n+                    out[outOfs + completeBlkLen + n] = (byte) ((in[inOfs + completeBlkLen + n] ^ block[n]));\n+                }\n@@ -267,0 +267,2 @@\n+        } finally {\n+            reset();\n@@ -268,1 +270,0 @@\n-        reset();\n@@ -282,2 +283,1 @@\n-        if (!src.isDirect() && !dst.isDirect() &&\n-            !src.isReadOnly() && !dst.isReadOnly()) {\n+        if (src.hasArray() && dst.hasArray()) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+\n@@ -51,0 +52,1 @@\n+\n@@ -52,0 +54,1 @@\n+\n@@ -60,1 +63,0 @@\n-\n@@ -182,0 +184,4 @@\n+        inLen -= (inLen % AES_BLOCK_SIZE);\n+        if (inLen == 0) {\n+            return 0;\n+        }\n@@ -183,1 +189,1 @@\n-        \/\/ If src is a direct bytebuffer, send it directly to the intrinsic\n+        \/\/ If ct is a direct bytebuffer, send it directly to the intrinsic\n@@ -185,1 +191,1 @@\n-            int processed = inLen - (inLen % AES_BLOCK_SIZE);\n+            int processed = inLen;\n@@ -187,1 +193,0 @@\n-            ct.position(ct.position());\n@@ -199,4 +204,0 @@\n-        inLen -= (inLen % AES_BLOCK_SIZE);\n-        if (inLen == 0) {\n-            return 0;\n-        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -125,0 +125,8 @@\n+        int tagLen = spec.getTLen();\n+        if (tagLen < 96 || tagLen > 128 || ((tagLen & 0x07) != 0)) {\n+            throw new InvalidAlgorithmParameterException\n+                (\"Unsupported TLen value.  Must be one of \" +\n+                    \"{128, 120, 112, 104, 96}\");\n+        }\n+        tagLenBytes = tagLen >> 3;\n+\n@@ -133,0 +141,1 @@\n+            Arrays.fill(keyValue, (byte) 0);\n@@ -141,0 +150,1 @@\n+                Arrays.fill(keyValue, (byte) 0);\n@@ -155,8 +165,0 @@\n-        int tagLen = spec.getTLen();\n-        if (tagLen < 96 || tagLen > 128 || ((tagLen & 0x07) != 0)) {\n-            throw new InvalidAlgorithmParameterException\n-                (\"Unsupported TLen value.  Must be one of \" +\n-                    \"{128, 120, 112, 104, 96}\");\n-        }\n-        tagLenBytes = tagLen >> 3;\n-\n@@ -232,1 +234,1 @@\n-        spec = new GCMParameterSpec(DEFAULT_TAG_LEN * 8,\n+        spec = new GCMParameterSpec(tagLenBytes * 8,\n@@ -1226,1 +1228,2 @@\n-                doLastBlock(in, inOfs, inLen, out, outOfs + resultLen);\n+                processed += gctrghash.doFinal(in, inOfs, inLen, out,\n+                    outOfs + resultLen);\n@@ -1273,1 +1276,1 @@\n-            byte[] block =  getLengthBlock(sizeOfAAD, processed);\n+            byte[] block = getLengthBlock(sizeOfAAD, processed);\n@@ -1285,16 +1288,0 @@\n-\n-        void doLastBlock(byte[] in, int inOfs, int inLen, byte[] out,\n-            int outOfs) {\n-            gctrPAndC.doFinal(in, inOfs, inLen, out, outOfs);\n-            processed += inLen;\n-\n-            int lastLen = inLen % blockSize;\n-            if (lastLen != 0) {\n-                ghashAllToS.update(out, outOfs, inLen - lastLen);\n-                ghashAllToS.update(expandToOneBlock(out,\n-                    (outOfs + inLen - lastLen), lastLen, blockSize));\n-            } else {\n-                ghashAllToS.update(out, outOfs, inLen);\n-            }\n-        }\n-\n@@ -1690,1 +1677,1 @@\n-    public static final class GCTRGHASH implements GCM {\n+    static final class GCTRGHASH implements GCM {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-                System.out.println(\"Combination #\" + k + 1 + \"\\nresult    \" +\n+                System.out.println(\"Combination #\" + (k + 1) + \"\\nresult    \" +\n@@ -239,1 +239,1 @@\n-                throw new RuntimeException(\"Combination #\" + k + \" failed\");\n+                throw new RuntimeException(\"Combination #\" + (k + 1) + \" failed\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/Encrypt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    boolean error = false;\n@@ -56,1 +57,7 @@\n-        c.doFinal(cipherText, 1, len, pt, 0);\n+        int r = c.doFinal(cipherText, 1, len, pt, 0);\n+        if (r != pt.length) {\n+            System.out.println(\n+                \"doFinal() return ( \" + r + \") is not the same\" +\n+                    \"as getOutputSize returned\" + pt.length);\n+            error = true;\n+        }\n@@ -59,1 +66,2 @@\n-            System.out.println(\"expected: \" + HexFormat.of().formatHex(plaintext));\n+            System.out.println(\"expected: \" +\n+                HexFormat.of().formatHex(plaintext));\n@@ -61,0 +69,4 @@\n+            error = true;\n+        }\n+        if (error) {\n+            throw new Exception(\"An error has occurred\");\n@@ -78,1 +90,1 @@\n-        c.doFinal(ByteBuffer.wrap(cipherText, 1, len), out);\n+        int r = c.doFinal(ByteBuffer.wrap(cipherText, 1, len), out);\n@@ -80,0 +92,6 @@\n+        if (r != out.capacity()) {\n+            System.out.println(\n+                \"doFinal() return ( \" + r + \") is not the same\" +\n+                    \" as getOutputSize returned\" + out.capacity());\n+            error = true;\n+        }\n@@ -81,4 +99,9 @@\n-            System.out.println(\"output  : \" + HexFormat.of().formatHex(out.array()));\n-            System.out.println(\"expected: \" + HexFormat.of().formatHex(plaintext));\n-            throw new Exception(\"output and plaintext do not match\");\n-\n+            System.out.println(\"output and plaintext do not match\");\n+            System.out.println(\"output  : \" +\n+                HexFormat.of().formatHex(out.array()));\n+            System.out.println(\"expected: \" +\n+                HexFormat.of().formatHex(plaintext));\n+            error = true;\n+        }\n+        if (error) {\n+            throw new Exception(\"An error has occurred\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMShortBuffer.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        AlgorithmParameterSpec aps = new GCMParameterSpec(128, new byte[16]);\n+        AlgorithmParameterSpec aps = new GCMParameterSpec(128, iv);\n@@ -115,3 +115,3 @@\n-            \/\/int offset = ci.update(plainText, 0, plainText.length, cipherText, 0);\n-            \/\/ci.doFinal(cipherText, offset);\n-            ci.doFinal(plainText, 0, plainText.length, cipherText, 0);\n+            int offset = ci.update(plainText, 0, plainText.length, cipherText,\n+                0);\n+            ci.doFinal(cipherText, offset);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestAESCipher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}