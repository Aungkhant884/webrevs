{"files":[{"patch":"@@ -141,1 +141,1 @@\n-    public static final class AES128_GCM_NoPadding extends OidImpl {\n+    public static final class AES128_GCM_NoPadding extends GaloisCounterMode {\n@@ -143,1 +143,1 @@\n-            super(16, \"GCM\", \"NOPADDING\");\n+            super(16, new AESCrypt());\n@@ -146,1 +146,1 @@\n-    public static final class AES192_GCM_NoPadding extends OidImpl {\n+    public static final class AES192_GCM_NoPadding extends GaloisCounterMode {\n@@ -148,1 +148,1 @@\n-            super(24, \"GCM\", \"NOPADDING\");\n+            super(24, new AESCrypt());\n@@ -151,1 +151,1 @@\n-    public static final class AES256_GCM_NoPadding extends OidImpl {\n+    public static final class AES256_GCM_NoPadding extends GaloisCounterMode {\n@@ -153,1 +153,1 @@\n-            super(32, \"GCM\", \"NOPADDING\");\n+            super(32, new AESCrypt());\n@@ -580,80 +580,0 @@\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD), using a subset of the provided buffer.\n-     * <p>\n-     * Calls to this method provide AAD to the cipher when operating in\n-     * modes such as AEAD (GCM\/CCM).  If this cipher is operating in\n-     * either GCM or CCM mode, all AAD must be supplied before beginning\n-     * operations on the ciphertext (via the {@code update} and {@code\n-     * doFinal} methods).\n-     *\n-     * @param src the buffer containing the AAD\n-     * @param offset the offset in {@code src} where the AAD input starts\n-     * @param len the number of AAD bytes\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    @Override\n-    protected void engineUpdateAAD(byte[] src, int offset, int len) {\n-        if (core.getMode() == CipherCore.GCM_MODE && updateCalled) {\n-            throw new IllegalStateException(\"AAD must be supplied before encryption\/decryption starts\");\n-        }\n-        core.updateAAD(src, offset, len);\n-    }\n-\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD).\n-     * <p>\n-     * Calls to this method provide AAD to the cipher when operating in\n-     * modes such as AEAD (GCM\/CCM).  If this cipher is operating in\n-     * either GCM or CCM mode, all AAD must be supplied before beginning\n-     * operations on the ciphertext (via the {@code update} and {@code\n-     * doFinal} methods).\n-     * <p>\n-     * All {@code src.remaining()} bytes starting at\n-     * {@code src.position()} are processed.\n-     * Upon return, the input buffer's position will be equal\n-     * to its limit; its limit will not have changed.\n-     *\n-     * @param src the buffer containing the AAD\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    @Override\n-    protected void engineUpdateAAD(ByteBuffer src) {\n-        if (core.getMode() == CipherCore.GCM_MODE && updateCalled) {\n-            throw new IllegalStateException(\"AAD must be supplied before encryption\/decryption starts\");\n-        }\n-        if (src != null) {\n-            int aadLen = src.limit() - src.position();\n-            if (aadLen > 0) {\n-                if (src.hasArray()) {\n-                    int aadOfs = Math.addExact(src.arrayOffset(), src.position());\n-                    core.updateAAD(src.array(), aadOfs, aadLen);\n-                    src.position(src.limit());\n-                } else {\n-                    byte[] aad = new byte[aadLen];\n-                    src.get(aad);\n-                    core.updateAAD(aad, 0, aadLen);\n-                }\n-            }\n-        }\n-    }\n-\n@@ -675,5 +595,1 @@\n-        if (core.getMode() == CipherCore.GCM_MODE && !input.hasArray()) {\n-            return core.gcmDoFinal(input, output);\n-        } else {\n-            return super.engineDoFinal(input, output);\n-        }\n+        return super.engineDoFinal(input, output);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCipher.java","additions":7,"deletions":91,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-     * 2) GCM mode + decryption - due to its trailing tag bytes\n@@ -128,1 +127,0 @@\n-    static final int GCM_MODE = 7;\n@@ -130,14 +128,0 @@\n-    \/*\n-     * variables used for performing the GCM (key+iv) uniqueness check.\n-     * To use GCM mode safely, the cipher object must be re-initialized\n-     * with a different combination of key + iv values for each\n-     * encryption operation. However, checking all past key + iv values\n-     * isn't feasible. Thus, we only do a per-instance check of the\n-     * key + iv values used in previous encryption.\n-     * For decryption operations, no checking is necessary.\n-     * NOTE: this key+iv check have to be done inside CipherCore class\n-     * since CipherCore class buffers potential tag bytes in GCM mode\n-     * and may not call GaloisCounterMode when there isn't sufficient\n-     * input to process.\n-     *\/\n-    private boolean requireReinit = false;\n@@ -145,1 +129,0 @@\n-    private byte[] lastEncIv = null;\n@@ -200,9 +183,0 @@\n-        }  else if (modeUpperCase.equals(\"GCM\")) {\n-            \/\/ can only be used for block ciphers w\/ 128-bit block size\n-            if (blockSize != 16) {\n-                throw new NoSuchAlgorithmException\n-                    (\"GCM mode can only be used for AES cipher\");\n-            }\n-            cipherMode = GCM_MODE;\n-            cipher = new GaloisCounterMode(rawImpl);\n-            padding = null;\n@@ -282,2 +256,1 @@\n-            ((cipherMode == CTR_MODE) || (cipherMode == CTS_MODE)\n-             || (cipherMode == GCM_MODE))) {\n+            ((cipherMode == CTR_MODE) || (cipherMode == CTS_MODE))) {\n@@ -290,3 +263,0 @@\n-            case GCM_MODE:\n-                modeStr = \"GCM\";\n-                break;\n@@ -313,1 +283,1 @@\n-     * previous <code>update<\/code> call, padding, and AEAD tagging.\n+     * previous <code>update<\/code> call, and padding.\n@@ -329,1 +299,1 @@\n-        int totalLen = Math.addExact(buffered, cipher.getBufferedLength());\n+        int totalLen = buffered;\n@@ -331,23 +301,4 @@\n-        switch (cipherMode) {\n-        case GCM_MODE:\n-            if (isDoFinal) {\n-                int tagLen = ((GaloisCounterMode) cipher).getTagLen();\n-                if (!decrypting) {\n-                    totalLen = Math.addExact(totalLen, tagLen);\n-                } else {\n-                    totalLen -= tagLen;\n-                }\n-            }\n-            if (totalLen < 0) {\n-                totalLen = 0;\n-            }\n-            break;\n-        default:\n-            if (padding != null && !decrypting) {\n-                if (unitBytes != blockSize) {\n-                    if (totalLen < diffBlocksize) {\n-                        totalLen = diffBlocksize;\n-                    } else {\n-                        int residue = (totalLen - diffBlocksize) % blockSize;\n-                        totalLen = Math.addExact(totalLen, (blockSize - residue));\n-                    }\n+        if (padding != null && !decrypting) {\n+            if (unitBytes != blockSize) {\n+                if (totalLen < diffBlocksize) {\n+                    totalLen = diffBlocksize;\n@@ -355,1 +306,2 @@\n-                    totalLen = Math.addExact(totalLen, padding.padLength(totalLen));\n+                    int residue = (totalLen - diffBlocksize) % blockSize;\n+                    totalLen = Math.addExact(totalLen, (blockSize - residue));\n@@ -357,0 +309,2 @@\n+            } else {\n+                totalLen = Math.addExact(totalLen, padding.padLength(totalLen));\n@@ -358,1 +312,0 @@\n-            break;\n@@ -401,6 +354,1 @@\n-            \/\/ generate spec using default value\n-            if (cipherMode == GCM_MODE) {\n-                iv = new byte[GaloisCounterMode.DEFAULT_IV_LEN];\n-            } else {\n-                iv = new byte[blockSize];\n-            }\n+            iv = new byte[blockSize];\n@@ -409,4 +357,4 @@\n-        if (cipherMode == GCM_MODE) {\n-            algName = \"GCM\";\n-            spec = new GCMParameterSpec\n-                (((GaloisCounterMode) cipher).getTagLen()*8, iv);\n+        if (algName.equals(\"RC2\")) {\n+            RC2Crypt rawImpl = (RC2Crypt) cipher.getEmbeddedCipher();\n+            spec = new RC2ParameterSpec\n+                (rawImpl.getEffectiveKeyBits(), iv);\n@@ -414,7 +362,1 @@\n-           if (algName.equals(\"RC2\")) {\n-               RC2Crypt rawImpl = (RC2Crypt) cipher.getEmbeddedCipher();\n-               spec = new RC2ParameterSpec\n-                   (rawImpl.getEffectiveKeyBits(), iv);\n-           } else {\n-               spec = new IvParameterSpec(iv);\n-           }\n+            spec = new IvParameterSpec(iv);\n@@ -508,1 +450,0 @@\n-            int tagLen = -1;\n@@ -511,11 +452,3 @@\n-                if (cipherMode == GCM_MODE) {\n-                    if (params instanceof GCMParameterSpec) {\n-                        tagLen = ((GCMParameterSpec) params).getTLen();\n-                        if (tagLen < 96 || tagLen > 128 || ((tagLen & 0x07) != 0)) {\n-                            throw new InvalidAlgorithmParameterException\n-                                    (\"Unsupported TLen value; must be one of \" +\n-                                            \"{128, 120, 112, 104, 96}\");\n-                        }\n-                        tagLen = tagLen >> 3;\n-                        ivBytes = ((GCMParameterSpec) params).getIV();\n-                    } else {\n+                if (params instanceof IvParameterSpec) {\n+                    ivBytes = ((IvParameterSpec) params).getIV();\n+                    if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n@@ -523,1 +456,2 @@\n-                                (\"Unsupported parameter: \" + params);\n+                            (\"Wrong IV length: must be \" + blockSize +\n+                                \" bytes long\");\n@@ -525,16 +459,3 @@\n-                } else {\n-                    if (params instanceof IvParameterSpec) {\n-                        ivBytes = ((IvParameterSpec) params).getIV();\n-                        if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n-                            throw new InvalidAlgorithmParameterException\n-                                    (\"Wrong IV length: must be \" + blockSize +\n-                                            \" bytes long\");\n-                        }\n-                    } else if (params instanceof RC2ParameterSpec) {\n-                        ivBytes = ((RC2ParameterSpec) params).getIV();\n-                        if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n-                            throw new InvalidAlgorithmParameterException\n-                                    (\"Wrong IV length: must be \" + blockSize +\n-                                            \" bytes long\");\n-                        }\n-                    } else {\n+                } else if (params instanceof RC2ParameterSpec) {\n+                    ivBytes = ((RC2ParameterSpec) params).getIV();\n+                    if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n@@ -542,1 +463,2 @@\n-                                (\"Unsupported parameter: \" + params);\n+                            (\"Wrong IV length: must be \" + blockSize +\n+                                \" bytes long\");\n@@ -544,0 +466,3 @@\n+                } else {\n+                    throw new InvalidAlgorithmParameterException\n+                        (\"Unsupported parameter: \" + params);\n@@ -560,5 +485,2 @@\n-                if (cipherMode == GCM_MODE) {\n-                    ivBytes = new byte[GaloisCounterMode.DEFAULT_IV_LEN];\n-                } else {\n-                    ivBytes = new byte[blockSize];\n-                }\n+\n+                ivBytes = new byte[blockSize];\n@@ -572,28 +494,1 @@\n-\n-            \/\/ GCM mode needs additional handling\n-            if (cipherMode == GCM_MODE) {\n-                if (tagLen == -1) {\n-                    tagLen = GaloisCounterMode.DEFAULT_TAG_LEN;\n-                }\n-                if (decrypting) {\n-                    minBytes = tagLen;\n-                } else {\n-                    \/\/ check key+iv for encryption in GCM mode\n-                    requireReinit =\n-                            Arrays.equals(ivBytes, lastEncIv) &&\n-                                    MessageDigest.isEqual(keyBytes, lastEncKey);\n-                    if (requireReinit) {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Cannot reuse iv for GCM encryption\");\n-                    }\n-                    lastEncIv = ivBytes;\n-                    if (lastEncKey != null) {\n-                        Arrays.fill(lastEncKey, (byte) 0);\n-                    }\n-                    lastEncKey = keyBytes;\n-                }\n-                ((GaloisCounterMode) cipher).init\n-                        (decrypting, algorithm, keyBytes, ivBytes, tagLen);\n-            } else {\n-                cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n-            }\n+            cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n@@ -601,1 +496,0 @@\n-            requireReinit = false;\n@@ -616,10 +510,5 @@\n-                if (cipherMode == GCM_MODE) {\n-                    paramType = \"GCM\";\n-                    spec = params.getParameterSpec(GCMParameterSpec.class);\n-                } else {\n-                    \/\/ NOTE: RC2 parameters are always handled through\n-                    \/\/ init(..., AlgorithmParameterSpec,...) method, so\n-                    \/\/ we can assume IvParameterSpec type here.\n-                    paramType = \"IV\";\n-                    spec = params.getParameterSpec(IvParameterSpec.class);\n-                }\n+                \/\/ NOTE: RC2 parameters are always handled through\n+                \/\/ init(..., AlgorithmParameterSpec,...) method, so\n+                \/\/ we can assume IvParameterSpec type here.\n+                paramType = \"IV\";\n+                spec = params.getParameterSpec(IvParameterSpec.class);\n@@ -674,1 +563,0 @@\n-        checkReinit();\n@@ -722,1 +610,0 @@\n-        checkReinit();\n@@ -857,1 +744,0 @@\n-            checkReinit();\n@@ -924,1 +810,0 @@\n-        checkReinit();\n@@ -946,6 +831,4 @@\n-            if (getMode() != GCM_MODE || outputCapacity < estOutSize) {\n-                \/\/ create temporary output buffer if the estimated size is larger\n-                \/\/ than the user-provided buffer.\n-                internalOutput = new byte[estOutSize];\n-                offset = 0;\n-            }\n+            \/\/ create temporary output buffer if the estimated size is larger\n+            \/\/ than the user-provided buffer.\n+            internalOutput = new byte[estOutSize];\n+            offset = 0;\n@@ -953,1 +836,0 @@\n-        byte[] outBuffer = (internalOutput != null) ? internalOutput : output;\n@@ -955,0 +837,1 @@\n+        byte[] outBuffer = (internalOutput != null) ? internalOutput : output;\n@@ -964,3 +847,2 @@\n-                                               + (outputCapacity)\n-                                               + \" bytes given, \" + outLen\n-                                               + \" bytes needed\");\n+                    + (outputCapacity) + \" bytes given, \" + outLen\n+                    + \" bytes needed\");\n@@ -970,1 +852,2 @@\n-                System.arraycopy(internalOutput, 0, output, outputOffset, outLen);\n+                System.arraycopy(internalOutput, 0, output, outputOffset,\n+                    outLen);\n@@ -1004,1 +887,1 @@\n-        int totalLen = Math.addExact(len, cipher.getBufferedLength());\n+        int totalLen = len;\n@@ -1062,4 +945,4 @@\n-                                 byte[] output, int outOfs, int finalBufLen,\n-                                 byte[] input)\n-            throws ShortBufferException, BadPaddingException,\n-            IllegalBlockSizeException {\n+        byte[] output, int outOfs, int finalBufLen, byte[] input)\n+        throws ShortBufferException, BadPaddingException,\n+        IllegalBlockSizeException {\n+\n@@ -1069,1 +952,1 @@\n-                    outOfs, finalBufLen);\n+                outOfs, finalBufLen);\n@@ -1075,7 +958,3 @@\n-            if (!decrypting) {\n-                \/\/ reset after doFinal() for GCM encryption\n-                requireReinit = (cipherMode == GCM_MODE);\n-                if (finalBuf != input) {\n-                    \/\/ done with internal finalBuf array. Copied to output\n-                    Arrays.fill(finalBuf, (byte) 0x00);\n-                }\n+            if (!decrypting && finalBuf != input) {\n+                \/\/ done with internal finalBuf array. Copied to output\n+                Arrays.fill(finalBuf, (byte) 0x00);\n@@ -1086,0 +965,1 @@\n+\n@@ -1101,7 +981,0 @@\n-    private void checkReinit() {\n-        if (requireReinit) {\n-            throw new IllegalStateException\n-                (\"Must use either different key or iv for GCM encryption\");\n-        }\n-    }\n-\n@@ -1110,2 +983,1 @@\n-        throws IllegalBlockSizeException, AEADBadTagException,\n-        ShortBufferException {\n+        throws IllegalBlockSizeException, ShortBufferException {\n@@ -1113,1 +985,1 @@\n-        if ((cipherMode != GCM_MODE) && (in == null || len == 0)) {\n+        if (in == null || len == 0) {\n@@ -1117,1 +989,0 @@\n-            (cipherMode != GCM_MODE) &&\n@@ -1129,1 +1000,1 @@\n-        int outLen = 0;\n+        int outLen;\n@@ -1220,55 +1091,0 @@\n-\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD), using a subset of the provided buffer.\n-     * <p>\n-     * Calls to this method provide AAD to the cipher when operating in\n-     * modes such as AEAD (GCM\/CCM).  If this cipher is operating in\n-     * either GCM or CCM mode, all AAD must be supplied before beginning\n-     * operations on the ciphertext (via the {@code update} and {@code\n-     * doFinal} methods).\n-     *\n-     * @param src the buffer containing the AAD\n-     * @param offset the offset in {@code src} where the AAD input starts\n-     * @param len the number of AAD bytes\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    void updateAAD(byte[] src, int offset, int len) {\n-        checkReinit();\n-        cipher.updateAAD(src, offset, len);\n-    }\n-\n-    \/\/ This must only be used with GCM.\n-    \/\/ If some data has been buffered from an update call, operate on the buffer\n-    \/\/ then run doFinal.\n-    int gcmDoFinal(ByteBuffer src, ByteBuffer dst) throws ShortBufferException,\n-        IllegalBlockSizeException, BadPaddingException {\n-        int estOutSize = getOutputSizeByOperation(src.remaining(), true);\n-        if (estOutSize > dst.remaining()) {\n-            throw new ShortBufferException(\"output buffer too small\");\n-        }\n-\n-        int len;\n-        if (decrypting) {\n-            if (buffered > 0) {\n-                cipher.decrypt(buffer, 0, buffered, new byte[0], 0);\n-            }\n-            len = cipher.decryptFinal(src, dst);\n-        } else {\n-            if (buffered > 0) {\n-                ((GaloisCounterMode)cipher).encrypt(buffer, 0, buffered);\n-            }\n-            len = cipher.encryptFinal(src, dst);\n-        }\n-        endDoFinal();\n-        return len;\n-    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":60,"deletions":244,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,2 +203,1 @@\n-         throws IllegalBlockSizeException, AEADBadTagException,\n-         ShortBufferException {\n+         throws IllegalBlockSizeException, ShortBufferException {\n@@ -208,28 +207,0 @@\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD), using a subset of the provided buffer. If this\n-     * cipher is operating in either GCM or CCM mode, all AAD must be\n-     * supplied before beginning operations on the ciphertext (via the\n-     * {@code update} and {@code doFinal} methods).\n-     * <p>\n-     * NOTE: Given most modes do not accept AAD, default impl for this\n-     * method throws IllegalStateException.\n-     *\n-     * @param src the buffer containing the AAD\n-     * @param offset the offset in {@code src} where the AAD input starts\n-     * @param len the number of AAD bytes\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    void updateAAD(byte[] src, int offset, int len) {\n-        throw new IllegalStateException(\"No AAD accepted\");\n-    }\n-\n@@ -242,2 +213,0 @@\n-        \/\/ Currently only AEAD cipher impl, e.g. GCM, buffers data\n-        \/\/ internally during decryption mode\n@@ -246,23 +215,0 @@\n-\n-    \/*\n-     * ByteBuffer methods should not be accessed as CipherCore and AESCipher\n-     * copy the data to byte arrays.  These methods are to satisfy the compiler.\n-     *\/\n-    int encrypt(ByteBuffer src, ByteBuffer dst) {\n-        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n-    };\n-\n-    int decrypt(ByteBuffer src, ByteBuffer dst) {\n-        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n-    };\n-\n-    int encryptFinal(ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException, ShortBufferException {\n-        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n-    };\n-\n-    int decryptFinal(ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException, AEADBadTagException,\n-        ShortBufferException {\n-        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n-    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/FeedbackCipher.java","additions":2,"deletions":56,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.nio.ByteBuffer;\n+\n+\/**\n+ * This interface allows GHASH.java and GCTR.java to easily operate to\n+ * better operate with GaloisCounterMode.java\n+ *\/\n+\n+public interface GCM {\n+    int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs);\n+    int update(byte[] in, int inOfs, int inLen, ByteBuffer dst);\n+    int update(ByteBuffer src, ByteBuffer dst);\n+    int doFinal(byte[] in, int inOfs, int inLen, byte[] out, int outOfs);\n+    int doFinal(ByteBuffer src, ByteBuffer dst);\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCM.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -34,2 +34,1 @@\n-import javax.crypto.IllegalBlockSizeException;\n-import static com.sun.crypto.provider.AESConstants.AES_BLOCK_SIZE;\n+import java.util.Arrays;\n@@ -55,1 +54,1 @@\n-final class GCTR extends CounterMode {\n+final class GCTR extends CounterMode implements GCM {\n@@ -59,0 +58,1 @@\n+    byte[] block;\n@@ -62,1 +62,1 @@\n-        if (initialCounterBlk.length != AES_BLOCK_SIZE) {\n+        if (initialCounterBlk.length != blockSize) {\n@@ -64,2 +64,2 @@\n-                initialCounterBlk.length + \") not equal to AES_BLOCK_SIZE (\" +\n-                AES_BLOCK_SIZE + \")\");\n+                initialCounterBlk.length + \") not equal to blockSize (\" +\n+                blockSize + \")\");\n@@ -86,2 +86,18 @@\n-    \/\/ input must be multiples of 128-bit blocks when calling update\n-    int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+    void checkBlock() {\n+        if (block == null) {\n+            block = new byte[blockSize];\n+        } else {\n+            Arrays.fill(block, (byte)0);\n+        }\n+    }\n+\n+    \/**\n+     * Using the given inLen, this operations only on blockSize data, leaving\n+     * the remainder in 'in'.\n+     * The return value will be (inLen - (inLen - blockSize))\n+     *\/\n+    public int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+        if (inLen == 0) {\n+            return 0;\n+        }\n+\n@@ -91,1 +107,1 @@\n-        if (inLen < 0 || inLen % AES_BLOCK_SIZE != 0) {\n+        if (inLen < 0) {\n@@ -94,1 +110,1 @@\n-        if (out.length - outOfs < inLen) {\n+        if (out.length - outOfs < (inLen - (inLen % blockSize))) {\n@@ -98,0 +114,1 @@\n+        inLen -= inLen % blockSize;\n@@ -99,1 +116,1 @@\n-        int numOfCompleteBlocks = inLen \/ AES_BLOCK_SIZE;\n+        int numOfCompleteBlocks = inLen \/ blockSize;\n@@ -103,1 +120,1 @@\n-            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            checkBlock();\n@@ -105,3 +122,3 @@\n-                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n-                    int index = (i * AES_BLOCK_SIZE + n);\n+                embeddedCipher.encryptBlock(counter, 0, block, 0);\n+                for (int n = 0; n < blockSize; n++) {\n+                    int index = (i * blockSize + n);\n@@ -109,1 +126,1 @@\n-                        (byte) ((in[inOfs + index] ^ encryptedCntr[n]));\n+                        (byte) ((in[inOfs + index] ^ block[n]));\n@@ -119,2 +136,14 @@\n-    \/\/ input must be multiples of AES blocks, 128-bit, when calling update\n-    int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+    \/**\n+     * Operate on only blocksize data leaving the remainder in 'in' .\n+     *\/\n+    public int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+        \/\/ If the bytebuffer is backed by arrays, use that instead of\n+        \/\/ allocating and copying for direct bytebuffers\n+        if (!dst.isDirect()) {\n+            int len = update(in, inOfs, inLen,  dst.array(),\n+                dst.arrayOffset() + dst.position());\n+            dst.position(dst.position() + len);\n+            return len;\n+        }\n+\n+        \/\/ Direct ByteBuffer operation\n@@ -124,1 +153,1 @@\n-        if (inLen < 0 || inLen % AES_BLOCK_SIZE != 0) {\n+        if (inLen < 0 || inLen % blockSize != 0) {\n@@ -131,1 +160,1 @@\n-        int numOfCompleteBlocks = inLen \/ AES_BLOCK_SIZE;\n+        int numOfCompleteBlocks = inLen \/ blockSize;\n@@ -135,1 +164,1 @@\n-            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            checkBlock();\n@@ -137,4 +166,4 @@\n-                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n-                    int index = (i * AES_BLOCK_SIZE + n);\n-                    dst.put((byte) ((in[inOfs + index] ^ encryptedCntr[n])));\n+                embeddedCipher.encryptBlock(counter, 0, block, 0);\n+                for (int n = 0; n < blockSize; n++) {\n+                    int index = (i * blockSize + n);\n+                    dst.put((byte) ((in[inOfs + index] ^ block[n])));\n@@ -146,1 +175,1 @@\n-            int len = inLen - inLen % AES_BLOCK_SIZE;\n+            int len = inLen - inLen % blockSize;\n@@ -165,3 +194,19 @@\n-    \/\/ input operates on multiples of AES blocks, 128-bit, when calling update.\n-    \/\/ The remainder is left in the src buffer.\n-    int update(ByteBuffer src, ByteBuffer dst) {\n+    \/**\n+     * Operate on only blocksize data leaving the remainder in the src buffer.\n+     *\/\n+    public int update(ByteBuffer src, ByteBuffer dst) {\n+        int len;\n+\n+        \/\/ If the bytebuffer is backed by arrays, use that instead of\n+        \/\/ allocating and copying for direct bytebuffers\n+        if (!src.isDirect() && !dst.isDirect() &&\n+            !src.isReadOnly() && !dst.isReadOnly()) {\n+            len = update(src.array(), src.arrayOffset() + src.position(),\n+                src.remaining() - (src.remaining() % blockSize),\n+                dst.array(), dst.arrayOffset() + dst.position());\n+            src.position(src.position() + len);\n+            dst.position(dst.position() + len);\n+            return len;\n+        }\n+\n+        \/\/ Direct bytebuffer operation\n@@ -169,1 +214,1 @@\n-        int numOfCompleteBlocks = src.remaining() \/ AES_BLOCK_SIZE;\n+        int numOfCompleteBlocks = src.remaining() \/ blockSize;\n@@ -173,1 +218,0 @@\n-            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n@@ -175,3 +219,4 @@\n-                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n-                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n+                checkBlock();\n+                embeddedCipher.encryptBlock(counter, 0, block, 0);\n+                for (int n = 0; n < blockSize; n++) {\n+                    dst.put((byte) (src.get() ^ block[n]));\n@@ -181,1 +226,1 @@\n-            return numOfCompleteBlocks * AES_BLOCK_SIZE;\n+            return numOfCompleteBlocks * blockSize;\n@@ -184,1 +229,1 @@\n-        int len = src.remaining() - (src.remaining() % AES_BLOCK_SIZE);\n+        len = src.remaining() - (src.remaining() % blockSize);\n@@ -199,21 +244,22 @@\n-    \/\/ input can be arbitrary size when calling doFinal\n-    int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n-        int outOfs) throws IllegalBlockSizeException {\n-        try {\n-            if (inLen < 0) {\n-                throw new IllegalBlockSizeException(\"Negative input size!\");\n-            } else if (inLen > 0) {\n-                int lastBlockSize = inLen % AES_BLOCK_SIZE;\n-                int completeBlkLen = inLen - lastBlockSize;\n-                \/\/ process the complete blocks first\n-                update(in, inOfs, completeBlkLen, out, outOfs);\n-                if (lastBlockSize != 0) {\n-                    \/\/ do the last partial block\n-                    byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n-                    embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                    for (int n = 0; n < lastBlockSize; n++) {\n-                        out[outOfs + completeBlkLen + n] =\n-                            (byte) ((in[inOfs + completeBlkLen + n] ^\n-                                encryptedCntr[n]));\n-                    }\n-                }\n+    \/**\n+     * doFinal operation by using update() for any full block operations needed,\n+     * then operating on the final bytes in the input buffer.\n+     *\n+     * This method will not write any block padding to the output buffer\n+     *\/\n+    public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+        int outOfs) {\n+        if (inLen == 0) {\n+            return 0;\n+        }\n+        int lastBlockSize = inLen % blockSize;\n+        int completeBlkLen = inLen - lastBlockSize;\n+        \/\/ process the complete blocks first\n+        update(in, inOfs, completeBlkLen, out, outOfs);\n+        if (lastBlockSize != 0) {\n+            \/\/ do the last partial block\n+            checkBlock();\n+            embeddedCipher.encryptBlock(counter, 0, block, 0);\n+            for (int n = 0; n < lastBlockSize; n++) {\n+                out[outOfs + completeBlkLen + n] =\n+                    (byte) ((in[inOfs + completeBlkLen + n] ^ block[n]));\n@@ -221,2 +267,0 @@\n-        } finally {\n-            reset();\n@@ -224,0 +268,1 @@\n+        reset();\n@@ -227,2 +272,20 @@\n-    \/\/ src can be arbitrary size when calling doFinal\n-    int doFinal(ByteBuffer src, ByteBuffer dst) {\n+    \/**\n+     * doFinal operation by using update() for any full block operations needed,\n+     * then operating on the final bytes in the input buffer.\n+     *\n+     * If src and dst are array-backed bytebuffers, call doFinal(byte[]...) for\n+     * less memory usage.\n+     *\/\n+    public int doFinal(ByteBuffer src, ByteBuffer dst) {\n+        \/\/ If the bytebuffer is backed by arrays, use that instead of\n+        \/\/ allocating and copying for direct bytebuffers\n+        if (!src.isDirect() && !dst.isDirect() &&\n+            !src.isReadOnly() && !dst.isReadOnly()) {\n+            int len = doFinal(src.array(), src.arrayOffset() + src.position(),\n+                src.remaining(), dst.array(),\n+                dst.arrayOffset() + dst.position());\n+            src.position(src.position() + len);\n+            dst.position(dst.position() + len);\n+            return len;\n+        }\n+\n@@ -230,1 +293,1 @@\n-        int lastBlockSize = len % AES_BLOCK_SIZE;\n+        int lastBlockSize = len % blockSize;\n@@ -234,0 +297,1 @@\n+                checkBlock();\n@@ -235,2 +299,1 @@\n-                byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n-                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n+                embeddedCipher.encryptBlock(counter, 0, block, 0);\n@@ -238,1 +301,1 @@\n-                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n+                    dst.put((byte) (src.get() ^ block[n]));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":128,"deletions":65,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2015 Red Hat, Inc.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +27,1 @@\n+ * Copyright (c) 2015 Red Hat, Inc.\n@@ -32,0 +32,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -33,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -47,10 +50,6 @@\n-final class GHASH {\n-\n-    private static long getLong(byte[] buffer, int offset) {\n-        long result = 0;\n-        int end = offset + 8;\n-        for (int i = offset; i < end; ++i) {\n-            result = (result << 8) + (buffer[i] & 0xFF);\n-        }\n-        return result;\n-    }\n+final class GHASH implements Cloneable, GCM {\n+    private static final int AES_BLOCK_SIZE = 16;\n+    \/\/ Handle for converting byte[] <-> long\n+    private static final VarHandle asLongView =\n+        MethodHandles.byteArrayViewVarHandle(long[].class,\n+            ByteOrder.BIG_ENDIAN);\n@@ -58,7 +57,2 @@\n-    private static void putLong(byte[] buffer, int offset, long value) {\n-        int end = offset + 8;\n-        for (int i = end - 1; i >= offset; --i) {\n-            buffer[i] = (byte) value;\n-            value >>= 8;\n-        }\n-    }\n+    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n+    private static final int MAX_LEN = 1024;\n@@ -66,1 +60,0 @@\n-    private static final int AES_BLOCK_SIZE = 16;\n@@ -130,1 +123,2 @@\n-    \/\/ hashtable subkeyHtbl; holds 2*9 powers of subkeyH computed using carry-less multiplication\n+    \/\/ hashtable subkeyHtbl holds 2*9 powers of subkeyH computed using\n+    \/\/ carry-less multiplication\n@@ -136,3 +130,0 @@\n-    \/\/ variables for save\/restore calls\n-    private long stateSave0, stateSave1;\n-\n@@ -154,2 +145,2 @@\n-        subkeyHtbl[0] = getLong(subkeyH, 0);\n-        subkeyHtbl[1] = getLong(subkeyH, 8);\n+        subkeyHtbl[0] = (long)asLongView.get(subkeyH, 0);\n+        subkeyHtbl[1] = (long)asLongView.get(subkeyH, 8);\n@@ -158,8 +149,4 @@\n-    \/**\n-     * Resets the GHASH object to its original state, i.e. blank w\/\n-     * the same subkey H. Used after digest() is called and to re-use\n-     * this object for different data w\/ the same H.\n-     *\/\n-    void reset() {\n-        state[0] = 0;\n-        state[1] = 0;\n+    \/\/ Cloning constructor\n+    private GHASH(GHASH g) {\n+        state = g.state.clone();\n+        subkeyHtbl = g.subkeyHtbl.clone();\n@@ -168,14 +155,3 @@\n-    \/**\n-     * Save the current snapshot of this GHASH object.\n-     *\/\n-    void save() {\n-        stateSave0 = state[0];\n-        stateSave1 = state[1];\n-    }\n-\n-    \/**\n-     * Restores this object using the saved snapshot.\n-     *\/\n-    void restore() {\n-        state[0] = stateSave0;\n-        state[1] = stateSave1;\n+    @Override\n+    public GHASH clone() {\n+        return new GHASH(this);\n@@ -185,2 +161,2 @@\n-        st[0] ^= getLong(data, ofs);\n-        st[1] ^= getLong(data, ofs + 8);\n+        st[0] ^= (long)asLongView.get(data, ofs);\n+        st[1] ^= (long)asLongView.get(data, ofs + 8);\n@@ -190,2 +166,2 @@\n-    void update(byte[] in) {\n-        update(in, 0, in.length);\n+    int update(byte[] in) {\n+        return update(in, 0, in.length);\n@@ -194,1 +170,1 @@\n-    void update(byte[] in, int inOfs, int inLen) {\n+    int update(byte[] in, int inOfs, int inLen) {\n@@ -196,1 +172,1 @@\n-            return;\n+            return 0;\n@@ -198,2 +174,4 @@\n-        ghashRangeCheck(in, inOfs, inLen, state, subkeyHtbl);\n-        processBlocks(in, inOfs, inLen\/AES_BLOCK_SIZE, state, subkeyHtbl);\n+        int len = inLen - (inLen % AES_BLOCK_SIZE);\n+        ghashRangeCheck(in, inOfs, len, state, subkeyHtbl);\n+        processBlocks(in, inOfs, len \/ AES_BLOCK_SIZE, state, subkeyHtbl);\n+        return len;\n@@ -202,3 +180,0 @@\n-    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n-    private static final int MAX_LEN = 1024;\n-\n@@ -206,1 +181,18 @@\n-    int update(ByteBuffer src, int inLen) {\n+    int update(ByteBuffer ct, int inLen) {\n+\n+        \/\/ If src is a direct bytebuffer, send it directly to the intrinsic\n+        if (ct.isDirect()) {\n+            int processed = inLen - (inLen % AES_BLOCK_SIZE);\n+            processBlocksDirect(ct, inLen);\n+            ct.position(ct.position());\n+            return processed;\n+        } else if (!ct.isReadOnly()) {\n+            \/\/ If a non-read only heap bytebuffer, use the array update method\n+            int processed = update(ct.array(),\n+                ct.arrayOffset() + ct.position(),\n+                inLen);\n+            ct.position(ct.position() + processed);\n+            return processed;\n+        }\n+\n+        \/\/ Read only heap bytebuffers have to be copied and operated on\n@@ -211,2 +203,1 @@\n-\n-        int processed = inLen;\n+        int to_process = inLen;\n@@ -214,2 +205,2 @@\n-        while (processed > MAX_LEN ) {\n-            src.get(in, 0, MAX_LEN);\n+        while (to_process > MAX_LEN ) {\n+            ct.get(in, 0, MAX_LEN);\n@@ -217,1 +208,1 @@\n-            processed -= MAX_LEN;\n+            to_process -= MAX_LEN;\n@@ -219,2 +210,2 @@\n-        src.get(in, 0, processed);\n-        update(in, 0, processed);\n+        ct.get(in, 0, to_process);\n+        update(in, 0, to_process);\n@@ -224,2 +215,7 @@\n-    void doLastBlock(ByteBuffer src, int inLen) {\n-        int processed = update(src, inLen);\n+    int doFinal(ByteBuffer src, int inLen) {\n+        int processed = 0;\n+\n+        if (inLen >= AES_BLOCK_SIZE) {\n+            processed = update(src, inLen);\n+        }\n+\n@@ -227,1 +223,1 @@\n-            return;\n+            return processed;\n@@ -232,0 +228,13 @@\n+        return inLen;\n+    }\n+\n+    int doFinal(byte[] in, int inOfs, int inLen) {\n+        int remainder = inLen % AES_BLOCK_SIZE;\n+        inOfs += update(in, inOfs, inLen - remainder);\n+        if (remainder > 0) {\n+            byte[] block = new byte[AES_BLOCK_SIZE];\n+            System.arraycopy(in, inOfs, block, 0,\n+                remainder);\n+            update(block, 0, AES_BLOCK_SIZE);\n+        }\n+        return inLen;\n@@ -275,0 +284,15 @@\n+    \/\/ ProcessBlock for Direct ByteBuffers\n+    private void processBlocksDirect(ByteBuffer ct, int inLen) {\n+        byte[] data = new byte[Math.min(MAX_LEN, inLen)];\n+        while (inLen > MAX_LEN) {\n+            ct.get(data, 0, MAX_LEN);\n+            processBlocks(data, 0, MAX_LEN \/ AES_BLOCK_SIZE, state, subkeyHtbl);\n+            inLen -= MAX_LEN;\n+        }\n+        if (inLen >= AES_BLOCK_SIZE) {\n+            int len = inLen - (inLen % AES_BLOCK_SIZE);\n+            ct.get(data, 0, len);\n+            processBlocks(data, 0, len \/ AES_BLOCK_SIZE, state, subkeyHtbl);\n+        }\n+    }\n+\n@@ -277,3 +301,5 @@\n-        putLong(result, 0, state[0]);\n-        putLong(result, 8, state[1]);\n-        reset();\n+        asLongView.set(result, 0, state[0]);\n+        asLongView.set(result, 8, state[1]);\n+        \/\/ Reset state\n+        state[0] = 0;\n+        state[1] = 0;\n@@ -282,0 +308,31 @@\n+\n+\n+    \/**\n+     * None of the out or dst values are necessary, they are to satisfy the\n+     * GCM interface requirement\n+     *\/\n+    @Override\n+    public int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+        return update(in, inOfs, inLen);\n+    }\n+\n+    @Override\n+    public int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+        return update(in, inOfs, inLen);\n+    }\n+\n+    @Override\n+    public int update(ByteBuffer src, ByteBuffer dst) {\n+        return update(src, src.remaining());\n+    }\n+\n+    @Override\n+    public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+        int outOfs) {\n+        return doFinal(in, inOfs, inLen);\n+    }\n+\n+    @Override\n+    public int doFinal(ByteBuffer src, ByteBuffer dst) {\n+        return doFinal(src, src.remaining());\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":130,"deletions":73,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherSpi;\n@@ -33,0 +36,1 @@\n+import javax.crypto.NoSuchPaddingException;\n@@ -34,0 +38,1 @@\n+import javax.crypto.spec.GCMParameterSpec;\n@@ -36,0 +41,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -37,0 +44,2 @@\n+import java.nio.ByteOrder;\n+import java.security.AlgorithmParameters;\n@@ -39,0 +48,2 @@\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n@@ -40,3 +51,4 @@\n-\n-import static com.sun.crypto.provider.AESConstants.AES_BLOCK_SIZE;\n-\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n@@ -57,1 +69,1 @@\n-final class GaloisCounterMode extends FeedbackCipher {\n+abstract class GaloisCounterMode extends CipherSpi {\n@@ -59,1 +71,5 @@\n-    static int DEFAULT_TAG_LEN = AES_BLOCK_SIZE;\n+    SymmetricCipher blockCipher;\n+    \/\/ Engine instance for encryption or decryption\n+    private GCMEngine engine;\n+\n+    private boolean encryption = true;\n@@ -75,3 +91,12 @@\n-    \/\/ buffer for AAD data; if null, meaning update has been called\n-    private ByteArrayOutputStream aadBuffer = new ByteArrayOutputStream();\n-    private int sizeOfAAD = 0;\n+    private boolean initialized = false;\n+    \/\/ Default value is 128bits, this in stores bytes.\n+    int tagLenBytes = 16;\n+    \/\/ Key size if the value is passed\n+    int keySize;\n+    \/\/ Prevent reuse of iv or key\n+    boolean reInit = false;\n+    final static byte[] emptyBuf = new byte[0];\n+    byte[] lastKey = emptyBuf;\n+    byte[] lastIv = emptyBuf;\n+    byte[] iv = null;\n+\n@@ -79,2 +104,9 @@\n-    \/\/ buffer data for crypto operation\n-    private ByteArrayOutputStream ibuffer = null;\n+    \/**\n+     *\n+     * @param keySize length of key.\n+     * @param embeddedCipher Cipher object, such as AESCrypt.\n+     *\/\n+    GaloisCounterMode(int keySize, SymmetricCipher embeddedCipher) {\n+        blockCipher = embeddedCipher;\n+        this.keySize = keySize;\n+    }\n@@ -82,2 +114,20 @@\n-    \/\/ Original dst buffer if there was an overlap situation\n-    private ByteBuffer originalDst = null;\n+    \/**\n+     * Initializes the cipher in the specified mode with the given key\n+     * and iv.\n+     *\/\n+    void init(int opmode, Key key, GCMParameterSpec spec)\n+        throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        encryption = (opmode == Cipher.ENCRYPT_MODE) ||\n+            (opmode == Cipher.WRAP_MODE);\n+\n+        \/\/ Check the Key object is valid and the right size\n+        if (key == null) {\n+            throw new InvalidKeyException(\"The key must not be null\");\n+        }\n+        byte[] keyValue = key.getEncoded();\n+        if (keyValue == null) {\n+            throw new InvalidKeyException(\"Key encoding must not be null\");\n+        } else if (keySize != -1 && keyValue.length != keySize) {\n+            throw new InvalidKeyException(\"The key must be \" +\n+                keySize + \" bytes\");\n+        }\n@@ -85,2 +135,7 @@\n-    \/\/ in bytes; need to convert to bits (default value 128) when needed\n-    private int tagLenBytes = DEFAULT_TAG_LEN;\n+        \/\/ Check for reuse\n+        if (encryption) {\n+            if (Arrays.compare(keyValue, lastKey) == 0 && Arrays.compare(iv,\n+                lastIv) == 0) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"Cannot reuse iv for GCM encryption\");\n+            }\n@@ -88,4 +143,8 @@\n-    \/\/ these following 2 fields can only be initialized after init() is\n-    \/\/ called, e.g. after cipher key k is set, and STAY UNCHANGED\n-    private byte[] subkeyH = null;\n-    private byte[] preCounterBlock = null;\n+            \/\/ Both values are already clones\n+            lastKey = keyValue;\n+            lastIv = iv;\n+        } else {\n+            if (spec == null) {\n+                throw new InvalidKeyException(\"No GCMParameterSpec specified\");\n+            }\n+        }\n@@ -93,2 +152,1 @@\n-    private GCTR gctrPAndC = null;\n-    private GHASH ghashAllToS = null;\n+        reInit = false;\n@@ -96,2 +154,7 @@\n-    \/\/ length of total data, i.e. len(C)\n-    private int processed = 0;\n+        int tagLen = spec.getTLen();\n+        if (tagLen < 96 || tagLen > 128 || ((tagLen & 0x07) != 0)) {\n+            throw new InvalidAlgorithmParameterException\n+                (\"Unsupported TLen value.  Must be one of \" +\n+                    \"{128, 120, 112, 104, 96}\");\n+        }\n+        tagLenBytes = tagLen >> 3;\n@@ -99,5 +162,3 @@\n-    \/\/ additional variables for save\/restore calls\n-    private byte[] aadBufferSave = null;\n-    private int sizeOfAADSave = 0;\n-    private byte[] ibufferSave = null;\n-    private int processedSave = 0;\n+        \/\/ always encrypt mode for embedded cipher\n+        blockCipher.init(false, key.getAlgorithm(), keyValue);\n+    }\n@@ -105,3 +166,277 @@\n-    \/\/ value must be 16-byte long; used by GCTR and GHASH as well\n-    static void increment32(byte[] value) {\n-        if (value.length != AES_BLOCK_SIZE) {\n+    \/\/ return tag length in bytes\n+    int getTagLen() {\n+        return this.tagLenBytes;\n+    }\n+\n+    @Override\n+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n+        if (!mode.equalsIgnoreCase(\"GCM\")) {\n+            throw new NoSuchAlgorithmException(\"Mode must be GCM\");\n+        }\n+    }\n+\n+    @Override\n+    protected void engineSetPadding(String padding)\n+        throws NoSuchPaddingException {\n+        if (!padding.equalsIgnoreCase(\"NoPadding\")) {\n+            throw new NoSuchPaddingException(\"Padding must be NoPadding\");\n+        }\n+    }\n+\n+    @Override\n+    protected int engineGetBlockSize() {\n+        return blockCipher.getBlockSize();\n+    }\n+\n+    @Override\n+    protected int engineGetOutputSize(int inputLen) {\n+        checkInit();\n+        return engine.getOutputSize(inputLen, true);\n+    }\n+\n+    @Override\n+    protected int engineGetKeySize(Key key) throws InvalidKeyException {\n+        return super.engineGetKeySize(key);\n+    }\n+\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return iv.clone();\n+    }\n+\n+    \/**\n+     * Create a random 16-byte iv.\n+     *\n+     * @param random a {@code SecureRandom} object.  If {@code null} is\n+     * provided a new {@code SecureRandom} object will be instantiated.\n+     *\n+     * @return a 16-byte array containing the random nonce.\n+     *\/\n+    private static byte[] createIv(SecureRandom random) {\n+        byte[] iv = new byte[DEFAULT_IV_LEN];\n+        if (random != null) {\n+            random.nextBytes(iv);\n+        } else {\n+            new SecureRandom().nextBytes(iv);\n+        }\n+        return iv;\n+    }\n+\n+    SecureRandom random = null;\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        GCMParameterSpec spec;\n+        spec = new GCMParameterSpec(getTagLen() * 8,\n+            iv == null ? createIv(random) : iv.clone());\n+        try {\n+            AlgorithmParameters params =\n+                AlgorithmParameters.getInstance(\"GCM\",\n+                    SunJCE.getInstance());\n+            params.init(spec);\n+            return params;\n+        } catch (NoSuchAlgorithmException | InvalidParameterSpecException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, SecureRandom random)\n+        throws InvalidKeyException {\n+\n+        engine = null;\n+        if (opmode == Cipher.DECRYPT_MODE || opmode == Cipher.UNWRAP_MODE) {\n+            throw new InvalidKeyException(\"No GCMParameterSpec specified\");\n+        }\n+        try {\n+            engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            \/\/ never happen\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+        AlgorithmParameterSpec params, SecureRandom random)\n+        throws InvalidKeyException, InvalidAlgorithmParameterException {\n+\n+        GCMParameterSpec spec;\n+        engine = null;\n+        if (params == null) {\n+            iv = createIv(random);\n+            spec = new GCMParameterSpec(getTagLen() * 8, iv);\n+        } else {\n+            if (!(params instanceof GCMParameterSpec)) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"AlgorithmParameterSpec not of GCMParameterSpec\");\n+            }\n+            spec = (GCMParameterSpec)params;\n+            iv = spec.getIV();\n+            if (iv == null) {\n+                throw new InvalidAlgorithmParameterException(\"IV is null\");\n+            }\n+            if (iv.length == 0) {\n+                throw new InvalidAlgorithmParameterException(\"IV is empty\");\n+            }\n+        }\n+        init(opmode, key, spec);\n+        initialized = true;\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, AlgorithmParameters params,\n+        SecureRandom random) throws InvalidKeyException,\n+        InvalidAlgorithmParameterException {\n+        GCMParameterSpec spec = null;\n+        engine = null;\n+        if (params != null) {\n+            try {\n+                spec = params.getParameterSpec(GCMParameterSpec.class);\n+            } catch (InvalidParameterSpecException e) {\n+                throw new InvalidAlgorithmParameterException(e);\n+            }\n+        }\n+        engineInit(opmode, key, spec, random);\n+    }\n+\n+    void checkInit() {\n+        if (!initialized) {\n+            throw new IllegalStateException(\"Operation not initialized.\");\n+        }\n+\n+        if (engine == null) {\n+            if (encryption) {\n+                engine = new GCMEncrypt(blockCipher);\n+            } else {\n+                engine = new GCMDecrypt(blockCipher);\n+            }\n+        }\n+    }\n+\n+    void checkReInit() {\n+        if (reInit) {\n+            throw new IllegalStateException(\n+                \"Must use either different key or \" + \" iv for GCM encryption\");\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {\n+        checkInit();\n+        return engine.doUpdate(input, inputOffset, inputLen);\n+    }\n+\n+    @Override\n+    protected int engineUpdate(byte[] input, int inputOffset, int inputLen,\n+        byte[] output, int outputOffset) throws ShortBufferException {\n+        checkInit();\n+        int len = engine.getOutputSize(inputLen, false);\n+        if (len > output.length - outputOffset) {\n+            throw new ShortBufferException(\"Output buffer too small, must be \" +\n+                \"at least \" + len + \" bytes long\");\n+        }\n+        return engine.doUpdate(input, inputOffset, inputLen, output,\n+            outputOffset);\n+    }\n+\n+    @Override\n+    protected int engineUpdate(ByteBuffer src, ByteBuffer dst)\n+        throws ShortBufferException {\n+        checkInit();\n+        int len = engine.getOutputSize(src.remaining(), false);\n+        if (len > dst.remaining()) {\n+            throw new ShortBufferException(\n+                \"Output buffer must be at least \" + len + \" bytes long\");\n+        }\n+        return engine.doUpdate(src, dst);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(byte[] src, int offset, int len) {\n+        checkInit();\n+        engine.updateAAD(src, offset, len);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(ByteBuffer src) {\n+        checkInit();\n+        if (src.hasArray()) {\n+            int pos = src.position();\n+            int len = src.remaining();\n+            engine.updateAAD(src.array(), src.arrayOffset() + pos, len);\n+            src.position(pos + len);\n+        } else {\n+            byte[] aad = new byte[src.remaining()];\n+            src.get(aad);\n+            engine.updateAAD(aad, 0, aad.length);\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineDoFinal(byte[] input, int inputOffset,\n+        int inputLen) throws IllegalBlockSizeException, BadPaddingException {\n+        checkInit();\n+        byte[] output = new byte[engine.getOutputSize(inputLen, true)];\n+        if (input == null) {\n+            input = emptyBuf;\n+        }\n+        try {\n+            engine.doFinal(input, inputOffset, inputLen, output, 0);\n+        } catch (ShortBufferException e) {\n+            throw new ProviderException(e);\n+        } finally {\n+            \/\/ Release crypto engine\n+            engine = null;\n+        }\n+        return output;\n+    }\n+\n+    @Override\n+    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,\n+        byte[] output, int outputOffset) throws ShortBufferException,\n+        IllegalBlockSizeException, BadPaddingException {\n+        checkInit();\n+        if (input == null) {\n+            input = emptyBuf;\n+        }\n+        try {\n+            ArrayUtil.nullAndBoundsCheck(input, inputOffset, inputLen);\n+        } catch (Exception e) {\n+            \/\/ Release crypto engine\n+            engine = null;\n+            throw new IllegalBlockSizeException(\"input array invalid\");\n+        }\n+        int len = engine.doFinal(input, inputOffset, inputLen, output,\n+            outputOffset);\n+\n+        \/\/ Release crypto engine\n+        engine = null;\n+\n+        return len;\n+    }\n+\n+    @Override\n+    protected int engineDoFinal(ByteBuffer src, ByteBuffer dst)\n+        throws ShortBufferException, IllegalBlockSizeException,\n+        BadPaddingException {\n+        checkInit();\n+\n+        int len = engine.doFinal(src, dst);\n+\n+        \/\/ Release crypto engine\n+        engine = null;\n+\n+        return len;\n+    }\n+\n+    @Override\n+    protected byte[] engineWrap(Key key) throws IllegalBlockSizeException,\n+        InvalidKeyException {\n+        checkInit();\n+        try {\n+            byte[] encodedKey = key.getEncoded();\n+            if ((encodedKey == null) || (encodedKey.length == 0)) {\n+                throw new InvalidKeyException(\n+                    \"Cannot get an encoding of the key to be wrapped\");\n+            }\n+            return engineDoFinal(encodedKey, 0, encodedKey.length);\n+        } catch (BadPaddingException e) {\n@@ -109,1 +444,3 @@\n-            throw new ProviderException(\"Illegal counter block length\");\n+        } finally {\n+            \/\/ Release crypto engine\n+            engine = null;\n@@ -111,0 +448,26 @@\n+        return null;\n+    }\n+\n+    @Override\n+    protected Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm,\n+        int wrappedKeyType) throws InvalidKeyException,\n+        NoSuchAlgorithmException {\n+        checkInit();\n+\n+        byte[] encodedKey;\n+        try {\n+            encodedKey = engineDoFinal(wrappedKey, 0,\n+                wrappedKey.length);\n+        } catch (BadPaddingException ePadding) {\n+            throw new InvalidKeyException(\n+                \"The wrapped key is not padded correctly\");\n+        } catch (IllegalBlockSizeException eBlockSize) {\n+            throw new InvalidKeyException(\n+                \"The wrapped key does not have the correct length\");\n+        }\n+        return ConstructKeys.constructKey(encodedKey, wrappedKeyAlgorithm,\n+                                          wrappedKeyType);\n+    }\n+\n+    \/\/ value must be 16-byte long; used by GCTR and GHASH as well\n+    static void increment32(byte[] value) {\n@@ -118,11 +481,6 @@\n-    private static byte[] getLengthBlock(int ivLenInBytes) {\n-        long ivLen = ((long)ivLenInBytes) << 3;\n-        byte[] out = new byte[AES_BLOCK_SIZE];\n-        out[8] = (byte)(ivLen >>> 56);\n-        out[9] = (byte)(ivLen >>> 48);\n-        out[10] = (byte)(ivLen >>> 40);\n-        out[11] = (byte)(ivLen >>> 32);\n-        out[12] = (byte)(ivLen >>> 24);\n-        out[13] = (byte)(ivLen >>> 16);\n-        out[14] = (byte)(ivLen >>> 8);\n-        out[15] = (byte)ivLen;\n+    private static final VarHandle wrapToByteArray =\n+        MethodHandles.byteArrayViewVarHandle(long[].class,\n+            ByteOrder.BIG_ENDIAN);\n+\n+    private static byte[] getLengthBlock(int ivLenInBytes, byte[] out) {\n+        wrapToByteArray.set(out, 8, ((long)ivLenInBytes  & 0xFFFFFFFFL) << 3);\n@@ -132,21 +490,4 @@\n-    private static byte[] getLengthBlock(int aLenInBytes, int cLenInBytes) {\n-        long aLen = ((long)aLenInBytes) << 3;\n-        long cLen = ((long)cLenInBytes) << 3;\n-        byte[] out = new byte[AES_BLOCK_SIZE];\n-        out[0] = (byte)(aLen >>> 56);\n-        out[1] = (byte)(aLen >>> 48);\n-        out[2] = (byte)(aLen >>> 40);\n-        out[3] = (byte)(aLen >>> 32);\n-        out[4] = (byte)(aLen >>> 24);\n-        out[5] = (byte)(aLen >>> 16);\n-        out[6] = (byte)(aLen >>> 8);\n-        out[7] = (byte)aLen;\n-        out[8] = (byte)(cLen >>> 56);\n-        out[9] = (byte)(cLen >>> 48);\n-        out[10] = (byte)(cLen >>> 40);\n-        out[11] = (byte)(cLen >>> 32);\n-        out[12] = (byte)(cLen >>> 24);\n-        out[13] = (byte)(cLen >>> 16);\n-        out[14] = (byte)(cLen >>> 8);\n-        out[15] = (byte)cLen;\n-        return out;\n+    private static void getLengthBlock(int aLenInBytes, int cLenInBytes,\n+        byte[] out) {\n+        wrapToByteArray.set(out, 0, ((long)aLenInBytes & 0xFFFFFFFFL) << 3);\n+        wrapToByteArray.set(out, 8, ((long)cLenInBytes & 0xFFFFFFFFL) << 3);\n@@ -155,2 +496,3 @@\n-    private static byte[] expandToOneBlock(byte[] in, int inOfs, int len) {\n-        if (len > AES_BLOCK_SIZE) {\n+    private static byte[] expandToOneBlock(byte[] in, int inOfs, int len,\n+        int blockSize) {\n+        if (len > blockSize) {\n@@ -159,1 +501,1 @@\n-        if (len == AES_BLOCK_SIZE && inOfs == 0) {\n+        if (len == blockSize && inOfs == 0) {\n@@ -162,1 +504,1 @@\n-            byte[] paddedIn = new byte[AES_BLOCK_SIZE];\n+            byte[] paddedIn = new byte[blockSize];\n@@ -168,1 +510,1 @@\n-    private static byte[] getJ0(byte[] iv, byte[] subkeyH) {\n+    private static byte[] getJ0(byte[] iv, byte[] subkeyH, int blockSize) {\n@@ -171,2 +513,2 @@\n-            j0 = expandToOneBlock(iv, 0, iv.length);\n-            j0[AES_BLOCK_SIZE - 1] = 1;\n+            j0 = expandToOneBlock(iv, 0, iv.length, blockSize);\n+            j0[blockSize - 1] = 1;\n@@ -175,1 +517,1 @@\n-            int lastLen = iv.length % AES_BLOCK_SIZE;\n+            int lastLen = iv.length % blockSize;\n@@ -179,1 +521,2 @@\n-                    expandToOneBlock(iv, iv.length - lastLen, lastLen);\n+                    expandToOneBlock(iv, iv.length - lastLen, lastLen,\n+                        blockSize);\n@@ -184,2 +527,1 @@\n-            byte[] lengthBlock = getLengthBlock(iv.length);\n-            g.update(lengthBlock);\n+            g.update(getLengthBlock(iv.length, new byte[blockSize]));\n@@ -201,1 +543,1 @@\n-        if (processed > max) {\n+        if (engine.processed > max) {\n@@ -207,5 +549,0 @@\n-    GaloisCounterMode(SymmetricCipher embeddedCipher) {\n-        super(embeddedCipher);\n-        aadBuffer = new ByteArrayOutputStream();\n-    }\n-\n@@ -213,3 +550,1 @@\n-     * Gets the name of the feedback mechanism\n-     *\n-     * @return the name of the feedback mechanism\n+     * Abstract class for GCMEncrypt and GCMDecrypt internal context objects\n@@ -217,3 +552,2 @@\n-    String getFeedback() {\n-        return \"GCM\";\n-    }\n+    abstract class GCMEngine {\n+        byte[] preCounterBlock;\n@@ -221,17 +555,25 @@\n-    \/**\n-     * Resets the cipher object to its original state.\n-     * This is used when doFinal is called in the Cipher class, so that the\n-     * cipher can be reused (with its original key and iv).\n-     *\/\n-    void reset() {\n-        if (aadBuffer == null) {\n-            aadBuffer = new ByteArrayOutputStream();\n-        } else {\n-            aadBuffer.reset();\n-        }\n-        if (gctrPAndC != null) gctrPAndC.reset();\n-        if (ghashAllToS != null) ghashAllToS.reset();\n-        processed = 0;\n-        sizeOfAAD = 0;\n-        if (ibuffer != null) {\n-            ibuffer.reset();\n+        GCTR gctrPAndC;\n+        GHASH ghashAllToS;\n+\n+        \/\/ Block size of the algorithm\n+        final int blockSize;\n+\n+        \/\/ length of total data, i.e. len(C)\n+        int processed = 0;\n+\n+        \/\/ buffer for AAD data; if null, meaning update has been called\n+        ByteArrayOutputStream aadBuffer = null;\n+        int sizeOfAAD = 0;\n+        boolean aadProcessed = false;\n+\n+        \/\/ buffer data for crypto operation\n+        ByteArrayOutputStream ibuffer = null;\n+\n+        \/\/ Original dst buffer if there was an overlap situation\n+        ByteBuffer originalDst = null;\n+        byte[] originalOut = null;\n+        int originalOutOfs = 0;\n+\n+\n+        GCMEngine(SymmetricCipher blockCipher) {\n+            blockSize = blockCipher.getBlockSize();\n@@ -239,1 +581,0 @@\n-    }\n@@ -241,13 +582,12 @@\n-    \/**\n-     * Save the current content of this cipher.\n-     *\/\n-    void save() {\n-        processedSave = processed;\n-        sizeOfAADSave = sizeOfAAD;\n-        aadBufferSave =\n-            ((aadBuffer == null || aadBuffer.size() == 0)?\n-             null : aadBuffer.toByteArray());\n-        if (gctrPAndC != null) gctrPAndC.save();\n-        if (ghashAllToS != null) ghashAllToS.save();\n-        if (ibuffer != null) {\n-            ibufferSave = ibuffer.toByteArray();\n+        \/**\n+         * Initialize GHASH and GCTR.  Encryption needs initialization right\n+         * away; however, decryption can wait until doFinal()\n+         *\/\n+        void initEngine() {\n+            byte[] subkeyH = new byte[blockSize];\n+            blockCipher.encryptBlock(subkeyH, 0, subkeyH,0);\n+            preCounterBlock = getJ0(iv, subkeyH, blockSize);\n+            byte[] j0Plus1 = preCounterBlock.clone();\n+            increment32(j0Plus1);\n+            gctrPAndC = new GCTR(blockCipher, j0Plus1);\n+            ghashAllToS = new GHASH(subkeyH);\n@@ -255,1 +595,0 @@\n-    }\n@@ -257,10 +596,31 @@\n-    \/**\n-     * Restores the content of this cipher to the previous saved one.\n-     *\/\n-    void restore() {\n-        processed = processedSave;\n-        sizeOfAAD = sizeOfAADSave;\n-        if (aadBuffer != null) {\n-            aadBuffer.reset();\n-            if (aadBufferSave != null) {\n-                aadBuffer.write(aadBufferSave, 0, aadBufferSave.length);\n+        \/**\n+         * Get output buffer size\n+         * @param inLen Contains the length of the input data and buffered data.\n+         * @param isFinal true if this is a doFinal operation\n+         * @return If it's an update operation, inLen must blockSize\n+         *         divisible.  If it's a final operation, output will\n+         *         include the tag.\n+         *\/\n+        abstract int getOutputSize(int inLen, boolean isFinal);\n+\n+        \/\/ Update operations\n+        abstract byte[] doUpdate(byte[] in, int inOff, int inLen);\n+        abstract int doUpdate(byte[] in, int inOff, int inLen, byte[] out,\n+            int outOff) throws ShortBufferException;\n+        abstract int doUpdate(ByteBuffer src, ByteBuffer dst)\n+            throws ShortBufferException;\n+\n+        \/\/ Final operations\n+        abstract int doFinal(byte[] in, int inOff, int inLen, byte[] out,\n+            int outOff) throws IllegalBlockSizeException, AEADBadTagException,\n+            ShortBufferException;\n+        abstract int doFinal(ByteBuffer src, ByteBuffer dst)\n+            throws IllegalBlockSizeException, AEADBadTagException,\n+            ShortBufferException;\n+\n+        abstract int cryptBlocks(GCM op, ByteBuffer src, ByteBuffer dst);\n+\n+        \/\/ Initialize internal data buffer, if not already.\n+        void initBuffer(int len) {\n+            if (ibuffer == null) {\n+                ibuffer = new ByteArrayOutputStream(len);\n@@ -269,24 +629,0 @@\n-        if (gctrPAndC != null) gctrPAndC.restore();\n-        if (ghashAllToS != null) ghashAllToS.restore();\n-        if (ibuffer != null) {\n-            ibuffer.reset();\n-            ibuffer.write(ibufferSave, 0, ibufferSave.length);\n-        }\n-    }\n-\n-    \/**\n-     * Initializes the cipher in the specified mode with the given key\n-     * and iv.\n-     *\n-     * @param decrypting flag indicating encryption or decryption\n-     * @param algorithm the algorithm name\n-     * @param key the key\n-     * @param iv the iv\n-     * @exception InvalidKeyException if the given key is inappropriate for\n-     * initializing this cipher\n-     *\/\n-    @Override\n-    void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        init(decrypting, algorithm, key, iv, DEFAULT_TAG_LEN);\n-    }\n@@ -294,24 +630,3 @@\n-    \/**\n-     * Initializes the cipher in the specified mode with the given key\n-     * and iv.\n-     *\n-     * @param decrypting flag indicating encryption or decryption\n-     * @param algorithm the algorithm name\n-     * @param keyValue the key\n-     * @param ivValue the iv\n-     * @param tagLenBytes the length of tag in bytes\n-     *\n-     * @exception InvalidKeyException if the given key is inappropriate for\n-     * initializing this cipher\n-     *\/\n-    void init(boolean decrypting, String algorithm, byte[] keyValue,\n-              byte[] ivValue, int tagLenBytes)\n-              throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        if (keyValue == null) {\n-            throw new InvalidKeyException(\"Internal error\");\n-        }\n-        if (ivValue == null) {\n-            throw new InvalidAlgorithmParameterException(\"Internal error\");\n-        }\n-        if (ivValue.length == 0) {\n-            throw new InvalidAlgorithmParameterException(\"IV is empty\");\n+        \/\/ Helper method for getting ibuffer size\n+        int getBufferedLength() {\n+            return (ibuffer == null ? 0 : ibuffer.size());\n@@ -320,18 +635,4 @@\n-        \/\/ always encrypt mode for embedded cipher\n-        this.embeddedCipher.init(false, algorithm, keyValue);\n-        this.subkeyH = new byte[AES_BLOCK_SIZE];\n-        this.embeddedCipher.encryptBlock(new byte[AES_BLOCK_SIZE], 0,\n-                this.subkeyH, 0);\n-\n-        this.iv = ivValue.clone();\n-        preCounterBlock = getJ0(iv, subkeyH);\n-        byte[] j0Plus1 = preCounterBlock.clone();\n-        increment32(j0Plus1);\n-        gctrPAndC = new GCTR(embeddedCipher, j0Plus1);\n-        ghashAllToS = new GHASH(subkeyH);\n-\n-        this.tagLenBytes = tagLenBytes;\n-        if (aadBuffer == null) {\n-            aadBuffer = new ByteArrayOutputStream();\n-        } else {\n-            aadBuffer.reset();\n+        int mergeBlock(byte[] buffer, int bufOfs, byte[] in, int inOfs,\n+            int inLen, byte[] block) {\n+            return mergeBlock(buffer, bufOfs, buffer.length - bufOfs, in,\n+                inOfs, inLen, block);\n@@ -339,4 +640,19 @@\n-        processed = 0;\n-        sizeOfAAD = 0;\n-        if (decrypting) {\n-            ibuffer = new ByteArrayOutputStream();\n+\n+        \/**\n+         * The method takes two buffers to create one block of data\n+         *\n+         * This in only called when buffer length is less that a blockSize\n+         * @return number of bytes used from 'in'\n+         *\/\n+        int mergeBlock(byte[] buffer, int bufOfs, int bufLen, byte[] in,\n+            int inOfs, int inLen, byte[] block) {\n+            if (bufLen > blockSize) {\n+                throw new RuntimeException(\"mergeBlock called on an ibuffer \" +\n+                    \"too big:  \" + bufLen + \" bytes\");\n+            }\n+\n+            System.arraycopy(buffer, bufOfs, block, 0, bufLen);\n+            int inUsed = Math.min(block.length - bufLen,\n+                (Math.min(inLen, block.length)));\n+            System.arraycopy(in, inOfs, block, bufLen, inUsed);\n+            return inUsed;\n@@ -344,1 +660,0 @@\n-    }\n@@ -346,26 +661,31 @@\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD), using a subset of the provided buffer. If this\n-     * cipher is operating in either GCM or CCM mode, all AAD must be\n-     * supplied before beginning operations on the ciphertext (via the\n-     * {@code update} and {@code doFinal} methods).\n-     * <p>\n-     * NOTE: Given most modes do not accept AAD, default impl for this\n-     * method throws IllegalStateException.\n-     *\n-     * @param src the buffer containing the AAD\n-     * @param offset the offset in {@code src} where the AAD input starts\n-     * @param len the number of AAD bytes\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    void updateAAD(byte[] src, int offset, int len) {\n-        if (aadBuffer != null) {\n+        \/**\n+         * Continues a multi-part update of the Additional Authentication\n+         * Data (AAD), using a subset of the provided buffer.  All AAD must be\n+         * supplied before beginning operations on the ciphertext (via the\n+         * {@code update} and {@code doFinal} methods).\n+         *\n+         * @param src the buffer containing the AAD\n+         * @param offset the offset in {@code src} where the AAD input starts\n+         * @param len the number of AAD bytes\n+         *\n+         * @throws IllegalStateException if this cipher is in a wrong state\n+         * (e.g., has not been initialized) or does not accept AAD, and one of\n+         * the {@code update} methods has already been called for the active\n+         * encryption\/decryption operation\n+         * @throws UnsupportedOperationException if this method\n+         * has not been overridden by an implementation\n+         *\/\n+        void updateAAD(byte[] src, int offset, int len) {\n+            if (encryption) {\n+                checkReInit();\n+            }\n+\n+            if (aadBuffer == null) {\n+                if (sizeOfAAD == 0 && !aadProcessed) {\n+                    aadBuffer = new ByteArrayOutputStream(len);\n+                } else {\n+                    \/\/ update has already been called\n+                    throw new IllegalStateException\n+                        (\"Update has been called; no more AAD data\");\n+                }\n+            }\n@@ -373,4 +693,0 @@\n-        } else {\n-            \/\/ update has already been called\n-            throw new IllegalStateException\n-                (\"Update has been called; no more AAD data\");\n@@ -378,1 +694,0 @@\n-    }\n@@ -380,6 +695,21 @@\n-    \/\/ Feed the AAD data to GHASH, pad if necessary\n-    void processAAD() {\n-        if (aadBuffer != null) {\n-            if (aadBuffer.size() > 0) {\n-                byte[] aad = aadBuffer.toByteArray();\n-                sizeOfAAD = aad.length;\n+        \/\/ Feed the AAD data to GHASH, pad if necessary\n+        void processAAD() {\n+            if (aadBuffer != null) {\n+                if (aadBuffer.size() > 0) {\n+                    byte[] aad = aadBuffer.toByteArray();\n+                    sizeOfAAD = aad.length;\n+\n+                    int lastLen = aad.length % blockSize;\n+                    if (lastLen != 0) {\n+                        ghashAllToS.update(aad, 0, aad.length - lastLen);\n+                        byte[] padded = expandToOneBlock(aad,\n+                            aad.length - lastLen, lastLen, blockSize);\n+                        ghashAllToS.update(padded);\n+                    } else {\n+                        ghashAllToS.update(aad);\n+                    }\n+                }\n+                aadBuffer = null;\n+            }\n+            aadProcessed = true;\n+        }\n@@ -387,6 +717,25 @@\n-                int lastLen = aad.length % AES_BLOCK_SIZE;\n-                if (lastLen != 0) {\n-                    ghashAllToS.update(aad, 0, aad.length - lastLen);\n-                    byte[] padded = expandToOneBlock(aad, aad.length - lastLen,\n-                                                     lastLen);\n-                    ghashAllToS.update(padded);\n+        \/**\n+         * Process en\/decryption all the way to the last block.  It takes both\n+         * For input it takes the ibuffer which is wrapped in 'buffer' and 'src'\n+         * from doFinal.\n+         *\/\n+        int doLastBlock(GCM op, ByteBuffer buffer, ByteBuffer src, ByteBuffer dst) {\n+            int len = 0;\n+\n+            if (buffer != null && buffer.remaining() > 0) {\n+                \/\/ If there is no src, just finish the rest of the buffer.\n+                if (src.remaining() == 0) {\n+                    return op.doFinal(buffer, dst);\n+                }\n+                \/\/ en\/decrypt on how much buffer there is in blockSize\n+                if (buffer.remaining() >= blockSize) {\n+                    len += op.update(buffer, dst);\n+                }\n+                \/\/ Process the remainder in the ibuffer with src data\n+                if (src.remaining() + buffer.remaining() >= blockSize) {\n+                    byte[] block = new byte[blockSize];\n+                    \/\/ Copy the remainder of the buffer into the extra block\n+                    int over = buffer.remaining();\n+                    buffer.get(block, 0, over);\n+                    src.get(block, over, blockSize - over);\n+                    len += op.update(ByteBuffer.wrap(block), dst);\n@@ -394,1 +743,7 @@\n-                    ghashAllToS.update(aad);\n+                    byte[] block =\n+                        new byte[src.remaining() + buffer.remaining()];\n+                    int over = buffer.remaining();\n+                    buffer.get(block, 0, over);\n+                    src.get(block, over, src.remaining());\n+                    len += op.doFinal(ByteBuffer.wrap(block), dst);\n+                    return len;\n@@ -397,3 +752,0 @@\n-            aadBuffer = null;\n-        }\n-    }\n@@ -401,6 +753,7 @@\n-    \/\/ Utility to process the last block; used by encryptFinal and decryptFinal\n-    void doLastBlock(byte[] in, int inOfs, int len, byte[] out, int outOfs,\n-                     boolean isEncrypt) throws IllegalBlockSizeException {\n-        byte[] ct;\n-        int ctOfs;\n-        int ilen = len;  \/\/ internal length\n+            \/*\n+             * At this point there are two scenarios.  Either there is\n+             * remaining data in the buffer that does not fill a block,\n+             * or there is only src data remaining of any length.\n+             *\n+             * doFinal must be called so it can reset the object.\n+             *\/\n@@ -408,6 +761,6 @@\n-        if (isEncrypt) {\n-            ct = out;\n-            ctOfs = outOfs;\n-        } else {\n-            ct = in;\n-            ctOfs = inOfs;\n+            if (src.remaining() == 0) {\n+                return len;\n+            }\n+\n+            len += cryptBlocks(op, src, dst);\n+            return len + op.doFinal(src, dst);\n@@ -416,2 +769,15 @@\n-        \/\/ Divide up larger data sizes to trigger CTR & GHASH intrinsic quicker\n-        if (len > TRIGGERLEN) {\n+\n+        \/**\n+         * This segments large data into smaller chunks so hotspot will start\n+         * using CTR and GHASH intrinsics sooner.  This is a problem for app\n+         * and perf tests that only use large input sizes.\n+         *\/\n+        int throttleData(GCM op, byte[] in, int inOfs, int inLen,\n+            byte[] out, int outOfs) {\n+\n+            if (inLen < TRIGGERLEN) {\n+                return 0;\n+            }\n+            int segments = (inLen \/ 6);\n+            segments -= segments % blockSize;\n+            int len, resultLen = 0;\n@@ -419,61 +785,95 @@\n-            int tlen;  \/\/ incremental lengths\n-            final int plen = AES_BLOCK_SIZE * 6;\n-            \/\/ arbitrary formula to aid intrinsic without reaching buffer end\n-            final int count = len \/ 1024;\n-\n-            while (count > i) {\n-                tlen = gctrPAndC.update(in, inOfs, plen, out, outOfs);\n-                ghashAllToS.update(ct, ctOfs, tlen);\n-                inOfs += tlen;\n-                outOfs += tlen;\n-                ctOfs += tlen;\n-                i++;\n-            }\n-            ilen -= count * plen;\n-            processed += count * plen;\n-        }\n-\n-        gctrPAndC.doFinal(in, inOfs, ilen, out, outOfs);\n-        processed += ilen;\n-\n-        int lastLen = ilen % AES_BLOCK_SIZE;\n-        if (lastLen != 0) {\n-            ghashAllToS.update(ct, ctOfs, ilen - lastLen);\n-            ghashAllToS.update(\n-                    expandToOneBlock(ct, (ctOfs + ilen - lastLen), lastLen));\n-        } else {\n-            ghashAllToS.update(ct, ctOfs, ilen);\n-        }\n-    }\n-\n-    \/\/ Process en\/decryption all the way to the last block.  It takes both\n-    \/\/ For input it takes the ibuffer which is wrapped in 'buffer' and 'src'\n-    \/\/ from doFinal.\n-    void doLastBlock(ByteBuffer buffer, ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException {\n-\n-        if (buffer != null && buffer.remaining() > 0) {\n-            \/\/ en\/decrypt on how much buffer there is in AES_BLOCK_SIZE\n-            processed += gctrPAndC.update(buffer, dst);\n-\n-            \/\/ Process the remainder in the buffer\n-            if (buffer.remaining() > 0) {\n-                \/\/ Copy the remainder of the buffer into the extra block\n-                byte[] block = new byte[AES_BLOCK_SIZE];\n-                int over = buffer.remaining();\n-                int len = over;  \/\/ how much is processed by in the extra block\n-                buffer.get(block, 0, over);\n-\n-                \/\/ if src is empty, update the final block and wait for later\n-                \/\/ to finalize operation\n-                if (src.remaining() > 0) {\n-                    \/\/ Fill out block with what is in data\n-                    if (src.remaining() > AES_BLOCK_SIZE - over) {\n-                        src.get(block, over, AES_BLOCK_SIZE - over);\n-                        len += AES_BLOCK_SIZE - over;\n-                    } else {\n-                        \/\/ If the remaining in buffer + data does not fill a\n-                        \/\/ block, complete the ghash operation\n-                        int l = src.remaining();\n-                        src.get(block, over, l);\n-                        len += l;\n+            do {\n+                len = op.update(in, inOfs, segments, out, outOfs);\n+                outOfs += len;\n+                inOfs += len;\n+                inLen -= len;\n+                resultLen += len;\n+            } while (++i < 5);\n+\n+            resultLen += op.update(in, inOfs, inLen, out, outOfs);\n+            return resultLen;\n+        }\n+\n+\n+        \/**\n+         * This segments large data into smaller chunks so hotspot will start\n+         * using CTR and GHASH intrinsics sooner.  This is a problem for app\n+         * and perf tests that only use large input sizes.\n+         *\/\n+        int throttleData(GCM op, ByteBuffer src, ByteBuffer dst) {\n+            int inLen = src.limit();\n+            int segments = (src.remaining() \/ 6);\n+            segments -= segments % blockSize;\n+            int i = 0, resultLen = 0;\n+            do {\n+                src.limit(src.position() + segments);\n+                resultLen += op.update(src, dst);\n+            } while (++i < 5);\n+\n+            src.limit(inLen);\n+            \/\/ If there is still at least a blockSize left\n+            if (src.remaining() > blockSize) {\n+                resultLen += op.update(src, dst);\n+            }\n+\n+            return resultLen;\n+        }\n+\n+        \/**\n+         * Check for overlap. If the src and dst buffers are using shared data\n+         * and if dst will overwrite src data before src can be processed.\n+         * If so, make a copy to put the dst data in.\n+         *\/\n+        ByteBuffer overlapDetection(ByteBuffer src, ByteBuffer dst) {\n+            if (src.isDirect() && dst.isDirect()) {\n+                DirectBuffer dsrc = (DirectBuffer) src;\n+                DirectBuffer ddst = (DirectBuffer) dst;\n+\n+                \/\/ Get the current memory address for the given ByteBuffers\n+                long srcaddr = dsrc.address();\n+                long dstaddr = ddst.address();\n+\n+                \/\/ Find the lowest attachment that is the base memory address\n+                \/\/ of the shared memory for the src object\n+                while (dsrc.attachment() != null) {\n+                    srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n+                    dsrc = (DirectBuffer) dsrc.attachment();\n+                }\n+\n+                \/\/ Find the lowest attachment that is the base memory address\n+                \/\/ of the shared memory for the dst object\n+                while (ddst.attachment() != null) {\n+                    dstaddr = ((DirectBuffer) ddst.attachment()).address();\n+                    ddst = (DirectBuffer) ddst.attachment();\n+                }\n+\n+                \/\/ If the base addresses are not the same, there is no overlap\n+                if (srcaddr != dstaddr) {\n+                    return dst;\n+                }\n+                \/\/ At this point we know these objects share the same memory.\n+                \/\/ This checks the starting position of the src and dst address\n+                \/\/ for overlap.\n+                \/\/ It uses the base address minus the passed object's address to\n+                \/\/ get the offset from the base address, then add the position()\n+                \/\/ from the passed object.  That gives up the true offset from\n+                \/\/ the base address.  As long as the src side is >= the dst\n+                \/\/ side, we are not in overlap.\n+                if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n+                    ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n+                    return dst;\n+                }\n+\n+            } else if (!src.isDirect() && !dst.isDirect()) {\n+                \/\/ if src is read only, then we need a copy\n+                if (!src.isReadOnly()) {\n+                    \/\/ If using the heap, check underlying byte[] address.\n+                    if (!src.array().equals(dst.array()) ) {\n+                        return dst;\n+                    }\n+\n+                    \/\/ Position plus arrayOffset() will give us the true offset\n+                    \/\/ from the underlying byte[] address.\n+                    if (src.position() + src.arrayOffset() >=\n+                        dst.position() + dst.arrayOffset()) {\n+                        return dst;\n@@ -482,2 +882,3 @@\n-                gctrPAndC.update(block, 0, AES_BLOCK_SIZE, dst);\n-                processed += len;\n+            } else {\n+                \/\/ buffer types are not the same and can be used as-is\n+                return dst;\n@@ -485,0 +886,11 @@\n+\n+            \/\/ Create a copy\n+            ByteBuffer tmp = dst.duplicate();\n+            \/\/ We can use a heap buffer for internal use, save on alloc cost\n+            ByteBuffer bb = ByteBuffer.allocate(dst.remaining());\n+            tmp.limit(dst.limit());\n+            tmp.position(dst.position());\n+            bb.put(tmp);\n+            bb.flip();\n+            originalDst = dst;\n+            return bb;\n@@ -487,4 +899,14 @@\n-        \/\/ en\/decrypt whatever remains in src.\n-        \/\/ If src has been consumed, this will be a no-op\n-        processed += gctrPAndC.doFinal(src, dst);\n-    }\n+        \/**\n+         * Overlap detection for data using byte array.\n+         * If an intermediate array is needed, the whole original out array\n+         * length is allocated because it's simpler than keep the same offset\n+         * and hope the expected output is\n+         *\/\n+        byte[] overlapDetection(byte[] in, int inOfs, byte[] out, int outOfs) {\n+            if (in == out && inOfs < outOfs) {\n+                originalOut = out;\n+                originalOutOfs = outOfs;\n+                return new byte[out.length];\n+            }\n+            return out;\n+        }\n@@ -492,10 +914,7 @@\n-     \/*\n-     * This method is for CipherCore to insert the remainder of its buffer\n-     * into the ibuffer before a doFinal(ByteBuffer, ByteBuffer) operation\n-     *\/\n-    int encrypt(byte[] in, int inOfs, int len) {\n-        if (len > 0) {\n-            \/\/ store internally until encryptFinal\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n-            if (ibuffer == null) {\n-                ibuffer = new ByteArrayOutputStream();\n+        \/**\n+         * If originalDst is not null, 'dst' is an internal buffer and it's\n+         * data will be copied to the original dst buffer\n+         *\/\n+        void restoreDst(ByteBuffer dst) {\n+            if (originalDst == null) {\n+                return;\n@@ -503,1 +922,16 @@\n-            ibuffer.write(in, inOfs, len);\n+\n+            dst.flip();\n+            originalDst.put(dst);\n+        }\n+\n+        \/**\n+         * If originalOut is not null, the 'out' is an internal buffer and it's\n+         * data will be copied into original out byte[];\n+         *\/\n+        void restoreOut(byte[] out, int len) {\n+            if (originalOut == null) {\n+                return;\n+            }\n+\n+            System.arraycopy(out, originalOutOfs, originalOut, originalOutOfs,\n+                len);\n@@ -505,1 +939,0 @@\n-        return len;\n@@ -509,12 +942,1 @@\n-     * Performs encryption operation.\n-     *\n-     * <p>The input plain text <code>in<\/code>, starting at <code>inOfs<\/code>\n-     * and ending at <code>(inOfs + len - 1)<\/code>, is encrypted. The result\n-     * is stored in <code>out<\/code>, starting at <code>outOfs<\/code>.\n-     *\n-     * @param in the buffer with the input data to be encrypted\n-     * @param inOfs the offset in <code>in<\/code>\n-     * @param inLen the length of the input data\n-     * @param out the buffer for the result\n-     * @param outOfs the offset in <code>out<\/code>\n-     * @return the number of bytes placed into the <code>out<\/code> buffer\n+     * Encryption Engine object\n@@ -522,50 +944,17 @@\n-    int encrypt(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n-        checkDataLength(inLen, getBufferedLength());\n-        ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n-        ArrayUtil.nullAndBoundsCheck(out, outOfs, inLen);\n-\n-        processAAD();\n-        \/\/ 'inLen' stores the length to use with buffer 'in'.\n-        \/\/ 'len' stores the length returned by the method.\n-        int len = inLen;\n-\n-        \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n-        if (ibuffer != null && ibuffer.size() > 0) {\n-            byte[] buffer = ibuffer.toByteArray();\n-            \/\/ number of bytes not filling a block\n-            int remainder = ibuffer.size() % blockSize;\n-            \/\/ number of bytes along block boundary\n-            int blen = ibuffer.size() - remainder;\n-\n-            \/\/ If there is enough bytes in ibuffer for a block or more,\n-            \/\/ encrypt that first.\n-            if (blen > 0) {\n-                encryptBlocks(buffer, 0, blen, out, outOfs);\n-                outOfs += blen;\n-            }\n-\n-            \/\/ blen is now the offset for 'buffer'\n-\n-            \/\/ Construct and encrypt a block if there is enough 'buffer' and\n-            \/\/ 'in' to make one\n-            if ((inLen + remainder) >= blockSize) {\n-                byte[] block = new byte[blockSize];\n-\n-                System.arraycopy(buffer, blen, block, 0, remainder);\n-                int inLenUsed = blockSize - remainder;\n-                System.arraycopy(in, inOfs, block, remainder, inLenUsed);\n-\n-                encryptBlocks(block, 0, blockSize, out, outOfs);\n-                inOfs += inLenUsed;\n-                inLen -= inLenUsed;\n-                len += (blockSize - inLenUsed);\n-                outOfs += blockSize;\n-                ibuffer.reset();\n-                \/\/ Code below will write the remainder from 'in' to ibuffer\n-            } else if (remainder > 0) {\n-                \/\/ If a block or more was encrypted from 'buffer' only, but the\n-                \/\/ rest of 'buffer' with 'in' could not construct a block, then\n-                \/\/ put the rest of 'buffer' back into ibuffer.\n-                ibuffer.reset();\n-                ibuffer.write(buffer, blen, remainder);\n-                \/\/ Code below will write the remainder from 'in' to ibuffer\n+    class GCMEncrypt extends GCMEngine {\n+        GCTRGHASH gctrghash;\n+\n+        GCMEncrypt(SymmetricCipher blockCipher) {\n+            super(blockCipher);\n+            initEngine();\n+            gctrghash = new GCTRGHASH(gctrPAndC, ghashAllToS);\n+        }\n+\n+        @Override\n+        public int getOutputSize(int inLen, boolean isFinal) {\n+            int len = getBufferedLength();\n+            if (isFinal) {\n+                return len + inLen + tagLenBytes;\n+            } else {\n+                len += inLen;\n+                return len - (len % blockCipher.getBlockSize());\n@@ -573,3 +962,0 @@\n-            \/\/ If blen == 0 and there was not enough to construct a block\n-            \/\/ from 'buffer' and 'in', then let the below code append 'in' to\n-            \/\/ the ibuffer.\n@@ -578,5 +964,8 @@\n-        \/\/ Write any remaining bytes outside the blockSize into ibuffer.\n-        int remainder = inLen % blockSize;\n-        if (remainder > 0) {\n-            if (ibuffer == null) {\n-                ibuffer = new ByteArrayOutputStream(inLen % blockSize);\n+        @Override\n+        byte[] doUpdate(byte[] in, int inOff, int inLen) {\n+            checkReInit();\n+            byte[] output = new byte[getOutputSize(inLen, false)];\n+            try {\n+                doUpdate(in, inOff, inLen, output, 0);\n+            } catch (ShortBufferException e) {\n+                \/\/ update decryption has no output\n@@ -584,4 +973,1 @@\n-            len -= remainder;\n-            inLen -= remainder;\n-            \/\/ remainder offset is based on original buffer length\n-            ibuffer.write(in, inOfs + inLen, remainder);\n+            return output;\n@@ -590,3 +976,15 @@\n-        \/\/ Encrypt the remaining blocks inside of 'in'\n-        if (inLen > 0) {\n-            encryptBlocks(in, inOfs, inLen, out, outOfs);\n+        \/**\n+         * Encrypt update operation.  This uses both the ibuffer and 'in' to\n+         * encrypt as many blocksize data as possible.  Any remaining data is\n+         * put into the ibuffer.\n+         *\/\n+        @Override\n+        public int doUpdate(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws ShortBufferException {\n+            checkReInit();\n+            checkDataLength(inLen, getBufferedLength());\n+            ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n+            ArrayUtil.nullAndBoundsCheck(out, outOfs, out.length - outOfs);\n+            processAAD();\n+\n+            return encryptBlocks(in, inOfs, inLen, out, outOfs);\n@@ -595,2 +993,12 @@\n-        return len;\n-    }\n+        \/**\n+         * Encrypt update operation.  This uses both the ibuffer and 'src' to\n+         * encrypt as many blocksize data as possible.  Any remaining data is\n+         * put into the ibuffer.\n+         *\/\n+        @Override\n+        public int doUpdate(ByteBuffer src, ByteBuffer dst)\n+            throws ShortBufferException {\n+            checkReInit();\n+            return encryptBlocks((ibuffer == null || ibuffer.size() == 0) ?\n+                null : ByteBuffer.wrap(ibuffer.toByteArray()), src, dst);\n+        }\n@@ -598,5 +1006,13 @@\n-    void encryptBlocks(byte[] in, int inOfs, int len, byte[] out, int outOfs) {\n-        gctrPAndC.update(in, inOfs, len, out, outOfs);\n-        processed += len;\n-        ghashAllToS.update(out, outOfs, len);\n-    }\n+        \/**\n+         * Return final encrypted data with auth tag using byte[]\n+         *\/\n+        @Override\n+        public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws IllegalBlockSizeException, ShortBufferException {\n+            checkReInit();\n+            try {\n+                ArrayUtil.nullAndBoundsCheck(out, outOfs, getOutputSize(inLen,\n+                    true));\n+            } catch (ArrayIndexOutOfBoundsException aiobe) {\n+                throw new ShortBufferException(\"Output buffer invalid\");\n+            }\n@@ -604,13 +1020,34 @@\n-    \/**\n-     * Performs encryption operation for the last time.\n-     *\n-     * @param in the input buffer with the data to be encrypted\n-     * @param inOfs the offset in <code>in<\/code>\n-     * @param len the length of the input data\n-     * @param out the buffer for the encryption result\n-     * @param outOfs the offset in <code>out<\/code>\n-     * @return the number of bytes placed into the <code>out<\/code> buffer\n-     *\/\n-    int encryptFinal(byte[] in, int inOfs, int len, byte[] out, int outOfs)\n-        throws IllegalBlockSizeException, ShortBufferException {\n-        checkDataLength(len, getBufferedLength(), tagLenBytes);\n+            int bufLen = getBufferedLength();\n+            checkDataLength(inLen, bufLen, tagLenBytes);\n+            processAAD();\n+            out = overlapDetection(in, inOfs, out, outOfs);\n+\n+            int resultLen = inLen;\n+            byte[] block;\n+\n+            \/\/ process what is in the ibuffer\n+            if (bufLen > 0) {\n+                int r, bufOfs = 0;\n+                byte[] buffer = ibuffer.toByteArray();\n+\n+                \/\/ Add ibuffer to resulting length\n+                resultLen += bufLen;\n+\n+                \/\/ If more than one block is in ibuffer, call doUpdate()\n+                if (bufLen >= blockSize) {\n+                    r = doUpdate(buffer, 0, bufLen, out, outOfs);\n+                    bufLen -= r;\n+                    inOfs += r;\n+                    outOfs += r;\n+                    bufOfs += r;\n+                }\n+                \/\/ Make a block if the remaining ibuffer and 'in' can make one.\n+                if (bufLen > 0 && inLen > 0 && bufLen + inLen >= blockSize) {\n+                    block = new byte[blockSize];\n+                    r = mergeBlock(buffer, bufOfs, in, inOfs, inLen, block);\n+                    inOfs += r;\n+                    inLen -= r;\n+                    r = cryptBlocks(block, 0, blockSize, out, outOfs);\n+                    outOfs += r;\n+                    bufLen = 0;\n+                }\n@@ -618,5 +1055,35 @@\n-        try {\n-            ArrayUtil.nullAndBoundsCheck(out, outOfs,\n-                (len + tagLenBytes));\n-        } catch (ArrayIndexOutOfBoundsException aiobe) {\n-            throw new ShortBufferException(\"Output buffer too small\");\n+                \/\/ Need to consume all the ibuffer here to prepare for doFinal()\n+                if (bufLen > 0) {\n+                    block = new byte[bufLen + inLen];\n+                    System.arraycopy(buffer, 0, block, 0, bufLen);\n+                    System.arraycopy(in, inOfs, block, bufLen, inLen);\n+                    inLen += bufLen;\n+                    in = block;\n+                    inOfs = 0;\n+                }\n+            }\n+\n+            \/\/ process what is left in the input buffer\n+            if (inLen > 0) {\n+                if (inLen > blockSize) {\n+                    int r = cryptBlocks(in, inOfs, inLen, out, outOfs);\n+                    inOfs += r;\n+                    inLen -= r;\n+                    outOfs += r;\n+                }\n+                doLastBlock(in, inOfs, inLen, out, outOfs);\n+            }\n+\n+            block = new byte[blockSize];\n+            getLengthBlock(sizeOfAAD, processed, block);\n+            ghashAllToS.update(block);\n+            block = ghashAllToS.digest();\n+            new GCTR(blockCipher, preCounterBlock).doFinal(block, 0,\n+                tagLenBytes, block, 0);\n+\n+            \/\/ copy the tag to the end of the buffer\n+            System.arraycopy(block, 0, out, (outOfs + inLen), tagLenBytes);\n+            restoreOut(out, resultLen + tagLenBytes);\n+\n+            reInit = true;\n+            return (resultLen + tagLenBytes);\n@@ -625,3 +1092,28 @@\n-        processAAD();\n-        if (len > 0) {\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n+        \/**\n+         * Return final encrypted data with auth tag using bytebuffers\n+         *\/\n+        @Override\n+        public int doFinal(ByteBuffer src, ByteBuffer dst) throws\n+            IllegalBlockSizeException, ShortBufferException {\n+            checkReInit();\n+            dst = overlapDetection(src, dst);\n+            int len = src.remaining() + getBufferedLength();\n+\n+            \/\/ 'len' includes ibuffer data\n+            checkDataLength(len, tagLenBytes);\n+            if (dst.remaining() < len + tagLenBytes) {\n+                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                    \"be at least \" + (len + tagLenBytes) + \" bytes long\");\n+            }\n+\n+            processAAD();\n+            if (len > 0) {\n+                processed += doLastBlock(gctrghash,\n+                    (ibuffer == null || ibuffer.size() == 0) ? null :\n+                        ByteBuffer.wrap(ibuffer.toByteArray()), src, dst);\n+            }\n+\n+            \/\/ release buffer if needed\n+            if (ibuffer != null) {\n+                ibuffer.reset();\n+            }\n@@ -629,1 +1121,11 @@\n-            doLastBlock(in, inOfs, len, out, outOfs, true);\n+            byte[] block = new byte[blockSize];\n+            getLengthBlock(sizeOfAAD, processed, block);\n+            ghashAllToS.update(block);\n+            block = ghashAllToS.digest();\n+            new GCTR(blockCipher, preCounterBlock).doFinal(block, 0,\n+                tagLenBytes, block, 0);\n+            dst.put(block, 0, tagLenBytes);\n+            restoreDst(dst);\n+\n+            reInit = true;\n+            return (len + tagLenBytes);\n@@ -632,5 +1134,0 @@\n-        byte[] block = getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(block);\n-        block = ghashAllToS.digest();\n-        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n-        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n@@ -638,3 +1135,3 @@\n-        System.arraycopy(block, 0, out, (outOfs + len), tagLenBytes);\n-        return (len + tagLenBytes);\n-    }\n+        void doLastBlock(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+            gctrPAndC.doFinal(in, inOfs, inLen, out, outOfs);\n+            processed += inLen;\n@@ -642,5 +1139,9 @@\n-    int encryptFinal(ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException, ShortBufferException {\n-        dst = overlapDetection(src, dst);\n-        int len = src.remaining();\n-        len += getBufferedLength();\n+            int lastLen = inLen % blockSize;\n+            if (lastLen != 0) {\n+                ghashAllToS.update(out, outOfs, inLen - lastLen);\n+                ghashAllToS.update(expandToOneBlock(out,\n+                    (outOfs + inLen - lastLen), lastLen, blockSize));\n+            } else {\n+                ghashAllToS.update(out, outOfs, inLen);\n+            }\n+        }\n@@ -648,5 +1149,72 @@\n-        \/\/ 'len' includes ibuffer data\n-        checkDataLength(len, tagLenBytes);\n-        dst.mark();\n-        if (dst.remaining() < len + tagLenBytes) {\n-            throw new ShortBufferException(\"Output buffer too small\");\n+        \/**\n+         * Take any less than blocksize data from ibuffer and combine it with\n+         * 'in' to encrypt or decrypt a block, then encrypted what it can\n+         * from the remaining blocksize bytes in 'in'.  Any bytes under a\n+         * blocksize are put into the 'ibuffer'.\n+         *\/\n+        int encryptBlocks(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) {\n+            \/\/ 'inLen' stores the length to use with buffer 'in'.\n+            \/\/ 'len' stores the length returned by the method.\n+            int len = 0;\n+            int bLen = getBufferedLength();\n+\n+            processAAD();\n+\n+            \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n+            if (bLen > 0) {\n+                byte[] buffer = ibuffer.toByteArray();\n+                \/\/ number of bytes not filling a block\n+                int remainder = bLen % blockSize;\n+                \/\/ number of bytes along block boundary\n+                bLen -= remainder;\n+\n+                \/\/ If there is enough bytes in ibuffer for a block or more,\n+                \/\/ encrypt that first.\n+                if (bLen > 0) {\n+                    len += cryptBlocks(buffer, 0, bLen, out, outOfs);\n+                    outOfs += bLen;\n+                }\n+\n+                \/\/ blen is now the offset for 'buffer'\n+\n+                \/\/ Construct and encrypt a block if there is enough 'buffer' and\n+                \/\/ 'in' to make one\n+                if ((inLen + remainder) >= blockSize) {\n+                    byte[] block = new byte[blockSize];\n+\n+                    System.arraycopy(buffer, bLen, block, 0, remainder);\n+                    int inLenUsed = blockSize - remainder;\n+                    System.arraycopy(in, inOfs, block, remainder, inLenUsed);\n+\n+                    len += cryptBlocks(block, 0, blockSize, out, outOfs);\n+                    inOfs += inLenUsed;\n+                    inLen -= inLenUsed;\n+                    outOfs += blockSize;\n+                    ibuffer.reset();\n+                    \/\/ Code below will write the remainder from 'in' to ibuffer\n+                } else if (remainder > 0) {\n+                    \/\/ If a block or more was encrypted from 'buffer' only, but\n+                    \/\/ the rest of 'buffer' with 'in' could not construct a\n+                    \/\/  block, then put the rest of 'buffer' back into ibuffer.\n+                    ibuffer.reset();\n+                    ibuffer.write(buffer, bLen, remainder);\n+                    \/\/ Code below will write the remainder from 'in' to ibuffer\n+                }\n+            }\n+\n+            \/\/ Encrypt the remaining blocks inside of 'in'\n+            if (inLen > 0) {\n+                len += cryptBlocks(in, inOfs, inLen, out, outOfs);\n+            }\n+\n+            \/\/ Write any remaining bytes less than a blockSize into ibuffer.\n+            int remainder = inLen % blockSize;\n+            if (remainder > 0) {\n+                initBuffer(remainder);\n+                inLen -= remainder;\n+                \/\/ remainder offset is based on original buffer length\n+                ibuffer.write(in, inOfs + inLen, remainder);\n+            }\n+\n+            return len;\n@@ -655,6 +1223,76 @@\n-        processAAD();\n-        if (len > 0) {\n-            doLastBlock((ibuffer == null || ibuffer.size() == 0) ?\n-                    null : ByteBuffer.wrap(ibuffer.toByteArray()), src, dst);\n-            dst.reset();\n-            ghashAllToS.doLastBlock(dst, len);\n+        \/**\n+         * Take any less than blocksize data from ibuffer and combine it with\n+         * 'src' to encrypt or decrypt a block, then encrypted what it can\n+         * from the remaining blocksize bytes in 'src'.  Any bytes under a\n+         * blocksize are put into the 'ibuffer'.\n+         *\n+         * Because this does encrypt and decrypt, ibuffer could be > blockSize\n+         *\/\n+        int encryptBlocks(ByteBuffer buffer, ByteBuffer src, ByteBuffer dst) {\n+            processAAD();\n+            \/\/ 'inLen' stores the length to use with buffer 'in'.\n+            \/\/ 'len' stores the length returned by the method.\n+            int len = 0;\n+\n+            \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n+            if (buffer != null && buffer.remaining() > 0) {\n+                \/\/ number of bytes not filling a block\n+                int remainder = buffer.remaining() % blockSize;\n+                \/\/ number of bytes along block boundary\n+                int blen = ibuffer.size() - remainder;\n+\n+                \/\/ If there is enough bytes in ibuffer for a block or more,\n+                \/\/ en\/decrypt that first.\n+                if (blen > 0) {\n+                    len += cryptBlocks(buffer, dst);\n+                }\n+\n+                \/\/ Check if there is any data left in the buffer, if there is,\n+                \/\/ try to construct a block with data from the buffer and src\n+                \/\/ to en\/decrypt.\n+                if (buffer.remaining() == 0) {\n+                    ibuffer.reset();\n+                } else {\n+                    if ((buffer.remaining() + src.remaining()) >= blockSize) {\n+                        byte[] block = new byte[blockSize];\n+                        buffer.get(block, 0, remainder);\n+                        src.get(block, remainder, blockSize - remainder);\n+                        len += cryptBlocks(\n+                            ByteBuffer.wrap(block, 0, blockSize), dst);\n+                        ibuffer.reset();\n+                    }\n+                }\n+            }\n+\n+            \/\/ encrypt any blocksized data in 'src'\n+            if (src.remaining() >= blockSize) {\n+                len += cryptBlocks(src, dst);\n+            }\n+\n+            \/\/ Write the remaining bytes into the 'ibuffer'\n+            if (src.remaining() > 0) {\n+                initBuffer(src.remaining());\n+                byte[] b = new byte[src.remaining()];\n+                src.get(b);\n+                \/\/ remainder offset is based on original buffer length\n+                try {\n+                    ibuffer.write(b);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            return len;\n+        }\n+\n+        \/\/ Handler method for encrypting blocks\n+        int cryptBlocks(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) {\n+            int len;\n+            if (inLen > TRIGGERLEN) {\n+                len = throttleData(gctrghash, in, inOfs, inLen, out, outOfs);\n+            } else {\n+                len = gctrghash.update(in, inOfs, inLen, out, outOfs);\n+            }\n+            processed += len;\n+            return len;\n@@ -663,7 +1301,4 @@\n-        byte[] block = getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(block);\n-        block = ghashAllToS.digest();\n-        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n-        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n-        dst.put(block, 0, tagLenBytes);\n-        restoreDst(dst);\n+        \/\/ Handler method for encrypting blocks\n+        int cryptBlocks(ByteBuffer src, ByteBuffer dst) {\n+            return cryptBlocks(gctrghash, src, dst);\n+        }\n@@ -671,1 +1306,11 @@\n-        return (len + tagLenBytes);\n+        \/\/ Handler method for encrypting blocks\n+        int cryptBlocks(GCM ops, ByteBuffer src, ByteBuffer dst) {\n+            int len;\n+            if (src.remaining() > TRIGGERLEN) {\n+                len = throttleData(gctrghash, src, dst);\n+            } else {\n+                len = gctrghash.update(src, dst);\n+            }\n+            processed += len;\n+            return len;\n+        }\n@@ -675,15 +1320,1 @@\n-     * Performs decryption operation.\n-     *\n-     * <p>The input cipher text <code>in<\/code>, starting at\n-     * <code>inOfs<\/code> and ending at <code>(inOfs + len - 1)<\/code>,\n-     * is decrypted. The result is stored in <code>out<\/code>, starting at\n-     * <code>outOfs<\/code>.\n-     *\n-     * @param in the buffer with the input data to be decrypted\n-     * @param inOfs the offset in <code>in<\/code>\n-     * @param len the length of the input data\n-     * @param out the buffer for the result\n-     * @param outOfs the offset in <code>out<\/code>\n-     * @exception ProviderException if <code>len<\/code> is not\n-     * a multiple of the block size\n-     * @return the number of bytes placed into the <code>out<\/code> buffer\n+     * Decryption Engine object\n@@ -691,2 +1322,9 @@\n-    int decrypt(byte[] in, int inOfs, int len, byte[] out, int outOfs) {\n-        processAAD();\n+    class GCMDecrypt extends GCMEngine {\n+        \/\/ byte array of tag\n+        byte[] tag;\n+        \/\/ offset for byte[] operations\n+        int tagOfs = 0;\n+\n+        GCMDecrypt(SymmetricCipher blockCipher) {\n+            super(blockCipher);\n+        }\n@@ -694,6 +1332,6 @@\n-        if (len > 0) {\n-            \/\/ store internally until decryptFinal is called because\n-            \/\/ spec mentioned that only return recovered data after tag\n-            \/\/ is successfully verified\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n-            ibuffer.write(in, inOfs, len);\n+        @Override\n+        public int getOutputSize(int inLen, boolean isFinal) {\n+            if (!isFinal) {\n+                return 0;\n+            }\n+            return Math.max(inLen + getBufferedLength() - tagLenBytes, 0);\n@@ -701,2 +1339,0 @@\n-        return 0;\n-    }\n@@ -704,4 +1340,3 @@\n-    int decrypt(ByteBuffer src, ByteBuffer dst) {\n-        if (src.remaining() > 0) {\n-            byte[] b = new byte[src.remaining()];\n-            src.get(b);\n+        \/\/ Put the input data into the ibuffer\n+        @Override\n+        byte[] doUpdate(byte[] in, int inOff, int inLen) {\n@@ -709,3 +1344,3 @@\n-                ibuffer.write(b);\n-            } catch (IOException e) {\n-                throw new ProviderException(\"Unable to add remaining input to the buffer\", e);\n+                doUpdate(in, inOff, inLen, null, 0);\n+            } catch (ShortBufferException e) {\n+                \/\/ update decryption has no output\n@@ -713,0 +1348,1 @@\n+            return new byte[0];\n@@ -714,2 +1350,0 @@\n-        return 0;\n-    }\n@@ -717,22 +1351,14 @@\n-    \/**\n-     * Performs decryption operation for the last time.\n-     *\n-     * <p>NOTE: For cipher feedback modes which does not perform\n-     * special handling for the last few blocks, this is essentially\n-     * the same as <code>encrypt(...)<\/code>. Given most modes do\n-     * not do special handling, the default impl for this method is\n-     * to simply call <code>decrypt(...)<\/code>.\n-     *\n-     * @param in the input buffer with the data to be decrypted\n-     * @param inOfs the offset in <code>cipher<\/code>\n-     * @param len the length of the input data\n-     * @param out the buffer for the decryption result\n-     * @param outOfs the offset in <code>plain<\/code>\n-     * @return the number of bytes placed into the <code>out<\/code> buffer\n-     *\/\n-    int decryptFinal(byte[] in, int inOfs, int len,\n-                     byte[] out, int outOfs)\n-        throws IllegalBlockSizeException, AEADBadTagException,\n-        ShortBufferException {\n-        if (len < tagLenBytes) {\n-            throw new AEADBadTagException(\"Input too short - need tag\");\n+        \/\/ Put the input data into the ibuffer\n+        @Override\n+        public int doUpdate(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws ShortBufferException {\n+\n+            if (inLen > 0) {\n+                \/\/ store internally until decryptFinal is called because\n+                \/\/ spec mentioned that only return recovered data after tag\n+                \/\/ is successfully verified\n+                ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n+                initBuffer(inLen);\n+                ibuffer.write(in, inOfs, inLen);\n+            }\n+            return 0;\n@@ -741,3 +1367,0 @@\n-        \/\/ do this check here can also catch the potential integer overflow\n-        \/\/ scenario for the subsequent output buffer capacity check.\n-        checkDataLength(getBufferedLength(), (len - tagLenBytes));\n@@ -745,5 +1368,25 @@\n-        try {\n-            ArrayUtil.nullAndBoundsCheck(out, outOfs,\n-                (getBufferedLength() + len) - tagLenBytes);\n-        } catch (ArrayIndexOutOfBoundsException aiobe) {\n-            throw new ShortBufferException(\"Output buffer too small\");\n+        \/\/ Put the src data into the ibuffer\n+        @Override\n+        public int doUpdate(ByteBuffer src, ByteBuffer dst)\n+            throws ShortBufferException {\n+\n+            if (src.remaining() > 0) {\n+                \/\/ If there is an array, use that to avoid the extra copy to\n+                \/\/ take the src data out of the bytebuffer.\n+                if (src.hasArray()) {\n+                    doUpdate(src.array(), src.arrayOffset() + src.position(),\n+                        src.remaining(), null, 0);\n+                    src.position(src.limit());\n+                } else {\n+                    byte[] b = new byte[src.remaining()];\n+                    src.get(b);\n+                    initBuffer(b.length);\n+                    try {\n+                        ibuffer.write(b);\n+                    } catch (IOException e) {\n+                        throw new ProviderException(\n+                            \"Unable to add remaining input to the buffer\", e);\n+                    }\n+                }\n+            }\n+            return 0;\n@@ -752,1 +1395,18 @@\n-        processAAD();\n+        \/**\n+         * Use any data from ibuffer and 'in' to first verify the auth tag. If\n+         * the tag is valid, decrypt the data.\n+         *\/\n+        @Override\n+        public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws IllegalBlockSizeException, AEADBadTagException,\n+            ShortBufferException {\n+            GHASH save = null;\n+\n+            \/\/ Initialize GHASH & GCTR\n+            initEngine();\n+\n+            int bufLen = getBufferedLength();\n+            int len = inLen + bufLen;\n+            if (len < tagLenBytes) {\n+                throw new AEADBadTagException(\"Input too short - need tag\");\n+            }\n@@ -754,1 +1414,3 @@\n-        ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n+            if (len - tagLenBytes > out.length - outOfs) {\n+                save = ghashAllToS.clone();\n+            }\n@@ -756,4 +1418,17 @@\n-        \/\/ get the trailing tag bytes from 'in'\n-        byte[] tag = new byte[tagLenBytes];\n-        System.arraycopy(in, inOfs + len - tagLenBytes, tag, 0, tagLenBytes);\n-        len -= tagLenBytes;\n+            checkDataLength(len - tagLenBytes);\n+            processAAD();\n+\n+            findTag(in, inOfs, inLen);\n+            byte[] block = new byte[blockSize];\n+            getLengthBlock(sizeOfAAD,\n+                decryptBlocks(ghashAllToS, in, inOfs, inLen, null, 0), block);\n+            ghashAllToS.update(block);\n+            block = ghashAllToS.digest();\n+            new GCTR(blockCipher, preCounterBlock).doFinal(block, 0,\n+                tagLenBytes, block, 0);\n+\n+            \/\/ check entire authentication tag for time-consistency\n+            int mismatch = 0;\n+            for (int i = 0; i < tagLenBytes; i++) {\n+                mismatch |= tag[i] ^ block[i];\n+            }\n@@ -761,5 +1436,2 @@\n-        \/\/ If decryption is in-place or there is buffered \"ibuffer\" data, copy\n-        \/\/ the \"in\" byte array into the ibuffer before proceeding.\n-        if (in == out || getBufferedLength() > 0) {\n-            if (len > 0) {\n-                ibuffer.write(in, inOfs, len);\n+            if (mismatch != 0) {\n+                throw new AEADBadTagException(\"Tag mismatch!\");\n@@ -768,6 +1440,10 @@\n-            \/\/ refresh 'in' to all buffered-up bytes\n-            in = ibuffer.toByteArray();\n-            inOfs = 0;\n-            len = in.length;\n-            ibuffer.reset();\n-        }\n+            try {\n+                ArrayUtil.nullAndBoundsCheck(out, outOfs, len - tagLenBytes);\n+            } catch (ArrayIndexOutOfBoundsException aiobe) {\n+                throw new ShortBufferException(\"Output buffer invalid\");\n+            }\n+\n+            if (save != null) {\n+                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                    \"be at least \" + (len - tagLenBytes) + \" bytes long\");\n+            }\n@@ -775,2 +1451,4 @@\n-        if (len > 0) {\n-            doLastBlock(in, inOfs, len, out, outOfs, false);\n+            out = overlapDetection(in, inOfs, out, outOfs);\n+            len = decryptBlocks(gctrPAndC, in, inOfs, inLen, out, outOfs);\n+            restoreOut(out, len);\n+            return len;\n@@ -779,5 +1457,23 @@\n-        byte[] block = getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(block);\n-        block = ghashAllToS.digest();\n-        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n-        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n+        \/**\n+         * Use any data from ibuffer and 'src' to first verify the auth tag. If\n+         * the tag is valid, decrypt the data.\n+         *\/\n+        @Override\n+        public int doFinal(ByteBuffer src, ByteBuffer dst)\n+            throws IllegalBlockSizeException, AEADBadTagException,\n+            ShortBufferException {\n+            GHASH save = null;\n+\n+            \/\/ Initialize GHASH & GCTR\n+            initEngine();\n+\n+            \/\/ If these are array backed ByteBuffers, use the underlying array\n+            if (src.hasArray() && dst.hasArray()) {\n+                int len = doFinal(src.array(),\n+                    src.arrayOffset() + src.position(),\n+                    src.remaining(), dst.array(),\n+                    dst.arrayOffset() + dst.position());\n+                src.position(src.limit());\n+                dst.position(dst.position() + len);\n+                return len;\n+            }\n@@ -785,5 +1481,2 @@\n-        \/\/ check entire authentication tag for time-consistency\n-        int mismatch = 0;\n-        for (int i = 0; i < tagLenBytes; i++) {\n-            mismatch |= tag[i] ^ block[i];\n-        }\n+            \/\/ Check for overlap in the bytebuffers\n+            dst = overlapDetection(src, dst);\n@@ -791,3 +1484,3 @@\n-        if (mismatch != 0) {\n-            throw new AEADBadTagException(\"Tag mismatch!\");\n-        }\n+            \/\/ Length of the input\n+            ByteBuffer tag;\n+            ByteBuffer ct = src.duplicate();\n@@ -795,2 +1488,3 @@\n-        return len;\n-    }\n+            ByteBuffer buffer = ((ibuffer == null || ibuffer.size() == 0) ?\n+                null : ByteBuffer.wrap(ibuffer.toByteArray()));\n+            int len;\n@@ -798,5 +1492,26 @@\n-    \/\/ Note: In-place operations do not need an intermediary copy because\n-    \/\/ the GHASH check was performed before the decryption.\n-    int decryptFinal(ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException, AEADBadTagException,\n-        ShortBufferException {\n+            if (ct.remaining() >= tagLenBytes) {\n+                tag = src.duplicate();\n+                tag.position(ct.limit() - tagLenBytes);\n+                ct.limit(ct.limit() - tagLenBytes);\n+                len = ct.remaining();\n+                if (buffer != null) {\n+                    len += buffer.remaining();\n+                }\n+            } else if (buffer != null) {\n+                \/\/ It's unlikely the tag will be between the buffer and data\n+                tag = ByteBuffer.allocate(tagLenBytes);\n+                int limit = buffer.remaining() - (tagLenBytes - ct.remaining());\n+                buffer.mark();\n+                buffer.position(limit);\n+                \/\/ Read from \"new\" limit to buffer's end\n+                tag.put(buffer);\n+                \/\/ reset buffer to data only\n+                buffer.reset();\n+                buffer.limit(limit);\n+                tag.put(ct);\n+                tag.flip();\n+                \/\/ Limit is how much of the ibuffer has been chopped off.\n+                len = buffer.remaining();\n+            } else {\n+                throw new AEADBadTagException(\"Input too short - need tag\");\n+            }\n@@ -804,4 +1519,2 @@\n-        dst = overlapDetection(src, dst);\n-        \/\/ Length of the input\n-        ByteBuffer tag;\n-        ByteBuffer ct = src.duplicate();\n+            \/\/ 'len' contains the length in ibuffer and src\n+            checkDataLength(len);\n@@ -809,3 +1522,27 @@\n-        ByteBuffer buffer = ((ibuffer == null || ibuffer.size() == 0) ? null :\n-            ByteBuffer.wrap(ibuffer.toByteArray()));\n-        int len;\n+            \/\/ Save GHASH context to allow the tag to be checked even though\n+            \/\/ the dst buffer is too short.  Context will be restored so the\n+            \/\/ method can be called again with the proper sized dst buffer.\n+            if (len > dst.remaining()) {\n+                save = ghashAllToS.clone();\n+            }\n+\n+            processAAD();\n+            \/\/ Set the mark for a later reset. Either it will be zero, or the\n+            \/\/ tag buffer creation above will have consume some or all of it.\n+            ct.mark();\n+\n+            \/\/ Perform GHASH check on data\n+            doLastBlock(ghashAllToS, buffer, ct, dst);\n+\n+            byte[] block = new byte[blockSize];\n+            getLengthBlock(sizeOfAAD, len, block);\n+            ghashAllToS.update(block);\n+            block = ghashAllToS.digest();\n+            new GCTR(blockCipher, preCounterBlock).doFinal(block, 0,\n+                tagLenBytes, block, 0);\n+\n+            \/\/ check entire authentication tag for time-consistency\n+            int mismatch = 0;\n+            for (int i = 0; i < tagLenBytes; i++) {\n+                mismatch |= tag.get() ^ block[i];\n+            }\n@@ -813,5 +1550,11 @@\n-        if (ct.remaining() >= tagLenBytes) {\n-            tag = src.duplicate();\n-            tag.position(ct.limit() - tagLenBytes);\n-            ct.limit(ct.limit() - tagLenBytes);\n-            len = ct.remaining();\n+            if (mismatch != 0) {\n+                throw new AEADBadTagException(\"Tag mismatch!\");\n+            }\n+\n+            if (save != null) {\n+                ghashAllToS = save;\n+                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                    \" be at least \" + len + \" bytes long\");\n+            }\n+\n+            \/\/ Prepare for decryption\n@@ -819,20 +1562,3 @@\n-                len += buffer.remaining();\n-            }\n-        } else if (buffer != null && ct.remaining() < tagLenBytes) {\n-            \/\/ It's unlikely the tag will be between the buffer and data\n-            tag = ByteBuffer.allocate(tagLenBytes);\n-            int limit = buffer.remaining() - (tagLenBytes - ct.remaining());\n-            buffer.mark();\n-            buffer.position(limit);\n-            \/\/ Read from \"new\" limit to buffer's end\n-            tag.put(buffer);\n-            \/\/ reset buffer to data only\n-            buffer.reset();\n-            buffer.limit(limit);\n-            tag.put(ct);\n-            tag.flip();\n-            \/\/ Limit is how much of the ibuffer has been chopped off.\n-            len = buffer.remaining();\n-        } else {\n-            throw new AEADBadTagException(\"Input too short - need tag\");\n-        }\n+                buffer.flip();\n+            }\n+            ct.reset();\n@@ -840,2 +1566,10 @@\n-        \/\/ 'len' contains the length in ibuffer and src\n-        checkDataLength(len);\n+            \/\/ Decrypt the all the input data and put it into dst\n+            processed = doLastBlock(gctrPAndC, buffer, ct, dst);\n+            restoreDst(dst);\n+            src.position(src.limit());\n+            if (ibuffer != null) {\n+                ibuffer.reset();\n+            }\n+            engine = null;\n+            return processed;\n+        }\n@@ -843,2 +1577,22 @@\n-        if (len > dst.remaining()) {\n-            throw new ShortBufferException(\"Output buffer too small\");\n+        \/**\n+         * Find the tag in a given input buffer\n+         *\n+         * If tagOfs > 0, the tag is inside 'in' along with encrypted data\n+         * If tagOfs = 0, 'in' contains only the tag\n+         * if tagOfs = blockSize, there is no data in 'in' and all the tag\n+         *   is in ibuffer\n+         * If tagOfs < 0, that tag is split between ibuffer and 'in'\n+         *\/\n+        void findTag(byte[] in, int inOfs, int inLen) {\n+            tag = new byte[tagLenBytes];\n+            if (inLen >= tagLenBytes) {\n+                tagOfs = inLen - tagLenBytes;\n+                System.arraycopy(in, inOfs + tagOfs, tag, 0,\n+                    tagLenBytes);\n+            } else {\n+                \/\/ tagOfs will be negative\n+                byte[] buffer = ibuffer.toByteArray();\n+                tagOfs = mergeBlock(buffer,\n+                    buffer.length - (tagLenBytes - inLen), in, inOfs, inLen,\n+                    tag) - tagLenBytes;\n+            }\n@@ -847,4 +1601,24 @@\n-        processAAD();\n-        \/\/ Set the mark for a later reset. Either it will be zero, or the tag\n-        \/\/ buffer creation above will have consume some or all of it.\n-        ct.mark();\n+        \/**\n+         * This method organizes the data from the ibuffer and 'in' to\n+         * blocksize operations for GHASH and GCTR decryption operations.\n+         * When this method is used, all the data is either in the ibuffer\n+         * or in 'in'.\n+         *\/\n+        int decryptBlocks(GCM op, byte[] in, int inOfs, int inLen,\n+            byte[] out, int outOfs) {\n+            byte[] buffer = null;\n+            byte[] block = null;\n+            int resultLen = 0;\n+            int bLen = getBufferedLength();\n+            int len = 0;\n+\n+            \/\/ Calculate the encrypted data length inside the ibuffer\n+            \/\/ considering the tag location\n+            int ctBufLen = bLen;\n+            \/\/ Change the inLen based of the tag location.\n+            if (tagOfs < 0) {\n+                inLen = 0;\n+                ctBufLen += tagOfs;\n+            } else {\n+                inLen -= tagLenBytes;\n+            }\n@@ -852,11 +1626,9 @@\n-        \/\/ If there is data stored in the buffer\n-        if (buffer != null && buffer.remaining() > 0) {\n-            ghashAllToS.update(buffer, buffer.remaining());\n-            \/\/ Process the overage\n-            if (buffer.remaining() > 0) {\n-                \/\/ Fill out block between two buffers\n-                if (ct.remaining() > 0) {\n-                    int over = buffer.remaining();\n-                    byte[] block = new byte[AES_BLOCK_SIZE];\n-                    \/\/ Copy the remainder of the buffer into the extra block\n-                    buffer.get(block, 0, over);\n+            \/\/ If there is no buffered data, only process the 'in'\n+            if (ctBufLen == 0) {\n+                int l = throttleData(op, in, inOfs, inLen, out, outOfs);\n+                if (l > 0) {\n+                    inOfs += l;\n+                    inLen -= l;\n+                    outOfs += l; \/\/ noop for ghash\n+                    len += l;\n+                }\n@@ -864,11 +1636,32 @@\n-                    \/\/ Fill out block with what is in data\n-                    if (ct.remaining() > AES_BLOCK_SIZE - over) {\n-                        ct.get(block, over, AES_BLOCK_SIZE - over);\n-                        ghashAllToS.update(block, 0, AES_BLOCK_SIZE);\n-                    } else {\n-                        \/\/ If the remaining in buffer + data does not fill a\n-                        \/\/ block, complete the ghash operation\n-                        int l = ct.remaining();\n-                        ct.get(block, over, l);\n-                        ghashAllToS.doLastBlock(ByteBuffer.wrap(block), over + l);\n-                    }\n+                return len + op.doFinal(in, inOfs, inLen, out, outOfs);\n+            }\n+\n+            if (bLen > 0) {\n+                buffer = ibuffer.toByteArray();\n+            }\n+\n+            \/\/ If ibuffer has at least a block size worth of data, decrypt it\n+            if (ctBufLen >= blockSize) {\n+                resultLen = op.update(buffer, 0, ctBufLen, out, outOfs);\n+                outOfs += resultLen; \/\/ noop for ghash\n+                len += resultLen;\n+                \/\/ Preserve resultLen, as it becomes the ibuffer offset, if\n+                \/\/ needed, in the next op\n+            }\n+\n+            \/\/ merge the remaining ibuffer with the 'in'\n+            int bufRemainder = ctBufLen - resultLen;\n+\n+            if (bufRemainder > 0) {\n+                block = new byte[blockSize];\n+                int inUsed = mergeBlock(buffer, resultLen, bufRemainder, in,\n+                    inOfs, inLen, block);\n+                \/\/ update the input parameters for what was taken out of 'in'\n+                inOfs += inUsed;\n+                inLen -= inUsed;\n+                if ((bufRemainder + inUsed <= blockSize) && inLen == 0) {\n+                    \/\/ If there is no more data in the inLen, send this to\n+                    \/\/ doFinal below\n+                    in = block;\n+                    inOfs = 0;\n+                    inLen = bufRemainder + inUsed;\n@@ -876,3 +1669,4 @@\n-                    \/\/ data is empty, so complete the ghash op with the\n-                    \/\/ remaining buffer\n-                    ghashAllToS.doLastBlock(buffer, buffer.remaining());\n+                    \/\/ Do an update for the merged block and doFinal on the\n+                    \/\/ remainder in 'in'\n+                    len += op.update(block, 0, blockSize, out, outOfs);\n+                    outOfs += blockSize; \/\/ noop for ghash\n@@ -881,9 +1675,0 @@\n-            \/\/ Prepare buffer for decryption\n-            buffer.flip();\n-        }\n-\n-        if (ct.remaining() > 0) {\n-            ghashAllToS.doLastBlock(ct, ct.remaining());\n-        }\n-        \/\/ Prepare buffer for decryption if available\n-        ct.reset();\n@@ -891,5 +1676,7 @@\n-        byte[] block = getLengthBlock(sizeOfAAD, len);\n-        ghashAllToS.update(block);\n-        block = ghashAllToS.digest();\n-        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n-        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n+            int l = throttleData(op, in, inOfs, inLen, out, outOfs);\n+            if (l > 0) {\n+                inOfs += l;\n+                inLen -= l;\n+                outOfs += l; \/\/ noop for ghash\n+                len += l;\n+            }\n@@ -897,4 +1684,2 @@\n-        \/\/ check entire authentication tag for time-consistency\n-        int mismatch = 0;\n-        for (int i = 0; i < tagLenBytes; i++) {\n-            mismatch |= tag.get() ^ block[i];\n+            \/\/ Finish off the operation\n+            return len + op.doFinal(in, inOfs, inLen, out, outOfs);\n@@ -903,2 +1688,7 @@\n-        if (mismatch != 0) {\n-            throw new AEADBadTagException(\"Tag mismatch!\");\n+        @Override\n+        \/\/ Handler method for encrypting blocks\n+        int cryptBlocks(GCM op, ByteBuffer src, ByteBuffer dst) {\n+            if (src.remaining() > TRIGGERLEN) {\n+                return throttleData(op, src, dst);\n+            }\n+            return op.update(src, dst);\n@@ -907,6 +1697,0 @@\n-        \/\/ Decrypt the all the input data and put it into dst\n-        doLastBlock(buffer, ct, dst);\n-        restoreDst(dst);\n-        src.position(src.limit());\n-        \/\/ 'processed' from the gctr decryption operation, not ghash\n-        return processed;\n@@ -915,3 +1699,4 @@\n-    \/\/ return tag length in bytes\n-    int getTagLen() {\n-        return this.tagLenBytes;\n+    public static final class AESGCM extends GaloisCounterMode {\n+        public AESGCM() {\n+            super(-1, new AESCrypt());\n+        }\n@@ -920,5 +1705,3 @@\n-    int getBufferedLength() {\n-        if (ibuffer == null) {\n-            return 0;\n-        } else {\n-            return ibuffer.size();\n+    public static final class AES128 extends GaloisCounterMode {\n+        public AES128() {\n+            super(16, new AESCrypt());\n@@ -928,13 +1711,5 @@\n-    \/**\n-     * Check for overlap. If the src and dst buffers are using shared data and\n-     * if dst will overwrite src data before src can be processed.  If so, make\n-     * a copy to put the dst data in.\n-     *\/\n-    ByteBuffer overlapDetection(ByteBuffer src, ByteBuffer dst) {\n-        if (src.isDirect() && dst.isDirect()) {\n-            DirectBuffer dsrc = (DirectBuffer) src;\n-            DirectBuffer ddst = (DirectBuffer) dst;\n-\n-            \/\/ Get the current memory address for the given ByteBuffers\n-            long srcaddr = dsrc.address();\n-            long dstaddr = ddst.address();\n+    public static final class AES192 extends GaloisCounterMode {\n+        public AES192() {\n+            super(24, new AESCrypt());\n+        }\n+    }\n@@ -942,6 +1717,5 @@\n-            \/\/ Find the lowest attachment that is the base memory address of the\n-            \/\/ shared memory for the src object\n-            while (dsrc.attachment() != null) {\n-                srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n-                dsrc = (DirectBuffer) dsrc.attachment();\n-            }\n+    public static final class AES256 extends GaloisCounterMode {\n+        public AES256() {\n+            super(32, new AESCrypt());\n+        }\n+    }\n@@ -949,6 +1723,3 @@\n-            \/\/ Find the lowest attachment that is the base memory address of the\n-            \/\/ shared memory for the dst object\n-            while (ddst.attachment() != null) {\n-                dstaddr = ((DirectBuffer) ddst.attachment()).address();\n-                ddst = (DirectBuffer) ddst.attachment();\n-            }\n+    public static final class GCTRGHASH implements GCM {\n+        GCTR gctr;\n+        GHASH ghash;\n@@ -956,16 +1727,4 @@\n-            \/\/ If the base addresses are not the same, there is no overlap\n-            if (srcaddr != dstaddr) {\n-                return dst;\n-            }\n-            \/\/ At this point we know these objects share the same memory.\n-            \/\/ This checks the starting position of the src and dst address for\n-            \/\/ overlap.\n-            \/\/ It uses the base address minus the passed object's address to get\n-            \/\/ the offset from the base address, then add the position() from\n-            \/\/ the passed object.  That gives up the true offset from the base\n-            \/\/ address.  As long as the src side is >= the dst side, we are not\n-            \/\/ in overlap.\n-            if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n-                ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n-                return dst;\n-            }\n+        GCTRGHASH(GCTR c, GHASH g) {\n+            gctr = c;\n+            ghash = g;\n+        }\n@@ -973,6 +1732,7 @@\n-        } else if (!src.isDirect() && !dst.isDirect()) {\n-            if (!src.isReadOnly()) {\n-                \/\/ If using the heap, check underlying byte[] address.\n-                if (src.array() != dst.array()) {\n-                    return dst;\n-                }\n+        @Override\n+        public int update(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) {\n+            int len = gctr.update(in, inOfs, inLen, out, outOfs);\n+            ghash.update(out, outOfs, len);\n+            return len;\n+        }\n@@ -980,10 +1740,7 @@\n-                \/\/ Position plus arrayOffset() will give us the true offset from\n-                \/\/ the underlying byte[] address.\n-                if (src.position() + src.arrayOffset() >=\n-                    dst.position() + dst.arrayOffset()) {\n-                    return dst;\n-                }\n-            }\n-        } else {\n-            \/\/ buffer types aren't the same\n-            return dst;\n+        @Override\n+        public int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+            dst.mark();\n+            int len = gctr.update(in, inOfs, inLen, dst);\n+            dst.reset();\n+            ghash.update(dst, len);\n+            return len;\n@@ -992,11 +1749,8 @@\n-        \/\/ Create a copy\n-        ByteBuffer tmp = dst.duplicate();\n-        \/\/ We can use a heap buffer for internal use, save on alloc cost\n-        ByteBuffer bb = ByteBuffer.allocate(dst.remaining());\n-        tmp.limit(dst.limit());\n-        tmp.position(dst.position());\n-        bb.put(tmp);\n-        bb.flip();\n-        originalDst = dst;\n-        return bb;\n-    }\n+        @Override\n+        public int update(ByteBuffer src, ByteBuffer dst) {\n+            dst.mark();\n+            int len = gctr.update(src, dst);\n+            dst.reset();\n+            ghash.update(dst, len);\n+            return len;\n+        }\n@@ -1004,7 +1758,3 @@\n-    \/**\n-     * If originalDst exists, dst is an internal dst buffer, then copy the data\n-     * into the original dst buffer\n-     *\/\n-    void restoreDst(ByteBuffer dst) {\n-        if (originalDst == null) {\n-            return;\n+        @Override\n+        public int doFinal(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+            return 0;\n@@ -1013,3 +1763,8 @@\n-        dst.flip();\n-        originalDst.put(dst);\n-        originalDst = null;\n+        @Override\n+        public int doFinal(ByteBuffer src, ByteBuffer dst) {\n+            dst.mark();\n+            int l = gctr.doFinal(src, dst);\n+            dst.reset();\n+            ghash.doFinal(dst, l);\n+            return l;\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":1512,"deletions":757,"binary":false,"changes":2269,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-            \"|GCM|CFB72|CFB80|CFB88|CFB96|CFB104|CFB112|CFB120|CFB128\" +\n+            \"|CFB72|CFB80|CFB88|CFB96|CFB104|CFB112|CFB120|CFB128\" +\n@@ -206,3 +206,0 @@\n-        psA(\"Cipher\", \"AES_128\/GCM\/NoPadding\",\n-                \"com.sun.crypto.provider.AESCipher$AES128_GCM_NoPadding\",\n-                attrs);\n@@ -222,3 +219,0 @@\n-        psA(\"Cipher\", \"AES_192\/GCM\/NoPadding\",\n-                \"com.sun.crypto.provider.AESCipher$AES192_GCM_NoPadding\",\n-                attrs);\n@@ -238,0 +232,15 @@\n+\n+        attrs.clear();\n+        attrs.put(\"SupportedModes\", \"GCM\");\n+        attrs.put(\"SupportedKeyFormats\", \"RAW\");\n+\n+\/\/        ps(\"Cipher\", \"GCM\",\n+\/\/            \"com.sun.crypto.provider.GaloisCounterMode$AESGCM\", null, attrs);\n+        ps(\"Cipher\", \"AES\/GCM\/NoPadding\",\n+            \"com.sun.crypto.provider.GaloisCounterMode$AESGCM\", null, attrs);\n+        psA(\"Cipher\", \"AES_128\/GCM\/NoPadding\",\n+            \"com.sun.crypto.provider.GaloisCounterMode$AES128\",\n+            attrs);\n+        psA(\"Cipher\", \"AES_192\/GCM\/NoPadding\",\n+            \"com.sun.crypto.provider.GaloisCounterMode$AES192\",\n+            attrs);\n@@ -239,2 +248,2 @@\n-                \"com.sun.crypto.provider.AESCipher$AES256_GCM_NoPadding\",\n-                attrs);\n+            \"com.sun.crypto.provider.GaloisCounterMode$AES256\",\n+            attrs);\n@@ -247,1 +256,1 @@\n-                \"com.sun.crypto.provider.DESedeWrapCipher\", null, attrs);\n+            \"com.sun.crypto.provider.DESedeWrapCipher\", null, attrs);\n@@ -256,1 +265,1 @@\n-                null, attrs);\n+            null, attrs);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -220,1 +220,2 @@\n-        store(\"AES\", KnownOIDs.AES, \"Rijndael\");\n+        store(\"AES\/GCM\", KnownOIDs.AES_128$GCM$NoPadding,\n+            \"AES\/GCM\/NoPadding\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.HexFormat;\n@@ -87,1 +88,1 @@\n-    private static final String ALGORITHMS[] = { \"AES\", \"Rijndael\" };\n+    private static final String ALGORITHMS[] = { \"AES\" };\n@@ -233,0 +234,1 @@\n+            HexFormat hex = HexFormat.of().withUpperCase();\n@@ -234,0 +236,3 @@\n+                System.out.println(\"Combination #\" + k + 1 + \"\\nresult    \" +\n+                    hex.formatHex(outputTexts.get(k)) +\n+                    \"\\nexpected: \" + hex.formatHex(output));\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/Encrypt.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.math.BigInteger;\n@@ -44,0 +43,1 @@\n+import java.util.HexFormat;\n@@ -68,0 +68,1 @@\n+    static HexFormat hex = HexFormat.of();\n@@ -111,2 +112,2 @@\n-                System.out.println(\"Error in generating data for length \" +\n-                    ptlen);\n+                throw new RuntimeException(\"Error in generating data for length \" +\n+                    ptlen, e);\n@@ -119,0 +120,7 @@\n+        private static final byte[] HexToBytes(String hexVal) {\n+            if (hexVal == null) {\n+                return new byte[0];\n+            }\n+            return hex.parseHex(hexVal);\n+        }\n+\n@@ -179,1 +187,1 @@\n-        throw new Exception(\"Unaeble to find dataSet id = \" + id);\n+        throw new Exception(\"Unable to find dataSet id = \" + id);\n@@ -247,1 +255,1 @@\n-        System.out.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n+        System.err.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n@@ -259,1 +267,1 @@\n-                    System.out.print(\"Encrypt:  Data Index: \" + i + \" \\tSizes[ \");\n+                    System.err.print(\"Encrypt:  Data Index: \" + i + \" \\tSizes[ \");\n@@ -261,1 +269,1 @@\n-                        System.out.print(v + \" \");\n+                        System.err.print(v + \" \");\n@@ -263,1 +271,1 @@\n-                    System.out.println(\"]\");\n+                    System.err.println(\"]\");\n@@ -269,1 +277,1 @@\n-                    System.out.print(\"Decrypt:  Data Index: \" + i + \" \\tSizes[ \");\n+                    System.err.print(\"Decrypt:  Data Index: \" + i + \" \\tSizes[ \");\n@@ -271,1 +279,1 @@\n-                        System.out.print(v + \" \");\n+                        System.err.print(v + \" \");\n@@ -273,1 +281,1 @@\n-                    System.out.println(\"]\");\n+                    System.err.println(\"]\");\n@@ -280,1 +288,1 @@\n-                System.out.println(\"Encrypt:  Data Index: \" + i);\n+                System.err.println(\"Encrypt:  Data Index: \" + i);\n@@ -283,1 +291,1 @@\n-                System.out.println(\"Decrypt:  Data Index: \" + i);\n+                System.err.println(\"Decrypt:  Data Index: \" + i);\n@@ -301,1 +309,1 @@\n-        System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+        System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n@@ -307,1 +315,1 @@\n-            System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n@@ -323,2 +331,2 @@\n-        System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n-            inOfs + \"  outOfs \" + outOfs + \"  in-place: different\");\n+        System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: different\");\n@@ -329,1 +337,1 @@\n-            System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n@@ -487,6 +495,4 @@\n-                        \"):\\nresult   (len=\" + ctresult.length + \"):\" +\n-                        String.format(\"%0\" + (ctresult.length << 1) + \"x\",\n-                            new BigInteger(1, ctresult)) +\n-                        \"\\nexpected (len=\" + output.length + \"):\" +\n-                    String.format(\"%0\" + (output.length << 1) + \"x\",\n-                        new BigInteger(1, output));\n+                        \"):\\nresult   (len=\" + ctresult.length + \"): \" +\n+                        hex.formatHex(ctresult) +\n+                        \"\\nexpected (len=\" + output.length + \"): \" +\n+                        hex.formatHex(output);\n@@ -608,1 +614,1 @@\n-                        byteToHex(out) +\n+                        hex.formatHex(out) +\n@@ -610,2 +616,1 @@\n-                        String.format(\"%0\" + (output.length << 1) + \"x\",\n-                            new BigInteger(1, output));\n+                        hex.formatHex(output);\n@@ -626,0 +631,2 @@\n+        GCMBufferTest t;\n+\n@@ -627,0 +634,1 @@\n+\n@@ -665,1 +673,1 @@\n-        GCMBufferTest t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n@@ -681,0 +689,1 @@\n+\n@@ -713,1 +722,0 @@\n-    }\n@@ -715,18 +723,3 @@\n-    private static byte[] HexToBytes(String hexVal) {\n-        if (hexVal == null) {\n-            return new byte[0];\n-        }\n-        byte[] result = new byte[hexVal.length()\/2];\n-        for (int i = 0; i < result.length; i++) {\n-            String byteVal = hexVal.substring(2*i, 2*i +2);\n-            result[i] = Integer.valueOf(byteVal, 16).byteValue();\n-        }\n-        return result;\n-    }\n-\n-    private static String byteToHex(byte[] barray) {\n-        StringBuilder s = new StringBuilder();\n-        for (byte b : barray) {\n-            s.append(String.format(\"%02x\", b));\n-        }\n-        return s.toString();\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+            dataSegments(new int[] { 49, 0, 2 }).dataSet(0).test();\n@@ -765,2 +758,1 @@\n-                \"794ec588176c703d3d2a7a07\",\n-                new byte[256], null,\n+                \"794ec588176c703d3d2a7a07\", new byte[256], null,\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMBufferTest.java","additions":42,"deletions":50,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+\/*\n+ * @test\n+ * @summary Call decrypt doFinal() with different output values to see if the\n+ * the operation can complete after a ShortBufferException\n+ *\/\n+public class GCMShortBuffer {\n+    static Cipher c;\n+    static final GCMParameterSpec iv = new GCMParameterSpec(128, new byte[16]);\n+    static final SecretKeySpec keySpec = new SecretKeySpec(new byte[16], \"AES\");\n+    static byte cipherText[], plaintext[] = new byte[51];\n+\n+    GCMShortBuffer(byte[] out) throws Exception {\n+        int len = cipherText.length - 1;\n+\n+        c.init(Cipher.DECRYPT_MODE, keySpec, iv);\n+        byte[] pt = new byte[c.getOutputSize(cipherText.length)];\n+        c.update(cipherText, 0, 1);\n+        try {\n+            c.doFinal(cipherText, 1, len, out, 0);\n+        } catch (ShortBufferException e) {\n+            System.out.println(\"ShortBuffer caught\");\n+        } catch (Exception e) {\n+            throw e;\n+        }\n+        c.doFinal(cipherText, 1, len, pt, 0);\n+        if (Arrays.compare(pt, plaintext) != 0) {\n+            System.out.println(\"output  : \" + HexFormat.of().formatHex(pt));\n+            System.out.println(\"expected: \" + HexFormat.of().formatHex(plaintext));\n+            System.out.println(\"output and plaintext do not match\");\n+        }\n+    }\n+\n+    GCMShortBuffer(ByteBuffer dst) throws Exception {\n+        int len = cipherText.length - 1;\n+        ByteBuffer out = ByteBuffer.allocate(plaintext.length);\n+\n+        c.init(Cipher.DECRYPT_MODE, keySpec, iv);\n+        c.update(cipherText, 0, 1);\n+        ByteBuffer ct = ByteBuffer.wrap(cipherText, 1, len);\n+        try {\n+            c.doFinal(ct , dst);\n+        } catch (ShortBufferException e) {\n+            System.out.println(\"ShortBuffer caught\");\n+        } catch (Exception e) {\n+            throw e;\n+        }\n+        c.doFinal(ByteBuffer.wrap(cipherText, 1, len), out);\n+        out.flip();\n+        if (out.compareTo(ByteBuffer.wrap(plaintext)) != 0) {\n+            System.out.println(\"output  : \" + HexFormat.of().formatHex(out.array()));\n+            System.out.println(\"expected: \" + HexFormat.of().formatHex(plaintext));\n+            throw new Exception(\"output and plaintext do not match\");\n+\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        c = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+        c.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n+        cipherText = c.doFinal(plaintext);\n+\n+        new GCMShortBuffer(new byte[13]);\n+        new GCMShortBuffer(new byte[50]);\n+        new GCMShortBuffer(ByteBuffer.allocate(13));\n+        new GCMShortBuffer(ByteBuffer.allocate(50));\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMShortBuffer.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -110,0 +110,3 @@\n+                System.out.println(\"inOfsInBuf  = \" + inOfsInBuf);\n+                System.out.println(\"outOfsInBuf = \" + outOfsInBuf);\n+\n@@ -135,2 +138,0 @@\n-                    System.out.println(\"inOfsInBuf  = \" + inOfsInBuf);\n-                    System.out.println(\"outOfsInBuf = \" + outOfsInBuf);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/OverlapByteBuffer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.Arrays;\n+import java.util.HexFormat;\n@@ -37,0 +39,1 @@\n+import javax.crypto.spec.GCMParameterSpec;\n@@ -38,0 +41,1 @@\n+import javax.crypto.spec.SecretKeySpec;\n@@ -46,1 +50,0 @@\n- * @key randomness\n@@ -59,1 +62,3 @@\n-    private static final int KEY_LENGTH = 128;\n+    private static final int KEY_LENGTH = 16;\n+    static byte[] plainText = new byte[128];\n+    static byte[] key = new byte[KEY_LENGTH];\n@@ -62,0 +67,2 @@\n+        plainText = makeData(plainText.length);\n+        key = makeData(KEY_LENGTH);\n@@ -76,0 +83,10 @@\n+    static byte[] makeData(int len) {\n+        int i = 0;\n+        byte[] b = new byte[len];\n+        while (i < len) {\n+            b[i] = (byte)(i % 255);\n+            i++;\n+        }\n+        return b;\n+    }\n+\n@@ -77,4 +94,7 @@\n-        Cipher ci = null;\n-        byte[] iv = null;\n-        AlgorithmParameterSpec aps = null;\n-        SecretKey key = null;\n+        Cipher ci;\n+        System.out.println(\"Testing \" + algo + \"\/\" + mo + \"\/\" + pad);\n+\n+        byte[] iv = makeData(16);\n+        AlgorithmParameterSpec aps = new GCMParameterSpec(128, new byte[16]);\n+        SecretKey key = new SecretKeySpec(this.key, 0, KEY_LENGTH,\"AES\");\n+\n@@ -83,4 +103,0 @@\n-            Random rdm = new Random();\n-            byte[] plainText = new byte[128];\n-            rdm.nextBytes(plainText);\n-\n@@ -88,3 +104,0 @@\n-            KeyGenerator kg = KeyGenerator.getInstance(algo, PROVIDER);\n-            kg.init(KEY_LENGTH);\n-            key = kg.generateKey();\n@@ -93,1 +106,1 @@\n-            if (!mo.equalsIgnoreCase(\"GCM\")) {\n+            if (mo.equalsIgnoreCase(\"GCM\")) {\n@@ -95,0 +108,2 @@\n+            } else if (mo.equalsIgnoreCase(\"ECB\")) {\n+                ci.init(Cipher.ENCRYPT_MODE, key, (AlgorithmParameterSpec)null);\n@@ -96,1 +111,1 @@\n-                ci.init(Cipher.ENCRYPT_MODE, key);\n+                ci.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));\n@@ -100,3 +115,3 @@\n-            int offset = ci.update(plainText, 0, plainText.length, cipherText,\n-                    0);\n-            ci.doFinal(cipherText, offset);\n+            \/\/int offset = ci.update(plainText, 0, plainText.length, cipherText, 0);\n+            \/\/ci.doFinal(cipherText, offset);\n+            ci.doFinal(plainText, 0, plainText.length, cipherText, 0);\n@@ -120,2 +135,0 @@\n-            byte[] tmp = new byte[len];\n-            System.arraycopy(recoveredText, 0, tmp, 0, len);\n@@ -124,1 +137,2 @@\n-            if (!java.util.Arrays.equals(plainText, tmp)) {\n+            if (!java.util.Arrays.equals(plainText, 0 , plainText.length,\n+                recoveredText, 0, len)) {\n@@ -126,1 +140,1 @@\n-                dumpBytes(plainText);\n+                System.out.println(HexFormat.of().formatHex(plainText));\n@@ -128,4 +142,4 @@\n-                dumpBytes(tmp);\n-                throw new RuntimeException(\n-                        \"Original text is not equal with recovered text, with mode:\"\n-                                + mo);\n+                System.out.println(HexFormat.of().\n+                    formatHex(recoveredText, 0, len));\n+                throw new RuntimeException(\"Original text is not equal with \" +\n+                    \"recovered text, with mode:\" + mo);\n@@ -137,2 +151,2 @@\n-                System.out.println(\"Unexpected NoSuchAlgorithmException with mode: \"\n-                        + mo);\n+                System.out.println(\"Unexpected NoSuchAlgorithmException with\" +\n+                    \" mode: \" + mo);\n@@ -149,8 +163,0 @@\n-\n-    private void dumpBytes(byte[] bytes) {\n-        for (byte b : bytes) {\n-            System.out.print(Integer.toHexString(b));\n-        }\n-\n-        System.out.println();\n-    }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestAESCipher.java","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private static final String ALGORITHM = \"Rijndael\";\n+    private static final String ALGORITHM = \"AES\";\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestSameBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}