{"files":[{"patch":"@@ -988,0 +988,6 @@\n+\n+            \/\/ 'inLen' stores the length to use with buffer 'in'.\n+            \/\/ 'len' stores the length returned by the method.\n+            int len = 0;\n+            int bLen = getBufferedLength();\n+\n@@ -989,0 +995,27 @@\n+            out = overlapDetection(in, inOfs, out, outOfs);\n+\n+            \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n+            if (bLen > 0) {\n+                byte[] buffer = ibuffer.toByteArray();\n+                \/\/ number of bytes not filling a block\n+                int remainder = bLen % blockSize;\n+                \/\/ number of bytes along block boundary\n+                bLen -= remainder;\n+\n+                \/\/ If there is enough bytes in ibuffer for a block or more,\n+                \/\/ encrypt that first.\n+                if (bLen > 0) {\n+                    len += cryptBlocks(buffer, 0, bLen, out, outOfs);\n+                    outOfs += bLen;\n+                }\n+\n+                \/\/ blen is now the offset for 'buffer'\n+\n+                \/\/ Construct and encrypt a block if there is enough 'buffer' and\n+                \/\/ 'in' to make one\n+                if ((inLen + remainder) >= blockSize) {\n+                    byte[] block = new byte[blockSize];\n+\n+                    System.arraycopy(buffer, bLen, block, 0, remainder);\n+                    int inLenUsed = blockSize - remainder;\n+                    System.arraycopy(in, inOfs, block, remainder, inLenUsed);\n@@ -990,1 +1023,32 @@\n-            return encryptBlocks(in, inOfs, inLen, out, outOfs);\n+                    len += cryptBlocks(block, 0, blockSize, out, outOfs);\n+                    inOfs += inLenUsed;\n+                    inLen -= inLenUsed;\n+                    outOfs += blockSize;\n+                    ibuffer.reset();\n+                    \/\/ Code below will write the remainder from 'in' to ibuffer\n+                } else if (remainder > 0) {\n+                    \/\/ If a block or more was encrypted from 'buffer' only, but\n+                    \/\/ the rest of 'buffer' with 'in' could not construct a\n+                    \/\/  block, then put the rest of 'buffer' back into ibuffer.\n+                    ibuffer.reset();\n+                    ibuffer.write(buffer, bLen, remainder);\n+                    \/\/ Code below will write the remainder from 'in' to ibuffer\n+                }\n+            }\n+\n+            \/\/ Encrypt the remaining blocks inside of 'in'\n+            if (inLen > 0) {\n+                len += cryptBlocks(in, inOfs, inLen, out, outOfs);\n+            }\n+\n+            \/\/ Write any remaining bytes less than a blockSize into ibuffer.\n+            int remainder = inLen % blockSize;\n+            if (remainder > 0) {\n+                initBuffer(remainder);\n+                inLen -= remainder;\n+                \/\/ remainder offset is based on original buffer length\n+                ibuffer.write(in, inOfs + inLen, remainder);\n+            }\n+\n+            restoreOut(out, len);\n+            return len;\n@@ -1002,2 +1066,59 @@\n-            return encryptBlocks((ibuffer == null || ibuffer.size() == 0) ?\n-                null : ByteBuffer.wrap(ibuffer.toByteArray()), src, dst);\n+            checkDataLength(src.remaining(), getBufferedLength());\n+\n+            \/\/ 'len' stores the length returned by the method.\n+            int len = 0;\n+            ByteBuffer buffer = (ibuffer == null || ibuffer.size() == 0) ?\n+                null : ByteBuffer.wrap(ibuffer.toByteArray());\n+            processAAD();\n+\n+            dst = overlapDetection(src, dst);\n+            \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n+            if (buffer != null && buffer.remaining() > 0) {\n+                \/\/ number of bytes not filling a block\n+                int remainder = buffer.remaining() % blockSize;\n+                \/\/ number of bytes along block boundary\n+                int blen = ibuffer.size() - remainder;\n+\n+                \/\/ If there is enough bytes in ibuffer for a block or more,\n+                \/\/ en\/decrypt that first.\n+                if (blen > 0) {\n+                    len += cryptBlocks(buffer, dst);\n+                }\n+\n+                \/\/ Check if there is any data left in the buffer, if there is,\n+                \/\/ try to construct a block with data from the buffer and src\n+                \/\/ to en\/decrypt.\n+                if (buffer.remaining() == 0) {\n+                    ibuffer.reset();\n+                } else {\n+                    if ((buffer.remaining() + src.remaining()) >= blockSize) {\n+                        byte[] block = new byte[blockSize];\n+                        buffer.get(block, 0, remainder);\n+                        src.get(block, remainder, blockSize - remainder);\n+                        len += cryptBlocks(\n+                            ByteBuffer.wrap(block, 0, blockSize), dst);\n+                        ibuffer.reset();\n+                    }\n+                }\n+            }\n+\n+            \/\/ encrypt any blocksized data in 'src'\n+            if (src.remaining() >= blockSize) {\n+                len += cryptBlocks(src, dst);\n+            }\n+\n+            \/\/ Write the remaining bytes into the 'ibuffer'\n+            if (src.remaining() > 0) {\n+                initBuffer(src.remaining());\n+                byte[] b = new byte[src.remaining()];\n+                src.get(b);\n+                \/\/ remainder offset is based on original buffer length\n+                try {\n+                    ibuffer.write(b);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            restoreDst(dst);\n+            return len;\n@@ -1149,144 +1270,0 @@\n-        \/**\n-         * Take any less than blocksize data from ibuffer and combine it with\n-         * 'in' to encrypt or decrypt a block, then encrypted what it can\n-         * from the remaining blocksize bytes in 'in'.  Any bytes under a\n-         * blocksize are put into the 'ibuffer'.\n-         *\/\n-        int encryptBlocks(byte[] in, int inOfs, int inLen, byte[] out,\n-            int outOfs) {\n-            \/\/ 'inLen' stores the length to use with buffer 'in'.\n-            \/\/ 'len' stores the length returned by the method.\n-            int len = 0;\n-            int bLen = getBufferedLength();\n-\n-            processAAD();\n-\n-            out = overlapDetection(in, inOfs, out, outOfs);\n-\n-            \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n-            if (bLen > 0) {\n-                byte[] buffer = ibuffer.toByteArray();\n-                \/\/ number of bytes not filling a block\n-                int remainder = bLen % blockSize;\n-                \/\/ number of bytes along block boundary\n-                bLen -= remainder;\n-\n-                \/\/ If there is enough bytes in ibuffer for a block or more,\n-                \/\/ encrypt that first.\n-                if (bLen > 0) {\n-                    len += cryptBlocks(buffer, 0, bLen, out, outOfs);\n-                    outOfs += bLen;\n-                }\n-\n-                \/\/ blen is now the offset for 'buffer'\n-\n-                \/\/ Construct and encrypt a block if there is enough 'buffer' and\n-                \/\/ 'in' to make one\n-                if ((inLen + remainder) >= blockSize) {\n-                    byte[] block = new byte[blockSize];\n-\n-                    System.arraycopy(buffer, bLen, block, 0, remainder);\n-                    int inLenUsed = blockSize - remainder;\n-                    System.arraycopy(in, inOfs, block, remainder, inLenUsed);\n-\n-                    len += cryptBlocks(block, 0, blockSize, out, outOfs);\n-                    inOfs += inLenUsed;\n-                    inLen -= inLenUsed;\n-                    outOfs += blockSize;\n-                    ibuffer.reset();\n-                    \/\/ Code below will write the remainder from 'in' to ibuffer\n-                } else if (remainder > 0) {\n-                    \/\/ If a block or more was encrypted from 'buffer' only, but\n-                    \/\/ the rest of 'buffer' with 'in' could not construct a\n-                    \/\/  block, then put the rest of 'buffer' back into ibuffer.\n-                    ibuffer.reset();\n-                    ibuffer.write(buffer, bLen, remainder);\n-                    \/\/ Code below will write the remainder from 'in' to ibuffer\n-                }\n-            }\n-\n-            \/\/ Encrypt the remaining blocks inside of 'in'\n-            if (inLen > 0) {\n-                len += cryptBlocks(in, inOfs, inLen, out, outOfs);\n-            }\n-\n-            \/\/ Write any remaining bytes less than a blockSize into ibuffer.\n-            int remainder = inLen % blockSize;\n-            if (remainder > 0) {\n-                initBuffer(remainder);\n-                inLen -= remainder;\n-                \/\/ remainder offset is based on original buffer length\n-                ibuffer.write(in, inOfs + inLen, remainder);\n-            }\n-\n-            restoreOut(out, len);\n-            return len;\n-        }\n-\n-        \/**\n-         * Take any less than blocksize data from ibuffer and combine it with\n-         * 'src' to encrypt or decrypt a block, then encrypted what it can\n-         * from the remaining blocksize bytes in 'src'.  Any bytes under a\n-         * blocksize are put into the 'ibuffer'.\n-         *\n-         * Because this does encrypt and decrypt, ibuffer could be > blockSize\n-         *\/\n-        int encryptBlocks(ByteBuffer buffer, ByteBuffer src, ByteBuffer dst) {\n-            processAAD();\n-            \/\/ 'inLen' stores the length to use with buffer 'in'.\n-            \/\/ 'len' stores the length returned by the method.\n-            int len = 0;\n-\n-            dst = overlapDetection(src, dst);\n-            \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n-            if (buffer != null && buffer.remaining() > 0) {\n-                \/\/ number of bytes not filling a block\n-                int remainder = buffer.remaining() % blockSize;\n-                \/\/ number of bytes along block boundary\n-                int blen = ibuffer.size() - remainder;\n-\n-                \/\/ If there is enough bytes in ibuffer for a block or more,\n-                \/\/ en\/decrypt that first.\n-                if (blen > 0) {\n-                    len += cryptBlocks(buffer, dst);\n-                }\n-\n-                \/\/ Check if there is any data left in the buffer, if there is,\n-                \/\/ try to construct a block with data from the buffer and src\n-                \/\/ to en\/decrypt.\n-                if (buffer.remaining() == 0) {\n-                    ibuffer.reset();\n-                } else {\n-                    if ((buffer.remaining() + src.remaining()) >= blockSize) {\n-                        byte[] block = new byte[blockSize];\n-                        buffer.get(block, 0, remainder);\n-                        src.get(block, remainder, blockSize - remainder);\n-                        len += cryptBlocks(\n-                            ByteBuffer.wrap(block, 0, blockSize), dst);\n-                        ibuffer.reset();\n-                    }\n-                }\n-            }\n-\n-            \/\/ encrypt any blocksized data in 'src'\n-            if (src.remaining() >= blockSize) {\n-                len += cryptBlocks(src, dst);\n-            }\n-\n-            \/\/ Write the remaining bytes into the 'ibuffer'\n-            if (src.remaining() > 0) {\n-                initBuffer(src.remaining());\n-                byte[] b = new byte[src.remaining()];\n-                src.get(b);\n-                \/\/ remainder offset is based on original buffer length\n-                try {\n-                    ibuffer.write(b);\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-\n-            restoreDst(dst);\n-            return len;\n-        }\n-\n@@ -1335,0 +1312,1 @@\n+            initEngine();\n@@ -1361,0 +1339,1 @@\n+            processAAD();\n@@ -1410,3 +1389,0 @@\n-            \/\/ Initialize GHASH & GCTR\n-            initEngine();\n-\n@@ -1472,3 +1448,0 @@\n-            \/\/ Initialize GHASH & GCTR\n-            initEngine();\n-\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":126,"deletions":153,"binary":false,"changes":279,"status":"modified"}]}