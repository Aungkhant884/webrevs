{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteBuffer;\n@@ -128,2 +127,0 @@\n-    private byte[] lastEncKey = null;\n-\n@@ -201,9 +198,0 @@\n-    \/**\n-     * Returns the mode of this cipher.\n-     *\n-     * @return the parsed cipher mode\n-     *\/\n-    int getMode() {\n-        return cipherMode;\n-    }\n-\n@@ -449,18 +437,5 @@\n-        try {\n-            byte[] ivBytes = null;\n-            if (params != null) {\n-                if (params instanceof IvParameterSpec) {\n-                    ivBytes = ((IvParameterSpec) params).getIV();\n-                    if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n-                        throw new InvalidAlgorithmParameterException\n-                            (\"Wrong IV length: must be \" + blockSize +\n-                                \" bytes long\");\n-                    }\n-                } else if (params instanceof RC2ParameterSpec) {\n-                    ivBytes = ((RC2ParameterSpec) params).getIV();\n-                    if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n-                        throw new InvalidAlgorithmParameterException\n-                            (\"Wrong IV length: must be \" + blockSize +\n-                                \" bytes long\");\n-                    }\n-                } else {\n+        byte[] ivBytes = null;\n+        if (params != null) {\n+            if (params instanceof IvParameterSpec) {\n+                ivBytes = ((IvParameterSpec) params).getIV();\n+                if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n@@ -468,1 +443,2 @@\n-                        (\"Unsupported parameter: \" + params);\n+                        (\"Wrong IV length: must be \" + blockSize +\n+                            \" bytes long\");\n@@ -470,3 +446,3 @@\n-            }\n-            if (cipherMode == ECB_MODE) {\n-                if (ivBytes != null) {\n+            } else if (params instanceof RC2ParameterSpec) {\n+                ivBytes = ((RC2ParameterSpec) params).getIV();\n+                if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n@@ -474,6 +450,2 @@\n-                            (\"ECB mode cannot use IV\");\n-                }\n-            } else if (ivBytes == null) {\n-                if (decrypting) {\n-                    throw new InvalidAlgorithmParameterException(\"Parameters \"\n-                            + \"missing\");\n+                        (\"Wrong IV length: must be \" + blockSize +\n+                            \" bytes long\");\n@@ -481,7 +453,14 @@\n-\n-                if (random == null) {\n-                    random = SunJCE.getRandom();\n-                }\n-\n-                ivBytes = new byte[blockSize];\n-                random.nextBytes(ivBytes);\n+            } else {\n+                throw new InvalidAlgorithmParameterException\n+                    (\"Unsupported parameter: \" + params);\n+            }\n+        }\n+        if (cipherMode == ECB_MODE) {\n+            if (ivBytes != null) {\n+                throw new InvalidAlgorithmParameterException\n+                    (\"ECB mode cannot use IV\");\n+            }\n+        } else if (ivBytes == null) {\n+            if (decrypting) {\n+                throw new InvalidAlgorithmParameterException(\"Parameters \"\n+                    + \"missing\");\n@@ -490,9 +469,2 @@\n-            buffered = 0;\n-            diffBlocksize = blockSize;\n-\n-            String algorithm = key.getAlgorithm();\n-            cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n-            \/\/ skip checking key+iv from now on until after doFinal()\n-        } finally {\n-            if (lastEncKey != keyBytes) {\n-                Arrays.fill(keyBytes, (byte) 0);\n+            if (random == null) {\n+                random = SunJCE.getRandom();\n@@ -500,0 +472,3 @@\n+\n+            ivBytes = new byte[blockSize];\n+            random.nextBytes(ivBytes);\n@@ -501,0 +476,6 @@\n+\n+        buffered = 0;\n+        diffBlocksize = blockSize;\n+\n+        String algorithm = key.getAlgorithm();\n+        cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n@@ -757,1 +738,1 @@\n-                    \/\/ Zero out internal (ouput) array\n+                    \/\/ Zero out internal (output) array\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":38,"deletions":57,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    byte[] block;\n+    private byte[] block;\n@@ -86,1 +86,1 @@\n-    void checkBlock() {\n+    private void checkBlock() {\n@@ -95,1 +95,1 @@\n-     * Using the given inLen, this operations only on blockSize data, leaving\n+     * Using the given inLen, this operates only on blockSize data, leaving\n@@ -97,1 +97,1 @@\n-     * The return value will be (inLen - (inLen - blockSize))\n+     * The return value will be (inLen - (inLen % blockSize))\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.jca.JCAUtil;\n@@ -49,0 +50,1 @@\n+import java.security.MessageDigest;\n@@ -70,6 +72,0 @@\n-\n-    SymmetricCipher blockCipher;\n-    \/\/ Engine instance for encryption or decryption\n-    private GCMEngine engine;\n-\n-    private boolean encryption = true;\n@@ -77,1 +73,1 @@\n-\n+    static int DEFAULT_TAG_LEN = 16; \/\/ in bytes\n@@ -87,1 +83,0 @@\n-\n@@ -91,0 +86,2 @@\n+    static final byte[] EMPTY_BUF = new byte[0];\n+\n@@ -92,1 +89,7 @@\n-    \/\/ Default value is 128bits, this in stores bytes.\n+\n+    SymmetricCipher blockCipher;\n+    \/\/ Engine instance for encryption or decryption\n+    private GCMEngine engine;\n+    private boolean encryption = true;\n+\n+    \/\/ Default value is 128bits, this is in bytes.\n@@ -94,1 +97,1 @@\n-    \/\/ Key size if the value is passed\n+    \/\/ Key size if the value is passed, in bytes.\n@@ -98,3 +101,2 @@\n-    final static byte[] emptyBuf = new byte[0];\n-    byte[] lastKey = emptyBuf;\n-    byte[] lastIv = emptyBuf;\n+    byte[] lastKey = EMPTY_BUF;\n+    byte[] lastIv = EMPTY_BUF;\n@@ -102,1 +104,1 @@\n-\n+    SecureRandom random = null;\n@@ -137,2 +139,2 @@\n-            if (Arrays.compare(keyValue, lastKey) == 0 && Arrays.compare(iv,\n-                lastIv) == 0) {\n+            if (MessageDigest.isEqual(keyValue, lastKey) &&\n+                MessageDigest.isEqual(iv, lastIv)) {\n@@ -144,0 +146,3 @@\n+            if (lastKey != null) {\n+                Arrays.fill(lastKey, (byte) 0);\n+            }\n@@ -146,4 +151,0 @@\n-        } else {\n-            if (spec == null) {\n-                throw new InvalidKeyException(\"No GCMParameterSpec specified\");\n-            }\n@@ -166,5 +167,0 @@\n-    \/\/ return tag length in bytes\n-    int getTagLen() {\n-        return this.tagLenBytes;\n-    }\n-\n@@ -199,1 +195,7 @@\n-        return super.engineGetKeySize(key);\n+        byte[] encoded = key.getEncoded();\n+        Arrays.fill(encoded, (byte)0);\n+        if (!AESCrypt.isKeySizeValid(encoded.length)) {\n+            throw new InvalidKeyException(\"Invalid key length: \" +\n+                                          encoded.length + \" bytes\");\n+        }\n+        return Math.multiplyExact(encoded.length, 8);\n@@ -204,0 +206,3 @@\n+        if (iv == null) {\n+            return null;\n+        }\n@@ -217,4 +222,2 @@\n-        if (random != null) {\n-            random.nextBytes(iv);\n-        } else {\n-            new SecureRandom().nextBytes(iv);\n+        if (random == null) {\n+            random = JCAUtil.getDefSecureRandom();\n@@ -222,0 +225,1 @@\n+        random.nextBytes(iv);\n@@ -225,1 +229,0 @@\n-    SecureRandom random = null;\n@@ -229,1 +232,1 @@\n-        spec = new GCMParameterSpec(getTagLen() * 8,\n+        spec = new GCMParameterSpec(DEFAULT_TAG_LEN * 8,\n@@ -266,1 +269,1 @@\n-            spec = new GCMParameterSpec(getTagLen() * 8, iv);\n+            spec = new GCMParameterSpec(DEFAULT_TAG_LEN * 8, iv);\n@@ -377,2 +380,0 @@\n-        checkInit();\n-        byte[] output = new byte[engine.getOutputSize(inputLen, true)];\n@@ -380,1 +381,1 @@\n-            input = emptyBuf;\n+            input = EMPTY_BUF;\n@@ -382,0 +383,9 @@\n+        try {\n+            ArrayUtil.nullAndBoundsCheck(input, inputOffset, inputLen);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new IllegalBlockSizeException(\"input array invalid\");\n+        }\n+\n+        checkInit();\n+        byte[] output = new byte[engine.getOutputSize(inputLen, true)];\n+\n@@ -397,1 +407,1 @@\n-        checkInit();\n+\n@@ -399,1 +409,1 @@\n-            input = emptyBuf;\n+            input = EMPTY_BUF;\n@@ -403,1 +413,1 @@\n-        } catch (Exception e) {\n+        } catch (ArrayIndexOutOfBoundsException e) {\n@@ -408,0 +418,1 @@\n+        checkInit();\n@@ -434,0 +445,2 @@\n+        byte[] encodedKey = null;\n+\n@@ -436,1 +449,1 @@\n-            byte[] encodedKey = key.getEncoded();\n+            encodedKey = key.getEncoded();\n@@ -447,0 +460,1 @@\n+            Arrays.fill(encodedKey, (byte)0);\n@@ -468,2 +482,6 @@\n-        return ConstructKeys.constructKey(encodedKey, wrappedKeyAlgorithm,\n-                                          wrappedKeyType);\n+        try {\n+            return ConstructKeys.constructKey(encodedKey, wrappedKeyAlgorithm,\n+                wrappedKeyType);\n+        } finally {\n+            Arrays.fill(encodedKey, (byte)0);\n+        }\n@@ -556,1 +574,0 @@\n-\n@@ -628,0 +645,8 @@\n+        \/**\n+         * The method takes two buffers to create one block of data.  The\n+         * difference with the other mergeBlock is this will calculate\n+         * the bufLen from the existing 'buffer' length & offset\n+         *\n+         * This is only called when buffer length is less than a blockSize\n+         * @return number of bytes used from 'in'\n+         *\/\n@@ -637,1 +662,1 @@\n-         * This in only called when buffer length is less that a blockSize\n+         * This is only called when buffer length is less than a blockSize\n@@ -648,2 +673,1 @@\n-            int inUsed = Math.min(block.length - bufLen,\n-                (Math.min(inLen, block.length)));\n+            int inUsed = Math.min(block.length - bufLen, inLen);\n@@ -1471,3 +1495,0 @@\n-            \/\/ Check for overlap in the bytebuffers\n-            dst = overlapDetection(src, dst);\n-\n@@ -1477,0 +1498,1 @@\n+            ByteBuffer buffer = null;\n@@ -1478,3 +1500,17 @@\n-            ByteBuffer buffer = ((ibuffer == null || ibuffer.size() == 0) ?\n-                null : ByteBuffer.wrap(ibuffer.toByteArray()));\n-            int len;\n+            \/\/ The 'len' the total amount of ciphertext\n+            int len = ct.remaining() - tagLenBytes;\n+\n+            \/\/ Check if ibuffer has data\n+            if (getBufferedLength() != 0) {\n+                buffer = ByteBuffer.wrap(ibuffer.toByteArray());\n+                len += buffer.remaining();\n+            }\n+\n+            checkDataLength(len);\n+\n+            \/\/ Save GHASH context to allow the tag to be checked even though\n+            \/\/ the dst buffer is too short.  Context will be restored so the\n+            \/\/ method can be called again with the proper sized dst buffer.\n+            if (len > dst.remaining()) {\n+                save = ghashAllToS.clone();\n+            }\n@@ -1482,0 +1518,1 @@\n+            \/\/ Create buffer 'tag' that contains only the auth tag\n@@ -1486,4 +1523,0 @@\n-                len = ct.remaining();\n-                if (buffer != null) {\n-                    len += buffer.remaining();\n-                }\n@@ -1500,0 +1533,1 @@\n+                \/\/ Set the limit to where the ciphertext ends\n@@ -1503,2 +1537,0 @@\n-                \/\/ Limit is how much of the ibuffer has been chopped off.\n-                len = buffer.remaining();\n@@ -1509,11 +1541,0 @@\n-            \/\/ 'len' contains the length in ibuffer and src\n-            checkDataLength(len);\n-\n-            \/\/ Save GHASH context to allow the tag to be checked even though\n-            \/\/ the dst buffer is too short.  Context will be restored so the\n-            \/\/ method can be called again with the proper sized dst buffer.\n-            if (len > dst.remaining()) {\n-                save = ghashAllToS.clone();\n-            }\n-\n-            processAAD();\n@@ -1524,0 +1545,1 @@\n+            processAAD();\n@@ -1555,0 +1577,2 @@\n+            \/\/ Check for overlap in the bytebuffers\n+            dst = overlapDetection(src, dst);\n@@ -1557,1 +1581,0 @@\n-            \/\/decryptBlocks(buffer, ct, dst);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":93,"deletions":70,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-            \"com.sun.crypto.provider.DESedeWrapCipher\", null, attrs);\n+                \"com.sun.crypto.provider.DESedeWrapCipher\", null, attrs);\n@@ -264,1 +264,1 @@\n-            null, attrs);\n+                null, attrs);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -220,3 +220,0 @@\n-        store(\"AES\/GCM\", KnownOIDs.AES_128$GCM$NoPadding,\n-            \"AES\/GCM\/NoPadding\");\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}