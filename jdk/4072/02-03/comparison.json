{"files":[{"patch":"@@ -485,1 +485,2 @@\n-    private static byte[] getLengthBlock(int ivLenInBytes, byte[] out) {\n+    private static byte[] getLengthBlock(int ivLenInBytes) {\n+        byte[] out = new byte[16];\n@@ -490,2 +491,2 @@\n-    private static void getLengthBlock(int aLenInBytes, int cLenInBytes,\n-        byte[] out) {\n+    private static byte[] getLengthBlock(int aLenInBytes, int cLenInBytes) {\n+        byte[] out = new byte[16];\n@@ -494,0 +495,1 @@\n+        return out;\n@@ -527,1 +529,1 @@\n-            g.update(getLengthBlock(iv.length, new byte[blockSize]));\n+            g.update(getLengthBlock(iv.length));\n@@ -580,7 +582,0 @@\n-        }\n-\n-        \/**\n-         * Initialize GHASH and GCTR.  Encryption needs initialization right\n-         * away; however, decryption can wait until doFinal()\n-         *\/\n-        void initEngine() {\n@@ -621,2 +616,0 @@\n-        abstract int cryptBlocks(GCM op, ByteBuffer src, ByteBuffer dst);\n-\n@@ -723,1 +716,1 @@\n-            int len = 0;\n+            int resultLen = 0;\n@@ -726,5 +719,1 @@\n-                \/\/ If there is no src, just finish the rest of the buffer.\n-                if (src.remaining() == 0) {\n-                    return op.doFinal(buffer, dst);\n-                }\n-                \/\/ en\/decrypt on how much buffer there is in blockSize\n+                \/\/ en\/decrypt on how much buffer there is in AES_BLOCK_SIZE\n@@ -732,1 +721,1 @@\n-                    len += op.update(buffer, dst);\n+                    resultLen += op.update(buffer, dst);\n@@ -734,3 +723,3 @@\n-                \/\/ Process the remainder in the ibuffer with src data\n-                if (src.remaining() + buffer.remaining() >= blockSize) {\n-                    byte[] block = new byte[blockSize];\n+\n+                \/\/ Process the remainder in the buffer\n+                if (buffer.remaining() > 0) {\n@@ -738,0 +727,1 @@\n+                    byte[] block = new byte[blockSize];\n@@ -739,0 +729,1 @@\n+                    int len = over; \/\/ how much is processed by in the extra block\n@@ -740,10 +731,36 @@\n-                    src.get(block, over, blockSize - over);\n-                    len += op.update(ByteBuffer.wrap(block), dst);\n-                } else {\n-                    byte[] block =\n-                        new byte[src.remaining() + buffer.remaining()];\n-                    int over = buffer.remaining();\n-                    buffer.get(block, 0, over);\n-                    src.get(block, over, src.remaining());\n-                    len += op.doFinal(ByteBuffer.wrap(block), dst);\n-                    return len;\n+\n+                    \/\/ if src is empty, update the final block and wait for later\n+                    \/\/ to finalize operation\n+                    if (src.remaining() > 0) {\n+                        \/\/ Fill out block with what is in data\n+                        if (src.remaining() > blockSize - over) {\n+                            src.get(block, over, blockSize - over);\n+                            len = blockSize;\n+                        } else {\n+                            \/\/ If the remaining in buffer + data does not fill a\n+                            \/\/ block, complete the gctr operation\n+                            int l = src.remaining();\n+                            src.get(block, over, l);\n+                            len = l + over;\n+\n+                        }\n+                        resultLen += len;\n+                        if (len == blockSize) {\n+                            op.update(block, 0, blockSize, block, 0);\n+                            if (dst != null) {\n+                                dst.put(block, 0, blockSize);\n+                            }\n+                        } else {\n+                            op.doFinal(block, 0, len, block, 0);\n+                            if (dst != null) {\n+                                dst.put(block, 0, Math.min(block.length, len));\n+                            }\n+                            processed += resultLen;\n+                            return resultLen;\n+                        }\n+                    } else {\n+                        ByteBuffer b = ByteBuffer.wrap(block, 0,len);\n+                        resultLen += op.doFinal(b, dst);\n+                        processed += resultLen;\n+                        return resultLen;\n+                    }\n@@ -753,10 +770,4 @@\n-            \/*\n-             * At this point there are two scenarios.  Either there is\n-             * remaining data in the buffer that does not fill a block,\n-             * or there is only src data remaining of any length.\n-             *\n-             * doFinal must be called so it can reset the object.\n-             *\/\n-\n-            if (src.remaining() == 0) {\n-                return len;\n+            \/\/ en\/decrypt whatever remains in src.\n+            \/\/ If src has been consumed, this will be a no-op\n+            if (src.remaining() > TRIGGERLEN) {\n+                throttleData(op, src, dst);\n@@ -765,2 +776,3 @@\n-            len += cryptBlocks(op, src, dst);\n-            return len + op.doFinal(src, dst);\n+            resultLen += op.doFinal(src, dst);\n+            processed += resultLen;\n+            return resultLen;\n@@ -778,3 +790,0 @@\n-            if (inLen < TRIGGERLEN) {\n-                return 0;\n-            }\n@@ -783,1 +792,1 @@\n-            int len, resultLen = 0;\n+            int len = 0;\n@@ -786,5 +795,1 @@\n-                len = op.update(in, inOfs, segments, out, outOfs);\n-                outOfs += len;\n-                inOfs += len;\n-                inLen -= len;\n-                resultLen += len;\n+                len += op.update(in, inOfs + len, segments, out,outOfs + len);\n@@ -793,2 +798,2 @@\n-            resultLen += op.update(in, inOfs, inLen, out, outOfs);\n-            return resultLen;\n+            len += op.update(in, inOfs + len, inLen - len, out, outOfs + len);\n+            return len;\n@@ -949,1 +954,0 @@\n-            initEngine();\n@@ -1008,1 +1012,1 @@\n-                    len += cryptBlocks(buffer, 0, bLen, out, outOfs);\n+                    len += gctrghash.update(buffer, 0, bLen, out, outOfs);\n@@ -1023,1 +1027,1 @@\n-                    len += cryptBlocks(block, 0, blockSize, out, outOfs);\n+                    len += gctrghash.update(block, 0, blockSize, out, outOfs);\n@@ -1041,1 +1045,1 @@\n-                len += cryptBlocks(in, inOfs, inLen, out, outOfs);\n+                len += gctrghash.update(in, inOfs, inLen, out, outOfs);\n@@ -1054,0 +1058,1 @@\n+            processed += len;\n@@ -1146,1 +1151,1 @@\n-            int resultLen = inLen;\n+            int resultLen = 0;\n@@ -1154,3 +1159,0 @@\n-                \/\/ Add ibuffer to resulting length\n-                resultLen += bufLen;\n-\n@@ -1162,1 +1164,1 @@\n-                    outOfs += r;\n+                    resultLen += r;\n@@ -1171,2 +1173,3 @@\n-                    r = cryptBlocks(block, 0, blockSize, out, outOfs);\n-                    outOfs += r;\n+                    r = gctrghash.update(block, 0, blockSize, out,\n+                        outOfs + resultLen);\n+                    resultLen += r;\n@@ -1174,0 +1177,1 @@\n+                    processed += r;\n@@ -1189,2 +1193,3 @@\n-                if (inLen > blockSize) {\n-                    int r = cryptBlocks(in, inOfs, inLen, out, outOfs);\n+                if (inLen > TRIGGERLEN) {\n+                    int r = throttleData(gctrghash, in, inOfs, inLen, out,\n+                        outOfs + resultLen);\n@@ -1193,1 +1198,2 @@\n-                    outOfs += r;\n+                    resultLen += r;\n+                    processed += r;\n@@ -1195,1 +1201,3 @@\n-                doLastBlock(in, inOfs, inLen, out, outOfs);\n+\n+                doLastBlock(in, inOfs, inLen, out, outOfs + resultLen);\n+                resultLen += inLen;\n@@ -1198,2 +1206,1 @@\n-            block = new byte[blockSize];\n-            getLengthBlock(sizeOfAAD, processed, block);\n+            block = getLengthBlock(sizeOfAAD, processed);\n@@ -1206,1 +1213,1 @@\n-            System.arraycopy(block, 0, out, (outOfs + inLen), tagLenBytes);\n+            System.arraycopy(block, 0, out, resultLen + outOfs, tagLenBytes);\n@@ -1242,2 +1249,1 @@\n-            byte[] block = new byte[blockSize];\n-            getLengthBlock(sizeOfAAD, processed, block);\n+            byte[] block =  getLengthBlock(sizeOfAAD, processed);\n@@ -1256,1 +1262,2 @@\n-        void doLastBlock(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+        void doLastBlock(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) {\n@@ -1270,13 +1277,0 @@\n-        \/\/ Handler method for encrypting blocks\n-        int cryptBlocks(byte[] in, int inOfs, int inLen, byte[] out,\n-            int outOfs) {\n-            int len;\n-            if (inLen > TRIGGERLEN) {\n-                len = throttleData(gctrghash, in, inOfs, inLen, out, outOfs);\n-            } else {\n-                len = gctrghash.update(in, inOfs, inLen, out, outOfs);\n-            }\n-            processed += len;\n-            return len;\n-        }\n-\n@@ -1285,5 +1279,0 @@\n-            return cryptBlocks(gctrghash, src, dst);\n-        }\n-\n-        \/\/ Handler method for encrypting blocks\n-        int cryptBlocks(GCM ops, ByteBuffer src, ByteBuffer dst) {\n@@ -1312,1 +1301,0 @@\n-            initEngine();\n@@ -1323,0 +1311,24 @@\n+        \/**\n+         * Find the tag in a given input buffer\n+         *\n+         * If tagOfs > 0, the tag is inside 'in' along with encrypted data\n+         * If tagOfs = 0, 'in' contains only the tag\n+         * if tagOfs = blockSize, there is no data in 'in' and all the tag\n+         *   is in ibuffer\n+         * If tagOfs < 0, that tag is split between ibuffer and 'in'\n+         *\/\n+        void findTag(byte[] in, int inOfs, int inLen) {\n+            tag = new byte[tagLenBytes];\n+            if (inLen >= tagLenBytes) {\n+                tagOfs = inLen - tagLenBytes;\n+                System.arraycopy(in, inOfs + tagOfs, tag, 0,\n+                    tagLenBytes);\n+            } else {\n+                \/\/ tagOfs will be negative\n+                byte[] buffer = ibuffer.toByteArray();\n+                tagOfs = mergeBlock(buffer,\n+                    buffer.length - (tagLenBytes - inLen), in, inOfs, inLen,\n+                    tag) - tagLenBytes;\n+            }\n+        }\n+\n@@ -1357,0 +1369,1 @@\n+            processAAD();\n@@ -1403,3 +1416,2 @@\n-            byte[] block = new byte[blockSize];\n-            getLengthBlock(sizeOfAAD,\n-                decryptBlocks(ghashAllToS, in, inOfs, inLen, null, 0), block);\n+            byte[] block = getLengthBlock(sizeOfAAD,\n+                decryptBlocks(ghashAllToS, in, inOfs, inLen, null, 0));\n@@ -1513,1 +1525,1 @@\n-            doLastBlock(ghashAllToS, buffer, ct, dst);\n+            doLastBlock(ghashAllToS, buffer, ct, null);\n@@ -1515,2 +1527,1 @@\n-            byte[] block = new byte[blockSize];\n-            getLengthBlock(sizeOfAAD, len, block);\n+            byte[] block = getLengthBlock(sizeOfAAD, len);\n@@ -1543,0 +1554,1 @@\n+            processed = 0;\n@@ -1545,1 +1557,2 @@\n-            processed = doLastBlock(gctrPAndC, buffer, ct, dst);\n+            \/\/decryptBlocks(buffer, ct, dst);\n+            doLastBlock(gctrPAndC, buffer, ct, dst);\n@@ -1555,24 +1568,0 @@\n-        \/**\n-         * Find the tag in a given input buffer\n-         *\n-         * If tagOfs > 0, the tag is inside 'in' along with encrypted data\n-         * If tagOfs = 0, 'in' contains only the tag\n-         * if tagOfs = blockSize, there is no data in 'in' and all the tag\n-         *   is in ibuffer\n-         * If tagOfs < 0, that tag is split between ibuffer and 'in'\n-         *\/\n-        void findTag(byte[] in, int inOfs, int inLen) {\n-            tag = new byte[tagLenBytes];\n-            if (inLen >= tagLenBytes) {\n-                tagOfs = inLen - tagLenBytes;\n-                System.arraycopy(in, inOfs + tagOfs, tag, 0,\n-                    tagLenBytes);\n-            } else {\n-                \/\/ tagOfs will be negative\n-                byte[] buffer = ibuffer.toByteArray();\n-                tagOfs = mergeBlock(buffer,\n-                    buffer.length - (tagLenBytes - inLen), in, inOfs, inLen,\n-                    tag) - tagLenBytes;\n-            }\n-        }\n-\n@@ -1587,3 +1576,2 @@\n-            byte[] buffer = null;\n-            byte[] block = null;\n-            int resultLen = 0;\n+            byte[] buffer;\n+            byte[] block;\n@@ -1604,14 +1592,1 @@\n-            \/\/ If there is no buffered data, only process the 'in'\n-            if (ctBufLen == 0) {\n-                int l = throttleData(op, in, inOfs, inLen, out, outOfs);\n-                if (l > 0) {\n-                    inOfs += l;\n-                    inLen -= l;\n-                    outOfs += l; \/\/ noop for ghash\n-                    len += l;\n-                }\n-\n-                return len + op.doFinal(in, inOfs, inLen, out, outOfs);\n-            }\n-\n-            if (bLen > 0) {\n+            if (ctBufLen > 0) {\n@@ -1619,1 +1594,0 @@\n-            }\n@@ -1621,8 +1595,6 @@\n-            \/\/ If ibuffer has at least a block size worth of data, decrypt it\n-            if (ctBufLen >= blockSize) {\n-                resultLen = op.update(buffer, 0, ctBufLen, out, outOfs);\n-                outOfs += resultLen; \/\/ noop for ghash\n-                len += resultLen;\n-                \/\/ Preserve resultLen, as it becomes the ibuffer offset, if\n-                \/\/ needed, in the next op\n-            }\n+                if (ctBufLen >= blockSize) {\n+                    len += op.update(buffer, 0, ctBufLen, out, outOfs);\n+                    outOfs += len; \/\/ noop for ghash\n+                    \/\/ Use len as it becomes the ibuffer offset, if\n+                    \/\/ needed, in the next op\n+                }\n@@ -1630,21 +1602,22 @@\n-            \/\/ merge the remaining ibuffer with the 'in'\n-            int bufRemainder = ctBufLen - resultLen;\n-\n-            if (bufRemainder > 0) {\n-                block = new byte[blockSize];\n-                int inUsed = mergeBlock(buffer, resultLen, bufRemainder, in,\n-                    inOfs, inLen, block);\n-                \/\/ update the input parameters for what was taken out of 'in'\n-                inOfs += inUsed;\n-                inLen -= inUsed;\n-                if ((bufRemainder + inUsed <= blockSize) && inLen == 0) {\n-                    \/\/ If there is no more data in the inLen, send this to\n-                    \/\/ doFinal below\n-                    in = block;\n-                    inOfs = 0;\n-                    inLen = bufRemainder + inUsed;\n-                } else {\n-                    \/\/ Do an update for the merged block and doFinal on the\n-                    \/\/ remainder in 'in'\n-                    len += op.update(block, 0, blockSize, out, outOfs);\n-                    outOfs += blockSize; \/\/ noop for ghash\n+                \/\/ merge the remaining ibuffer with the 'in'\n+                int bufRemainder = ctBufLen - len;\n+                if (bufRemainder > 0) {\n+                    block = new byte[blockSize];\n+                    int inUsed = mergeBlock(buffer, len, bufRemainder, in,\n+                        inOfs, inLen, block);\n+                    \/\/ update the input parameters for what was taken out of 'in'\n+                    inOfs += inUsed;\n+                    inLen -= inUsed;\n+                    \/\/ If is more than block between the merged data and 'in',\n+                    \/\/ update(), otherwise setup for final\n+                    if (inLen > 0) {\n+                        int resultLen;\n+                        resultLen = op.update(block, 0, blockSize,\n+                            out, outOfs);\n+                        outOfs += resultLen; \/\/ noop for ghash\n+                        len += resultLen;\n+                    } else {\n+                        in = block;\n+                        inOfs = 0;\n+                        inLen = inUsed + bufRemainder;\n+                    }\n@@ -1654,2 +1627,3 @@\n-            int l = throttleData(op, in, inOfs, inLen, out, outOfs);\n-            if (l > 0) {\n+            \/\/ Finish off the operation\n+            if (inLen > TRIGGERLEN) {\n+                int l = throttleData(op, in, inOfs, inLen, out, outOfs);\n@@ -1661,2 +1635,0 @@\n-\n-            \/\/ Finish off the operation\n@@ -1665,10 +1637,0 @@\n-\n-        @Override\n-        \/\/ Handler method for encrypting blocks\n-        int cryptBlocks(GCM op, ByteBuffer src, ByteBuffer dst) {\n-            if (src.remaining() > TRIGGERLEN) {\n-                return throttleData(op, src, dst);\n-            }\n-            return op.update(src, dst);\n-        }\n-\n@@ -1742,1 +1704,3 @@\n-            return 0;\n+            int len = gctr.doFinal(in, inOfs, inLen, out, outOfs);\n+            ghash.doFinal(out, outOfs, len);\n+            return len;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":153,"deletions":189,"binary":false,"changes":342,"status":"modified"}]}