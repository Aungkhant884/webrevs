{"files":[{"patch":"@@ -141,16 +141,1 @@\n-\/*    public static final class AES128_GCM_NoPadding extends GaloisCounterMode {\n-        public AES128_GCM_NoPadding() {\n-            super(16, new AESCrypt());\n-        }\n-    }\n-    public static final class AES192_GCM_NoPadding extends GaloisCounterMode {\n-        public AES192_GCM_NoPadding() {\n-            super(24, new AESCrypt());\n-        }\n-    }\n-    public static final class AES256_GCM_NoPadding extends GaloisCounterMode {\n-        public AES256_GCM_NoPadding() {\n-            super(32, new AESCrypt());\n-        }\n-    }\n-*\/\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCipher.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    private static final int TRIGGERLEN = 65536;  \/\/ 64k\n+    private static final int TRIGGERLEN = 4096;  \/\/ 64k\n@@ -96,1 +96,1 @@\n-    int tagLenBytes = 16;\n+    int tagLenBytes = DEFAULT_TAG_LEN;\n@@ -217,1 +217,1 @@\n-     * @param random a {@code SecureRandom} object.  If {@code null} is\n+     * @param rand a {@code SecureRandom} object.  If {@code null} is\n@@ -222,1 +222,1 @@\n-    private static byte[] createIv(SecureRandom random) {\n+    private static byte[] createIv(SecureRandom rand) {\n@@ -224,2 +224,2 @@\n-        if (random == null) {\n-            random = JCAUtil.getDefSecureRandom();\n+        if (rand == null) {\n+            rand = JCAUtil.getDefSecureRandom();\n@@ -227,1 +227,1 @@\n-        random.nextBytes(iv);\n+        rand.nextBytes(iv);\n@@ -268,0 +268,1 @@\n+        this.random = random;\n@@ -330,0 +331,1 @@\n+        ArrayUtil.nullAndBoundsCheck(input, inputOffset, inputLen);\n@@ -337,0 +339,3 @@\n+        ArrayUtil.nullAndBoundsCheck(input, inputOffset, inputLen);\n+        ArrayUtil.nullAndBoundsCheck(output, outputOffset,\n+                output.length - outputOffset);\n@@ -744,1 +749,1 @@\n-            int bLen = getBufferedLength();\n+            int bLen = (buffer != null ? buffer.remaining() : 0);\n@@ -752,2 +757,2 @@\n-                if (bLen > 0) {\n-                    \/\/ Copy the remainder of the buffer into the extra block\n+                if (bLen - resultLen > 0) {\n+                    \/\/ Copy the buffer remainder into an extra block\n@@ -756,1 +761,0 @@\n-                    int len = over; \/\/ how much is processed by in the extra block\n@@ -759,29 +763,8 @@\n-                    \/\/ if src is empty, update the final block and wait for later\n-                    \/\/ to finalize operation\n-                    if (src.remaining() > 0) {\n-                        \/\/ Fill out block with what is in data\n-                        if (src.remaining() > blockSize - over) {\n-                            src.get(block, over, blockSize - over);\n-                            len = blockSize;\n-                        } else {\n-                            \/\/ If the remaining in buffer + data does not fill a\n-                            \/\/ block, complete the gctr operation\n-                            int l = src.remaining();\n-                            src.get(block, over, l);\n-                            len = l + over;\n-\n-                        }\n-                        resultLen += len;\n-                        if (len == blockSize) {\n-                            op.update(block, 0, blockSize, block, 0);\n-                            if (dst != null) {\n-                                dst.put(block, 0, blockSize);\n-                            }\n-                        } else {\n-                            op.doFinal(block, 0, len, block, 0);\n-                            if (dst != null) {\n-                                dst.put(block, 0, Math.min(block.length, len));\n-                            }\n-                            processed += resultLen;\n-                            return resultLen;\n-                        }\n+                    \/\/ If src has data, complete the block;\n+                    int slen = Math.min(src.remaining(), blockSize - over);\n+                    if (slen > 0) {\n+                        src.get(block, over, slen);\n+                    }\n+                    int len = slen + over;\n+                    if (len == blockSize) {\n+                        resultLen += op.update(block, 0, blockSize, dst);\n@@ -789,2 +772,5 @@\n-                        ByteBuffer b = ByteBuffer.wrap(block, 0,len);\n-                        resultLen += op.doFinal(b, dst);\n+                        resultLen += op.doFinal(block, 0, len, block,\n+                                0);\n+                        if (dst != null) {\n+                            dst.put(block, 0, len);\n+                        }\n@@ -800,1 +786,1 @@\n-                throttleData(op, src, dst);\n+                resultLen += throttleData(op, src, dst);\n@@ -811,1 +797,1 @@\n-         * using CTR and GHASH intrinsics sooner.  This is a problem for app\n+         * using GCTR and GHASH intrinsics sooner.  This is a problem for app\n@@ -832,1 +818,1 @@\n-         * using CTR and GHASH intrinsics sooner.  This is a problem for app\n+         * using GCTR and GHASH intrinsics sooner.  This is a problem for app\n@@ -933,3 +919,2 @@\n-         * If an intermediate array is needed, the whole original out array\n-         * length is allocated because it's simpler than keep the same offset\n-         * and hope the expected output is\n+         * If an intermediate array is needed, the original out array length is\n+         * allocated because for code simplicity.\n@@ -1002,1 +987,2 @@\n-                \/\/ update decryption has no output\n+                \/\/ This should never happen because we just allocated output\n+                throw new ProviderException(\"output buffer creation failed\", e);\n@@ -1017,2 +1003,0 @@\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n-            ArrayUtil.nullAndBoundsCheck(out, outOfs, out.length - outOfs);\n@@ -1033,12 +1017,1 @@\n-                int remainder = bLen % blockSize;\n-                \/\/ number of bytes along block boundary\n-                bLen -= remainder;\n-\n-                \/\/ If there is enough bytes in ibuffer for a block or more,\n-                \/\/ encrypt that first.\n-                if (bLen > 0) {\n-                    len += gctrghash.update(buffer, 0, bLen, out, outOfs);\n-                    outOfs += bLen;\n-                }\n-\n-                \/\/ bLen is now the offset for 'buffer'\n+                int remainder = blockSize - bLen;\n@@ -1048,1 +1021,1 @@\n-                if ((inLen + remainder) >= blockSize) {\n+                if ((inLen + bLen) >= blockSize) {\n@@ -1051,3 +1024,2 @@\n-                    System.arraycopy(buffer, bLen, block, 0, remainder);\n-                    int inLenUsed = blockSize - remainder;\n-                    System.arraycopy(in, inOfs, block, remainder, inLenUsed);\n+                    System.arraycopy(buffer, 0, block, 0, bLen);\n+                    System.arraycopy(in, inOfs, block, bLen, remainder);\n@@ -1055,3 +1027,3 @@\n-                    len += gctrghash.update(block, 0, blockSize, out, outOfs);\n-                    inOfs += inLenUsed;\n-                    inLen -= inLenUsed;\n+                    len = gctrghash.update(block, 0, blockSize, out, outOfs);\n+                    inOfs += remainder;\n+                    inLen -= remainder;\n@@ -1060,8 +1032,0 @@\n-                    \/\/ Code below will write the remainder from 'in' to ibuffer\n-                } else if (remainder > 0) {\n-                    \/\/ If a block or more was encrypted from 'buffer' only, but\n-                    \/\/ the rest of 'buffer' with 'in' could not construct a\n-                    \/\/  block, then put the rest of 'buffer' back into ibuffer.\n-                    ibuffer.reset();\n-                    ibuffer.write(buffer, bLen, remainder);\n-                    \/\/ Code below will write the remainder from 'in' to ibuffer\n@@ -1072,1 +1036,1 @@\n-            if (inLen > 0) {\n+            if (inLen >= blockSize) {\n@@ -1110,1 +1074,0 @@\n-                ByteBuffer buffer = ByteBuffer.wrap(ibuffer.toByteArray());\n@@ -1112,19 +1075,8 @@\n-                int remainder = bLen % blockSize;\n-\n-                \/\/ If there is enough bytes in ibuffer for a block or more,\n-                \/\/ en\/decrypt that first.\n-                if (ibuffer.size() - remainder > 0) {\n-                    len += cryptBlocks(buffer, dst);\n-                }\n-\n-                \/\/ Check if there is any data left in the buffer, if there is,\n-                \/\/ try to construct a block with data from the buffer and src\n-                \/\/ to en\/decrypt.\n-                if (buffer.remaining() == 0) {\n-                    ibuffer.reset();\n-                } else {\n-                    if ((buffer.remaining() + src.remaining()) >= blockSize) {\n-                        byte[] block = new byte[blockSize];\n-                        buffer.get(block, 0, remainder);\n-                        src.get(block, remainder, blockSize - remainder);\n-                        len += cryptBlocks(\n+                int remainder = blockSize - bLen;\n+                \/\/ Check if there is enough 'src' and 'buffer' to fill a block\n+                if (src.remaining() >= remainder) {\n+                    byte[] block = new byte[blockSize];\n+                    ByteBuffer buffer = ByteBuffer.wrap(ibuffer.toByteArray());\n+                    buffer.get(block, 0, bLen);\n+                    src.get(block, bLen, remainder);\n+                    len += cryptBlocks(\n@@ -1132,2 +1084,1 @@\n-                        ibuffer.reset();\n-                    }\n+                    ibuffer.reset();\n@@ -1183,1 +1134,0 @@\n-                int r, bufOfs = 0;\n@@ -1186,8 +1136,0 @@\n-                \/\/ If more than one block is in ibuffer, call doUpdate()\n-                if (bLen >= blockSize) {\n-                    r = gctrghash.update(buffer, 0, bLen, out, outOfs);\n-                    bLen -= r;\n-                    inOfs += r;\n-                    resultLen += r;\n-                    bufOfs += r;\n-                }\n@@ -1195,1 +1137,2 @@\n-                if (bLen > 0 && inLen > 0 && bLen + inLen >= blockSize) {\n+                if (bLen + inLen >= blockSize) {\n+                    int r, bufOfs = 0;\n@@ -1201,1 +1144,2 @@\n-                        outOfs + resultLen);\n+                        outOfs);\n+                    outOfs += r;\n@@ -1203,1 +1147,0 @@\n-                    bLen = 0;\n@@ -1205,4 +1148,2 @@\n-                }\n-\n-                \/\/ Need to consume all the ibuffer here to prepare for doFinal()\n-                if (bLen > 0) {\n+                } else {\n+                    \/\/ Need to consume all the ibuffer here to prepare for doFinal()\n@@ -1220,2 +1161,1 @@\n-                int r = throttleData(gctrghash, in, inOfs, inLen, out,\n-                    outOfs + resultLen);\n+                int r = throttleData(gctrghash, in, inOfs, inLen, out, outOfs);\n@@ -1224,0 +1164,1 @@\n+                outOfs += r;\n@@ -1228,2 +1169,2 @@\n-            processed += gctrghash.doFinal(in, inOfs, inLen, out,\n-                outOfs + resultLen);\n+            processed += gctrghash.doFinal(in, inOfs, inLen, out, outOfs);\n+            outOfs += inLen;\n@@ -1239,1 +1180,1 @@\n-            System.arraycopy(block, 0, out, resultLen + outOfs, tagLenBytes);\n+            System.arraycopy(block, 0, out, outOfs, tagLenBytes);\n@@ -1325,1 +1266,1 @@\n-         * If tagOfs > 0, the tag is inside 'in' along with encrypted data\n+         * If tagOfs > 0, the tag is inside 'in' along with some encrypted data\n@@ -1327,2 +1268,0 @@\n-         * if tagOfs = blockSize, there is no data in 'in' and all the tag\n-         *   is in ibuffer\n@@ -1330,0 +1269,1 @@\n+         * If tagOfs = -tagLenBytes, the tag is in the ibuffer, 'in' is empty.\n@@ -1367,1 +1307,0 @@\n-                ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n@@ -1414,0 +1353,6 @@\n+            try {\n+                ArrayUtil.nullAndBoundsCheck(out, outOfs, len - tagLenBytes);\n+            } catch (ArrayIndexOutOfBoundsException aiobe) {\n+                throw new ShortBufferException(\"Output buffer invalid\");\n+            }\n+\n@@ -1443,6 +1388,0 @@\n-            try {\n-                ArrayUtil.nullAndBoundsCheck(out, outOfs, len - tagLenBytes);\n-            } catch (ArrayIndexOutOfBoundsException aiobe) {\n-                throw new ShortBufferException(\"Output buffer invalid\");\n-            }\n-\n@@ -1450,0 +1389,1 @@\n+                ghashAllToS = save;\n@@ -1470,12 +1410,0 @@\n-            \/\/ If these are array backed ByteBuffers, use the underlying array\n-            if (src.hasArray() && dst.hasArray()) {\n-                int len = doFinal(src.array(),\n-                    src.arrayOffset() + src.position(),\n-                    src.remaining(), dst.array(),\n-                    dst.arrayOffset() + dst.position());\n-                src.position(src.limit());\n-                dst.position(dst.position() + len);\n-                return len;\n-            }\n-\n-            \/\/ Length of the input\n@@ -1573,1 +1501,0 @@\n-            engine = null;\n@@ -1623,2 +1550,1 @@\n-                        int resultLen;\n-                        resultLen = op.update(block, 0, blockSize,\n+                        int resultLen = op.update(block, 0, blockSize,\n@@ -1673,1 +1599,1 @@\n-     * This class is for encryption operations when both GCTR and GHASH\n+     * This class is for encryption when both GCTR and GHASH\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":74,"deletions":148,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Arrays;\n@@ -31,1 +30,0 @@\n-import java.util.Random;\n@@ -35,1 +33,0 @@\n-import javax.crypto.KeyGenerator;\n@@ -67,2 +64,0 @@\n-        plainText = makeData(plainText.length);\n-        key = makeData(KEY_LENGTH);\n@@ -83,9 +78,0 @@\n-    static byte[] makeData(int len) {\n-        int i = 0;\n-        byte[] b = new byte[len];\n-        while (i < len) {\n-            b[i] = (byte)(i % 255);\n-            i++;\n-        }\n-        return b;\n-    }\n@@ -97,1 +83,1 @@\n-        byte[] iv = makeData(16);\n+        byte[] iv = new byte[16];\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestAESCipher.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"}]}