{"files":[{"patch":"@@ -2,1 +2,2 @@\n-# Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n@@ -31,1 +32,0 @@\n-RENDERPERFLCD_CLASSES = $(CLASSES)\/renderperf\/RenderPerfLCDTest.class\n@@ -33,1 +33,0 @@\n-RENDERPERFLCD_SOURCES = $(SOURCEPATH)\/renderperf\/RenderPerfLCDTest.java\n@@ -37,1 +36,1 @@\n-all: mkdirs $(DIST)\/RenderPerfTest.jar $(DIST)\/RenderPerfLCDTest.jar\n+all: mkdirs $(DIST)\/RenderPerfTest.jar\n@@ -47,5 +46,0 @@\n-$(DIST)\/RenderPerfLCDTest.jar: \\\n-\t$(RENDERPERFLCD_CLASSES) $(RENDERPERFLCD_RESOURCES) \\\n-\t$(CLASSES)\/renderperflcd.manifest\n-\tjar cvmf $(CLASSES)\/renderperflcd.manifest $(DIST)\/RenderPerfLCDTest.jar -C $(CLASSES) .\n-\n@@ -59,3 +53,0 @@\n-$(CLASSES)\/renderperflcd.manifest:\n-\techo \"Main-Class: renderperf.RenderPerfLCDTest\" > $@\n-\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/Makefile","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/build.xml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,373 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package renderperf;\n-\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Frame;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.RenderingHints;\n-import java.awt.Robot;\n-\n-import java.awt.event.WindowAdapter;\n-import java.awt.event.WindowEvent;\n-import java.awt.geom.AffineTransform;\n-import java.awt.geom.Point2D;\n-import java.awt.geom.QuadCurve2D;\n-import java.awt.image.BufferedImage;\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import javax.imageio.ImageIO;\n-import javax.swing.JPanel;\n-import javax.swing.SwingUtilities;\n-import javax.swing.Timer;\n-\n-public class RenderPerfLCDTest {\n-    private static HashSet<String> ignoredTests = new HashSet<>();\n-\n-    private final static int N = 1000;\n-    private final static float WIDTH = 800;\n-    private final static float HEIGHT = 800;\n-    private final static float R = 25;\n-    private final static int BW = 50;\n-    private final static int BH = 50;\n-    private final static int COUNT = 300;\n-    private final static int DELAY = 10;\n-    private final static int RESOLUTION = 5;\n-    private final static int COLOR_TOLERANCE = 10;\n-    private final static int MAX_MEASURE_TIME = 5000;\n-\n-\n-    interface Configurable {\n-        void configure(Graphics2D g2d);\n-    }\n-\n-    interface Renderable {\n-        void setup(Graphics2D g2d);\n-        void render(Graphics2D g2d);\n-        void update();\n-    }\n-\n-    static class Particles {\n-        private float[] bx;\n-        private float[] by;\n-        private float[] vx;\n-        private float[] vy;\n-        private float r;\n-        private int n;\n-\n-        private float x0;\n-        private float y0;\n-        private float width;\n-        private float height;\n-\n-        Particles(int n, float r, float x0, float y0, float width, float height) {\n-            bx = new float[n];\n-            by = new float[n];\n-            vx = new float[n];\n-            vy = new float[n];\n-            this.n = n;\n-            this.r = r;\n-            this.x0 = x0;\n-            this.y0 = y0;\n-            this.width = width;\n-            this.height = height;\n-            for (int i = 0; i < n; i++) {\n-                bx[i] = (float) (x0 + r + 0.1 + Math.random() * (width - 2 * r - 0.2 - x0));\n-                by[i] = (float) (y0 + r + 0.1 + Math.random() * (height - 2 * r - 0.2 - y0));\n-                vx[i] = 0.1f * (float) (Math.random() * 2 * r - r);\n-                vy[i] = 0.1f * (float) (Math.random() * 2 * r - r);\n-            }\n-\n-        }\n-\n-        void render(Graphics2D g2d, ParticleRenderer renderer) {\n-            for (int i = 0; i < n; i++) {\n-                renderer.render(g2d, i, bx, by, vx, vy);\n-            }\n-        }\n-\n-        void update() {\n-            for (int i = 0; i < n; i++) {\n-                bx[i] += vx[i];\n-                if (bx[i] + r > width || bx[i] - r < x0) vx[i] = -vx[i];\n-                by[i] += vy[i];\n-                if (by[i] + r > height || by[i] - r < y0) vy[i] = -vy[i];\n-            }\n-\n-        }\n-\n-    }\n-\n-    ParticleRenderable createPR(ParticleRenderer renderer) {\n-        return new ParticleRenderable(renderer);\n-    }\n-\n-    static class ParticleRenderable implements Renderable {\n-        ParticleRenderer renderer;\n-        Configurable configure;\n-\n-        ParticleRenderable(ParticleRenderer renderer, Configurable configure) {\n-            this.renderer = renderer;\n-            this.configure = configure;\n-        }\n-\n-        ParticleRenderable(ParticleRenderer renderer) {\n-            this(renderer, null);\n-        }\n-\n-        @Override\n-        public void setup(Graphics2D g2d) {\n-            if (configure != null) configure.configure(g2d);\n-        }\n-\n-        @Override\n-        public void render(Graphics2D g2d) {\n-            balls.render(g2d, renderer);\n-        }\n-\n-        @Override\n-        public void update() {\n-            balls.update();\n-        }\n-\n-        public ParticleRenderable configure(Configurable configure) {\n-            this.configure = configure;\n-            return this;\n-        }\n-    }\n-\n-    interface ParticleRenderer {\n-        void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy);\n-\n-    }\n-\n-    static class WhiteTextParticleRenderer implements ParticleRenderer {\n-        float r;\n-\n-        WhiteTextParticleRenderer(float r) {\n-            this.r = r;\n-        }\n-\n-        void setPaint(Graphics2D g2d, int id) {\n-            g2d.setColor(Color.WHITE);\n-        }\n-\n-        @Override\n-        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n-            setPaint(g2d, id);\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] - r));\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)y[id]);\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] + r));\n-        }\n-    }\n-\n-    static class TextParticleRenderer extends WhiteTextParticleRenderer {\n-        Color[] colors;\n-\n-        float r;\n-\n-        TextParticleRenderer(int n, float r) {\n-            super(r);\n-            colors = new Color[n];\n-            this.r = r;\n-            for (int i = 0; i < n; i++) {\n-                colors[i] = new Color((float) Math.random(),\n-                        (float) Math.random(), (float) Math.random());\n-            }\n-        }\n-\n-        void setPaint(Graphics2D g2d, int id) {\n-            g2d.setColor(colors[id % colors.length]);\n-        }\n-    }\n-\n-    static class PerfMeter {\n-        private String name;\n-        private int frame = 0;\n-\n-        private JPanel panel;\n-\n-        private long time;\n-        private double execTime = 0;\n-        private Color expColor = Color.RED;\n-        AtomicBoolean waiting = new AtomicBoolean(false);\n-        private double fps;\n-\n-        PerfMeter(String name) {\n-            this.name = name;\n-        }\n-\n-        PerfMeter exec(final Renderable renderable) throws Exception {\n-            final CountDownLatch latch = new CountDownLatch(COUNT);\n-            final CountDownLatch latchFrame = new CountDownLatch(1);\n-            final long endTime = System.currentTimeMillis() + MAX_MEASURE_TIME;\n-\n-            final Frame f = new Frame();\n-            f.addWindowListener(new WindowAdapter() {\n-                @Override\n-                public void windowClosed(WindowEvent e) {\n-                    latchFrame.countDown();\n-                }\n-            });\n-\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-                @Override\n-                public void run() {\n-\n-                    panel = new JPanel()\n-                    {\n-                        @Override\n-                        protected void paintComponent(Graphics g) {\n-\n-                            super.paintComponent(g);\n-                            time = System.nanoTime();\n-                            Graphics2D g2d = (Graphics2D) g.create();\n-                            renderable.setup(g2d);\n-                            renderable.render(g2d);\n-                            g2d.setColor(expColor);\n-                            g.fillRect(0, 0, BW, BH);\n-                        }\n-                    };\n-\n-                    panel.setPreferredSize(new Dimension((int)(WIDTH + BW), (int)(HEIGHT + BH)));\n-                    panel.setBackground(Color.BLACK);\n-                    f.add(panel);\n-                    \/\/f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n-                    f.pack();\n-                    f.setVisible(true);\n-                }\n-            });\n-            Robot robot = new Robot();\n-\n-            Timer timer = new Timer(DELAY, e -> {\n-\n-                if (waiting.compareAndSet(false, true)) {\n-                    Color c = robot.getPixelColor(\n-                            panel.getTopLevelAncestor().getX() + panel.getTopLevelAncestor().getInsets().left + BW \/ 2,\n-                            panel.getTopLevelAncestor().getY() + panel.getTopLevelAncestor().getInsets().top + BW \/ 2);\n-                    if (isAlmostEqual(c, Color.BLUE)) {\n-                        expColor = Color.RED;\n-                    } else {\n-                        expColor = Color.BLUE;\n-                    }\n-                    renderable.update();\n-                    panel.getParent().repaint();\n-\n-                } else {\n-                    while (!isAlmostEqual(\n-                            robot.getPixelColor(\n-                                    panel.getTopLevelAncestor().getX() + panel.getTopLevelAncestor().getInsets().left + BW\/2,\n-                                    panel.getTopLevelAncestor().getY() + panel.getTopLevelAncestor().getInsets().top + BH\/2),\n-                            expColor))\n-                    {\n-                        try {\n-                            Thread.sleep(RESOLUTION);\n-                        } catch (InterruptedException ex) {\n-                            ex.printStackTrace();\n-                        }\n-                    }\n-                    time = System.nanoTime() - time;\n-                    execTime += time;\n-                    frame++;\n-                    waiting.set(false);\n-                }\n-\n-                if (System.currentTimeMillis() < endTime) {\n-                    latch.countDown();\n-                } else {\n-                    while(latch.getCount() > 0) latch.countDown();\n-                }\n-            });\n-            timer.start();\n-            latch.await();\n-            SwingUtilities.invokeAndWait(() -> {\n-                timer.stop();\n-                f.setVisible(false);\n-                f.dispose();\n-            });\n-\n-            latchFrame.await();\n-            if (execTime != 0 && frame != 0) {\n-                fps = 1e9 \/ (execTime \/ frame);\n-            } else {\n-                fps = 0;\n-            }\n-\n-            return this;\n-        }\n-\n-        private void report() {\n-            System.err.println(name + \" : \" + String.format(\"%.2f FPS\", fps));\n-        }\n-\n-        private boolean isAlmostEqual(Color c1, Color c2) {\n-            return Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE ||\n-                    Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE ||\n-                    Math.abs(c1.getBlue() - c2.getBlue()) < COLOR_TOLERANCE;\n-\n-        }\n-    }\n-\n-    private static final Particles balls = new Particles(N, R, BW, BH, WIDTH, HEIGHT);\n-    private static final ParticleRenderer textRenderer = new TextParticleRenderer(N, R);\n-\n-    private static final Configurable TextLCD = (Graphics2D g2d) ->\n-        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n-                RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);\n-\n-    public void testTextBubblesLCD() throws Exception {\n-        (new PerfMeter(\"TextLCD\")).exec(createPR(textRenderer).configure(TextLCD)).report();\n-    }\n-\n-    public static void main(String[] args)\n-            throws InvocationTargetException, IllegalAccessException, NoSuchMethodException\n-    {\n-        RenderPerfLCDTest test = new RenderPerfLCDTest();\n-\n-        if (args.length > 0) {\n-            for (String testCase : args) {\n-                Method m = RenderPerfLCDTest.class.getDeclaredMethod(testCase);\n-                m.invoke(test);\n-            }\n-        } else {\n-            Method[] methods = RenderPerfLCDTest.class.getDeclaredMethods();\n-            for (Method m : methods) {\n-                if (m.getName().startsWith(\"test\") && !ignoredTests.contains(m.getName())) {\n-                    m.invoke(test);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/src\/renderperf\/RenderPerfLCDTest.java","additions":0,"deletions":373,"binary":false,"changes":373,"status":"deleted"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n@@ -57,1 +58,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -59,0 +59,2 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -63,1 +65,0 @@\n-import javax.swing.Timer;\n@@ -70,1 +71,2 @@\n-        ignoredTests.add(\"testWiredBoxAA\");\n+       \/\/ add ignored tests here\n+       \/\/ ignoredTests.add(\"testMyIgnoredTest\");\n@@ -79,3 +81,4 @@\n-    private final static int COUNT = 300;\n-    private final static int DELAY = 10;\n-    private final static int RESOLUTION = 5;\n+    private final static int COUNT = 600;\n+    private final static int CYCLE_DELAY = 3;\n+    private final static int MAX_FRAME_CYCLES = 3000\/CYCLE_DELAY;\n+\n@@ -83,1 +86,1 @@\n-    private final static int MAX_MEASURE_TIME = 5000;\n+    private final static int MAX_MEASURE_CYCLES = 6000\/CYCLE_DELAY;\n@@ -85,0 +88,1 @@\n+    private final static Color[] marker = {Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, Color.ORANGE, Color.MAGENTA};\n@@ -279,0 +283,1 @@\n+            if (id % 100 != 0) return;\n@@ -602,1 +607,1 @@\n-        private int frame = 0;\n+\n@@ -606,1 +611,0 @@\n-        private long time;\n@@ -608,2 +612,4 @@\n-        private Color expColor = Color.RED;\n-        AtomicBoolean waiting = new AtomicBoolean(false);\n+        private AtomicInteger markerIdx = new AtomicInteger(0);\n+        private int renderedMarkerIdx = -1;\n+        private AtomicLong markerPaintTime = new AtomicLong(0);\n+\n@@ -611,0 +617,1 @@\n+        private int skippedFrame = 0;\n@@ -617,1 +624,0 @@\n-            final CountDownLatch latch = new CountDownLatch(COUNT);\n@@ -619,1 +625,0 @@\n-            final long endTime = System.currentTimeMillis() + MAX_MEASURE_TIME;\n@@ -633,2 +638,1 @@\n-                    panel = new JPanel()\n-                    {\n+                    panel = new JPanel() {\n@@ -637,1 +641,0 @@\n-\n@@ -639,1 +642,5 @@\n-                            time = System.nanoTime();\n+                            int idx = markerIdx.get();\n+                            if (idx != renderedMarkerIdx) {\n+                                markerPaintTime.set(System.nanoTime());\n+                            }\n+\n@@ -643,2 +650,5 @@\n-                            g2d.setColor(expColor);\n-                            g.fillRect(0, 0, BW, BH);\n+                            g2d.setClip(null);\n+                            g2d.setPaintMode();\n+                            g2d.setColor(marker[idx]);\n+                            g2d.fillRect(0, 0, BW, BH);\n+                            renderedMarkerIdx = idx;\n@@ -648,1 +658,1 @@\n-                    panel.setPreferredSize(new Dimension((int)(WIDTH + BW), (int)(HEIGHT + BH)));\n+                    panel.setPreferredSize(new Dimension((int) (WIDTH + BW), (int) (HEIGHT + BH)));\n@@ -656,1 +666,0 @@\n-            Robot robot = new Robot();\n@@ -658,1 +667,11 @@\n-            Timer timer = new Timer(DELAY, e -> {\n+            Robot robot = new Robot();\n+            int cycle = 0;\n+            int frame = 0;\n+            long paintTime = 0;\n+            int maxFrameCycle = -1;\n+            while (frame < COUNT) {\n+                long t;\n+                if ((t = markerPaintTime.getAndSet(0)) > 0) {\n+                    paintTime = t;\n+                    maxFrameCycle = cycle + MAX_FRAME_CYCLES;\n+                }\n@@ -660,1 +679,1 @@\n-                if (waiting.compareAndSet(false, true)) {\n+                if (paintTime > 0) {\n@@ -664,20 +683,15 @@\n-                    if (isAlmostEqual(c, Color.BLUE)) {\n-                        expColor = Color.RED;\n-                    } else {\n-                        expColor = Color.BLUE;\n-                    }\n-                    renderable.update();\n-                    panel.getParent().repaint();\n-\n-                } else {\n-                    while (!isAlmostEqual(\n-                            robot.getPixelColor(\n-                                    panel.getTopLevelAncestor().getX() + panel.getTopLevelAncestor().getInsets().left + BW\/2,\n-                                    panel.getTopLevelAncestor().getY() + panel.getTopLevelAncestor().getInsets().top + BH\/2),\n-                            expColor))\n-                    {\n-                        try {\n-                            Thread.sleep(RESOLUTION);\n-                        } catch (InterruptedException ex) {\n-                            ex.printStackTrace();\n-                        }\n+\n+                    if (isAlmostEqual(c, marker[markerIdx.get()])) {\n+                        execTime += System.nanoTime() - paintTime;\n+                        frame++;\n+                        paintTime = 0;\n+                        maxFrameCycle = -1;\n+                        markerIdx.accumulateAndGet(marker.length, (x, y) -> (x + 1) % y);\n+                        renderable.update();\n+                        panel.getParent().repaint();\n+                    } else if (cycle >= maxFrameCycle) {\n+                        skippedFrame++;\n+                        paintTime = 0;\n+                        maxFrameCycle = -1;\n+                        markerIdx.accumulateAndGet(marker.length, (x, y) -> (x + 1) % y);\n+                        panel.getParent().repaint();\n@@ -685,4 +699,0 @@\n-                    time = System.nanoTime() - time;\n-                    execTime += time;\n-                    frame++;\n-                    waiting.set(false);\n@@ -690,5 +700,4 @@\n-\n-                if (System.currentTimeMillis() < endTime) {\n-                    latch.countDown();\n-                } else {\n-                    while(latch.getCount() > 0) latch.countDown();\n+                try {\n+                    Thread.sleep(CYCLE_DELAY);\n+                } catch (InterruptedException ex) {\n+                    ex.printStackTrace();\n@@ -696,3 +705,5 @@\n-            });\n-            timer.start();\n-            latch.await();\n+                if (cycle >= MAX_MEASURE_CYCLES) {\n+                    break;\n+                }\n+                cycle++;\n+            }\n@@ -700,1 +711,0 @@\n-                timer.stop();\n@@ -716,0 +726,3 @@\n+            if (skippedFrame > 0) {\n+                System.err.println(skippedFrame + \" frame(s) skipped\");\n+            }\n@@ -720,2 +733,2 @@\n-            return Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE ||\n-                    Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE ||\n+            return Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE &&\n+                    Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE &&\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/src\/renderperf\/RenderPerfTest.java","additions":71,"deletions":58,"binary":false,"changes":129,"status":"modified"}]}