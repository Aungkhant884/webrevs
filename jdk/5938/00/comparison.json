{"files":[{"patch":"@@ -716,0 +716,24 @@\n+  \/* java level dcmd *\/                                                                                                                \\\n+  template(sum_management_cmd_Factory,                      \"sun\/management\/cmd\/Factory\")                                              \\\n+  template(buildCommand_name,                               \"buildCommand\")                                                            \\\n+  template(buildCommand_signature,                          \"(Ljava\/lang\/String;C)Lsun\/management\/cmd\/Executable;\")                    \\\n+  template(sum_management_cmd_internal_Executor,            \"sun\/management\/cmd\/internal\/Executor\")                                    \\\n+  template(executeCommand_name,                             \"executeCommand\")                                                          \\\n+  template(executeCommand_signature,                        \"(Lsun\/management\/cmd\/Executable;)Ljava\/lang\/String;\")                     \\\n+  template(factory_enabled_name,                            \"enabled\")                                                                 \\\n+  template(factory_disabledMessage_name,                    \"disabledMessage\")                                                         \\\n+  template(factory_command_name,                            \"command\")                                                                 \\\n+  template(factory_options_name,                            \"options\")                                                                 \\\n+  template(factory_arguments_name,                          \"arguments\")                                                               \\\n+  template(description_name,                                \"description\")                                                             \\\n+  template(impact_name,                                     \"impact\")                                                                  \\\n+  template(permissionClass_name,                            \"permissionClass\")                                                         \\\n+  template(permissionName_name,                             \"permissionName\")                                                          \\\n+  template(permissionAction_name,                           \"permissionAction\")                                                        \\\n+  template(ordinal_name,                                    \"ordinal\")                                                                 \\\n+  template(defaultValue_name,                               \"defaultValue\")                                                            \\\n+  template(isMandatory_name,                                \"isMandatory\")                                                             \\\n+  template(cmdMeta_signature,                               \"Lsun\/management\/cmd\/Factory$CmdMeta;\")                                    \\\n+  template(paramMeta_signature,                             \"Lsun\/management\/cmd\/Factory$ParamMeta;\")                                  \\\n+  template(paramMeta_array_signature,                       \"[Lsun\/management\/cmd\/Factory$ParamMeta;\")                                 \\\n+                                                                                                                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -343,0 +343,3 @@\n+  void         (JNICALL *RegisterDiagnosticCommand)\n+                                                  (JNIEnv *env,\n+                                                   jobject factory);\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -32,0 +35,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -566,0 +570,239 @@\n+\n+static InstanceKlass* factory_klass(TRAPS) {\n+  Symbol* klass = vmSymbols::sum_management_cmd_Factory();\n+  Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  if (ik->should_be_initialized()) {\n+    ik->initialize(CHECK_NULL);\n+  }\n+  return ik;\n+}\n+\n+static InstanceKlass* executor_klass(TRAPS) {\n+  Symbol* klass = vmSymbols::sum_management_cmd_internal_Executor();\n+  Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  if (ik->should_be_initialized()) {\n+    ik->initialize(CHECK_NULL);\n+  }\n+  return ik;\n+}\n+\n+void JavaDCmd::parse(CmdLine *line, char delim, TRAPS) {\n+  HandleMark hm(THREAD);\n+  InstanceKlass* ik = factory_klass(CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.set_receiver(Handle(THREAD, JNIHandles::resolve_non_null(_factory._factory)));\n+\n+  char* cmd_args = NULL;\n+  if (line->args_len() > 0) {\n+    cmd_args = NEW_RESOURCE_ARRAY(char, line->args_len() + 1);\n+    strncpy(cmd_args, line->args_addr(), line->args_len());\n+    cmd_args[line->args_len()] = '\\0';\n+  }\n+\n+  Handle args_str = java_lang_String::create_from_str((cmd_args != NULL ? cmd_args : \"\"), CHECK);\n+  args.push_oop(args_str);\n+  args.push_int(delim);\n+\n+  JavaCalls::call_virtual(&result,\n+                          ik,\n+                          vmSymbols::buildCommand_name(),\n+                          vmSymbols::buildCommand_signature(),\n+                          &args,\n+                          CHECK);\n+  Handle r = Handle(THREAD, result.get_oop());\n+  _cmd = JNIHandles::make_global(r);\n+}\n+\n+void JavaDCmd::execute(DCmdSource source, TRAPS) {\n+  HandleMark hm(THREAD);\n+  InstanceKlass* ik = executor_klass(CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+\n+  args.push_oop(Handle(THREAD, JNIHandles::resolve_non_null(_cmd)));\n+  JavaCalls::call_static(&result,\n+                         ik,\n+                         vmSymbols::executeCommand_name(),\n+                         vmSymbols::executeCommand_signature(),\n+                         &args,\n+                         CHECK);\n+  Handle h = Handle(THREAD, result.get_oop());\n+  if (h.not_null()) {\n+    output()->print_raw(java_lang_String::as_utf8_string(h()));\n+  }\n+}\n+\n+void JavaDCmd::cleanup() {\n+  JNIHandles::destroy_global(_cmd);\n+}\n+\n+void JavaDCmd::print_help(const char* name) const {\n+  GrowableArray<DCmdArgumentInfo*>* argument_infos = _factory._argument_infos;\n+\n+  outputStream* out = output();\n+  int option_count = _factory._option_count;\n+  out->print(\"Syntax : %s %s\", name, option_count == 0 ? \"\" : \"[options]\");\n+\n+  for (int i = option_count; i < argument_infos->length(); i++) {\n+     DCmdArgumentInfo* info = argument_infos->at(i);\n+     if (info->is_mandatory()) {\n+       out->print(\" <%s>\", info->name());\n+     } else {\n+       out->print(\" [<%s>]\", info->name());\n+     }\n+  }\n+  out->cr();\n+\n+  if (argument_infos->length() > option_count) {\n+    out->print_cr(\"\\nArguments:\");\n+\n+    for (int i = _factory._option_count; i < argument_infos->length(); i++) {\n+       DCmdArgumentInfo* info = argument_infos->at(i);\n+       out->print(\"\\t%s : %s %s (%s, \", info->name(),\n+                  info->is_mandatory() ? \"\" : \"[optional]\",\n+                  info->description(), info->type());\n+       if (info->default_string() != NULL) {\n+          out->print(\"%s\", info->default_string());\n+       } else {\n+          out->print(\"no default value\");\n+       }\n+        out->print_cr(\")\");\n+    }\n+  }\n+\n+  if (option_count > 0) {\n+    out->print_cr(\"\\nOptions: (options must be specified using the <key> or <key>=<value> syntax)\");\n+    for (int i = 0; i < option_count; i++) {\n+       DCmdArgumentInfo* info = argument_infos->at(i);\n+       out->print(\"\\t%s : %s %s (%s, \", info->name(),\n+                  info->is_mandatory() ? \"\" : \"[optional]\",\n+                  info->description(), info->type());\n+       if (info->default_string() != NULL) {\n+          out->print(\"%s\", info->default_string());\n+       } else {\n+          out->print(\"no default value\");\n+       }\n+       out->print_cr(\")\");\n+    }\n+  }\n+}\n+\n+GrowableArray<const char*>* JavaDCmd::argument_name_array() const {\n+  return _factory._argument_names;\n+}\n+\n+GrowableArray<DCmdArgumentInfo*>* JavaDCmd::argument_info_array() const {\n+  return _factory._argument_infos;\n+}\n+\n+static int get_offset_of(oop o, Symbol* name, Symbol* sig) {\n+  fieldDescriptor fd;\n+  InstanceKlass* ik = InstanceKlass::cast(o->klass());\n+  bool found = ik->find_local_field(name, sig, &fd);\n+  assert(found, \"sanity check\");\n+  return fd.offset();\n+}\n+\n+static oop get_oop_field(oop o, Symbol* name, Symbol* sig) {\n+  return o->obj_field(get_offset_of(o, name, sig));\n+}\n+\n+static oop get_string_field(oop o, Symbol* name) {\n+  return get_oop_field(o, name, vmSymbols::string_signature());\n+}\n+\n+static jint get_int_field(oop o, Symbol* name) {\n+  return o->int_field(get_offset_of(o, name, vmSymbols::int_signature()));\n+}\n+\n+static jboolean get_bool_field(oop o, Symbol* name) {\n+  return o->bool_field(get_offset_of(o, name, vmSymbols::bool_signature()));\n+}\n+\n+static char* to_native_string(oop string, bool null_if_empty = false) {\n+  size_t length = java_lang_String::utf8_length(string);\n+  if (length == 0 && null_if_empty) {\n+    return NULL;\n+  }\n+  char* result = AllocateHeap(length + 1, mtInternal);\n+  java_lang_String::as_utf8_string(string, result, (int) length + 1);\n+  return result;\n+}\n+\n+static void fill_argument_info(GrowableArray<const char*>* argument_names,\n+                               GrowableArray<DCmdArgumentInfo*>* argument_infos,\n+                               oop meta) {\n+  oop name = get_string_field(meta, vmSymbols::name_name());\n+  oop description = get_string_field(meta, vmSymbols::description_name());\n+  int ordinal = get_int_field(meta, vmSymbols::ordinal_name());\n+  oop defaultValue = get_string_field(meta, vmSymbols::defaultValue_name());\n+  bool isMandatory = get_bool_field(meta, vmSymbols::isMandatory_name());\n+  oop type = get_string_field(meta, vmSymbols::type_name());\n+\n+  argument_names->append(to_native_string(name));\n+\n+\n+  DCmdArgumentInfo* info = new(ResourceObj::C_HEAP, mtInternal)\n+                             DCmdArgumentInfo(to_native_string(name),\n+                                              to_native_string(description),\n+                                              to_native_string(type),\n+                                              to_native_string(defaultValue, true),\n+                                              isMandatory,\n+                                              ordinal != -1,\n+                                              false,\n+                                              ordinal);\n+  argument_infos->append(info);\n+}\n+\n+void DCmdRegistrant::register_java_dcmd(jobject app_factory, TRAPS) {\n+  HandleMark hm(THREAD);\n+  oop o = JNIHandles::resolve_non_null(app_factory);\n+  int export_flags = get_int_field(o, vmSymbols::flags_name());\n+  bool enabled = get_bool_field(o, vmSymbols::factory_enabled_name());\n+  oop disabled_message = get_string_field(o, vmSymbols::factory_disabledMessage_name());\n+  oop cmd = get_oop_field(o, vmSymbols::factory_command_name(), vmSymbols::cmdMeta_signature());\n+  oop name = get_string_field(cmd, vmSymbols::name_name());\n+  oop description = get_string_field(cmd, vmSymbols::description_name());\n+  oop impact = get_string_field(cmd, vmSymbols::impact_name());\n+  oop permission_class = get_string_field(cmd, vmSymbols::permissionClass_name());\n+  oop permission_name = get_string_field(cmd, vmSymbols::permissionName_name());\n+  oop permission_action = get_string_field(cmd, vmSymbols::permissionAction_name());\n+\n+  JavaPermission permission = {to_native_string(permission_class, true),\n+                               to_native_string(permission_name, true),\n+                               to_native_string(permission_action, true)};\n+\n+  objArrayOop options = (objArrayOop)get_oop_field(o, vmSymbols::factory_options_name(),\n+                                                      vmSymbols::paramMeta_array_signature());\n+  objArrayOop arguments = (objArrayOop)get_oop_field(o, vmSymbols::factory_arguments_name(),\n+                                                        vmSymbols::paramMeta_array_signature());\n+\n+  int num_of_arguments = options->length() + arguments->length();\n+  GrowableArray<const char*>* argument_names = new(ResourceObj::C_HEAP, mtInternal)\n+                                                   GrowableArray<const char*>(num_of_arguments, mtInternal);\n+  GrowableArray<DCmdArgumentInfo*>* argument_infos = new(ResourceObj::C_HEAP, mtInternal)\n+                                                   GrowableArray<DCmdArgumentInfo*>(num_of_arguments, mtInternal);\n+\n+  for (int i = 0; i < options->length(); i++) {\n+    fill_argument_info(argument_names, argument_infos, options->obj_at(i));\n+  }\n+\n+  for (int i = 0; i < arguments->length(); i++) {\n+    fill_argument_info(argument_names, argument_infos, arguments->obj_at(i));\n+  }\n+\n+  Handle fh = Handle(THREAD, o);\n+  DCmdFactory::register_DCmdFactory(new JavaDCmdFactoryImpl(\n+                                      export_flags, enabled,\n+                                      num_of_arguments,\n+                                      to_native_string(name), to_native_string(description),\n+                                      to_native_string(impact), permission,\n+                                      to_native_string(disabled_message),\n+                                      argument_names,\n+                                      argument_infos,\n+                                      options->length(),\n+                                      JNIHandles::make_global(fh)));\n+}\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":243,"deletions":0,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -334,0 +334,20 @@\n+class JavaDCmdFactoryImpl;\n+\n+class JavaDCmd : public DCmd {\n+private:\n+  const JavaDCmdFactoryImpl& _factory;\n+  jobject _cmd;\n+public:\n+  JavaDCmd(const JavaDCmdFactoryImpl& factory, outputStream *output, bool heap = false) : DCmd(output, heap),\n+    _factory(factory), _cmd(NULL) { }\n+\n+  void parse(CmdLine *line, char delim, TRAPS);\n+  void execute(DCmdSource source, TRAPS);\n+  void cleanup();\n+\n+  void print_help(const char* name) const;\n+\n+  GrowableArray<const char*>* argument_name_array() const;\n+  GrowableArray<DCmdArgumentInfo*>* argument_info_array() const;\n+};\n+\n@@ -455,0 +475,55 @@\n+class JavaDCmdFactoryImpl : public DCmdFactory {\n+friend class JavaDCmd;\n+private:\n+  char* _name;\n+  char* _description;\n+  char* _impact;\n+  JavaPermission _permission;\n+  char* _disabled_message;\n+\n+  GrowableArray<const char*>* _argument_names;\n+  GrowableArray<DCmdArgumentInfo*>* _argument_infos;\n+  const int _option_count;\n+\n+  jobject _factory;\n+public:\n+  JavaDCmdFactoryImpl(uint32_t flags, bool enabled, int num_arguments,\n+                     char* name, char* description, char* impact, JavaPermission permission,\n+                     char* disabled_message,\n+                     GrowableArray<const char*>* argument_names,\n+                     GrowableArray<DCmdArgumentInfo*>* argument_infos,\n+                     int option_count,\n+                     jobject factory) :\n+    DCmdFactory(num_arguments, flags, enabled, false),\n+    _name(name), _description(description), _impact(impact), _permission(permission),\n+    _disabled_message(disabled_message),\n+    _argument_names(argument_names),\n+    _argument_infos(argument_infos),\n+    _option_count(option_count),\n+    _factory(factory) { }\n+\n+  DCmd* create_resource_instance(outputStream* output) const {\n+    return new JavaDCmd(*this, output, false);\n+  }\n+\n+  const char* name() const {\n+    return _name;\n+  }\n+\n+  const char* description() const {\n+    return _description;\n+  }\n+\n+  const char* impact() const {\n+    return _impact;\n+  }\n+\n+  const JavaPermission permission() const {\n+    return _permission;\n+  }\n+\n+  const char* disabled_message() const {\n+     return _disabled_message;\n+  }\n+};\n+\n@@ -466,0 +541,3 @@\n+\n+public:\n+    static void register_java_dcmd(jobject app_factory, TRAPS);\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2061,0 +2061,4 @@\n+JVM_ENTRY(void, jmm_RegisterDiagnosticCommand(JNIEnv *env, jobject factory))\n+  DCmdRegistrant::register_java_dcmd(factory, THREAD);\n+JVM_END\n+\n@@ -2243,1 +2247,2 @@\n-  jmm_SetDiagnosticFrameworkNotificationEnabled\n+  jmm_SetDiagnosticFrameworkNotificationEnabled,\n+  jmm_RegisterDiagnosticCommand\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+package sun.management.cmd;\n+\n+\/**\n+ * Command constant\n+ *\n+ * @author Denghui Dong\n+ *\/\n+public interface Constant {\n+\n+    \/**\n+     * Accept invocation from the JVM\n+     *\/\n+    int INTERNAL = 1;\n+\n+    \/**\n+     * Accept invocation via the attachAPI\n+     *\/\n+    int ATTACH_API = 2;\n+\n+    \/**\n+     * Accept invocation via the MBean\n+     *\/\n+    int MBEAN = 4;\n+\n+    \/**\n+     * Accept all invocation\n+     *\/\n+    int FULL_EXPORT = INTERNAL | ATTACH_API | MBEAN;\n+\n+    \/**\n+     * Empty value\n+     *\/\n+    String EMPTY_VALUE = \"\";\n+\n+    \/**\n+     * Default description\n+     *\/\n+    String DEFAULT_DESCRIPTION = EMPTY_VALUE;\n+\n+    \/**\n+     * Default impact\n+     *\/\n+    String DEFAULT_IMPACT = \"Low\";\n+\n+\n+    \/**\n+     * Default permission\n+     *\/\n+    String[] DEFAULT_PERMISSION = {EMPTY_VALUE, EMPTY_VALUE, EMPTY_VALUE};\n+\n+    \/**\n+     * Default disabled message\n+     *\/\n+    String DEFAULT_DISABLED_MESSAGE = \"Command currently disabled\";\n+}\n","filename":"src\/java.management\/share\/classes\/sun\/management\/cmd\/Constant.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+package sun.management.cmd;\n+\n+import java.io.PrintWriter;\n+\n+\/**\n+ * The {@code Executable} interface should be implemented by any\n+ * class which is annotated by {@code @Command}.\n+ *\n+ * @author Denghui Dong\n+ *\/\n+public interface Executable {\n+\n+    \/**\n+     * @param output the output when this executable is running\n+     *\/\n+    void execute(PrintWriter output);\n+}\n","filename":"src\/java.management\/share\/classes\/sun\/management\/cmd\/Executable.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,552 @@\n+package sun.management.cmd;\n+\n+import sun.management.cmd.annotation.Command;\n+import sun.management.cmd.annotation.Parameter;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import static sun.management.cmd.Constant.*;\n+\n+\/**\n+ * Command factory\n+ *\n+ * @author Denghui Dong\n+ *\/\n+public class Factory {\n+\n+    private static final Set<String> COMMANDS = new HashSet<>();\n+\n+    private static final Object LOCK = new Object();\n+\n+    private static final String[] RESERVED_DOMAIN = {\n+        \"Compiler.\",\n+        \"GC.\",\n+        \"JFR.\",\n+        \"JVMTI.\",\n+        \"ManagementAgent.\",\n+        \"System.\",\n+        \"Thread.\",\n+        \"VM.\"\n+    };\n+\n+    \/* <domain>.[sub-domain.]<command> *\/\n+    private static final Pattern\n+        CMD_NAME_PATTERN = Pattern.compile(\"^([A-Za-z_][A-Za-z_0-9]*\\\\.)+[A-Za-z_][A-Za-z_0-9]*$\");\n+\n+    private static final Pattern\n+        PARAM_NAME_PATTERN = Pattern.compile(\"^[A-Za-z_][A-Za-z_0-9]*$\");\n+\n+    static {\n+        \/\/ make sure that the management lib is loaded within\n+        \/\/ java.lang.management.ManagementFactory\n+        try {\n+            MethodHandles.lookup().ensureInitialized(ManagementFactory.class);\n+        } catch (IllegalAccessException e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    private final int flags;\n+\n+    private final boolean enabled;\n+\n+    private final String disabledMessage;\n+\n+    private CmdMeta command;\n+\n+    private ParamMeta[] options;\n+\n+    private ParamMeta[] arguments;\n+\n+    private Factory(Class<? extends Executable> clazz) {\n+        Command cmd = getCommandAnnotation(clazz);\n+        checkFlags(cmd.exportFlags());\n+        this.flags = cmd.exportFlags();\n+        this.enabled = cmd.enabled();\n+        this.disabledMessage = cmd.disabledMessage();\n+        init(clazz);\n+    }\n+\n+    private Factory(String name, String description, String impact, String[] permission, int flags, boolean enabled,\n+                    String disabledMessage, Executable executable) {\n+        checkFlags(flags);\n+        this.flags = flags;\n+        this.enabled = enabled;\n+        this.disabledMessage = disabledMessage;\n+        init(name, description, impact, permission, executable);\n+    }\n+\n+    private static void checkFlags(int exportFlags) {\n+        if ((exportFlags & ~FULL_EXPORT) != 0 || (exportFlags & FULL_EXPORT) == 0) {\n+            throw new IllegalArgumentException(\"Illegal export flags: \" + exportFlags);\n+        }\n+    }\n+\n+    \/**\n+     * Registers a command by class annotated by @Command\n+     *\/\n+    public static void register(Class<? extends Executable> clazz) {\n+        Command meta = getCommandAnnotation(clazz);\n+        checkName(clazz, meta.name());\n+        doRegister(new Factory(clazz));\n+    }\n+\n+    \/**\n+     * Registers a command by name and executable\n+     *\/\n+    public static void register(String name, Executable executable) {\n+        register(name, DEFAULT_DESCRIPTION, DEFAULT_IMPACT, DEFAULT_PERMISSION,\n+                 FULL_EXPORT, true, DEFAULT_DISABLED_MESSAGE, executable);\n+    }\n+\n+    \/**\n+     * Registers a command by full description\n+     *\/\n+    public static void register(String name, String description, String impact,\n+                                String[] permission, int exportFlags, boolean enabled, String disabledMessage,\n+                                Executable executable) {\n+        checkName(executable.getClass(), name);\n+        doRegister(new Factory(name, description, impact, permission, exportFlags, enabled, disabledMessage,\n+                               executable));\n+    }\n+\n+    private static boolean isReservedName(Class<? extends Executable> clazz, String name) {\n+        String cn = clazz.getName();\n+        if (!cn.startsWith(\"java.\") && !cn.startsWith(\"jdk.\") && !cn.startsWith(\"javax.\") && !cn.startsWith(\"sun.\")) {\n+            for (String prefix : RESERVED_DOMAIN) {\n+                if (name.startsWith(prefix)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void checkName(Class<? extends Executable> clazz, String name) {\n+        if (!CMD_NAME_PATTERN.matcher(name).matches()) {\n+            throw new IllegalArgumentException(\"Illegal command name: \" + name);\n+        }\n+\n+        if (isReservedName(clazz, name)) {\n+            throw new IllegalArgumentException(\"Reserved command name: \" + name);\n+        }\n+\n+        synchronized (LOCK) {\n+            if (COMMANDS.contains(name)) {\n+                throw new IllegalArgumentException(\"Duplicated command: \" + name);\n+            }\n+        }\n+    }\n+\n+    private static void doRegister(Factory factory) {\n+        String name = factory.command.name;\n+        synchronized (LOCK) {\n+            checkName(factory.command.clazz, name);\n+            doRegister0(factory);\n+            COMMANDS.add(name);\n+        }\n+    }\n+\n+    private static native void doRegister0(Factory factory);\n+\n+    private static Command getCommandAnnotation(Class<? extends Executable> clazz) {\n+        Command meta = clazz.getDeclaredAnnotation(Command.class);\n+        if (meta == null) {\n+            throw new IllegalArgumentException(\"Should be annotated by @Command\");\n+        }\n+        return meta;\n+    }\n+\n+    private void init(Class<? extends Executable> clazz) {\n+        initCmdMeta(clazz);\n+        initParamMeta();\n+    }\n+\n+    private void init(String name, String description, String impact, String[] permission, Executable executable) {\n+        initCmdMeta(name, description, impact, permission, executable);\n+        initParamMeta();\n+    }\n+\n+    private void initCmdMeta(Class<? extends Executable> clazz) {\n+        Command meta = getCommandAnnotation(clazz);\n+\n+        try {\n+            clazz.getDeclaredConstructor();\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Should have a default constructor\");\n+        }\n+\n+        this.command = new CmdMeta(meta.name(), meta.description(), meta.impact(), meta.permission(), clazz, null);\n+    }\n+\n+    private void initCmdMeta(String name, String description, String impact, String[] permission,\n+                             Executable executable) {\n+        this.command = new CmdMeta(name, description, impact, permission, executable.getClass(), executable);\n+    }\n+\n+    private void initParamMeta() {\n+        Field[] declaredFields = command.clazz.getDeclaredFields();\n+        List<ParamMeta> options = new ArrayList<>();\n+        List<ParamMeta> arguments = new ArrayList<>();\n+        int maxOrdinal = -1;\n+        Set<Integer> indexes = new HashSet<>();\n+        Set<String> names = new HashSet<>();\n+        for (Field field : declaredFields) {\n+            if (Modifier.isStatic(field.getModifiers())) {\n+                continue;\n+            }\n+\n+            Parameter paramMeta = field.getDeclaredAnnotation(Parameter.class);\n+            if (paramMeta == null) {\n+                continue;\n+            }\n+\n+            String typeDesc = parameterType(field);\n+\n+            String name = paramMeta.name();\n+\n+            if (names.contains(name)) {\n+                throw new IllegalArgumentException(\"Duplicated parameter name: \" + paramMeta.name());\n+            }\n+\n+            if (!PARAM_NAME_PATTERN.matcher(name).matches()) {\n+                throw new IllegalArgumentException(\"Illegal parameter name\");\n+            }\n+\n+            if (paramMeta.ordinal() < -1) {\n+                throw new IllegalArgumentException(\"Illegal ordinal: \" + paramMeta.ordinal());\n+            }\n+\n+            names.add(paramMeta.name());\n+\n+            ParamMeta meta = new ParamMeta(\n+                name,\n+                paramMeta.description(),\n+                paramMeta.ordinal(),\n+                paramMeta.defaultValue(),\n+                paramMeta.isMandatory(),\n+                typeDesc,\n+                field\n+            );\n+\n+            if (meta.ordinal == -1) {\n+                options.add(meta);\n+            } else {\n+                if (indexes.contains(meta.ordinal)) {\n+                    throw new IllegalArgumentException(\"Duplicated ordinal: \" + meta.ordinal);\n+                }\n+                indexes.add(meta.ordinal);\n+                maxOrdinal = Math.max(maxOrdinal, meta.ordinal);\n+                arguments.add(meta);\n+            }\n+        }\n+\n+        if (indexes.size() != maxOrdinal + 1) {\n+            throw new IllegalArgumentException(\"Illegal ordinals\");\n+        }\n+\n+        arguments.sort(Comparator.comparingInt(p -> p.ordinal));\n+        this.options = options.toArray(new ParamMeta[0]);\n+        this.arguments = arguments.toArray(new ParamMeta[0]);\n+    }\n+\n+    private String parameterType(Field field) {\n+        Class<?> type = field.getType();\n+\n+        if (type == String.class) {\n+            return \"STRING\";\n+        } else if (type == long.class) {\n+            return \"LONG\";\n+        } else if (type == int.class) {\n+            return \"INT\";\n+        } else if (type == boolean.class) {\n+            return \"BOOLEAN\";\n+        } else {\n+            throw new IllegalArgumentException(\"Illegal parameter type\");\n+        }\n+    }\n+\n+    private int lookupOption(Arg arg) {\n+        for (int i = 0; i < options.length; i++) {\n+            if (options[i].name.equals(arg.key)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private void readValue(Executable cmd, Field field, String val) throws IllegalAccessException {\n+        Class<?> type = field.getType();\n+        field.setAccessible(true);\n+        if (type == String.class) {\n+            field.set(cmd, val);\n+            return;\n+        } else if (type == long.class) {\n+            field.set(cmd, Long.parseLong(val));\n+            return;\n+        } else if (type == int.class) {\n+            field.set(cmd, Integer.parseInt(val));\n+            return;\n+        } else if (type == boolean.class) {\n+            if (Boolean.TRUE.toString().equalsIgnoreCase(val)) {\n+                field.set(cmd, true);\n+                return;\n+            } else if (Boolean.FALSE.toString().equalsIgnoreCase(val)) {\n+                field.set(cmd, false);\n+                return;\n+            }\n+            throw new IllegalArgumentException(\"Illegal boolean value\");\n+        }\n+        throw new IllegalStateException(\"Should not reach here\");\n+    }\n+\n+    \/**\n+     * invoked by native\n+     *\/\n+    Executable buildCommand(String args, char delim) throws Exception {\n+        Executable command = this.command.executable;\n+        if (command == null) {\n+            Class<? extends Executable> clazz = this.command.clazz;\n+            Constructor<? extends Executable> constructor = clazz.getDeclaredConstructor();\n+            constructor.setAccessible(true);\n+            command = constructor.newInstance();\n+        }\n+\n+        int nextArg = 0;\n+        ArgItr argItr = new ArgItr(args, delim);\n+        boolean[] optionIsSet = new boolean[options.length];\n+        boolean[] argumentIsSet = new boolean[arguments.length];\n+        while (argItr.hasNext()) {\n+            Arg arg = argItr.next();\n+            int index = lookupOption(arg);\n+            if (index != -1) {\n+                ParamMeta option = options[index];\n+                if (arg.value != null) {\n+                    readValue(command, option.field, arg.value);\n+                    optionIsSet[index] = true;\n+                }\n+            } else if (nextArg < arguments.length) {\n+                readValue(command, arguments[nextArg].field, arg.key);\n+                argumentIsSet[nextArg++] = true;\n+            } else {\n+                throw new IllegalArgumentException(\"Unknown argument in command.\");\n+            }\n+        }\n+\n+        \/\/ check mandatory\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (!argumentIsSet[i]) {\n+                ParamMeta argument = arguments[i];\n+                if (argument.defaultValue.length() > 0) {\n+                    readValue(command, argument.field, argument.defaultValue);\n+                    continue;\n+                }\n+                if (argument.isMandatory) {\n+                    throw new IllegalArgumentException(\"The argument '\" + argument.name + \"' is mandatory.\");\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < options.length; i++) {\n+            if (!optionIsSet[i]) {\n+                ParamMeta option = options[i];\n+                if (option.defaultValue.length() > 0) {\n+                    readValue(command, option.field, option.defaultValue);\n+                    continue;\n+                }\n+                if (option.isMandatory) {\n+                    throw new IllegalArgumentException(\"The option '\" + option.name + \"' is mandatory.\");\n+                }\n+            }\n+        }\n+\n+        return command;\n+    }\n+\n+    private static class CmdMeta {\n+        String name;\n+\n+        String description;\n+\n+        final String impact;\n+\n+        final String permissionClass;\n+\n+        final String permissionName;\n+\n+        final String permissionAction;\n+\n+        final Class<? extends Executable> clazz;\n+\n+        final Executable executable;\n+\n+        public CmdMeta(String name, String description, String impact, String[] permission,\n+                       Class<? extends Executable> clazz, Executable executable) {\n+            if (permission.length != 3) {\n+                throw new IllegalArgumentException(\"Illegal permission\");\n+            }\n+            this.name = name;\n+            this.description = Optional.ofNullable(description).orElse(DEFAULT_DESCRIPTION);\n+            this.impact = Optional.ofNullable(impact).orElse(DEFAULT_IMPACT);\n+            this.permissionClass = Optional.ofNullable(permission[0]).orElse(EMPTY_VALUE);\n+            this.permissionName = Optional.ofNullable(permission[1]).orElse(EMPTY_VALUE);\n+            this.permissionAction = Optional.ofNullable(permission[2]).orElse(EMPTY_VALUE);\n+            this.clazz = clazz;\n+            this.executable = executable;\n+        }\n+    }\n+\n+    private static class ParamMeta {\n+        final String name;\n+\n+        final String description;\n+\n+        final int ordinal;\n+\n+        final String defaultValue;\n+\n+        final boolean isMandatory;\n+\n+        final String type;\n+\n+        final Field field;\n+\n+        public ParamMeta(String name, String description, int ordinal, String defaultValue, boolean isMandatory,\n+                         String type, Field field) {\n+            this.name = name;\n+            this.description = Optional.ofNullable(description).orElse(DEFAULT_DESCRIPTION);\n+            this.ordinal = ordinal;\n+            this.defaultValue = Optional.ofNullable(defaultValue).orElse(EMPTY_VALUE);\n+            this.isMandatory = isMandatory;\n+            this.type = type;\n+            this.field = field;\n+        }\n+    }\n+\n+    private static class Arg {\n+        String key;\n+\n+        String value;\n+    }\n+\n+    private static class ArgItr implements Iterator<Arg> {\n+        String args;\n+        char delim;\n+\n+        int cursor;\n+        Arg cur;\n+\n+        ArgItr(String args, char delim) {\n+            this.args = args;\n+            this.delim = delim;\n+            step();\n+        }\n+\n+        private void matchNextQuote(char quote) {\n+            while (cursor < args.length() - 1) {\n+                cursor++;\n+                if (args.charAt(cursor) == quote && args.charAt(cursor - 1) != '\\\\') {\n+                    break;\n+                }\n+            }\n+            if (args.charAt(cursor) != quote) {\n+                throw new IllegalArgumentException(\"Format error in diagnostic command arguments\");\n+            }\n+        }\n+\n+        private void step() {\n+            if (cursor >= args.length()) {\n+                return;\n+            }\n+\n+            while (args.charAt(cursor) == delim) {\n+                if (++cursor >= args.length()) {\n+                    return;\n+                }\n+            }\n+\n+            int keyStart = cursor;\n+            boolean hadQuotes = false;\n+            do {\n+                char c = args.charAt(cursor);\n+                if (c == '=' || c == delim) {\n+                    break;\n+                }\n+                if (c == '\\\"' || c == '\\'') {\n+                    keyStart++;\n+                    hadQuotes = true;\n+                    matchNextQuote(c);\n+                    break;\n+                }\n+            } while (++cursor < args.length());\n+\n+            String key = args.substring(keyStart, cursor);\n+            if (key.length() == 0) {\n+                return;\n+            }\n+\n+            if (hadQuotes) {\n+                cursor++;\n+            }\n+\n+            String val = null;\n+            if (cursor < args.length() && args.charAt(cursor) == '=') {\n+                cursor++;\n+                int valStart = cursor;\n+                hadQuotes = false;\n+\n+                while (cursor < args.length()) {\n+                    char c = args.charAt(cursor);\n+                    if (c == delim) {\n+                        break;\n+                    }\n+                    if (c == '\\\"' || c == '\\'') {\n+                        valStart++;\n+                        hadQuotes = true;\n+                        matchNextQuote(c);\n+                        break;\n+                    }\n+                    cursor++;\n+                }\n+\n+                val = args.substring(valStart, cursor);\n+                if (hadQuotes) {\n+                    cursor++;\n+                }\n+            }\n+\n+            cur = new Arg();\n+            cur.key = key;\n+            cur.value = val;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return cur != null;\n+        }\n+\n+        @Override\n+        public Arg next() {\n+            if (cur == null) {\n+                throw new NoSuchElementException();\n+            }\n+            Arg res = cur;\n+            cur = null;\n+            step();\n+            return res;\n+        }\n+    }\n+}\n","filename":"src\/java.management\/share\/classes\/sun\/management\/cmd\/Factory.java","additions":552,"deletions":0,"binary":false,"changes":552,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+package sun.management.cmd.annotation;\n+\n+import sun.management.cmd.Constant;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Provide the metadata of a command\n+ *\n+ * @author Denghui Dong\n+ *\/\n+@Documented\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE})\n+public @interface Command {\n+\n+    \/**\n+     * Returns the name of this command.\n+     *\n+     * @return the name of this command\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Returns the description of this command.\n+     *\n+     * @return the description of this command\n+     *\/\n+    String description() default Constant.DEFAULT_DESCRIPTION;\n+\n+    \/**\n+     * Returns the impact on the application of this command.\n+     *\n+     * @return the impact on the application of this command\n+     *\/\n+    String impact() default Constant.DEFAULT_IMPACT;\n+\n+    \/**\n+     * Returns the permission of this command.\n+     *\n+     * @return the permission of this command\n+     *\/\n+    String[] permission() default {\"\", \"\", \"\"};\n+\n+    \/**\n+     * Returns the export flags.\n+     *\n+     * @return the export flags\n+     *\/\n+    int exportFlags() default Constant.FULL_EXPORT;\n+\n+    \/**\n+     * Check whether this command is enabled or not.\n+     *\n+     * @return true if this command is enabled, or false otherwise\n+     *\/\n+    boolean enabled() default true;\n+\n+    \/**\n+     * Returns the customized message when the command is disabled.\n+     *\n+     * @return the customized message when the command is disabled\n+     *\/\n+    String disabledMessage() default Constant.DEFAULT_DISABLED_MESSAGE;\n+}\n","filename":"src\/java.management\/share\/classes\/sun\/management\/cmd\/annotation\/Command.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+package sun.management.cmd.annotation;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Provide the metadata of a parameter\n+ *\n+ * @author Denghui Dong\n+ *\/\n+@Documented\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.FIELD})\n+public @interface Parameter {\n+\n+    \/**\n+     * Returns the name of this parameter.\n+     *\n+     * @return the name of this parameter\n+     *\/\n+    String name() default \"\";\n+\n+    \/**\n+     * Returns the description of this parameter.\n+     *\n+     * @return the description of this parameter\n+     *\/\n+    String description() default \"\";\n+\n+    \/**\n+     * Returns the order of this parameter, or -1 it's an option.\n+     *\n+     * @return the order of this parameter, or -1 it's an option.\n+     *\/\n+    int ordinal() default -1;\n+\n+    \/**\n+     * Returns the default value of this parameter\n+     *\n+     * @return the default value of this parameter.\n+     *\/\n+    String defaultValue() default \"\";\n+\n+    \/**\n+     * Returns true if this parameter must have a value, or false otherwise.\n+     *\n+     * @return true if this parameter must have a value, or false otherwise\n+     *\/\n+    boolean isMandatory() default false;\n+}\n","filename":"src\/java.management\/share\/classes\/sun\/management\/cmd\/annotation\/Parameter.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+package sun.management.cmd.internal;\n+\n+import sun.management.cmd.Executable;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class Executor {\n+\n+    \/\/ TODO: the value should be configurable\n+    private static final long TIMEOUT = 60;\n+\n+    \/**\n+     * invoked by native\n+     *\/\n+    static String executeCommand(Executable cmd) {\n+        ExecutorService es = Executors.newFixedThreadPool(1, r -> new Thread(r, \"Java DCmd Runner\"));\n+        try {\n+            Future<String> f = es.submit(\n+                () -> {\n+                    StringWriter sw = new StringWriter();\n+                    try (PrintWriter pw = new PrintWriter(sw)) {\n+                        cmd.execute(pw);\n+                    }\n+                    return sw.toString();\n+                }\n+            );\n+\n+            String res;\n+            try {\n+                res = f.get(TIMEOUT, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                f.cancel(true);\n+                if (e instanceof TimeoutException) {\n+                    res = \"Timed out\";\n+                } else {\n+                    res = e.getMessage();\n+                }\n+            }\n+            return res;\n+        } finally {\n+            es.shutdown();\n+        }\n+    }\n+}\n","filename":"src\/java.management\/share\/classes\/sun\/management\/cmd\/internal\/Executor.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+#include <jni.h>\n+#include \"management.h\"\n+#include \"sun_management_cmd_Factory.h\"\n+\n+JNIEXPORT void JNICALL Java_sun_management_cmd_Factory_doRegister0\n+  (JNIEnv *env, jclass cls, jobject factory) {\n+    jmm_interface->RegisterDiagnosticCommand(env, factory);\n+}\n+\n","filename":"src\/java.management\/share\/native\/libmanagement\/Factory.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"}]}