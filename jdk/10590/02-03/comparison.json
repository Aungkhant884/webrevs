{"files":[{"patch":"@@ -203,2 +203,2 @@\n-MonitorEnterStub::MonitorEnterStub(LIR_Opr obj_reg, LIR_Opr lock_reg, CodeEmitInfo* info)\n-: MonitorAccessStub(obj_reg, lock_reg) {\n+MonitorEnterStub::MonitorEnterStub(LIR_Opr obj_reg, CodeEmitInfo* info)\n+: MonitorAccessStub(obj_reg) {\n@@ -211,2 +211,1 @@\n-  ce->store_parameter(_obj_reg->as_register(),  1);\n-  ce->store_parameter(_lock_reg->as_register(), 0);\n+  ce->store_parameter(_obj_reg->as_register(),  0);\n@@ -227,5 +226,1 @@\n-  if (_compute_lock) {\n-    \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n-  ce->store_parameter(_lock_reg->as_register(), 0);\n+  ce->store_parameter(_obj_reg->as_register(), 0);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-      (2 * BytesPerWord) * (number_of_locks - 1);\n+      BytesPerWord * (number_of_locks - 1);\n@@ -247,1 +247,1 @@\n-      int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);\n+      int slot_offset = monitor_offset - (i * BytesPerWord);\n@@ -252,1 +252,1 @@\n-        __ ld(t0, Address(OSR_buf, slot_offset + 1 * BytesPerWord));\n+        __ ld(t0, Address(OSR_buf, slot_offset));\n@@ -258,3 +258,1 @@\n-      __ ld(x9, Address(OSR_buf, slot_offset + 0));\n-      __ sd(x9, frame_map()->address_for_monitor_lock(i));\n-      __ ld(x9, Address(OSR_buf, slot_offset + 1 * BytesPerWord));\n+      __ ld(x9, Address(OSR_buf, slot_offset));\n@@ -362,1 +360,2 @@\n-    stub = new MonitorExitStub(FrameMap::r10_opr, true, 0);\n+    __ ld(x10, Address(x10, BasicObjectLock::obj_offset_in_bytes()));\n+    stub = new MonitorExitStub(FrameMap::r10_opr);\n@@ -1505,1 +1504,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -1512,1 +1510,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -1609,1 +1606,1 @@\n-  __ la(dst->as_register(), frame_map()->address_for_monitor_lock(monitor_no));\n+  __ la(dst->as_register(), frame_map()->address_for_monitor_object(monitor_no));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-  LIR_Opr lock = new_register(T_INT);\n+  LIR_Opr lock = new_register(T_ADDRESS);\n@@ -288,1 +288,1 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n+  monitor_enter(obj.result(), lock, syncTempOpr(), new_register(T_INT), new_register(T_INT),\n@@ -298,1 +298,1 @@\n-  LIR_Opr lock = new_register(T_INT);\n+  LIR_Opr lock = new_register(T_ADDRESS);\n@@ -301,1 +301,1 @@\n-  monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x->monitor_no());\n+  monitor_exit(obj_temp, lock, syncTempOpr(), new_register(T_INT), x->monitor_no());\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,3 +62,0 @@\n-  \/\/ save object being locked into the BasicObjectLock\n-  sd(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-\n@@ -74,34 +71,3 @@\n-  \/\/ Load object header\n-  ld(hdr, Address(obj, hdr_offset));\n-  \/\/ and mark it as unlocked\n-  ori(hdr, hdr, markWord::unlocked_value);\n-  \/\/ save unlocked object header into the displaced header location on the stack\n-  sd(hdr, Address(disp_hdr, 0));\n-  \/\/ test if object header is still the same (i.e. unlocked), and if so, store the\n-  \/\/ displaced header address in the object header - if it is not the same, get the\n-  \/\/ object header instead\n-  la(t1, Address(obj, hdr_offset));\n-  cmpxchgptr(hdr, disp_hdr, t1, t0, done, \/*fallthough*\/NULL);\n-  \/\/ if the object header was the same, we're done\n-  \/\/ if the object header was not the same, it is now in the hdr register\n-  \/\/ => test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-  \/\/\n-  \/\/ 1) (hdr & aligned_mask) == 0\n-  \/\/ 2) sp <= hdr\n-  \/\/ 3) hdr <= sp + page_size\n-  \/\/\n-  \/\/ these 3 tests can be done by evaluating the following expression:\n-  \/\/\n-  \/\/ (hdr -sp) & (aligned_mask - page_size)\n-  \/\/\n-  \/\/ assuming both the stack pointer and page_size have their least\n-  \/\/ significant 2 bits cleared and page_size is a power of 2\n-  sub(hdr, hdr, sp);\n-  mv(t0, aligned_mask - os::vm_page_size());\n-  andr(hdr, hdr, t0);\n-  \/\/ for recursive locking, the result is zero => save it in the displaced header\n-  \/\/ location (NULL in the displaced hdr location indicates recursive locking)\n-  sd(hdr, Address(disp_hdr, 0));\n-  \/\/ otherwise we don't care about the result and handle locking via runtime call\n-  bnez(hdr, slow_case, \/* is_far *\/ true);\n-  bind(done);\n+  ld(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  fast_lock(obj, hdr, disp_hdr, t0, t1, slow_case);\n+\n@@ -114,2 +80,1 @@\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n-  Label done;\n+  assert_different_registers(hdr, obj, disp_hdr);\n@@ -117,7 +82,0 @@\n-  \/\/ load displaced header\n-  ld(hdr, Address(disp_hdr, 0));\n-  \/\/ if the loaded hdr is NULL we had recursive locking\n-  \/\/ if we had recursive locking, we are done\n-  beqz(hdr, done);\n-  \/\/ load object\n-  ld(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n@@ -125,12 +83,3 @@\n-  \/\/ test if object header is pointing to the displaced header, and if so, restore\n-  \/\/ the displaced header in the object - if the object header is not pointing to\n-  \/\/ the displaced header, get the object header instead\n-  \/\/ if the object header was not pointing to the displaced header,\n-  \/\/ we do unlocking via runtime call\n-  if (hdr_offset) {\n-    la(t0, Address(obj, hdr_offset));\n-    cmpxchgptr(disp_hdr, hdr, t0, t1, done, &slow_case);\n-  } else {\n-    cmpxchgptr(disp_hdr, hdr, obj, t1, done, &slow_case);\n-  }\n-  bind(done);\n+\n+  ld(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  fast_unlock(obj, hdr, t0, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":7,"deletions":58,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -886,2 +886,1 @@\n-        f.load_argument(1, x10); \/\/ x10: object\n-        f.load_argument(0, x11); \/\/ x11: lock address\n+        f.load_argument(0, x10); \/\/ x10: object\n@@ -889,1 +888,1 @@\n-        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorenter), x10, x11);\n+        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorenter), x10);\n@@ -908,1 +907,1 @@\n-        f.load_argument(0, x10); \/\/ x10: lock address\n+        f.load_argument(0, x10); \/\/ x10: object\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -781,0 +781,7 @@\n+\n+  const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n+  const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n+\n+  \/\/ Load object pointer into obj_reg c_rarg3\n+  ld(obj_reg, Address(lock_reg, obj_offset));\n+\n@@ -784,1 +791,1 @@\n-            lock_reg);\n+            obj_reg);\n@@ -790,6 +797,0 @@\n-    const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n-\n-    const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n-    const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();\n-    const int mark_offset = lock_offset +\n-                            BasicLock::displaced_header_offset_in_bytes();\n@@ -799,3 +800,0 @@\n-    \/\/ Load object pointer into obj_reg c_rarg3\n-    ld(obj_reg, Address(lock_reg, obj_offset));\n-\n@@ -809,28 +807,3 @@\n-    \/\/ Load (object->mark() | 1) into swap_reg\n-    ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-    ori(swap_reg, t0, 1);\n-\n-    \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-    sd(swap_reg, Address(lock_reg, mark_offset));\n-\n-    assert(lock_offset == 0,\n-           \"displached header must be first word in BasicObjectLock\");\n-\n-    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, t0, done, \/*fallthrough*\/NULL);\n-\n-    \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-    \/\/  1) (mark & 7) == 0, and\n-    \/\/  2) sp <= mark < mark + os::pagesize()\n-    \/\/\n-    \/\/ These 3 tests can be done by evaluating the following\n-    \/\/ expression: ((mark - sp) & (7 - os::vm_page_size())),\n-    \/\/ assuming both stack pointer and pagesize have their\n-    \/\/ least significant 3 bits clear.\n-    \/\/ NOTE: the oopMark is in swap_reg x10 as the result of cmpxchg\n-    sub(swap_reg, swap_reg, sp);\n-    mv(t0, (int64_t)(7 - os::vm_page_size()));\n-    andr(swap_reg, swap_reg, t0);\n-\n-    \/\/ Save the test result, for recursive case, the result is zero\n-    sd(swap_reg, Address(lock_reg, mark_offset));\n-    beqz(swap_reg, done);\n+    ld(tmp, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+    fast_lock(obj_reg, tmp, t0, swap_reg, t1, slow_case);\n+    j(done);\n@@ -843,1 +816,1 @@\n-            lock_reg);\n+            obj_reg);\n@@ -865,0 +838,8 @@\n+  const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n+\n+  \/\/ Load oop into obj_reg(c_rarg3)\n+  ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+\n+  \/\/ Free entry\n+  sd(zr, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+\n@@ -866,1 +847,1 @@\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), obj_reg);\n@@ -868,1 +849,1 @@\n-    Label done;\n+    Label done, slow_case;\n@@ -872,1 +853,0 @@\n-    const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n@@ -876,6 +856,4 @@\n-    \/\/ Convert from BasicObjectLock structure to object and BasicLock\n-    \/\/ structure Store the BasicLock address into x10\n-    la(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));\n-\n-    \/\/ Load oop into obj_reg(c_rarg3)\n-    ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+    \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n+    \/\/ must handle it.\n+    ld(header_reg, Address(xthread, Thread::lock_stack_current_offset()));\n+    bne(header_reg, obj_reg, slow_case);\n@@ -883,12 +861,3 @@\n-    \/\/ Free entry\n-    sd(zr, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n-\n-    \/\/ Load the old header from BasicLock structure\n-    ld(header_reg, Address(swap_reg,\n-                           BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ Test for recursion\n-    beqz(header_reg, done);\n-\n-    \/\/ Atomic swap back the old header\n-    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, t0, done, \/*fallthrough*\/NULL);\n+    ld(header_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+    fast_unlock(obj_reg, header_reg, swap_reg, t0, slow_case);\n+    j(done);\n@@ -897,2 +866,2 @@\n-    sd(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes())); \/\/ restore obj\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n+    bind(slow_case);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), obj_reg);\n@@ -901,1 +870,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":31,"deletions":63,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2178,6 +2178,0 @@\n-void MacroAssembler::cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,\n-                                        Label &succeed, Label *fail) {\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"assumption\");\n-  cmpxchgptr(oldv, newv, obj, tmp, succeed, fail);\n-}\n-\n@@ -4153,0 +4147,51 @@\n+\n+\/\/ Attempt to fast-lock an object. Fall-through on success, branch to slow label\n+\/\/ on failure.\n+\/\/ Registers:\n+\/\/  - obj: the object to be locked\n+\/\/  - hdr: the header, already loaded from obj, will be destroyed\n+\/\/  - t1, t2, t3: temporary registers, will be destroyed\n+void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Register t3, Label& slow) {\n+  \/\/ Check if we would have space on lock-stack for the object.\n+  ld(t1, Address(xthread, Thread::lock_stack_current_offset()));\n+  ld(t2, Address(xthread, Thread::lock_stack_limit_offset()));\n+\n+  \/\/ Cannot use bge(..., slow) here, because \"slow\" is too far away.\n+  Label ok;\n+  blt(t1, t2, ok);\n+  j(slow);\n+  bind(ok);\n+\n+  \/\/ Load (object->mark() | 1) into hdr\n+  ori(hdr, hdr, markWord::unlocked_value);\n+  \/\/ Clear lock-bits, into t2\n+  xori(t2, hdr, markWord::unlocked_value);\n+  \/\/ Try to swing header from unlocked to locked\n+  Label success;\n+  cmpxchgptr(hdr, t2, obj, t3, success, &slow);\n+  bind(success);\n+\n+  \/\/ After successful lock, push object on lock-stack\n+  sd(obj, Address(t1, 0));\n+  add(t1, t1, oopSize);\n+  sd(t1, Address(xthread, Thread::lock_stack_current_offset()));\n+}\n+\n+void MacroAssembler::fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+  \/\/ Load the expected old header (lock-bits cleared to indicate 'locked') into hdr\n+  li(t1, ~markWord::lock_mask_in_place);\n+  andr(hdr, hdr, t1);\n+\n+  \/\/ Load the new header (unlocked) into t1\n+  ori(t1, hdr, markWord::unlocked_value);\n+\n+  \/\/ Try to swing header from locked to unlocked\n+  Label success;\n+  cmpxchgptr(hdr, t1, obj, t2, success, &slow);\n+  bind(success);\n+\n+  \/\/ After successful unlock, pop object from lock-stack\n+  ld(t1, Address(xthread, Thread::lock_stack_current_offset()));\n+  sub(t1, t1, oopSize);\n+  sd(t1, Address(xthread, Thread::lock_stack_current_offset()));\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":51,"deletions":6,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -559,1 +559,0 @@\n-  void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp, Label &succeed, Label *fail);\n@@ -931,0 +930,4 @@\n+\n+public:\n+  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Register t3, Label& slow);\n+  void fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2381,2 +2381,2 @@\n-      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-      __ ori(tmp, disp_hdr, markWord::unlocked_value);\n+      Label slow;\n+      __ fast_lock(oop, disp_hdr, box, tmp, t0, slow);\n@@ -2384,8 +2384,1 @@\n-      \/\/ Initialize the box. (Must happen before we update the object mark!)\n-      __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Compare object markWord with an unlocked value (tmp) and if\n-      \/\/ equal exchange the stack address of our box with object markWord.\n-      \/\/ On failure disp_hdr contains the possibly locked markWord.\n-      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64, Assembler::aq,\n-                 Assembler::rl, \/*result*\/disp_hdr);\n+      \/\/ Indicate success at cont.\n@@ -2393,20 +2386,2 @@\n-      __ beq(disp_hdr, tmp, cont); \/\/ prepare zero flag and goto cont if we won the cas\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object, will have now locked it will continue at label cont\n-      \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-      \/\/ Check if the owner is self by comparing the value in the\n-      \/\/ markWord of object (disp_hdr) with the stack pointer.\n-      __ sub(disp_hdr, disp_hdr, sp);\n-      __ mv(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n-      \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto cont,\n-      \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n-      \/\/ recursive lock.\n-      __ andr(tmp\/*==0?*\/, disp_hdr, tmp);\n-      __ sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-      __ mv(flag, tmp); \/\/ we can use the value of tmp as the result here\n-    } else {\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n+      __ j(cont);\n+      __ bind(slow);\n@@ -2415,0 +2390,1 @@\n+    __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n@@ -2427,7 +2403,0 @@\n-    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-    \/\/ lock. The fast-path monitor unlock code checks for\n-    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-    \/\/ relevant bit set, and also matches ObjectSynchronizer::slow_enter.\n-    __ mv(tmp, (address)markWord::unused_mark().value());\n-    __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n@@ -2460,9 +2429,0 @@\n-    if (!UseHeavyMonitors) {\n-      \/\/ Find the lock address and load the displaced header from the stack.\n-      __ ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ If the displaced header is 0, we have a recursive unlock.\n-      __ mv(flag, disp_hdr);\n-      __ beqz(disp_hdr, cont);\n-    }\n-\n@@ -2471,2 +2431,2 @@\n-    __ andi(t0, disp_hdr, markWord::monitor_value);\n-    __ bnez(t0, object_has_monitor);\n+\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n@@ -2475,3 +2435,3 @@\n-      \/\/ Check if it is still a light weight lock, this is true if we\n-      \/\/ see the stack address of the basicLock in the markWord of the\n-      \/\/ object.\n+      Label slow;\n+      __ andi(t0, disp_hdr, markWord::monitor_value);\n+      __ bnez(t0, object_has_monitor);\n@@ -2479,5 +2439,6 @@\n-      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64, Assembler::relaxed,\n-                 Assembler::rl, \/*result*\/tmp);\n-      __ xorr(flag, box, tmp); \/\/ box == tmp if cas succeeds\n-    } else {\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n+      __ fast_unlock(oop, tmp, box, disp_hdr, slow);\n+\n+      \/\/ Indicate success at cont.\n+      __ mv(flag, zr);\n+      __ j(cont);\n+      __ bind(slow);\n@@ -2485,1 +2446,0 @@\n-    __ j(cont);\n@@ -2487,1 +2447,2 @@\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+    __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n+    __ j(cont);\n@@ -2493,0 +2454,15 @@\n+\n+    \/\/ If the owner is anonymous, we need to fix it -- in the slow-path.\n+    {\n+      Label L;\n+      __ ld(disp_hdr, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n+      __ push_reg(tmp);\n+      __ li(tmp, (unsigned char)(intptr_t) ANONYMOUS_OWNER);\n+      __ bne(disp_hdr, tmp, L);\n+      __ mv(flag, 1); \/\/ Indicate failure at cont -- dive into slow-path.\n+      __ pop_reg(tmp);\n+      __ j(cont);\n+      __ bind(L);\n+      __ pop_reg(tmp);\n+    }\n+\n@@ -10397,2 +10373,2 @@\n-  match(Set cr (FastLock object box));\n-  effect(TEMP tmp1, TEMP tmp2);\n+  match(Set cr (FastLock object));\n+  effect(TEMP box, TEMP tmp1, TEMP tmp2);\n@@ -10411,2 +10387,2 @@\n-  match(Set cr (FastUnlock object box));\n-  effect(TEMP tmp1, TEMP tmp2);\n+  match(Set cr (FastUnlock object));\n+  effect(TEMP box, TEMP tmp1, TEMP tmp2);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":38,"deletions":62,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -957,1 +957,0 @@\n-                                       in_ByteSize(-1),\n@@ -1013,1 +1012,0 @@\n-  int lock_slot_offset = 0;\n@@ -1026,1 +1024,0 @@\n-    lock_slot_offset = stack_slots;\n@@ -1043,2 +1040,0 @@\n-  \/\/      | lock box (if sync)  |\n-  \/\/      |---------------------| <- lock_slot_offset\n@@ -1300,2 +1295,0 @@\n-    const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();\n-\n@@ -1305,4 +1298,0 @@\n-    \/\/ Get address of the box\n-\n-    __ la(lock_reg, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-\n@@ -1313,28 +1302,2 @@\n-      \/\/ Load (object->mark() | 1) into swap_reg % x10\n-      __ ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ ori(swap_reg, t0, 1);\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n-\n-      \/\/ src -> dest if dest == x10 else x10 <- dest\n-      {\n-        Label here;\n-        __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, lock_done, \/*fallthrough*\/NULL);\n-      }\n-\n-      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-      \/\/  1) (mark & 3) == 0, and\n-      \/\/  2) sp <= mark < mark + os::pagesize()\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 2 bits clear.\n-      \/\/ NOTE: the oopMark is in swap_reg % 10 as the result of cmpxchg\n-\n-      __ sub(swap_reg, swap_reg, sp);\n-      __ andi(swap_reg, swap_reg, 3 - os::vm_page_size());\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n-      __ bnez(swap_reg, slow_path_lock);\n+      __ ld(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ fast_lock(obj_reg, old_hdr, swap_reg, tmp, t0, slow_path_lock);\n@@ -1432,7 +1395,0 @@\n-    if (!UseHeavyMonitors) {\n-      \/\/ Simple recursive lock?\n-      __ ld(t0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      __ beqz(t0, done);\n-    }\n-\n-\n@@ -1445,9 +1401,2 @@\n-      \/\/ get address of the stack lock\n-      __ la(x10, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      \/\/  get old displaced header\n-      __ ld(old_hdr, Address(x10, 0));\n-\n-      \/\/ Atomic swap old header if oop still contains the stack lock\n-      Label succeed;\n-      __ cmpxchg_obj_header(x10, old_hdr, obj_reg, t0, succeed, &slow_path_unlock);\n-      __ bind(succeed);\n+      __ ld(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ fast_unlock(obj_reg, old_hdr, swap_reg, t0, slow_path_unlock);\n@@ -1522,2 +1471,1 @@\n-    __ mv(c_rarg1, lock_reg);\n-    __ mv(c_rarg2, xthread);\n+    __ mv(c_rarg1, xthread);\n@@ -1526,1 +1474,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), 3);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), 2);\n@@ -1548,2 +1496,1 @@\n-    __ mv(c_rarg2, xthread);\n-    __ la(c_rarg1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n+    __ mv(c_rarg1, xthread);\n@@ -1653,1 +1600,0 @@\n-                                            in_ByteSize(lock_slot_offset*VMRegImpl::stack_slot_size),\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":7,"deletions":61,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#ifdef AARCH64\n+#if defined(AARCH64) || defined(RISCV)\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}