{"files":[{"patch":"@@ -44,1 +44,0 @@\n-import jdk.internal.foreign.HeapMemorySegmentImpl;\n@@ -46,1 +45,1 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.SegmentFactories;\n@@ -1212,1 +1211,1 @@\n-        return HeapMemorySegmentImpl.OfByte.fromArray(byteArray);\n+        return SegmentFactories.fromArray(byteArray);\n@@ -1224,1 +1223,1 @@\n-        return HeapMemorySegmentImpl.OfChar.fromArray(charArray);\n+        return SegmentFactories.fromArray(charArray);\n@@ -1236,1 +1235,1 @@\n-        return HeapMemorySegmentImpl.OfShort.fromArray(shortArray);\n+        return SegmentFactories.fromArray(shortArray);\n@@ -1248,1 +1247,1 @@\n-        return HeapMemorySegmentImpl.OfInt.fromArray(intArray);\n+        return SegmentFactories.fromArray(intArray);\n@@ -1260,1 +1259,1 @@\n-        return HeapMemorySegmentImpl.OfFloat.fromArray(floatArray);\n+        return SegmentFactories.fromArray(floatArray);\n@@ -1272,1 +1271,1 @@\n-        return HeapMemorySegmentImpl.OfLong.fromArray(longArray);\n+        return SegmentFactories.fromArray(longArray);\n@@ -1284,1 +1283,1 @@\n-        return HeapMemorySegmentImpl.OfDouble.fromArray(doubleArray);\n+        return SegmentFactories.fromArray(doubleArray);\n@@ -1290,1 +1289,1 @@\n-    MemorySegment NULL = new NativeMemorySegmentImpl();\n+    MemorySegment NULL = MemorySegment.ofAddress(0L);\n@@ -1304,1 +1303,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, 0);\n+        return SegmentFactories.makeNativeSegmentUnchecked(address, 0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-                () -> cleanup.accept(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize)) :\n+                () -> cleanup.accept(SegmentFactories.makeNativeSegmentUnchecked(address(), newSize)) :\n@@ -156,1 +156,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize,\n+        return SegmentFactories.makeNativeSegmentUnchecked(address(), newSize,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentNoZeroing(byteSize, byteAlignment, session, shouldReserveMemory);\n+        return SegmentFactories.allocateSegment(byteSize, byteAlignment, session, shouldReserveMemory);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -51,1 +50,1 @@\n-public abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n+abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n@@ -113,7 +112,0 @@\n-        public static MemorySegment fromArray(byte[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -147,7 +139,0 @@\n-        public static MemorySegment fromArray(char[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -181,7 +166,0 @@\n-        public static MemorySegment fromArray(short[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -215,7 +193,0 @@\n-        public static MemorySegment fromArray(int[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -249,7 +220,0 @@\n-        public static MemorySegment fromArray(long[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -283,7 +247,0 @@\n-        public static MemorySegment fromArray(float[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -317,7 +274,0 @@\n-        public static MemorySegment fromArray(double[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":1,"deletions":51,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public final class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n+final class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.misc.VM;\n@@ -41,7 +40,1 @@\n-public sealed class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl permits MappedMemorySegmentImpl {\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n-    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n-    private static final long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n+sealed class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl permits MappedMemorySegmentImpl {\n@@ -113,68 +106,0 @@\n-\n-    \/\/ factories\n-\n-    public static MemorySegment makeNativeSegmentNoZeroing(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n-                                                  boolean shouldReserve) {\n-        sessionImpl.checkValidState();\n-        if (VM.isDirectMemoryPageAligned()) {\n-            byteAlignment = Math.max(byteAlignment, NIO_ACCESS.pageSize());\n-        }\n-        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n-                byteSize + (byteAlignment - 1) :\n-                byteSize);\n-\n-        if (shouldReserve) {\n-            NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n-        }\n-\n-        long buf = allocateMemoryWrapper(alignedSize);\n-        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n-                false, sessionImpl);\n-        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-            @Override\n-            public void cleanup() {\n-                UNSAFE.freeMemory(buf);\n-                if (shouldReserve) {\n-                    NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n-                }\n-            }\n-        });\n-        if (alignedSize != byteSize) {\n-            long delta = alignedBuf - buf;\n-            segment = segment.asSlice(delta, byteSize);\n-        }\n-        return segment;\n-    }\n-\n-    private static long allocateMemoryWrapper(long size) {\n-        try {\n-            return UNSAFE.allocateMemory(size);\n-        } catch (IllegalArgumentException ex) {\n-            throw new OutOfMemoryError();\n-        }\n-    }\n-\n-    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n-    \/\/ associated with MemorySegment::ofAddress.\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n-        if (action == null) {\n-            sessionImpl.checkValidState();\n-        } else {\n-            sessionImpl.addCloseAction(action);\n-        }\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n-    }\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n-        sessionImpl.checkValidState();\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n-    }\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n-        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":1,"deletions":76,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.access.foreign.UnmapperProxy;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfByte;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfChar;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfDouble;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfFloat;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfInt;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfLong;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfShort;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Objects;\n+\n+\/**\n+ * This class is used to retrieve concrete memory segment implementations, while making sure that classes\n+ * are initialized in the right order (that is, that {@code MemorySegment} is always initialized first).\n+ * See {@link SegmentFactories#ensureInitialized()}.\n+ *\/\n+public class SegmentFactories {\n+\n+    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n+    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n+    private static final long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n+    \/\/ associated with MemorySegment::ofAddress.\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n+        ensureInitialized();\n+        if (action == null) {\n+            sessionImpl.checkValidState();\n+        } else {\n+            sessionImpl.addCloseAction(action);\n+        }\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n+        ensureInitialized();\n+        sessionImpl.checkValidState();\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n+        ensureInitialized();\n+        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n+    }\n+\n+    public static MemorySegment fromArray(byte[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n+        return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(short[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n+        return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(int[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n+        return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(char[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n+        return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(float[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n+        return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(double[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n+        return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(long[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n+        return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment allocateSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                  boolean shouldReserve) {\n+        ensureInitialized();\n+        sessionImpl.checkValidState();\n+        if (VM.isDirectMemoryPageAligned()) {\n+            byteAlignment = Math.max(byteAlignment, AbstractMemorySegmentImpl.NIO_ACCESS.pageSize());\n+        }\n+        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n+                byteSize + (byteAlignment - 1) :\n+                byteSize);\n+\n+        if (shouldReserve) {\n+            AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n+        }\n+\n+        long buf = allocateMemoryWrapper(alignedSize);\n+        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n+                false, sessionImpl);\n+        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                UNSAFE.freeMemory(buf);\n+                if (shouldReserve) {\n+                    AbstractMemorySegmentImpl.NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                }\n+            }\n+        });\n+        if (alignedSize != byteSize) {\n+            long delta = alignedBuf - buf;\n+            segment = segment.asSlice(delta, byteSize);\n+        }\n+        return segment;\n+    }\n+\n+    private static long allocateMemoryWrapper(long size) {\n+        try {\n+            return UNSAFE.allocateMemory(size);\n+        } catch (IllegalArgumentException ex) {\n+            throw new OutOfMemoryError();\n+        }\n+    }\n+\n+    public static MemorySegment mapSegment(long size, UnmapperProxy unmapper, boolean readOnly, MemorySessionImpl sessionImpl) {\n+        ensureInitialized();\n+        if (unmapper != null) {\n+            AbstractMemorySegmentImpl segment =\n+                    new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n+                            readOnly, sessionImpl);\n+            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n+                    new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+                        @Override\n+                        public void cleanup() {\n+                            unmapper.unmap();\n+                        }\n+                    };\n+            sessionImpl.addOrCleanupIfFail(resource);\n+            return segment;\n+        } else {\n+            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n+        }\n+    }\n+\n+    \/\/ The method below needs to be called before any concrete subclass of MemorySegment\n+    \/\/ is instantiated. This is to make sure that we cannot have an initialization deadlock\n+    \/\/ where one thread attempts to initialize e.g. MemorySegment (and then NativeMemorySegmentImpl, via\n+    \/\/ the MemorySegment.NULL field) while another thread is attempting to initialize\n+    \/\/ NativeMemorySegmentImpl (and then MemorySegment, the super-interface).\n+    @ForceInline\n+    private static void ensureInitialized() {\n+        MemorySegment segment = MemorySegment.NULL;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -151,1 +151,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size);\n+        return SegmentFactories.makeNativeSegmentUnchecked(addr, size);\n@@ -159,1 +159,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size, scope);\n+        return SegmentFactories.makeNativeSegmentUnchecked(addr, size, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n@@ -56,0 +54,1 @@\n+import jdk.internal.foreign.SegmentFactories;\n@@ -1338,16 +1337,1 @@\n-        if (unmapper != null) {\n-            AbstractMemorySegmentImpl segment =\n-                new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n-                                            readOnly, sessionImpl);\n-            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n-                new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-                    @Override\n-                    public void cleanup() {\n-                        unmapper.unmap();\n-                    }\n-                };\n-            sessionImpl.addOrCleanupIfFail(resource);\n-            return segment;\n-        } else {\n-            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n-        }\n+        return SegmentFactories.mapSegment(size, unmapper, readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -72,3 +72,0 @@\n-import jdk.internal.foreign.HeapMemorySegmentImpl;\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -990,3 +987,3 @@\n-        Predicate<MemorySegment> heapTest = segment -> segment instanceof HeapMemorySegmentImpl;\n-        Predicate<MemorySegment> nativeTest = segment -> segment instanceof NativeMemorySegmentImpl;\n-        Predicate<MemorySegment> mappedTest = segment -> segment instanceof MappedMemorySegmentImpl;\n+        Predicate<MemorySegment> heapTest = segment -> !segment.isNative() && !segment.isMapped();\n+        Predicate<MemorySegment> nativeTest = segment -> segment.isNative() && !segment.isMapped();\n+        Predicate<MemorySegment> mappedTest = segment -> segment.isNative() && segment.isMapped();\n@@ -1004,1 +1001,1 @@\n-                            nativeTest \/* this seems to be an existing bug in the BB implementation *\/ }\n+                            mappedTest }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Arena_allocateFrom\n+ * @run main\/othervm\/timeout=5 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n+ *\/\n+\n+\/*\n+ * @test id=FileChannel_map\n+ * @run main\/othervm\/timeout=5 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock FileChannel\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class TestDeadlock {\n+    public static void main(String[] args) throws Throwable {\n+        CountDownLatch latch = new CountDownLatch(2);\n+\n+        Runnable tester = switch (args[0]) {\n+            case \"Arena\" -> () -> {\n+                Arena arena = Arena.global();\n+                arena.scope(); \/\/ init ArenaImpl\n+                ValueLayout.JAVA_INT.byteSize(); \/\/ init ValueLayout (and impls)\n+                latch.countDown();\n+                try {\n+                    latch.await();\n+                } catch(InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                \/\/ Access ArenaImpl -> NativeMemorySegmentImpl -> MemorySegment\n+                arena.allocateFrom(ValueLayout.JAVA_INT, 42);\n+            };\n+            case \"FileChannel\" -> () -> {\n+                try {\n+                    Arena arena = Arena.global();\n+                    Path p = Files.createFile(Path.of(\"test.out\"));\n+\n+                    try (FileChannel channel = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                        channel.map(FileChannel.MapMode.READ_WRITE, 0, 4); \/\/ create MappedByteBuffer to initialize other things\n+                        latch.countDown();\n+                        latch.await();\n+\n+                        \/\/ Access MappedMemorySegmentImpl -> MemorySegment\n+                        channel.map(FileChannel.MapMode.READ_WRITE, 0, 4, arena);\n+                    }\n+                } catch(InterruptedException | IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            };\n+            default -> throw new IllegalArgumentException(\"Unknown test selection: \" + args[0]);\n+        };\n+\n+        Thread t1 = Thread.ofPlatform().start(tester);\n+        Thread t2 = Thread.ofPlatform().start(() -> {\n+            latch.countDown();\n+            try {\n+                latch.await();\n+            } catch(InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            \/\/ Access MemorySegment -> NativeMemorySegmentImpl\n+            MemorySegment.ofAddress(42);\n+        });\n+\n+        \/\/ wait for potential deadlock\n+\n+        t1.join();\n+        t2.join();\n+\n+        \/\/ all good\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestDeadlock.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -242,1 +241,1 @@\n-                assertEquals(segment.isNative(), segment instanceof NativeMemorySegmentImpl);\n+                assertTrue(segment.isNative());\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}