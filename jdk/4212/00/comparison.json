{"files":[{"patch":"@@ -1100,0 +1100,4 @@\n+  if (receiver_type == NULL) {\n+    return NULL; \/\/ no receiver type info\n+  }\n+\n@@ -1103,8 +1107,7 @@\n-  if (receiver_type != NULL) {\n-    \/\/ Array methods are all inherited from Object, and are monomorphic.\n-    \/\/ finalize() call on array is not allowed.\n-    if (receiver_type->isa_aryptr() &&\n-        callee->holder() == env()->Object_klass() &&\n-        callee->name() != ciSymbols::finalize_method_name()) {\n-      return callee;\n-    }\n+  \/\/ Array methods are all inherited from Object, and are monomorphic.\n+  \/\/ finalize() call on array is not allowed.\n+  if (receiver_type->isa_aryptr() &&\n+      callee->holder() == env()->Object_klass() &&\n+      callee->name() != ciSymbols::finalize_method_name()) {\n+    return callee;\n+  }\n@@ -1112,4 +1115,4 @@\n-    \/\/ All other interesting cases are instance klasses.\n-    if (!receiver_type->isa_instptr()) {\n-      return NULL;\n-    }\n+  \/\/ All other interesting cases are instance klasses.\n+  if (!receiver_type->isa_instptr()) {\n+    return NULL;\n+  }\n@@ -1117,9 +1120,8 @@\n-    ciInstanceKlass *ikl = receiver_type->klass()->as_instance_klass();\n-    if (ikl->is_loaded() && ikl->is_initialized() && !ikl->is_interface() &&\n-        (ikl == actual_receiver || ikl->is_subtype_of(actual_receiver))) {\n-      \/\/ ikl is a same or better type than the original actual_receiver,\n-      \/\/ e.g. static receiver from bytecodes.\n-      actual_receiver = ikl;\n-      \/\/ Is the actual_receiver exact?\n-      actual_receiver_is_exact = receiver_type->klass_is_exact();\n-    }\n+  ciInstanceKlass *ikl = receiver_type->klass()->as_instance_klass();\n+  if (ikl->is_loaded() && ikl->is_initialized() && !ikl->is_interface() &&\n+      (ikl == actual_receiver || ikl->is_subtype_of(actual_receiver))) {\n+    \/\/ ikl is a same or better type than the original actual_receiver,\n+    \/\/ e.g. static receiver from bytecodes.\n+    actual_receiver = ikl;\n+    \/\/ Is the actual_receiver exact?\n+    actual_receiver_is_exact = receiver_type->klass_is_exact();\n@@ -1130,0 +1132,2 @@\n+\n+  \/\/ Validate receiver info against target method.\n@@ -1131,20 +1135,5 @@\n-    assert(!cha_monomorphic_target->is_abstract(), \"\");\n-    \/\/ Look at the method-receiver type.  Does it add \"too much information\"?\n-    ciKlass*    mr_klass = cha_monomorphic_target->holder();\n-    const Type* mr_type  = TypeInstPtr::make(TypePtr::BotPTR, mr_klass);\n-    if (receiver_type == NULL || !receiver_type->higher_equal(mr_type)) {\n-      \/\/ Calling this method would include an implicit cast to its holder.\n-      \/\/ %%% Not yet implemented.  Would throw minor asserts at present.\n-      \/\/ %%% The most common wins are already gained by +UseUniqueSubclasses.\n-      \/\/ To fix, put the higher_equal check at the call of this routine,\n-      \/\/ and add a CheckCastPP to the receiver.\n-      if (TraceDependencies) {\n-        tty->print_cr(\"found unique CHA method, but could not cast up\");\n-        tty->print(\"  method  = \");\n-        cha_monomorphic_target->print();\n-        tty->cr();\n-      }\n-      if (log() != NULL) {\n-        log()->elem(\"missed_CHA_opportunity klass='%d' method='%d'\",\n-                       log()->identify(klass),\n-                       log()->identify(cha_monomorphic_target));\n+    bool has_receiver = !cha_monomorphic_target->is_static();\n+    bool is_interface_holder = cha_monomorphic_target->holder()->is_interface();\n+    if (has_receiver && !is_interface_holder) {\n+      if (!cha_monomorphic_target->holder()->is_subtype_of(receiver_type->klass())) {\n+        cha_monomorphic_target = NULL; \/\/ not a subtype\n@@ -1152,1 +1141,0 @@\n-      cha_monomorphic_target = NULL;\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":30,"deletions":42,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"opto\/type.hpp\"\n@@ -1195,0 +1196,36 @@\n+  \/\/ Narrow receiver type when it is too broad for the method being parsed.\n+  ciInstanceKlass* callee_holder = method()->holder();\n+  if (!method()->is_static()) {\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n+\n+    Node* receiver_obj = local(0);\n+    const TypeInstPtr* receiver_type = _gvn.type(receiver_obj)->isa_instptr();\n+\n+    if (receiver_type != NULL && !receiver_type->higher_equal(holder_type)) {\n+\n+#ifdef ASSERT\n+      \/\/ Perform dynamic receiver subtype check against callee holder class w\/ a halt on failure.\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n+      Node* not_subtype_ctrl = gen_subtype_check(receiver_obj, holder_klass);\n+      assert(!stopped(), \"not a subtype\");\n+\n+      Node* halt = _gvn.transform(new HaltNode(not_subtype_ctrl, frameptr(), \"failed receiver subtype check\"));\n+      C->root()->add_req(halt);\n+#endif \/\/ ASSERT\n+\n+      \/\/ Receiver should always be a subtype of callee holder.\n+      \/\/ But, since C2 type system doesn't properly track interfaces,\n+      \/\/ the invariant on default methods can't be expressed in the type system.\n+      \/\/ Example: for unrelated C <: I and D <: I, (C `meet` D) = Object <\/: I.\n+      \/\/ (Downcasting interface receiver type to concrete class is fine, though it doesn't happen in practice.)\n+      if (!callee_holder->is_interface()) {\n+        assert(callee_holder->is_subtype_of(receiver_type->klass()), \"sanity\");\n+        assert(!receiver_type->klass()->is_interface(), \"interface receiver type\");\n+        receiver_type = receiver_type->join_speculative(holder_type)->is_instptr(); \/\/ keep speculative part\n+        Node* casted_receiver_obj = _gvn.transform(new CheckCastPPNode(control(), receiver_obj, receiver_type));\n+        set_local(0, casted_receiver_obj);\n+      }\n+\n+    }\n+  }\n+\n@@ -1208,1 +1245,1 @@\n-    if(method()->is_static()) {\n+    if (method()->is_static()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"}]}