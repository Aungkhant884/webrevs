{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#include \"gc\/shared\/weakProcessorPhaseTimes.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -66,2 +68,2 @@\n-  int index = G1GCPhaseTimes::StrongOopStorageSetRoots;\n-  for (OopStorageSet::Iterator it = OopStorageSet::strong_iterator(); !it.is_end(); ++it, ++index) {\n+  for (auto id : EnumRange<OopStorageSet::StrongId>()) {\n+    GCParPhases phase = strong_oopstorage_phase(id);\n@@ -69,2 +71,3 @@\n-    char* oop_storage_phase_name = NEW_C_HEAP_ARRAY(char, strlen(phase_name_postfix) + strlen(it->name()) + 1, mtGC);\n-    strcpy(oop_storage_phase_name, it->name());\n+    const char* storage_name = OopStorageSet::storage(id)->name();\n+    char* oop_storage_phase_name = NEW_C_HEAP_ARRAY(char, strlen(phase_name_postfix) + strlen(storage_name) + 1, mtGC);\n+    strcpy(oop_storage_phase_name, storage_name);\n@@ -72,1 +75,1 @@\n-    _gc_par_phases[index] = new WorkerDataArray<double>(it->name(), oop_storage_phase_name, max_gc_threads);\n+    _gc_par_phases[phase] = new WorkerDataArray<double>(storage_name, oop_storage_phase_name, max_gc_threads);\n@@ -489,1 +492,2 @@\n-  _weak_phase_times.log_print(2);\n+  _weak_phase_times.log_total(2);\n+  _weak_phase_times.log_subtotals(3);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/weakProcessorPhaseTimes.hpp\"\n+#include \"gc\/shared\/weakProcessorTimes.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -54,2 +55,2 @@\n-    \/\/ For every OopStorage there will be one element in the enum, starting with\n-    \/\/ StrongOopStorageSetRoots.\n+    \/\/ For every strong OopStorage there will be one element in this enum,\n+    \/\/ starting with StrongOopStorageSetRoots.\n@@ -57,1 +58,1 @@\n-    MergeER = StrongOopStorageSetRoots + OopStorageSet::strong_count,\n+    MergeER = StrongOopStorageSetRoots + EnumRange<OopStorageSet::StrongId>().size(),\n@@ -87,0 +88,5 @@\n+  static constexpr GCParPhases strong_oopstorage_phase(OopStorageSet::StrongId id) {\n+    size_t index = EnumRange<OopStorageSet::StrongId>().index(id);\n+    return GCParPhases(StrongOopStorageSetRoots + index);\n+  }\n+\n@@ -190,1 +196,1 @@\n-  WeakProcessorPhaseTimes _weak_phase_times;\n+  WeakProcessorTimes _weak_phase_times;\n@@ -439,1 +445,1 @@\n-  WeakProcessorPhaseTimes* weak_phase_times() { return &_weak_phase_times; }\n+  WeakProcessorTimes* weak_phase_times() { return &_weak_phase_times; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -192,2 +193,2 @@\n-  for (int i = 0; i < _oop_storage_set_strong_par_state.par_state_count(); ++i) {\n-    G1GCPhaseTimes::GCParPhases phase = G1GCPhaseTimes::GCParPhases(G1GCPhaseTimes::StrongOopStorageSetRoots + i);\n+  for (auto id : EnumRange<OopStorageSet::StrongId>()) {\n+    G1GCPhaseTimes::GCParPhases phase = G1GCPhaseTimes::strong_oopstorage_phase(id);\n@@ -195,1 +196,1 @@\n-    _oop_storage_set_strong_par_state.par_state(i)->oops_do(closures->strong_oops());\n+    _oop_storage_set_strong_par_state.par_state(id)->oops_do(closures->strong_oops());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,1 @@\n-\/\/ +1 for NULL singular entry.\n-OopStorage* OopStorageSet::storages[all_count + 1] = {};\n+OopStorage* OopStorageSet::_storages[all_count] = {};\n@@ -39,1 +38,1 @@\n-  storages[strong_start + registered_strong++] = storage;\n+  _storages[strong_start + registered_strong++] = storage;\n@@ -47,1 +46,1 @@\n-  storages[weak_start + registered_weak++] = storage;\n+  _storages[weak_start + registered_weak++] = storage;\n@@ -54,1 +53,1 @@\n-    to[i] = storage(strong_start + i);\n+    to[i] = get_storage(strong_start + i);\n@@ -60,1 +59,1 @@\n-    to[i] = storage(weak_start + i);\n+    to[i] = get_storage(weak_start + i);\n@@ -66,1 +65,1 @@\n-    to[i] = storage(all_start + i);\n+    to[i] = get_storage(all_start + i);\n@@ -70,4 +69,3 @@\n-#ifdef ASSERT\n-\n-void OopStorageSet::verify_initialized(uint index) {\n-  assert(storages[index] != NULL, \"oopstorage_init not yet called\");\n+OopStorage* OopStorageSet::get_storage(uint index) {\n+  verify_initialized(index);\n+  return _storages[index];\n@@ -76,2 +74,5 @@\n-void OopStorageSet::Iterator::verify_nonsingular() const {\n-  assert(_category != singular, \"precondition\");\n+template<typename E>\n+OopStorage* OopStorageSet::get_storage(E id) {\n+  assert(EnumRange<E>().first() <= id, \"invalid id\");\n+  assert(id <= EnumRange<E>().last(), \"invalid id\");\n+  return get_storage(static_cast<uint>(id));\n@@ -80,4 +81,3 @@\n-void OopStorageSet::Iterator::verify_category_match(const Iterator& other) const {\n-  verify_nonsingular();\n-  assert(_category == other._category, \"precondition\");\n-}\n+template OopStorage* OopStorageSet::get_storage(StrongId);\n+template OopStorage* OopStorageSet::get_storage(WeakId);\n+template OopStorage* OopStorageSet::get_storage(Id);\n@@ -85,3 +85,5 @@\n-void OopStorageSet::Iterator::verify_dereferenceable() const {\n-  verify_nonsingular();\n-  assert(!is_end(), \"precondition\");\n+#ifdef ASSERT\n+\n+void OopStorageSet::verify_initialized(uint index) {\n+  assert(index < ARRAY_SIZE(_storages), \"invalid index\");\n+  assert(_storages[index] != NULL, \"oopstorage_init not yet called\");\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.cpp","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -38,1 +39,0 @@\n-public:\n@@ -42,0 +42,1 @@\n+\n@@ -43,0 +44,2 @@\n+  static const uint all_start = 0;\n+  static const uint all_end = all_start + all_count;\n@@ -44,3 +47,0 @@\n-private:\n-  static const uint singular_index = 0; \/\/ For singular iterator.\n-  static const uint all_start = 1;\n@@ -49,0 +49,1 @@\n+\n@@ -51,1 +52,1 @@\n-  static const uint all_end = weak_end;\n+  static_assert(all_end == weak_end, \"invariant\");\n@@ -53,1 +54,1 @@\n-  static OopStorage* storages[all_end];\n+  static OopStorage* _storages[all_count];\n@@ -57,4 +58,4 @@\n-  static OopStorage* storage(uint index) {\n-    verify_initialized(index);\n-    return storages[index];\n-  }\n+  static OopStorage* get_storage(uint index);\n+\n+  template<typename E>\n+  static OopStorage* get_storage(E id);\n@@ -68,1 +69,3 @@\n-  class Iterator;\n+  enum class StrongId : uint {}; \/\/ [strong_start, strong_end)\n+  enum class WeakId : uint {};   \/\/ [weak_start, weak_end)\n+  enum class Id : uint {};       \/\/ [all_start, all_end)\n@@ -70,3 +73,8 @@\n-  static Iterator strong_iterator();\n-  static Iterator weak_iterator();\n-  static Iterator all_iterator();\n+  \/\/ Give these access to the private start\/end\/count constants.\n+  friend struct EnumeratorRange<StrongId>;\n+  friend struct EnumeratorRange<WeakId>;\n+  friend struct EnumeratorRange<Id>;\n+\n+  static OopStorage* storage(StrongId id) { return get_storage(id); }\n+  static OopStorage* storage(WeakId id) { return get_storage(id); }\n+  static OopStorage* storage(Id id) { return get_storage(id); }\n@@ -77,0 +85,4 @@\n+  \/\/ Support iteration over the storage objects.\n+  template<typename StorageId> class Range;\n+  template<typename StorageId> class Iterator;\n+\n@@ -79,1 +91,0 @@\n-};\n@@ -81,2 +92,1 @@\n-class OopStorageSet::Iterator {\n-  friend class OopStorageSet;\n+};\n@@ -84,1 +94,3 @@\n-  enum Category { singular, strong, weak, all };\n+ENUMERATOR_VALUE_RANGE(OopStorageSet::StrongId,\n+                       OopStorageSet::strong_start,\n+                       OopStorageSet::strong_end);\n@@ -86,3 +98,3 @@\n-  uint _index;\n-  uint _limit;\n-  DEBUG_ONLY(Category _category;)\n+ENUMERATOR_VALUE_RANGE(OopStorageSet::WeakId,\n+                       OopStorageSet::weak_start,\n+                       OopStorageSet::weak_end);\n@@ -90,2 +102,3 @@\n-  Iterator(uint index, uint limit, Category category) :\n-    _index(index), _limit(limit) DEBUG_ONLY(COMMA _category(category)) {}\n+ENUMERATOR_VALUE_RANGE(OopStorageSet::Id,\n+                       OopStorageSet::all_start,\n+                       OopStorageSet::all_end);\n@@ -93,3 +106,3 @@\n-  void verify_nonsingular() const NOT_DEBUG_RETURN;\n-  void verify_category_match(const Iterator& other) const NOT_DEBUG_RETURN;\n-  void verify_dereferenceable() const NOT_DEBUG_RETURN;\n+template<typename StorageId>\n+class OopStorageSet::Iterator {\n+  EnumIterator<StorageId> _it;\n@@ -98,54 +111,5 @@\n-  \/\/ Construct a singular iterator for later assignment.  The only valid\n-  \/\/ operations are destruction and assignment.\n-  Iterator() :\n-    _index(singular_index),\n-    _limit(singular_index)\n-    DEBUG_ONLY(COMMA _category(singular)) {}\n-\n-  bool is_end() const {\n-    verify_nonsingular();\n-    return _index == _limit;\n-  }\n-\n-  bool operator==(const Iterator& other) const {\n-    verify_category_match(other);\n-    return _index == other._index;\n-  }\n-\n-  bool operator!=(const Iterator& other) const {\n-    return !operator==(other);\n-  }\n-\n-  OopStorage* operator*() const {\n-    verify_dereferenceable();\n-    return storage(_index);\n-  }\n-\n-  OopStorage* operator->() const {\n-    return operator*();\n-  }\n-\n-  Iterator& operator++() {\n-    verify_dereferenceable();\n-    ++_index;\n-    return *this;\n-  }\n-\n-  Iterator operator++(int) {\n-    Iterator result = *this;\n-    operator++();\n-    return result;\n-  }\n-\n-  Iterator begin() const {\n-    verify_nonsingular();\n-    return *this;\n-  }\n-\n-  Iterator end() const {\n-    verify_nonsingular();\n-    Iterator result = *this;\n-    result._index = _limit;\n-    return result;\n-  }\n-};\n+  constexpr Iterator() : _it() {}\n+  explicit constexpr Iterator(EnumIterator<StorageId> it) : _it(it) {}\n+\n+  constexpr bool operator==(Iterator other) const { return _it == other._it; }\n+  constexpr bool operator!=(Iterator other) const { return _it != other._it; }\n@@ -153,3 +117,2 @@\n-inline OopStorageSet::Iterator OopStorageSet::strong_iterator() {\n-  return Iterator(strong_start, strong_end, Iterator::strong);\n-}\n+  constexpr Iterator& operator++() { ++_it; return *this; }\n+  constexpr Iterator operator++(int) { Iterator i = *this; ++_it; return i; }\n@@ -157,3 +120,7 @@\n-inline OopStorageSet::Iterator OopStorageSet::weak_iterator() {\n-  return Iterator(weak_start, weak_end, Iterator::weak);\n-}\n+  OopStorage* operator*() const { return storage(*_it); }\n+  OopStorage* operator->() const { return operator*(); }\n+};\n+\n+template<typename StorageId>\n+class OopStorageSet::Range {\n+  EnumRange<StorageId> _range;\n@@ -161,3 +128,4 @@\n-inline OopStorageSet::Iterator OopStorageSet::all_iterator() {\n-  return Iterator(all_start, all_end, Iterator::all);\n-}\n+public:\n+  constexpr auto begin() const { return Iterator<StorageId>(_range.begin()); }\n+  constexpr auto end() const { return Iterator<StorageId>(_range.end()); }\n+};\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.hpp","additions":57,"deletions":89,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -33,2 +34,2 @@\n-  for (OopStorageSet::Iterator it = OopStorageSet::strong_iterator(); !it.is_end(); ++it) {\n-    (*it)->oops_do(cl);\n+  for (auto id : EnumRange<StrongId>()) {\n+    storage(id)->oops_do(cl);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"utilities\/enumIterator.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -32,7 +34,3 @@\n-template <bool concurrent, bool is_const>\n-class OopStorageSetStrongParState {\n-  typedef OopStorage::ParState<concurrent, is_const> ParStateType;\n-  typedef ValueObjArray<ParStateType, OopStorageSet::strong_count> ParStateArray;\n-\n-  ParStateArray _par_states;\n-\n+\/\/ Base class for OopStorageSet{Strong,Weak}ParState.\n+template<typename T, bool concurrent, bool is_const>\n+class OopStorageSetParState {\n@@ -40,1 +38,1 @@\n-  OopStorageSetStrongParState();\n+  using ParState = OopStorage::ParState<concurrent, is_const>;\n@@ -42,2 +40,3 @@\n-  template <typename Closure>\n-  void oops_do(Closure* cl);\n+  ParState* par_state(T id) const {\n+    return _par_states.at(checked_cast<int>(EnumRange<T>().index(id)));\n+  }\n@@ -45,3 +44,3 @@\n-  ParStateType* par_state(int i) const { return _par_states.at(i); }\n-  int par_state_count() const { return _par_states.count(); }\n-};\n+protected:\n+  OopStorageSetParState() : _par_states(OopStorageSet::Range<T>().begin()) {}\n+  ~OopStorageSetParState() = default;\n@@ -49,4 +48,2 @@\n-template <bool concurrent, bool is_const>\n-class OopStorageSetWeakParState {\n-  typedef OopStorage::ParState<concurrent, is_const> ParStateType;\n-  typedef ValueObjArray<ParStateType, OopStorageSet::weak_count> ParStateArray;\n+private:\n+  ValueObjArray<ParState, EnumRange<T>().size()> _par_states;\n@@ -54,1 +51,2 @@\n-  ParStateArray _par_states;\n+  NONCOPYABLE(OopStorageSetParState);\n+};\n@@ -56,0 +54,5 @@\n+\/\/ Set of strong parallel states.\n+template<bool concurrent, bool is_const>\n+class OopStorageSetStrongParState\n+  : public OopStorageSetParState<OopStorageSet::StrongId, concurrent, is_const>\n+{\n@@ -57,4 +60,3 @@\n-  OopStorageSetWeakParState();\n-\n-  template <typename ClosureType>\n-  void oops_do(ClosureType* cl);\n+  template<typename Closure>\n+  void oops_do(Closure* cl);\n+};\n@@ -62,2 +64,8 @@\n-  ParStateType* par_state(int i) const { return _par_states.at(i); }\n-  int par_state_count() const { return _par_states.count(); }\n+\/\/ Set of weak parallel states.\n+template<bool concurrent, bool is_const>\n+class OopStorageSetWeakParState\n+  : public OopStorageSetParState<OopStorageSet::WeakId, concurrent, is_const>\n+{\n+public:\n+  template<typename Closure>\n+  void oops_do(Closure* cl);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSetParState.hpp","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -35,10 +35,5 @@\n-template <bool concurrent, bool is_const>\n-OopStorageSetStrongParState<concurrent, is_const>::OopStorageSetStrongParState() :\n-    _par_states(OopStorageSet::strong_iterator()) {\n-}\n-\n-template <bool concurrent, bool is_const>\n-template <typename ClosureType>\n-void OopStorageSetStrongParState<concurrent, is_const>::oops_do(ClosureType* cl) {\n-  for (int i = 0; i < _par_states.count(); i++) {\n-    _par_states.at(i)->oops_do(cl);\n+template<bool concurrent, bool is_const>\n+template<typename Closure>\n+void OopStorageSetStrongParState<concurrent, is_const>::oops_do(Closure* cl) {\n+  for (auto id : EnumRange<OopStorageSet::StrongId>()) {\n+    this->par_state(id)->oops_do(cl);\n@@ -48,5 +43,0 @@\n-template <bool concurrent, bool is_const>\n-OopStorageSetWeakParState<concurrent, is_const>::OopStorageSetWeakParState() :\n-    _par_states(OopStorageSet::weak_iterator()) {\n-}\n-\n@@ -81,4 +71,4 @@\n-template <typename ClosureType>\n-void OopStorageSetWeakParState<concurrent, is_const>::oops_do(ClosureType* cl) {\n-  for (int i = 0; i < _par_states.count(); i++) {\n-    ParStateType* state = _par_states.at(i);\n+template <typename Closure>\n+void OopStorageSetWeakParState<concurrent, is_const>::oops_do(Closure* cl) {\n+  for (auto id : EnumRange<OopStorageSet::WeakId>()) {\n+    auto state = this->par_state(id);\n@@ -86,1 +76,1 @@\n-      DeadCounterClosure<ClosureType> counting_cl(cl);\n+      DeadCounterClosure<Closure> counting_cl(cl);\n@@ -97,2 +87,2 @@\n-  for (int i = 0; i < _par_states.count(); i++) {\n-    ParStateType* state = _par_states.at(i);\n+  for (auto id : EnumRange<OopStorageSet::WeakId>()) {\n+    auto state = this->par_state(id);\n@@ -102,0 +92,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSetParState.inline.hpp","additions":13,"deletions":22,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"gc\/shared\/weakProcessorPhaseTimes.hpp\"\n+#include \"gc\/shared\/weakProcessorTimes.hpp\"\n@@ -64,3 +64,2 @@\n-  OopStorageSet::Iterator it = OopStorageSet::weak_iterator();\n-  for ( ; !it.is_end(); ++it) {\n-    if (it->should_report_num_dead()) {\n+  for (OopStorage* storage : OopStorageSet::Range<OopStorageSet::WeakId>()) {\n+    if (storage->should_report_num_dead()) {\n@@ -68,2 +67,2 @@\n-      it->oops_do(&cl);\n-      it->report_num_dead(cl.dead());\n+      storage->oops_do(&cl);\n+      storage->report_num_dead(cl.dead());\n@@ -71,1 +70,1 @@\n-      it->weak_oops_do(is_alive, keep_alive);\n+      storage->weak_oops_do(is_alive, keep_alive);\n@@ -77,4 +76,2 @@\n-\n-  OopStorageSet::Iterator it = OopStorageSet::weak_iterator();\n-  for ( ; !it.is_end(); ++it) {\n-    it->weak_oops_do(closure);\n+  for (OopStorage* storage : OopStorageSet::Range<OopStorageSet::WeakId>()) {\n+    storage->weak_oops_do(closure);\n@@ -94,3 +91,2 @@\n-  OopStorageSet::Iterator it = OopStorageSet::weak_iterator();\n-  for ( ; !it.is_end(); ++it) {\n-    ref_count += it->allocation_count();\n+  for (OopStorage* storage : OopStorageSet::Range<OopStorageSet::WeakId>()) {\n+    ref_count += storage->allocation_count();\n@@ -107,1 +103,1 @@\n-  assert(_phase_times == NULL || _nworkers <= _phase_times->max_threads(),\n+  assert(_times == nullptr || _nworkers <= _times->max_threads(),\n@@ -109,1 +105,1 @@\n-         _nworkers, _phase_times->max_threads());\n+         _nworkers, _times->max_threads());\n@@ -111,2 +107,2 @@\n-  if (_phase_times) {\n-    _phase_times->set_active_workers(_nworkers);\n+  if (_times) {\n+    _times->set_active_workers(_nworkers);\n@@ -117,7 +113,1 @@\n-WeakProcessor::Task::Task(uint nworkers) :\n-  _phase_times(NULL),\n-  _nworkers(nworkers),\n-  _storage_states()\n-{\n-  initialize();\n-}\n+WeakProcessor::Task::Task(uint nworkers) : Task(nullptr, nworkers) {}\n@@ -125,2 +115,2 @@\n-WeakProcessor::Task::Task(WeakProcessorPhaseTimes* phase_times, uint nworkers) :\n-  _phase_times(phase_times),\n+WeakProcessor::Task::Task(WeakProcessorTimes* times, uint nworkers) :\n+  _times(times),\n@@ -134,4 +124,1 @@\n-  for (int i = 0; i < _storage_states.par_state_count(); ++i) {\n-    StorageState* state = _storage_states.par_state(i);\n-    state->report_num_dead();\n-  }\n+  _storage_states.report_num_dead();\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.cpp","additions":18,"deletions":31,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class WeakProcessorPhaseTimes;\n+class WeakProcessorTimes;\n@@ -58,1 +58,1 @@\n-                           WeakProcessorPhaseTimes* phase_times);\n+                           WeakProcessorTimes* times);\n@@ -83,1 +83,1 @@\n-  WeakProcessorPhaseTimes* _phase_times;\n+  WeakProcessorTimes* _times;\n@@ -91,1 +91,1 @@\n-  Task(WeakProcessorPhaseTimes* phase_times, uint nworkers);\n+  Task(WeakProcessorTimes* times, uint nworkers);\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n@@ -32,2 +33,1 @@\n-#include \"gc\/shared\/weakProcessorPhase.hpp\"\n-#include \"gc\/shared\/weakProcessorPhaseTimes.hpp\"\n+#include \"gc\/shared\/weakProcessorTimes.hpp\"\n@@ -37,0 +37,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -84,2 +85,1 @@\n-  constexpr EnumRange<WeakProcessorPhase> phase_range{};\n-  for (WeakProcessorPhase phase : phase_range) {\n+  for (auto id : EnumRange<OopStorageSet::WeakId>()) {\n@@ -87,3 +87,3 @@\n-    WeakProcessorPhaseTimeTracker pt(_phase_times, phase, worker_id);\n-    int state_index = checked_cast<int>(phase_range.index(phase));\n-    StorageState* cur_state = _storage_states.par_state(state_index);\n+    WeakProcessorParTimeTracker pt(_times, id, worker_id);\n+    StorageState* cur_state = _storage_states.par_state(id);\n+    assert(cur_state->storage() == OopStorageSet::storage(id), \"invariant\");\n@@ -92,2 +92,2 @@\n-    if (_phase_times != NULL) {\n-      _phase_times->record_worker_items(worker_id, phase, cl.new_dead(), cl.total());\n+    if (_times != NULL) {\n+      _times->record_worker_items(worker_id, id, cl.new_dead(), cl.total());\n@@ -116,1 +116,1 @@\n-           WeakProcessorPhaseTimes* phase_times,\n+           WeakProcessorTimes* times,\n@@ -119,1 +119,1 @@\n-    _task(phase_times, nworkers),\n+    _task(times, nworkers),\n@@ -133,2 +133,2 @@\n-                                 WeakProcessorPhaseTimes* phase_times) {\n-  WeakProcessorTimeTracker tt(phase_times);\n+                                 WeakProcessorTimes* times) {\n+  WeakProcessorTimeTracker tt(times);\n@@ -137,1 +137,1 @@\n-                                    phase_times->max_threads()));\n+                                    times->max_threads()));\n@@ -139,1 +139,1 @@\n-  GangTask task(\"Weak Processor\", is_alive, keep_alive, phase_times, nworkers);\n+  GangTask task(\"Weak Processor\", is_alive, keep_alive, times, nworkers);\n@@ -150,3 +150,3 @@\n-  WeakProcessorPhaseTimes pt(nworkers);\n-  weak_oops_do(workers, is_alive, keep_alive, &pt);\n-  pt.log_print_phases(indent_log);\n+  WeakProcessorTimes times(nworkers);\n+  weak_oops_do(workers, is_alive, keep_alive, &times);\n+  times.log_subtotals(indent_log); \/\/ Caller logs total if desired.\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.inline.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_WEAKPROCESSORPHASE_HPP\n-#define SHARE_GC_SHARED_WEAKPROCESSORPHASE_HPP\n-\n-#include \"gc\/shared\/oopStorageSet.hpp\"\n-#include \"utilities\/enumIterator.hpp\"\n-\n-enum class WeakProcessorPhase : uint {};\n-\n-ENUMERATOR_VALUE_RANGE(WeakProcessorPhase, 0, OopStorageSet::weak_count);\n-\n-#endif \/\/ SHARE_GC_SHARED_WEAKPROCESSORPHASE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorPhase.hpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,222 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/shared\/oopStorage.hpp\"\n-#include \"gc\/shared\/weakProcessorPhase.hpp\"\n-#include \"gc\/shared\/weakProcessorPhaseTimes.hpp\"\n-#include \"gc\/shared\/workerDataArray.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-const double uninitialized_time = -1.0;\n-\n-#ifdef ASSERT\n-static bool is_initialized_time(double t) { return t >= 0.0; }\n-#endif \/\/ ASSERT\n-\n-\n-WeakProcessorPhaseTimes::WeakProcessorPhaseTimes(uint max_threads) :\n-  _max_threads(max_threads),\n-  _active_workers(0),\n-  _total_time_sec(uninitialized_time),\n-  _worker_data()\n-{\n-  assert(_max_threads > 0, \"max_threads must not be zero\");\n-\n-  WorkerDataArray<double>** wpt = _worker_data;\n-  OopStorageSet::Iterator it = OopStorageSet::weak_iterator();\n-  for ( ; !it.is_end(); ++it) {\n-    assert(size_t(wpt - _worker_data) < ARRAY_SIZE(_worker_data), \"invariant\");\n-    const char* description = it->name();\n-    *wpt = new WorkerDataArray<double>(NULL, description, _max_threads);\n-    (*wpt)->create_thread_work_items(\"Dead\", DeadItems);\n-    (*wpt)->create_thread_work_items(\"Total\", TotalItems);\n-    wpt++;\n-  }\n-  assert(size_t(wpt - _worker_data) == ARRAY_SIZE(_worker_data), \"invariant\");\n-}\n-\n-WeakProcessorPhaseTimes::~WeakProcessorPhaseTimes() {\n-  for (size_t i = 0; i < ARRAY_SIZE(_worker_data); ++i) {\n-    delete _worker_data[i];\n-  }\n-}\n-\n-uint WeakProcessorPhaseTimes::max_threads() const { return _max_threads; }\n-\n-uint WeakProcessorPhaseTimes::active_workers() const {\n-  assert(_active_workers != 0, \"active workers not set\");\n-  return _active_workers;\n-}\n-\n-void WeakProcessorPhaseTimes::set_active_workers(uint n) {\n-  assert(_active_workers == 0, \"active workers already set\");\n-  assert(n > 0, \"active workers must be non-zero\");\n-  assert(n <= _max_threads, \"active workers must not exceed max threads\");\n-  _active_workers = n;\n-}\n-\n-void WeakProcessorPhaseTimes::reset() {\n-  _active_workers = 0;\n-  _total_time_sec = uninitialized_time;\n-  for (size_t i = 0; i < ARRAY_SIZE(_worker_data); ++i) {\n-    _worker_data[i]->reset();\n-  }\n-}\n-\n-double WeakProcessorPhaseTimes::total_time_sec() const {\n-  assert(is_initialized_time(_total_time_sec), \"Total time not set\");\n-  return _total_time_sec;\n-}\n-\n-void WeakProcessorPhaseTimes::record_total_time_sec(double time_sec) {\n-  assert(!is_initialized_time(_total_time_sec), \"Already set total time\");\n-  _total_time_sec = time_sec;\n-}\n-\n-WorkerDataArray<double>* WeakProcessorPhaseTimes::worker_data(WeakProcessorPhase phase) const {\n-  size_t index = EnumRange<WeakProcessorPhase>().index(phase);\n-  assert(index < ARRAY_SIZE(_worker_data), \"invalid phase\");\n-  return _worker_data[index];\n-}\n-\n-double WeakProcessorPhaseTimes::worker_time_sec(uint worker_id, WeakProcessorPhase phase) const {\n-  assert(worker_id < active_workers(),\n-         \"invalid worker id %u for %u\", worker_id, active_workers());\n-  return worker_data(phase)->get(worker_id);\n-}\n-\n-void WeakProcessorPhaseTimes::record_worker_time_sec(uint worker_id,\n-                                                     WeakProcessorPhase phase,\n-                                                     double time_sec) {\n-  worker_data(phase)->set(worker_id, time_sec);\n-}\n-\n-void WeakProcessorPhaseTimes::record_worker_items(uint worker_id,\n-                                                  WeakProcessorPhase phase,\n-                                                  size_t num_dead,\n-                                                  size_t num_total) {\n-  WorkerDataArray<double>* phase_data = worker_data(phase);\n-  phase_data->set_or_add_thread_work_item(worker_id, num_dead, DeadItems);\n-  phase_data->set_or_add_thread_work_item(worker_id, num_total, TotalItems);\n-}\n-\n-static double elapsed_time_sec(Ticks start_time, Ticks end_time) {\n-  return (end_time - start_time).seconds();\n-}\n-\n-WeakProcessorTimeTracker::WeakProcessorTimeTracker(WeakProcessorPhaseTimes* times) :\n-  _times(times),\n-  _start_time(Ticks::now())\n-{}\n-\n-WeakProcessorTimeTracker::~WeakProcessorTimeTracker() {\n-  if (_times != NULL) {\n-    Ticks end_time = Ticks::now();\n-    _times->record_total_time_sec(elapsed_time_sec(_start_time, end_time));\n-  }\n-}\n-\n-WeakProcessorPhaseTimeTracker::WeakProcessorPhaseTimeTracker(WeakProcessorPhaseTimes* times,\n-                                                             WeakProcessorPhase phase,\n-                                                             uint worker_id) :\n-  _times(times),\n-  _phase(phase),\n-  _worker_id(worker_id),\n-  _start_time(Ticks::now())\n-{\n-  assert(_times == NULL || worker_id < _times->active_workers(),\n-         \"Invalid worker_id %u\", worker_id);\n-}\n-\n-\n-WeakProcessorPhaseTimeTracker::~WeakProcessorPhaseTimeTracker() {\n-  if (_times != NULL) {\n-    double time_sec = elapsed_time_sec(_start_time, Ticks::now());\n-    _times->record_worker_time_sec(_worker_id, _phase, time_sec);\n-  }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ Printing times\n-\n-const char* const indents[] = {\"\", \"  \", \"    \", \"      \", \"        \"};\n-const size_t max_indents_index = ARRAY_SIZE(indents) - 1;\n-\n-static const char* indent_str(size_t i) {\n-  return indents[MIN2(i, max_indents_index)];\n-}\n-\n-#define TIME_FORMAT \"%.1lfms\"\n-\n-void WeakProcessorPhaseTimes::log_phase_summary(WeakProcessorPhase phase,\n-                                                uint indent) const {\n-  LogTarget(Debug, gc, phases) lt;\n-  LogStream ls(lt);\n-  ls.print(\"%s\", indents[indent]);\n-  worker_data(phase)->print_summary_on(&ls, true);\n-  log_phase_details(worker_data(phase), indent + 1);\n-\n-  for (uint i = 0; i < worker_data(phase)->MaxThreadWorkItems; i++) {\n-    WorkerDataArray<size_t>* work_items = worker_data(phase)->thread_work_items(i);\n-    if (work_items != NULL) {\n-      ls.print(\"%s\", indents[indent + 1]);\n-      work_items->print_summary_on(&ls, true);\n-      log_phase_details(work_items, indent + 1);\n-    }\n-  }\n-}\n-\n-template <typename T>\n-void WeakProcessorPhaseTimes::log_phase_details(WorkerDataArray<T>* data,\n-                                                uint indent) const {\n-  LogTarget(Trace, gc, phases) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"%s\", indents[indent]);\n-    data->print_details_on(&ls);\n-  }\n-}\n-\n-void WeakProcessorPhaseTimes::log_print_phases(uint indent) const {\n-  if (log_is_enabled(Debug, gc, phases)) {\n-    for (WeakProcessorPhase phase : EnumRange<WeakProcessorPhase>()) {\n-      log_phase_summary(phase, indent);\n-    }\n-  }\n-}\n-\n-void WeakProcessorPhaseTimes::log_print(uint indent) const {\n-  if (log_is_enabled(Debug, gc, phases)) {\n-    log_debug(gc, phases)(\"%s%s: \" TIME_FORMAT,\n-                          indent_str(indent),\n-                          \"Weak Processing\",\n-                          total_time_sec() * MILLIUNITS);\n-    log_print_phases(indent + 1);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorPhaseTimes.cpp","additions":0,"deletions":222,"binary":false,"changes":222,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_WEAKPROCESSORPHASETIMES_HPP\n-#define SHARE_GC_SHARED_WEAKPROCESSORPHASETIMES_HPP\n-\n-#include \"gc\/shared\/weakProcessorPhase.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-template<typename T> class WorkerDataArray;\n-\n-class WeakProcessorPhaseTimes {\n-  enum {\n-    DeadItems,\n-    TotalItems\n-  };\n-  uint _max_threads;\n-  uint _active_workers;\n-\n-  \/\/ Total time for weak processor.\n-  double _total_time_sec;\n-\n-  \/\/ Per-worker times and linked items.\n-  WorkerDataArray<double>* _worker_data[EnumRange<WeakProcessorPhase>().size()];\n-  WorkerDataArray<double>* worker_data(WeakProcessorPhase phase) const;\n-\n-  void log_phase_summary(WeakProcessorPhase phase, uint indent) const;\n-  template <typename T>\n-  void log_phase_details(WorkerDataArray<T>* data, uint indent) const;\n-\n-public:\n-  WeakProcessorPhaseTimes(uint max_threads);\n-  ~WeakProcessorPhaseTimes();\n-\n-  uint max_threads() const;\n-  uint active_workers() const;\n-  void set_active_workers(uint n);\n-\n-  double total_time_sec() const;\n-  double worker_time_sec(uint worker_id, WeakProcessorPhase phase) const;\n-\n-  void record_total_time_sec(double time_sec);\n-  void record_worker_time_sec(uint worker_id, WeakProcessorPhase phase, double time_sec);\n-  void record_worker_items(uint worker_id, WeakProcessorPhase phase, size_t num_dead, size_t num_total);\n-\n-  void reset();\n-\n-  void log_print(uint indent = 0) const;\n-  void log_print_phases(uint indent = 0) const;\n-};\n-\n-\/\/ Record total weak processor time and worker count in times.\n-\/\/ Does nothing if times is NULL.\n-class WeakProcessorTimeTracker : StackObj {\n-  WeakProcessorPhaseTimes* _times;\n-  Ticks _start_time;\n-\n-public:\n-  WeakProcessorTimeTracker(WeakProcessorPhaseTimes* times);\n-  ~WeakProcessorTimeTracker();\n-};\n-\n-\/\/ Record phase time contribution for the current thread in phase times.\n-\/\/ Does nothing if phase times is NULL.\n-class WeakProcessorPhaseTimeTracker : StackObj {\n-private:\n-  WeakProcessorPhaseTimes* _times;\n-  WeakProcessorPhase _phase;\n-  uint _worker_id;\n-  Ticks _start_time;\n-\n-public:\n-  \/\/ For tracking possibly parallel phase times (even if processed by\n-  \/\/ only one thread).\n-  \/\/ Precondition: worker_id < times->max_threads().\n-  WeakProcessorPhaseTimeTracker(WeakProcessorPhaseTimes* times,\n-                                WeakProcessorPhase phase,\n-                                uint worker_id);\n-\n-  ~WeakProcessorPhaseTimeTracker();\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_WEAKPROCESSORPHASETIMES_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorPhaseTimes.hpp","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/weakProcessor.hpp\"\n+#include \"gc\/shared\/weakProcessorTimes.hpp\"\n+#include \"gc\/shared\/workerDataArray.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/enumIterator.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+const double uninitialized_time = -1.0;\n+\n+#ifdef ASSERT\n+static bool is_initialized_time(double t) { return t >= 0.0; }\n+#endif \/\/ ASSERT\n+\n+\n+WeakProcessorTimes::WeakProcessorTimes(uint max_threads) :\n+  _max_threads(max_threads),\n+  _active_workers(0),\n+  _total_time_sec(uninitialized_time),\n+  _worker_data()\n+{\n+  assert(_max_threads > 0, \"max_threads must not be zero\");\n+\n+  WorkerDataArray<double>** wpt = _worker_data;\n+  for (auto id : EnumRange<StorageId>()) {\n+    assert(size_t(wpt - _worker_data) < ARRAY_SIZE(_worker_data), \"invariant\");\n+    const char* description = OopStorageSet::storage(id)->name();\n+    *wpt = new WorkerDataArray<double>(NULL, description, _max_threads);\n+    (*wpt)->create_thread_work_items(\"Dead\", DeadItems);\n+    (*wpt)->create_thread_work_items(\"Total\", TotalItems);\n+    wpt++;\n+  }\n+  assert(size_t(wpt - _worker_data) == ARRAY_SIZE(_worker_data), \"invariant\");\n+}\n+\n+WeakProcessorTimes::~WeakProcessorTimes() {\n+  for (size_t i = 0; i < ARRAY_SIZE(_worker_data); ++i) {\n+    delete _worker_data[i];\n+  }\n+}\n+\n+uint WeakProcessorTimes::max_threads() const { return _max_threads; }\n+\n+uint WeakProcessorTimes::active_workers() const {\n+  assert(_active_workers != 0, \"active workers not set\");\n+  return _active_workers;\n+}\n+\n+void WeakProcessorTimes::set_active_workers(uint n) {\n+  assert(_active_workers == 0, \"active workers already set\");\n+  assert(n > 0, \"active workers must be non-zero\");\n+  assert(n <= _max_threads, \"active workers must not exceed max threads\");\n+  _active_workers = n;\n+}\n+\n+void WeakProcessorTimes::reset() {\n+  _active_workers = 0;\n+  _total_time_sec = uninitialized_time;\n+  for (size_t i = 0; i < ARRAY_SIZE(_worker_data); ++i) {\n+    _worker_data[i]->reset();\n+  }\n+}\n+\n+double WeakProcessorTimes::total_time_sec() const {\n+  assert(is_initialized_time(_total_time_sec), \"Total time not set\");\n+  return _total_time_sec;\n+}\n+\n+void WeakProcessorTimes::record_total_time_sec(double time_sec) {\n+  assert(!is_initialized_time(_total_time_sec), \"Already set total time\");\n+  _total_time_sec = time_sec;\n+}\n+\n+WorkerDataArray<double>* WeakProcessorTimes::worker_data(StorageId id) const {\n+  size_t index = EnumRange<StorageId>().index(id);\n+  assert(index < ARRAY_SIZE(_worker_data), \"invalid phase\");\n+  return _worker_data[index];\n+}\n+\n+double WeakProcessorTimes::worker_time_sec(uint worker_id, StorageId id) const {\n+  assert(worker_id < active_workers(),\n+         \"invalid worker id %u for %u\", worker_id, active_workers());\n+  return worker_data(id)->get(worker_id);\n+}\n+\n+void WeakProcessorTimes::record_worker_time_sec(uint worker_id,\n+                                                StorageId id,\n+                                                double time_sec) {\n+  worker_data(id)->set(worker_id, time_sec);\n+}\n+\n+void WeakProcessorTimes::record_worker_items(uint worker_id,\n+                                             StorageId id,\n+                                             size_t num_dead,\n+                                             size_t num_total) {\n+  WorkerDataArray<double>* data = worker_data(id);\n+  data->set_or_add_thread_work_item(worker_id, num_dead, DeadItems);\n+  data->set_or_add_thread_work_item(worker_id, num_total, TotalItems);\n+}\n+\n+static double elapsed_time_sec(Ticks start_time, Ticks end_time) {\n+  return (end_time - start_time).seconds();\n+}\n+\n+WeakProcessorTimeTracker::WeakProcessorTimeTracker(WeakProcessorTimes* times) :\n+  _times(times),\n+  _start_time(Ticks::now())\n+{}\n+\n+WeakProcessorTimeTracker::~WeakProcessorTimeTracker() {\n+  if (_times != NULL) {\n+    Ticks end_time = Ticks::now();\n+    _times->record_total_time_sec(elapsed_time_sec(_start_time, end_time));\n+  }\n+}\n+\n+WeakProcessorParTimeTracker::WeakProcessorParTimeTracker(WeakProcessorTimes* times,\n+                                                         StorageId storage_id,\n+                                                         uint worker_id) :\n+  _times(times),\n+  _storage_id(storage_id),\n+  _worker_id(worker_id),\n+  _start_time(Ticks::now())\n+{\n+  assert(_times == NULL || worker_id < _times->active_workers(),\n+         \"Invalid worker_id %u\", worker_id);\n+}\n+\n+\n+WeakProcessorParTimeTracker::~WeakProcessorParTimeTracker() {\n+  if (_times != NULL) {\n+    double time_sec = elapsed_time_sec(_start_time, Ticks::now());\n+    _times->record_worker_time_sec(_worker_id, _storage_id, time_sec);\n+  }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Printing times\n+\n+const char* const indents[] = {\"\", \"  \", \"    \", \"      \", \"        \"};\n+const size_t max_indents_index = ARRAY_SIZE(indents) - 1;\n+\n+static const char* indent_str(size_t i) {\n+  return indents[MIN2(i, max_indents_index)];\n+}\n+\n+#define TIME_FORMAT \"%.1lfms\"\n+\n+void WeakProcessorTimes::log_summary(StorageId id, uint indent) const {\n+  LogTarget(Debug, gc, phases) lt;\n+  LogStream ls(lt);\n+  ls.print(\"%s\", indents[indent]);\n+  worker_data(id)->print_summary_on(&ls, true);\n+  log_details(worker_data(id), indent + 1);\n+\n+  for (uint i = 0; i < worker_data(id)->MaxThreadWorkItems; i++) {\n+    WorkerDataArray<size_t>* work_items = worker_data(id)->thread_work_items(i);\n+    if (work_items != NULL) {\n+      ls.print(\"%s\", indents[indent + 1]);\n+      work_items->print_summary_on(&ls, true);\n+      log_details(work_items, indent + 1);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void WeakProcessorTimes::log_details(WorkerDataArray<T>* data, uint indent) const {\n+  LogTarget(Trace, gc, phases) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print(\"%s\", indents[indent]);\n+    data->print_details_on(&ls);\n+  }\n+}\n+\n+void WeakProcessorTimes::log_subtotals(uint indent) const {\n+  if (log_is_enabled(Debug, gc, phases)) {\n+    for (auto id : EnumRange<StorageId>()) {\n+      log_summary(id, indent);\n+    }\n+  }\n+}\n+\n+void WeakProcessorTimes::log_total(uint indent) const {\n+  log_debug(gc, phases)(\"%s%s: \" TIME_FORMAT,\n+                        indent_str(indent),\n+                        \"Weak Processing\",\n+                        total_time_sec() * MILLIUNITS);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorTimes.cpp","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_WEAKPROCESSORTIMES_HPP\n+#define SHARE_GC_SHARED_WEAKPROCESSORTIMES_HPP\n+\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+template<typename T> class WorkerDataArray;\n+\n+class WeakProcessorTimes {\n+public:\n+  using StorageId = OopStorageSet::WeakId;\n+\n+private:\n+  enum {\n+    DeadItems,\n+    TotalItems\n+  };\n+  uint _max_threads;\n+  uint _active_workers;\n+\n+  \/\/ Total time for weak processor.\n+  double _total_time_sec;\n+\n+  \/\/ Per-worker times and linked items.\n+  WorkerDataArray<double>* _worker_data[EnumRange<StorageId>().size()];\n+  WorkerDataArray<double>* worker_data(StorageId id) const;\n+\n+  void log_summary(StorageId id, uint indent) const;\n+  template <typename T>\n+  void log_details(WorkerDataArray<T>* data, uint indent) const;\n+\n+public:\n+  WeakProcessorTimes(uint max_threads);\n+  ~WeakProcessorTimes();\n+\n+  uint max_threads() const;\n+  uint active_workers() const;\n+  void set_active_workers(uint n);\n+\n+  double total_time_sec() const;\n+  double worker_time_sec(uint worker_id, StorageId id) const;\n+\n+  void record_total_time_sec(double time_sec);\n+  void record_worker_time_sec(uint worker_id, StorageId id, double time_sec);\n+  void record_worker_items(uint worker_id, StorageId id, size_t num_dead, size_t num_total);\n+\n+  void reset();\n+\n+  void log_total(uint indent = 0) const;\n+  void log_subtotals(uint indent = 0) const;\n+};\n+\n+\/\/ Record total weak processor time and worker count in times.\n+\/\/ Does nothing if times is NULL.\n+class WeakProcessorTimeTracker : StackObj {\n+  WeakProcessorTimes* _times;\n+  Ticks _start_time;\n+\n+public:\n+  WeakProcessorTimeTracker(WeakProcessorTimes* times);\n+  ~WeakProcessorTimeTracker();\n+};\n+\n+\/\/ Record time contribution for the current thread.\n+\/\/ Does nothing if times is NULL.\n+class WeakProcessorParTimeTracker : StackObj {\n+public:\n+  using StorageId = OopStorageSet::WeakId;\n+\n+private:\n+  WeakProcessorTimes* _times;\n+  StorageId _storage_id;\n+  uint _worker_id;\n+  Ticks _start_time;\n+\n+public:\n+  \/\/ For tracking possibly parallel times (even if processed by\n+  \/\/ only one thread).\n+  \/\/ Precondition: worker_id < times->max_threads().\n+  WeakProcessorParTimeTracker(WeakProcessorTimes* times,\n+                              StorageId storage_id,\n+                              uint worker_id);\n+\n+  ~WeakProcessorParTimeTracker();\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_WEAKPROCESSORTIMES_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorTimes.hpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/weakProcessorPhaseTimes.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -157,3 +158,2 @@\n-  for (OopStorageSet::Iterator it = OopStorageSet::weak_iterator(); !it.is_end(); ++it) {\n-    OopStorage* storage = *it;\n-    storage->oops_do<OopClosure>(cl);\n+  for (auto id : EnumRange<OopStorageSet::WeakId>()) {\n+    OopStorageSet::storage(id)->oops_do(cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/shared\/weakProcessorPhaseTimes.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -133,2 +134,2 @@\n-  int i = 0;\n-  for (OopStorageSet::Iterator it = OopStorageSet::strong_iterator(); !it.is_end(); ++it, ++i) {\n+  using Range = EnumRange<OopStorageSet::StrongId>;\n+  for (auto id : Range()) {\n@@ -136,1 +137,1 @@\n-    OopStorage* oop_storage = *it;\n+    OopStorage* oop_storage = OopStorageSet::storage(id);\n@@ -140,1 +141,1 @@\n-    OldObjectRoot::System system = OldObjectRoot::System(OldObjectRoot::_strong_oop_storage_set_first + i);\n+    OldObjectRoot::System system = OldObjectRoot::System(OldObjectRoot::_strong_oop_storage_set_first + Range().index(id));\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -34,7 +35,5 @@\n-    int index = val - _strong_oop_storage_set_first;\n-    int i = 0;\n-    for (OopStorageSet::Iterator it = OopStorageSet::strong_iterator(); !it.is_end(); ++it, ++i) {\n-      if (i == index) {\n-        return *it;\n-      }\n-    }\n+    using StrongId = OopStorageSet::StrongId;\n+    using Underlying = std::underlying_type_t<StrongId>;\n+    auto first = static_cast<Underlying>(EnumRange<StrongId>().first());\n+    auto id = static_cast<StrongId>(first + (val - _strong_oop_storage_set_first));\n+    return OopStorageSet::storage(id);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/rootType.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -38,1 +39,1 @@\n-    _strong_oop_storage_set_last = _strong_oop_storage_set_first + OopStorageSet::strong_count - 1,\n+    _strong_oop_storage_set_last = _strong_oop_storage_set_first + EnumRange<OopStorageSet::StrongId>().size() - 1,\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/rootType.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -129,3 +129,2 @@\n-  OopStorageSet::Iterator it = OopStorageSet::all_iterator();\n-  for ( ; !it.is_end(); ++it) {\n-    it->delete_empty_blocks();\n+  for (OopStorage* storage : OopStorageSet::Range<OopStorageSet::Id>()) {\n+    storage->delete_empty_blocks();\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -47,7 +48,6 @@\n-  template <uint count>\n-  static void check_iterator(OopStorageSet::Iterator it,\n-      OopStorage* storages[count]) {\n-    OopStorageSet::Iterator start = it;\n-    ASSERT_EQ(start, it);\n-    for ( ; !it.is_end(); ++it) {\n-      size_t index = find_storage<count>(*it, storages);\n+  template <uint count, typename Range>\n+  static void check_iterator(Range range, OopStorage* storages[count]) {\n+    ASSERT_EQ(range.size(), count);\n+    for (auto id : range) {\n+      OopStorage* storage = OopStorageSet::storage(id);\n+      size_t index = find_storage<count>(storage, storages);\n@@ -55,1 +55,1 @@\n-      storages[index] = NULL;\n+      storages[index] = nullptr;\n@@ -57,2 +57,0 @@\n-    ASSERT_NE(start, it);\n-    const OopStorage* null_storage = NULL;\n@@ -60,1 +58,1 @@\n-      ASSERT_EQ(null_storage, storages[i]);\n+      ASSERT_EQ(nullptr \/* null_storage *\/, storages[i]);\n@@ -64,3 +62,2 @@\n-  template <uint count>\n-  static void test_iterator(OopStorageSet::Iterator iterator,\n-      void (*fill)(OopStorage*[count])) {\n+  template<uint count, typename Range>\n+  static void test_iterator(Range range, void (*fill)(OopStorage*[count])) {\n@@ -69,1 +66,1 @@\n-    check_iterator<count>(iterator, storages);\n+    check_iterator<count>(range, storages);\n@@ -74,2 +71,2 @@\n-        OopStorageSet::strong_iterator(),\n-        &OopStorageSet::fill_strong);\n+      EnumRange<OopStorageSet::StrongId>(),\n+      &OopStorageSet::fill_strong);\n@@ -80,2 +77,2 @@\n-        OopStorageSet::weak_iterator(),\n-        &OopStorageSet::fill_weak);\n+      EnumRange<OopStorageSet::WeakId>(),\n+      &OopStorageSet::fill_weak);\n@@ -86,2 +83,2 @@\n-        OopStorageSet::all_iterator(),\n-        &OopStorageSet::fill_all);\n+      EnumRange<OopStorageSet::Id>(),\n+      &OopStorageSet::fill_all);\n@@ -91,1 +88,1 @@\n-TEST_VM_F(OopStorageSetTest, iterators) {\n+TEST_VM_F(OopStorageSetTest, strong_iterator) {\n@@ -93,0 +90,3 @@\n+}\n+\n+TEST_VM_F(OopStorageSetTest, weak_iterator) {\n@@ -94,0 +94,3 @@\n+}\n+\n+TEST_VM_F(OopStorageSetTest, all_iterator) {\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorageSet.cpp","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"}]}