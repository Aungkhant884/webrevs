{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -607,3 +608,40 @@\n-        if (getClass() == BufferedInputStream.class\n-                && ((count - pos) <= 0) && (markpos == -1)) {\n-            return getInIfOpen().transferTo(out);\n+        if (getClass() == BufferedInputStream.class && markpos == -1) {\n+            int avail = count - pos;\n+            if (avail > 0) {\n+                byte[] buffer = getBufIfOpen();\n+\n+                \/\/ Prevent buffer poisoning (by out.write throwing IOException)\n+                byte[] emptyBuffer = new byte[0];\n+                if (!U.compareAndSetReference(this, BUF_OFFSET, buffer, emptyBuffer)) {\n+                    \/\/ Can't replace buf if there was an async close.\n+                    \/\/ Note: This would need to be changed if transferTo()\n+                    \/\/ is ever made accessible to multiple threads.\n+                    \/\/ But for now, the only way CAS can fail is via close.\n+                    \/\/ assert buf == null;\n+                    throw new IOException(\"Stream closed\");\n+                }\n+\n+                \/\/ Prevent leaking of \"confidential\" buffer content\n+                Arrays.fill(buffer, 0, pos, (byte) 0);\n+                Arrays.fill(buffer, count, buffer.length, (byte) 0);\n+\n+                out.write(buffer, pos, avail);\n+                count = 0;\n+                pos = 0;\n+\n+                \/\/ Allow GC before reallocating possibly large buffer to prevent OOME\n+                int bufferSize = buffer.length;\n+                buffer = null;\n+\n+                \/\/ Resizing the buffer to respect user's buffer size choice\n+                byte[] nbuf = new byte[bufferSize];\n+                if (!U.compareAndSetReference(this, BUF_OFFSET, emptyBuffer, nbuf)) {\n+                    \/\/ Can't replace buf if there was an async close.\n+                    \/\/ Note: This would need to be changed if transferTo()\n+                    \/\/ is ever made accessible to multiple threads.\n+                    \/\/ But for now, the only way CAS can fail is via close.\n+                    \/\/ assert buf == null;\n+                    throw new IOException(\"Stream closed\");\n+                }\n+            }\n+            return avail + getInIfOpen().transferTo(out);\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"}]}