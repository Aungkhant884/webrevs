{"files":[{"patch":"@@ -611,20 +611,4 @@\n-                byte[] buffer = getBufIfOpen();\n-\n-                \/\/ Prevent buffer poisoning (by out.write throwing IOException)\n-                byte[] emptyBuffer = new byte[0]; \/\/ read-past-EOF is rather unlikely\n-                if (!U.compareAndSetReference(this, BUF_OFFSET, buffer, emptyBuffer)) {\n-                    \/\/ Can't replace buf if there was an async close.\n-                    \/\/ Note: This would need to be changed if transferTo()\n-                    \/\/ is ever made accessible to multiple threads.\n-                    \/\/ But for now, the only way CAS can fail is via close.\n-                    \/\/ assert buf == null;\n-                    throw new IOException(\"Stream closed\");\n-                }\n-\n-                \/\/ Prevent leaking of \"confidential\" buffer content\n-                Arrays.fill(buffer, 0, pos, (byte) 0);\n-                Arrays.fill(buffer, count, buffer.length, (byte) 0);\n-\n-                out.write(buffer, pos, avail);\n-                count = 0;\n-                pos = 0;\n+                \/\/ Prevent poisoning and leaking of buf\n+                byte[] buffer = Arrays.copyOfRange(getBufIfOpen(), pos, count);\n+                out.write(buffer);\n+                pos = count;\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"}]}