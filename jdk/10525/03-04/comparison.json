{"files":[{"patch":"@@ -614,1 +614,1 @@\n-                byte[] emptyBuffer = new byte[0];\n+                byte[] emptyBuffer = new byte[0]; \/\/ read-past-EOF is rather unlikely\n@@ -631,15 +631,0 @@\n-\n-                \/\/ Allow GC before reallocating possibly large buffer to prevent OOME\n-                int bufferSize = buffer.length;\n-                buffer = null;\n-\n-                \/\/ Resizing the buffer to respect user's buffer size choice\n-                byte[] nbuf = new byte[bufferSize];\n-                if (!U.compareAndSetReference(this, BUF_OFFSET, emptyBuffer, nbuf)) {\n-                    \/\/ Can't replace buf if there was an async close.\n-                    \/\/ Note: This would need to be changed if transferTo()\n-                    \/\/ is ever made accessible to multiple threads.\n-                    \/\/ But for now, the only way CAS can fail is via close.\n-                    \/\/ assert buf == null;\n-                    throw new IOException(\"Stream closed\");\n-                }\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"}]}