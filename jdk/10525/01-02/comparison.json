{"files":[{"patch":"@@ -610,2 +610,27 @@\n-                out.write(getBufIfOpen(), pos, avail);\n-                pos = count;\n+                byte[] buffer = getBufIfOpen();\n+                out.write(buffer, pos, avail);\n+                count = 0;\n+                pos = 0;\n+\n+                \/\/ Allow GC before reallocating possibly large buffer to prevent OOME\n+                byte[] emptyBuffer = new byte[0];\n+                if (!U.compareAndSetReference(this, BUF_OFFSET, buffer, emptyBuffer)) {\n+                    \/\/ Can't replace buf if there was an async close.\n+                    \/\/ Note: This would need to be changed if transferTo()\n+                    \/\/ is ever made accessible to multiple threads.\n+                    \/\/ But for now, the only way CAS can fail is via close.\n+                    \/\/ assert buf == null;\n+                    throw new IOException(\"Stream closed\");\n+                }\n+                int bufferSize = buffer.length;\n+                buffer = null;\n+\n+                byte[] nbuf = new byte[bufferSize];\n+                if (!U.compareAndSetReference(this, BUF_OFFSET, emptyBuffer, nbuf)) {\n+                    \/\/ Can't replace buf if there was an async close.\n+                    \/\/ Note: This would need to be changed if transferTo()\n+                    \/\/ is ever made accessible to multiple threads.\n+                    \/\/ But for now, the only way CAS can fail is via close.\n+                    \/\/ assert buf == null;\n+                    throw new IOException(\"Stream closed\");\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"}]}