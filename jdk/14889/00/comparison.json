{"files":[{"patch":"@@ -474,0 +474,1 @@\n+          \/\/ This is true for parallel capable and non-parallel capable class_loaders.\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -231,0 +231,8 @@\n+#ifdef ASSERT\n+bool PlaceholderTable::is_definer(JavaThread* thread, Symbol* name, ClassLoaderData* loader_data) {\n+  MutexLocker ml(thread, SystemDictionary_lock);\n+  PlaceholderEntry* entry = get_entry(name, loader_data);\n+  return entry != nullptr && entry->definer_acquire() == thread;\n+}\n+#endif\n+\n@@ -283,1 +291,1 @@\n-\/\/ definer() tracks the single thread that owns define token\n+\/\/ definer_acquire() tracks the single thread that owns define token\n@@ -304,1 +312,1 @@\n-      && (probe->defineThreadQ() == nullptr) && (probe->definer() == nullptr)) {\n+      && (probe->defineThreadQ() == nullptr) && (probe->definer_acquire() == nullptr)) {\n@@ -316,1 +324,1 @@\n-  if (supername() != nullptr) {\n+  if (_supername != nullptr) {\n@@ -318,1 +326,1 @@\n-    supername()->print_value_on(st);\n+    _supername->print_value_on(st);\n@@ -320,1 +328,1 @@\n-  if (definer() != nullptr) {\n+  if (_definer != nullptr) {\n@@ -322,1 +330,1 @@\n-    definer()->print_value_on(st);\n+    _definer->print_value_on(st);\n@@ -324,1 +332,1 @@\n-  if (instance_klass() != nullptr) {\n+  if (_instanceKlass != nullptr) {\n@@ -326,1 +334,1 @@\n-    instance_klass()->print_value_on(st);\n+    _instanceKlass->print_value_on(st);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -57,0 +58,1 @@\n+  DEBUG_ONLY(static bool is_definer(JavaThread* thread, Symbol* name, ClassLoaderData* loader_data));\n@@ -118,2 +120,2 @@\n-  JavaThread*        definer()             const {return _definer; }\n-  void               set_definer(JavaThread* definer) { _definer = definer; }\n+  JavaThread*        definer_acquire()     const { return Atomic::load_acquire(&_definer); }\n+  void               release_set_definer(JavaThread* definer) { Atomic::release_store(&_definer, definer); }\n@@ -121,1 +123,1 @@\n-  InstanceKlass*     instance_klass()      const {return _instanceKlass; }\n+  InstanceKlass*     instance_klass()      const { return _instanceKlass; }\n@@ -132,4 +134,0 @@\n-  bool define_class_in_progress() {\n-    return (_defineThreadQ != nullptr);\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-  \/\/ the define.\n+  \/\/ the define, if the define lock happens to be taken before this one.\n@@ -898,15 +898,4 @@\n-  \/\/ If a class loader supports parallel classloading, handle parallel define requests.\n-  \/\/ find_or_define_instance_class may return a different InstanceKlass,\n-  \/\/ in which case the old k would be deallocated\n-  if (is_parallelCapable(class_loader)) {\n-    k = find_or_define_instance_class(h_name, class_loader, k, CHECK_NULL);\n-  } else {\n-    define_instance_class(k, class_loader, THREAD);\n-\n-    \/\/ If defining the class throws an exception register 'k' for cleanup.\n-    if (HAS_PENDING_EXCEPTION) {\n-      assert(k != nullptr, \"Must have an instance klass here!\");\n-      loader_data->add_to_deallocate_list(k);\n-      return nullptr;\n-    }\n-  }\n+  \/\/ If a class loader supports parallel classloading with AllowParallelDefineClass for parallel-capable class non-boot\n+  \/\/ class loaders, handle parallel define requests. In this case, find_or_define_instance_class may return a different\n+  \/\/ InstanceKlass, in which case the old k would be deallocated\n+  k = find_or_define_instance_class(h_name, class_loader, k, CHECK_NULL);\n@@ -1383,10 +1372,2 @@\n-  \/\/ Bootstrap and other parallel classloaders don't acquire a lock,\n-  \/\/ they use placeholder token.\n-  \/\/ If a parallelCapable class loader calls define_instance_class instead of\n-  \/\/ find_or_define_instance_class to get here, we have a timing\n-  \/\/ hole with systemDictionary updates and check_constraints\n-  if (!is_parallelCapable(class_loader)) {\n-    assert(ObjectSynchronizer::current_thread_holds_lock(THREAD,\n-           get_loader_lock_or_null(class_loader)),\n-           \"define called without lock\");\n-  }\n+  assert(PlaceholderTable::is_definer(THREAD, k->name(), loader_data),\n+         \"define called without a placeholder entry\");\n@@ -1399,4 +1380,0 @@\n-  \/\/ Existing classloaders will call define_instance_class with the\n-  \/\/ classloader lock held\n-  \/\/ Parallel classloaders will call find_or_define_instance_class\n-  \/\/ which will require a token to perform the define class\n@@ -1477,1 +1454,1 @@\n-    while (probe->definer() != nullptr) {\n+    while (probe->definer_acquire() != nullptr) {\n@@ -1494,1 +1471,1 @@\n-      probe->set_definer(THREAD);\n+      probe->release_set_definer(THREAD);\n@@ -1508,1 +1485,1 @@\n-    probe->set_definer(nullptr);\n+    probe->release_set_definer(nullptr);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":10,"deletions":33,"binary":false,"changes":43,"status":"modified"}]}