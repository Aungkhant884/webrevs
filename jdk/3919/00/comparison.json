{"files":[{"patch":"@@ -2957,1 +2957,1 @@\n-      Thread::send_async_exception(java_thread, java_throwable);\n+      JavaThread::send_async_exception(java_thread, java_throwable);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -974,1 +974,1 @@\n-    if (self->has_async_condition()) {\n+    if (self->has_async_exception_condition()) {\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,2 +268,0 @@\n-  _suspend_flags = 0;\n-\n@@ -544,21 +542,0 @@\n-class InstallAsyncExceptionClosure : public HandshakeClosure {\n-  Handle _throwable; \/\/ The Throwable thrown at the target Thread\n-public:\n-  InstallAsyncExceptionClosure(Handle throwable) : HandshakeClosure(\"InstallAsyncException\"), _throwable(throwable) {}\n-\n-  void do_thread(Thread* thr) {\n-    JavaThread* target = thr->as_Java_thread();\n-    \/\/ Note that this now allows multiple ThreadDeath exceptions to be\n-    \/\/ thrown at a thread.\n-    \/\/ The target thread has run and has not exited yet.\n-    target->send_thread_stop(_throwable());\n-  }\n-};\n-\n-void Thread::send_async_exception(oop java_thread, oop java_throwable) {\n-  Handle throwable(Thread::current(), java_throwable);\n-  JavaThread* target = java_lang_Thread::thread(java_thread);\n-  InstallAsyncExceptionClosure vm_stop(throwable);\n-  Handshake::execute(&vm_stop, target);\n-}\n-\n@@ -1055,1 +1032,3 @@\n-  _special_runtime_exit_condition(_no_async_condition),\n+\n+  _suspend_flags(0),\n+  _async_exception_condition(_no_async_condition),\n@@ -1616,1 +1595,0 @@\n-\/\/ JVM support.\n@@ -1618,0 +1596,2 @@\n+\/\/ Asynchronous exceptions support\n+\/\/\n@@ -1621,2 +1601,2 @@\n-void JavaThread::check_and_handle_async_exceptions(bool check_unsafe_error) {\n-  if (has_last_Java_frame() && has_async_condition()) {\n+void JavaThread::check_and_handle_async_exceptions() {\n+  if (has_last_Java_frame() && has_async_exception_condition()) {\n@@ -1646,1 +1626,1 @@\n-  JavaThread::AsyncRequests condition = clear_special_runtime_exit_condition();\n+  AsyncExceptionCondition condition = clear_async_exception_condition();\n@@ -1678,1 +1658,2 @@\n-      clear_has_async_exception();\n+      \/\/ Clear condition from _suspend_flags since we have finished processing it.\n+      clear_suspend_flag(_has_async_exception);\n@@ -1682,2 +1663,1 @@\n-  if (check_unsafe_error &&\n-      condition == _async_unsafe_access_error && !has_pending_exception()) {\n+  if (condition == _async_unsafe_access_error && !has_pending_exception()) {\n@@ -1686,1 +1666,0 @@\n-    condition = _no_async_condition;  \/\/ done\n@@ -1710,3 +1689,1 @@\n-  assert(condition == _no_async_condition || has_pending_exception() ||\n-         (!check_unsafe_error && condition == _async_unsafe_access_error),\n-         \"must have handled the async condition, if no exception\");\n+  assert(has_pending_exception(), \"must have handled the async condition if no exception\");\n@@ -1731,0 +1708,21 @@\n+class InstallAsyncExceptionClosure : public HandshakeClosure {\n+  Handle _throwable; \/\/ The Throwable thrown at the target Thread\n+public:\n+  InstallAsyncExceptionClosure(Handle throwable) : HandshakeClosure(\"InstallAsyncException\"), _throwable(throwable) {}\n+\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = thr->as_Java_thread();\n+    \/\/ Note that this now allows multiple ThreadDeath exceptions to be\n+    \/\/ thrown at a thread.\n+    \/\/ The target thread has run and has not exited yet.\n+    target->send_thread_stop(_throwable());\n+  }\n+};\n+\n+void JavaThread::send_async_exception(oop java_thread, oop java_throwable) {\n+  Handle throwable(Thread::current(), java_throwable);\n+  JavaThread* target = java_lang_Thread::thread(java_thread);\n+  InstallAsyncExceptionClosure vm_stop(throwable);\n+  Handshake::execute(&vm_stop, target);\n+}\n+\n@@ -1885,1 +1883,1 @@\n-  if (thread->has_async_exception()) {\n+  if (thread->has_async_exception_condition(false \/* check unsafe access error *\/)) {\n@@ -1888,1 +1886,1 @@\n-    thread->check_and_handle_async_exceptions(false);\n+    thread->check_and_handle_async_exceptions();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":35,"deletions":37,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -218,14 +218,0 @@\n-  enum SuspendFlags {\n-    \/\/ NOTE: avoid using the sign-bit as cc generates different test code\n-    \/\/       when the sign-bit is used, and sometimes incorrectly - see CR 6398077\n-\n-    _has_async_exception    = 0x00000001U, \/\/ there is a pending async exception\n-\n-    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n-    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n-  };\n-\n-  \/\/ various suspension related flags - atomically updated\n-  \/\/ overloaded for async exception checking in check_special_condition_for_native_trans.\n-  volatile uint32_t _suspend_flags;\n-\n@@ -399,14 +385,0 @@\n-  bool has_async_exception() const { return (_suspend_flags & _has_async_exception) != 0; }\n-\n-  inline void set_suspend_flag(SuspendFlags f);\n-  inline void clear_suspend_flag(SuspendFlags f);\n-\n-  inline void set_has_async_exception();\n-  inline void clear_has_async_exception();\n-\n-  inline void set_trace_flag();\n-  inline void clear_trace_flag();\n-\n-  inline void set_obj_deopt_flag();\n-  inline void clear_obj_deopt_flag();\n-\n@@ -443,3 +415,0 @@\n-  \/\/ Installs a pending exception to be inserted later\n-  static void send_async_exception(oop thread_oop, oop java_throwable);\n-\n@@ -481,4 +450,0 @@\n-  bool is_trace_suspend()               { return (_suspend_flags & _trace_flag) != 0; }\n-\n-  bool is_obj_deopt_suspend()           { return (_suspend_flags & _obj_deopt) != 0; }\n-\n@@ -810,2 +775,26 @@\n-  \/\/ Async. requests support\n-  enum AsyncRequests {\n+  enum SuspendFlags {\n+    \/\/ NOTE: avoid using the sign-bit as cc generates different test code\n+    \/\/       when the sign-bit is used, and sometimes incorrectly - see CR 6398077\n+    _has_async_exception    = 0x00000001U, \/\/ there is a pending async exception\n+    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n+    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n+  };\n+\n+  \/\/ various suspension related flags - atomically updated\n+  \/\/ overloaded with async exceptions so that we do a single check when transitioning from native->Java\n+  volatile uint32_t _suspend_flags;\n+\n+  inline void set_suspend_flag(SuspendFlags f);\n+  inline void clear_suspend_flag(SuspendFlags f);\n+\n+ public:\n+  inline void set_trace_flag();\n+  inline void clear_trace_flag();\n+  inline void set_obj_deopt_flag();\n+  inline void clear_obj_deopt_flag();\n+  bool is_trace_suspend()      { return (_suspend_flags & _trace_flag) != 0; }\n+  bool is_obj_deopt_suspend()  { return (_suspend_flags & _obj_deopt) != 0; }\n+\n+  \/\/ Asynchronous exceptions support\n+ private:\n+  enum AsyncExceptionCondition {\n@@ -816,2 +805,26 @@\n-  AsyncRequests _special_runtime_exit_condition; \/\/ Enum indicating pending async. request\n-  oop           _pending_async_exception;\n+  AsyncExceptionCondition _async_exception_condition;\n+  oop                     _pending_async_exception;\n+\n+  void set_async_exception_condition(AsyncExceptionCondition aec) { _async_exception_condition = aec; }\n+  AsyncExceptionCondition clear_async_exception_condition() {\n+    AsyncExceptionCondition x = _async_exception_condition;\n+    _async_exception_condition = _no_async_condition;\n+    return x;\n+  }\n+\n+ public:\n+  bool has_async_exception_condition(bool check_unsafe_access_error = true) {\n+    return check_unsafe_access_error ? _async_exception_condition != _no_async_condition\n+                                     : _async_exception_condition == _async_exception;\n+  }\n+  inline void set_pending_async_exception(oop e);\n+  void set_pending_unsafe_access_error()  {\n+    \/\/ Don't overwrite an asynchronous exception sent by another thread\n+    if (_async_exception_condition == _no_async_condition) {\n+      set_async_exception_condition(_async_unsafe_access_error);\n+    }\n+  }\n+  void check_and_handle_async_exceptions();\n+  \/\/ Installs a pending exception to be inserted later\n+  static void send_async_exception(oop thread_oop, oop java_throwable);\n+  void send_thread_stop(oop throwable);\n@@ -1130,13 +1143,0 @@\n-  \/\/ Thread.stop support\n-  void send_thread_stop(oop throwable);\n-  AsyncRequests clear_special_runtime_exit_condition() {\n-    AsyncRequests x = _special_runtime_exit_condition;\n-    _special_runtime_exit_condition = _no_async_condition;\n-    return x;\n-  }\n-\n-  \/\/ Are any async conditions present?\n-  bool has_async_condition() { return (_special_runtime_exit_condition != _no_async_condition); }\n-\n-  void check_and_handle_async_exceptions(bool check_unsafe_error = true);\n-\n@@ -1149,1 +1149,1 @@\n-    return (_special_runtime_exit_condition != _no_async_condition) ||\n+    return (_async_exception_condition != _no_async_condition) ||\n@@ -1153,4 +1153,0 @@\n-  void set_pending_unsafe_access_error()          { _special_runtime_exit_condition = _async_unsafe_access_error; }\n-\n-  inline void set_pending_async_exception(oop e);\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":53,"deletions":57,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -39,34 +39,0 @@\n-inline void Thread::set_suspend_flag(SuspendFlags f) {\n-  uint32_t flags;\n-  do {\n-    flags = _suspend_flags;\n-  }\n-  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags | f)) != flags);\n-}\n-inline void Thread::clear_suspend_flag(SuspendFlags f) {\n-  uint32_t flags;\n-  do {\n-    flags = _suspend_flags;\n-  }\n-  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags & ~f)) != flags);\n-}\n-\n-inline void Thread::set_has_async_exception() {\n-  set_suspend_flag(_has_async_exception);\n-}\n-inline void Thread::clear_has_async_exception() {\n-  clear_suspend_flag(_has_async_exception);\n-}\n-inline void Thread::set_trace_flag() {\n-  set_suspend_flag(_trace_flag);\n-}\n-inline void Thread::clear_trace_flag() {\n-  clear_suspend_flag(_trace_flag);\n-}\n-inline void Thread::set_obj_deopt_flag() {\n-  set_suspend_flag(_obj_deopt);\n-}\n-inline void Thread::clear_obj_deopt_flag() {\n-  clear_suspend_flag(_obj_deopt);\n-}\n-\n@@ -122,0 +88,28 @@\n+inline void JavaThread::set_suspend_flag(SuspendFlags f) {\n+  uint32_t flags;\n+  do {\n+    flags = _suspend_flags;\n+  }\n+  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags | f)) != flags);\n+}\n+inline void JavaThread::clear_suspend_flag(SuspendFlags f) {\n+  uint32_t flags;\n+  do {\n+    flags = _suspend_flags;\n+  }\n+  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags & ~f)) != flags);\n+}\n+\n+inline void JavaThread::set_trace_flag() {\n+  set_suspend_flag(_trace_flag);\n+}\n+inline void JavaThread::clear_trace_flag() {\n+  clear_suspend_flag(_trace_flag);\n+}\n+inline void JavaThread::set_obj_deopt_flag() {\n+  set_suspend_flag(_obj_deopt);\n+}\n+inline void JavaThread::clear_obj_deopt_flag() {\n+  clear_suspend_flag(_obj_deopt);\n+}\n+\n@@ -124,2 +118,5 @@\n-  _special_runtime_exit_condition = _async_exception;\n-  set_has_async_exception();\n+  set_async_exception_condition(_async_exception);\n+  \/\/ Set _suspend_flags too so we save a comparison in the transition from native to Java\n+  \/\/ in the native wrappers. It will be cleared in check_and_handle_async_exceptions()\n+  \/\/ when we actually install the exception.\n+  set_suspend_flag(_has_async_exception);\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":33,"deletions":36,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -733,1 +733,0 @@\n-  volatile_nonstatic_field(Thread,             _suspend_flags,                                uint32_t)                              \\\n@@ -746,0 +745,2 @@\n+  volatile_nonstatic_field(JavaThread,         _suspend_flags,                                uint32_t)                              \\\n+  nonstatic_field(JavaThread,                  _async_exception_condition,                    JavaThread::AsyncExceptionCondition)   \\\n@@ -750,1 +751,0 @@\n-  nonstatic_field(JavaThread,                  _special_runtime_exit_condition,               JavaThread::AsyncRequests)             \\\n@@ -1986,1 +1986,1 @@\n-  declare_integer_type(JavaThread::AsyncRequests)                         \\\n+  declare_integer_type(JavaThread::AsyncExceptionCondition)               \\\n@@ -2146,1 +2146,1 @@\n-  declare_constant(Thread::_has_async_exception)                          \\\n+  declare_constant(JavaThread::_has_async_exception)                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-    suspendFlagsField = typeThread.getCIntegerField(\"_suspend_flags\");\n-    HAS_ASYNC_EXCEPTION = db.lookupIntConstant(\"Thread::_has_async_exception\").intValue();\n+    suspendFlagsField = typeJavaThread.getCIntegerField(\"_suspend_flags\");\n+    HAS_ASYNC_EXCEPTION = db.lookupIntConstant(\"JavaThread::_has_async_exception\").intValue();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Thread.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}