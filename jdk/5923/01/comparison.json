{"files":[{"patch":"@@ -38,2 +38,2 @@\n- * HotSpot Java Virtual Machines on the local host and possibly for a\n- * specific user. The ability to detect all possible HotSpot Java Virtual\n+ * HotSpot Java Virtual Machines on the local host that can be accessed\n+ * by the current user. The ability to detect all possible HotSpot Java Virtual\n@@ -41,1 +41,1 @@\n- * principal running this JVM.\n+ * current user running this JVM.\n@@ -47,10 +47,3 @@\n-    private String userName;                 \/\/ user name for monitored jvm\n-    private Pattern userPattern;\n-    private Matcher userMatcher;\n-    private FilenameFilter userFilter;\n-    private Pattern filePattern;\n-    private Matcher fileMatcher;\n-    private FilenameFilter fileFilter;\n-    private Pattern tmpFilePattern;\n-    private Matcher tmpFileMatcher;\n-    private FilenameFilter tmpFileFilter;\n+    private FilenameFilter userDirFilter;\n+    private FilenameFilter userDirFileFilter;\n+    private FilenameFilter oldtmpFileFilter;\n@@ -61,1 +54,1 @@\n-     * Manages LocalMonitoredVm instances for which the principal\n+     * Manages LocalMonitoredVm instances for which the current user\n@@ -65,30 +58,3 @@\n-        this(null);\n-    }\n-\n-    \/**\n-     * Creates a LocalVmManager instance for the given user.\n-     * <p>\n-     * Manages LocalMonitoredVm instances for all JVMs owned by the specified\n-     * user.\n-     *\n-     * @param user the name of the user\n-     *\/\n-    public LocalVmManager(String user) {\n-        this.userName = user;\n-\n-        if (userName == null) {\n-            userPattern = Pattern.compile(PerfDataFile.userDirNamePattern);\n-            userMatcher = userPattern.matcher(\"\");\n-\n-            userFilter = new FilenameFilter() {\n-                public boolean accept(File dir, String name) {\n-                    userMatcher.reset(name);\n-                    return userMatcher.lookingAt();\n-                }\n-            };\n-        }\n-\n-        filePattern = Pattern.compile(PerfDataFile.fileNamePattern);\n-        fileMatcher = filePattern.matcher(\"\");\n-\n-        fileFilter = new FilenameFilter() {\n+        \/\/ 1.4.2 and later: The files are in {tmpdir}\/hsperfdata_{any_user_name}\/[0-9]+\n+        Pattern userDirPattern = Pattern.compile(PerfDataFile.userDirNamePattern);\n+        userDirFilter = new FilenameFilter() {\n@@ -96,2 +62,1 @@\n-                fileMatcher.reset(name);\n-                return fileMatcher.matches();\n+                return userDirPattern.matcher(name).lookingAt();\n@@ -101,2 +66,6 @@\n-        tmpFilePattern = Pattern.compile(PerfDataFile.tmpFileNamePattern);\n-        tmpFileMatcher = tmpFilePattern.matcher(\"\");\n+        Pattern userDirFilePattern = Pattern.compile(PerfDataFile.fileNamePattern);\n+        userDirFileFilter = new FilenameFilter() {\n+            public boolean accept(File dir, String name) {\n+                return userDirFilePattern.matcher(name).matches();\n+            }\n+        };\n@@ -104,1 +73,4 @@\n-        tmpFileFilter = new FilenameFilter() {\n+        \/\/ 1.4.1 (or earlier?): the files are stored directly under {tmpdir}\/ with\n+        \/\/ the following pattern.\n+        Pattern oldtmpFilePattern = Pattern.compile(PerfDataFile.tmpFileNamePattern);\n+        oldtmpFileFilter = new FilenameFilter() {\n@@ -106,2 +78,1 @@\n-                tmpFileMatcher.reset(name);\n-                return tmpFileMatcher.matches();\n+                return oldtmpFilePattern.matcher(name).matches();\n@@ -113,8 +84,2 @@\n-     * Return the current set of monitorable Java Virtual Machines.\n-     * <p>\n-     * The set returned by this method depends on the user name passed\n-     * to the constructor. If no user name was specified, then this\n-     * method will return all candidate JVMs on the system. Otherwise,\n-     * only the JVMs for the given user will be returned. This assumes\n-     * that principal associated with this JVM has the appropriate\n-     * permissions to access the target set of JVMs.\n+     * Return the current set of monitorable Java Virtual Machines that\n+     * are accessible by the current user.\n@@ -126,4 +91,3 @@\n-         * This method is synchronized because the Matcher object used by\n-         * fileFilter is not safe for concurrent use, and this method is\n-         * called by multiple threads. Before this method was synchronized,\n-         * we'd see strange file names being matched by the matcher.\n+         * TODO: this method was synchronized due to its thread-unsafe use of the regexp\n+         * Matcher objects. That is not the case anymore, but I am too afraid to change\n+         * it now. Maybe fix this later in a separate RFE.\n@@ -132,1 +96,1 @@\n-        List<String> tmpdirs = PerfDataFile.getTempDirectories(userName, 0);\n+        List<String> tmpdirs = PerfDataFile.getTempDirectories(0);\n@@ -140,10 +104,0 @@\n-            if (userName == null) {\n-                \/*\n-                 * get a list of all of the user temporary directories and\n-                 * iterate over the list to find any files within those directories.\n-                 *\/\n-                File[] dirs = tmpdir.listFiles(userFilter);\n-                for (int i = 0 ; i < dirs.length; i ++) {\n-                    if (!dirs[i].isDirectory()) {\n-                        continue;\n-                    }\n@@ -151,12 +105,6 @@\n-                    \/\/ get a list of files from the directory\n-                    File[] files = dirs[i].listFiles(fileFilter);\n-                    if (files != null) {\n-                        for (int j = 0; j < files.length; j++) {\n-                            if (files[j].isFile() && files[j].canRead()) {\n-                                int vmid = PerfDataFile.getLocalVmId(files[j]);\n-                                if (vmid != -1) {\n-                                  jvmSet.add(vmid);\n-                                }\n-                            }\n-                        }\n-                    }\n+            \/\/ 1.4.2 and later: Look for the files {tmpdir}\/hsperfdata_{any_user_name}\/[0-9]+\n+            \/\/ that are readable by the current user.\n+            File[] dirs = tmpdir.listFiles(userDirFilter);\n+            for (int i = 0 ; i < dirs.length; i ++) {\n+                if (!dirs[i].isDirectory()) {\n+                    continue;\n@@ -164,9 +112,0 @@\n-            } else {\n-                \/*\n-                 * Check if the user directory can be accessed. Any of these\n-                 * conditions may have asynchronously changed between subsequent\n-                 * calls to this method.\n-                 *\/\n-\n-                \/\/ get the list of files from the specified user directory\n-                File[] files = tmpdir.listFiles(fileFilter);\n@@ -174,0 +113,2 @@\n+                \/\/ get a list of files from the directory\n+                File[] files = dirs[i].listFiles(userDirFileFilter);\n@@ -186,2 +127,2 @@\n-            \/\/ look for any 1.4.1 files\n-            File[] files = tmpdir.listFiles(tmpFileFilter);\n+            \/\/ look for any 1.4.1 files that are readable by the current user.\n+            File[] files = tmpdir.listFiles(oldtmpFileFilter);\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/local\/LocalVmManager.java","additions":38,"deletions":97,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,162 +87,0 @@\n-    \/**\n-     * Get a File object for the instrumentation backing store file\n-     * for the JVM identified by the given local Vm Identifier.\n-     * <p>\n-     * This method looks for the most up to date backing store file for\n-     * the given {@code lvmid}. It will search all the user specific\n-     * directories in the temporary directory for the host operating\n-     * system, which may be influenced by platform specific environment\n-     * variables.\n-     *\n-     * @param lvmid  the local Java Virtual Machine Identifier for the target\n-     * @return File - a File object to the backing store file for the named\n-     *                shared memory region of the target JVM.\n-     * @see java.io.File\n-     * @see #getTempDirectories()\n-     *\/\n-    public static File getFile(int lvmid) {\n-        if (lvmid == 0) {\n-            \/*\n-             * lvmid == 0 is used to indicate the current Java Virtual Machine.\n-             * If the SDK provided an API to get a unique Java Virtual Machine\n-             * identifier, then a filename could be constructed with that\n-             * identifier. In absence of such an api, return null.\n-             *\/\n-            return null;\n-        }\n-\n-        List<String> tmpDirs = getTempDirectories(null, lvmid);\n-        File newest = null;\n-\n-        for (String dir : tmpDirs) {\n-            \/*\n-             * iterate over all files in all directories in this tmpDir that\n-             * match the file name patterns.\n-             *\/\n-            File tmpDir = new File(dir);\n-            String[] files = tmpDir.list(new FilenameFilter() {\n-                public boolean accept(File dir, String name) {\n-                    if (!name.startsWith(dirNamePrefix)) {\n-                        return false;\n-                    }\n-                    File candidate = new File(dir, name);\n-                    return ((candidate.isDirectory() || candidate.isFile())\n-                            && candidate.canRead());\n-                }\n-            });\n-\n-            long newestTime = 0;\n-\n-            for (String file : files) {\n-                File f = new File(dir + file);\n-                File candidate = null;\n-\n-                if (f.exists() && f.isDirectory()) {\n-                    \/*\n-                     * found a directory matching the name patterns. This\n-                     * is a 1.4.2 hsperfdata_<user> directory. Check for\n-                     * file named <lvmid> in that directory\n-                     *\/\n-                    String name = f.getAbsolutePath() + File.separator + lvmid;\n-                    candidate = new File(name);\n-                    \/\/ Try NameSpace Id if Host Id doesn't exist.\n-                    if (!candidate.exists()) {\n-                        name = f.getAbsolutePath() + File.separator +\n-                               platSupport.getNamespaceVmId(lvmid);\n-                        candidate = new File(name);\n-                    }\n-                } else if (f.exists() && f.isFile()) {\n-                    \/*\n-                     * found a file matching the name patterns. This\n-                     * is a 1.4.1 hsperfdata_<lvmid> file.\n-                     *\/\n-                    candidate = f;\n-\n-                } else {\n-                    \/\/ unexpected - let conditional below filter this one out\n-                    candidate = f;\n-                }\n-\n-                if (candidate.exists() && candidate.isFile()\n-                        && candidate.canRead()) {\n-                    long modTime = candidate.lastModified();\n-                    if (modTime >= newestTime) {\n-                        newestTime = modTime;\n-                        newest = candidate;\n-                    }\n-                }\n-            }\n-        }\n-        return newest;\n-    }\n-\n-    \/**\n-     * Return the File object for the backing store file for the specified Java\n-     * Virtual Machine.\n-     * <p>\n-     * This method looks for the most up to date backing store file for\n-     * the JVM identified by the given user name and lvmid. The directory\n-     * searched is the temporary directory for the host operating system,\n-     * which may be influenced by environment variables.\n-     *\n-     * @param user   the user name\n-     * @param lvmid  the local Java Virtual Machine Identifier for the target\n-     * @return File - a File object to the backing store file for the named\n-     *                shared memory region of the target JVM.\n-     * @see java.io.File\n-     * @see #getTempDirectories()\n-     *\/\n-    public static File getFile(String user, int lvmid) {\n-        if (lvmid == 0) {\n-            \/*\n-             * lvmid == 0 is used to indicate the current Java Virtual Machine.\n-             * If the SDK provided an API to get a unique Java Virtual Machine\n-             * identifier, then a filename could be constructed with that\n-             * identifier. In absence of such an api, return null.\n-             *\/\n-            return null;\n-        }\n-\n-        \/\/ first try for 1.4.2 and later JVMs\n-        List<String> tmpDirs = getTempDirectories(user, lvmid);\n-        String basename;\n-        File f;\n-\n-        for (String dir : tmpDirs) {\n-            basename = dir + lvmid;\n-            f = new File(basename);\n-            if (f.exists() && f.isFile() && f.canRead()) {\n-                return f;\n-            }\n-            \/\/ Try NameSpace Id if Host Id doesn't exist.\n-            basename = dir + platSupport.getNamespaceVmId(lvmid);\n-            f = new File(basename);\n-            if (f.exists() && f.isFile() && f.canRead()) {\n-                return f;\n-            }\n-        }\n-\n-        \/\/ No hit on 1.4.2 JVMs, try 1.4.1 files\n-        long newestTime = 0;\n-        File newest = null;\n-        for (int i = 0; i < 2; i++) {\n-            if (i == 0) {\n-                basename = getTempDirectory() + Integer.toString(lvmid);\n-            } else {\n-                basename = getTempDirectory() + Integer.toString(lvmid)\n-                           + Integer.toString(i);\n-            }\n-\n-            f = new File(basename);\n-\n-            if (f.exists() && f.isFile() && f.canRead()) {\n-                long modTime = f.lastModified();\n-                if (modTime >= newestTime) {\n-                    newestTime = modTime;\n-                    newest = f;\n-                }\n-            }\n-        }\n-        return newest;\n-    }\n-\n@@ -297,16 +135,0 @@\n-    \/**\n-     * Return the name of the temporary directory to be searched\n-     * for HotSpot PerfData backing store files for a given user.\n-     * <p>\n-     * This method generally returns the name of a subdirectory of\n-     * the directory indicated in the java.io.tmpdir property. However,\n-     * on some platforms it may return a different directory, as the\n-     * JVM implementation may store the PerfData backing store files\n-     * in a different directory for performance reasons.\n-     *\n-     * @return String - the name of the temporary directory.\n-     *\/\n-    public static String getTempDirectory(String user) {\n-        return getTempDirectory() + dirNamePrefix + user + File.separator;\n-    }\n-\n@@ -322,11 +144,2 @@\n-    public static List<String> getTempDirectories(String userName, int vmid) {\n-        List<String> list = platSupport.getTemporaryDirectories(vmid);\n-        if (userName == null) {\n-            return list;\n-        }\n-\n-        List<String> nameList = list.stream()\n-            .map(name -> name + dirNamePrefix + userName + File.separator)\n-            .collect(Collectors.toList());\n-\n-        return nameList;\n+    public static List<String> getTempDirectories(int vmid) {\n+        return platSupport.getTemporaryDirectories(vmid);\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/local\/PerfDataFile.java","additions":3,"deletions":190,"binary":false,"changes":193,"status":"modified"}]}