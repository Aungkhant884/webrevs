{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,6 +70,0 @@\n-\n-void LambdaFormInvokers::append_filtered(char* line) {\n-  if (should_be_archived(line)) {\n-      append(line);\n-  }\n-}\n@@ -183,0 +177,9 @@\n+\/\/ check if a class name is a species\n+bool is_a_species(const char* species_name) {\n+  log_info(cds)(\"Checking class %s\", species_name);\n+  if (strstr(species_name, \"java\/lang\/invoke\/BoundMethodHandle$Species_\") != nullptr) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -191,0 +194,6 @@\n+  \/\/ the species is shared in base archive, skip it.\n+  if (klass->is_regenerated() && is_a_species(name)) {\n+    log_info(cds)(\"Skip regenerating for shared  %s\", name);\n+    return;\n+  }\n+\n@@ -214,2 +223,2 @@\n-  \/\/ exclude the existing class from dump\n-  SystemDictionaryShared::set_excluded(InstanceKlass::cast(klass));\n+  result->set_regenerated();  \/\/ mark for regenerated\n+  SystemDictionaryShared::set_excluded(InstanceKlass::cast(klass)); \/\/ exclude the existing class from dump\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-  static void append_filtered(char* line);\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1418,0 +1418,5 @@\n+    \/\/ We did not save the classfile data of the regenerated LambdaForm invoker classes,\n+    \/\/ so we cannot support CLFH for such classes.\n+    if (record->_klass->is_regenerated() && JvmtiExport::should_post_class_file_load_hook()) {\n+       return NULL;\n+    }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -178,1 +178,2 @@\n-    _verified_at_dump_time = 8\n+    _verified_at_dump_time = 8,\n+    _regenerated = 16\n@@ -342,0 +343,7 @@\n+  void set_regenerated() {\n+    CDS_ONLY(_shared_class_flags |= _regenerated;)\n+  }\n+  bool is_regenerated() const {\n+    CDS_ONLY(return (_shared_class_flags & _regenerated) != 0;)\n+    NOT_CDS(return false;)\n+  }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3687,1 +3687,1 @@\n-      \/\/ Note: LambdaFormInvokers::append_filtered and LambdaFormInvokers::append take same format which is not\n+      \/\/ Note: LambdaFormInvokers::append take same format which is not\n@@ -3689,1 +3689,1 @@\n-      LambdaFormInvokers::append_filtered(os::strdup((const char*)c_line, mtInternal));\n+      LambdaFormInvokers::append(os::strdup((const char*)c_line, mtInternal));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class CDSLambdaInvoker {\n+    public static void main(String args[]) throws Throwable {\n+        invoke(MethodHandles.identity(double.class), 1.0);\n+        invoke(MethodHandles.identity(long.class), 1);\n+        invoke(MethodHandles.identity(int.class), 1);\n+        invoke(MethodHandles.identity(float.class), 1.0f);\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodType mt = MethodType.methodType(void.class, float.class, double.class, int.class,\n+                                              boolean.class, Object.class, long.class, double.class);\n+        MethodHandle mh = lookup.findStatic(CDSLambdaInvoker.class, \"callme\", mt);\n+        mh.invokeExact(4.0f, 5.0, 6, true, (Object)args, 7L, 8.0);\n+    }\n+\n+    private static Object invoke(MethodHandle mh, Object ... args) throws Throwable {\n+        try {\n+            for (Object o : args) {\n+                mh = MethodHandles.insertArguments(mh, 0, o);\n+            }\n+            return mh.invoke();\n+        } catch (Throwable t) {\n+            System.out.println(\"Failed to find, link and\/or invoke \" + mh.toString() + \": \" + t.getMessage());\n+            throw t;\n+        }\n+    }\n+\n+    private static void callme(float f, double d, int i, boolean b, Object o, long l, double d2) {\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/CDSLambdaInvoker.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary test archive lambda invoker species type in dynamic dump\n+ * @bug 8280767\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\n+ * @compile CDSLambdaInvoker.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cds-test.jar CDSLambdaInvoker\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. TestLambdaInvokers\n+ *\/\n+\n+public class TestLambdaInvokers extends DynamicArchiveTestBase {\n+    private static final String mainClass = \"CDSLambdaInvoker\";\n+    private static final String jarFile   = \"cds-test.jar\";\n+    private static void doTest(String topArchiveName) throws Exception {\n+        dump(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\",\n+             jarFile,\n+             mainClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldContain(\"Skip regenerating for shared\");\n+             });\n+        run(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-Xlog:class+load\",\n+             \"-cp\",\n+             jarFile,\n+             mainClass)\n+             .assertNormalExit(output -> {\n+                 \/\/ java.lang.invoke.BoundMethodHandle$Species_JL is generated from CDSLambdaInvoker\n+                 output.shouldContain(\"java.lang.invoke.BoundMethodHandle$Species_JL source: shared objects file (top)\");\n+             });\n+    }\n+\n+    static void testWithDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(topArchiveName);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(TestLambdaInvokers::testWithDefaultBase);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestLambdaInvokers.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}