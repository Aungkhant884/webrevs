{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import java.nio.channels.Channel;\n@@ -217,0 +218,1 @@\n+    @Override\n@@ -248,0 +250,1 @@\n+    @Override\n@@ -283,0 +286,1 @@\n+    @Override\n@@ -315,0 +319,1 @@\n+    @Override\n@@ -351,0 +356,1 @@\n+    @Override\n@@ -380,0 +386,1 @@\n+    @Override\n@@ -409,0 +416,1 @@\n+    @Override\n@@ -436,0 +444,1 @@\n+    @Override\n@@ -513,0 +522,1 @@\n+    @Override\n@@ -537,1 +547,1 @@\n-    \/\/ Assume at first that the underlying kernel supports sendfile();\n+    \/\/ Assume at first that the underlying kernel supports sendfile\/equivalent;\n@@ -540,1 +550,1 @@\n-    private static volatile boolean transferToNotSupported;\n+    private static volatile boolean transferToDirectNotSupported;\n@@ -542,2 +552,2 @@\n-    \/\/ Assume that the underlying kernel sendfile() will work if the target\n-    \/\/ fd is a pipe; set this to false if we find out later that it doesn't\n+    \/\/ Assume that the underlying kernel sendfile\/equivalent will work if the target\n+    \/\/ fd is a file; set this to true if we find out later that it doesn't\n@@ -545,1 +555,1 @@\n-    private static volatile boolean pipeSupported = true;\n+    private static volatile boolean transferToFileDirectNotSupported;\n@@ -547,4 +557,13 @@\n-    \/\/ Assume that the underlying kernel sendfile() will work if the target\n-    \/\/ fd is a file; set this to false if we find out later that it doesn't\n-    \/\/\n-    private static volatile boolean fileSupported = true;\n+    \/**\n+     * Marks the beginning of a transfer to or from this channel.\n+     * @throws ClosedChannelException if channel is closed\n+     *\/\n+    private int beforeTransfer() throws ClosedChannelException {\n+        int ti = threads.add();\n+        if (isOpen()) {\n+            return ti;\n+        } else {\n+            threads.remove(ti);\n+            throw new ClosedChannelException();\n+        }\n+    }\n@@ -552,3 +571,71 @@\n-    private long transferToDirectlyInternal(long position, int icount,\n-                                            WritableByteChannel target,\n-                                            FileDescriptor targetFD)\n+    \/**\n+     * Marks the end of a transfer to or from this channel.\n+     * @throws AsynchronousCloseException if not completed and the channel is closed\n+     *\/\n+    private void afterTransfer(boolean completed, int ti) throws AsynchronousCloseException {\n+        threads.remove(ti);\n+        if (!completed && !isOpen()) {\n+            throw new AsynchronousCloseException();\n+        }\n+    }\n+\n+    \/**\n+     * Invoked when ClosedChannelException is thrown during a transfer. This method\n+     * translates it to an AsynchronousCloseException or ClosedByInterruptException. In\n+     * the case of ClosedByInterruptException, it ensures that this channel and the\n+     * source\/target channel are closed.\n+     *\/\n+    private AsynchronousCloseException transferFailed(ClosedChannelException cce, Channel other) {\n+        ClosedByInterruptException cbie = null;\n+        if (cce instanceof ClosedByInterruptException e) {\n+            assert Thread.currentThread().isInterrupted();\n+            cbie = e;\n+        } else if (!uninterruptible && Thread.currentThread().isInterrupted()) {\n+            cbie = new ClosedByInterruptException();\n+        }\n+        if (cbie != null) {\n+            try {\n+                this.close();\n+            } catch (IOException ioe) {\n+                cbie.addSuppressed(ioe);\n+            }\n+            try {\n+                other.close();\n+            } catch (IOException ioe) {\n+                cbie.addSuppressed(ioe);\n+            }\n+            return cbie;\n+\n+        }\n+        \/\/ one of the channels was closed during the transfer\n+        if (cce instanceof AsynchronousCloseException ace) {\n+            return ace;\n+        } else {\n+            var ace = new AsynchronousCloseException();\n+            ace.addSuppressed(cce);\n+            return ace;\n+        }\n+    }\n+\n+    \/**\n+     * Transfers bytes from this channel's file to the resource that the given file\n+     * descriptor is connected to.\n+     *\/\n+    private long transferToFileDescriptor(long position, int count, FileDescriptor targetFD) {\n+        long n;\n+        boolean append = fdAccess.getAppend(targetFD);\n+        do {\n+            long comp = Blocker.begin();\n+            try {\n+                n = nd.transferTo(fd, position, count, targetFD, append);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        } while ((n == IOStatus.INTERRUPTED) && isOpen());\n+        return n;\n+    }\n+\n+    \/**\n+     * Transfers bytes from this channel's file to the given channel's file.\n+     *\/\n+    private long transferToFileChannel(long position, int count, FileChannelImpl target)\n@@ -557,2 +644,2 @@\n-        assert !nd.transferToDirectlyNeedsPositionLock() ||\n-               Thread.holdsLock(positionLock);\n+        if (transferToFileDirectNotSupported)\n+            return IOStatus.UNSUPPORTED_CASE;\n@@ -560,2 +647,2 @@\n-        long n = -1;\n-        int ti = -1;\n+        final FileChannelImpl source = this;\n+        boolean completed = false;\n@@ -564,6 +651,3 @@\n-            ti = threads.add();\n-            if (!isOpen())\n-                return -1;\n-            boolean append = fdAccess.getAppend(targetFD);\n-            do {\n-                long comp = Blocker.begin();\n+            int sourceIndex = source.beforeTransfer();\n+            try {\n+                int targetIndex = target.beforeTransfer();\n@@ -571,1 +655,11 @@\n-                    n = nd.transferTo(fd, position, icount, targetFD, append);\n+                    long n = transferToFileDescriptor(position, count, target.fd);\n+                    if (n == IOStatus.UNSUPPORTED_CASE) {\n+                        transferToFileDirectNotSupported = true;\n+                        return IOStatus.UNSUPPORTED_CASE;\n+                    }\n+                    if (n == IOStatus.UNSUPPORTED) {\n+                        transferToDirectNotSupported = true;\n+                        return IOStatus.UNSUPPORTED;\n+                    }\n+                    completed = (n >= 0);\n+                    return IOStatus.normalize(n);\n@@ -573,1 +667,1 @@\n-                    Blocker.end(comp);\n+                    target.afterTransfer(completed, targetIndex);\n@@ -575,12 +669,2 @@\n-            } while ((n == IOStatus.INTERRUPTED) && isOpen());\n-            if (n == IOStatus.UNSUPPORTED_CASE) {\n-                if (target instanceof SinkChannelImpl)\n-                    pipeSupported = false;\n-                if (target instanceof FileChannelImpl)\n-                    fileSupported = false;\n-                return IOStatus.UNSUPPORTED_CASE;\n-            }\n-            if (n == IOStatus.UNSUPPORTED) {\n-                \/\/ Don't bother trying again\n-                transferToNotSupported = true;\n-                return IOStatus.UNSUPPORTED;\n+            } finally {\n+                source.afterTransfer(completed, sourceIndex);\n@@ -588,1 +672,0 @@\n-            return IOStatus.normalize(n);\n@@ -590,2 +673,1 @@\n-            threads.remove(ti);\n-            end (n > -1);\n+            endBlocking(completed);\n@@ -595,2 +677,4 @@\n-    private long transferToDirectly(long position, int icount,\n-                                    WritableByteChannel target)\n+    \/**\n+     * Transfers bytes from this channel's file to the given channel's socket.\n+     *\/\n+    private long transferToSocketChannel(long position, int count, SocketChannelImpl target)\n@@ -599,12 +683,28 @@\n-        if (transferToNotSupported)\n-            return IOStatus.UNSUPPORTED;\n-\n-        FileDescriptor targetFD = null;\n-        if (target instanceof FileChannelImpl) {\n-            if (!fileSupported)\n-                return IOStatus.UNSUPPORTED_CASE;\n-            targetFD = ((FileChannelImpl)target).fd;\n-        } else if (target instanceof SelChImpl) {\n-            \/\/ Direct transfer to pipe causes EINVAL on some configurations\n-            if ((target instanceof SinkChannelImpl) && !pipeSupported)\n-                return IOStatus.UNSUPPORTED_CASE;\n+        final FileChannelImpl source = this;\n+        boolean completed = false;\n+        try {\n+            beginBlocking();\n+            int sourceIndex = source.beforeTransfer();\n+            try {\n+                target.beforeTransferTo();\n+                try {\n+                    long n = transferToFileDescriptor(position, count, target.getFD());\n+                    if (n == IOStatus.UNSUPPORTED_CASE) {\n+                        return IOStatus.UNSUPPORTED_CASE;\n+                    }\n+                    if (n == IOStatus.UNSUPPORTED) {\n+                        transferToDirectNotSupported = true;\n+                        return IOStatus.UNSUPPORTED;\n+                    }\n+                    completed = (n >= 0);\n+                    return IOStatus.normalize(n);\n+                } finally {\n+                    target.afterTransferTo(completed);\n+                }\n+            } finally {\n+                source.afterTransfer(completed, sourceIndex);\n+            }\n+        } finally {\n+            endBlocking(completed);\n+        }\n+    }\n@@ -612,5 +712,8 @@\n-            \/\/ Platform-specific restrictions. Now there is only one:\n-            \/\/ Direct transfer to non-blocking channel could be forbidden\n-            SelectableChannel sc = (SelectableChannel)target;\n-            if (!nd.canTransferToDirectly(sc))\n-                return IOStatus.UNSUPPORTED_CASE;\n+    \/**\n+     * Transfers bytes from this channel's file from the given channel's file. This\n+     * implementation uses sendfile, copy_file_range or equivalent.\n+     *\/\n+    private long transferToDirectInternal(long position, int count, WritableByteChannel target)\n+        throws IOException\n+    {\n+        assert !nd.transferToDirectlyNeedsPositionLock() || Thread.holdsLock(positionLock);\n@@ -618,2 +721,6 @@\n-            targetFD = ((SelChImpl)target).getFD();\n-        }\n+        return switch (target) {\n+            case FileChannelImpl fci  -> transferToFileChannel(position, count, fci);\n+            case SocketChannelImpl sci -> transferToSocketChannel(position, count, sci);\n+            default -> IOStatus.UNSUPPORTED_CASE;\n+        };\n+    }\n@@ -621,5 +728,9 @@\n-        if (targetFD == null)\n-            return IOStatus.UNSUPPORTED;\n-        int thisFDVal = IOUtil.fdVal(fd);\n-        int targetFDVal = IOUtil.fdVal(targetFD);\n-        if (thisFDVal == targetFDVal) \/\/ Not supported on some configurations\n+    \/**\n+     * Transfers bytes from this channel's file to the given channel's file or socket.\n+     * @return the number of bytes transferred, UNSUPPORTED_CASE if this transfer cannot\n+     * be done directly, or UNSUPPORTED if there is no direct support\n+     *\/\n+    private long transferToDirect(long position, int count, WritableByteChannel target)\n+        throws IOException\n+    {\n+        if (transferToDirectNotSupported)\n@@ -627,0 +738,2 @@\n+        if (target instanceof SelectableChannel sc && !nd.canTransferToDirectly(sc))\n+            return IOStatus.UNSUPPORTED_CASE;\n@@ -632,2 +745,1 @@\n-                    return transferToDirectlyInternal(position, icount,\n-                                                      target, targetFD);\n+                    return transferToDirectInternal(position, count, target);\n@@ -635,1 +747,5 @@\n-                    position(pos);\n+                    try {\n+                        position(pos);\n+                    } catch (ClosedChannelException ignore) {\n+                        \/\/ can't reset position if channel is closed\n+                    }\n@@ -639,1 +755,1 @@\n-            return transferToDirectlyInternal(position, icount, target, targetFD);\n+            return transferToDirectInternal(position, count, target);\n@@ -651,0 +767,4 @@\n+    \/**\n+     * Transfers bytes from channel's file to the given channel. This implementation\n+     * memory maps this channel's file.\n+     *\/\n@@ -660,1 +780,1 @@\n-            return IOStatus.UNSUPPORTED;\n+            return IOStatus.UNSUPPORTED_CASE;\n@@ -664,3 +784,3 @@\n-            if (posThis - count + 1 <= position &&\n-                position - count + 1 <= posThis &&\n-                !nd.canTransferToFromOverlappedMap()) {\n+            if ((posThis - count + 1 <= position)\n+                    && (position - count + 1 <= posThis)\n+                    && !nd.canTransferToFromOverlappedMap()) {\n@@ -671,1 +791,0 @@\n-        \/\/ Trusted target: Use a mapped buffer\n@@ -678,1 +797,1 @@\n-                    \/\/ ## Bug: Closing this channel will not terminate the write\n+                    \/\/ write may block, closing this channel will not wake it up\n@@ -691,10 +810,0 @@\n-            } catch (ClosedByInterruptException e) {\n-                \/\/ target closed by interrupt as ClosedByInterruptException needs\n-                \/\/ to be thrown after closing this channel.\n-                assert !target.isOpen();\n-                try {\n-                    close();\n-                } catch (Throwable suppressed) {\n-                    e.addSuppressed(suppressed);\n-                }\n-                throw e;\n@@ -711,0 +820,3 @@\n+    \/**\n+     * Transfers bytes from channel's file to the given channel.\n+     *\/\n@@ -716,1 +828,1 @@\n-        int c = (int)Math.min(count, TRANSFER_SIZE);\n+        int c = (int) Math.min(count, TRANSFER_SIZE);\n@@ -722,1 +834,1 @@\n-                bb.limit((int)Math.min(count - tw, TRANSFER_SIZE));\n+                bb.limit((int) Math.min(count - tw, TRANSFER_SIZE));\n@@ -727,2 +839,1 @@\n-                \/\/ ## Bug: Will block writing target if this channel\n-                \/\/ ##      is asynchronously closed\n+                \/\/ write may block, closing this channel will not wake it up\n@@ -744,2 +855,2 @@\n-    public long transferTo(long position, long count,\n-                           WritableByteChannel target)\n+    @Override\n+    public long transferTo(long position, long count, WritableByteChannel target)\n@@ -753,2 +864,1 @@\n-        if (target instanceof FileChannelImpl &&\n-            !((FileChannelImpl)target).writable)\n+        if (target instanceof FileChannelImpl && !((FileChannelImpl) target).writable)\n@@ -758,27 +868,0 @@\n-        final long sz = size();\n-        if (position > sz)\n-            return 0;\n-\n-        \/\/ Now position <= sz so remaining >= 0 and\n-        \/\/ remaining == 0 if and only if sz == 0\n-        long remaining = sz - position;\n-\n-        \/\/ Adjust count only if remaining > 0, i.e.,\n-        \/\/ sz > position which means sz > 0\n-        if (remaining > 0 && remaining < count)\n-            count = remaining;\n-\n-        \/\/ System calls supporting fast transfers might not work on files\n-        \/\/ which advertise zero size such as those in Linux \/proc\n-        if (sz > 0) {\n-            \/\/ Attempt a direct transfer, if the kernel supports it, limiting\n-            \/\/ the number of bytes according to which platform\n-            int icount = (int)Math.min(count, nd.maxDirectTransferSize());\n-            long n;\n-            if ((n = transferToDirectly(position, icount, target)) >= 0)\n-                return n;\n-\n-            \/\/ Attempt a mapped transfer, but only to trusted channel types\n-            if ((n = transferToTrustedChannel(position, count, target)) >= 0)\n-                return n;\n-        }\n@@ -786,2 +869,35 @@\n-        \/\/ Slow path for untrusted targets\n-        return transferToArbitraryChannel(position, count, target);\n+        try {\n+            final long sz = size();\n+            if (position > sz)\n+                return 0;\n+\n+            \/\/ Now position <= sz so remaining >= 0 and\n+            \/\/ remaining == 0 if and only if sz == 0\n+            long remaining = sz - position;\n+\n+            \/\/ Adjust count only if remaining > 0, i.e.,\n+            \/\/ sz > position which means sz > 0\n+            if (remaining > 0 && remaining < count)\n+                count = remaining;\n+\n+            \/\/ System calls supporting fast transfers might not work on files\n+            \/\/ which advertise zero size such as those in Linux \/proc\n+            if (sz > 0) {\n+                \/\/ Attempt a direct transfer, if the kernel supports it, limiting\n+                \/\/ the number of bytes according to which platform\n+                int icount = (int) Math.min(count, nd.maxDirectTransferSize());\n+                long n;\n+                if ((n = transferToDirect(position, icount, target)) >= 0)\n+                    return n;\n+\n+                \/\/ Attempt a mapped transfer, but only to trusted channel types\n+                if ((n = transferToTrustedChannel(position, count, target)) >= 0)\n+                    return n;\n+            }\n+\n+            \/\/ fallback to read\/write loop\n+            return transferToArbitraryChannel(position, count, target);\n+        } catch (ClosedChannelException e) {\n+            \/\/ throw AsynchronousCloseException or ClosedByInterruptException\n+            throw transferFailed(e, target);\n+        }\n@@ -790,0 +906,1 @@\n+\n@@ -793,1 +910,1 @@\n-    private static volatile boolean transferFromNotSupported;\n+    private static volatile boolean transferFromDirectNotSupported;\n@@ -795,2 +912,23 @@\n-    private long transferFromDirectlyInternal(FileDescriptor srcFD,\n-                                              long position, long count)\n+    \/**\n+     * Transfers bytes into this channel's file from the resource that the given file\n+     * descriptor is connected to.\n+     *\/\n+    private long transferFromFileDescriptor(FileDescriptor srcFD, long position, long count) {\n+        long n;\n+        boolean append = fdAccess.getAppend(fd);\n+        do {\n+            long comp = Blocker.begin();\n+            try {\n+                n = nd.transferFrom(srcFD, fd, position, count, append);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        } while ((n == IOStatus.INTERRUPTED) && isOpen());\n+        return n;\n+    }\n+\n+    \/**\n+     * Transfers bytes into this channel's file from the given channel's file. This\n+     * implementation uses copy_file_range or equivalent.\n+     *\/\n+    private long transferFromDirect(FileChannelImpl src, long position, long count)\n@@ -799,2 +937,4 @@\n-        long n = -1;\n-        int ti = -1;\n+        if (transferFromDirectNotSupported)\n+            return IOStatus.UNSUPPORTED;\n+\n+        boolean completed = false;\n@@ -803,5 +943,3 @@\n-            ti = threads.add();\n-            if (!isOpen())\n-                return -1;\n-            do {\n-                long comp = Blocker.begin();\n+            int thisIndex = this.beforeTransfer();\n+            try {\n+                int srcIndex = src.beforeTransfer();\n@@ -809,2 +947,7 @@\n-                    boolean append = fdAccess.getAppend(fd);\n-                    n = nd.transferFrom(srcFD, fd, position, count, append);\n+                    long n = transferFromFileDescriptor(src.fd, position, count);\n+                    if (n == IOStatus.UNSUPPORTED) {\n+                        transferFromDirectNotSupported = true;\n+                        return IOStatus.UNSUPPORTED;\n+                    }\n+                    completed = (n >= 0);\n+                    return IOStatus.normalize(n);\n@@ -812,1 +955,1 @@\n-                    Blocker.end(comp);\n+                    src.afterTransfer(completed, srcIndex);\n@@ -814,5 +957,2 @@\n-            } while ((n == IOStatus.INTERRUPTED) && isOpen());\n-            if (n == IOStatus.UNSUPPORTED) {\n-                \/\/ Don't bother trying again\n-                transferFromNotSupported = true;\n-                return IOStatus.UNSUPPORTED;\n+            } finally {\n+                this.afterTransfer(completed, thisIndex);\n@@ -820,1 +960,0 @@\n-            return IOStatus.normalize(n);\n@@ -822,2 +961,1 @@\n-            threads.remove(ti);\n-            end (n > -1);\n+            endBlocking(completed);\n@@ -827,17 +965,5 @@\n-    private long transferFromDirectly(FileChannelImpl src,\n-                                      long position, long count)\n-        throws IOException\n-    {\n-        if (!src.readable)\n-            throw new NonReadableChannelException();\n-        if (transferFromNotSupported)\n-            return IOStatus.UNSUPPORTED;\n-        FileDescriptor srcFD = src.fd;\n-        if (srcFD == null)\n-            return IOStatus.UNSUPPORTED_CASE;\n-\n-        return transferFromDirectlyInternal(srcFD, position, count);\n-    }\n-\n-    private long transferFromFileChannel(FileChannelImpl src,\n-                                         long position, long count)\n+    \/**\n+     * Transfers bytes into this channel's file from the given channel's file. This\n+     * implementation memory maps the given channel's file.\n+     *\/\n+    private long transferFromFileChannel(FileChannelImpl src, long position, long count)\n@@ -846,2 +972,0 @@\n-        if (!src.readable)\n-            throw new NonReadableChannelException();\n@@ -855,6 +979,5 @@\n-            if (src == this) {\n-                if (position() - max + 1 <= pos &&\n-                    pos - max + 1 <= position() &&\n-                    !nd.canTransferToFromOverlappedMap()) {\n-                    return IOStatus.UNSUPPORTED_CASE;\n-                }\n+            if (src == this\n+                    && (position() - max + 1 <= pos)\n+                    && (pos - max + 1 <= position())\n+                    && !nd.canTransferToFromOverlappedMap()) {\n+                return IOStatus.UNSUPPORTED_CASE;\n@@ -867,1 +990,0 @@\n-                \/\/ ## Bug: Closing this channel will not terminate the write\n@@ -892,0 +1014,3 @@\n+    \/**\n+     * Transfers bytes into this channel's file from the given channel.\n+     *\/\n@@ -896,2 +1021,1 @@\n-        \/\/ Untrusted target: Use a newly-erased buffer\n-        int c = (int)Math.min(count, TRANSFER_SIZE);\n+        int c = (int) Math.min(count, TRANSFER_SIZE);\n@@ -903,3 +1027,2 @@\n-                bb.limit((int)Math.min((count - tw), (long)TRANSFER_SIZE));\n-                \/\/ ## Bug: Will block reading src if this channel\n-                \/\/ ##      is asynchronously closed\n+                bb.limit((int) Math.min((count - tw), TRANSFER_SIZE));\n+                \/\/ read may block, closing this channel will not wake it up\n@@ -925,2 +1048,2 @@\n-    public long transferFrom(ReadableByteChannel src,\n-                             long position, long count)\n+    @Override\n+    public long transferFrom(ReadableByteChannel src, long position, long count)\n@@ -939,9 +1062,10 @@\n-        \/\/ System calls supporting fast transfers might not work on files\n-        \/\/ which advertise zero size such as those in Linux \/proc\n-        if (src instanceof FileChannelImpl fci && fci.size() > 0) {\n-            long n;\n-            if ((n = transferFromDirectly(fci, position, count)) >= 0)\n-                return n;\n-            if ((n = transferFromFileChannel(fci, position, count)) >= 0)\n-                return n;\n-        }\n+        try {\n+            \/\/ System calls supporting fast transfers might not work on files\n+            \/\/ which advertise zero size such as those in Linux \/proc\n+            if (src instanceof FileChannelImpl fci && fci.size() > 0) {\n+                long n;\n+                if ((n = transferFromDirect(fci, position, count)) >= 0)\n+                    return n;\n+                if ((n = transferFromFileChannel(fci, position, count)) >= 0)\n+                    return n;\n+            }\n@@ -949,1 +1073,6 @@\n-        return transferFromArbitraryChannel(src, position, count);\n+            \/\/ fallback to read\/write loop\n+            return transferFromArbitraryChannel(src, position, count);\n+        } catch (ClosedChannelException e) {\n+            \/\/ throw AsynchronousCloseException or ClosedByInterruptException\n+            throw transferFailed(e, src);\n+        }\n@@ -952,0 +1081,1 @@\n+    @Override\n@@ -997,0 +1127,1 @@\n+    @Override\n@@ -1181,0 +1312,1 @@\n+    @Override\n@@ -1208,3 +1340,2 @@\n-    public MemorySegment map(MapMode mode, long offset, long size,\n-                             Arena arena)\n-            throws IOException\n+    public MemorySegment map(MapMode mode, long offset, long size, Arena arena)\n+        throws IOException\n@@ -1463,0 +1594,1 @@\n+    @Override\n@@ -1515,0 +1647,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":322,"deletions":189,"binary":false,"changes":511,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -621,0 +621,40 @@\n+    \/**\n+     * Marks the beginning of a transfer to this channel.\n+     * @throws ClosedChannelException if channel is closed or the output is shutdown\n+     * @throws NotYetConnectedException if open and not connected\n+     *\/\n+    void beforeTransferTo() throws ClosedChannelException {\n+        boolean completed = false;\n+        writeLock.lock();\n+        try {\n+            synchronized (stateLock) {\n+                ensureOpenAndConnected();\n+                if (isOutputClosed)\n+                    throw new ClosedChannelException();\n+                writerThread = NativeThread.current();\n+                completed = true;\n+            }\n+        } finally {\n+            if (!completed) {\n+                writeLock.unlock();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Marks the end of a transfer to this channel.\n+     * @throws AsynchronousCloseException if not completed and the channel is closed\n+     *\/\n+    void afterTransferTo(boolean completed) throws AsynchronousCloseException {\n+        synchronized (stateLock) {\n+            writerThread = 0;\n+            if (state == ST_CLOSING) {\n+                tryFinishClose();\n+            }\n+        }\n+        writeLock.unlock();\n+        if (!completed && !isOpen()) {\n+            throw new AsynchronousCloseException();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8310902\n+ * @summary Test async close and interrupt during FileChannel transferTo\/transferFrom\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run junit CloseDuringTransfer\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Random;\n+import java.util.concurrent.*;\n+import java.util.stream.Stream;\n+import static java.nio.file.StandardOpenOption.*;\n+import static java.util.concurrent.TimeUnit.*;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import org.junit.jupiter.api.*;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class CloseDuringTransfer {\n+    private static final int SOURCE_SIZE = 1024 * 1024;\n+    private static final Random RAND = RandomFactory.getRandom();\n+\n+    \/\/ used for schedule close and interrupt\n+    private static ScheduledExecutorService scheduler;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        ThreadFactory factory = Executors.defaultThreadFactory();\n+        scheduler = Executors.newScheduledThreadPool(8, factory);\n+    }\n+\n+    @AfterAll\n+    static void finish() {\n+        scheduler.shutdown();\n+    }\n+\n+    \/**\n+     * Channels that may be used as a transferTo target.\n+     *\/\n+    static Stream<WritableByteChannel> targets() throws Exception {\n+        return Stream.of(\n+                fileChannelTarget(),\n+                socketChannelTarget(),\n+                pipeSink(),\n+                arbitraryTarget()\n+        );\n+    }\n+\n+    \/**\n+     * Channels that may be used as a transferFrom source.\n+     *\/\n+    static Stream<ReadableByteChannel> sources() throws Exception {\n+        return Stream.of(\n+                fileChannelSource(SOURCE_SIZE),\n+                socketChannelSource(SOURCE_SIZE),\n+                pipeSource(SOURCE_SIZE),\n+                arbitrarySource(SOURCE_SIZE)\n+        );\n+    }\n+\n+    \/**\n+     * Close source file channel during transferTo.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"targets\")\n+    void testCloseSourceDuringTransferTo(WritableByteChannel target) throws Exception {\n+        try (FileChannel src = fileChannelSource(SOURCE_SIZE); target) {\n+            scheduleClose(src);\n+            try {\n+                long n = src.transferTo(0, Long.MAX_VALUE, target);\n+                assertTrue(n > 0);\n+            } catch (ClosedChannelException e) {\n+                assertFalse(src.isOpen());\n+            }\n+            assertTrue(target.isOpen());\n+        }\n+    }\n+\n+    \/**\n+     * Close target channel during transferTo.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"targets\")\n+    void testCloseTargetDuringTransferTo(WritableByteChannel target) throws Exception {\n+        try (FileChannel src = fileChannelSource(SOURCE_SIZE); target) {\n+            scheduleClose(target);\n+            try {\n+                long n = src.transferTo(0, Long.MAX_VALUE, target);\n+                assertTrue(n > 0);\n+            } catch (ClosedChannelException e) {\n+                assertFalse(target.isOpen());\n+            }\n+            assertTrue(src.isOpen());\n+        }\n+    }\n+\n+    \/**\n+     * Interrupt thread during transferTo.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"targets\")\n+    void testInterruptDuringTransferTo(WritableByteChannel target) throws Exception {\n+        try (FileChannel src = fileChannelSource(SOURCE_SIZE); target) {\n+            Future<?> interrupter = scheduleInterrupt();\n+            try {\n+                long n = src.transferTo(0, Long.MAX_VALUE, target);\n+                assertTrue(n > 0);\n+            } catch (ClosedByInterruptException e) {\n+                assertTrue(Thread.currentThread().isInterrupted());\n+                assertFalse(src.isOpen());\n+                assertFalse(target.isOpen());\n+            } finally {\n+                finishInterrupt(interrupter);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Close source channel during transferFrom.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sources\")\n+    void testCloseSourceDuringTransferFrom(ReadableByteChannel src) throws Exception {\n+        try (src; FileChannel target = fileChannelTarget()) {\n+            scheduleClose(src);\n+            try {\n+                long n = target.transferFrom(src, 0, Long.MAX_VALUE);\n+                assertTrue(n > 0);\n+            } catch (ClosedChannelException e) {\n+                assertFalse(src.isOpen());\n+            }\n+            assertTrue(target.isOpen());\n+        }\n+    }\n+\n+    \/**\n+     * Close target file channel during transferFrom.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sources\")\n+    void testCloseTargetDuringTransferFrom(ReadableByteChannel src) throws Exception {\n+        try (src;  FileChannel target = fileChannelTarget()) {\n+            scheduleClose(target);\n+            try {\n+                long n = target.transferFrom(src, 0, Long.MAX_VALUE);\n+                assertTrue(n > 0);\n+            } catch (ClosedChannelException e) {\n+                assertFalse(target.isOpen());\n+            }\n+            assertTrue(src.isOpen());\n+        }\n+    }\n+\n+    \/**\n+     * Interrupt thread during transferFrom.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sources\")\n+    void testInterruptTransferDuringTransferFrom(ReadableByteChannel src) throws Exception {\n+        try (src; FileChannel target = fileChannelTarget()) {\n+            Future<?> interrupter = scheduleInterrupt();\n+            try {\n+                long n = target.transferFrom(src, 0, Long.MAX_VALUE);\n+                assertTrue(n > 0);\n+            } catch (ClosedByInterruptException e) {\n+                assertTrue(Thread.currentThread().isInterrupted());\n+                assertFalse(src.isOpen());\n+                assertFalse(target.isOpen());\n+            } finally {\n+                finishInterrupt(interrupter);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Schedules a channel to be closed after a random delay.\n+     *\/\n+    private Future<?> scheduleClose(Channel channel) {\n+        int delay = RAND.nextInt(10);\n+        return scheduler.schedule(() -> {\n+            channel.close();\n+            return null;\n+        }, delay, MILLISECONDS);\n+    }\n+\n+    \/**\n+     * Schedules the caller thread to be interrupted after a random delay.\n+     *\/\n+    private Future<?> scheduleInterrupt() {\n+        Thread thread = Thread.currentThread();\n+        int delay = RAND.nextInt(10);\n+        return scheduler.schedule(() -> {\n+            thread.interrupt();\n+            return null;\n+        }, delay, MILLISECONDS);\n+    }\n+\n+    \/**\n+     * Waits for the interrupt task submitted by scheduleInterrupt, and clears the\n+     * current thread's interrupt status.\n+     *\/\n+    private void finishInterrupt(Future<?> interrupter) throws Exception {\n+        boolean done = false;\n+        while (!done) {\n+            try {\n+                interrupter.get();\n+                done = true;\n+            } catch (InterruptedException e) { }\n+        }\n+        Thread.interrupted();\n+    }\n+\n+    \/**\n+     * Return a FileChannel to a file that reads up to given number of bytes.\n+     *\/\n+    private static FileChannel fileChannelSource(int size) throws Exception {\n+        Path here = Path.of(\".\");\n+        Path source = Files.createTempFile(here, \"source\", \"dat\");\n+        Files.write(source, new byte[size]);\n+        return FileChannel.open(source);\n+    }\n+\n+    \/**\n+     * Return a FileChannel to a file opened for writing.\n+     *\/\n+    private static FileChannel fileChannelTarget() throws Exception {\n+        Path here = Path.of(\".\");\n+        Path target = Files.createTempFile(here, \"target\", \"dat\");\n+        return FileChannel.open(target, CREATE, TRUNCATE_EXISTING, WRITE);\n+    }\n+\n+    \/**\n+     * Return a SocketChannel to a socket that reads up to given number of bytes.\n+     *\/\n+    private static SocketChannel socketChannelSource(int size) throws Exception {\n+        var lb = InetAddress.getLoopbackAddress();\n+        try (var listener = ServerSocketChannel.open()) {\n+            listener.bind(new InetSocketAddress(lb, 0));\n+            SocketChannel sc1 = SocketChannel.open();\n+            SocketChannel sc2 = null;\n+            try {\n+                sc1.socket().connect(listener.getLocalAddress(), 10_000);\n+                sc2 = listener.accept();\n+            } catch (IOException ioe) {\n+                sc1.close();\n+                throw ioe;\n+            }\n+            SocketChannel peer = sc2;\n+            scheduler.submit(() -> {\n+                try (peer) {\n+                    ByteBuffer bb = ByteBuffer.allocate(size);\n+                    while (bb.hasRemaining()) {\n+                        peer.write(bb);\n+                    }\n+                }\n+                return null;\n+            });\n+            return sc1;\n+        }\n+    }\n+\n+    \/**\n+     * Return a SocketChannel with the channel's socket ready for writing.\n+     *\/\n+    private static SocketChannel socketChannelTarget() throws Exception {\n+        var lb = InetAddress.getLoopbackAddress();\n+        try (var listener = ServerSocketChannel.open()) {\n+            listener.bind(new InetSocketAddress(lb, 0));\n+            SocketChannel sc1 = SocketChannel.open();\n+            SocketChannel sc2 = null;\n+            try {\n+                sc1.socket().connect(listener.getLocalAddress(), 10_000);\n+                sc2 = listener.accept();\n+            } catch (IOException ioe) {\n+                sc1.close();\n+                throw ioe;\n+            }\n+            SocketChannel peer = sc2;\n+            scheduler.submit(() -> {\n+                ByteBuffer bb = ByteBuffer.allocate(8192);\n+                try {\n+                    int n;\n+                    do {\n+                        bb.clear();\n+                        n = peer.read(bb);\n+                    } while (n > 0);\n+                } catch (IOException ioe) {\n+                    if (peer.isOpen()) {\n+                        ioe.printStackTrace();\n+                    }\n+                }\n+            });\n+            return sc1;\n+        }\n+    }\n+\n+    \/**\n+     * Return a Pipe.SourceChannel that reads up to given number of bytes.\n+     *\/\n+    private static Pipe.SourceChannel pipeSource(int size) throws Exception {\n+        Pipe pipe = Pipe.open();\n+        Pipe.SourceChannel source = pipe.source();\n+        Pipe.SinkChannel sink = pipe.sink();\n+        scheduler.submit(() -> {\n+            try (sink) {\n+                ByteBuffer bb = ByteBuffer.allocate(size);\n+                while (bb.hasRemaining()) {\n+                    sink.write(bb);\n+                }\n+            }\n+            return null;\n+        });\n+        return source;\n+    }\n+\n+    \/**\n+     * Return a Pipe.SinkChannel with the channel's pipe ready for writing.\n+     *\/\n+    private static Pipe.SinkChannel pipeSink() throws Exception {\n+        Pipe pipe = Pipe.open();\n+        Pipe.SourceChannel source = pipe.source();\n+        Pipe.SinkChannel sink = pipe.sink();\n+        scheduler.submit(() -> {\n+            ByteBuffer bb = ByteBuffer.allocate(8192);\n+            try {\n+                int n;\n+                do {\n+                    bb.clear();\n+                    n = source.read(bb);\n+                } while (n > 0);\n+            } catch (IOException ioe) {\n+                if (source.isOpen()) {\n+                    ioe.printStackTrace();\n+                }\n+            }\n+        });\n+        return sink;\n+    }\n+\n+    \/**\n+     * Return a ReadableByteChannel that reads up thte given number of bytes.\n+     *\/\n+    private static ReadableByteChannel arbitrarySource(int size) throws Exception {\n+        ReadableByteChannel delegate = fileChannelSource(size);\n+        return new ReadableByteChannel() {\n+            @Override\n+            public int read(ByteBuffer bb) throws IOException {\n+                return delegate.read(bb);\n+            }\n+            @Override\n+            public boolean isOpen() {\n+                return delegate.isOpen();\n+            }\n+            @Override\n+            public void close() throws IOException {\n+                delegate.close();;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Return a WritableByteChannel that is ready for writing.\n+     *\/\n+    private static WritableByteChannel arbitraryTarget() throws Exception {\n+        WritableByteChannel delegate = fileChannelTarget();\n+        return new WritableByteChannel() {\n+            @Override\n+            public int write(ByteBuffer bb) throws IOException {\n+                return delegate.write(bb);\n+            }\n+            @Override\n+            public boolean isOpen() {\n+                return delegate.isOpen();\n+            }\n+            @Override\n+            public void close() throws IOException {\n+                delegate.close();;\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/CloseDuringTransfer.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"}]}