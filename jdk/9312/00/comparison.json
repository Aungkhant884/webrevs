{"files":[{"patch":"@@ -555,0 +555,23 @@\n+\/**\n+ * Used to calculate the offset between two tm structs.\n+ *\/\n+static time_t\n+calculateTimeOffset(struct tm tm1, struct tm tm2)\n+{\n+    time_t offset;\n+    const int seconds_per_minute = 60;\n+    const int seconds_per_hour = seconds_per_minute * 60;\n+    const int seconds_per_day = seconds_per_hour * 24;\n+    \/\/ The conversion of years and months is not important, as offset should never exceed a day.\n+    const int seconds_per_month = seconds_per_day * 31;\n+    const int seconds_per_year = seconds_per_month * 12;\n+\n+    \/\/ Apply mod to the result in order to normalize offset result to be under a day.\n+    offset = ((tm1.tm_year - tm2.tm_year) * seconds_per_year +\n+        (tm1.tm_mon - tm2.tm_mon) * seconds_per_month +\n+        (tm1.tm_mday - tm2.tm_mday) * seconds_per_day +\n+        (tm1.tm_hour - tm2.tm_hour) * seconds_per_hour +\n+        (tm1.tm_min - tm2.tm_min) * seconds_per_minute) % seconds_per_day;\n+    return offset;\n+}\n+\n@@ -595,1 +618,15 @@\n-    offset = timezone;\n+    struct tm localtm;\n+    time_t clock;\n+\n+    clock = time(NULL);\n+    if (localtime_r(&clock, &localtm) == NULL) {\n+        return strdup(\"GMT\");\n+    }\n+\n+    struct tm gmt;\n+\n+    if (gmtime_r(&clock, &gmt) == NULL) {\n+        return strdup(\"GMT\");\n+    }\n+\n+    offset = calculateTimeOffset(localtm, gmt);\n@@ -601,1 +638,0 @@\n-    \/* Note that the time offset direction is opposite. *\/\n@@ -603,1 +639,1 @@\n-        sign = '-';\n+        sign = '+';\n@@ -606,1 +642,1 @@\n-        sign = '+';\n+        sign = '-';\n","filename":"src\/java.base\/unix\/native\/libjava\/TimeZone_md.c","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8285838\n+ * @library \/test\/lib\n+ * @summary This test will ensure that daylight savings rules are followed\n+ * appropriately when setting a custom timezone ID via the TZ env variable.\n+ * @requires os.family != \"windows\"\n+ * @run main\/othervm CustomTzIDCheckDST\n+ *\/\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.SimpleTimeZone;\n+import java.time.DayOfWeek;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.TemporalAdjusters;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+public class CustomTzIDCheckDST {\n+    private static String CUSTOM_TZ = \"MEZ-1MESZ,M3.5.0,M10.5.0\";\n+    public static void main(String args[]) throws Throwable {\n+        if (args.length == 0) {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(List.of(\"CustomTzIDCheckDST\", \"runTZTest\"));\n+            pb.environment().put(\"TZ\", CUSTOM_TZ);\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            output.shouldHaveExitValue(0);\n+        } else {\n+            runTZTest();\n+        }\n+    }\n+\n+    \/* TZ code will always be set to \"MEZ-1MESZ,M3.5.0,M10.5.0\".\n+     * This ensures the transition periods for Daylights Savings should be at March's last\n+     * Sunday and October's last Sunday.\n+     *\/\n+    private static void runTZTest() {\n+        Date time = new Date();\n+        if (new SimpleTimeZone(3600000, \"MEZ-1MESZ\", Calendar.MARCH, -1, Calendar.SUNDAY, 0,\n+                Calendar.OCTOBER, -1, Calendar.SUNDAY, 0).inDaylightTime(time)) {\n+            \/\/ We are in Daylight savings period.\n+            if (time.toString().endsWith(\"GMT+02:00 \" + Integer.toString(time.getYear() + 1900)))\n+                return;\n+        } else {\n+            if (time.toString().endsWith(\"GMT+01:00 \" + Integer.toString(time.getYear() + 1900)))\n+                return;\n+        }\n+\n+        \/\/ Reaching here means time zone did not match up as expected.\n+        throw new RuntimeException(\"Got unexpected timezone information: \" + time);\n+    }\n+\n+    private static ZonedDateTime getLastSundayOfMonth(ZonedDateTime date) {\n+        return date.with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/TimeZone\/CustomTzIDCheckDST.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}