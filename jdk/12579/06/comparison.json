{"files":[{"patch":"@@ -88,1 +88,1 @@\n-    \/\/ Used to ensure that each spun class name is unique\n+    \/\/ Used to ensure that dumped class files for failed definitions have a unique class name\n@@ -212,1 +212,1 @@\n-        return name.replace('.', '\/') + \"$$Lambda$\" + counter.incrementAndGet();\n+        return name.replace('.', '\/') + \"$$Lambda\";\n@@ -304,1 +304,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -365,13 +364,0 @@\n-        \/\/ If requested, dump out to a file for debugging purposes\n-        if (dumper != null) {\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                @Override\n-                public Void run() {\n-                    dumper.dumpClass(lambdaClassName, classBytes);\n-                    return null;\n-                }\n-            }, null,\n-            new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n-            \/\/ createDirectories may need it\n-            new PropertyPermission(\"user.dir\", \"read\"));\n-        }\n@@ -381,5 +367,21 @@\n-            if (useImplMethodHandle) {\n-                lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n-                                                               NESTMATE, STRONG);\n-            } else {\n-                lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n+            try {\n+                if (useImplMethodHandle) {\n+                    lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n+                        NESTMATE, STRONG);\n+                } else {\n+                    lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n+                }\n+            } catch (Throwable t) {\n+                \/\/ If requested, dump out to a file for debugging purposes\n+                if (dumper != null) {\n+                    doDump(lambdaClassName + \".failed-\" + counter.incrementAndGet(), classBytes);\n+                }\n+                throw t;\n+            }\n+            final Class<?> clazz = lookup.lookupClass();\n+            \/\/ If requested, dump out to a file for debugging purposes\n+            if (dumper != null) {\n+                final String definedName = clazz.getName();\n+                final int suffixIdx = definedName.lastIndexOf('\/');\n+                assert suffixIdx != -1;\n+                doDump(lambdaClassName + '.' + definedName.substring(suffixIdx + 1), classBytes);\n@@ -387,1 +389,1 @@\n-            return lookup.lookupClass();\n+            return clazz;\n@@ -395,0 +397,14 @@\n+    @SuppressWarnings(\"removal\")\n+    private void doDump(final String className, final byte[] classBytes) {\n+        AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public Void run() {\n+                dumper.dumpClass(className, classBytes);\n+                return null;\n+            }\n+        }, null,\n+        new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n+        \/\/ createDirectories may need it\n+        new PropertyPermission(\"user.dir\", \"read\"));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":38,"deletions":22,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-            \"2: VerifyStackTrace$$Lambda$1\/0x0000000801001848.run(Unknown Source)\\n\" +\n+            \"2: VerifyStackTrace$$Lambda\/0x0000000801001848.run(Unknown Source)\\n\" +\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-                \"A$I$$Lambda$*.class\")) {\n+                \"A$I$$Lambda.*.class\")) {\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAsm.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}