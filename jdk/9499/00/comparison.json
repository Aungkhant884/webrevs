{"files":[{"patch":"@@ -389,1 +389,1 @@\n-    public TagletWriter getTagletWriterInstance(TagletWriterImpl.Context context) {\n+    public TagletWriterImpl getTagletWriterInstance(TagletWriterImpl.Context context) {\n@@ -974,310 +974,0 @@\n-    public Content seeTagToContent(Element element, DocTree see, TagletWriterImpl.Context context) {\n-        Kind kind = see.getKind();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        String tagName = ch.getTagName(see);\n-\n-        String refText;\n-        List<? extends DocTree> label;\n-        switch (kind) {\n-            case LINK, LINK_PLAIN -> {\n-                \/\/ {@link[plain] reference label...}\n-                LinkTree lt = (LinkTree) see;\n-                var linkRef = lt.getReference();\n-                if (linkRef == null) {\n-                    messages.warning(ch.getDocTreePath(see),\"doclet.link.no_reference\");\n-                    return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", lt.toString()),\n-                        Optional.empty());\n-                }\n-                refText = linkRef.toString();\n-                label = lt.getLabel();\n-            }\n-\n-            case SEE -> {\n-                List<? extends DocTree> ref = ((SeeTree) see).getReference();\n-                assert !ref.isEmpty();\n-                DocTree ref0 = ref.get(0);\n-                switch (ref0.getKind()) {\n-                    case TEXT, START_ELEMENT -> {\n-                        \/\/ @see \"Reference\"\n-                        \/\/ @see <a href=\"...\">...<\/a>\n-                        return commentTagsToContent(element, ref, false, false);\n-                    }\n-                    case REFERENCE -> {\n-                        \/\/ @see reference label...\n-                        refText = ref0.toString();\n-                        label = ref.subList(1, ref.size());\n-                    }\n-                    case ERRONEOUS -> {\n-                        return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n-                                        ref0.toString()),\n-                                Optional.empty());\n-                    }\n-                    default ->\n-                        throw new IllegalStateException(ref0.getKind().toString());\n-                }\n-            }\n-\n-            default ->\n-                throw new IllegalStateException(kind.toString());\n-        }\n-\n-        boolean isLinkPlain = kind == LINK_PLAIN;\n-        Content labelContent = plainOrCode(isLinkPlain,\n-                commentTagsToContent(element, label, context));\n-\n-        \/\/ The signature from the @see tag. We will output this text when a label is not specified.\n-        Content text = plainOrCode(isLinkPlain,\n-                Text.of(Objects.requireNonNullElse(ch.getReferencedSignature(see), \"\")));\n-\n-        TypeElement refClass = ch.getReferencedClass(see);\n-        Element refMem =       ch.getReferencedMember(see);\n-        String refMemName =    ch.getReferencedMemberName(see);\n-\n-        if (refMemName == null && refMem != null) {\n-            refMemName = refMem.toString();\n-        }\n-        if (refClass == null) {\n-            ModuleElement refModule = ch.getReferencedModule(see);\n-            if (refModule != null && utils.isIncluded(refModule)) {\n-                return getModuleLink(refModule, labelContent.isEmpty() ? text : labelContent);\n-            }\n-            \/\/@see is not referencing an included class\n-            PackageElement refPackage = ch.getReferencedPackage(see);\n-            if (refPackage != null && utils.isIncluded(refPackage)) {\n-                \/\/@see is referencing an included package\n-                if (labelContent.isEmpty())\n-                    labelContent = plainOrCode(isLinkPlain,\n-                            Text.of(refPackage.getQualifiedName()));\n-                return getPackageLink(refPackage, labelContent);\n-            } else {\n-                \/\/ @see is not referencing an included class, module or package. Check for cross links.\n-                String refModuleName =  ch.getReferencedModuleName(see);\n-                DocLink elementCrossLink = (refPackage != null) ? getCrossPackageLink(refPackage) :\n-                        (configuration.extern.isModule(refModuleName))\n-                                ? getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n-                                : null;\n-                if (elementCrossLink != null) {\n-                    \/\/ Element cross link found\n-                    return links.createExternalLink(elementCrossLink,\n-                            (labelContent.isEmpty() ? text : labelContent));\n-                } else {\n-                    \/\/ No cross link found so print warning\n-                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n-                        messages.warning(ch.getDocTreePath(see),\n-                                \"doclet.see.class_or_package_not_found\",\n-                                \"@\" + tagName,\n-                                refText);\n-                    }\n-                    return invalidTagOutput(resources.getText(\"doclet.tag.invalid\", tagName),\n-                            Optional.of(labelContent.isEmpty() ? text: labelContent));\n-                }\n-            }\n-        } else if (refMemName == null) {\n-            \/\/ Must be a class reference since refClass is not null and refMemName is null.\n-            if (labelContent.isEmpty()) {\n-                TypeMirror referencedType = ch.getReferencedType(see);\n-                if (utils.isGenericType(referencedType)) {\n-                    \/\/ This is a generic type link, use the TypeMirror representation.\n-                    return plainOrCode(isLinkPlain, getLink(\n-                            new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, referencedType)));\n-                }\n-                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n-            }\n-            return getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, refClass)\n-                    .label(labelContent));\n-        } else if (refMem == null) {\n-            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n-            \/\/ However, refMem is null, so this referenced member does not exist.\n-            return (labelContent.isEmpty() ? text: labelContent);\n-        } else {\n-            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n-            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n-            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n-\n-            \/\/ Find the enclosing type where the method is actually visible\n-            \/\/ in the inheritance hierarchy.\n-            ExecutableElement overriddenMethod = null;\n-            if (refMem.getKind() == ElementKind.METHOD) {\n-                VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);\n-                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n-\n-                if (overriddenMethod != null)\n-                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n-            }\n-            if (refText.trim().startsWith(\"#\") &&\n-                ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n-                \/\/ Since the link is relative and the holder is not even being\n-                \/\/ documented, this must be an inherited link.  Redirect it.\n-                \/\/ The current class either overrides the referenced member or\n-                \/\/ inherits it automatically.\n-                if (this instanceof ClassWriterImpl writer) {\n-                    containing = writer.getTypeElement();\n-                } else if (!utils.isPublic(containing)) {\n-                    messages.warning(\n-                        ch.getDocTreePath(see), \"doclet.see.class_or_package_not_accessible\",\n-                        tagName, utils.getFullyQualifiedName(containing));\n-                } else {\n-                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n-                        messages.warning(\n-                                ch.getDocTreePath(see), \"doclet.see.class_or_package_not_found\",\n-                                tagName, refText);\n-                    }\n-                }\n-            }\n-            if (configuration.currentTypeElement != containing) {\n-                refMemName = (utils.isConstructor(refMem))\n-                        ? refMemName\n-                        : utils.getSimpleName(containing) + \".\" + refMemName;\n-            }\n-            if (utils.isExecutableElement(refMem)) {\n-                if (refMemName.indexOf('(') < 0) {\n-                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n-                }\n-                if (overriddenMethod != null) {\n-                    \/\/ The method to actually link.\n-                    refMem = overriddenMethod;\n-                }\n-            }\n-\n-            return getDocLink(HtmlLinkInfo.Kind.SEE_TAG, containing,\n-                    refMem, (labelContent.isEmpty()\n-                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n-                            : labelContent), null, false);\n-        }\n-    }\n-\n-    \/\/ TODO: this method and seeTagToContent share much of the code; consider factoring common pieces out\n-    public Content linkToContent(Element referrer, Element target, String targetSignature, String text) {\n-        CommentHelper ch = utils.getCommentHelper(referrer);\n-\n-        boolean isLinkPlain = false; \/\/ TODO: for now\n-        Content labelContent = plainOrCode(isLinkPlain, Text.of(text));\n-\n-        TypeElement refClass = ch.getReferencedClass(target);\n-        Element refMem =       ch.getReferencedMember(target);\n-        String refMemName =    ch.getReferencedMemberName(targetSignature);\n-\n-        if (refMemName == null && refMem != null) {\n-            refMemName = refMem.toString();\n-        }\n-        if (refClass == null) {\n-            ModuleElement refModule = ch.getReferencedModule(target);\n-            if (refModule != null && utils.isIncluded(refModule)) {\n-                return getModuleLink(refModule, labelContent);\n-            }\n-            \/\/@see is not referencing an included class\n-            PackageElement refPackage = ch.getReferencedPackage(target);\n-            if (refPackage != null && utils.isIncluded(refPackage)) {\n-                \/\/@see is referencing an included package\n-                if (labelContent.isEmpty())\n-                    labelContent = plainOrCode(isLinkPlain,\n-                                               Text.of(refPackage.getQualifiedName()));\n-                return getPackageLink(refPackage, labelContent);\n-            } else {\n-                \/\/ @see is not referencing an included class, module or package. Check for cross links.\n-                String refModuleName =  ch.getReferencedModuleName(targetSignature);\n-                DocLink elementCrossLink = (refPackage != null) ? getCrossPackageLink(refPackage) :\n-                        (configuration.extern.isModule(refModuleName))\n-                                ? getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n-                                : null;\n-                if (elementCrossLink != null) {\n-                    \/\/ Element cross link found\n-                    return links.createExternalLink(elementCrossLink, labelContent);\n-                } else {\n-                    \/\/ No cross link found so print warning\n-\/\/ TODO:\n-\/\/                    messages.warning(ch.getDocTreePath(see),\n-\/\/                                     \"doclet.see.class_or_package_not_found\",\n-\/\/                                     \"@\" + tagName,\n-\/\/                                     seeText);\n-                    return labelContent;\n-                }\n-            }\n-        } else if (refMemName == null) {\n-            \/\/ Must be a class reference since refClass is not null and refMemName is null.\n-            if (labelContent.isEmpty()) {\n-                if (!refClass.getTypeParameters().isEmpty() && targetSignature.contains(\"<\")) {\n-                    \/\/ If this is a generic type link try to use the TypeMirror representation.\n-\n-\/\/ TODO:\n-\/\/                  TypeMirror refType = ch.getReferencedType(target);\n-                    TypeMirror refType = target.asType();\n-\n-                    if (refType != null) {\n-                        return plainOrCode(isLinkPlain, getLink(\n-                                new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, refType)));\n-                    }\n-                }\n-                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n-            }\n-            return getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, refClass)\n-                                   .label(labelContent));\n-        } else if (refMem == null) {\n-            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n-            \/\/ However, refMem is null, so this referenced member does not exist.\n-            return labelContent;\n-        } else {\n-            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n-            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n-            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n-\n-            \/\/ Find the enclosing type where the method is actually visible\n-            \/\/ in the inheritance hierarchy.\n-            ExecutableElement overriddenMethod = null;\n-            if (refMem.getKind() == ElementKind.METHOD) {\n-                VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);\n-                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n-\n-                if (overriddenMethod != null)\n-                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n-            }\n-            if (targetSignature.trim().startsWith(\"#\") &&\n-                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n-                \/\/ Since the link is relative and the holder is not even being\n-                \/\/ documented, this must be an inherited link.  Redirect it.\n-                \/\/ The current class either overrides the referenced member or\n-                \/\/ inherits it automatically.\n-                if (this instanceof ClassWriterImpl writer) {\n-                    containing = writer.getTypeElement();\n-                } else if (!utils.isPublic(containing)) {\n-\/\/ TODO:\n-\/\/                    messages.warning(\n-\/\/                            ch.getDocTreePath(see), \"doclet.see.class_or_package_not_accessible\",\n-\/\/                            tagName, utils.getFullyQualifiedName(containing));\n-                } else {\n-\/\/ TODO:\n-\/\/                    messages.warning(\n-\/\/                            ch.getDocTreePath(see), \"doclet.see.class_or_package_not_found\",\n-\/\/                            tagName, seeText);\n-                }\n-            }\n-            if (configuration.currentTypeElement != containing) {\n-                refMemName = (utils.isConstructor(refMem))\n-                        ? refMemName\n-                        : utils.getSimpleName(containing) + \".\" + refMemName;\n-            }\n-            if (utils.isExecutableElement(refMem)) {\n-                if (refMemName.indexOf('(') < 0) {\n-                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n-                }\n-                if (overriddenMethod != null) {\n-                    \/\/ The method to actually link.\n-                    refMem = overriddenMethod;\n-                }\n-            }\n-\n-            return getDocLink(HtmlLinkInfo.Kind.SEE_TAG, containing,\n-                              refMem, (labelContent.isEmpty()\n-                            ? plainOrCode(isLinkPlain, Text.of(text))\n-                            : labelContent), null, false);\n-        }\n-    }\n-\n-    private String removeTrailingSlash(String s) {\n-        return s.endsWith(\"\/\") ? s.substring(0, s.length() -1) : s;\n-    }\n-\n-    private Content plainOrCode(boolean plain, Content body) {\n-        return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);\n-    }\n-\n@@ -1663,2 +1353,2 @@\n-                        Content c = seeTagToContent(element, node, context.within(node));\n-                        content.add(c);\n+                        TagletWriterImpl t = getTagletWriterInstance(context.within(node));\n+                        content.add(t.linkTagOutput(element, node));\n@@ -1677,6 +1367,0 @@\n-                @Override\n-                public Boolean visitSee(SeeTree node, Content content) {\n-                    content.add(seeTagToContent(element, node, context));\n-                    return false;\n-                }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":3,"deletions":319,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Objects;\n@@ -34,0 +35,1 @@\n+import java.util.function.BiConsumer;\n@@ -49,0 +51,1 @@\n+import com.sun.source.doctree.LinkTree;\n@@ -69,0 +72,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.Messages;\n@@ -82,0 +86,3 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n@@ -146,0 +153,3 @@\n+\n+    private final Messages messages;\n+\n@@ -189,0 +199,1 @@\n+        messages = configuration.messages;\n@@ -273,0 +284,26 @@\n+    @Override\n+    public Content linkTagOutput(Element element, LinkTree tag) {\n+        CommentHelper ch = utils.getCommentHelper(element);\n+\n+        var linkRef = tag.getReference();\n+        if (linkRef == null) {\n+            messages.warning(ch.getDocTreePath(tag), \"doclet.link.no_reference\");\n+            return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", tag.toString()),\n+                    Optional.empty());\n+        }\n+\n+        DocTree.Kind kind = tag.getKind();\n+        String tagName = ch.getTagName(tag);\n+        String refSignature = ch.getReferencedSignature(linkRef);\n+\n+        return linkSeeReferenceOutput(element,\n+                tag,\n+                refSignature,\n+                ch.getReferencedElement(tag),\n+                tagName,\n+                (kind == LINK_PLAIN),\n+                htmlWriter.commentTagsToContent(element, tag.getLabel(), context),\n+                (key, args) -> messages.warning(ch.getDocTreePath(tag), key, args)\n+        );\n+    }\n+\n@@ -318,2 +355,3 @@\n-        for (DocTree dt : seeTags) {\n-            links.add(htmlWriter.seeTagToContent(holder, dt, context.within(dt)));\n+        for (SeeTree dt : seeTags) {\n+            TagletWriterImpl t = new TagletWriterImpl(htmlWriter, context.within(dt));\n+            links.add(t.seeTagOutput(holder, dt));\n@@ -366,0 +404,193 @@\n+    \/**\n+     * {@return the output for a single {@code @see} tag}\n+     *\n+     * @param element the element that has the documentation comment containing this tag\n+     * @param seeTag  the tag\n+     *\/\n+    private Content seeTagOutput(Element element, SeeTree seeTag) {\n+        List<? extends DocTree> ref = seeTag.getReference();\n+        assert !ref.isEmpty();\n+        DocTree ref0 = ref.get(0);\n+        switch (ref0.getKind()) {\n+            case TEXT, START_ELEMENT -> {\n+                \/\/ @see \"Reference\"\n+                \/\/ @see <a href=\"...\">...<\/a>\n+                return htmlWriter.commentTagsToContent(element, ref, false, false);\n+            }\n+\n+            case REFERENCE -> {\n+                \/\/ @see reference label...\n+                CommentHelper ch = utils.getCommentHelper(element);\n+                String tagName = ch.getTagName(seeTag);\n+                String refSignature = ch.getReferencedSignature(ref0);\n+                List<? extends DocTree> label = ref.subList(1, ref.size());\n+\n+                return linkSeeReferenceOutput(element,\n+                        seeTag,\n+                        refSignature,\n+                        ch.getReferencedElement(seeTag),\n+                        tagName,\n+                        false,\n+                        htmlWriter.commentTagsToContent(element, label, context),\n+                        (key, args) -> messages.warning(ch.getDocTreePath(seeTag), key, args)\n+                );\n+            }\n+\n+            case ERRONEOUS -> {\n+                return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n+                                ref0.toString()),\n+                        Optional.empty());\n+            }\n+\n+            default -> throw new IllegalStateException(ref0.getKind().toString());\n+        }\n+\n+    }\n+\n+    \/**\n+     * Worker method to generate a link from the information in different kinds of tags,\n+     * such as {@code {@link ...}} tags, {@code @see ...} tags and the {@code link} markup tag\n+     * in a {@code {@snippet ...}} tag.\n+     *\n+     * @param holder        the element that has the documentation comment containing the information\n+     * @param refTree       the tree node containing the information, or {@code null} if not avaiable\n+     * @param refSignature  the normalized signature of the target of the reference\n+     * @param ref           the target of the reference\n+     * @param tagName       the name of the tag in the source, to be used in diagnostics\n+     * @param isLinkPlain   {@code true} if the link should be presented in \"plain\" font,\n+     *                      or {@code false} for \"code\" font.\n+     * @param label         the label for the link,\n+     *                      or an empty list to use a default label derived from the signature\n+     * @param reportWarning a function to report warnings about issues found in the reference\n+     *\n+     * @return the output containing the generated link, or content indicating an error\n+     *\/\n+    Content linkSeeReferenceOutput(Element holder, DocTree refTree, String refSignature, Element ref,\n+                                   String tagName, boolean isLinkPlain,\n+                                   Content label,\n+                                   BiConsumer<String, Object[]> reportWarning) {\n+        Content labelContent = plainOrCode(isLinkPlain, label);\n+\n+        \/\/ The signature from the @see tag. We will output this text when a label is not specified.\n+        Content text = plainOrCode(isLinkPlain,\n+                Text.of(Objects.requireNonNullElse(refSignature, \"\")));\n+\n+        CommentHelper ch = utils.getCommentHelper(holder);\n+        TypeElement refClass = ch.getReferencedClass(ref);\n+        Element refMem =       ch.getReferencedMember(ref);\n+        String refMemName =    ch.getReferencedMemberName(refSignature);\n+\n+        if (refMemName == null && refMem != null) {\n+            refMemName = refMem.toString();\n+        }\n+        if (refClass == null) {\n+            ModuleElement refModule = ch.getReferencedModule(ref);\n+            if (refModule != null && utils.isIncluded(refModule)) {\n+                return htmlWriter.getModuleLink(refModule, labelContent.isEmpty() ? text : labelContent);\n+            }\n+            \/\/@see is not referencing an included class\n+            PackageElement refPackage = ch.getReferencedPackage(ref);\n+            if (refPackage != null && utils.isIncluded(refPackage)) {\n+                \/\/@see is referencing an included package\n+                if (labelContent.isEmpty())\n+                    labelContent = plainOrCode(isLinkPlain,\n+                            Text.of(refPackage.getQualifiedName()));\n+                return htmlWriter.getPackageLink(refPackage, labelContent);\n+            } else {\n+                \/\/ @see is not referencing an included class, module or package. Check for cross links.\n+                String refModuleName =  ch.getReferencedModuleName(refSignature);\n+                DocLink elementCrossLink = (refPackage != null) ? htmlWriter.getCrossPackageLink(refPackage) :\n+                        (configuration.extern.isModule(refModuleName))\n+                                ? htmlWriter.getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n+                                : null;\n+                if (elementCrossLink != null) {\n+                    \/\/ Element cross link found\n+                    return htmlWriter.links.createExternalLink(elementCrossLink,\n+                            (labelContent.isEmpty() ? text : labelContent));\n+                } else {\n+                    \/\/ No cross link found so print warning\n+                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n+                        reportWarning.accept(\n+                                \"doclet.see.class_or_package_not_found\",\n+                                new Object[] { \"@\" + tagName, refSignature});\n+                    }\n+                    return htmlWriter.invalidTagOutput(resources.getText(\"doclet.tag.invalid\", tagName),\n+                            Optional.of(labelContent.isEmpty() ? text: labelContent));\n+                }\n+            }\n+        } else if (refMemName == null) {\n+            \/\/ Must be a class reference since refClass is not null and refMemName is null.\n+            if (labelContent.isEmpty() && refTree != null) {\n+                TypeMirror referencedType = ch.getReferencedType(refTree);\n+                if (utils.isGenericType(referencedType)) {\n+                    \/\/ This is a generic type link, use the TypeMirror representation.\n+                    return plainOrCode(isLinkPlain, htmlWriter.getLink(\n+                            new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, referencedType)));\n+                }\n+                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n+            }\n+            return htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, refClass)\n+                    .label(labelContent));\n+        } else if (refMem == null) {\n+            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n+            \/\/ However, refMem is null, so this referenced member does not exist.\n+            return (labelContent.isEmpty() ? text: labelContent);\n+        } else {\n+            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n+            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n+            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n+\n+            \/\/ Find the enclosing type where the method is actually visible\n+            \/\/ in the inheritance hierarchy.\n+            ExecutableElement overriddenMethod = null;\n+            if (refMem.getKind() == ElementKind.METHOD) {\n+                VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);\n+                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n+\n+                if (overriddenMethod != null)\n+                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n+            }\n+            if (refSignature.trim().startsWith(\"#\") &&\n+                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n+                \/\/ Since the link is relative and the holder is not even being\n+                \/\/ documented, this must be an inherited link.  Redirect it.\n+                \/\/ The current class either overrides the referenced member or\n+                \/\/ inherits it automatically.\n+                if (htmlWriter instanceof ClassWriterImpl writer) {\n+                    containing = writer.getTypeElement();\n+                } else if (!utils.isPublic(containing)) {\n+                    reportWarning.accept(\"doclet.see.class_or_package_not_accessible\",\n+                            new Object[] { tagName, utils.getFullyQualifiedName(containing)});\n+                } else {\n+                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n+                        reportWarning.accept(\"doclet.see.class_or_package_not_found\",\n+                                new Object[] { tagName, refSignature });\n+                    }\n+                }\n+            }\n+            if (configuration.currentTypeElement != containing) {\n+                refMemName = (utils.isConstructor(refMem))\n+                        ? refMemName\n+                        : utils.getSimpleName(containing) + \".\" + refMemName;\n+            }\n+            if (utils.isExecutableElement(refMem)) {\n+                if (refMemName.indexOf('(') < 0) {\n+                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n+                }\n+                if (overriddenMethod != null) {\n+                    \/\/ The method to actually link.\n+                    refMem = overriddenMethod;\n+                }\n+            }\n+\n+            return htmlWriter.getDocLink(HtmlLinkInfo.Kind.SEE_TAG, containing,\n+                    refMem, (labelContent.isEmpty()\n+                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n+                            : labelContent), null, false);\n+        }\n+    }\n+\n+    private Content plainOrCode(boolean plain, Content body) {\n+        return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);\n+    }\n+\n@@ -447,1 +678,9 @@\n-                        c = new ContentBuilder(whitespace, htmlWriter.linkToContent(element, e, t, strippedLine));\n+                        Content lc = linkSeeReferenceOutput(element,\n+                                null,\n+                                t,\n+                                e,\n+                                \"link\",\n+                                false, \/\/ TODO: for now\n+                                Text.of(strippedLine),\n+                                (key, args) -> { \/* TODO: report diagnostic *\/ });\n+                        c = new ContentBuilder(whitespace, lc);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":242,"deletions":3,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import com.sun.source.doctree.LinkTree;\n@@ -110,0 +111,10 @@\n+    \/**\n+     * Returns the output for a {@code {@link ...}} or {@code {@linkplain ...}} tag.\n+     *\n+     * @param element The element that owns the doc comment\n+     * @param tag     the tag\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content linkTagOutput(Element element, LinkTree tag);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -159,2 +159,2 @@\n-            DocTrees doctrees = configuration.docEnv.getDocTrees();\n-            return doctrees.getType(docTreePath);\n+            DocTrees docTrees = configuration.docEnv.getDocTrees();\n+            return docTrees.getType(docTreePath);\n@@ -216,5 +216,0 @@\n-    public String getReferencedMemberName(DocTree dtree) {\n-        String s = getReferencedSignature(dtree);\n-        return getReferencedMemberName(s);\n-    }\n-\n@@ -262,1 +257,1 @@\n-    private Element getReferencedElement(DocTree dtree) {\n+    public Element getReferencedElement(DocTree dtree) {\n@@ -289,1 +284,4 @@\n-    public  String getReferencedSignature(DocTree dtree) {\n+    \/**\n+     * {@return the normalized signature from a {@code ReferenceTree}}\n+     *\/\n+    public String getReferencedSignature(DocTree dtree) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    public <A> void methodThatHasTypeParmaters(A... a) {}\n+    public <A> void methodThatHasTypeParameters(A... a) {}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/pkg\/TypeParameters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}