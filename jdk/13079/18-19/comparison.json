{"files":[{"patch":"@@ -70,0 +70,3 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IllegalArgumentException if {@code bitAlignment} is less than {@code M}, where {@code M} is the maximum alignment\n+     * constraint in any of the member layouts associated with this group layout.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int (*foo)[10]}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int (*ptr)[10]}<\/th>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -707,0 +707,1 @@\n+     * @throws IllegalArgumentException if {@code elementLayout.bitAlignment() > elementLayout.bitSize()}.\n@@ -711,0 +712,1 @@\n+        Utils.checkElementAlignment(elementLayout, \"Element layout alignment greater than its size\");\n@@ -726,0 +728,1 @@\n+     * @throws IllegalArgumentException if {@code elementLayout.bitAlignment() > elementLayout.bitSize()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -353,4 +353,3 @@\n- *     <li>pointers returned from a foreign function;<\/li>\n- *     <li>pointers passed by a foreign function to an\n- *     {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}; and<\/li>\n- *     <li>pointers {@linkplain MemorySegment#get(AddressLayout, long) read} from a memory segment.<\/li>\n+ *     <li>pointers <a href=\"Linker.html#by-ref\">returned from a foreign function<\/a>;<\/li>\n+ *     <li>pointers <a href=\"Linker.html#function-pointers\">passed by a foreign function to an upcall stub<\/a>; and<\/li>\n+ *     <li>pointers read from a memory segment (more on that below).<\/li>\n@@ -370,1 +369,8 @@\n- * To work with native zero-length memory segments, clients have several options, all of which are <em>unsafe<\/em>.\n+ * To demonstrate how clients can work with zero-length memory segments, consider the case of a client that wants\n+ * to read a pointer from some memory segment. This can be done via the\n+ * {@linkplain MemorySegment#get(AddressLayout, long)} access method. This method accepts an\n+ * {@linkplain AddressLayout address layout} (e.g. {@link ValueLayout#ADDRESS}), the layout of the pointer\n+ * to be read. For instance on a 64-bit platform, the size of an address layout is 64 bits. The access operation\n+ * also accepts an offset, expressed in bytes, which indicates the position (relative to the start of the memory segment)\n+ * at which the pointer is stored. The access operation returns a zero-length native memory segment, backed by a region\n+ * of memory whose starting address is the 64-bit value read at the specified offset.\n@@ -372,3 +378,4 @@\n- * First, clients can unsafely resize a zero-length memory segment by {@linkplain #reinterpret(long) obtaining} a\n- * memory segment with the same base address as the zero-length memory segment, but with the desired size,\n- * so that the resulting segment can then be accessed directly, as follows:\n+ * The returned zero-length memory segment cannot be accessed directly by the client: since the size of the segment\n+ * is zero, any access operation would result in out-of-bounds access. Instead, the client must, <em>unsafely<\/em>,\n+ * assign new spatial bounds to the zero-length memory segment. This can be done via the\n+ * {@link #reinterpret(long)} method, as follows:\n@@ -377,3 +384,3 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ size = 0\n- *                                    .reinterpret(4)               \/\/ size = 4\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n+ * MemorySegment z = segment.get(ValueLayout.ADDRESS, ...);   \/\/ size = 0\n+ * MemorySegment ptr = z.reinterpret(16);                     \/\/ size = 16\n+ * int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);           \/\/ ok\n@@ -382,3 +389,3 @@\n- * In some cases, a client might additionally want to assign new temporal bounds to a zero-length memory segment.\n- * This can be done using the {@link #reinterpret(long, Arena, Consumer)} method, which returns a\n- * new native segment with the desired size and the same temporal bounds as those in the provided arena:\n+ * In some cases, the client might additionally want to assign new temporal bounds to a zero-length memory segment.\n+ * This can be done via the {@link #reinterpret(long, Arena, Consumer)} method, which returns a\n+ * new native segment with the desired size and the same temporal bounds as those of the provided arena:\n@@ -387,1 +394,1 @@\n- * MemorySegment foreign = null;\n+ * MemorySegment ptr = null;\n@@ -389,3 +396,3 @@\n- *       foreign = someSegment.get(ValueLayout.ADDRESS, 0)           \/\/ size = 0, scope = always alive\n- *                            .reinterpret(4, arena, null);          \/\/ size = 4, scope = arena.scope()\n- *       int x = foreign.get(ValueLayout.JAVA_INT, 0);               \/\/ ok\n+ *       MemorySegment z = segment.get(ValueLayout.ADDRESS, ...);    \/\/ size = 0, scope = always alive\n+ *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 4, scope = arena.scope()\n+ *       int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);            \/\/ ok\n@@ -393,1 +400,1 @@\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ throws IllegalStateException\n+ * int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);                  \/\/ throws IllegalStateException\n@@ -396,5 +403,6 @@\n- * Alternatively, if the true size of the zero-length memory segment is known statically, clients can associate a\n- * {@linkplain AddressLayout#withTargetLayout(MemoryLayout) target layout} with the address layout used to obtain the\n- * segment. When an access operation, or a function descriptor that is passed to a downcall method handle,\n- * uses an address value layout with target layout {@code T}, the runtime will wrap any corresponding raw addresses\n- * with native segments with size set to {@code T.byteSize()}:\n+ * Alternatively, if the size of the region of memory backing the zero-length memory segment is known statically,\n+ * the client can overlay a {@linkplain AddressLayout#withTargetLayout(MemoryLayout) target layout} on the address\n+ * layout used when reading a pointer. The target layout is then used to dynamically\n+ * <em>expand<\/em> the size of the native memory segment returned by the access operation, so that the size\n+ * of the segment is the same as the size of the target layout. In other words, the returned segment is no\n+ * longer a zero-length memory segment, and the pointer it represents can be dereferenced directly:\n@@ -403,2 +411,4 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.withTargetLayout(JAVA_INT), 0); \/\/ size = 4\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0);                                               \/\/ ok\n+ * AddressLayout intArrPtrLayout = ValueLayout.ADDRESS.withTargetLayout(\n+ *         MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT)); \/\/ layout for int (*ptr)[4]\n+ * MemorySegment ptr = segment.get(intArrPtrLayout, ...);         \/\/ size = 16\n+ * int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);               \/\/ ok\n@@ -407,7 +417,0 @@\n- * Which approach is taken largely depends on the information that a client has available when obtaining a memory segment\n- * wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the\n- * segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). If the\n- * true size of the zero-length memory segment is known statically, using an address layout with the correct target layout might be preferable.\n- * In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should\n- * be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n- * <p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":36,"deletions":33,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,0 +145,2 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IllegalArgumentException if {@code bitAlignment < elementLayout().bitAlignment()}.\n@@ -146,1 +148,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n@@ -154,1 +155,0 @@\n-\n@@ -180,0 +180,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -215,0 +216,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -251,0 +253,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -287,0 +290,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -323,0 +327,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -395,0 +400,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -431,0 +437,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -195,1 +195,0 @@\n-        checkAlignment(this);\n@@ -284,20 +283,0 @@\n-    private static void checkAlignment(LayoutPath path) {\n-        MemoryLayout layout = path.layout;\n-        long alignment = layout.bitAlignment();\n-        if (!Utils.isAligned(path.offset, alignment)) {\n-            throw new UnsupportedOperationException(\"Invalid alignment requirements for layout \" + layout);\n-        }\n-        for (long stride : path.strides) {\n-            if (!Utils.isAligned(stride, alignment)) {\n-                throw new UnsupportedOperationException(\"Alignment requirements for layout \" + layout + \" do not match stride \" + stride);\n-            }\n-        }\n-        LayoutPath encl = path.enclosing;\n-        if (encl != null) {\n-            if (encl.layout.bitAlignment() < alignment) {\n-                throw new UnsupportedOperationException(\"Alignment requirements for layout \" + layout + \" do not match those for enclosing layout \" + encl.layout);\n-            }\n-            checkAlignment(encl);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    final long minBitAlignment;\n@@ -53,6 +54,2 @@\n-    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements) {\n-        this(kind, elements, kind.alignof(elements), Optional.empty());\n-    }\n-\n-    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n-        super(kind.sizeof(elements), bitAlignment, name); \/\/ Subclassing creates toctou problems here\n+    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long bitSize, long bitAlignment, long minBitAlignment, Optional<String> name) {\n+        super(bitSize, bitAlignment, name); \/\/ Subclassing creates toctou problems here\n@@ -61,0 +58,1 @@\n+        this.minBitAlignment = minBitAlignment;\n@@ -86,0 +84,8 @@\n+    @Override\n+    public L withBitAlignment(long bitAlignment) {\n+        if (bitAlignment < minBitAlignment) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint\");\n+        }\n+        return super.withBitAlignment(bitAlignment);\n+    }\n+\n@@ -108,1 +114,1 @@\n-        return bitAlignment() == kind.alignof(elements);\n+        return bitAlignment() == minBitAlignment;\n@@ -118,1 +124,1 @@\n-        STRUCT(\"\", Math::addExact),\n+        STRUCT(\"\"),\n@@ -122,1 +128,1 @@\n-        UNION(\"|\", Math::max);\n+        UNION(\"|\");\n@@ -125,1 +131,0 @@\n-        final LongBinaryOperator sizeOp;\n@@ -127,1 +132,1 @@\n-        Kind(String delimTag, LongBinaryOperator sizeOp) {\n+        Kind(String delimTag) {\n@@ -129,16 +134,0 @@\n-            this.sizeOp = sizeOp;\n-        }\n-\n-        long sizeof(List<MemoryLayout> elems) {\n-            long size = 0;\n-            for (MemoryLayout elem : elems) {\n-                size = sizeOp.applyAsLong(size, elem.bitSize());\n-            }\n-            return size;\n-        }\n-\n-        long alignof(List<MemoryLayout> elems) {\n-            return elems.stream()\n-                    .mapToLong(MemoryLayout::bitAlignment)\n-                    .max() \/\/ max alignment in case we have member layouts\n-                    .orElse(8); \/\/ or minimal alignment if no member layout is given\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":16,"deletions":27,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    public final L withBitAlignment(long bitAlignment) {\n+    public L withBitAlignment(long bitAlignment) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,0 +203,8 @@\n+    @Override\n+    public SequenceLayoutImpl withBitAlignment(long bitAlignment) {\n+        if (bitAlignment < elementLayout.bitAlignment()) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint\");\n+        }\n+        return super.withBitAlignment(bitAlignment);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,6 +35,2 @@\n-    private StructLayoutImpl(List<MemoryLayout> elements) {\n-        super(Kind.STRUCT, elements);\n-    }\n-\n-    private StructLayoutImpl(List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n-        super(Kind.STRUCT, elements, bitAlignment, name);\n+    private StructLayoutImpl(List<MemoryLayout> elements, long bitSize, long bitAlignment, long minBitAlignment, Optional<String> name) {\n+        super(Kind.STRUCT, elements, bitSize, bitAlignment, minBitAlignment, name);\n@@ -45,1 +41,1 @@\n-        return new StructLayoutImpl(memberLayouts(), bitAlignment, name);\n+        return new StructLayoutImpl(memberLayouts(), bitSize(), bitAlignment, minBitAlignment, name);\n@@ -49,1 +45,10 @@\n-        return new StructLayoutImpl(elements);\n+        long size = 0;\n+        long align = 8;\n+        for (MemoryLayout elem : elements) {\n+            if (size % elem.bitAlignment() != 0) {\n+                throw new IllegalArgumentException(\"Invalid alignment constraint for member layout: \" + elem);\n+            }\n+            size = Math.addExact(size, elem.bitSize());\n+            align = Math.max(align, elem.bitAlignment());\n+        }\n+        return new StructLayoutImpl(elements, size, align, align, Optional.empty());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/StructLayoutImpl.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,6 +35,2 @@\n-    private UnionLayoutImpl(List<MemoryLayout> elements) {\n-        super(Kind.UNION, elements);\n-    }\n-\n-    private UnionLayoutImpl(List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n-        super(Kind.UNION, elements, bitAlignment, name);\n+    private UnionLayoutImpl(List<MemoryLayout> elements, long bitSize, long bitAlignment, long minBitAlignment, Optional<String> name) {\n+        super(Kind.UNION, elements, bitSize, bitAlignment, minBitAlignment, name);\n@@ -45,1 +41,1 @@\n-        return new UnionLayoutImpl(memberLayouts(), bitAlignment, name);\n+        return new UnionLayoutImpl(memberLayouts(), bitSize(), bitAlignment, minBitAlignment, name);\n@@ -49,1 +45,7 @@\n-        return new UnionLayoutImpl(elements);\n+        long size = 0;\n+        long align = 8;\n+        for (MemoryLayout elem : elements) {\n+            size = Math.max(size, elem.bitSize());\n+            align = Math.max(align, elem.bitAlignment());\n+        }\n+        return new UnionLayoutImpl(elements, size, align, align, Optional.empty());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/UnionLayoutImpl.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    private static final long BIT_ALIGNMENT = Long.SIZE * 2;\n+    private static final long BIT_ALIGNMENT = Byte.SIZE;\n@@ -168,1 +168,3 @@\n-        GroupLayout v = MemoryLayout.structLayout(JAVA_INT, JAVA_LONG)\n+        GroupLayout v = MemoryLayout.structLayout(\n+                        JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n+                        JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n@@ -177,1 +179,3 @@\n-        StructLayout v = MemoryLayout.structLayout(JAVA_INT, JAVA_LONG)\n+        StructLayout v = MemoryLayout.structLayout(\n+                        JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n+                        JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n@@ -186,1 +190,3 @@\n-        UnionLayout v = MemoryLayout.unionLayout(JAVA_INT, JAVA_LONG)\n+        UnionLayout v = MemoryLayout.unionLayout(\n+                    JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n+                    JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -179,38 +179,0 @@\n-    @Test\n-    public void testBadContainerAlign() {\n-        GroupLayout g = MemoryLayout.structLayout(JAVA_INT.withBitAlignment(16).withName(\"foo\")).withBitAlignment(8);\n-        try {\n-            g.bitOffset(groupElement(\"foo\"));\n-            g.byteOffset(groupElement(\"foo\"));\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex); \/\/ should be ok!\n-        }\n-        try {\n-            g.varHandle(groupElement(\"foo\")); \/\/ok\n-            assertTrue(false); \/\/should fail!\n-        } catch (UnsupportedOperationException ex) {\n-            \/\/ok\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex); \/\/should fail!\n-        }\n-    }\n-\n-    @Test\n-    public void testBadAlignOffset() {\n-        GroupLayout g = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n-        try {\n-            g.bitOffset(groupElement(\"foo\"));\n-            g.byteOffset(groupElement(\"foo\"));\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex); \/\/ should be ok!\n-        }\n-        try {\n-            g.varHandle(groupElement(\"foo\")); \/\/ok\n-            assertTrue(false); \/\/should fail!\n-        } catch (UnsupportedOperationException ex) {\n-            \/\/ok\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex); \/\/should fail!\n-        }\n-    }\n-\n@@ -255,3 +217,3 @@\n-                ValueLayout.JAVA_CHAR.withName(\"1\"),\n-                ValueLayout.JAVA_FLOAT.withName(\"2\"),\n-                ValueLayout.JAVA_LONG.withName(\"3\")\n+                ValueLayout.JAVA_CHAR.withBitAlignment(8).withName(\"1\"),\n+                ValueLayout.JAVA_FLOAT.withBitAlignment(8).withName(\"2\"),\n+                ValueLayout.JAVA_LONG.withBitAlignment(8).withName(\"3\")\n@@ -364,1 +326,1 @@\n-            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), JAVA_INT.withName(\"y\"))),\n+            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(32), JAVA_INT.withName(\"y\"))),\n@@ -367,1 +329,1 @@\n-            (JAVA_INT.bitSize() + 8) * 4 + 8\n+            (JAVA_INT.bitSize() + 32) * 4 + 32\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":5,"deletions":43,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-            if (layout.bitAlignment() == layout.bitSize()) {\n+            if (layout.bitAlignment() == bitAlign) {\n@@ -277,1 +277,3 @@\n-                assertEquals(layout.withBitAlignment(a).toString().contains(\"%\"), a != bitAlign);\n+                if (a >= layout.bitAlignment()) {\n+                    assertEquals(layout.withBitAlignment(a).toString().contains(\"%\"), a != bitAlign);\n+                }\n@@ -282,0 +284,22 @@\n+    @Test(dataProvider=\"layoutsAndAlignments\")\n+    public void testBadBitAlignment(MemoryLayout layout, long bitAlign) {\n+        long[] alignments = { 8, 16, 32, 64, 128 };\n+        for (long a : alignments) {\n+            if (a < bitAlign && !(layout instanceof ValueLayout)) {\n+                assertThrows(IllegalArgumentException.class, () -> layout.withBitAlignment(a));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider=\"layoutsAndAlignments\", expectedExceptions = IllegalArgumentException.class)\n+    public void testBadSequence(MemoryLayout layout, long bitAlign) {\n+        layout = layout.withBitAlignment(layout.bitSize() * 2); \/\/ hyper-align\n+        MemoryLayout.sequenceLayout(layout);\n+    }\n+\n+    @Test(dataProvider=\"layoutsAndAlignments\", expectedExceptions = IllegalArgumentException.class)\n+    public void testBadStruct(MemoryLayout layout, long bitAlign) {\n+        layout = layout.withBitAlignment(layout.bitSize() * 2); \/\/ hyper-align\n+        MemoryLayout.structLayout(layout, layout);\n+    }\n+\n@@ -420,1 +444,1 @@\n-                MemoryLayout.structLayout(JAVA_INT, JAVA_LONG),\n+                MemoryLayout.structLayout(JAVA_INT, MemoryLayout.paddingLayout(32), JAVA_LONG),\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -65,3 +65,0 @@\n-        MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n-        assertEquals(alignedGroup.bitAlignment(), align);\n-        VarHandle vh = aligned.varHandle();\n@@ -69,0 +66,3 @@\n+            MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n+            assertEquals(alignedGroup.bitAlignment(), align);\n+            VarHandle vh = aligned.varHandle();\n@@ -81,1 +81,0 @@\n-        GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -83,0 +82,1 @@\n+            GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -85,1 +85,1 @@\n-        } catch (UnsupportedOperationException ex) {\n+        } catch (IllegalArgumentException ex) {\n@@ -92,1 +92,0 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(align));\n@@ -94,0 +93,1 @@\n+            SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(align));\n@@ -101,1 +101,1 @@\n-        } catch (UnsupportedOperationException ex) {\n+        } catch (IllegalArgumentException ex) {\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -216,21 +216,0 @@\n-            },\n-            \/\/ struct __attribute__((__packed__)) s { float a; double b; };\n-            { MemoryLayout.structLayout(C_FLOAT, C_DOUBLE),\n-                new Binding[]{\n-                    dup(),\n-                    \/\/ s.a\n-                    bufferLoad(0, float.class), vmStore(f10, float.class),\n-                    \/\/ s.b\n-                    bufferLoad(4, double.class), vmStore(f11, double.class),\n-                }\n-            },\n-            \/\/ struct s { float a; float b __attribute__ ((aligned (8))); }\n-            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32),\n-                C_FLOAT, MemoryLayout.paddingLayout(32)),\n-                new Binding[]{\n-                    dup(),\n-                    \/\/ s.a\n-                    bufferLoad(0, float.class), vmStore(f10, float.class),\n-                    \/\/ s.b\n-                    bufferLoad(8, float.class), vmStore(f11, float.class),\n-                }\n@@ -281,1 +260,1 @@\n-        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, C_DOUBLE);\n+        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE);\n@@ -301,1 +280,1 @@\n-                bufferLoad(4, double.class),\n+                bufferLoad(8, double.class),\n@@ -313,1 +292,1 @@\n-            bufferStore(4, double.class)\n+            bufferStore(8, double.class)\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -148,60 +148,0 @@\n-    @Test\n-    public void testNestedStructsUnaligned() {\n-        MemoryLayout POINT = MemoryLayout.structLayout(\n-                C_INT,\n-                MemoryLayout.structLayout(\n-                        C_LONG,\n-                        C_INT\n-                )\n-        );\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(POINT);\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n-                    bufferLoad(8, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class)},\n-            { vmStore(rax, long.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-\n-        assertEquals(bindings.nVectorArgs(), 0);\n-    }\n-\n-    @Test\n-    public void testNestedUnionUnaligned() {\n-        MemoryLayout POINT = MemoryLayout.structLayout(\n-                C_INT,\n-                MemoryLayout.unionLayout(\n-                        MemoryLayout.structLayout(C_INT, C_INT),\n-                        C_LONG\n-                )\n-        );\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(POINT);\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n-                    bufferLoad(8, int.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class)},\n-            { vmStore(rax, long.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-\n-        assertEquals(bindings.nVectorArgs(), 0);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"modified"}]}