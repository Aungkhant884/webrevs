{"files":[{"patch":"@@ -302,0 +302,15 @@\n+void BarrierSetAssembler::check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error) {\n+  \/\/ Check if the oop is in the right area of memory\n+  __ mov(tmp2, (intptr_t) Universe::verify_oop_mask());\n+  __ andr(tmp1, obj, tmp2);\n+  __ mov(tmp2, (intptr_t) Universe::verify_oop_bits());\n+\n+  \/\/ Compare tmp1 and tmp2.  We don't use a compare\n+  \/\/ instruction here because the flags register is live.\n+  __ eor(tmp1, tmp1, tmp2);\n+  __ cbnz(tmp1, error);\n+\n+  \/\/ make sure klass is 'reasonable', which is not zero.\n+  __ load_klass(obj, obj); \/\/ get klass\n+  __ cbz(obj, error);      \/\/ if klass is NULL it is broken\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+  virtual void check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,0 +450,14 @@\n+\n+#define __ masm->\n+\n+void ZBarrierSetAssembler::check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error) {\n+  \/\/ Check if mask is good.\n+  \/\/ verifies that ZAddressBadMask & r0 == 0\n+  __ ldr(tmp2, Address(rthread, ZThreadLocalData::address_bad_mask_offset()));\n+  __ andr(tmp1, obj, tmp2);\n+  __ cbnz(tmp1, error);\n+\n+  BarrierSetAssembler::check_oop(masm, obj, tmp1, tmp2, error);\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+\n+  void check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -571,23 +571,2 @@\n-#if INCLUDE_ZGC\n-    if (UseZGC) {\n-      \/\/ Check if mask is good.\n-      \/\/ verifies that ZAddressBadMask & r0 == 0\n-      __ ldr(c_rarg3, Address(rthread, ZThreadLocalData::address_bad_mask_offset()));\n-      __ andr(c_rarg2, r0, c_rarg3);\n-      __ cbnz(c_rarg2, error);\n-    }\n-#endif\n-\n-    \/\/ Check if the oop is in the right area of memory\n-    __ mov(c_rarg3, (intptr_t) Universe::verify_oop_mask());\n-    __ andr(c_rarg2, r0, c_rarg3);\n-    __ mov(c_rarg3, (intptr_t) Universe::verify_oop_bits());\n-\n-    \/\/ Compare c_rarg2 and c_rarg3.  We don't use a compare\n-    \/\/ instruction here because the flags register is live.\n-    __ eor(c_rarg2, c_rarg2, c_rarg3);\n-    __ cbnz(c_rarg2, error);\n-\n-    \/\/ make sure klass is 'reasonable', which is not zero.\n-    __ load_klass(r0, r0);  \/\/ get klass\n-    __ cbz(r0, error);      \/\/ if klass is NULL it is broken\n+    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs_asm->check_oop(_masm, r0, c_rarg2, c_rarg3, error);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -734,1 +734,4 @@\n-            __ verify_oop(from_reg->as_register(), FILE_AND_LINE);\n+            if (VerifyOops) {\n+              BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+              bs->check_oop(_masm, from_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+            }\n@@ -775,1 +778,4 @@\n-          __ verify_oop(from_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+          if (VerifyOops) {\n+            BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+            bs->check_oop(_masm, from_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+          }\n@@ -816,1 +822,4 @@\n-          __ verify_oop(to_reg->as_register(), FILE_AND_LINE);\n+          if (VerifyOops) {\n+            BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+            bs->check_oop(_masm, to_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+          }\n@@ -847,1 +856,4 @@\n-        __ verify_oop(to_reg->as_register(), FILE_AND_LINE);\n+        if (VerifyOops) {\n+          BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+          bs->check_oop(_masm, to_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+        }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -258,0 +258,4 @@\n+\n+void BarrierSetAssembler::check_oop(MacroAssembler *masm, Register oop, const char* msg) {\n+  __ verify_oop(oop, msg);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,2 @@\n+\n+  virtual void check_oop(MacroAssembler *masm, Register oop, const char* msg);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,0 +311,14 @@\n+\n+void BarrierSetAssembler::check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error) {\n+  \/\/ Check if the oop is in the right area of memory\n+  __ mv(tmp2, (intptr_t) Universe::verify_oop_mask());\n+  __ andr(tmp1, obj, tmp2);\n+  __ mv(tmp2, (intptr_t) Universe::verify_oop_bits());\n+\n+  \/\/ Compare tmp1 and tmp2.\n+  __ bne(tmp1, tmp2, error);\n+\n+  \/\/ Make sure klass is 'reasonable', which is not zero.\n+  __ load_klass(obj, obj, tmp1); \/\/ get klass\n+  __ beqz(obj, error);           \/\/ if klass is NULL it is broken\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+  virtual void check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,0 +447,14 @@\n+\n+#define __ masm->\n+\n+void ZBarrierSetAssembler::check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error) {\n+  \/\/ Check if mask is good.\n+  \/\/ verifies that ZAddressBadMask & obj == 0\n+  __ ld(tmp2, Address(xthread, ZThreadLocalData::address_bad_mask_offset()));\n+  __ andr(tmp1, obj, tmp2);\n+  __ bnez(tmp1, error);\n+\n+  BarrierSetAssembler::check_oop(masm, obj, tmp1, tmp2, error);\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+\n+  void check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -617,21 +617,2 @@\n-#if INCLUDE_ZGC\n-    if (UseZGC) {\n-      \/\/ Check if mask is good.\n-      \/\/ verifies that ZAddressBadMask & x10 == 0\n-      __ ld(c_rarg3, Address(xthread, ZThreadLocalData::address_bad_mask_offset()));\n-      __ andr(c_rarg2, x10, c_rarg3);\n-      __ bnez(c_rarg2, error);\n-    }\n-#endif\n-\n-    \/\/ Check if the oop is in the right area of memory\n-    __ mv(c_rarg3, (intptr_t) Universe::verify_oop_mask());\n-    __ andr(c_rarg2, x10, c_rarg3);\n-    __ mv(c_rarg3, (intptr_t) Universe::verify_oop_bits());\n-\n-    \/\/ Compare c_rarg2 and c_rarg3.\n-    __ bne(c_rarg2, c_rarg3, error);\n-\n-    \/\/ make sure klass is 'reasonable', which is not zero.\n-    __ load_klass(x10, x10);  \/\/ get klass\n-    __ beqz(x10, error);      \/\/ if klass is NULL it is broken\n+    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs_asm->check_oop(_masm, x10, c_rarg2, c_rarg3, error);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -369,0 +369,15 @@\n+\n+void BarrierSetAssembler::check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error) {\n+  \/\/ Check if the oop is in the right area of memory\n+  __ movptr(tmp1, obj);\n+  __ movptr(tmp2, (intptr_t) Universe::verify_oop_mask());\n+  __ andptr(tmp1, tmp2);\n+  __ movptr(tmp2, (intptr_t) Universe::verify_oop_bits());\n+  __ cmpptr(tmp1, tmp2);\n+  __ jcc(Assembler::notZero, error);\n+\n+  \/\/ make sure klass is 'reasonable', which is not zero.\n+  __ load_klass(obj, obj, tmp1);  \/\/ get klass\n+  __ testptr(obj, obj);\n+  __ jcc(Assembler::zero, error); \/\/ if klass is NULL it is broken\n+}\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+\n+  virtual void check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/z\/zThreadLocalData.hpp\"\n@@ -703,0 +704,11 @@\n+\n+#define __ masm->\n+\n+void ZBarrierSetAssembler::check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error) {\n+  \/\/ Check if metadata bits indicate a bad oop\n+  __ testptr(obj, Address(r15_thread, ZThreadLocalData::address_bad_mask_offset()));\n+  __ jcc(Assembler::notZero, error);\n+  BarrierSetAssembler::check_oop(masm, obj, tmp1, tmp2, error);\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+\n+  void check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1096,20 +1096,2 @@\n-#if INCLUDE_ZGC\n-  if (UseZGC) {\n-    \/\/ Check if metadata bits indicate a bad oop\n-    __ testptr(rax, Address(r15_thread, ZThreadLocalData::address_bad_mask_offset()));\n-    __ jcc(Assembler::notZero, error);\n-  }\n-#endif\n-\n-  \/\/ Check if the oop is in the right area of memory\n-  __ movptr(c_rarg2, rax);\n-  __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_mask());\n-  __ andptr(c_rarg2, c_rarg3);\n-  __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_bits());\n-  __ cmpptr(c_rarg2, c_rarg3);\n-  __ jcc(Assembler::notZero, error);\n-\n-  \/\/ make sure klass is 'reasonable', which is not zero.\n-  __ load_klass(rax, rax, rscratch1);  \/\/ get klass\n-  __ testptr(rax, rax);\n-  __ jcc(Assembler::zero, error); \/\/ if klass is NULL it is broken\n+   BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+   bs_asm->check_oop(_masm, rax, c_rarg2, c_rarg3, error);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"}]}