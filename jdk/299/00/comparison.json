{"files":[{"patch":"@@ -71,9 +71,17 @@\n-    \/\/ Note that a ldrexd + clrex combination is only needed for\n-    \/\/ correctness on the OS level (context-switches). In this\n-    \/\/ case, clrex *may* be beneficial for performance. For now\n-    \/\/ don't bother with clrex as this is Zero.\n-    jlong tmp;\n-    asm volatile (\"ldrexd  %0, [%1]\\n\"\n-                  : \"=r\"(tmp)\n-                  : \"r\"(src), \"m\"(src));\n-    *(jlong *) dst = tmp;\n+    \/\/ The only way to perform the atomic 64-bit load\/store\n+    \/\/ is to use ldrexd\/strexd for both reads and writes.\n+    \/\/ For store, we need to have the matching (fake) load first.\n+    \/\/ Put clrex between exclusive ops on src and dst for clarity.\n+    uint64_t tmp_r, tmp_w;\n+    uint32_t flag_w;\n+    asm volatile (\"ldrexd %[tmp_r], [%[src]]\\n\"\n+                  \"clrex\\n\"\n+                  \"1:\\n\"\n+                  \"ldrexd %[tmp_w], [%[dst]]\\n\"\n+                  \"strexd %[flag_w], %[tmp_r], [%[dst]]\\n\"\n+                  \"cmp    %[flag_w], 0\\n\"\n+                  \"bne    1b\\n\"\n+                  : [tmp_r] \"=&r\" (tmp_r), [tmp_w] \"=&r\" (tmp_w),\n+                    [flag_w] \"=&r\" (flag_w)\n+                  : [src] \"r\" (src), [dst] \"r\" (dst)\n+                  : \"cc\", \"memory\");\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"}]}