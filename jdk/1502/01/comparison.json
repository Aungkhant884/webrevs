{"files":[{"patch":"@@ -344,1 +344,1 @@\n-    jchar pid;\n+    pid_t pid;\n@@ -346,1 +346,1 @@\n-    size_t plen = ICMP_ADVLENMIN + sizeof(tv);\n+    size_t plen = ICMP_ADVLENMIN + sizeof(tv) + sizeof(pid_t);\n@@ -364,0 +364,2 @@\n+    \/\/we don't need to cast this down, as it will be put into the icmp_data member\n+    pid = htonl(getpid());\n@@ -365,2 +367,0 @@\n-    \/\/ icmp_id is a 16 bit data type, therefore down cast the pid\n-    pid = (jchar)getpid();\n@@ -375,2 +375,3 @@\n-        \/\/ let's tag the ECHO packet with our pid so we can identify it\n-        icmp->icmp_id = htons(pid);\n+        \/\/ same result as downcasting the little-endian pid, although we are not longer\n+        \/\/ relying on this value to identify echo replies.\n+        icmp->icmp_id = pid >> 16;\n@@ -381,0 +382,2 @@\n+        \/\/copy our pid into icmp_data so we can uniquely identify the echo response\n+        memcpy(icmp->icmp_data + sizeof(tv), &pid, sizeof(pid_t));\n@@ -423,1 +426,1 @@\n-                \/\/ I.E.: An ICMP_ECHO_REPLY packet with the proper PID and\n+                \/\/ I.E.: An ICMP_ECHO_REPLY packet with the proper timestamp and PID\n@@ -426,1 +429,2 @@\n-                    (ntohs(icmp->icmp_id) == pid))\n+                (memcmp(icmp->icmp_data, &tv, sizeof(tv)) == 0) &&\n+                (*(pid_t *)(icmp->icmp_data + sizeof(tv)) == pid))\n@@ -489,4 +493,13 @@\n-    \/\/ Let's try to create a RAW socket to send ICMP packets.\n-    \/\/ This usually requires \"root\" privileges, so it's likely to fail.\n-    fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);\n-    if (fd == -1) {\n+\/*\n+    First we see if the OS supports ICMP as a protocol.\n+    In the event that this is an older kernel without IPPROTO_ICMP\n+    or that the net.ipv4.ping_group_range kernel parameter is not\n+    set, then we fall back to trying to create a RAW socket to\n+    send ICMP packets.\n+    This usually requires \"root\" privileges, so it's likely to fail.\n+    If all else fails, fall back to TCP and implement tcp echo\n+*\/\n+    fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);\n+    if (fd == -1)\n+        fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);\n+    if (fd == -1)\n@@ -494,2 +507,1 @@\n-    } else {\n-        \/\/ It didn't fail, so we can use ICMP_ECHO requests.\n+    else\n@@ -497,1 +509,1 @@\n-    }\n+\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet4AddressImpl.c","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -547,1 +547,1 @@\n-    jchar pid;\n+    pid_t pid;\n@@ -549,1 +549,1 @@\n-    size_t plen = sizeof(struct icmp6_hdr) + sizeof(tv);\n+    size_t plen = sizeof(struct icmp6_hdr) + sizeof(tv) + sizeof(pid_t);\n@@ -577,2 +577,2 @@\n-    \/\/ icmp_id is a 16 bit data type, therefore down cast the pid\n-    pid = (jchar)getpid();\n+    \/\/we don't need to cast this down, as it will be put into the icmp_data member\n+    pid = htonl(getpid());\n@@ -587,2 +587,3 @@\n-        \/\/ let's tag the ECHO packet with our pid so we can identify it\n-        icmp6->icmp6_id = htons(pid);\n+        \/\/ same result as downcasting the little-endian pid, although we are not longer\n+        \/\/ relying on this value to identify echo replies.\n+        icmp6->icmp6_id = pid >> 16;\n@@ -593,0 +594,3 @@\n+        \/\/copy our pid into icmp_data so we can uniquely identify the echo response\n+        memcpy(sendbuf + sizeof(struct icmp6_hdr) + sizeof(tv), &pid, sizeof(pid_t));\n+\n@@ -629,0 +633,1 @@\n+\n@@ -630,1 +635,2 @@\n-                    (ntohs(icmp6->icmp6_id) == pid))\n+                (memcmp(recvbuf + sizeof(struct icmp6_hdr), &tv, sizeof(tv)) == 0) &&\n+                (*(pid_t *)(recvbuf + sizeof(struct icmp6_hdr) + sizeof(tv)) == pid))\n@@ -700,4 +706,12 @@\n-    \/\/ Let's try to create a RAW socket to send ICMP packets.\n-    \/\/ This usually requires \"root\" privileges, so it's likely to fail.\n-    fd = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n-    if (fd == -1) {\n+\/*\n+    First we see if the OS supports ICMP as a protocol.\n+    In the event that this is an older kernel without\n+    IPPROTO_ICMPV6, then we fall back to trying to create\n+    a RAW socket to send ICMP packets.\n+    This usually requires \"root\" privileges, so it's likely to fail.\n+    If all else fails, fall back to TCP and implement tcp echo\n+*\/\n+    fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6);\n+    if (fd == -1)\n+        fd = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n+    if (fd == -1)\n@@ -705,2 +719,1 @@\n-    } else {\n-        \/\/ It didn't fail, so we can use ICMP_ECHO requests.\n+    else\n@@ -708,1 +721,0 @@\n-    }\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet6AddressImpl.c","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"}]}