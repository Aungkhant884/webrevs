{"files":[{"patch":"@@ -161,93 +161,0 @@\n-    \/**\n-     * Step mapping Theta as defined in section 3.2.1 .\n-     *\/\n-    private static long[] smTheta(long[] a) {\n-        long c0 = a[0]^a[5]^a[10]^a[15]^a[20];\n-        long c1 = a[1]^a[6]^a[11]^a[16]^a[21];\n-        long c2 = a[2]^a[7]^a[12]^a[17]^a[22];\n-        long c3 = a[3]^a[8]^a[13]^a[18]^a[23];\n-        long c4 = a[4]^a[9]^a[14]^a[19]^a[24];\n-        long d0 = c4 ^ Long.rotateLeft(c1, 1);\n-        long d1 = c0 ^ Long.rotateLeft(c2, 1);\n-        long d2 = c1 ^ Long.rotateLeft(c3, 1);\n-        long d3 = c2 ^ Long.rotateLeft(c4, 1);\n-        long d4 = c3 ^ Long.rotateLeft(c0, 1);\n-        for (int y = 0; y < a.length; y += DM) {\n-            a[y] ^= d0;\n-            a[y+1] ^= d1;\n-            a[y+2] ^= d2;\n-            a[y+3] ^= d3;\n-            a[y+4] ^= d4;\n-        }\n-        return a;\n-    }\n-\n-    \/**\n-     * Merged Step mapping Rho (section 3.2.2) and Pi (section 3.2.3).\n-     * for performance. Optimization is achieved by precalculating\n-     * shift constants for the following loop\n-     *   int xNext, yNext;\n-     *   for (int t = 0, x = 1, y = 0; t <= 23; t++, x = xNext, y = yNext) {\n-     *        int numberOfShift = ((t + 1)*(t + 2)\/2) % 64;\n-     *        a[y][x] = Long.rotateLeft(a[y][x], numberOfShift);\n-     *        xNext = y;\n-     *        yNext = (2 * x + 3 * y) % DM;\n-     *   }\n-     * and with inplace permutation.\n-     *\/\n-    private static long[] smPiRho(long[] a) {\n-        long tmp = Long.rotateLeft(a[10], 3);\n-        a[10] = Long.rotateLeft(a[1], 1);\n-        a[1] = Long.rotateLeft(a[6], 44);\n-        a[6] = Long.rotateLeft(a[9], 20);\n-        a[9] = Long.rotateLeft(a[22], 61);\n-        a[22] = Long.rotateLeft(a[14], 39);\n-        a[14] = Long.rotateLeft(a[20], 18);\n-        a[20] = Long.rotateLeft(a[2], 62);\n-        a[2] = Long.rotateLeft(a[12], 43);\n-        a[12] = Long.rotateLeft(a[13], 25);\n-        a[13] = Long.rotateLeft(a[19], 8);\n-        a[19] = Long.rotateLeft(a[23], 56);\n-        a[23] = Long.rotateLeft(a[15], 41);\n-        a[15] = Long.rotateLeft(a[4], 27);\n-        a[4] = Long.rotateLeft(a[24], 14);\n-        a[24] = Long.rotateLeft(a[21], 2);\n-        a[21] = Long.rotateLeft(a[8], 55);\n-        a[8] = Long.rotateLeft(a[16], 45);\n-        a[16] = Long.rotateLeft(a[5], 36);\n-        a[5] = Long.rotateLeft(a[3], 28);\n-        a[3] = Long.rotateLeft(a[18], 21);\n-        a[18] = Long.rotateLeft(a[17], 15);\n-        a[17] = Long.rotateLeft(a[11], 10);\n-        a[11] = Long.rotateLeft(a[7], 6);\n-        a[7] = tmp;\n-        return a;\n-    }\n-\n-    \/**\n-     * Step mapping Chi as defined in section 3.2.4.\n-     *\/\n-    private static long[] smChi(long[] a) {\n-        for (int y = 0; y < a.length; y+=DM) {\n-            long ay0 = a[y];\n-            long ay1 = a[y+1];\n-            long ay2 = a[y+2];\n-            long ay3 = a[y+3];\n-            long ay4 = a[y+4];\n-            a[y] = ay0 ^ ((~ay1) & ay2);\n-            a[y+1] = ay1 ^ ((~ay2) & ay3);\n-            a[y+2] = ay2 ^ ((~ay3) & ay4);\n-            a[y+3] = ay3 ^ ((~ay4) & ay0);\n-            a[y+4] = ay4 ^ ((~ay0) & ay1);\n-        }\n-        return a;\n-    }\n-\n-    \/**\n-     * Step mapping Iota as defined in section 3.2.5.\n-     *\/\n-    private static long[] smIota(long[] a, int rndIndex) {\n-        a[0] ^= RC_CONSTANTS[rndIndex];\n-        return a;\n-    }\n-\n@@ -261,0 +168,10 @@\n+\n+        long a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12;\n+        long a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24;\n+        \/\/ move data into local variables\n+        a0 = lanes[0]; a1 = lanes[1]; a2 = lanes[2]; a3 = lanes[3]; a4 = lanes[4];\n+        a5 = lanes[5]; a6 = lanes[6]; a7 = lanes[7]; a8 = lanes[8]; a9 = lanes[9];\n+        a10 = lanes[10]; a11 = lanes[11]; a12 = lanes[12]; a13 = lanes[13]; a14 = lanes[14];\n+        a15 = lanes[15]; a16 = lanes[16]; a17 = lanes[17]; a18 = lanes[18]; a19 = lanes[19];\n+        a20 = lanes[20]; a21 = lanes[21]; a22 = lanes[22]; a23 = lanes[23]; a24 = lanes[24];\n+\n@@ -263,1 +180,98 @@\n-            smIota(smChi(smPiRho(smTheta(lanes))), ir);\n+            \/\/ Step mapping Theta as defined in section 3.2.1.\n+            long c0 = a0^a5^a10^a15^a20;\n+            long c1 = a1^a6^a11^a16^a21;\n+            long c2 = a2^a7^a12^a17^a22;\n+            long c3 = a3^a8^a13^a18^a23;\n+            long c4 = a4^a9^a14^a19^a24;\n+            long d0 = c4 ^ Long.rotateLeft(c1, 1);\n+            long d1 = c0 ^ Long.rotateLeft(c2, 1);\n+            long d2 = c1 ^ Long.rotateLeft(c3, 1);\n+            long d3 = c2 ^ Long.rotateLeft(c4, 1);\n+            long d4 = c3 ^ Long.rotateLeft(c0, 1);\n+            a0  ^= d0; a1  ^= d1; a2  ^= d2; a3  ^= d3; a4  ^= d4;\n+            a5  ^= d0; a6  ^= d1; a7  ^= d2; a8  ^= d3; a9  ^= d4;\n+            a10 ^= d0; a11 ^= d1; a12 ^= d2; a13 ^= d3; a14 ^= d4;\n+            a15 ^= d0; a16 ^= d1; a17 ^= d2; a18 ^= d3; a19 ^= d4;\n+            a20 ^= d0; a21 ^= d1; a22 ^= d2; a23 ^= d3; a24 ^= d4;\n+\n+            \/**\n+             * Merged Step mapping Rho (section 3.2.2) and Pi (section 3.2.3).\n+             * for performance. Optimization is achieved by precalculating\n+             * shift constants for the following loop\n+             *   int xNext, yNext;\n+             *   for (int t = 0, x = 1, y = 0; t <= 23; t++, x = xNext, y = yNext) {\n+             *        int numberOfShift = ((t + 1)*(t + 2)\/2) % 64;\n+             *        a[y][x] = Long.rotateLeft(a[y][x], numberOfShift);\n+             *        xNext = y;\n+             *        yNext = (2 * x + 3 * y) % DM;\n+             *   }\n+             * and with inplace permutation.\n+             *\/\n+            long ay = Long.rotateLeft(a10, 3);\n+            a10 = Long.rotateLeft(a1, 1);\n+            a1 = Long.rotateLeft(a6, 44);\n+            a6 = Long.rotateLeft(a9, 20);\n+            a9 = Long.rotateLeft(a22, 61);\n+            a22 = Long.rotateLeft(a14, 39);\n+            a14 = Long.rotateLeft(a20, 18);\n+            a20 = Long.rotateLeft(a2, 62);\n+            a2 = Long.rotateLeft(a12, 43);\n+            a12 = Long.rotateLeft(a13, 25);\n+            a13 = Long.rotateLeft(a19, 8);\n+            a19 = Long.rotateLeft(a23, 56);\n+            a23 = Long.rotateLeft(a15, 41);\n+            a15 = Long.rotateLeft(a4, 27);\n+            a4 = Long.rotateLeft(a24, 14);\n+            a24 = Long.rotateLeft(a21, 2);\n+            a21 = Long.rotateLeft(a8, 55);\n+            a8 = Long.rotateLeft(a16, 45);\n+            a16 = Long.rotateLeft(a5, 36);\n+            a5 = Long.rotateLeft(a3, 28);\n+            a3 = Long.rotateLeft(a18, 21);\n+            a18 = Long.rotateLeft(a17, 15);\n+            a17 = Long.rotateLeft(a11, 10);\n+            a11 = Long.rotateLeft(a7, 6);\n+            a7 = ay;\n+\n+            \/\/ Step mapping Chi as defined in section 3.2.4.\n+            long tmp0 = a0;\n+            long tmp1 = a1;\n+            long tmp2 = a2;\n+            long tmp3 = a3;\n+            long tmp4 = a4;\n+            a0 = tmp0 ^ ((~tmp1) & tmp2);\n+            a1 = tmp1 ^ ((~tmp2) & tmp3);\n+            a2 = tmp2 ^ ((~tmp3) & tmp4);\n+            a3 = tmp3 ^ ((~tmp4) & tmp0);\n+            a4 = tmp4 ^ ((~tmp0) & tmp1);\n+\n+            tmp0 = a5; tmp1 = a6; tmp2 = a7; tmp3 = a8; tmp4 = a9;\n+            a5 = tmp0 ^ ((~tmp1) & tmp2);\n+            a6 = tmp1 ^ ((~tmp2) & tmp3);\n+            a7 = tmp2 ^ ((~tmp3) & tmp4);\n+            a8 = tmp3 ^ ((~tmp4) & tmp0);\n+            a9 = tmp4 ^ ((~tmp0) & tmp1);\n+\n+            tmp0 = a10; tmp1 = a11; tmp2 = a12; tmp3 = a13; tmp4 = a14;\n+            a10 = tmp0 ^ ((~tmp1) & tmp2);\n+            a11 = tmp1 ^ ((~tmp2) & tmp3);\n+            a12 = tmp2 ^ ((~tmp3) & tmp4);\n+            a13 = tmp3 ^ ((~tmp4) & tmp0);\n+            a14 = tmp4 ^ ((~tmp0) & tmp1);\n+\n+            tmp0 = a15; tmp1 = a16; tmp2 = a17; tmp3 = a18; tmp4 = a19;\n+            a15 = tmp0 ^ ((~tmp1) & tmp2);\n+            a16 = tmp1 ^ ((~tmp2) & tmp3);\n+            a17 = tmp2 ^ ((~tmp3) & tmp4);\n+            a18 = tmp3 ^ ((~tmp4) & tmp0);\n+            a19 = tmp4 ^ ((~tmp0) & tmp1);\n+\n+            tmp0 = a20; tmp1 = a21; tmp2 = a22; tmp3 = a23; tmp4 = a24;\n+            a20 = tmp0 ^ ((~tmp1) & tmp2);\n+            a21 = tmp1 ^ ((~tmp2) & tmp3);\n+            a22 = tmp2 ^ ((~tmp3) & tmp4);\n+            a23 = tmp3 ^ ((~tmp4) & tmp0);\n+            a24 = tmp4 ^ ((~tmp0) & tmp1);\n+\n+            \/\/ Step mapping Iota as defined in section 3.2.5.\n+            a0 ^= RC_CONSTANTS[ir];\n@@ -265,0 +279,7 @@\n+\n+        lanes[0] = a0; lanes[1] = a1; lanes[2] = a2; lanes[3] = a3; lanes[4] = a4;\n+        lanes[5] = a5; lanes[6] = a6; lanes[7] = a7; lanes[8] = a8; lanes[9] = a9;\n+        lanes[10] = a10; lanes[11] = a11; lanes[12] = a12; lanes[13] = a13; lanes[14] = a14;\n+        lanes[15] = a15; lanes[16] = a16; lanes[17] = a17; lanes[18] = a18; lanes[19] = a19;\n+        lanes[20] = a20; lanes[21] = a21; lanes[22] = a22; lanes[23] = a23; lanes[24] = a24;\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":115,"deletions":94,"binary":false,"changes":209,"status":"modified"}]}