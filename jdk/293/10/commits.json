[{"commit":{"message":"stubGenerator_ppc.cpp: reduce loop_unrolls to 1 to match new benchmark results."},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"}],"sha":"c4d22da36db9d79b2ccd5d69bf91a2166d78faa0"},{"commit":{"message":"stubGenerator_ppc.cpp: fix trailing whitespace errors"},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"}],"sha":"8292527ef8a6d8660c29927bcea919221d3c30a8"},{"commit":{"message":"stubGenerator_ppc.cpp: Remove the predicted branch around the xxsel instruction to improves performance by about 9%\n\nThis conditional branch around the xxsel seemed like a good idea at the\ntime, because I thought the branch would be less costly than the xxsel\ninstruction, but it turns out not to be the case; executing the xxsel every\ntime without a conditional branch increases performance by about 9%.\nRemoving that branch also removed the need for the declaration and usage of\nan array of Label's for the branch destinations inside the unrolled code."},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"}],"sha":"0e291be4f682a65538811ec00d2b3ac428a98bd4"},{"commit":{"message":"stubGenerator_ppc.cpp: address issues with understanding the pack algorithm\n\n * Change the order of the bytes as listed in the tables, which makes the\n   use of vpextd easier to understand.\n\n * Because the byte order of the constants used in the tables is reversed from\n   the original documentation, change the constant declarations to match the order\n   in the table, by using the ARRAY_TO_LXV_ORDER macro.  This makes the constant\n   declarations more consistent as well."},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"}],"sha":"b958c023155ef019e0ee2301591cb63e432ccc57"},{"commit":{"message":"TestBase64.java: remove jdk.test.lib.Utils from @build which was causing Tier3 failures."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java"}],"sha":"8e15d971e507f3f1441da392343390766a2bbe95"},{"commit":{"message":"CheckGraalIntrinsics.java: fix copy\/paste error"},"files":[{"filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot.test\/src\/org\/graalvm\/compiler\/hotspot\/test\/CheckGraalIntrinsics.java"}],"sha":"f93614dc3a9b5e66dd765d174375f83aba4536c1"},{"commit":{"message":"CheckGraalIntrinsics.java: Disable testing of decodeBlock intrinsic until implemented for AMD64\/x86"},"files":[{"filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot.test\/src\/org\/graalvm\/compiler\/hotspot\/test\/CheckGraalIntrinsics.java"}],"sha":"dcd15d5788e7a1b6b69f82d387aa157c52b645fd"},{"commit":{"message":"Merge branch 'master' of https:\/\/git.openjdk.java.net\/jdk into base64_decode_intrinsic"},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp"},{"filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp"},{"filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp"},{"filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp"},{"filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp"},{"filename":"src\/hotspot\/share\/opto\/c2compiler.cpp"},{"filename":"src\/hotspot\/share\/opto\/escape.cpp"},{"filename":"src\/hotspot\/share\/opto\/library_call.cpp"},{"filename":"src\/hotspot\/share\/opto\/library_call.hpp"},{"filename":"src\/hotspot\/share\/opto\/runtime.cpp"},{"filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp"}],"sha":"d9b18e9777e1ebc3f3b955e6933cfa6578b3e627"},{"commit":{"message":"stubGenerator_ppc.cpp: remove unnecessary complexity for checking < 0 after srawi."},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"}],"sha":"46cb103281b28efe32877acfa9d0749773fad381"},{"commit":{"message":"Per Martin Doerr's v4 review: fix regression, and speed up return time for buffers that are too small\n\n - Check for case where the result of subtacting 12 off of the source\n   length produces a negative number.  To do this efficiently, I added the\n   instruction definition for mcrxrx, which is implemented on Power9+.\n\n - Rearrange the code so that minimal initialization is performed before\n   checking the size, so that the intrinsic can return quickly in the event\n   that the buffer is too small to process."},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp"},{"filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp"},{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"}],"sha":"b5acb75c7b6abaa65a3460eddcb56beb776c0928"},{"commit":{"message":"TestBase64.java: fix comment to correctly reflect actual intrinsic names.\n\nThe intrinsic names that are visible with -XX:+PrintCompilation are encode\nand decode, rather than encodeBlock and decodeBlock."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java"}],"sha":"164fa2a91213f8b8b02ad9a9368fe1f3ecb6ccd9"},{"commit":{"message":"stubGenerator_ppc.cpp: fix regression caused by change to using loop counter\n\nMy original fix didn't account for the case where sl < block_size.  In the\nevent sl < block_size, the shifted sl will become zero, so it should\njump to the code that computes how much data was processed - 0 - and return."},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"}],"sha":"c8110d13522924c27e4e3a1b491960b13656903c"},{"commit":{"message":"stubGenerator_ppc.cpp: Fix multiple issues as per Martin Doerr's v2 review\n\n * Remove extraneous comma from SAP copyright notice\n * Move align(32) to the head of the loop rather than the beginning of the unwound code\n * Simplified looping condition to use a loop counter instead of a final\n   address.  This eliminated the need for the \"end\" variable, and\n   essentially replaced it with CTR, which is computed using a simple\n   bitwise shift of the size.\n * Re-ran benchmarks against loop_unrolls values: 1, 2, 4, 8, 16 to find\n   optimal value, now 4.\n * Corrected a typo in the word \"elements\""},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"}],"sha":"8932c233bbf0c9bde8861e720a37eda6998bbeb6"},{"commit":{"message":"vm_version_ppc.cpp: per Martin Doerr's review of v2: fix copy\/paste error"},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp"}],"sha":"5ecac9884da073a762884b80f0163734716e47c2"},{"commit":{"message":"vmIntrinsics.cpp: Per Martin Doerr's v2 review: rearrange order of case statement to be consistent with others."},"files":[{"filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp"}],"sha":"64f0b8072ed32eef7d471d2316a3886dde93018c"},{"commit":{"message":"runtime.cpp: per Martin Doerr's review of v2, correct comment as per current semantics of decodeBlock()\n\n  * The reference to \"ofs\" seems to be a copy\/paste error.\n  * -1 is no longer returned from decodeBlock() in the event of a\n    non-base64 character being encountered; only a count of bytes written\n    to dst."},"files":[{"filename":"src\/hotspot\/share\/opto\/runtime.cpp"}],"sha":"c1f6233b6c45bdb330ba081c47a3132a0832d648"},{"commit":{"message":"TestBase64.java: Change comment as per Martin Doerr's v2 review"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java"}],"sha":"c2942b3b862877f66dde6c7c4fd5050637fc8e2b"},{"commit":{"message":"Base64.java: Make changes as per Roger Riggs and Martin Doerr's v2 Review\n\n  * Make comment about the sl parameter more precise\n  * Fix comparison to avoid possible integer overflow of sp"},"files":[{"filename":"src\/java.base\/share\/classes\/java\/util\/Base64.java"}],"sha":"1192a554478b5fa28a939f8860501fbf77b36944"},{"commit":{"message":"library_call.cpp: Fix rebase merge error"},"files":[{"filename":"src\/hotspot\/share\/opto\/library_call.cpp"}],"sha":"7711d7df64569fd053c638101bc8c016cbfdc022"},{"commit":{"message":"AOT: Revert change to aotCodeHeap.cpp for decodeBlock\n\nDon't add the SET_AOT_GLOBAL_SYMBOL_VALUE macro for decode block until all\narches that implement AOT, implement the decodeBlock intrinsic."},"files":[],"sha":"e42ac7db389a2071ddde071626aa279e5883bd70"},{"commit":{"message":"Base64.java decodeBlock: Changes from PR review\n\n * Make comparison safer and consistent with the while loop\n * Update comment about the decodeBlock intrinsic so that it matches the new structure\n * Add comment about the lack of a length check on the destination buffer\n * As per issue 8138732, change HotSpotIntrinsicCandidate to IntrinsicCandidate"},"files":[{"filename":"src\/java.base\/share\/classes\/java\/util\/Base64.java"}],"sha":"5574336effaa6ffca4a6545f05ffec8bc1a18aa7"},{"commit":{"message":"stubGenerator_ppc.cpp: Changes from PR review\n\n * Fix clearing of upper bits to clear 32 bits instead of 31 (due to misreading of clrldi instruction)\n * change and document loop_unrolls setting from 8 to 2 after re-running the benchmark\n * align unrolled loop on a 32-byte boundary\n * replace instruction used for checking isURL from a double word to single\n   word instruction since the register is effectively 32 bits wide\n * cosmetic change to realign register comments."},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"}],"sha":"85d7ddbf9eb9e4698d58219495aae969c762ba39"},{"commit":{"message":"TestBase64.java: Changes from PR review\n\n * Use Utils.toByteArrays() method instead of a locally-defined method\n * Generate the two non-Base64 tables dynamically rather than use static initialization\n * Added comments describing the two above-mentioned arrays"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java"}],"sha":"853ec00e2b6dff2be3f6a781763c5e908f547274"},{"commit":{"message":"Expand the Base64 intrinsic regression test to cover decodeBlock\n\nThis patch makes four significant changes:\n\n1) The Power implementation of the decodeBlock intrinsic, at least,\nrequires a decode length of at least 128 bytes, but the existing test cases\nare much shorter, maxing out at 111 bytes.  So the patch adds a new input\ndata file which has longer test cases in it.\n\n2) The original test cases only covers the encoding of just the printable\nsubset of the 7-bit ASCII characters.  However, Base64 encoding requires\nbeing able to encode arbitrary binary data, i.e. it must handle all 256\n8-bit byte encodings.  To remedy this, but keep the original line-oriented\nstyle of the input data, I added another input file type that uses a simple\nASCII hexadecimal encoding - two ASCII hex characters per 8-bit byte.  When\ntest0 is called, a new parameter is passed that specifies the type of the\ninput file, which is either the original ASCII type or the hexadecimal\nformat.  So to test both longer input data and arbitrary 8-bit data, the\nnewly added input test file has test cases which are both longer and\nencoded in ASCII hex so as to give full 8-bit capability.  When reading\nthis type of file, test0 calls a newly-added function to translate the\nASCII hex to binary data.  Except for the first line of input data, which\ncontains all possible 8-bit values sequentially, the input data was\ngenerated using a random length (between 111 and 520 bytes) buffer filled\nwith random 8-bit data, which should give adequate coverage.\n\n3) The original test did not test that the decoder detects illegal Base64\nbytes.  This change chooses a random location in the encoded data to\ncorrupt with a randomly-chosen byte which is illegal for the specific\nBase64 encoding that is chosen (i.e. standard or URLsafe).  It then calls\nthe decode function to verify that the illegal byte is detected and the\nproper exception is thrown.\n\n4) The test iteration count was originally 100K, but that is far more than\nenough iterations to test the intrinsic.  It takes 20K iterations on each\ninstrinsic for HotSpot C2 to begin calling it.  The test originally had\nthree types of encodings to test and called the encode intrinsic four times\nfor each iteration, which works out to 100K * 3 * 4 = 1.2M calls just to\nencode.  Decode was called four times as well (now five because of the\nillegal byte test).  I believe this is excessive and with the extra test\ndata I have added, the test was timing out after ten minutes of execution.\nIt appears that it is timing out, not because the intrinsics take a long\ntime to run, but because test0 generates an enormous number of discarded\ndata buffers for the GC system to recover (the test runs at about 39GB of\nvirtual memory on my test machine).  To remedy the timeout problem, I have\nchanged the code so that a warmup function of 20K repetitions is performed\non a fixed buffer, to activate the instrinsic(s).  After the warmup, I have\nreduced the number of iterations to 5K on each test0 call.  This should\ngive adequate coverage."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/longLineBaseEncode.txt"},{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/longLineHEX.txt"},{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/longLineMimeEncode.txt"},{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/longLineUrlEncode.txt"}],"sha":"cd2bfb684c6457ae5c32a9b808286a29ad117272"},{"commit":{"message":"Add JMH benchmark for Base64 variable length buffer decoding"},"files":[{"filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64VarLenDecode.java"}],"sha":"7fea4e09877934fa473644e5b24d3b29637f20fc"},{"commit":{"message":"Add Power9+ intrinsic implementation for Base64 decoding"},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp"},{"filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp"},{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp"}],"sha":"cb74946a725502027482936ee56e9ab36561d753"},{"commit":{"message":"Add HotSpot code to implement Base64 decodeBlock API"},"files":[{"filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp"},{"filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp"},{"filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp"},{"filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp"},{"filename":"src\/hotspot\/share\/opto\/c2compiler.cpp"},{"filename":"src\/hotspot\/share\/opto\/escape.cpp"},{"filename":"src\/hotspot\/share\/opto\/library_call.cpp"},{"filename":"src\/hotspot\/share\/opto\/runtime.cpp"},{"filename":"src\/hotspot\/share\/opto\/runtime.hpp"},{"filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp"},{"filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp"},{"filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp"}],"sha":"755f1ff166000cb471bc1d0e4f8b496dd74e1fa8"},{"commit":{"message":"Add HotSpotIntrinsicCandidate and API for Base64 decoding"},"files":[{"filename":"src\/java.base\/share\/classes\/java\/util\/Base64.java"}],"sha":"d4733affefca2f81ba86432c3261d68517c3dfdc"}]