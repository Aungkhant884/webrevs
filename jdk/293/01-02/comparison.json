{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2020, SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n@@ -3660,1 +3660,1 @@\n-    \/\/ (min, avg, max) = (101097.676, 101611.387, 101838.460), stdev = 182.156\n+    \/\/ (min, avg, max) = (102011.070, 103007.654, 103385.576), stdev = 274.914\n@@ -3662,1 +3662,1 @@\n-    \/\/ (min, avg, max) = (106430.268, 106717.050, 106977.072), stdev = 171.667\n+    \/\/ (min, avg, max) = (105869.171, 106268.478, 106641.559), stdev = 240.833\n@@ -3664,1 +3664,1 @@\n-    \/\/ (min, avg, max) = (105342.240, 106084.930, 106390.059), stdev = 264.617\n+    \/\/ (min, avg, max) = (96981.562, 107306.291, 108382.325), stdev = 2720.824\n@@ -3666,1 +3666,3 @@\n-    \/\/ min, avg, max) = (105790.841, 106318.585, 106602.132), stdev = 243.740\n+    \/\/ (min, avg, max) = (107385.501, 108192.973, 108580.890), stdev = 304.418\n+    \/\/ loop_unrolls = 16 :\n+    \/\/ (min, avg, max) = (108151.519, 108408.000, 108636.058), stdev = 139.843\n@@ -3668,4 +3670,7 @@\n-    \/\/ Given that the performance is about 5% better at 2, and that there's\n-    \/\/ an advantage to keeping loop_unrolls small (to be able to process\n-    \/\/ smaller buffers), 2 is clearly the best choice.\n-    const unsigned loop_unrolls = 2;\n+    \/\/ Comparing only the max values, there's a clear bend in the curve at 4.\n+    \/\/ The performance goes up slightly at 8, but is essentially flat at\n+    \/\/ 16.  Since it's desirable to have a loop_unrolls value on the\n+    \/\/ smaller side to help have smaller buffers be able to take advantage\n+    \/\/ of the decodeBlock intrinsic, the value 4 was chosen, which gives a\n+    \/\/ minimum src buffer size of 64 bytes.\n+    const unsigned loop_unrolls = 4;\n@@ -3675,1 +3680,1 @@\n-    const unsigned block_size_clear = exact_log2(block_size); \/\/ the lower log2(block_size) bits of the size\n+    const unsigned block_size_shift = exact_log2(block_size);\n@@ -3692,1 +3697,0 @@\n-    Register end           = R11; \/\/ pointer to the last byte of the source\n@@ -3796,2 +3800,2 @@\n-    \/\/ result of this subtraction implies that the non-instrinsic routine\n-    \/\/ will be used to process the last 12 characters.\n+    \/\/ result of this subtraction implies that a Java function in the\n+    \/\/ Base64 class will be used to process the last 12 characters.\n@@ -3800,3 +3804,4 @@\n-\n-    \/\/ Round sl down to the nearest multiple of block_size\n-    __ clrrdi(sl, sl, block_size_clear);\n+    \/\/ Load CTR with the number of passes through the unrolled loop\n+    \/\/ = sl >> block_size_shift\n+    __ srawi(sl, sl, block_size_shift);\n+    __ mtctr(sl);\n@@ -3810,8 +3815,0 @@\n-    \/\/ Address of the last byte of the source is (in + sl - 1)\n-    __ add(end, in, sl);\n-    __ subi(end, end, 1);\n-\n-    __ bind(unrolled_loop_start);\n-\n-    __ cmpd(CCR0, end, in);\n-    __ blt_predict_not_taken(CCR0, unrolled_loop_exit);\n@@ -3819,0 +3816,1 @@\n+    __ bind(unrolled_loop_start);\n@@ -3836,1 +3834,1 @@\n-        \/\/ Find out which elemets are the special case character (isURL ? '\/' : '-')\n+        \/\/ Find out which elements are the special case character (isURL ? '\/' : '-')\n@@ -3979,1 +3977,1 @@\n-    __ b(unrolled_loop_start);\n+    __ bdnz(unrolled_loop_start);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":24,"deletions":26,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-      FLAG_SET_DEFAULT(UseCharacterCompareIntrinsics, false);\n+      FLAG_SET_DEFAULT(UseBASE64Intrinsics, false);\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -491,1 +491,0 @@\n-  case vmIntrinsics::_base64_decodeBlock:\n@@ -493,0 +492,1 @@\n+  case vmIntrinsics::_base64_decodeBlock:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -310,1 +310,0 @@\n-  bool inline_sha_implCompress(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1211,1 +1211,1 @@\n-  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ dst ofs, or -1\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ count of bytes written to dst\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -775,1 +775,1 @@\n-         *         the total length of source array\n+         *         the offset (exclusive) past the last byte to be converted.\n@@ -812,1 +812,1 @@\n-                if (shiftto == 18 && sp + 4 < sl) {       \/\/ fast path\n+                if (shiftto == 18 && sp < sl - 4) {       \/\/ fast path\n","filename":"src\/java.base\/share\/classes\/java\/util\/Base64.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,2 @@\n-        \/\/ This should be enough to get both the decoder and encoder intrinsic loaded up and running.\n+        \/\/ This should be enough to get both encodeBlock() and\n+        \/\/ decodeBlock() compiled on the highest tier.\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}