[{"commit":{"message":"Expand the Base64 intrinsic regression test to cover decodeBlock\n\nThis patch makes four significant changes:\n\n1) The Power implementation of the decodeBlock intrinsic, at least,\nrequires a decode length of at least 128 bytes, but the existing test cases\nare much shorter, maxing out at 111 bytes.  So the patch adds a new input\ndata file which has longer test cases in it.\n\n2) The original test cases only covers the encoding of just the printable\nsubset of the 7-bit ASCII characters.  However, Base64 encoding requires\nbeing able to encode arbitrary binary data, i.e. it must handle all 256\n8-bit byte encodings.  To remedy this, but keep the original line-oriented\nstyle of the input data, I added another input file type that uses a simple\nASCII hexadecimal encoding - two ASCII hex characters per 8-bit byte.  When\ntest0 is called, a new parameter is passed that specifies the type of the\ninput file, which is either the original ASCII type or the hexadecimal\nformat.  So to test both longer input data and arbitrary 8-bit data, the\nnewly added input test file has test cases which are both longer and\nencoded in ASCII hex so as to give full 8-bit capability.  When reading\nthis type of file, test0 calls a newly-added function to translate the\nASCII hex to binary data.  Except for the first line of input data, which\ncontains all possible 8-bit values sequentially, the input data was\ngenerated using a random length (between 111 and 520 bytes) buffer filled\nwith random 8-bit data, which should give adequate coverage.\n\n3) The original test did not test that the decoder detects illegal Base64\nbytes.  This change chooses a random location in the encoded data to\ncorrupt with a randomly-chosen byte which is illegal for the specific\nBase64 encoding that is chosen (i.e. standard or URLsafe).  It then calls\nthe decode function to verify that the illegal byte is detected and the\nproper exception is thrown.\n\n4) The test iteration count was originally 100K, but that is far more than\nenough iterations to test the intrinsic.  It takes 20K iterations on each\ninstrinsic for HotSpot C2 to begin calling it.  The test originally had\nthree types of encodings to test and called the encode intrinsic four times\nfor each iteration, which works out to 100K * 3 * 4 = 1.2M calls just to\nencode.  Decode was called four times as well (now five because of the\nillegal byte test).  I believe this is excessive and with the extra test\ndata I have added, the test was timing out after ten minutes of execution.\nIt appears that it is timing out, not because the intrinsics take a long\ntime to run, but because test0 generates an enormous number of discarded\ndata buffers for the GC system to recover (the test runs at about 39GB of\nvirtual memory on my test machine).  To remedy the timeout problem, I have\nchanged the code so that a warmup function of 20K repetitions is performed\non a fixed buffer, to activate the instrinsic(s).  After the warmup, I have\nreduced the number of iterations to 5K on each test0 call.  This should\ngive adequate coverage."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/longLineBaseEncode.txt"},{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/longLineHEX.txt"},{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/longLineMimeEncode.txt"},{"filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/longLineUrlEncode.txt"}],"sha":"8b6d979ae366b7876afd9d33bca227a594b2ff29"},{"commit":{"message":"Add JMH benchmark for Base64 variable length buffer decoding"},"files":[{"filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64VarLenDecode.java"}],"sha":"282cee469e1c49879756232964e091f7f7691ed9"},{"commit":{"message":"Add Power9+ intrinsic implementation for Base64 decoding"},"files":[{"filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp"},{"filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp"},{"filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp"}],"sha":"3f9c07e92faf4e14d5d7f544429c6e430e8817b2"},{"commit":{"message":"Add HotSpot code to implement Base64 decodeBlock API"},"files":[{"filename":"src\/hotspot\/share\/aot\/aotCodeHeap.cpp"},{"filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp"},{"filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp"},{"filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp"},{"filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp"},{"filename":"src\/hotspot\/share\/opto\/c2compiler.cpp"},{"filename":"src\/hotspot\/share\/opto\/escape.cpp"},{"filename":"src\/hotspot\/share\/opto\/library_call.cpp"},{"filename":"src\/hotspot\/share\/opto\/runtime.cpp"},{"filename":"src\/hotspot\/share\/opto\/runtime.hpp"},{"filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp"},{"filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp"},{"filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp"}],"sha":"b0bd35574c20806f558402b41776085504da70da"},{"commit":{"message":"Add HotSpotIntrinsicCandidate and API for Base64 decoding"},"files":[{"filename":"src\/java.base\/share\/classes\/java\/util\/Base64.java"}],"sha":"3bdebef47cc7fe3b93ee8667ee5b3f1aa5a87f19"}]