{"files":[{"patch":"@@ -341,0 +341,1 @@\n+    MCRXRX_OPCODE = (31u << OPCODE_SHIFT | 576u << 1),\n@@ -1692,0 +1693,1 @@\n+  inline void mcrxrx(ConditionRegister cra);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -381,0 +381,3 @@\n+\/\/ Introduced in Power 9:\n+inline void Assembler::mcrxrx(ConditionRegister cra)\n+                                                  { emit_int32(MCRXRX_OPCODE | bf(cra)); }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3736,1 +3736,1 @@\n-    Label not_URL, calculate_size, unrolled_loop_start, skip_xxsel[loop_unrolls], unrolled_loop_exit;\n+    Label not_URL, calculate_size, unrolled_loop_start, skip_xxsel[loop_unrolls], unrolled_loop_exit, return_zero;\n@@ -3742,1 +3742,24 @@\n-    __ clrldi(dp, dp, 32);\n+\n+    \/\/ Don't handle the last 4 characters of the source, because this\n+    \/\/ VSX-based algorithm doesn't handle padding characters.  Also the\n+    \/\/ vector code will always write 16 bytes of decoded data on each pass,\n+    \/\/ but only the first 12 of those 16 bytes are valid data (16 base64\n+    \/\/ characters become 12 bytes of binary data), so for this reason we\n+    \/\/ need to subtract an additional 8 bytes from the source length, in\n+    \/\/ order not to write past the end of the destination buffer.  The\n+    \/\/ result of this subtraction implies that a Java function in the\n+    \/\/ Base64 class will be used to process the last 12 characters.\n+    __ sub(sl, sl, sp);\n+    __ subi(sl, sl, 12);\n+\n+    \/\/ Load CTR with the number of passes through the unrolled loop\n+    \/\/ = sl >> block_size_shift.  After the shift, if sl == 0, there's too\n+    \/\/ little data to be processed by this intrinsic.\n+    __ srawi_(sl, sl, block_size_shift);\n+    __ beq_predict_not_taken(CCR0, return_zero);\n+    \/\/ if sl was less than zero before the shift, XER CA will be set to 1\n+    __ mcrxrx(CCR2); \/\/ moves XER's OV, OV32, CA, CA32 to CCR2's LT, GT, EQ, SO bits, respectively.\n+    __ beq_predict_not_taken(CCR2, return_zero);\n+    __ mtctr(sl);\n+\n+    \/\/ Clear the other two parameter registers upper 32 bits.\n@@ -3744,0 +3767,1 @@\n+    __ clrldi(dp, dp, 32);\n@@ -3793,12 +3817,0 @@\n-    \/\/ Don't handle the last 4 characters of the source, because this\n-    \/\/ VSX-based algorithm doesn't handle padding characters.  Also the\n-    \/\/ vector code will always write 16 bytes of decoded data on each pass,\n-    \/\/ but only the first 12 of those 16 bytes are valid data (16 base64\n-    \/\/ characters become 12 bytes of binary data), so for this reason we\n-    \/\/ need to subtract an additional 8 bytes from the source length, in\n-    \/\/ order not to write past the end of the destination buffer.  The\n-    \/\/ result of this subtraction implies that a Java function in the\n-    \/\/ Base64 class will be used to process the last 12 characters.\n-    __ sub(sl, sl, sp);\n-    __ subi(sl, sl, 12);\n-\n@@ -3811,7 +3823,0 @@\n-    \/\/ Load CTR with the number of passes through the unrolled loop\n-    \/\/ = sl >> block_size_shift.  After the shift, if sl == 0, there's too\n-    \/\/ little data to be processed by this intrinsic.\n-    __ srawi_(sl, sl, block_size_shift);\n-    __ beq_predict_not_taken(CCR0, unrolled_loop_exit);\n-    __ mtctr(sl);\n-\n@@ -3990,0 +3995,4 @@\n+    __ bind(return_zero);\n+    __ li(R3_RET, 0);\n+    __ blr();\n+\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"}]}