{"files":[{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4512215 4818420 4819436\n- * @summary Updated currency data.\n- * @run junit Bug4512215\n- *\/\n-\n-import java.util.Currency;\n-import java.util.Locale;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-public class Bug4512215 {\n-\n-    \/**\n-     * Tests that the given country has the expected currency code from\n-     * calling getCurrencyCode().\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"twoDigitDecimals\")\n-    public void currencyCountryTest(String currencyCode, int digits, String country) {\n-        \/\/ digits parameter is not used, exists so that data provider can\n-        \/\/ be shared among multiple tests\n-        Currency currency = Currency.getInstance(Locale.of(\"\", country));\n-        assertEquals(currency.getCurrencyCode(), currencyCode, String.format(\n-                \"[%s] expected %s; got: %s\", country, currencyCode, currency.getCurrencyCode()));\n-    }\n-\n-    \/**\n-     * Tests that the given currencyCode has the expected number of\n-     * decimal digits from calling getDefaultFractionDigits().\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource({\"twoDigitDecimals\", \"nonTwoDigitDecimals\"})\n-    public void currencyDefinedTest(String currencyCode, int digits) {\n-        Currency currency = Currency.getInstance(currencyCode);\n-        assertEquals(currency.getDefaultFractionDigits(), digits, String.format(\n-                \"[%s] expected: %s; got: %s\", currencyCode, digits, currency.getDefaultFractionDigits()));\n-    }\n-\n-    private static Stream<Arguments> twoDigitDecimals() {\n-        return Stream.of(\n-                Arguments.of(\"TJS\", 2, \"TJ\"),\n-                Arguments.of(\"DKK\", 2, \"FO\"),\n-                Arguments.of(\"FKP\", 2, \"FK\"),\n-                Arguments.of(\"AFN\", 2, \"AF\"), \/\/ changed from \"AFA\"\n-                \/\/ Newsletter V-5 on ISO 3166-1 (2002-05-20)\n-                Arguments.of(\"USD\", 2, \"TL\"), \/\/ successor to TP\/TPE\n-                \/\/ Newsletter V-8 on ISO 3166-1 (2003-07-23)\n-                Arguments.of(\"CSD\", 2, \"CS\") \/\/ successor to YU\/YUM\n-        );\n-    }\n-\n-    private static Stream<Arguments> nonTwoDigitDecimals() {\n-        return Stream.of(\n-                Arguments.of(\"XBD\", -1),\n-                Arguments.of(\"XAG\", -1),\n-                Arguments.of(\"XAU\", -1),\n-                Arguments.of(\"XBA\", -1),\n-                Arguments.of(\"XBB\", -1)\n-        );\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Currency\/Bug4512215.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4512215 4818420 4819436 8310923\n+ * @summary Test some minor undefined currencies.\n+ * @run junit MinorUndefinedCodes\n+ *\/\n+\n+import java.util.Currency;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class MinorUndefinedCodes {\n+\n+    \/**\n+     * Spot check some minor undefined codes and ensure their default fraction\n+     * digits are not 2.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"minorUndefined\")\n+    public void checkFractionDigits(String currencyCode, int digits) {\n+        Currency currency = Currency.getInstance(currencyCode);\n+        assertEquals(currency.getCurrencyCode(), currencyCode);\n+        assertEquals(currency.getDefaultFractionDigits(), digits, String.format(\n+                \"[%s] expected: %s; got: %s\", currencyCode, digits, currency.getDefaultFractionDigits()));\n+    }\n+\n+    private static Stream<Arguments> minorUndefined() {\n+        return Stream.of(\n+                Arguments.of(\"XBD\", -1),\n+                Arguments.of(\"XAG\", -1),\n+                Arguments.of(\"XAU\", -1),\n+                Arguments.of(\"XBA\", -1),\n+                Arguments.of(\"XBB\", -1)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Currency\/MinorUndefinedCodes.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -31,0 +32,1 @@\n+ * @run junit ValidateISO4217\n@@ -33,21 +35,34 @@\n-\/*\n- * ############################################################################\n- *\n- *  ValidateISO4217 is a tool to detect differences between the latest ISO 4217\n- *  data and Java's currency data which is based on ISO 4217.\n- *  If there is a difference, the following file which includes currency data\n- *  may need to be updated.\n- *      src\/share\/classes\/java\/util\/CurrencyData.properties\n- *\n- * ############################################################################\n- *\n- * 1) Make a golden-data file.\n- *      From BSi's ISO4217 data (TABLE A1.doc), extract four (or eight, if currency is changing)\n- *      fields and save as .\/tablea1.txt.\n- *        <Country code>\\t<Currency code>\\t<Numeric code>\\t<Minor unit>[\\t<Cutover Date>\\t<new Currency code>\\t<new Numeric code>\\t<new Minor unit>]\n- *      The Cutover Date is given in SimpleDateFormat's 'yyyy-MM-dd-HH-mm-ss' format in the GMT time zone.\n- *\n- * 2) Compile ValidateISO4217.java\n- *\n- * 3) Execute ValidateISO4217 as follows:\n- *      java ValidateISO4217\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Currency;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+import java.util.TimeZone;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * This class tests the latest ISO 4217 data and Java's currency data which is\n+ * based on ISO 4217. The golden-data file (ISO 4217 data) 'tablea1.txt' has the following\n+ * format: <Country code>\\t<Currency code>\\t<Numeric code>\\t<Minor unit>[\\t<Cutover Date>\\t<new Currency code>\\t<new Numeric code>\\t<new Minor unit>]\n+ * The Cutover Date is given in SimpleDateFormat's 'yyyy-MM-dd-HH-mm-ss' format in the GMT time zone.\n@@ -55,5 +70,0 @@\n-\n-import java.io.*;\n-import java.text.*;\n-import java.util.*;\n-\n@@ -62,59 +72,28 @@\n-    static final int ALPHA_NUM = 26;\n-\n-    static final byte UNDEFINED = 0;\n-    static final byte DEFINED = 1;\n-    static final byte SKIPPED = 2;\n-\n-    \/* input files *\/\n-    static final String datafile = \"tablea1.txt\";\n-\n-    \/* alpha2-code table *\/\n-    static byte[] codes = new byte[ALPHA_NUM * ALPHA_NUM];\n-\n-    static final String[][] additionalCodes = {\n-        \/* Defined in ISO 4217 list, but don't have code and minor unit info. *\/\n-        {\"AQ\", \"\", \"\", \"0\"},    \/\/ Antarctica\n-\n-        \/*\n-         * Defined in ISO 4217 list, but don't have code and minor unit info in\n-         * it. On the other hand, both code and minor unit are defined in\n-         * .properties file. I don't know why, though.\n-         *\/\n-        {\"GS\", \"GBP\", \"826\", \"2\"},      \/\/ South Georgia And The South Sandwich Islands\n-\n-        \/* Not defined in ISO 4217 list, but defined in .properties file. *\/\n-        {\"AX\", \"EUR\", \"978\", \"2\"},      \/\/ \\u00c5LAND ISLANDS\n-        {\"PS\", \"ILS\", \"376\", \"2\"},      \/\/ Palestinian Territory, Occupied\n-\n-        \/* Not defined in ISO 4217 list, but added in ISO 3166 country code list *\/\n-        {\"JE\", \"GBP\", \"826\", \"2\"},      \/\/ Jersey\n-        {\"GG\", \"GBP\", \"826\", \"2\"},      \/\/ Guernsey\n-        {\"IM\", \"GBP\", \"826\", \"2\"},      \/\/ Isle of Man\n-        {\"BL\", \"EUR\", \"978\", \"2\"},      \/\/ Saint Barthelemy\n-        {\"MF\", \"EUR\", \"978\", \"2\"},      \/\/ Saint Martin\n-\n-        \/* Defined neither in ISO 4217 nor ISO 3166 list *\/\n-        {\"XK\", \"EUR\", \"978\", \"2\"},      \/\/ Kosovo\n-    };\n-\n-    \/* Codes that are obsolete, do not have related country, extra currency *\/\n-    static final String otherCodes =\n-        \"ADP-AFA-ATS-AYM-AZM-BEF-BGL-BOV-BYB-BYR-CHE-CHW-CLF-COU-CUC-CYP-\"\n-        + \"DEM-EEK-ESP-FIM-FRF-GHC-GRD-GWP-IEP-ITL-LTL-LUF-LVL-MGF-MRO-MTL-MXV-MZM-NLG-\"\n-        + \"PTE-ROL-RUR-SDD-SIT-SLL-SKK-SRG-STD-TMM-TPE-TRL-VEF-UYI-USN-USS-VEB-VED-\"\n-        + \"XAG-XAU-XBA-XBB-XBC-XBD-XDR-XFO-XFU-XPD-XPT-XSU-XTS-XUA-XXX-\"\n-        + \"YUM-ZMK-ZWD-ZWN-ZWR\";\n-\n-    static boolean err = false;\n-\n-    static Set<Currency> testCurrencies = new HashSet<Currency>();\n-\n-    public static void main(String[] args) throws Exception {\n-        CheckDataVersion.check();\n-        test1();\n-        test2();\n-        getAvailableCurrenciesTest();\n-\n-        if (err) {\n-            throw new RuntimeException(\"Failed: Validation ISO 4217 data\");\n-        }\n+    \/\/ Input golden-data file\n+    private static final File dataFile = new File(System.getProperty(\n+            \"test.src\", \".\"), \"tablea1.txt\");\n+    \/\/ Code statuses\n+    private static final byte UNDEFINED = 0;\n+    private static final byte DEFINED = 1;\n+    private static final byte SKIPPED = 2;\n+    private static final byte TESTED = 4;\n+    private static final int ALPHA_NUM = 26;\n+    \/\/ An alpha2 code table which maps the status of a country\n+    private static final byte[] codes = new byte[ALPHA_NUM * ALPHA_NUM];\n+    \/\/ Codes derived from ISO4217 golden-data file\n+    private static final List<Arguments> ISO4217Codes = new ArrayList<Arguments>();\n+    \/\/ Additional codes not from the ISO4217 golden-data file\n+    private static final List<Arguments> additionalCodes = new ArrayList<Arguments>();\n+    \/\/ Currencies to test (derived from ISO4217Codes and additionalCodes)\n+    private static final Set<Currency> testCurrencies = new HashSet<>();\n+    private static SimpleDateFormat format = null;\n+\n+    \/\/ Sets up the following test data:\n+    \/\/ ISO4217Codes, additionalCodes, testCurrencies, codes\n+    @BeforeAll\n+    static void setUpTestingData() throws Exception {\n+        \/\/ These functions laterally setup 'testCurrencies' and 'codes'\n+        \/\/ at the same time\n+        setUpISO4217Codes();\n+        setUpAdditionalCodes();\n+        finishTestCurrencies();\n@@ -123,3 +102,3 @@\n-    static void test1() throws Exception {\n-\n-        try (FileReader fr = new FileReader(new File(System.getProperty(\"test.src\", \".\"), datafile));\n+    \/\/ Parse the ISO4217 file and populate ISO4217Codes and testCurrencies.\n+    private static void setUpISO4217Codes() throws Exception{\n+        try (FileReader fr = new FileReader(dataFile);\n@@ -129,2 +108,0 @@\n-            SimpleDateFormat format = null;\n-\n@@ -133,0 +110,1 @@\n+                    \/\/ Skip comments and empty lines\n@@ -135,1 +113,0 @@\n-\n@@ -139,0 +116,1 @@\n+                    \/\/ Skip invalid countries\n@@ -141,0 +119,5 @@\n+                \/\/ If the country is valid, process the additional columns\n+                processColumns(tokens, country);\n+            }\n+        }\n+    }\n@@ -142,9 +125,23 @@\n-                String currency;\n-                String numeric;\n-                String minorUnit;\n-                int tokensCount = tokens.countTokens();\n-                if (tokensCount < 3) {\n-                    currency = \"\";\n-                    numeric = \"0\";\n-                    minorUnit = \"0\";\n-                } else {\n+    private static void processColumns(StringTokenizer tokens, String country) throws ParseException {\n+        String currency;\n+        String numeric;\n+        String minorUnit;\n+        int tokensCount = tokens.countTokens();\n+        if (tokensCount < 3) {\n+            \/\/ Ill-defined columns\n+            currency = \"\";\n+            numeric = \"0\";\n+            minorUnit = \"0\";\n+        } else {\n+            \/\/ Fully defined columns\n+            currency = tokens.nextToken();\n+            numeric = tokens.nextToken();\n+            minorUnit = tokens.nextToken();\n+            testCurrencies.add(Currency.getInstance(currency));\n+            \/\/ Check for the cut-over if a currency is changing\n+            if (tokensCount > 3) {\n+                if (format == null) {\n+                    createDateFormat();\n+                }\n+                \/\/ If the cut-over already passed, test the changed data too\n+                if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n@@ -155,16 +152,0 @@\n-\n-                    \/\/ check for the cutover\n-                    if (tokensCount > 3) {\n-                        if (format == null) {\n-                            format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n-                            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-                            format.setLenient(false);\n-                        }\n-                        if (format.parse(tokens.nextToken()).getTime() <\n-                            System.currentTimeMillis()) {\n-                            currency = tokens.nextToken();\n-                            numeric = tokens.nextToken();\n-                            minorUnit = tokens.nextToken();\n-                            testCurrencies.add(Currency.getInstance(currency));\n-                        }\n-                    }\n@@ -172,3 +153,0 @@\n-                int index = toIndex(country);\n-                testCountryCurrency(country, currency, Integer.parseInt(numeric),\n-                    Integer.parseInt(minorUnit), index);\n@@ -177,0 +155,10 @@\n+        int index = toIndex(country);\n+        ISO4217Codes.add(Arguments.of(country, currency, Integer.parseInt(numeric),\n+                Integer.parseInt(minorUnit), index));\n+        codes[index] = DEFINED;\n+    }\n+\n+    \/\/ Generates a unique index for an alpha-2 country\n+    private static int toIndex(String country) {\n+        return ((country.charAt(0) - 'A') * ALPHA_NUM + country.charAt(1) - 'A');\n+    }\n@@ -178,7 +166,36 @@\n-        for (int i = 0; i < additionalCodes.length; i++) {\n-            int index = toIndex(additionalCodes[i][0]);\n-            if (additionalCodes[i][1].length() != 0) {\n-                testCountryCurrency(additionalCodes[i][0], additionalCodes[i][1],\n-                    Integer.parseInt(additionalCodes[i][2]),\n-                    Integer.parseInt(additionalCodes[i][3]), index);\n-                testCurrencies.add(Currency.getInstance(additionalCodes[i][1]));\n+    private static void createDateFormat() {\n+        format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n+        format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+        format.setLenient(false);\n+    }\n+\n+    \/\/ Process 'extraCodes', turning them into JUnit arguments and populate\n+    \/\/ both additionalCodes and testCurrencies.\n+    private static void setUpAdditionalCodes() {\n+        String[][] extraCodes = {\n+                \/* Defined in ISO 4217 list, but don't have code and minor unit info. *\/\n+                {\"AQ\", \"\", \"\", \"0\"},    \/\/ Antarctica\n+                \/*\n+                 * Defined in ISO 4217 list, but don't have code and minor unit info in\n+                 * it. On the other hand, both code and minor unit are defined in\n+                 * .properties file. I don't know why, though.\n+                 *\/\n+                {\"GS\", \"GBP\", \"826\", \"2\"},      \/\/ South Georgia And The South Sandwich Islands\n+                \/* Not defined in ISO 4217 list, but defined in .properties file. *\/\n+                {\"AX\", \"EUR\", \"978\", \"2\"},      \/\/ \\u00c5LAND ISLANDS\n+                {\"PS\", \"ILS\", \"376\", \"2\"},      \/\/ Palestinian Territory, Occupied\n+                \/* Not defined in ISO 4217 list, but added in ISO 3166 country code list *\/\n+                {\"JE\", \"GBP\", \"826\", \"2\"},      \/\/ Jersey\n+                {\"GG\", \"GBP\", \"826\", \"2\"},      \/\/ Guernsey\n+                {\"IM\", \"GBP\", \"826\", \"2\"},      \/\/ Isle of Man\n+                {\"BL\", \"EUR\", \"978\", \"2\"},      \/\/ Saint Barthelemy\n+                {\"MF\", \"EUR\", \"978\", \"2\"},      \/\/ Saint Martin\n+                \/* Defined neither in ISO 4217 nor ISO 3166 list *\/\n+                {\"XK\", \"EUR\", \"978\", \"2\"},      \/\/ Kosovo\n+        };\n+        for (String[] extraCode : extraCodes) {\n+            int index = toIndex(extraCode[0]);\n+            if (extraCode[1].length() != 0) {\n+                additionalCodes.add(Arguments.of(extraCode[0], extraCode[1],\n+                        Integer.parseInt(extraCode[2]), Integer.parseInt(extraCode[3]), index));\n+                testCurrencies.add(Currency.getInstance(extraCode[1]));\n@@ -186,1 +203,1 @@\n-                codes[index] = SKIPPED;\n+                codes[index] = SKIPPED; \/\/ For example, Antarctica\n@@ -191,2 +208,15 @@\n-    static int toIndex(String s) {\n-        return ((s.charAt(0) - 'A') * ALPHA_NUM + s.charAt(1) - 'A');\n+    \/\/ The previous set-up method populated most of testCurrencies. This\n+    \/\/ method finishes populating the list with 'otherCodes'.\n+    private static void finishTestCurrencies() {\n+        \/\/ Codes that are obsolete, do not have related country, extra currency\n+        final String otherCodes =\n+                \"ADP-AFA-ATS-AYM-AZM-BEF-BGL-BOV-BYB-BYR-CHE-CHW-CLF-COU-CUC-CYP-\"\n+                        + \"DEM-EEK-ESP-FIM-FRF-GHC-GRD-GWP-IEP-ITL-LTL-LUF-LVL-MGF-MRO-MTL-MXV-MZM-NLG-\"\n+                        + \"PTE-ROL-RUR-SDD-SIT-SLL-SKK-SRG-STD-TMM-TPE-TRL-VEF-UYI-USN-USS-VEB-VED-\"\n+                        + \"XAG-XAU-XBA-XBB-XBC-XBD-XDR-XFO-XFU-XPD-XPT-XSU-XTS-XUA-XXX-\"\n+                        + \"YUM-ZMK-ZWD-ZWN-ZWR\";\n+        \/\/ Add otherCodes\n+        StringTokenizer st = new StringTokenizer(otherCodes, \"-\");\n+        while (st.hasMoreTokens()) {\n+            testCurrencies.add(Currency.getInstance(st.nextToken()));\n+        }\n@@ -195,6 +225,14 @@\n-    static void testCountryCurrency(String country, String currencyCode,\n-                                int numericCode, int digits, int index) {\n-        if (currencyCode.length() == 0) {\n-            return;\n-        }\n-        testCurrencyDefined(currencyCode, numericCode, digits);\n+    \/**\n+     * Tests the JDK's ISO4217 data and ensures the values for getNumericCode(),\n+     * getDefaultFractionDigits(), and getCurrencyCode() are as expected.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource({\"ISO4217CodesProvider\", \"additionalCodesProvider\"})\n+    public void countryCurrencyTest(String country, String currencyCode,\n+                                    int numericCode, int digits, int index) {\n+        currencyTest(currencyCode, numericCode, digits);\n+        countryTest(country, currencyCode);\n+        assertNotEquals(codes[index], TESTED,\n+                \"Error: Re-testing a previously defined code, possible duplication\");\n+        codes[index] = TESTED;\n+    }\n@@ -202,9 +240,6 @@\n-        Locale loc = Locale.of(\"\", country);\n-        try {\n-            Currency currency = Currency.getInstance(loc);\n-            if (!currency.getCurrencyCode().equals(currencyCode)) {\n-                System.err.println(\"Error: [\" + country + \":\" +\n-                    loc.getDisplayCountry() + \"] expected: \" + currencyCode +\n-                    \", got: \" + currency.getCurrencyCode());\n-                err = true;\n-            }\n+    \/\/ Test a Currency built from currencyCode\n+    private static void currencyTest(String currencyCode, int numericCode, int digits) {\n+        Currency currency = Currency.getInstance(currencyCode);\n+        assertEquals(currency.getNumericCode(), numericCode);\n+        assertEquals(currency.getDefaultFractionDigits(), digits);\n+    }\n@@ -212,11 +247,5 @@\n-            if (codes[index] != UNDEFINED) {\n-                System.out.println(\"Warning: [\" + country + \":\" +\n-                    loc.getDisplayCountry() +\n-                    \"] multiple definitions. currency code=\" + currencyCode);\n-            }\n-            codes[index] = DEFINED;\n-        }\n-        catch (Exception e) {\n-            System.err.println(\"Error: \" + e + \": Country=\" + country);\n-            err = true;\n-        }\n+    \/\/ Test a Currency built from country\n+    private static void countryTest(String country, String currencyCode) {\n+        Locale loc = Locale.of(\"\", country);\n+        Currency currency = Currency.getInstance(loc);\n+        assertEquals(currency.getCurrencyCode(), currencyCode);\n@@ -225,3 +254,3 @@\n-    static void testCurrencyDefined(String currencyCode, int numericCode, int digits) {\n-        try {\n-            Currency currency = currency = Currency.getInstance(currencyCode);\n+    private static List<Arguments> ISO4217CodesProvider() {\n+        return ISO4217Codes;\n+    }\n@@ -229,5 +258,3 @@\n-            if (currency.getNumericCode() != numericCode) {\n-                System.err.println(\"Error: [\" + currencyCode + \"] expected: \" +\n-                    numericCode + \"; got: \" + currency.getNumericCode());\n-                err = true;\n-            }\n+    private static List<Arguments> additionalCodesProvider() {\n+        return additionalCodes;\n+    }\n@@ -235,10 +262,19 @@\n-            if (currency.getDefaultFractionDigits() != digits) {\n-                System.err.println(\"Error: [\" + currencyCode + \"] expected: \" +\n-                    digits + \"; got: \" + currency.getDefaultFractionDigits());\n-                err = true;\n-            }\n-        }\n-        catch (Exception e) {\n-            System.err.println(\"Error: \" + e + \": Currency code=\" +\n-                currencyCode);\n-            err = true;\n+    \/**\n+     * Tests trying to create a Currency from an invalid alpha-2 country either\n+     * throws an IllegalArgumentException or returns null. The test data\n+     * supplied is every possible combination of AA -> ZZ.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"codeCombos\")\n+    public void twoLetterCodesTest(String country) {\n+        if (codes[toIndex(country)] == UNDEFINED) {\n+            \/\/ if a code is undefined \/ 0, creating a Currency from it\n+            \/\/ should throw an IllegalArgumentException\n+            assertThrows(IllegalArgumentException.class,\n+                    ()-> Currency.getInstance(Locale.of(\"\", country)),\n+                    \"Error: This should be an undefined code and throw IllegalArgumentException: \" + country);\n+        } else if (codes[toIndex(country)] == SKIPPED) {\n+            \/\/ if a code is marked as skipped \/ 2, creating a Currency from it\n+            \/\/ should return null\n+            assertNull(Currency.getInstance(Locale.of(\"\", country)),\n+                    \"Error: Currency.getInstance() for this locale should return null: \" + country);\n@@ -248,1 +284,3 @@\n-    static void test2() {\n+    \/\/ This method generates code combos from AA to ZZ\n+    private static List<String> codeCombos() {\n+        List<String> codeCombos = new ArrayList<>();\n@@ -252,34 +290,3 @@\n-                code[0] = (char)('A'+ i);\n-                code[1] = (char)('A'+ j);\n-                String country = new String(code);\n-                boolean ex;\n-\n-                if (codes[toIndex(country)] == UNDEFINED) {\n-                    ex = false;\n-                    try {\n-                        Currency.getInstance(Locale.of(\"\", country));\n-                    }\n-                    catch (IllegalArgumentException e) {\n-                        ex = true;\n-                    }\n-                    if (!ex) {\n-                        System.err.println(\"Error: This should be an undefined code and throw IllegalArgumentException: \" +\n-                            country);\n-                        err = true;\n-                    }\n-                } else if (codes[toIndex(country)] == SKIPPED) {\n-                    Currency cur = null;\n-                    try {\n-                        cur = Currency.getInstance(Locale.of(\"\", country));\n-                    }\n-                    catch (Exception e) {\n-                        System.err.println(\"Error: \" + e + \": Country=\" +\n-                            country);\n-                        err = true;\n-                    }\n-                    if (cur != null) {\n-                        System.err.println(\"Error: Currency.getInstance() for an this locale should return null: \" +\n-                            country);\n-                        err = true;\n-                    }\n-                }\n+                code[0] = (char) ('A' + i);\n+                code[1] = (char) ('A' + j);\n+                codeCombos.add(new String(code));\n@@ -288,0 +295,1 @@\n+        return codeCombos;\n@@ -290,4 +298,4 @@\n-    \/**\n-     * This test depends on test1(), where 'testCurrencies' set is constructed\n-     *\/\n-    static void getAvailableCurrenciesTest() {\n+    \/\/ This method ensures that getAvailableCurrencies() returns\n+    \/\/ the expected amount of currencies.\n+    @Test\n+    public void getAvailableCurrenciesTest() {\n@@ -295,0 +303,4 @@\n+        \/\/ Ensure that testCurrencies has all the JRE currency codes\n+        assertTrue(testCurrencies.containsAll(jreCurrencies),\n+                getSetDiffs(jreCurrencies, testCurrencies));\n+    }\n@@ -296,14 +308,6 @@\n-        \/\/ add otherCodes\n-        StringTokenizer st = new StringTokenizer(otherCodes, \"-\");\n-        while (st.hasMoreTokens()) {\n-            testCurrencies.add(Currency.getInstance(st.nextToken()));\n-        }\n-\n-        if (!testCurrencies.containsAll(jreCurrencies)) {\n-            System.err.print(\"Error: getAvailableCurrencies() returned extra currencies than expected: \");\n-            jreCurrencies.removeAll(testCurrencies);\n-            for (Currency c : jreCurrencies) {\n-                System.err.print(\" \"+c);\n-            }\n-            System.err.println();\n-            err = true;\n+    private static String getSetDiffs(Set<Currency> jreCurrencies, Set<Currency> testCurrencies) {\n+        StringBuilder bldr = new StringBuilder();\n+        bldr.append(\"Error: getAvailableCurrencies() returned unexpected currencies: \");\n+        jreCurrencies.removeAll(testCurrencies);\n+        for (Currency curr : jreCurrencies) {\n+            bldr.append(\" \" + curr);\n@@ -311,0 +315,2 @@\n+        bldr.append(\"\\n\");\n+        return bldr.toString();\n","filename":"test\/jdk\/java\/util\/Currency\/ValidateISO4217.java","additions":233,"deletions":227,"binary":false,"changes":460,"status":"modified"}]}