{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -27,0 +28,1 @@\n+ * @run junit Bug4512215\n@@ -31,0 +33,1 @@\n+import java.util.stream.Stream;\n@@ -32,1 +35,3 @@\n-public class Bug4512215 {\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -34,5 +39,1 @@\n-    public static void main(String[] args) throws Exception {\n-        testCurrencyDefined(\"XBD\", -1);\n-        testCountryCurrency(\"TJ\", \"TJS\", 2);\n-        testCountryCurrency(\"FO\", \"DKK\", 2);\n-        testCountryCurrency(\"FK\", \"FKP\", 2);\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -40,1 +41,1 @@\n-        testCountryCurrency(\"AF\", \"AFN\", 2);    \/\/ changed from \"AFA\"\n+public class Bug4512215 {\n@@ -42,2 +43,13 @@\n-        \/\/ Newsletter V-5 on ISO 3166-1 (2002-05-20)\n-        testCountryCurrency(\"TL\", \"USD\", 2);    \/\/ successor to TP\/TPE\n+    \/**\n+     * Tests that the given country has the expected currency code from\n+     * calling getCurrencyCode().\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"twoDigitDecimals\")\n+    public void currencyCountryTest(String currencyCode, int digits, String country) {\n+        \/\/ digits parameter is not used, exists so that data provider can\n+        \/\/ be shared among multiple tests\n+        Currency currency = Currency.getInstance(Locale.of(\"\", country));\n+        assertEquals(currency.getCurrencyCode(), currencyCode, String.format(\n+                \"[%s] expected %s; got: %s\", country, currencyCode, currency.getCurrencyCode()));\n+    }\n@@ -45,2 +57,10 @@\n-        \/\/ Newsletter V-8 on ISO 3166-1 (2003-07-23)\n-        testCountryCurrency(\"CS\", \"CSD\", 2);    \/\/ successor to YU\/YUM\n+    \/**\n+     * Tests that the given currencyCode has the expected number of\n+     * decimal digits from calling getDefaultFractionDigits().\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource({\"twoDigitDecimals\", \"nonTwoDigitDecimals\"})\n+    public void currencyDefinedTest(String currencyCode, int digits) {\n+        Currency currency = Currency.getInstance(currencyCode);\n+        assertEquals(currency.getDefaultFractionDigits(), digits, String.format(\n+                \"[%s] expected: %s; got: %s\", currencyCode, digits, currency.getDefaultFractionDigits()));\n@@ -49,9 +69,11 @@\n-    private static void testCountryCurrency(String country, String currencyCode,\n-            int digits) {\n-        testCurrencyDefined(currencyCode, digits);\n-        Currency currency = Currency.getInstance(Locale.of(\"\", country));\n-        if (!currency.getCurrencyCode().equals(currencyCode)) {\n-            throw new RuntimeException(\"[\" + country\n-                    + \"] expected: \" + currencyCode\n-                    + \"; got: \" + currency.getCurrencyCode());\n-        }\n+    private static Stream<Arguments> twoDigitDecimals() {\n+        return Stream.of(\n+                Arguments.of(\"TJS\", 2, \"TJ\"),\n+                Arguments.of(\"DKK\", 2, \"FO\"),\n+                Arguments.of(\"FKP\", 2, \"FK\"),\n+                Arguments.of(\"AFN\", 2, \"AF\"), \/\/ changed from \"AFA\"\n+                \/\/ Newsletter V-5 on ISO 3166-1 (2002-05-20)\n+                Arguments.of(\"USD\", 2, \"TL\"), \/\/ successor to TP\/TPE\n+                \/\/ Newsletter V-8 on ISO 3166-1 (2003-07-23)\n+                Arguments.of(\"CSD\", 2, \"CS\") \/\/ successor to YU\/YUM\n+        );\n@@ -60,7 +82,8 @@\n-    private static void testCurrencyDefined(String currencyCode, int digits) {\n-        Currency currency = Currency.getInstance(currencyCode);\n-        if (currency.getDefaultFractionDigits() != digits) {\n-            throw new RuntimeException(\"[\" + currencyCode\n-                    + \"] expected: \" + digits\n-                    + \"; got: \" + currency.getDefaultFractionDigits());\n-        }\n+    private static Stream<Arguments> nonTwoDigitDecimals() {\n+        return Stream.of(\n+                Arguments.of(\"XBD\", -1),\n+                Arguments.of(\"XAG\", -1),\n+                Arguments.of(\"XAU\", -1),\n+                Arguments.of(\"XBA\", -1),\n+                Arguments.of(\"XBB\", -1)\n+        );\n","filename":"test\/jdk\/java\/util\/Currency\/Bug4512215.java","additions":51,"deletions":28,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @bug 6807534\n- * @summary check whether the default implementation of\n- *    CurrencNameProvider.getDisplayName(String, Locale) throws appropriate\n- *    exceptions when necessary.\n- *\/\n-\n-import java.util.Locale;\n-import java.util.spi.CurrencyNameProvider;\n-\n-public class Bug6807534 {\n-\n-    static final CurrencyNameProvider cnp = new CurrencyNameProviderImpl();\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ test for NullPointerException (currencyCode)\n-        try {\n-            cnp.getDisplayName(null, Locale.US);\n-            throwException(\"NPE was not thrown with null currencyCode\");\n-        } catch (NullPointerException npe) {}\n-\n-        \/\/ test for NullPointerException (locale)\n-        try {\n-            cnp.getDisplayName(\"USD\", null);\n-            throwException(\"NPE was not thrown with null locale\");\n-        } catch (NullPointerException npe) {}\n-\n-        \/\/ test for IllegalArgumentException (illegal currencyCode)\n-        try {\n-            cnp.getDisplayName(\"INVALID\", Locale.US);\n-            throwException(\"IllegalArgumentException was not thrown with invalid currency code\");\n-        } catch (IllegalArgumentException iae) {}\n-        try {\n-            cnp.getDisplayName(\"inv\", Locale.US);\n-            throwException(\"IllegalArgumentException was not thrown with invalid currency code\");\n-        } catch (IllegalArgumentException iae) {}\n-\n-        \/\/ test for IllegalArgumentException (non-supported locale)\n-        try {\n-            cnp.getDisplayName(\"USD\", Locale.JAPAN);\n-            throwException(\"IllegalArgumentException was not thrown with non-supported locale\");\n-        } catch (IllegalArgumentException iae) {}\n-    }\n-\n-    static void throwException(String msg) {\n-        throw new RuntimeException(\"test failed. \"+msg);\n-    }\n-\n-    static class CurrencyNameProviderImpl extends CurrencyNameProvider {\n-        \/\/ dummy implementation\n-        public String getSymbol(String currencyCode, Locale locale) {\n-            return \"\";\n-        }\n-\n-        public Locale[] getAvailableLocales() {\n-            Locale[] avail = new Locale[1];\n-            avail[0] = Locale.US;\n-            return avail;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Currency\/Bug6807534.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -27,0 +28,1 @@\n+ * @run junit Bug8154295\n@@ -30,0 +32,1 @@\n+import java.util.stream.Stream;\n@@ -31,3 +34,3 @@\n-public class Bug8154295 {\n-\n-    public static void main(String[] args) {\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -35,5 +38,1 @@\n-        String numericCode = Currency.getInstance(\"AFA\").getNumericCodeAsString();\n-        if (!numericCode.equals(\"004\")) { \/\/should return \"004\" (a 3 digit string)\n-           throw new RuntimeException(\"[Expected 004, \"\n-                + \"found \"+numericCode+\" for AFA]\");\n-        }\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -41,11 +40,1 @@\n-        numericCode = Currency.getInstance(\"AUD\").getNumericCodeAsString();\n-        if (!numericCode.equals(\"036\")) { \/\/should return \"036\" (a 3 digit string)\n-            throw new RuntimeException(\"[Expected 036, \"\n-                + \"found \"+numericCode+\" for AUD]\");\n-        }\n-\n-        numericCode = Currency.getInstance(\"USD\").getNumericCodeAsString();\n-        if (!numericCode.equals(\"840\")) {\/\/ should return \"840\" (a 3 digit string)\n-            throw new RuntimeException(\"[Expected 840, \"\n-                + \"found \"+numericCode+\" for USD]\");\n-        }\n+public class Bug8154295 {\n@@ -53,0 +42,10 @@\n+    \/**\n+     * Ensure getNumericCodeAsString() returns the correct 3-digit numeric code\n+     * for the associated currency Code.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"codeProvider\")\n+    public void checkNumCodeTest(String currCode, String expectedNumCode) {\n+        String actualNumCode = Currency.getInstance(currCode).getNumericCodeAsString();\n+        assertEquals(expectedNumCode, actualNumCode, String.format(\n+                \"Expected: %s, but got: %s, for %s\", expectedNumCode, actualNumCode, currCode));\n@@ -55,0 +54,7 @@\n+    private static Stream<Arguments> codeProvider() {\n+        return Stream.of(\n+                Arguments.of(\"AFA\", \"004\"),\n+                Arguments.of(\"AUD\", \"036\"),\n+                Arguments.of(\"USD\", \"840\")\n+        );\n+    }\n","filename":"test\/jdk\/java\/util\/Currency\/Bug8154295.java","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,4 +23,5 @@\n-\/**\n- *\n- *\n- * Check the consistency between the regression tests and the currency data in the JRE\n+\n+\n+\/*\n+  Check the consistency between the regression tests and the currency\n+  data in the JRE. This class is used by other test classes.\n@@ -29,3 +30,8 @@\n-import java.io.*;\n-import java.lang.reflect.*;\n-import java.security.*;\n+import java.io.BufferedReader;\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n","filename":"test\/jdk\/java\/util\/Currency\/CheckDataVersion.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6807534\n+ * @summary check whether the default implementation of\n+ *    CurrencyNameProvider.getDisplayName(String, Locale) throws appropriate\n+ *    exceptions when necessary.\n+ * @run junit CurrencyNameProviderTest\n+ *\/\n+\n+import java.util.Locale;\n+import java.util.spi.CurrencyNameProvider;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class CurrencyNameProviderTest {\n+\n+    static final CurrencyNameProvider cnp = new CurrencyNameProviderImpl();\n+\n+    \/**\n+     * Tests that the currency name provider throws a NullPointerException\n+     * under the expected circumstances.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"nullArgProvider\")\n+    public void NPETest(String currencyCode, Locale locale, String err) {\n+        assertThrows(NullPointerException.class,\n+                () -> cnp.getDisplayName(currencyCode, locale), err);\n+    }\n+\n+    \/**\n+     * Tests that the currency name provider throws a IllegalArgumentException\n+     * under the expected circumstances.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"illegalArgProvider\")\n+    public void IAETest(String currencyCode, Locale locale, String err) {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> cnp.getDisplayName(currencyCode, locale), err);\n+    }\n+\n+    private static Stream<Arguments> nullArgProvider() {\n+        return Stream.of(\n+                Arguments.of(null, Locale.US,\n+                        \"NPE was not thrown with null currencyCode\"),\n+                Arguments.of(\"USD\", null,\n+                        \"NPE was not thrown with null locale\")\n+        );\n+    }\n+\n+    private static Stream<Arguments> illegalArgProvider() {\n+        return Stream.of(\n+                Arguments.of(\"INVALID\", Locale.US,\n+                        \"IAE was not thrown with invalid currency code\"),\n+                Arguments.of(\"inv\", Locale.US,\n+                        \"IAE was not thrown with invalid currency code\"),\n+                Arguments.of(\"USD\", Locale.JAPAN,\n+                        \"IllegalArgumentException was not thrown with non-supported locale\")\n+        );\n+    }\n+\n+    static class CurrencyNameProviderImpl extends CurrencyNameProvider {\n+        \/\/ dummy implementation\n+        public String getSymbol(String currencyCode, Locale locale) {\n+            return \"\";\n+        }\n+\n+        public Locale[] getAvailableLocales() {\n+            Locale[] avail = new Locale[1];\n+            avail[0] = Locale.US;\n+            return avail;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Currency\/CurrencyNameProviderTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -31,0 +32,1 @@\n+ * @run junit CurrencyTest\n@@ -41,0 +43,1 @@\n+import java.util.ArrayList;\n@@ -42,0 +45,1 @@\n+import java.util.List;\n@@ -43,0 +47,11 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -47,1 +62,3 @@\n-    public static void main(String[] args) throws Exception {\n+    \/\/ 'tablea1.txt' should be up-to-date before testing\n+    @Test\n+    public void dataVersionTest() {\n@@ -49,7 +66,0 @@\n-        testCurrencyCodeValidation();\n-        testLocaleMapping();\n-        testSymbols();\n-        testFractionDigits();\n-        testSerialization();\n-        testDisplayNames();\n-        testFundsCodes();\n@@ -58,14 +68,8 @@\n-    static void testCurrencyCodeValidation() {\n-        \/\/ test creation of some valid currencies\n-        testValidCurrency(\"USD\");\n-        testValidCurrency(\"EUR\");\n-        testValidCurrency(\"GBP\");\n-        testValidCurrency(\"JPY\");\n-        testValidCurrency(\"CNY\");\n-        testValidCurrency(\"CHF\");\n-\n-        \/\/ test creation of some fictitious currencies\n-        testInvalidCurrency(\"AQD\");\n-        testInvalidCurrency(\"US$\");\n-        testInvalidCurrency(\"\\u20AC\");\n-    }\n+    @Nested\n+    class CodeValidationTests {\n+        \/\/ Calling getInstance() on equal currency codes should return equal currencies\n+        @ParameterizedTest\n+        @MethodSource(\"validCurrencies\")\n+        public void validCurrencyTest(String currencyCode) {\n+            compareCurrencies(currencyCode);\n+        }\n@@ -73,5 +77,2 @@\n-    static void testValidCurrency(String currencyCode) {\n-        Currency currency1 = Currency.getInstance(currencyCode);\n-        Currency currency2 = Currency.getInstance(currencyCode);\n-        if (currency1 != currency2) {\n-            throw new RuntimeException(\"Didn't get same instance for same currency code\");\n+        private static Stream<String> validCurrencies() {\n+            return Stream.of(\"USD\", \"EUR\", \"GBP\", \"JPY\", \"CNY\", \"CHF\");\n@@ -79,2 +80,11 @@\n-        if (!currency1.getCurrencyCode().equals(currencyCode)) {\n-            throw new RuntimeException(\"Currency code changed\");\n+\n+        \/\/ Calling getInstance() with an illegal name should throw an IAE\n+        @ParameterizedTest\n+        @MethodSource(\"invalidCurrencies\")\n+        public void invalidCurrencyTest(String currencyCode) {\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    Currency.getInstance(currencyCode), \"getInstance() did not throw IAE\");\n+        }\n+\n+        private static Stream<String> invalidCurrencies() {\n+            return Stream.of(\"AQD\", \"US$\", \"\\u20AC\");\n@@ -84,6 +94,24 @@\n-    static void testInvalidCurrency(String currencyCode) {\n-        boolean gotException = false;\n-        try {\n-            Currency currency = Currency.getInstance(currencyCode);\n-        } catch (IllegalArgumentException e) {\n-            gotException = true;\n+    @Nested\n+    class FundsCodesTests {\n+        \/\/ Calling getInstance() on equal currency codes should return equal currencies\n+        @ParameterizedTest\n+        @MethodSource(\"fundsCodes\")\n+        public void validCurrencyTest(String currencyCode) {\n+            compareCurrencies(currencyCode);\n+        }\n+\n+        \/\/ Verify a currency has the expected fractional digits\n+        @ParameterizedTest\n+        @MethodSource(\"fundsCodes\")\n+        public void fractionDigitTest(String currencyCode, int expectedFractionDigits) {\n+            compareFractionDigits(currencyCode, expectedFractionDigits);\n+        }\n+\n+        \/\/ Verify a currency has the expected numeric code\n+        @ParameterizedTest\n+        @MethodSource(\"fundsCodes\")\n+        public void numericCodeTest(String currencyCode, int ignored, int expectedNumeric) {\n+            int numeric = Currency.getInstance(currencyCode).getNumericCode();\n+            assertEquals(numeric, expectedNumeric, String.format(\n+                    \"Wrong numeric code for currency %s, expected %s, got %s\",\n+                    currencyCode, expectedNumeric, numeric));\n@@ -91,2 +119,8 @@\n-        if (!gotException) {\n-            throw new RuntimeException(\"didn't get specified exception\");\n+\n+        private static Stream<Arguments> fundsCodes() {\n+            return Stream.of(\n+                    Arguments.of(\"BOV\", 2, 984), Arguments.of(\"CHE\", 2, 947),\n+                    Arguments.of(\"CHW\", 2, 948), Arguments.of(\"CLF\", 4, 990),\n+                    Arguments.of(\"COU\", 2, 970), Arguments.of(\"MXV\", 2, 979),\n+                    Arguments.of(\"USN\", 2, 997), Arguments.of(\"UYI\", 0, 940)\n+            );\n@@ -96,1 +130,3 @@\n-    static void testLocaleMapping() {\n+    @Nested\n+    class LocaleMappingTests {\n+\n@@ -99,25 +135,19 @@\n-        Locale[] locales = Locale.getAvailableLocales();\n-        int goodCountries = 0;\n-        int ownCurrencies = 0;\n-        for (int i = 0; i < locales.length; i++) {\n-            Locale locale = locales[i];\n-            String ctryCode = locale.getCountry();\n-            int ctryLength = ctryCode.length();\n-            if (ctryLength == 0 ||\n-                ctryLength == 3 || \/\/ UN M.49 code\n-                ctryCode.matches(\"AA|Q[M-Z]|X[A-JL-Z]|ZZ\" + \/\/ user defined codes, excluding \"XK\" (Kosovo)\n-                                 \"AC|CP|DG|EA|EU|FX|IC|SU|TA|UK\")) { \/\/ exceptional reservation codes\n-                boolean gotException = false;\n-                try {\n-                    Currency.getInstance(locale);\n-                } catch (IllegalArgumentException e) {\n-                    gotException = true;\n-                }\n-                if (!gotException) {\n-                    throw new RuntimeException(\"didn't get specified exception\");\n-                }\n-            } else {\n-                goodCountries++;\n-                Currency currency = Currency.getInstance(locale);\n-                if (currency.getCurrencyCode().indexOf(locale.getCountry()) == 0) {\n-                    ownCurrencies++;\n+        @Test\n+        public void localeMappingTest() {\n+            Locale[] locales = Locale.getAvailableLocales();\n+            int goodCountries = 0;\n+            int ownCurrencies = 0;\n+            for (Locale locale : locales) {\n+                String ctryCode = locale.getCountry();\n+                int ctryLength = ctryCode.length();\n+                if (ctryLength == 0 ||\n+                        ctryLength == 3 || \/\/ UN M.49 code\n+                        ctryCode.matches(\"AA|Q[M-Z]|X[A-JL-Z]|ZZ\" + \/\/ user defined codes, excluding \"XK\" (Kosovo)\n+                                \"AC|CP|DG|EA|EU|FX|IC|SU|TA|UK\")) { \/\/ exceptional reservation codes\n+                    assertThrows(IllegalArgumentException.class, () -> Currency.getInstance(locale), \"Did not throw IAE\");\n+                } else {\n+                    goodCountries++;\n+                    Currency currency = Currency.getInstance(locale);\n+                    if (currency.getCurrencyCode().indexOf(locale.getCountry()) == 0) {\n+                        ownCurrencies++;\n+                    }\n@@ -126,0 +156,5 @@\n+            System.out.println(\"Countries tested: \" + goodCountries +\n+                    \", own currencies: \" + ownCurrencies);\n+            if (ownCurrencies < (goodCountries \/ 2 + 1)) {\n+                throw new RuntimeException(\"suspicious: not enough countries have their own currency.\");\n+            }\n@@ -127,4 +162,6 @@\n-        System.out.println(\"Countries tested: \" + goodCountries +\n-                \", own currencies: \" + ownCurrencies);\n-        if (ownCurrencies < (goodCountries \/ 2 + 1)) {\n-            throw new RuntimeException(\"suspicious: not enough countries have their own currency.\");\n+\n+        \/\/ Check an invalid country code\n+        @Test\n+        public void invalidCountryTest() {\n+            assertThrows(IllegalArgumentException.class, ()->\n+                    Currency.getInstance(Locale.of(\"\", \"EU\")), \"Did not throw IAE\");\n@@ -133,5 +170,9 @@\n-        \/\/ check a few countries that don't change their currencies too often\n-        String[] country1 = {\"US\", \"CA\", \"JP\", \"CN\", \"SG\", \"CH\"};\n-        String[] currency1 = {\"USD\", \"CAD\", \"JPY\", \"CNY\", \"SGD\", \"CHF\"};\n-        for (int i = 0; i < country1.length; i++) {\n-            checkCountryCurrency(country1[i], currency1[i]);\n+        \/\/ Ensure a selection of countries have the expected currency\n+        @ParameterizedTest\n+        @MethodSource({\"countryProvider\", \"switchedOverCountries\"})\n+        public void countryCurrencyTest(String countryCode, String expected) {\n+            Locale locale = Locale.of(\"\", countryCode);\n+            Currency currency = Currency.getInstance(locale);\n+            String code = (currency != null) ? currency.getCurrencyCode() : null;\n+            assertEquals(expected, code, generateErrMsg(\n+                    \"currency for\", locale.getDisplayCountry(), expected, code));\n@@ -140,21 +181,12 @@\n-        \/*\n-        * check currency changes\n-        * In current implementation, there is no data of old currency and transition date at jdk\/src\/java.base\/share\/data\/currency\/CurrencyData.properties.\n-        * So, all the switch data arrays are empty. In the future, if data of old currency and transition date are necessary for any country, the\n-        * arrays here can be updated so that the program can check the currency switch.\n-        *\/\n-        String[] switchOverCtry = {};\n-        String[] switchOverOld = {};\n-        String[] switchOverNew = {};\n-        String[] switchOverTZ = {};\n-        int[] switchOverYear = {};\n-        int[] switchOverMonth = {}; \/\/ java.time APIs accept month starting from 1 i.e. 01 for January\n-        int[] switchOverDay = {};\n-\n-        for (int i = 0; i < switchOverCtry.length; i++) {\n-            ZoneId zoneId = ZoneId.of(switchOverTZ[i]);\n-            ZonedDateTime zonedDateAndTime  = ZonedDateTime.of(LocalDate.of(switchOverYear[i], switchOverMonth[i], switchOverDay[i]),\n-                                                  LocalTime.MIDNIGHT, zoneId);\n-            ZonedDateTime currentZonedDateAndTime =  ZonedDateTime.now(zoneId);\n-            checkCountryCurrency(switchOverCtry[i], (currentZonedDateAndTime.isAfter(zonedDateAndTime) ||\n-                        currentZonedDateAndTime.isEqual(zonedDateAndTime)) ? switchOverNew[i] : switchOverOld[i]);\n+        private static Stream<Arguments> countryProvider() {\n+            return Stream.of(\n+                    \/\/ Check country that does not have a currency\n+                    Arguments.of(\"AQ\", null),\n+                    \/\/ Check some countries that don't change their currencies often\n+                    Arguments.of(\"US\", \"USD\"),\n+                    Arguments.of(\"CA\", \"CAD\"),\n+                    Arguments.of(\"JP\", \"JPY\"),\n+                    Arguments.of(\"CN\", \"CNY\"),\n+                    Arguments.of(\"SG\", \"SGD\"),\n+                    Arguments.of(\"CH\", \"CHF\")\n+            );\n@@ -163,2 +195,17 @@\n-        \/\/ check a country code which doesn't have a currency\n-        checkCountryCurrency(\"AQ\", null);\n+        \/*\n+         * Check Currency Changes\n+         * In the current implementation, there is no data of old currency and transition\n+         * date at jdk\/src\/java.base\/share\/data\/currency\/CurrencyData.properties.\n+         * So, all the switch data arrays are empty. In the future, if data of old\n+         * currency and transition date are necessary for any country, the\n+         * arrays here can be updated so that the program can check the currency switch.\n+         *\/\n+        private static List<Arguments> switchedOverCountries() {\n+            List<Arguments> switched = new ArrayList<Arguments>();\n+            String[] switchOverCtry = {};\n+            String[] switchOverOld = {};\n+            String[] switchOverNew = {};\n+            String[] switchOverTZ = {};\n+            int[] switchOverYear = {};\n+            int[] switchOverMonth = {}; \/\/ java.time APIs accept month starting from 1 i.e. 01 for January\n+            int[] switchOverDay = {};\n@@ -166,9 +213,9 @@\n-        \/\/ check an invalid country code\n-        boolean gotException = false;\n-        try {\n-            Currency.getInstance(Locale.of(\"\", \"EU\"));\n-        } catch (IllegalArgumentException e) {\n-            gotException = true;\n-        }\n-        if (!gotException) {\n-            throw new RuntimeException(\"didn't get specified exception.\");\n+            for (int i = 0; i < switchOverCtry.length; i++) {\n+                ZoneId zoneId = ZoneId.of(switchOverTZ[i]);\n+                ZonedDateTime zonedDateAndTime  = ZonedDateTime.of(LocalDate.of(\n+                        switchOverYear[i], switchOverMonth[i], switchOverDay[i]), LocalTime.MIDNIGHT, zoneId);\n+                ZonedDateTime currentZonedDateAndTime =  ZonedDateTime.now(zoneId);\n+                switched.add(Arguments.of(switchOverCtry[i], (currentZonedDateAndTime.isAfter(zonedDateAndTime)\n+                        || currentZonedDateAndTime.isEqual(zonedDateAndTime)) ? switchOverNew[i] : switchOverOld[i]));\n+            }\n+            return switched;\n@@ -178,10 +225,1 @@\n-    static void checkCountryCurrency(String countryCode, String expected) {\n-        Locale locale = Locale.of(\"\", countryCode);\n-        Currency currency = Currency.getInstance(locale);\n-        String code = (currency != null) ? currency.getCurrencyCode() : null;\n-        if (!(expected == null ? code == null : expected.equals(code))) {\n-            throw new RuntimeException(\"Wrong currency for \" +\n-                    locale.getDisplayCountry() +\n-                    \": expected \" + expected + \", got \" + code);\n-        }\n-    }\n+    \/\/ NON-NESTED TESTS\n@@ -189,4 +227,5 @@\n-    static void testSymbols() {\n-        testSymbol(\"USD\", Locale.US, \"$\");\n-        testSymbol(\"EUR\", Locale.GERMANY, \"\\u20AC\");\n-        testSymbol(\"USD\", Locale.PRC, \"US$\");\n+    \/\/ Ensure selection of currencies have the correct fractional digits\n+    @ParameterizedTest\n+    @MethodSource(\"expectedFractionsProvider\")\n+    public void fractionDigitsTest(String currencyCode, int expectedFractionDigits) {\n+        compareFractionDigits(currencyCode, expectedFractionDigits);\n@@ -195,7 +234,10 @@\n-    static void testSymbol(String currencyCode, Locale locale, String expectedSymbol) {\n-        String symbol = Currency.getInstance(currencyCode).getSymbol(locale);\n-        if (!symbol.equals(expectedSymbol)) {\n-            throw new RuntimeException(\"Wrong symbol for currency \" +\n-                    currencyCode +\": expected \" + expectedSymbol +\n-                    \", got \" + symbol);\n-        }\n+    private static Stream<Arguments> expectedFractionsProvider() {\n+        return Stream.of(\n+                Arguments.of(\"USD\", 2), Arguments.of(\"EUR\", 2),\n+                Arguments.of(\"JPY\", 0), Arguments.of(\"XDR\", -1),\n+                Arguments.of(\"BHD\", 3), Arguments.of(\"IQD\", 3),\n+                Arguments.of(\"JOD\", 3), Arguments.of(\"KWD\", 3),\n+                Arguments.of(\"LYD\", 3), Arguments.of(\"OMR\", 3),\n+                Arguments.of(\"TND\", 3), Arguments.of(\"TRL\", 0), \/\/ Turkish Lira\n+                Arguments.of(\"TRY\", 2)\n+        );\n@@ -204,17 +246,7 @@\n-    static void testFractionDigits() {\n-        testFractionDigits(\"USD\", 2);\n-        testFractionDigits(\"EUR\", 2);\n-        testFractionDigits(\"JPY\", 0);\n-        testFractionDigits(\"XDR\", -1);\n-\n-        testFractionDigits(\"BHD\", 3);\n-        testFractionDigits(\"IQD\", 3);\n-        testFractionDigits(\"JOD\", 3);\n-        testFractionDigits(\"KWD\", 3);\n-        testFractionDigits(\"LYD\", 3);\n-        testFractionDigits(\"OMR\", 3);\n-        testFractionDigits(\"TND\", 3);\n-\n-        \/\/ Turkish Lira\n-        testFractionDigits(\"TRL\", 0);\n-        testFractionDigits(\"TRY\", 2);\n+    \/\/ Ensure selection of currencies have the expected symbol\n+    @ParameterizedTest\n+    @MethodSource(\"symbolProvider\")\n+    public void symbolTest(String currencyCode, Locale locale, String expectedSymbol) {\n+        String symbol = Currency.getInstance(currencyCode).getSymbol(locale);\n+        assertEquals(symbol, expectedSymbol, generateErrMsg(\n+                \"symbol for\", currencyCode, expectedSymbol, symbol));\n@@ -223,7 +255,6 @@\n-    static void testFractionDigits(String currencyCode, int expectedFractionDigits) {\n-        int digits = Currency.getInstance(currencyCode).getDefaultFractionDigits();\n-        if (digits != expectedFractionDigits) {\n-            throw new RuntimeException(\"Wrong number of fraction digits for currency \" +\n-                    currencyCode +\": expected \" + expectedFractionDigits +\n-                    \", got \" + digits);\n-        }\n+    private static Stream<Arguments> symbolProvider() {\n+        return Stream.of(\n+                Arguments.of(\"USD\", Locale.US, \"$\"),\n+                Arguments.of(\"EUR\", Locale.GERMANY, \"\\u20AC\"),\n+                Arguments.of(\"USD\", Locale.PRC, \"US$\")\n+        );\n@@ -232,1 +263,4 @@\n-    static void testSerialization() throws Exception {\n+    \/\/ Ensure serialization does not break class invariant.\n+    \/\/ Currency should be able to round-trip and remain the same value.\n+    @Test\n+    public void serializationTest() throws Exception {\n@@ -244,4 +278,1 @@\n-\n-        if (currency1 != currency2) {\n-            throw new RuntimeException(\"serialization breaks class invariant\");\n-        }\n+        assertEquals(currency1, currency2, \"serialization breaks class invariant\");\n@@ -250,17 +281,5 @@\n-    static void testDisplayNames() {\n-        \/\/ null argument test\n-        try {\n-            testDisplayName(\"USD\", null, \"\");\n-            throw new RuntimeException(\"getDisplayName(NULL) did not throw an NPE.\");\n-        } catch (NullPointerException npe) {}\n-\n-        testDisplayName(\"USD\", Locale.ENGLISH, \"US Dollar\");\n-        testDisplayName(\"FRF\", Locale.FRENCH, \"franc fran\\u00e7ais\");\n-        testDisplayName(\"DEM\", Locale.GERMAN, \"Deutsche Mark\");\n-        testDisplayName(\"ESP\", Locale.of(\"es\"), \"peseta espa\\u00f1ola\");\n-        testDisplayName(\"ITL\", Locale.ITALIAN, \"lira italiana\");\n-        testDisplayName(\"JPY\", Locale.JAPANESE, \"\\u65e5\\u672c\\u5186\");\n-        testDisplayName(\"KRW\", Locale.KOREAN, \"\\ub300\\ud55c\\ubbfc\\uad6d \\uc6d0\");\n-        testDisplayName(\"SEK\", Locale.of(\"sv\"), \"svensk krona\");\n-        testDisplayName(\"CNY\", Locale.SIMPLIFIED_CHINESE, \"\\u4eba\\u6c11\\u5e01\");\n-        testDisplayName(\"TWD\", Locale.TRADITIONAL_CHINESE, \"\\u65b0\\u53f0\\u5e63\");\n+    \/\/ Ensure getInstance() throws null when passed a null locale\n+    @Test\n+    public void nullDisplayNameTest() {\n+        assertThrows(NullPointerException.class, ()->\n+                Currency.getInstance(\"USD\").getDisplayName(null));\n@@ -269,1 +288,4 @@\n-    static void testDisplayName(String currencyCode, Locale locale, String expectedName) {\n+    \/\/ Ensure a selection of currencies\/locale combos have the correct display name\n+    @ParameterizedTest\n+    @MethodSource(\"displayNameProvider\")\n+    public void displayNameTest(String currencyCode, Locale locale, String expectedName) {\n@@ -271,5 +293,2 @@\n-        if (!name.equals(expectedName)) {\n-            throw new RuntimeException(\"Wrong display name for currency \" +\n-                    currencyCode +\": expected '\" + expectedName +\n-                    \"', got '\" + name + \"'\");\n-        }\n+        assertEquals(name, expectedName, generateErrMsg(\n+                \"display name for\", currencyCode, expectedName, name));\n@@ -277,27 +296,14 @@\n-    static void testFundsCodes() {\n-        testValidCurrency(\"BOV\");\n-        testValidCurrency(\"CHE\");\n-        testValidCurrency(\"CHW\");\n-        testValidCurrency(\"CLF\");\n-        testValidCurrency(\"COU\");\n-        testValidCurrency(\"MXV\");\n-        testValidCurrency(\"USN\");\n-        testValidCurrency(\"UYI\");\n-\n-        testFractionDigits(\"BOV\", 2);\n-        testFractionDigits(\"CHE\", 2);\n-        testFractionDigits(\"CHW\", 2);\n-        testFractionDigits(\"CLF\", 4);\n-        testFractionDigits(\"COU\", 2);\n-        testFractionDigits(\"MXV\", 2);\n-        testFractionDigits(\"USN\", 2);\n-        testFractionDigits(\"UYI\", 0);\n-\n-        testNumericCode(\"BOV\", 984);\n-        testNumericCode(\"CHE\", 947);\n-        testNumericCode(\"CHW\", 948);\n-        testNumericCode(\"CLF\", 990);\n-        testNumericCode(\"COU\", 970);\n-        testNumericCode(\"MXV\", 979);\n-        testNumericCode(\"USN\", 997);\n-        testNumericCode(\"UYI\", 940);\n+\n+    private static Stream<Arguments> displayNameProvider() {\n+        return Stream.of(\n+                Arguments.of(\"USD\", Locale.ENGLISH, \"US Dollar\"),\n+                Arguments.of(\"FRF\", Locale.FRENCH, \"franc fran\\u00e7ais\"),\n+                Arguments.of(\"DEM\", Locale.GERMAN, \"Deutsche Mark\"),\n+                Arguments.of(\"ESP\", Locale.of(\"es\"), \"peseta espa\\u00f1ola\"),\n+                Arguments.of(\"ITL\", Locale.ITALIAN, \"lira italiana\"),\n+                Arguments.of(\"JPY\", Locale.JAPANESE, \"\\u65e5\\u672c\\u5186\"),\n+                Arguments.of(\"KRW\", Locale.KOREAN, \"\\ub300\\ud55c\\ubbfc\\uad6d \\uc6d0\"),\n+                Arguments.of(\"SEK\", Locale.of(\"sv\"), \"svensk krona\"),\n+                Arguments.of(\"CNY\", Locale.SIMPLIFIED_CHINESE, \"\\u4eba\\u6c11\\u5e01\"),\n+                Arguments.of(\"TWD\", Locale.TRADITIONAL_CHINESE, \"\\u65b0\\u53f0\\u5e63\")\n+        );\n@@ -306,7 +312,26 @@\n-    static void testNumericCode(String currencyCode, int expectedNumeric) {\n-        int numeric = Currency.getInstance(currencyCode).getNumericCode();\n-        if (numeric != expectedNumeric) {\n-            throw new RuntimeException(\"Wrong numeric code for currency \" +\n-                    currencyCode +\": expected \" + expectedNumeric +\n-                    \", got \" + numeric);\n-        }\n+    \/\/ HELPER FUNCTIONS\n+\n+    \/\/ A Currency instance returned from getInstance() should always be\n+    \/\/ equal if supplied the same currencyCode. getCurrencyCode() should\n+    \/\/ always be equal to the currencyCode used to create the Currency.\n+    private static void compareCurrencies(String currencyCode) {\n+        Currency currency1 = Currency.getInstance(currencyCode);\n+        Currency currency2 = Currency.getInstance(currencyCode);\n+        assertEquals(currency1, currency2, \"Didn't get same instance for same currency code\");\n+        assertEquals(currency1.getCurrencyCode(), currencyCode, \"Currency code changed\");\n+    }\n+\n+    \/\/ Ensures the getDefaultFractionDigits() method returns the expected amount\n+    private static void compareFractionDigits(String currencyCode,\n+                                              int expectedFractionDigits) {\n+        int digits = Currency.getInstance(currencyCode).getDefaultFractionDigits();\n+        assertEquals(digits, expectedFractionDigits, generateErrMsg(\n+                \"number of fraction digits for currency\",\n+                currencyCode, Integer.toString(expectedFractionDigits), Integer.toString(digits)));\n+    }\n+\n+    \/\/ Used for logging on failing tests\n+    private static String generateErrMsg(String subject, String currency,\n+                                         String expected, String got) {\n+        return String.format(\"Wrong %s %s: expected '%s', got '%s'\",\n+                subject, currency, expected, got);\n","filename":"test\/jdk\/java\/util\/Currency\/CurrencyTest.java","additions":237,"deletions":212,"binary":false,"changes":449,"status":"modified"}]}