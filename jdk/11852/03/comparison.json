{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires os.family == \"linux\" & vm.bits == \"64\" & (os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cds\n@@ -37,0 +37,5 @@\n+import java.util.HashMap;\n+import java.util.Properties;\n+import jdk.test.lib.artifacts.Artifact;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.artifacts.ArtifactResolverException;\n@@ -38,0 +43,1 @@\n+import jdk.test.lib.Platform;\n@@ -40,0 +46,1 @@\n+import jtreg.SkippedException;\n@@ -42,0 +49,3 @@\n+\n+    static final Properties props = System.getProperties();\n+\n@@ -51,2 +61,7 @@\n-    \/\/ the test.boot.jdk property is passed by make\/RunTests.gmk\n-    private static final String BOOT_JDK = System.getProperty(\"test.boot.jdk\", null);\n+    \/\/ the test.boot.jdk property is normally passed by make\/RunTests.gmk\n+    private static String OLD_JDK;\n+    private static String DEFAULT_OLD_JDK = System.getProperty(\"test.boot.jdk\", null);\n+\n+    \/\/ Comma separated list of JDK major versions that will be tested\n+    \/\/ If null, DEFAULT_OLD_JDK will be tested\n+    private static String JDK_VERSIONS = System.getProperty(\"test.autocreatesharedarchive.jdk.version\", null);\n@@ -64,2 +79,23 @@\n-        setupJVMs();\n-        doTest();\n+        \/\/ Earliest testable version is 19\n+        \/\/ Only run once if using the default boot jdk\n+        int n = java.lang.Runtime.version().major();\n+\n+        \/\/ Test only default version unless specified in gmk\n+        if (JDK_VERSIONS == null) {\n+            OLD_JDK = DEFAULT_OLD_JDK;\n+            setupJVMs();\n+            doTest();\n+            return;\n+        }\n+\n+        String[] versions = JDK_VERSIONS.split(\",\");\n+        for (int i = 0; i < versions.length && OLD_JDK != DEFAULT_OLD_JDK; i++) {\n+            System.out.println(\"Testing JDK: \" + versions[i]);\n+            try {\n+                OLD_JDK = fetchOldJDK(Integer.parseInt(versions[i]));\n+                setupJVMs();\n+                doTest();\n+            } catch (NumberFormatException e) {\n+                throw new RuntimeException(\"Invalid AutoCreateSharedArchive JDK version: \" + versions[i]);\n+            }\n+        }\n@@ -75,0 +111,1 @@\n+        \/\/ Example path: bundles\/linux-x64\/jdk-19_linux-x64_bin.tar.gz\/jdk-19\/bin\/java\n@@ -77,2 +114,2 @@\n-        } else if (BOOT_JDK != null) {\n-            oldJVM = BOOT_JDK + FS + \"bin\" + FS + \"java\";\n+        } else if (OLD_JDK != null) {\n+            oldJVM = OLD_JDK + FS + \"bin\" + FS + \"java\";\n@@ -80,1 +117,1 @@\n-            throw new RuntimeException(\"Use -Dtest.previous.jdk or -Dtest.boot.jdk to specify a \" +\n+            throw new SkippedException(\"Use -Dtest.previous.jdk or -Dtest.boot.jdk to specify a \" +\n@@ -104,1 +141,0 @@\n-        assertJSAVersionMismatch(output);\n@@ -112,1 +148,0 @@\n-        assertJSAVersionMismatch(output);\n@@ -137,4 +172,0 @@\n-    static void assertJSAVersionMismatch(OutputAnalyzer output) {\n-        output.shouldContain(\"does not match the required version\");\n-    }\n-\n@@ -144,0 +175,69 @@\n+\n+    \/\/ Fetch JDK artifact depending on platform\n+    \/\/ If the artifact cannot be found, default to the test.boot.jdk property\n+    private static String fetchOldJDK(int version) {\n+        int build;\n+        String architecture;\n+        HashMap<String, Object> jdkArtifactMap = new HashMap<>();\n+        jdkArtifactMap.put(\"server\", \"jpg\");\n+        jdkArtifactMap.put(\"product\", \"jdk\");\n+\n+        \/\/ Select the correct release build number for each version\n+        \/\/ *UPDATE THIS* after each release\n+        switch(version) {\n+            case 19:\n+                build = 36;\n+                break;\n+            case 20:\n+                build = 29;\n+                break;\n+            default:\n+                build = 0;\n+                break;\n+        }\n+        jdkArtifactMap.put(\"version\", version);\n+        jdkArtifactMap.put(\"build_number\", build);\n+\n+        \/\/ Get correct file name for architecture\n+        if (Platform.isX64()) {\n+            architecture = \"x\";\n+        } else if (Platform.isAArch64()) {\n+            architecture = \"aarch\";\n+        } else {\n+            return DEFAULT_OLD_JDK;\n+        }\n+\n+        \/\/ File name is bundles\/<os>-<architecture>64\/jdk-<version>_<os>-<architecture>64_bin.<extension>\n+        \/\/ Ex: bundles\/linux-x64\/jdk-19_linux-x64_bin.tar.gz\n+        if (Platform.isWindows()) {\n+            jdkArtifactMap.put(\"file\", \"bundles\/windows-x64\/jdk-\" + version + \"_windows-x64_bin.zip\");\n+            return fetchOldJDK(jdkArtifactMap, version);\n+        } else if (Platform.isOSX()) {\n+            jdkArtifactMap.put(\"file\", \"bundles\/macos-\" + architecture + \"64\/jdk-\" + version + \"_macos-\" + architecture + \"64_bin.tar.gz\");\n+            return fetchOldJDK(jdkArtifactMap, version) +  \".jdk\" + FS + \"Contents\" + FS + \"Home\";\n+        } else if (Platform.isLinux()) {\n+            jdkArtifactMap.put(\"file\", \"bundles\/linux-\" + architecture + \"64\/jdk-\" + version + \"_linux-\" + architecture + \"64_bin.tar.gz\");\n+            return fetchOldJDK(jdkArtifactMap, version);\n+        } else {\n+            return DEFAULT_OLD_JDK;\n+        }\n+    }\n+\n+    \/\/ Fetch JDK artifact\n+    private static String fetchOldJDK(HashMap<String, Object> jdkArtifactMap, int version) {\n+        String path = DEFAULT_OLD_JDK;\n+        try {\n+            path = ArtifactResolver.resolve(\"jdk\", jdkArtifactMap, true) + \"\/jdk-\" + version;\n+            System.out.println(\"Boot JDK path: \" + path);\n+        } catch (ArtifactResolverException e) {\n+            Throwable cause = e.getCause();\n+            if (cause == null) {\n+                System.out.println(\"Cannot resolve artifact, \"\n+                        + \"please check if JIB jar is present in classpath.\");\n+            } else {\n+                throw new RuntimeException(\"Fetch artifact failed: \"\n+                        + \"\\nPlease make sure the artifact is available.\", e);\n+            }\n+        }\n+        return path;\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveUpgrade.java","additions":115,"deletions":15,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.Map;\n@@ -30,0 +31,1 @@\n+    Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) throws ArtifactResolverException;\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/ArtifactManager.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,18 @@\n+    public static Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) throws ArtifactResolverException {\n+        ArtifactManager manager;\n+        try {\n+            String managerName = System.getProperty(\"jdk.test.lib.artifacts.artifactmanager\");\n+            if (managerName != null) {\n+                manager = (ArtifactManager) Class.forName(managerName).newInstance();\n+            } else if (System.getenv().containsKey(JibArtifactManager.JIB_HOME_ENV_NAME)) {\n+                manager = JibArtifactManager.newInstance();\n+            } else {\n+                manager = new DefaultArtifactManager();\n+            }\n+        } catch (Exception e) {\n+            throw new ArtifactResolverException(\"Failed to load ArtifactManager\", e);\n+        }\n+\n+        return  manager.resolve(name, artifactDescription, unpack);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/ArtifactResolver.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Map;\n@@ -43,0 +44,7 @@\n+\n+    \/\/ Unused\n+    @Override\n+    public Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) {\n+        return null;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/DefaultArtifactManager.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,1 @@\n+    @Override\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/JibArtifactManager.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}