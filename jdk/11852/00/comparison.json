{"files":[{"patch":"@@ -1,197 +0,0 @@\n-#!\/bin\/bash\n-#\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# This script installs the JIB tool into it's own local repository and\n-# puts a wrapper scripts into <source-root>\/.jib\n-\n-mydir=\"$(dirname \"${BASH_SOURCE[0]}\")\"\n-myname=\"$(basename \"${BASH_SOURCE[0]}\")\"\n-\n-installed_jib_script=${mydir}\/..\/.jib\/jib\n-install_data=${mydir}\/..\/.jib\/.data\n-\n-setup_url() {\n-    if [ -f ~\/.config\/jib\/jib.conf ]; then\n-        source ~\/.config\/jib\/jib.conf\n-    fi\n-\n-    jib_repository=\"jdk-virtual\"\n-    jib_organization=\"jpg\/infra\/builddeps\"\n-    jib_module=\"jib\"\n-    jib_revision=\"3.0-SNAPSHOT\"\n-    jib_ext=\"jib.sh.gz\"\n-\n-    closed_script=\"${mydir}\/..\/..\/closed\/make\/conf\/jib-install.conf\"\n-    if [ -f \"${closed_script}\" ]; then\n-        source \"${closed_script}\"\n-    fi\n-\n-    if [ -n \"${JIB_SERVER}\" ]; then\n-        jib_server=\"${JIB_SERVER}\"\n-    fi\n-    if [ -n \"${JIB_SERVER_MIRRORS}\" ]; then\n-        jib_server_mirrors=\"${JIB_SERVER_MIRRORS}\"\n-    fi\n-    if [ -n \"${JIB_REPOSITORY}\" ]; then\n-        jib_repository=\"${JIB_REPOSITORY}\"\n-    fi\n-    if [ -n \"${JIB_ORGANIZATION}\" ]; then\n-        jib_organization=\"${JIB_ORGANIZATION}\"\n-    fi\n-    if [ -n \"${JIB_MODULE}\" ]; then\n-        jib_module=\"${JIB_MODULE}\"\n-    fi\n-    if [ -n \"${JIB_REVISION}\" ]; then\n-        jib_revision=\"${JIB_REVISION}\"\n-    fi\n-    if [ -n \"${JIB_EXTENSION}\" ]; then\n-        jib_extension=\"${JIB_EXTENSION}\"\n-    fi\n-\n-    if [ -n \"${JIB_URL}\" ]; then\n-        jib_url=\"${JIB_URL}\"\n-        data_string=\"${jib_url}\"\n-    else\n-        jib_path=\"${jib_repository}\/${jib_organization}\/${jib_module}\/${jib_revision}\/${jib_module}-${jib_revision}.${jib_ext}\"\n-        data_string=\"${jib_path}\"\n-        jib_url=\"${jib_server}\/${jib_path}\"\n-    fi\n-}\n-\n-install_jib() {\n-    if [ -z \"${jib_server}\" -a -z \"${JIB_URL}\" ]; then\n-        echo \"No jib server or URL provided, set either\"\n-        echo \"JIB_SERVER=<base server address>\"\n-        echo \"or\"\n-        echo \"JIB_URL=<full path to install script>\"\n-        exit 1\n-    fi\n-\n-    if command -v curl > \/dev\/null; then\n-        getcmd=\"curl -s -L --retry 3 --retry-delay 5\"\n-    elif command -v wget > \/dev\/null; then\n-        getcmd=\"wget --quiet -O -\"\n-    else\n-        echo \"Could not find either curl or wget\"\n-        exit 1\n-    fi\n-\n-    if ! command -v gunzip > \/dev\/null; then\n-        echo \"Could not find gunzip\"\n-        exit 1\n-    fi\n-\n-    echo \"Downloading JIB bootstrap script\"\n-    mkdir -p \"${installed_jib_script%\/*}\"\n-    rm -f \"${installed_jib_script}.gz\"\n-    ${getcmd} ${jib_url} > \"${installed_jib_script}.gz\"\n-    if [ ! -s \"${installed_jib_script}.gz\" ]; then\n-        echo \"Failed to download ${jib_url}\"\n-        if [ -n \"${jib_path}\" -a -n \"${jib_server_mirrors}\" ]; then\n-            OLD_IFS=\"${IFS}\"\n-            IFS=\" ,\"\n-            for mirror in ${jib_server_mirrors}; do\n-                echo \"Trying mirror ${mirror}\"\n-                jib_url=\"${mirror}\/${jib_path}\"\n-                ${getcmd} ${jib_url} > \"${installed_jib_script}.gz\"\n-                if [ -s \"${installed_jib_script}.gz\" ]; then\n-                    echo \"Download from mirror successful\"\n-                    break\n-                else\n-                    echo \"Failed to download ${jib_url}\"\n-                fi\n-            done\n-            IFS=\"${OLD_IFS}\"\n-        fi\n-        if [ ! -s \"${installed_jib_script}.gz\" ]; then\n-            exit 1\n-        fi\n-    fi\n-    # Want to check the filetype using file, to see if we got served a HTML error page.\n-    # This is sensitive to the filename containing a specific string, but good enough.\n-    file ${installed_jib_script}.gz | grep \"gzip compressed data\" > \/dev\/null\n-    if [ $? -ne 0 ]; then \n-        echo \"Warning: ${installed_jib_script}.gz is not a gzip file.\"\n-        echo \"If you are behind a proxy you may need to configure exceptions using no_proxy.\"\n-        echo \"The download URL was: ${jib_url}\"\n-        exit 1\n-    fi\n-    echo \"Extracting JIB bootstrap script\"\n-    rm -f \"${installed_jib_script}\"\n-    gunzip \"${installed_jib_script}.gz\"\n-    chmod +x \"${installed_jib_script}\"\n-    echo \"${data_string}\" > \"${install_data}\"\n-}\n-\n-# Returns a shell-escaped version of the argument given.\n-shell_quote() {\n-  if [[ -n \"$1\" ]]; then\n-    # Uses only shell-safe characters?  No quoting needed.\n-    # '=' is a zsh meta-character, but only in word-initial position.\n-    if echo \"$1\" | grep '^[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\.:,%\/+=_-]\\{1,\\}$' > \/dev\/null \\\n-        && ! echo \"$1\" | grep '^=' > \/dev\/null; then\n-      quoted=\"$1\"\n-    else\n-      if echo \"$1\" | grep \"[\\'!]\" > \/dev\/null; then\n-        # csh does history expansion within single quotes, but not\n-        # when backslash-escaped!\n-        local quoted_quote=\"'\\\\''\" quoted_exclam=\"'\\\\!'\"\n-        word=\"${1\/\/\\'\/${quoted_quote}}\"\n-        word=\"${1\/\/\\!\/${quoted_exclam}}\"\n-      fi\n-      quoted=\"'$1'\"\n-    fi\n-    echo \"$quoted\"\n-  fi\n-}\n-\n-# Main body starts here\n-\n-setup_url\n-\n-if [ ! -x \"${installed_jib_script}\" ]; then\n-    install_jib\n-elif [ ! -e \"${install_data}\" ] || [ \"${data_string}\" != \"$(cat \"${install_data}\")\" ]; then\n-    echo \"Install url changed since last time, reinstalling\"\n-    install_jib\n-fi\n-\n-# Provide a reasonable default for the --src-dir parameter if run out of tree\n-if [ -z \"${JIB_SRC_DIR}\" ]; then\n-    export JIB_SRC_DIR=\"${mydir}\/..\/\"\n-fi\n-\n-\n-# Save the original command line\n-conf_quoted_arguments=()\n-for conf_option; do\n-  conf_quoted_arguments=(\"${conf_quoted_arguments[@]}\" \"$(shell_quote \"$conf_option\")\")\n-done\n-export REAL_CONFIGURE_COMMAND_LINE=\"${conf_quoted_arguments[@]}\"\n-\n-myfulldir=\"$(cd \"${mydir}\" > \/dev\/null && pwd)\"\n-export REAL_CONFIGURE_COMMAND_EXEC_FULL=\"$BASH $myfulldir\/$myname\"\n-export REAL_CONFIGURE_COMMAND_EXEC_SHORT=\"$myname\"\n-\n-${installed_jib_script} \"$@\"\n","filename":"bin\/jib.sh","additions":0,"deletions":197,"binary":false,"changes":197,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires os.family == \"linux\" & vm.bits == \"64\" & (os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cds\n@@ -37,0 +37,4 @@\n+import java.util.Properties;\n+import jdk.test.lib.artifacts.Artifact;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.artifacts.ArtifactResolverException;\n@@ -41,0 +45,2 @@\n+import java.util.HashMap;\n+\n@@ -42,0 +48,3 @@\n+\n+    static final Properties props = System.getProperties();\n+\n@@ -51,2 +60,4 @@\n-    \/\/ the test.boot.jdk property is passed by make\/RunTests.gmk\n-    private static final String BOOT_JDK = System.getProperty(\"test.boot.jdk\", null);\n+    \/\/ the test.boot.jdk property is normally passed by make\/RunTests.gmk\n+    \/\/ now it is pulled by the artifactory\n+    private static String BOOT_JDK;\n+    private static String DEFAULT_BOOT_JDK = System.getProperty(\"test.boot.jdk\", null);\n@@ -64,2 +75,11 @@\n-        setupJVMs();\n-        doTest();\n+        \/\/ Get OS and CPU type\n+        String arch = props.getProperty(\"os.arch\");\n+        String os = getOsId();\n+\n+        \/\/ Earliest testable version is 19\n+        int n = java.lang.Runtime.version().major() - 1;\n+        for (int i = 19; i < n; i++) {\n+            BOOT_JDK = fetchBootJDK(os, arch, i);\n+            setupJVMs(os);\n+            doTest();\n+        }\n@@ -68,1 +88,1 @@\n-    static void setupJVMs() throws Throwable {\n+    static void setupJVMs(String os) throws Throwable {\n@@ -75,0 +95,1 @@\n+        \/\/ Example path: bundles\/linux-x64\/jdk-19_linux-x64_bin.tar.gz\/jdk-19\/bin\/java\n@@ -78,1 +99,3 @@\n-            oldJVM = BOOT_JDK + FS + \"bin\" + FS + \"java\";\n+            oldJVM = (os == \"MacOSX\") ?\n+                BOOT_JDK + \".jdk\" + FS + \"Contents\" + FS + \"Home\" + FS + \"bin\" + FS + \"java\" :\n+                BOOT_JDK + FS + \"bin\" + FS + \"java\";\n@@ -144,0 +167,90 @@\n+\n+    \/\/ Fetch JDK artifact depending on platform\n+    \/\/ If the artifact cannot be found, default to the test.boot.jdk property\n+    private static String fetchBootJDK(String osID, String arch, int version) {\n+        int build;\n+        String architecture;\n+        HashMap<String, Object> jdkArtifactMap = new HashMap<>();\n+        jdkArtifactMap.put(\"server\", \"jpg\");\n+        jdkArtifactMap.put(\"product\", \"jdk\");\n+\n+        \/\/ Select the correct release build number for each version\n+        \/\/ *UPDATE THIS* after each release\n+        switch(version) {\n+            case 19:\n+                build = 36;\n+                break;\n+            case 20:\n+                build = 29;\n+                break;\n+            default:\n+                build = 0;\n+                break;\n+        }\n+        \/\/ Get correct file name for architecture\n+        switch(arch) {\n+            case(\"x86\"):\n+            case(\"x86_64\"):\n+            case(\"amd64\"):\n+                architecture = \"x\";\n+                break;\n+            case(\"aarch64\"):\n+                architecture = \"aarch\";\n+                break;\n+            default:\n+                architecture = \"\";\n+                break;\n+        }\n+        \/\/ File name is bundles\/<os>-<architecture>64\/jdk-<version>_<os>-<architecture>64_bin.<extension>\n+        \/\/ Ex: bundles\/linux-x64\/jdk-19_linux-x64_bin.tar.gz\n+        switch (osID) {\n+            case \"Windows\":\n+                jdkArtifactMap.put(\"version\", version);\n+                jdkArtifactMap.put(\"build_number\", build);\n+                jdkArtifactMap.put(\"file\", \"bundles\/windows-x64\/jdk-\" + version + \"_windows-x64_bin.zip\");\n+                return fetchBootJDK(jdkArtifactMap, version);\n+\n+            case \"MacOSX\":\n+                jdkArtifactMap.put(\"version\", version);\n+                jdkArtifactMap.put(\"build_number\", build);\n+                jdkArtifactMap.put(\"file\", \"bundles\/macos-\" + architecture + \"64\/jdk-\" + version + \"_macos-\" + architecture + \"64_bin.tar.gz\");\n+                return fetchBootJDK(jdkArtifactMap, version);\n+            case \"Linux\":\n+                jdkArtifactMap.put(\"version\", version);\n+                jdkArtifactMap.put(\"build_number\", build);\n+                jdkArtifactMap.put(\"file\", \"bundles\/linux-\" + architecture + \"64\/jdk-\" + version + \"_linux-\" + architecture + \"64_bin.tar.gz\");\n+                return fetchBootJDK(jdkArtifactMap, version);\n+\n+            default:\n+                return DEFAULT_BOOT_JDK;\n+        }\n+    }\n+\n+    \/\/ Fetch JDK version from artifactory\n+    private static String fetchBootJDK(HashMap<String, Object> jdkArtifactMap, int version) {\n+        String path = DEFAULT_BOOT_JDK;\n+        try {\n+            path = ArtifactResolver.resolve(\"jdk\", jdkArtifactMap, true) + \"\/jdk-\" + version;\n+            System.out.println(\"Boot JDK path: \" + path);\n+        } catch (ArtifactResolverException e) {\n+            Throwable cause = e.getCause();\n+            if (cause == null) {\n+                System.out.println(\"Cannot resolve artifact, \"\n+                        + \"please check if JIB jar is present in classpath.\");\n+            } else {\n+                throw new RuntimeException(\"Fetch artifact failed: \"\n+                        + \"\\nPlease make sure the artifact is available.\", e);\n+            }\n+        }\n+        return path;\n+    }\n+\n+    private static String getOsId() {\n+        String osName = props.getProperty(\"os.name\");\n+        if (osName.startsWith(\"Win\")) {\n+            osName = \"Windows\";\n+        } else if (osName.equals(\"Mac OS X\")) {\n+            osName = \"MacOSX\";\n+        }\n+        return osName;\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveUpgrade.java","additions":121,"deletions":8,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -32,4 +32,4 @@\n-    String organization();\n-    String name();\n-    String revision();\n-    String extension();\n+    String organization() default \"\";\n+    String name() default \"\";\n+    String revision() default \"\";\n+    String extension() default \"\";\n@@ -38,0 +38,7 @@\n+\n+    \/\/ For getting jdk versions\n+    String server() default \"\";\n+    String product() default \"\";\n+    int version() default 0;\n+    int build_number() default 0;\n+    String file() default \"\";\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/Artifact.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.Map;\n@@ -30,0 +31,1 @@\n+    Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) throws ArtifactResolverException;\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/ArtifactManager.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,18 @@\n+    public static Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) throws ArtifactResolverException {\n+        ArtifactManager manager;\n+        try {\n+            String managerName = System.getProperty(\"jdk.test.lib.artifacts.artifactmanager\");\n+            if (managerName != null) {\n+                manager = (ArtifactManager) Class.forName(managerName).newInstance();\n+            } else if (System.getenv().containsKey(JibArtifactManager.JIB_HOME_ENV_NAME)) {\n+                manager = JibArtifactManager.newInstance();\n+            } else {\n+                manager = new DefaultArtifactManager();\n+            }\n+        } catch (Exception e) {\n+            throw new ArtifactResolverException(\"Failed to load ArtifactManager\", e);\n+        }\n+\n+        return  manager.resolve(name, artifactDescription, unpack);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/ArtifactResolver.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Map;\n@@ -43,0 +44,7 @@\n+\n+    \/\/ Unused\n+    @Override\n+    public Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) {\n+        return null;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/DefaultArtifactManager.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,4 +117,13 @@\n-        artifactDescription.put(\"module\", artifact.name());\n-        artifactDescription.put(\"organization\", artifact.organization());\n-        artifactDescription.put(\"ext\", artifact.extension());\n-        artifactDescription.put(\"revision\", artifact.revision());\n+        if (artifact.server().equals(\"jpg\")) {\n+            artifactDescription.put(\"server\", artifact.server());\n+            artifactDescription.put(\"product\", artifact.product());\n+            artifactDescription.put(\"version\", artifact.version());\n+            artifactDescription.put(\"build_number\", artifact.build_number());\n+            artifactDescription.put(\"file\", artifact.file());\n+        } else {\n+            artifactDescription.put(\"module\", artifact.name());\n+            artifactDescription.put(\"organization\", artifact.organization());\n+            artifactDescription.put(\"ext\", artifact.extension());\n+            artifactDescription.put(\"revision\", artifact.revision());\n+        }\n+\n@@ -127,0 +136,1 @@\n+    @Override\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/JibArtifactManager.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}