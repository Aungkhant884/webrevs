{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires os.family == \"linux\" & vm.bits == \"64\" & (os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cds & vm.bits == \"64\"\n@@ -37,0 +37,3 @@\n+import java.util.HashMap;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.artifacts.ArtifactResolverException;\n@@ -38,0 +41,1 @@\n+import jdk.test.lib.Platform;\n@@ -40,0 +44,1 @@\n+import jtreg.SkippedException;\n@@ -42,0 +47,1 @@\n+\n@@ -51,2 +57,6 @@\n-    \/\/ the test.boot.jdk property is passed by make\/RunTests.gmk\n-    private static final String BOOT_JDK = System.getProperty(\"test.boot.jdk\", null);\n+    \/\/ the test.boot.jdk property is normally passed by make\/RunTests.gmk\n+    private static String BOOT_JDK = System.getProperty(\"test.boot.jdk\", null);\n+\n+    \/\/ Comma separated list of JDK major versions that will be tested\n+    \/\/ If null, BOOT_JDK will be tested\n+    private static String JDK_VERSIONS = System.getProperty(\"test.autocreatesharedarchive.jdk.version\", null);\n@@ -64,2 +74,23 @@\n-        setupJVMs();\n-        doTest();\n+        \/\/ Earliest testable version is 19\n+        \/\/ Only run once if using the default boot jdk\n+        int n = java.lang.Runtime.version().major();\n+\n+        \/\/ Test only default version unless specified in gmk\n+        if (JDK_VERSIONS == null) {\n+            setupJVMs(0);\n+            doTest();\n+            return;\n+        }\n+\n+        String[] versions = JDK_VERSIONS.split(\",\");\n+        boolean is_default = false;\n+        for (int i = 0; i < versions.length && !is_default; i++) {\n+            System.out.println(\"Testing JDK: \" + versions[i]);\n+            try {\n+                \/\/ If boot JDK runs because old JDK is not found, only run once\n+                is_default = setupJVMs(Integer.parseInt(versions[i]));\n+                doTest();\n+            } catch (NumberFormatException e) {\n+                throw new RuntimeException(\"Invalid AutoCreateSharedArchive JDK version: \" + versions[i]);\n+            }\n+        }\n@@ -68,1 +99,2 @@\n-    static void setupJVMs() throws Throwable {\n+    static boolean setupJVMs(int fetchVersion) throws Throwable {\n+        boolean is_default = true;\n@@ -75,1 +107,6 @@\n-        if (PREV_JDK != null) {\n+        \/\/ Example path: bundles\/linux-x64\/jdk-19_linux-x64_bin.tar.gz\/jdk-19\/bin\/java\n+        if (fetchVersion >= 19) {\n+            oldJVM = fetchJDK(fetchVersion) + FS + \"bin\" + FS + \"java\";\n+            if (!oldJVM.equals(BOOT_JDK + FS + \"bin\" + FS + \"java\"))\n+                is_default = false;\n+        } else if (PREV_JDK != null) {\n@@ -80,1 +117,1 @@\n-            throw new RuntimeException(\"Use -Dtest.previous.jdk or -Dtest.boot.jdk to specify a \" +\n+            throw new SkippedException(\"Use -Dtest.previous.jdk or -Dtest.boot.jdk to specify a \" +\n@@ -87,0 +124,1 @@\n+        return is_default;\n@@ -104,1 +142,0 @@\n-        assertJSAVersionMismatch(output);\n@@ -112,1 +149,0 @@\n-        assertJSAVersionMismatch(output);\n@@ -137,4 +173,0 @@\n-    static void assertJSAVersionMismatch(OutputAnalyzer output) {\n-        output.shouldContain(\"does not match the required version\");\n-    }\n-\n@@ -144,0 +176,69 @@\n+\n+    \/\/ Fetch JDK artifact depending on platform\n+    \/\/ If the artifact cannot be found, default to the test.boot.jdk property\n+    private static String fetchJDK(int version) {\n+        int build;\n+        String architecture;\n+        HashMap<String, Object> jdkArtifactMap = new HashMap<>();\n+        jdkArtifactMap.put(\"server\", \"jpg\");\n+        jdkArtifactMap.put(\"product\", \"jdk\");\n+\n+        \/\/ Select the correct release build number for each version\n+        \/\/ *UPDATE THIS* after each release\n+        switch(version) {\n+            case 19:\n+                build = 36;\n+                break;\n+            case 20:\n+                build = 29;\n+                break;\n+            default:\n+                build = 0;\n+                break;\n+        }\n+        jdkArtifactMap.put(\"version\", version);\n+        jdkArtifactMap.put(\"build_number\", build);\n+\n+        \/\/ Get correct file name for architecture\n+        if (Platform.isX64()) {\n+            architecture = \"x\";\n+        } else if (Platform.isAArch64()) {\n+            architecture = \"aarch\";\n+        } else {\n+            return BOOT_JDK;\n+        }\n+\n+        \/\/ File name is bundles\/<os>-<architecture>64\/jdk-<version>_<os>-<architecture>64_bin.<extension>\n+        \/\/ Ex: bundles\/linux-x64\/jdk-19_linux-x64_bin.tar.gz\n+        if (Platform.isWindows()) {\n+            jdkArtifactMap.put(\"file\", \"bundles\/windows-x64\/jdk-\" + version + \"_windows-x64_bin.zip\");\n+            return fetchJDK(jdkArtifactMap, version);\n+        } else if (Platform.isOSX()) {\n+            jdkArtifactMap.put(\"file\", \"bundles\/macos-\" + architecture + \"64\/jdk-\" + version + \"_macos-\" + architecture + \"64_bin.tar.gz\");\n+            return fetchJDK(jdkArtifactMap, version) +  \".jdk\" + FS + \"Contents\" + FS + \"Home\";\n+        } else if (Platform.isLinux()) {\n+            jdkArtifactMap.put(\"file\", \"bundles\/linux-\" + architecture + \"64\/jdk-\" + version + \"_linux-\" + architecture + \"64_bin.tar.gz\");\n+            return fetchJDK(jdkArtifactMap, version);\n+        } else {\n+            return BOOT_JDK;\n+        }\n+    }\n+\n+    \/\/ Fetch JDK artifact\n+    private static String fetchJDK(HashMap<String, Object> jdkArtifactMap, int version) {\n+        String path = BOOT_JDK;\n+        try {\n+            path = ArtifactResolver.resolve(\"jdk\", jdkArtifactMap, true) + \"\/jdk-\" + version;\n+            System.out.println(\"Boot JDK path: \" + path);\n+        } catch (ArtifactResolverException e) {\n+            Throwable cause = e.getCause();\n+            if (cause == null) {\n+                System.out.println(\"Cannot resolve artifact, \"\n+                        + \"please check if JIB jar is present in classpath.\");\n+            } else {\n+                throw new RuntimeException(\"Fetch artifact failed: \"\n+                        + \"\\nPlease make sure the artifact is available.\", e);\n+            }\n+        }\n+        return path;\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveUpgrade.java","additions":116,"deletions":15,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.Map;\n@@ -30,0 +31,1 @@\n+    Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) throws ArtifactResolverException;\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/ArtifactManager.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-    public static Map<String, Path> resolve(Class<?> klass) throws ArtifactResolverException {\n+    private static ArtifactManager getManager() throws ArtifactResolverException {\n@@ -45,0 +45,2 @@\n+        return manager;\n+    }\n@@ -46,0 +48,2 @@\n+    public static Map<String, Path> resolve(Class<?> klass) throws ArtifactResolverException {\n+        ArtifactManager manager = getManager();\n@@ -62,0 +66,5 @@\n+    public static Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) throws ArtifactResolverException {\n+        ArtifactManager manager = getManager();\n+        return  manager.resolve(name, artifactDescription, unpack);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/ArtifactResolver.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Map;\n@@ -43,0 +44,7 @@\n+\n+    \/\/ Unused\n+    @Override\n+    public Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) {\n+        return null;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/DefaultArtifactManager.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,1 @@\n+    @Override\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/JibArtifactManager.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}