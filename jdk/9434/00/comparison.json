{"files":[{"patch":"@@ -66,1 +66,1 @@\n-        if (!sun.hotspot.code.Compiler.isC1Enabled()) {\n+        if (!jdk.test.whitebox.code.Compiler.isC1Enabled()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/AbstractRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        if (!sun.hotspot.code.Compiler.isC1Enabled()) {\n+        if (!jdk.test.whitebox.code.Compiler.isC1Enabled()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-import sun.hotspot.code.BlobType;\n-import sun.hotspot.code.CodeBlob;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.CodeBlob;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/OverflowCodeCacheTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/TestSegmentedCodeCacheOption.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/CodeCacheFreeSpaceRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/GenericCodeHeapSizeRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/JVMStartupRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/TestCodeHeapSizeOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheCLITestCase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheInfoFormatter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/printcodecache\/PrintCodeCacheRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/printcodecache\/TestPrintCodeCacheOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/BeanTypeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import sun.hotspot.code.BlobType;\n-import sun.hotspot.code.CodeBlob;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.CodeBlob;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/CodeCacheUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/CodeHeapBeanPresenceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/GetUsageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/InitialAndMaxUsageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/ManagerNamesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/MemoryPoolsPresenceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/PeakUsageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/PoolsIndependenceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/ThresholdNotificationsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdExceededTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdIncreasedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdNotExceededTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/RandomAllocationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/ReturnBlobToWrongHeapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/TestAESMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/TestCipherBlockChainingEncrypt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestAndnI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestAndnL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsiI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsiL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsmskI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsmskL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsrI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsrL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBzhiI2L.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestLzcntI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestLzcntL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestTzcntI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestTzcntL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n-import sun.hotspot.code.NMethod;\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.code.NMethod;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BmiIntrinsicBase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/CastNullCheckDroppingsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/AllocateCompileIdTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/CompileCodeTestCase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/DisassembleCodeBlobTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ExecuteInstalledCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/HasCompiledCodeForOSRTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/InvalidateInstalledCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/onSpinWait\/TestOnSpinWaitAArch64DefaultFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeGetStableArrayElement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/AllocationCodeBlobTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/CompilerWhiteBoxTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeFramesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/ForceNMethodSweepTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-import sun.hotspot.code.BlobType;\n-import sun.hotspot.code.CodeBlob;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.CodeBlob;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/GetCodeHeapEntriesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-import sun.hotspot.code.BlobType;\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/GetNMethodTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/TestConcurrentGCBreakpoints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/TestJNIWeak\/TestJNIWeak.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/TestSmallHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelGCThreads.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelRefProc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/ergonomics\/TestDynamicNumberOfGCThreads.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/ergonomics\/TestInitialGCThreadLogging.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -43,2 +43,2 @@\n-import sun.hotspot.WhiteBox;\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerificationInConcurrentCycle.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/logging\/TestGCId.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n@@ -43,1 +43,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/UseCompressedOops.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-import sun.hotspot.code.Compiler;\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.code.Compiler;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/runtime\/MemberName\/MemberNameLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CommandLineFlagCombo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,2 +134,2 @@\n-    \/\/ we support only jdk\/test\/whitebox\/WhiteBox$WhiteBoxPermission and\n-    \/\/ sun\/hotspot\/WhiteBox$WhiteBoxPermission. See JDK-8199290\n+    \/\/ we support only jdk\/test\/whitebox\/WhiteBox$WhiteBoxPermission.\n+    \/\/ See JDK-8199290\n@@ -139,2 +139,0 @@\n-        boolean seenOldWb = false;\n-        boolean seenOldWbInner = false;\n@@ -145,2 +143,0 @@\n-        final String oldWb = \"sun\/hotspot\/WhiteBox\";\n-        final String oldWbInner = oldWb + \"$WhiteBoxPermission\";\n@@ -156,2 +152,0 @@\n-            case oldWb:      seenOldWb      = true; break;\n-            case oldWbInner: seenOldWbInner = true; break;\n@@ -163,4 +157,0 @@\n-        if (seenOldWb && !seenOldWbInner) {\n-            list.add(oldWbInner);\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/JarBuilder.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/CDSStreamTestDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/MainModuleOnly.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/MainModuleOnly.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-import sun.hotspot.code.Compiler;\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.code.Compiler;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/IncompatibleOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/runtime\/stringtable\/StringTableCleaningTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n@@ -32,1 +32,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestUniverse.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n@@ -66,1 +66,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF08\/gf08t001\/TestDriver.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-import sun.hotspot.gc.GC;\n+import jdk.test.whitebox.gc.GC;\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/CollectionUsageThreshold.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/LowMemoryTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import sun.hotspot.code.Compiler;\n+import jdk.test.whitebox.code.Compiler;\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/ResetPeakMemoryUsage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import sun.hotspot.code.BlobType;\n+import jdk.test.whitebox.code.BlobType;\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeCacheFull.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-import sun.hotspot.code.BlobType;\n-import sun.hotspot.code.CodeBlob;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.CodeBlob;\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeSweeper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-import sun.hotspot.code.NMethod;\n+import jdk.test.whitebox.code.NMethod;\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJFRIntrinsic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test id=without-inner-class\n- * @summary verify that sun.hotspot.WhiteBox class still can be used\n- * @library \/test\/lib\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI OldWhiteBox\n- *\/\n-\n-\/*\n- * @test id=with-inner-class\n- * @summary verify that sun.hotspot.WhiteBox class still can be used\n- * @library \/test\/lib\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI OldWhiteBox\n- *\/\n-\n-import sun.hotspot.WhiteBox;\n-\n-public class OldWhiteBox {\n-    public static void main(String[] args) {\n-        @SuppressWarnings(\"deprecation\")\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        if (wb.getHeapOopSize() < 0) {\n-            throw new Error(\"wb.getHeapOopSize() < 0\");\n-        }\n-    }\n-}\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/OldWhiteBox.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import sun.hotspot.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n","filename":"test\/lib\/jdk\/test\/lib\/cli\/predicate\/CPUSpecificPredicate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,2 +103,2 @@\n-    \/\/ we support only jdk.test.whitebox.WhiteBox$WhiteBoxPermission and\n-    \/\/ jdk\/test\/whitebox\/WhiteBox$WhiteBoxPermission. See JDK-8199290\n+    \/\/ we support only jdk.test.whitebox.WhiteBox$WhiteBoxPermission.\n+    \/\/ See JDK-8199290\n@@ -108,2 +108,0 @@\n-        boolean seenOldWb = false;\n-        boolean seenOldWbInner = false;\n@@ -112,2 +110,0 @@\n-        final String oldWb = \"sun.hotspot.WhiteBox\";\n-        final String oldWbInner = oldWb + \"$WhiteBoxPermission\";\n@@ -123,2 +119,0 @@\n-            case oldWb:      seenOldWb      = true; break;\n-            case oldWbInner: seenOldWbInner = true; break;\n@@ -130,4 +124,0 @@\n-        if (seenOldWb && !seenOldWbInner) {\n-            list.add(oldWbInner);\n-        }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/helpers\/ClassFileInstaller.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,698 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.hotspot;\n-\n-import java.lang.management.MemoryUsage;\n-import java.lang.reflect.Executable;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.function.BiFunction;\n-import java.util.function.Function;\n-import java.security.BasicPermission;\n-import java.util.Objects;\n-\n-import jdk.test.whitebox.parser.DiagnosticCommand;\n-\n-@Deprecated\n-public class WhiteBox {\n-  @SuppressWarnings(\"serial\")\n-  public static class WhiteBoxPermission extends BasicPermission {\n-    public WhiteBoxPermission(String s) {\n-      super(s);\n-    }\n-  }\n-\n-  private WhiteBox() {}\n-  private static final WhiteBox instance = new WhiteBox();\n-  private static native void registerNatives();\n-\n-  \/**\n-   * Returns the singleton WhiteBox instance.\n-   *\n-   * The returned WhiteBox object should be carefully guarded\n-   * by the caller, since it can be used to read and write data\n-   * at arbitrary memory addresses. It must never be passed to\n-   * untrusted code.\n-   *\/\n-  public synchronized static WhiteBox getWhiteBox() {\n-    @SuppressWarnings(\"removal\")\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null) {\n-      throw new SecurityException(\"can't use old whitebox with SecurityManager, please switch to jdk.test.whitebox.WhiteBox\");\n-    }\n-    return instance;\n-  }\n-\n-  static {\n-    registerNatives();\n-  }\n-\n-  \/\/ Get the maximum heap size supporting COOPs\n-  public native long getCompressedOopsMaxHeapSize();\n-  \/\/ Arguments\n-  public native void printHeapSizes();\n-\n-  \/\/ Memory\n-  private native long getObjectAddress0(Object o);\n-  public           long getObjectAddress(Object o) {\n-    Objects.requireNonNull(o);\n-    return getObjectAddress0(o);\n-  }\n-\n-  public native int  getHeapOopSize();\n-  public native int  getVMPageSize();\n-  public native long getVMAllocationGranularity();\n-  public native long getVMLargePageSize();\n-  public native long getHeapSpaceAlignment();\n-  public native long getHeapAlignment();\n-\n-  private native boolean isObjectInOldGen0(Object o);\n-  public         boolean isObjectInOldGen(Object o) {\n-    Objects.requireNonNull(o);\n-    return isObjectInOldGen0(o);\n-  }\n-\n-  private native long getObjectSize0(Object o);\n-  public         long getObjectSize(Object o) {\n-    Objects.requireNonNull(o);\n-    return getObjectSize0(o);\n-  }\n-\n-  \/\/ Runtime\n-  \/\/ Make sure class name is in the correct format\n-  public int countAliveClasses(String name) {\n-    return countAliveClasses0(name.replace('.', '\/'));\n-  }\n-  private native int countAliveClasses0(String name);\n-\n-  public boolean isClassAlive(String name) {\n-    return countAliveClasses(name) != 0;\n-  }\n-\n-  public  native int getSymbolRefcount(String name);\n-\n-  public native boolean deflateIdleMonitors();\n-\n-  private native boolean isMonitorInflated0(Object obj);\n-  public         boolean isMonitorInflated(Object obj) {\n-    Objects.requireNonNull(obj);\n-    return isMonitorInflated0(obj);\n-  }\n-\n-  public native void forceSafepoint();\n-\n-  private native long getConstantPool0(Class<?> aClass);\n-  public         long getConstantPool(Class<?> aClass) {\n-    Objects.requireNonNull(aClass);\n-    return getConstantPool0(aClass);\n-  }\n-\n-  private native int getConstantPoolCacheIndexTag0();\n-  public         int getConstantPoolCacheIndexTag() {\n-    return getConstantPoolCacheIndexTag0();\n-  }\n-\n-  private native int getConstantPoolCacheLength0(Class<?> aClass);\n-  public         int getConstantPoolCacheLength(Class<?> aClass) {\n-    Objects.requireNonNull(aClass);\n-    return getConstantPoolCacheLength0(aClass);\n-  }\n-\n-  private native int remapInstructionOperandFromCPCache0(Class<?> aClass, int index);\n-  public         int remapInstructionOperandFromCPCache(Class<?> aClass, int index) {\n-    Objects.requireNonNull(aClass);\n-    return remapInstructionOperandFromCPCache0(aClass, index);\n-  }\n-\n-  private native int encodeConstantPoolIndyIndex0(int index);\n-  public         int encodeConstantPoolIndyIndex(int index) {\n-    return encodeConstantPoolIndyIndex0(index);\n-  }\n-\n-  \/\/ JVMTI\n-  private native void addToBootstrapClassLoaderSearch0(String segment);\n-  public         void addToBootstrapClassLoaderSearch(String segment){\n-    Objects.requireNonNull(segment);\n-    addToBootstrapClassLoaderSearch0(segment);\n-  }\n-\n-  private native void addToSystemClassLoaderSearch0(String segment);\n-  public         void addToSystemClassLoaderSearch(String segment) {\n-    Objects.requireNonNull(segment);\n-    addToSystemClassLoaderSearch0(segment);\n-  }\n-\n-  \/\/ G1\n-  public native boolean g1InConcurrentMark();\n-  public native boolean g1HasRegionsToUncommit();\n-  private native boolean g1IsHumongous0(Object o);\n-  public         boolean g1IsHumongous(Object o) {\n-    Objects.requireNonNull(o);\n-    return g1IsHumongous0(o);\n-  }\n-\n-  private native boolean g1BelongsToHumongousRegion0(long adr);\n-  public         boolean g1BelongsToHumongousRegion(long adr) {\n-    if (adr == 0) {\n-      throw new IllegalArgumentException(\"adr argument should not be null\");\n-    }\n-    return g1BelongsToHumongousRegion0(adr);\n-  }\n-\n-\n-  private native boolean g1BelongsToFreeRegion0(long adr);\n-  public         boolean g1BelongsToFreeRegion(long adr) {\n-    if (adr == 0) {\n-      throw new IllegalArgumentException(\"adr argument should not be null\");\n-    }\n-    return g1BelongsToFreeRegion0(adr);\n-  }\n-\n-  public native long    g1NumMaxRegions();\n-  public native long    g1NumFreeRegions();\n-  public native int     g1RegionSize();\n-  public native MemoryUsage g1AuxiliaryMemoryUsage();\n-  private  native Object[]    parseCommandLine0(String commandline, char delim, DiagnosticCommand[] args);\n-  public          Object[]    parseCommandLine(String commandline, char delim, DiagnosticCommand[] args) {\n-    Objects.requireNonNull(args);\n-    return parseCommandLine0(commandline, delim, args);\n-  }\n-\n-  public native int g1ActiveMemoryNodeCount();\n-  public native int[] g1MemoryNodeIds();\n-\n-  \/\/ Parallel GC\n-  public native long psVirtualSpaceAlignment();\n-  public native long psHeapGenerationAlignment();\n-\n-  \/**\n-   * Enumerates old regions with liveness less than specified and produces some statistics\n-   * @param liveness percent of region's liveness (live_objects \/ total_region_size * 100).\n-   * @return long[3] array where long[0] - total count of old regions\n-   *                             long[1] - total memory of old regions\n-   *                             long[2] - lowest estimation of total memory of old regions to be freed (non-full\n-   *                             regions are not included)\n-   *\/\n-  public native long[] g1GetMixedGCInfo(int liveness);\n-\n-  \/\/ NMT\n-  public native long NMTMalloc(long size);\n-  public native void NMTFree(long mem);\n-  public native long NMTReserveMemory(long size);\n-  public native long NMTAttemptReserveMemoryAt(long addr, long size);\n-  public native void NMTCommitMemory(long addr, long size);\n-  public native void NMTUncommitMemory(long addr, long size);\n-  public native void NMTReleaseMemory(long addr, long size);\n-  public native long NMTMallocWithPseudoStack(long size, int index);\n-  public native long NMTMallocWithPseudoStackAndType(long size, int index, int type);\n-  public native int NMTGetHashSize();\n-  public native long NMTNewArena(long initSize);\n-  public native void NMTFreeArena(long arena);\n-  public native void NMTArenaMalloc(long arena, long size);\n-\n-  \/\/ Compiler\n-  public native boolean isC2OrJVMCIIncluded();\n-  public native boolean isJVMCISupportedByGC();\n-\n-  public native int     matchesMethod(Executable method, String pattern);\n-  public native int     matchesInline(Executable method, String pattern);\n-  public native boolean shouldPrintAssembly(Executable method, int comp_level);\n-  public native int     deoptimizeFrames(boolean makeNotEntrant);\n-  public native boolean isFrameDeoptimized(int depth);\n-  public native void    deoptimizeAll();\n-\n-  public        boolean isMethodCompiled(Executable method) {\n-    return isMethodCompiled(method, false \/*not osr*\/);\n-  }\n-  private native boolean isMethodCompiled0(Executable method, boolean isOsr);\n-  public         boolean isMethodCompiled(Executable method, boolean isOsr){\n-    Objects.requireNonNull(method);\n-    return isMethodCompiled0(method, isOsr);\n-  }\n-  public        boolean isMethodCompilable(Executable method) {\n-    return isMethodCompilable(method, -1 \/*any*\/);\n-  }\n-  public        boolean isMethodCompilable(Executable method, int compLevel) {\n-    return isMethodCompilable(method, compLevel, false \/*not osr*\/);\n-  }\n-  private native boolean isMethodCompilable0(Executable method, int compLevel, boolean isOsr);\n-  public         boolean isMethodCompilable(Executable method, int compLevel, boolean isOsr) {\n-    Objects.requireNonNull(method);\n-    return isMethodCompilable0(method, compLevel, isOsr);\n-  }\n-  private native boolean isMethodQueuedForCompilation0(Executable method);\n-  public         boolean isMethodQueuedForCompilation(Executable method) {\n-    Objects.requireNonNull(method);\n-    return isMethodQueuedForCompilation0(method);\n-  }\n-  \/\/ Determine if the compiler corresponding to the compilation level 'compLevel'\n-  \/\/ and to the compilation context 'compilation_context' provides an intrinsic\n-  \/\/ for the method 'method'. An intrinsic is available for method 'method' if:\n-  \/\/  - the intrinsic is enabled (by using the appropriate command-line flag) and\n-  \/\/  - the platform on which the VM is running provides the instructions necessary\n-  \/\/    for the compiler to generate the intrinsic code.\n-  \/\/\n-  \/\/ The compilation context is related to using the DisableIntrinsic flag on a\n-  \/\/ per-method level, see hotspot\/src\/share\/vm\/compiler\/abstractCompiler.hpp\n-  \/\/ for more details.\n-  public boolean isIntrinsicAvailable(Executable method,\n-                                      Executable compilationContext,\n-                                      int compLevel) {\n-      Objects.requireNonNull(method);\n-      return isIntrinsicAvailable0(method, compilationContext, compLevel);\n-  }\n-  \/\/ If usage of the DisableIntrinsic flag is not expected (or the usage can be ignored),\n-  \/\/ use the below method that does not require the compilation context as argument.\n-  public boolean isIntrinsicAvailable(Executable method, int compLevel) {\n-      return isIntrinsicAvailable(method, null, compLevel);\n-  }\n-  private native boolean isIntrinsicAvailable0(Executable method,\n-                                               Executable compilationContext,\n-                                               int compLevel);\n-  public        int     deoptimizeMethod(Executable method) {\n-    return deoptimizeMethod(method, false \/*not osr*\/);\n-  }\n-  private native int     deoptimizeMethod0(Executable method, boolean isOsr);\n-  public         int     deoptimizeMethod(Executable method, boolean isOsr) {\n-    Objects.requireNonNull(method);\n-    return deoptimizeMethod0(method, isOsr);\n-  }\n-  public        void    makeMethodNotCompilable(Executable method) {\n-    makeMethodNotCompilable(method, -1 \/*any*\/);\n-  }\n-  public        void    makeMethodNotCompilable(Executable method, int compLevel) {\n-    makeMethodNotCompilable(method, compLevel, false \/*not osr*\/);\n-  }\n-  private native void    makeMethodNotCompilable0(Executable method, int compLevel, boolean isOsr);\n-  public         void    makeMethodNotCompilable(Executable method, int compLevel, boolean isOsr) {\n-    Objects.requireNonNull(method);\n-    makeMethodNotCompilable0(method, compLevel, isOsr);\n-  }\n-  public        int     getMethodCompilationLevel(Executable method) {\n-    return getMethodCompilationLevel(method, false \/*not osr*\/);\n-  }\n-  private native int     getMethodCompilationLevel0(Executable method, boolean isOsr);\n-  public         int     getMethodCompilationLevel(Executable method, boolean isOsr) {\n-    Objects.requireNonNull(method);\n-    return getMethodCompilationLevel0(method, isOsr);\n-  }\n-  public         int     getMethodDecompileCount(Executable method) {\n-    Objects.requireNonNull(method);\n-    return getMethodDecompileCount0(method);\n-  }\n-  private native int     getMethodDecompileCount0(Executable method);\n-  \/\/ Get the total trap count of a method. If the trap count for a specific reason\n-  \/\/ did overflow, this includes the overflow trap count of the method.\n-  public         int     getMethodTrapCount(Executable method) {\n-    Objects.requireNonNull(method);\n-    return getMethodTrapCount0(method, null);\n-  }\n-  \/\/ Get the trap count of a method for a specific reason. If the trap count for\n-  \/\/ that reason did overflow, this includes the overflow trap count of the method.\n-  public         int     getMethodTrapCount(Executable method, String reason) {\n-    Objects.requireNonNull(method);\n-    return getMethodTrapCount0(method, reason);\n-  }\n-  private native int     getMethodTrapCount0(Executable method, String reason);\n-  \/\/ Get the total deopt count.\n-  public         int     getDeoptCount() {\n-    return getDeoptCount0(null, null);\n-  }\n-  \/\/ Get the deopt count for a specific reason and a specific action. If either\n-  \/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n-  \/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n-  \/\/ If both arguments are null, the method returns the total deopt count.\n-  public         int     getDeoptCount(String reason, String action) {\n-    return getDeoptCount0(reason, action);\n-  }\n-  private native int     getDeoptCount0(String reason, String action);\n-  private native boolean testSetDontInlineMethod0(Executable method, boolean value);\n-  public         boolean testSetDontInlineMethod(Executable method, boolean value) {\n-    Objects.requireNonNull(method);\n-    return testSetDontInlineMethod0(method, value);\n-  }\n-  public        int     getCompileQueuesSize() {\n-    return getCompileQueueSize(-1 \/*any*\/);\n-  }\n-  public native int     getCompileQueueSize(int compLevel);\n-  private native boolean testSetForceInlineMethod0(Executable method, boolean value);\n-  public         boolean testSetForceInlineMethod(Executable method, boolean value) {\n-    Objects.requireNonNull(method);\n-    return testSetForceInlineMethod0(method, value);\n-  }\n-  public        boolean enqueueMethodForCompilation(Executable method, int compLevel) {\n-    return enqueueMethodForCompilation(method, compLevel, -1 \/*InvocationEntryBci*\/);\n-  }\n-  private native boolean enqueueMethodForCompilation0(Executable method, int compLevel, int entry_bci);\n-  public  boolean enqueueMethodForCompilation(Executable method, int compLevel, int entry_bci) {\n-    Objects.requireNonNull(method);\n-    return enqueueMethodForCompilation0(method, compLevel, entry_bci);\n-  }\n-  private native boolean enqueueInitializerForCompilation0(Class<?> aClass, int compLevel);\n-  public  boolean enqueueInitializerForCompilation(Class<?> aClass, int compLevel) {\n-    Objects.requireNonNull(aClass);\n-    return enqueueInitializerForCompilation0(aClass, compLevel);\n-  }\n-  private native void    clearMethodState0(Executable method);\n-  public  native void    markMethodProfiled(Executable method);\n-  public         void    clearMethodState(Executable method) {\n-    Objects.requireNonNull(method);\n-    clearMethodState0(method);\n-  }\n-  public native void    lockCompilation();\n-  public native void    unlockCompilation();\n-  private native int     getMethodEntryBci0(Executable method);\n-  public         int     getMethodEntryBci(Executable method) {\n-    Objects.requireNonNull(method);\n-    return getMethodEntryBci0(method);\n-  }\n-  private native Object[] getNMethod0(Executable method, boolean isOsr);\n-  public         Object[] getNMethod(Executable method, boolean isOsr) {\n-    Objects.requireNonNull(method);\n-    return getNMethod0(method, isOsr);\n-  }\n-  public native long    allocateCodeBlob(int size, int type);\n-  public        long    allocateCodeBlob(long size, int type) {\n-      int intSize = (int) size;\n-      if ((long) intSize != size || size < 0) {\n-          throw new IllegalArgumentException(\n-                \"size argument has illegal value \" + size);\n-      }\n-      return allocateCodeBlob( intSize, type);\n-  }\n-  public native void    freeCodeBlob(long addr);\n-  public native void    forceNMethodSweep();\n-  public native Object[] getCodeHeapEntries(int type);\n-  public native int     getCompilationActivityMode();\n-  private native long getMethodData0(Executable method);\n-  public         long getMethodData(Executable method) {\n-    Objects.requireNonNull(method);\n-    return getMethodData0(method);\n-  }\n-  public native Object[] getCodeBlob(long addr);\n-\n-  private native void clearInlineCaches0(boolean preserve_static_stubs);\n-  public void clearInlineCaches() {\n-    clearInlineCaches0(false);\n-  }\n-  public void clearInlineCaches(boolean preserve_static_stubs) {\n-    clearInlineCaches0(preserve_static_stubs);\n-  }\n-\n-  \/\/ Intered strings\n-  public native boolean isInStringTable(String str);\n-\n-  \/\/ Memory\n-  public native void readReservedMemory();\n-  public native long allocateMetaspace(ClassLoader classLoader, long size);\n-  public native long incMetaspaceCapacityUntilGC(long increment);\n-  public native long metaspaceCapacityUntilGC();\n-  public native long metaspaceSharedRegionAlignment();\n-\n-  \/\/ Metaspace Arena Tests\n-  public native long createMetaspaceTestContext(long commit_limit, long reserve_limit);\n-  public native void destroyMetaspaceTestContext(long context);\n-  public native void purgeMetaspaceTestContext(long context);\n-  public native void printMetaspaceTestContext(long context);\n-  public native long getTotalCommittedWordsInMetaspaceTestContext(long context);\n-  public native long getTotalUsedWordsInMetaspaceTestContext(long context);\n-  public native long createArenaInTestContext(long context, boolean is_micro);\n-  public native void destroyMetaspaceTestArena(long arena);\n-  public native long allocateFromMetaspaceTestArena(long arena, long word_size);\n-  public native void deallocateToMetaspaceTestArena(long arena, long p, long word_size);\n-\n-  public native long maxMetaspaceAllocationSize();\n-\n-  \/\/ Don't use these methods directly\n-  \/\/ Use sun.hotspot.gc.GC class instead.\n-  public native boolean isGCSupported(int name);\n-  public native boolean isGCSupportedByJVMCICompiler(int name);\n-  public native boolean isGCSelected(int name);\n-  public native boolean isGCSelectedErgonomically();\n-\n-  \/\/ Force Young GC\n-  public native void youngGC();\n-\n-  \/\/ Force Full GC\n-  public native void fullGC();\n-\n-  \/\/ Returns true if the current GC supports concurrent collection control.\n-  public native boolean supportsConcurrentGCBreakpoints();\n-\n-  private void checkConcurrentGCBreakpointsSupported() {\n-    if (!supportsConcurrentGCBreakpoints()) {\n-      throw new UnsupportedOperationException(\"Concurrent GC breakpoints not supported\");\n-    }\n-  }\n-\n-  private native void concurrentGCAcquireControl0();\n-  private native void concurrentGCReleaseControl0();\n-  private native void concurrentGCRunToIdle0();\n-  private native boolean concurrentGCRunTo0(String breakpoint);\n-\n-  private static boolean concurrentGCIsControlled = false;\n-  private void checkConcurrentGCIsControlled() {\n-    if (!concurrentGCIsControlled) {\n-      throw new IllegalStateException(\"Not controlling concurrent GC\");\n-    }\n-  }\n-\n-  \/\/ All collectors supporting concurrent GC breakpoints are expected\n-  \/\/ to provide at least the following breakpoints.\n-  public final String AFTER_MARKING_STARTED = \"AFTER MARKING STARTED\";\n-  public final String BEFORE_MARKING_COMPLETED = \"BEFORE MARKING COMPLETED\";\n-\n-  \/\/ Collectors supporting concurrent GC breakpoints that do reference\n-  \/\/ processing concurrently should provide the following breakpoint.\n-  public final String AFTER_CONCURRENT_REFERENCE_PROCESSING_STARTED =\n-    \"AFTER CONCURRENT REFERENCE PROCESSING STARTED\";\n-\n-  \/\/ G1 specific GC breakpoints.\n-  public final String G1_AFTER_REBUILD_STARTED = \"AFTER REBUILD STARTED\";\n-  public final String G1_BEFORE_REBUILD_COMPLETED = \"BEFORE REBUILD COMPLETED\";\n-  public final String G1_AFTER_CLEANUP_STARTED = \"AFTER CLEANUP STARTED\";\n-  public final String G1_BEFORE_CLEANUP_COMPLETED = \"BEFORE CLEANUP COMPLETED\";\n-\n-  public void concurrentGCAcquireControl() {\n-    checkConcurrentGCBreakpointsSupported();\n-    if (concurrentGCIsControlled) {\n-      throw new IllegalStateException(\"Already controlling concurrent GC\");\n-    }\n-    concurrentGCAcquireControl0();\n-    concurrentGCIsControlled = true;\n-  }\n-\n-  public void concurrentGCReleaseControl() {\n-    checkConcurrentGCBreakpointsSupported();\n-    concurrentGCReleaseControl0();\n-    concurrentGCIsControlled = false;\n-  }\n-\n-  \/\/ Keep concurrent GC idle.  Release from breakpoint.\n-  public void concurrentGCRunToIdle() {\n-    checkConcurrentGCBreakpointsSupported();\n-    checkConcurrentGCIsControlled();\n-    concurrentGCRunToIdle0();\n-  }\n-\n-  \/\/ Allow concurrent GC to run to breakpoint.\n-  \/\/ Throws IllegalStateException if reached end of cycle first.\n-  public void concurrentGCRunTo(String breakpoint) {\n-    concurrentGCRunTo(breakpoint, true);\n-  }\n-\n-  \/\/ Allow concurrent GC to run to breakpoint.\n-  \/\/ Returns true if reached breakpoint.  If reached end of cycle first,\n-  \/\/ then throws IllegalStateException if errorIfFail is true, returning\n-  \/\/ false otherwise.\n-  public boolean concurrentGCRunTo(String breakpoint, boolean errorIfFail) {\n-    checkConcurrentGCBreakpointsSupported();\n-    checkConcurrentGCIsControlled();\n-    if (breakpoint == null) {\n-      throw new NullPointerException(\"null breakpoint\");\n-    } else if (concurrentGCRunTo0(breakpoint)) {\n-      return true;\n-    } else if (errorIfFail) {\n-      throw new IllegalStateException(\"Missed requested breakpoint \\\"\" + breakpoint + \"\\\"\");\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  \/\/ Method tries to start concurrent mark cycle.\n-  \/\/ It returns false if CM Thread is always in concurrent cycle.\n-  public native boolean g1StartConcMarkCycle();\n-\n-  \/\/ Tests on ReservedSpace\/VirtualSpace classes\n-  public native int stressVirtualSpaceResize(long reservedSpaceSize, long magnitude, long iterations);\n-  public native void readFromNoaccessArea();\n-  public native long getThreadStackSize();\n-  public native long getThreadRemainingStackSize();\n-\n-  \/\/ CPU features\n-  public native String getCPUFeatures();\n-\n-  \/\/ VM flags\n-  public native boolean isConstantVMFlag(String name);\n-  public native boolean isLockedVMFlag(String name);\n-  public native void    setBooleanVMFlag(String name, boolean value);\n-  public native void    setIntVMFlag(String name, long value);\n-  public native void    setUintVMFlag(String name, long value);\n-  public native void    setIntxVMFlag(String name, long value);\n-  public native void    setUintxVMFlag(String name, long value);\n-  public native void    setUint64VMFlag(String name, long value);\n-  public native void    setSizeTVMFlag(String name, long value);\n-  public native void    setStringVMFlag(String name, String value);\n-  public native void    setDoubleVMFlag(String name, double value);\n-  public native Boolean getBooleanVMFlag(String name);\n-  public native Long    getIntVMFlag(String name);\n-  public native Long    getUintVMFlag(String name);\n-  public native Long    getIntxVMFlag(String name);\n-  public native Long    getUintxVMFlag(String name);\n-  public native Long    getUint64VMFlag(String name);\n-  public native Long    getSizeTVMFlag(String name);\n-  public native String  getStringVMFlag(String name);\n-  public native Double  getDoubleVMFlag(String name);\n-  private final List<Function<String,Object>> flagsGetters = Arrays.asList(\n-    this::getBooleanVMFlag, this::getIntVMFlag, this::getUintVMFlag,\n-    this::getIntxVMFlag, this::getUintxVMFlag, this::getUint64VMFlag,\n-    this::getSizeTVMFlag, this::getStringVMFlag, this::getDoubleVMFlag);\n-\n-  public Object getVMFlag(String name) {\n-    return flagsGetters.stream()\n-                       .map(f -> f.apply(name))\n-                       .filter(x -> x != null)\n-                       .findAny()\n-                       .orElse(null);\n-  }\n-\n-  \/\/ Jigsaw\n-  public native void DefineModule(Object module, boolean is_open, String version,\n-                                  String location, Object[] packages);\n-  public native void AddModuleExports(Object from_module, String pkg, Object to_module);\n-  public native void AddReadsModule(Object from_module, Object source_module);\n-  public native void AddModuleExportsToAllUnnamed(Object module, String pkg);\n-  public native void AddModuleExportsToAll(Object module, String pkg);\n-\n-  public native int getCDSOffsetForName0(String name);\n-  public int getCDSOffsetForName(String name) throws Exception {\n-    int offset = getCDSOffsetForName0(name);\n-    if (offset == -1) {\n-      throw new RuntimeException(name + \" not found\");\n-    }\n-    return offset;\n-  }\n-  public native int getCDSConstantForName0(String name);\n-  public int getCDSConstantForName(String name) throws Exception {\n-    int constant = getCDSConstantForName0(name);\n-    if (constant == -1) {\n-      throw new RuntimeException(name + \" not found\");\n-    }\n-    return constant;\n-  }\n-  public native Boolean getMethodBooleanOption(Executable method, String name);\n-  public native Long    getMethodIntxOption(Executable method, String name);\n-  public native Long    getMethodUintxOption(Executable method, String name);\n-  public native Double  getMethodDoubleOption(Executable method, String name);\n-  public native String  getMethodStringOption(Executable method, String name);\n-  private final List<BiFunction<Executable,String,Object>> methodOptionGetters\n-      = Arrays.asList(this::getMethodBooleanOption, this::getMethodIntxOption,\n-          this::getMethodUintxOption, this::getMethodDoubleOption,\n-          this::getMethodStringOption);\n-\n-  public Object getMethodOption(Executable method, String name) {\n-    return methodOptionGetters.stream()\n-                              .map(f -> f.apply(method, name))\n-                              .filter(x -> x != null)\n-                              .findAny()\n-                              .orElse(null);\n-  }\n-\n-  \/\/ Sharing & archiving\n-  public native int     getCDSGenericHeaderMinVersion();\n-  public native int     getCurrentCDSVersion();\n-  public native String  getDefaultArchivePath();\n-  public native boolean cdsMemoryMappingFailed();\n-  public native boolean isSharingEnabled();\n-  public native boolean isShared(Object o);\n-  public native boolean isSharedClass(Class<?> c);\n-  public native boolean areSharedStringsMapped();\n-  public native boolean isSharedInternedString(String s);\n-  public native boolean isCDSIncluded();\n-  public native boolean isJFRIncluded();\n-  public native boolean isDTraceIncluded();\n-  public native boolean canWriteJavaHeapArchive();\n-  public native Object  getResolvedReferences(Class<?> c);\n-  public native void    linkClass(Class<?> c);\n-  public native boolean areOpenArchiveHeapObjectsMapped();\n-\n-  \/\/ Compiler Directive\n-  public native int addCompilerDirective(String compDirect);\n-  public native void removeCompilerDirective(int count);\n-\n-  \/\/ Handshakes\n-  public native int handshakeWalkStack(Thread t, boolean all_threads);\n-  public native boolean handshakeReadMonitors(Thread t);\n-  public native void asyncHandshakeWalkStack(Thread t);\n-\n-  public native void lockAndBlock(boolean suspender);\n-\n-  \/\/ Returns true on linux if library has the noexecstack flag set.\n-  public native boolean checkLibSpecifiesNoexecstack(String libfilename);\n-\n-  \/\/ Container testing\n-  public native boolean isContainerized();\n-  public native int validateCgroup(String procCgroups,\n-                                   String procSelfCgroup,\n-                                   String procSelfMountinfo);\n-  public native void printOsInfo();\n-\n-  \/\/ Decoder\n-  public native void disableElfSectionCache();\n-\n-  \/\/ Resolved Method Table\n-  public native long resolvedMethodItemsCount();\n-\n-  \/\/ Protection Domain Table\n-  public native int protectionDomainRemovedCount();\n-\n-  public native int getKlassMetadataSize(Class<?> c);\n-\n-  \/\/ ThreadSMR GC safety check for threadObj\n-  public native void checkThreadObjOfTerminatingThread(Thread target);\n-\n-  \/\/ libc name\n-  public native String getLibcName();\n-\n-  \/\/ Walk stack frames of current thread\n-  public native void verifyFrames(boolean log, boolean updateRegisterMap);\n-\n-  public native boolean isJVMTIIncluded();\n-\n-  public native void waitUnsafe(int time_ms);\n-\n-  public native void lockCritical();\n-\n-  public native void unlockCritical();\n-}\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":0,"deletions":698,"binary":false,"changes":698,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.hotspot.code;\n-\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.MemoryPoolMXBean;\n-import java.util.EnumSet;\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-public enum BlobType {\n-    \/\/ Execution level 1 and 4 (non-profiled) nmethods (including native nmethods)\n-    MethodNonProfiled(0, \"CodeHeap 'non-profiled nmethods'\", \"NonProfiledCodeHeapSize\") {\n-        @Override\n-        public boolean allowTypeWhenOverflow(BlobType type) {\n-            return super.allowTypeWhenOverflow(type)\n-                    || type == BlobType.MethodProfiled;\n-        }\n-    },\n-    \/\/ Execution level 2 and 3 (profiled) nmethods\n-    MethodProfiled(1, \"CodeHeap 'profiled nmethods'\", \"ProfiledCodeHeapSize\") {\n-        @Override\n-        public boolean allowTypeWhenOverflow(BlobType type) {\n-            return super.allowTypeWhenOverflow(type)\n-                    || type == BlobType.MethodNonProfiled;\n-        }\n-    },\n-    \/\/ Non-nmethods like Buffers, Adapters and Runtime Stubs\n-    NonNMethod(2, \"CodeHeap 'non-nmethods'\", \"NonNMethodCodeHeapSize\") {\n-        @Override\n-        public boolean allowTypeWhenOverflow(BlobType type) {\n-            return super.allowTypeWhenOverflow(type)\n-                    || type == BlobType.MethodNonProfiled\n-                    || type == BlobType.MethodProfiled;\n-        }\n-    },\n-    \/\/ All types (No code cache segmentation)\n-    All(3, \"CodeCache\", \"ReservedCodeCacheSize\");\n-\n-    public final int id;\n-    public final String sizeOptionName;\n-    public final String beanName;\n-\n-    private BlobType(int id, String beanName, String sizeOptionName) {\n-        this.id = id;\n-        this.beanName = beanName;\n-        this.sizeOptionName = sizeOptionName;\n-    }\n-\n-    public MemoryPoolMXBean getMemoryPool() {\n-        for (MemoryPoolMXBean bean : ManagementFactory.getMemoryPoolMXBeans()) {\n-            String name = bean.getName();\n-            if (beanName.equals(name)) {\n-                return bean;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public boolean allowTypeWhenOverflow(BlobType type) {\n-        return type == this;\n-    }\n-\n-    public static EnumSet<BlobType> getAvailable() {\n-        WhiteBox whiteBox = WhiteBox.getWhiteBox();\n-        if (!whiteBox.getBooleanVMFlag(\"SegmentedCodeCache\")) {\n-            \/\/ only All for non segmented world\n-            return EnumSet.of(All);\n-        }\n-        if (System.getProperty(\"java.vm.info\").startsWith(\"interpreted \")) {\n-            \/\/ only NonNMethod for -Xint\n-            return EnumSet.of(NonNMethod);\n-        }\n-\n-        EnumSet<BlobType> result = EnumSet.complementOf(EnumSet.of(All));\n-        if (!whiteBox.getBooleanVMFlag(\"TieredCompilation\")\n-                || whiteBox.getIntxVMFlag(\"TieredStopAtLevel\") <= 1) {\n-            \/\/ there is no MethodProfiled in non tiered world or pure C1\n-            result.remove(MethodProfiled);\n-        }\n-        return result;\n-    }\n-\n-    public long getSize() {\n-        return WhiteBox.getWhiteBox().getUintxVMFlag(sizeOptionName);\n-    }\n-}\n","filename":"test\/lib\/sun\/hotspot\/code\/BlobType.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.hotspot.code;\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-@Deprecated\n-public class CodeBlob {\n-  private static final WhiteBox WB = WhiteBox.getWhiteBox();\n-  public static CodeBlob[] getCodeBlobs(BlobType type) {\n-    Object[] obj = WB.getCodeHeapEntries(type.id);\n-    if (obj == null) {\n-      return null;\n-    }\n-    CodeBlob[] result = new CodeBlob[obj.length];\n-    for (int i = 0, n = result.length; i < n; ++i) {\n-      result[i] = new CodeBlob((Object[]) obj[i]);\n-    }\n-    return result;\n-  }\n-  public static CodeBlob getCodeBlob(long addr) {\n-    Object[] obj = WB.getCodeBlob(addr);\n-    if (obj == null) {\n-      return null;\n-    }\n-    return new CodeBlob(obj);\n-  }\n-  protected CodeBlob(Object[] obj) {\n-    assert obj.length == 4;\n-    name = (String) obj[0];\n-    size = (Integer) obj[1];\n-    int blob_type_index = (Integer) obj[2];\n-    code_blob_type = BlobType.values()[blob_type_index];\n-    assert code_blob_type.id == (Integer) obj[2];\n-    address = (Long) obj[3];\n-  }\n-  public final String name;\n-  public final int size;\n-  public final BlobType code_blob_type;\n-  public final long address;\n-  @Override\n-  public String toString() {\n-    return \"CodeBlob{\"\n-        + \"name=\" + name\n-        + \", size=\" + size\n-        + \", code_blob_type=\" + code_blob_type\n-        + \", address=\" + address\n-        + '}';\n-  }\n-}\n","filename":"test\/lib\/sun\/hotspot\/code\/CodeBlob.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.hotspot.code;\n-\n-import java.lang.reflect.Executable;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/**\n- * API to obtain information about enabled JIT compilers\n- * retrieved from the VM with the WhiteBox API.\n- *\/\n-public class Compiler {\n-\n-    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n-    \/**\n-     * Check if C2 or JVMCI were included in the VM build\n-     *\n-     * @return true if either C2 or JVMCI were included in the VM build.\n-     *\/\n-    public static boolean isC2OrJVMCIIncluded() {\n-        return WB.isC2OrJVMCIIncluded();\n-    }\n-\n-    \/**\n-     * Check if JVMCI is enabled.\n-     *\n-     * @return true if JVMCI is enabled\n-     *\/\n-    public static boolean isJVMCIEnabled() {\n-        Boolean enableJvmci = WB.getBooleanVMFlag(\"EnableJVMCI\");\n-        if (enableJvmci == null || !enableJvmci) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    \/**\n-     * Check if Graal is used as JIT compiler.\n-     *\n-     * Graal is enabled if following conditions are true:\n-     * - we are not in Interpreter mode\n-     * - UseJVMCICompiler flag is true\n-     * - jvmci.Compiler variable is equal to 'graal'\n-     * - TieredCompilation is not used or TieredStopAtLevel is greater than 3\n-     * No need to check client mode because it set UseJVMCICompiler to false.\n-     *\n-     * @return true if Graal is used as JIT compiler.\n-     *\/\n-    public static boolean isGraalEnabled() {\n-        Boolean useCompiler = WB.getBooleanVMFlag(\"UseCompiler\");\n-        if (useCompiler == null || !useCompiler) {\n-            return false;\n-        }\n-        Boolean useJvmciComp = WB.getBooleanVMFlag(\"UseJVMCICompiler\");\n-        if (useJvmciComp == null || !useJvmciComp) {\n-            return false;\n-        }\n-\n-        Boolean tieredCompilation = WB.getBooleanVMFlag(\"TieredCompilation\");\n-        Long compLevel = WB.getIntxVMFlag(\"TieredStopAtLevel\");\n-        \/\/ if TieredCompilation is enabled and compilation level is <= 3 then no Graal is used\n-        if (tieredCompilation != null && tieredCompilation &&\n-            compLevel != null && compLevel <= 3) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Check if C2 is used as JIT compiler.\n-     *\n-     * C2 is enabled if following conditions are true:\n-     * - we are not in Interpreter mode\n-     * - we are in Server compilation mode\n-     * - TieredCompilation is not used or TieredStopAtLevel is greater than 3\n-     * - Graal is not used\n-     *\n-     * @return true if C2 is used as JIT compiler.\n-     *\/\n-    public static boolean isC2Enabled() {\n-        Boolean useCompiler = WB.getBooleanVMFlag(\"UseCompiler\");\n-        if (useCompiler == null || !useCompiler) {\n-            return false;\n-        }\n-        Boolean serverMode = WB.getBooleanVMFlag(\"ProfileInterpreter\");\n-        if (serverMode == null || !serverMode) {\n-            return false;\n-        }\n-\n-        Boolean tieredCompilation = WB.getBooleanVMFlag(\"TieredCompilation\");\n-        Long compLevel = WB.getIntxVMFlag(\"TieredStopAtLevel\");\n-        \/\/ if TieredCompilation is enabled and compilation level is <= 3 then no Graal is used\n-        if (tieredCompilation != null && tieredCompilation &&\n-            compLevel != null && compLevel <= 3) {\n-            return false;\n-        }\n-\n-        if (isGraalEnabled()) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    \/*\n-     * Check if C1 is used as JIT compiler.\n-     *\n-     * C1 is enabled if following conditions are true:\n-     * - we are not in Interpreter mode\n-     * - we are not in Server compilation mode\n-     * - TieredCompilation is used in Server mode\n-     *\n-     * @return true if C1 is used as JIT compiler.\n-     *\/\n-    public static boolean isC1Enabled() {\n-        Boolean useCompiler = WB.getBooleanVMFlag(\"UseCompiler\");\n-        if (useCompiler == null || !useCompiler) {\n-            return false;\n-        }\n-        Boolean serverMode = WB.getBooleanVMFlag(\"ProfileInterpreter\");\n-        if (serverMode == null || !serverMode) {\n-            return true; \/\/ Client mode\n-        }\n-\n-        Boolean tieredCompilation = WB.getBooleanVMFlag(\"TieredCompilation\");\n-        \/\/ C1 is not used in server mode if TieredCompilation is off.\n-        if (tieredCompilation != null && !tieredCompilation) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    \/*\n-     * Determine if the compiler corresponding to the compilation level 'compLevel'\n-     * provides an intrinsic for 'class'.'method'.\n-     *\/\n-    public static boolean isIntrinsicAvailable(int compLevel, String klass, String method, Class<?>... parameterTypes) {\n-        Executable intrinsicMethod;\n-        try {\n-            intrinsicMethod = Class.forName(klass).getDeclaredMethod(method, parameterTypes);\n-        } catch (NoSuchMethodException e) {\n-            throw new RuntimeException(\"Test bug, '\" + method + \"' method unavailable. \" + e);\n-        } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(\"Test bug, '\" + klass + \"' class unavailable. \" + e);\n-        }\n-        return WB.isIntrinsicAvailable(intrinsicMethod, compLevel);\n-    }\n-}\n","filename":"test\/lib\/sun\/hotspot\/code\/Compiler.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.hotspot.code;\n-\n-import java.lang.reflect.Executable;\n-import jdk.test.whitebox.WhiteBox;\n-\n-@Deprecated\n-public class NMethod extends CodeBlob {\n-  private static final WhiteBox wb = WhiteBox.getWhiteBox();\n-  public static NMethod get(Executable method, boolean isOsr) {\n-    Object[] obj = wb.getNMethod(method, isOsr);\n-    return obj == null ? null : new NMethod(obj);\n-  }\n-  private NMethod(Object[] obj) {\n-    super((Object[])obj[0]);\n-    assert obj.length == 5;\n-    comp_level = (Integer) obj[1];\n-    insts = (byte[]) obj[2];\n-    compile_id = (Integer) obj[3];\n-    entry_point = (Long) obj[4];\n-  }\n-  public final byte[] insts;\n-  public final int comp_level;\n-  public final int compile_id;\n-  public final long entry_point;\n-\n-  @Override\n-  public String toString() {\n-    return \"NMethod{\"\n-        + super.toString()\n-        + \", insts=\" + insts\n-        + \", comp_level=\" + comp_level\n-        + \", compile_id=\" + compile_id\n-        + \", entry_point=\" + entry_point\n-        + '}';\n-  }\n-}\n","filename":"test\/lib\/sun\/hotspot\/code\/NMethod.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.hotspot.cpuinfo;\n-\n-import java.util.List;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/**\n- * Information about CPU on test box.\n- *\n- * CPUInfo uses WhiteBox to gather information,\n- * so WhiteBox class should be added to bootclasspath\n- * and option -XX:+WhiteBoxAPI should be explicitly\n- * specified on command line.\n- *\/\n-@Deprecated\n-public class CPUInfo {\n-\n-    private static final List<String> features;\n-    private static final String additionalCPUInfo;\n-\n-    static {\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-        Pattern additionalCPUInfoRE =\n-            Pattern.compile(\"([^(]*\\\\([^)]*\\\\)[^,]*),\\\\s*\");\n-\n-        String cpuFeaturesString = wb.getCPUFeatures();\n-        Matcher matcher = additionalCPUInfoRE.matcher(cpuFeaturesString);\n-        if (matcher.find()) {\n-            additionalCPUInfo = matcher.group(1);\n-        } else {\n-            additionalCPUInfo = \"\";\n-        }\n-        String splittedFeatures[] = matcher.replaceAll(\"\").split(\"(, )| \");\n-\n-        features = Collections.unmodifiableList(Arrays.\n-                                                asList(splittedFeatures));\n-    }\n-\n-    \/**\n-     * Get additional information about CPU.\n-     * For example, on X86 in will be family\/model\/stepping\n-     * and number of cores.\n-     *\n-     * @return additional CPU info\n-     *\/\n-    public static String getAdditionalCPUInfo() {\n-        return additionalCPUInfo;\n-    }\n-\n-    \/**\n-     * Get all known features supported by CPU.\n-     *\n-     * @return unmodifiable list with names of all known features\n-     *         supported by CPU.\n-     *\/\n-    public static List<String> getFeatures() {\n-        return features;\n-    }\n-\n-    \/**\n-     * Check if some feature is supported by CPU.\n-     *\n-     * @param feature Name of feature to be tested.\n-     * @return <b>true<\/b> if tested feature is supported by CPU.\n-     *\/\n-    public static boolean hasFeature(String feature) {\n-        return features.contains(feature.toLowerCase());\n-    }\n-}\n","filename":"test\/lib\/sun\/hotspot\/cpuinfo\/CPUInfo.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.hotspot.gc;\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/**\n- * API to obtain information about selected and supported Garbage Collectors\n- * retrieved from the VM with the WhiteBox API.\n- *\/\n-public enum GC {\n-    \/*\n-     * Enum values must match CollectedHeap::Name\n-     *\/\n-    Serial(1),\n-    Parallel(2),\n-    G1(3),\n-    Epsilon(4),\n-    Z(5),\n-    Shenandoah(6);\n-\n-    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n-    private final int name;\n-\n-    private GC(int name) {\n-        this.name = name;\n-    }\n-\n-    \/**\n-     * @return true if this GC is supported by the VM, i.e., it is built into the VM.\n-     *\/\n-    public boolean isSupported() {\n-        return WB.isGCSupported(name);\n-    }\n-\n-    \/**\n-     * @return true if this GC is supported by the JVMCI compiler\n-     *\/\n-    public boolean isSupportedByJVMCICompiler() {\n-        return WB.isGCSupportedByJVMCICompiler(name);\n-    }\n-\n-    \/**\n-     * @return true if this GC is currently selected\/used\n-     *\/\n-    public boolean isSelected() {\n-        return WB.isGCSelected(name);\n-    }\n-\n-    \/**\n-     * @return true if GC was selected ergonomically, as opposed\n-     *         to being explicitly specified on the command line\n-     *\/\n-    public static boolean isSelectedErgonomically() {\n-        return WB.isGCSelectedErgonomically();\n-    }\n-\n-    \/**\n-     * @return the selected GC.\n-     *\/\n-    public static GC selected() {\n-      for (GC gc : values()) {\n-        if (gc.isSelected()) {\n-          return gc;\n-        }\n-      }\n-      throw new IllegalStateException(\"No selected GC found\");\n-    }\n-}\n","filename":"test\/lib\/sun\/hotspot\/gc\/GC.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"}]}