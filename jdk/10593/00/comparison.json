{"files":[{"patch":"@@ -59,1 +59,4 @@\n-  \/\/ This function clears the memory of the object\n+  \/\/ Initialization provided by subclasses.\n+  virtual oop initialize(HeapWord* mem) const = 0;\n+\n+  \/\/ This function clears the memory of the object.\n@@ -61,0 +64,1 @@\n+\n@@ -64,1 +68,1 @@\n-  virtual oop finish(HeapWord* mem) const;\n+  oop finish(HeapWord* mem) const;\n@@ -75,0 +79,1 @@\n+  \/\/ Allocate and fully construct the object, and perform various instrumentation. Could safepoint.\n@@ -77,1 +82,0 @@\n-  virtual oop initialize(HeapWord* mem) const = 0;\n@@ -88,0 +92,1 @@\n+protected:\n@@ -90,1 +95,1 @@\n-protected:\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -164,5 +164,1 @@\n-  if (!do_zero) {\n-    return CollectedHeap::array_allocate(klass, size, length, false \/* do_zero *\/, THREAD);\n-  }\n-\n-  ZObjArrayAllocator allocator(klass, size, length, THREAD);\n+  ZObjArrayAllocator allocator(klass, size, length, do_zero, THREAD);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -31,2 +32,2 @@\n-ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, Thread* thread) :\n-    ObjArrayAllocator(klass, word_size, length, false \/* do_zero *\/, thread) {}\n+ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, bool do_zero, Thread* thread) :\n+    ObjArrayAllocator(klass, word_size, length, do_zero, thread) {}\n@@ -34,3 +35,3 @@\n-oop ZObjArrayAllocator::finish(HeapWord* mem) const {\n-  \/\/ Initialize object header and length field\n-  ObjArrayAllocator::finish(mem);\n+void ZObjArrayAllocator::yield_for_safepoint() const {\n+  ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n+}\n@@ -38,4 +39,8 @@\n-  \/\/ Keep the array alive across safepoints through an invisible\n-  \/\/ root. Invisible roots are not visited by the heap itarator\n-  \/\/ and the marking logic will not attempt to follow its elements.\n-  ZThreadLocalData::set_invisible_root(_thread, (oop*)&mem);\n+oop ZObjArrayAllocator::initialize(HeapWord* mem) const {\n+  \/\/ ZGC specializes the initialization by performing segmented clearing\n+  \/\/ to allow shorter time-to-safepoints.\n+\n+  if (!_do_zero) {\n+    \/\/ No need for ZGC specialization\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n@@ -47,2 +52,30 @@\n-  const size_t skip = arrayOopDesc::header_size(ArrayKlass::cast(_klass)->element_type());\n-  size_t remaining = _word_size - skip;\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t header = arrayOopDesc::header_size(element_type);\n+  const size_t payload_size = _word_size - header;\n+\n+  if (payload_size <= segment_max) {\n+    \/\/ To small to use segmented clearing\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n+\n+  \/\/ Segmented clearing\n+\n+  \/\/ The array is going to be exposed before it has been completely\n+  \/\/ cleared, therefore we can't expose the header at the end of this\n+  \/\/ function. Instead explicitly initialize it according to our needs.\n+  arrayOopDesc::set_mark(mem, markWord::prototype());\n+  arrayOopDesc::release_set_klass(mem, _klass);\n+  assert(_length >= 0, \"length should be non-negative\");\n+  arrayOopDesc::set_length(mem, _length);\n+\n+  \/\/ Keep the array alive across safepoints through an invisible\n+  \/\/ root. Invisible roots are not visited by the heap itarator\n+  \/\/ and the marking logic will not attempt to follow its elements.\n+  \/\/ Relocation knows how to dodge iterating over such objects.\n+  ZThreadLocalData::set_invisible_root(_thread, (oop*)&mem);\n+\n+  for (size_t processed = 0; processed < payload_size; processed += segment_max) {\n+    \/\/ Calculate segment\n+    HeapWord* const start = (HeapWord*)(mem + header + processed);\n+    const size_t remaining = payload_size - processed;\n+    const size_t segment_size = MIN2(remaining, segment_max);\n@@ -50,1 +83,0 @@\n-  while (remaining > 0) {\n@@ -52,3 +84,1 @@\n-    const size_t segment = MIN2(remaining, segment_max);\n-    Copy::zero_to_words(mem + (_word_size - remaining), segment);\n-    remaining -= segment;\n+    Copy::zero_to_words(start, segment_size);\n@@ -56,4 +86,2 @@\n-    if (remaining > 0) {\n-      \/\/ Safepoint\n-      ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n-    }\n+    \/\/ Safepoint\n+    yield_for_safepoint();\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":47,"deletions":19,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -30,2 +30,4 @@\n-public:\n-  ZObjArrayAllocator(Klass* klass, size_t word_size, int length, Thread* thread);\n+private:\n+  virtual oop initialize(HeapWord* mem) const override;\n+\n+  void yield_for_safepoint() const;\n@@ -33,1 +35,2 @@\n-  virtual oop finish(HeapWord* mem) const;\n+public:\n+  ZObjArrayAllocator(Klass* klass, size_t word_size, int length, bool do_zero, Thread* thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}