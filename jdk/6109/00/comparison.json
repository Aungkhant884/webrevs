{"files":[{"patch":"@@ -1894,13 +1894,0 @@\n-\/\/ Enforces volatile semantics for a non-volatile read.\n-class VolatileRead : public StackObj {\n- public:\n-  VolatileRead() {\n-    \/\/ Ensures a possibly volatile read is not reordered with a prior\n-    \/\/ volatile write.\n-    OrderAccess::storeload();\n-  }\n-  ~VolatileRead() {\n-    OrderAccess::acquire();\n-  }\n-};\n-\n@@ -1947,1 +1934,2 @@\n-  if (displacement < 0 || ((long) displacement + type2aelembytes(basic_type) > HeapWordSize * obj->size())) {\n+  int basic_type_elemsize = type2aelembytes(basic_type);\n+  if (displacement < 0 || ((long) displacement + basic_type_elemsize > HeapWordSize * obj->size())) {\n@@ -1992,1 +1980,1 @@\n-  \/\/ Treat all reads as volatile for simplicity as this function can be used\n+  \/\/ Treat all aligned reads as volatile for simplicity as this function can be used\n@@ -1994,5 +1982,1 @@\n-  \/\/ folding Unsafe.get* methods with volatile semantics. This is done by\n-  \/\/ performing the volatile barrier operations around a call to an\n-  \/\/ oopDesc::<kind>_field method. The oopDesc::<kind>_field_acquire method\n-  \/\/ cannot be used since it does not support unaligned reads on all platforms\n-  \/\/ (e.g., an unaligned ldar on AArch64 causes a SIGBUS).\n+  \/\/ folding Unsafe.get* methods with volatile semantics.\n@@ -2000,0 +1984,1 @@\n+  bool aligned = (displacement % basic_type_elemsize) == 0;\n@@ -2002,4 +1987,4 @@\n-    case T_BOOLEAN: { VolatileRead vr; value = obj->bool_field(displacement); } break;\n-    case T_BYTE:    { VolatileRead vr; value = obj->byte_field(displacement); } break;\n-    case T_SHORT:   { VolatileRead vr; value = obj->short_field(displacement);} break;\n-    case T_CHAR:    { VolatileRead vr; value = obj->char_field(displacement); } break;\n+    case T_BOOLEAN: value = aligned ? obj->bool_field_acquire(displacement)   : obj->bool_field(displacement);  break;\n+    case T_BYTE:    value = aligned ? obj->byte_field_acquire(displacement)   : obj->byte_field(displacement);  break;\n+    case T_SHORT:   value = aligned ? obj->short_field_acquire(displacement)  : obj->short_field(displacement); break;\n+    case T_CHAR:    value = aligned ? obj->char_field_acquire(displacement)   : obj->char_field(displacement);  break;\n@@ -2007,1 +1992,1 @@\n-    case T_INT:     { VolatileRead vr; value = obj->int_field(displacement);  } break;\n+    case T_INT:     value = aligned ? obj->int_field_acquire(displacement)    : obj->int_field(displacement);   break;\n@@ -2009,1 +1994,1 @@\n-    case T_LONG:    { VolatileRead vr; value = obj->long_field(displacement); } break;\n+    case T_LONG:    value = aligned ? obj->long_field_acquire(displacement)   : obj->long_field(displacement);  break;\n@@ -2019,2 +2004,1 @@\n-      oop value;\n-      { VolatileRead vr; value = obj->obj_field(displacement); }\n+      oop value = aligned ? obj->obj_field_acquire(displacement) : obj->obj_field(displacement);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":12,"deletions":28,"binary":false,"changes":40,"status":"modified"}]}