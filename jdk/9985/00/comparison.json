{"files":[{"patch":"@@ -553,0 +553,2 @@\n+\n+  Metaspace::purge(classes_unloaded);\n@@ -554,1 +556,0 @@\n-    Metaspace::purge();\n@@ -557,0 +558,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -998,1 +998,1 @@\n-void Metaspace::purge() {\n+void Metaspace::purge(bool classes_unloaded) {\n@@ -1003,6 +1003,2 @@\n-  ChunkManager* cm = ChunkManager::chunkmanager_nonclass();\n-  if (cm != NULL) {\n-    cm->purge();\n-  }\n-  if (using_class_space()) {\n-    cm = ChunkManager::chunkmanager_class();\n+  if (classes_unloaded) {\n+    ChunkManager* cm = ChunkManager::chunkmanager_nonclass();\n@@ -1012,0 +1008,6 @@\n+    if (using_class_space()) {\n+      cm = ChunkManager::chunkmanager_class();\n+      if (cm != NULL) {\n+        cm->purge();\n+      }\n+    }\n@@ -1014,1 +1016,6 @@\n-  MetaspaceCriticalAllocation::satisfy();\n+  \/\/ Try to satisfy queued metaspace allocation requests.\n+  \/\/\n+  \/\/ It might seem unnecessary to try to process allocation requests if no\n+  \/\/ classes have been unloaded. However, this call is required for the code\n+  \/\/ in MetaspaceCriticalAllocation::try_allocate_critical to work.\n+  MetaspaceCriticalAllocation::process();\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  static void purge();\n+  static void purge(bool classes_unloaded);\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,6 +36,6 @@\n-  ClassLoaderData*           _loader_data;\n-  size_t                     _word_size;\n-  Metaspace::MetadataType    _type;\n-  MetadataAllocationRequest* _next;\n-  MetaWord*                  _result;\n-  bool                       _has_result;\n+  ClassLoaderData* const        _loader_data;\n+  const size_t                  _word_size;\n+  const Metaspace::MetadataType _type;\n+  MetadataAllocationRequest*    _next;\n+  MetaWord*                     _result;\n+  bool                          _is_processed;\n@@ -52,1 +52,1 @@\n-      _has_result(false) {\n+      _is_processed(false) {\n@@ -60,6 +60,6 @@\n-  ClassLoaderData*           loader_data() const { return _loader_data; }\n-  size_t                     word_size() const   { return _word_size; }\n-  Metaspace::MetadataType    type() const        { return _type; }\n-  MetadataAllocationRequest* next() const        { return _next; }\n-  MetaWord*                  result() const      { return _result; }\n-  bool                       has_result() const  { return _has_result; }\n+  ClassLoaderData*           loader_data() const   { return _loader_data; }\n+  size_t                     word_size() const     { return _word_size; }\n+  Metaspace::MetadataType    type() const          { return _type; }\n+  MetadataAllocationRequest* next() const          { return _next; }\n+  MetaWord*                  result() const        { return _result; }\n+  bool                       is_processed() const  { return _is_processed; }\n@@ -70,1 +70,1 @@\n-    _has_result = true;\n+    _is_processed = true;\n@@ -116,0 +116,21 @@\n+  \/\/ This function uses an optimized scheme to limit the number of triggered\n+  \/\/ GCs. The idea is that only one request in the list is responsible for\n+  \/\/ triggering a GC, and later requests will try to piggy-back on that\n+  \/\/ request.\n+  \/\/\n+  \/\/ For this to work, it is important that we can tell which requests were\n+  \/\/ seen by the GC's call to process(), and which requests were added after\n+  \/\/ last proccess() call. The property '_is_processed' tells this. Because the\n+  \/\/ logic below relies on that property, it is important that the GC calls\n+  \/\/ process() even when the GC didn't unload any classes.\n+  \/\/\n+  \/\/ Note that process() leaves the requests in the queue, so that threads\n+  \/\/ in wait_for_purge, which had their requests processed, but didn't get any\n+  \/\/ memory can exit that function and trigger a new GC as a last effort to get\n+  \/\/ memory before throwing an OOME.\n+  \/\/\n+  \/\/ Requests that have been processed once, will not trigger new GCs, we\n+  \/\/ therefore filter them out when we determine if the current 'request'\n+  \/\/ needs to trigger a GC, or if there are earlier requests that will\n+  \/\/ trigger a GC.\n+\n@@ -118,2 +139,14 @@\n-    if (_requests_head == request) {\n-      \/\/ The first request can't opportunistically ride on a previous GC\n+    auto is_first_unprocessed = [&]() {\n+      for (MetadataAllocationRequest* curr = _requests_head; curr != NULL; curr = curr->next()) {\n+        if (!curr->is_processed()) {\n+          \/\/ curr is the first not satisfied request\n+          return curr == request;\n+        }\n+      }\n+\n+      return false;\n+    };\n+\n+    if (is_first_unprocessed()) {\n+      \/\/ The first non-processed request takes ownership of triggering the GC\n+      \/\/ on behalf of itself, and all trailing requests in the list.\n@@ -123,0 +156,1 @@\n+\n@@ -132,1 +166,3 @@\n-    if (request->has_result()) {\n+    if (request->is_processed()) {\n+      \/\/ The GC has procesed this request during the purge.\n+      \/\/ Return and check the result, and potentially call a last-effort GC.\n@@ -147,1 +183,1 @@\n-void MetaspaceCriticalAllocation::satisfy() {\n+void MetaspaceCriticalAllocation::process() {\n@@ -152,1 +188,1 @@\n-      \/\/ Don't satisfy twice\n+      \/\/ Don't satisfy twice (can still be processed twice)\n","filename":"src\/hotspot\/share\/memory\/metaspaceCriticalAllocation.cpp","additions":55,"deletions":19,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-\/\/ to satisfy a very small number of additional allocations. But it does solve pathologial\n+\/\/ to satisfy a very small number of additional allocations. But it does solve pathological\n@@ -80,1 +80,1 @@\n-  static void satisfy();\n+  static void process();\n","filename":"src\/hotspot\/share\/memory\/metaspaceCriticalAllocation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            \"-Xlog:gc:gc_$i.log\", \/\/ LOG_GC_ARG_INDEX\n+            \"UNSET_LOG_GC_ARG\", \/\/ LOG_GC_ARG_INDEX\n@@ -84,1 +84,1 @@\n-            args[LOG_GC_ARG_INDEX] = \"-Xlog:gc:gc_\" + i + \".log\";\n+            args[LOG_GC_ARG_INDEX] = \"-Xlog:gc*:gc_\" + i + \".log::filecount=0\";\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/shrink_grow\/ShrinkGrowMultiJVM\/ShrinkGrowMultiJVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+            log(\"just a tiny mint\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/shrink_grow\/ShrinkGrowTest\/ShrinkGrowTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}