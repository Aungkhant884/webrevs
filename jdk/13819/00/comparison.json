{"files":[{"patch":"@@ -74,1 +74,1 @@\n-    static MethodHandle makeArrayElementAccessor(Class<?> arrayClass, ArrayAccess access) {\n+    static MethodHandle makeArrayAccessor(Class<?> arrayClass, ArrayAccess access) {\n@@ -87,1 +87,3 @@\n-            assert(mh.type().parameterType(0) == Object[].class);\n+            \/\/ two assertions only applicable to non-construct access\n+            assert(access == ArrayAccess.CONSTRUCT || !arrayClass.isPrimitive());\n+            assert(access == ArrayAccess.CONSTRUCT || mh.type().parameterType(0) == Object[].class);\n@@ -95,1 +97,4 @@\n-        mh = makeIntrinsic(mh, ArrayAccess.intrinsic(access));\n+        var intrinsic = ArrayAccess.intrinsic(access);\n+        if (intrinsic != Intrinsic.NONE) {\n+            mh = makeIntrinsic(mh, intrinsic);\n+        }\n@@ -109,1 +114,1 @@\n-        GET, SET, LENGTH;\n+        GET, SET, LENGTH, CONSTRUCT;\n@@ -119,0 +124,1 @@\n+                case CONSTRUCT -> throw wrongArrayAccessPath(a);\n@@ -128,0 +134,1 @@\n+                case CONSTRUCT -> ArrayAccessor.OBJECT_ARRAY_CONSTRUCT;\n@@ -137,0 +144,1 @@\n+                case CONSTRUCT -> ArrayAccessor.CONSTRUCTOR_INDEX;\n@@ -146,0 +154,3 @@\n+                \/\/ Array.newInstance with constant class argument\n+                \/\/ is already constant-foldable\n+                case CONSTRUCT -> Intrinsic.NONE;\n@@ -151,0 +162,4 @@\n+    static InternalError wrongArrayAccessPath(ArrayAccess a) {\n+        throw newInternalError(\"should not reach here (not on code path of ArrayAccess: \" + a + \")\");\n+    }\n+\n@@ -157,1 +172,2 @@\n-        static final int GETTER_INDEX = 0, SETTER_INDEX = 1, LENGTH_INDEX = 2, INDEX_LIMIT = 3;\n+        static final int GETTER_INDEX = 0, SETTER_INDEX = 1, LENGTH_INDEX = 2,\n+                CONSTRUCTOR_INDEX = 3, INDEX_LIMIT = 4;\n@@ -159,1 +175,1 @@\n-                = new ClassValue<MethodHandle[]>() {\n+                = new ClassValue<>() {\n@@ -165,1 +181,2 @@\n-        static final MethodHandle OBJECT_ARRAY_GETTER, OBJECT_ARRAY_SETTER, OBJECT_ARRAY_LENGTH;\n+        static final MethodHandle OBJECT_ARRAY_GETTER, OBJECT_ARRAY_SETTER,\n+                OBJECT_ARRAY_LENGTH, OBJECT_ARRAY_CONSTRUCT;\n@@ -171,0 +188,2 @@\n+            cache[CONSTRUCTOR_INDEX] = OBJECT_ARRAY_CONSTRUCT = getAccessor(Object[].class, ArrayAccess.CONSTRUCT)\n+                    .viewAsType(MethodType.methodType(Object[].class, int.class), false);\n@@ -223,0 +242,1 @@\n+                case CONSTRUCT -> throw wrongArrayAccessPath(access);\n@@ -232,0 +252,1 @@\n+                case CONSTRUCT -> MethodType.methodType(arrayClass, int.class);\n@@ -236,0 +257,3 @@\n+            if (access == ArrayAccess.CONSTRUCT)\n+                return getConstantHandle(MH_Array_newInstance).bindTo(arrayClass.componentType());\n+\n@@ -1469,1 +1493,1 @@\n-        MethodHandle cache[] = Makers.TYPED_COLLECTORS.get(elemType);\n+        MethodHandle[] cache = Makers.TYPED_COLLECTORS.get(elemType);\n@@ -2094,1 +2118,1 @@\n-                : makeArrayElementAccessor(arrayType, ArrayAccess.SET);\n+                : makeArrayAccessor(arrayType, ArrayAccess.SET);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":33,"deletions":9,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4329,6 +4329,1 @@\n-        if (!arrayClass.isArray()) {\n-            throw newIllegalArgumentException(\"not an array class: \" + arrayClass.getName());\n-        }\n-        MethodHandle ani = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).\n-                bindTo(arrayClass.getComponentType());\n-        return ani.asType(ani.type().changeReturnType(arrayClass));\n+        return MethodHandleImpl.makeArrayAccessor(arrayClass, MethodHandleImpl.ArrayAccess.CONSTRUCT);\n@@ -4354,1 +4349,1 @@\n-        return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.LENGTH);\n+        return MethodHandleImpl.makeArrayAccessor(arrayClass, MethodHandleImpl.ArrayAccess.LENGTH);\n@@ -4378,1 +4373,1 @@\n-        return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.GET);\n+        return MethodHandleImpl.makeArrayAccessor(arrayClass, MethodHandleImpl.ArrayAccess.GET);\n@@ -4402,1 +4397,1 @@\n-        return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);\n+        return MethodHandleImpl.makeArrayAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-                {String.class, IllegalArgumentException.class, \"not an array class: java.lang.String\"},\n+                {String.class, IllegalArgumentException.class, \"not an array: class java.lang.String\"},\n","filename":"test\/jdk\/java\/lang\/invoke\/ArrayConstructorTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark assesses the performance of MethodHandles.arrayConstructor\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class MethodHandlesArrayConstructor {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - creating simple array, and accessing the middle element\n+     *   - might have done iteration over array, but that will measure pipelining effects instead\n+     *   - volatile modifier on array breaks the DCE, which would otherwise eliminate the array store\n+     *   - the array is not shared to prevent true sharing\n+     *   - the array is large enough to prevent false sharing\n+     *\/\n+\n+    private static MethodHandle mh;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        mh = MethodHandles.arrayConstructor(String[].class);\n+    }\n+\n+    @Benchmark\n+    public MethodHandle testCreate() {\n+        return MethodHandles.arrayConstructor(String[].class);\n+    }\n+\n+    @Benchmark\n+    public String[] baselineRaw() {\n+        return new String[5];\n+    }\n+\n+    @Benchmark\n+    public String[] testConstructor() throws Throwable {\n+        return (String[]) mh.invoke(5);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandlesArrayConstructor.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}