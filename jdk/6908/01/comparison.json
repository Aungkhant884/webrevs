{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1496,0 +1496,20 @@\n+void C2_MacroAssembler::load_vector(XMMRegister dst, Address src, int vlen_in_bytes) {\n+  switch (vlen_in_bytes) {\n+  case 4:  movdl(dst, src);   break;\n+  case 8:  movq(dst, src);    break;\n+  case 16: movdqu(dst, src);  break;\n+  case 32: vmovdqu(dst, src); break;\n+  case 64: evmovdquq(dst, src, Assembler::AVX_512bit); break;\n+  default: ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch) {\n+  if (reachable(src)) {\n+    load_vector(dst, as_Address(src), vlen_in_bytes);\n+  } else {\n+    lea(rscratch, src);\n+    load_vector(dst, Address(rscratch, 0), vlen_in_bytes);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,0 +147,2 @@\n+  void load_vector(XMMRegister dst, Address src, int vlen_in_bytes);\n+  void load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch = rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2551,9 +2551,15 @@\n-static inline jlong replicate8_imm(int con, int width) {\n-  \/\/ Load a constant of \"width\" (in bytes) and replicate it to fill 64bit.\n-  assert(width == 1 || width == 2 || width == 4, \"only byte, short or int types here\");\n-  int bit_width = width * 8;\n-  jlong val = con;\n-  val &= (((jlong) 1) << bit_width) - 1;  \/\/ mask off sign bits\n-  while(bit_width < 64) {\n-    val |= (val << bit_width);\n-    bit_width <<= 1;\n+template <class T>\n+static inline GrowableArray<jvalue>* vreplicate_imm(BasicType bt, T con, int len) {\n+  GrowableArray<jvalue>* val = new GrowableArray<jvalue>(len);\n+  jvalue ele;\n+  switch (bt) {\n+    case T_BYTE:   ele.b = con; break;\n+    case T_SHORT:  ele.s = con; break;\n+    case T_INT:    ele.i = con; break;\n+    case T_LONG:   ele.j = con; break;\n+    case T_FLOAT:  ele.f = con; break;\n+    case T_DOUBLE: ele.d = con; break;\n+    default: ShouldNotReachHere();\n+  }\n+  for (int i = 0; i < len; i++) {\n+    val->append(ele);\n@@ -3811,8 +3817,1 @@\n-    switch (Matcher::vector_length_in_bytes(this)) {\n-      case  4: __ movdl    ($dst$$XMMRegister, $mem$$Address); break;\n-      case  8: __ movq     ($dst$$XMMRegister, $mem$$Address); break;\n-      case 16: __ movdqu   ($dst$$XMMRegister, $mem$$Address); break;\n-      case 32: __ vmovdqu  ($dst$$XMMRegister, $mem$$Address); break;\n-      case 64: __ evmovdqul($dst$$XMMRegister, $mem$$Address, Assembler::AVX_512bit); break;\n-      default: ShouldNotReachHere();\n-    }\n+    __ load_vector($dst$$XMMRegister, $mem$$Address, Matcher::vector_length_in_bytes(this));\n@@ -3996,16 +3995,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 1));\n-    if (vlen == 4) {\n-      __ movdl($dst$$XMMRegister, const_addr);\n-    } else {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      if (vlen >= 16) {\n-        if (VM_Version::supports_avx2()) {\n-          int vlen_enc = vector_length_encoding(this);\n-          __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-        } else {\n-          assert(vlen == 16, \"sanity\");\n-          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n-    }\n+    InternalAddress addr = $constantaddress(T_BYTE, vreplicate_imm(T_BYTE, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4016,17 +4001,0 @@\n-\/\/ Replicate byte scalar zero to be vector\n-instruct ReplB_zero(vec dst, immI_0 zero) %{\n-  match(Set dst (ReplicateB zero));\n-  format %{ \"replicateB $dst,$zero\" %}\n-  ins_encode %{\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 16) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      \/\/ Use vpxor since AVX512F does not have 512bit vxorpd (requires AVX512DQ).\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n@@ -4078,31 +4046,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 2));\n-    if (vlen == 2) {\n-      __ movdl($dst$$XMMRegister, const_addr);\n-    } else {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      if (vlen >= 8) {\n-        if (VM_Version::supports_avx2()) {\n-          int vlen_enc = vector_length_encoding(this);\n-          __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-        } else {\n-          assert(vlen == 8, \"sanity\");\n-          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-instruct ReplS_zero(vec dst, immI_0 zero) %{\n-  match(Set dst (ReplicateS zero));\n-  format %{ \"replicateS $dst,$zero\" %}\n-  ins_encode %{\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 8) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n+    InternalAddress addr = $constantaddress(T_SHORT, vreplicate_imm(T_SHORT, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4110,1 +4049,1 @@\n-  ins_pipe( fpu_reg_reg );\n+  ins_pipe( pipe_slow );\n@@ -4160,13 +4099,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 4));\n-    if (vlen <= 4) {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      if (vlen == 4) {\n-        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-      }\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movq($dst$$XMMRegister, const_addr);\n-      __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n+    InternalAddress addr = $constantaddress(T_INT, vreplicate_imm(T_INT, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4177,1 +4105,1 @@\n-\/\/ Replicate integer (4 byte) scalar zero to be vector\n+\/\/ Replicate scalar zero to be vector\n@@ -4179,0 +4107,2 @@\n+  match(Set dst (ReplicateB zero));\n+  match(Set dst (ReplicateS zero));\n@@ -4182,2 +4112,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 4) {\n+    uint vsize = Matcher::vector_length_in_bytes(this);\n+    if (vsize <= 16) {\n@@ -4314,11 +4244,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress($con);\n-    if (vlen == 2) {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movq($dst$$XMMRegister, const_addr);\n-      __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n+    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4394,0 +4315,11 @@\n+\/\/ Replicate float scalar immediate to be vector by loading from const table.\n+instruct ReplF_imm(vec dst, immF con) %{\n+  match(Set dst (ReplicateF con));\n+  format %{ \"replicateF $dst,$con\" %}\n+  ins_encode %{\n+    InternalAddress addr = $constantaddress(T_FLOAT, vreplicate_imm(T_FLOAT, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4448,0 +4380,11 @@\n+\/\/ Replicate double (8 byte) scalar immediate to be vector by loading from const table.\n+instruct ReplD_imm(vec dst, immD con) %{\n+  match(Set dst (ReplicateD con));\n+  format %{ \"replicateD $dst,$con\" %}\n+  ins_encode %{\n+    InternalAddress addr = $constantaddress(T_DOUBLE, vreplicate_imm(T_DOUBLE, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":53,"deletions":110,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -432,0 +432,25 @@\n+  address array_constant(BasicType bt, GrowableArray<jvalue>* c) {\n+    CodeSection* c1 = _code_section;\n+    int len = c->length();\n+    int size = type2aelembytes(bt) * len;\n+    address ptr = start_a_const(size, MIN2(round_up_power_of_2(size), 8));\n+    if (ptr != NULL) {\n+      for (int i = 0; i < len; i++) {\n+        jvalue e = c->at(i);\n+        switch(bt) {\n+          case T_BOOLEAN: emit_int8(e.z);   break;\n+          case T_BYTE:    emit_int8(e.b);   break;\n+          case T_CHAR:    emit_int16(e.c);  break;\n+          case T_SHORT:   emit_int16(e.s);  break;\n+          case T_INT:     emit_int32(e.i);  break;\n+          case T_LONG:    emit_int64(e.j);  break;\n+          case T_FLOAT:   emit_float(e.f);  break;\n+          case T_DOUBLE:  emit_double(e.d); break;\n+          default:\n+            ShouldNotReachHere();\n+        }\n+      }\n+      end_a_const(c1);\n+    }\n+    return ptr;\n+  }\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+  if (is_array() || other.is_array()) {\n+    return is_array() && other.is_array() && _v._array == other._v._array;\n+  }\n@@ -40,4 +43,4 @@\n-  case T_INT:\n-  case T_FLOAT:   return (_v._value.i == other._v._value.i);\n-  case T_LONG:\n-  case T_DOUBLE:  return (_v._value.j == other._v._value.j);\n+  case T_INT:     return (_v._value.i == other._v._value.i);\n+  case T_FLOAT:   return jint_cast(_v._value.f) == jint_cast(other._v._value.f);\n+  case T_LONG:    return (_v._value.j == other._v._value.j);\n+  case T_DOUBLE:  return jlong_cast(_v._value.d) == jlong_cast(other._v._value.d);\n@@ -59,2 +62,5 @@\n-static int type_to_size_in_bytes(BasicType t) {\n-  switch (t) {\n+static int constant_size(ConstantTable::Constant* con) {\n+  if (con->is_array()) {\n+    return type2aelembytes(con->type()) * con->get_array()->length();\n+  }\n+  switch (con->type()) {\n@@ -99,2 +105,3 @@\n-    int typesize = type_to_size_in_bytes(con->type());\n-    offset = align_up(offset, typesize);\n+    int typesize = constant_size(con);\n+    assert(typesize <= 8 || con->is_array(), \"sanity\");\n+    offset = align_up(offset, MIN2(round_up_power_of_2(typesize), 8));\n@@ -122,26 +129,18 @@\n-    switch (con.type()) {\n-    case T_INT:    constant_addr = _masm.int_constant(   con.get_jint()   ); break;\n-    case T_LONG:   constant_addr = _masm.long_constant(  con.get_jlong()  ); break;\n-    case T_FLOAT:  constant_addr = _masm.float_constant( con.get_jfloat() ); break;\n-    case T_DOUBLE: constant_addr = _masm.double_constant(con.get_jdouble()); break;\n-    case T_OBJECT: {\n-      jobject obj = con.get_jobject();\n-      int oop_index = _masm.oop_recorder()->find_index(obj);\n-      constant_addr = _masm.address_constant((address) obj, oop_Relocation::spec(oop_index));\n-      break;\n-    }\n-    case T_ADDRESS: {\n-      address addr = (address) con.get_jobject();\n-      constant_addr = _masm.address_constant(addr);\n-      break;\n-    }\n-    \/\/ We use T_VOID as marker for jump-table entries (labels) which\n-    \/\/ need an internal word relocation.\n-    case T_VOID: {\n-      MachConstantNode* n = (MachConstantNode*) con.get_jobject();\n-      \/\/ Fill the jump-table with a dummy word.  The real value is\n-      \/\/ filled in later in fill_jump_table.\n-      address dummy = (address) n;\n-      constant_addr = _masm.address_constant(dummy);\n-      if (constant_addr == NULL) {\n-        return false;\n+    if (con.is_array()) {\n+      constant_addr = _masm.array_constant(con.type(), con.get_array());\n+    } else {\n+      switch (con.type()) {\n+      case T_INT:    constant_addr = _masm.int_constant(   con.get_jint()   ); break;\n+      case T_LONG:   constant_addr = _masm.long_constant(  con.get_jlong()  ); break;\n+      case T_FLOAT:  constant_addr = _masm.float_constant( con.get_jfloat() ); break;\n+      case T_DOUBLE: constant_addr = _masm.double_constant(con.get_jdouble()); break;\n+      case T_OBJECT: {\n+        jobject obj = con.get_jobject();\n+        int oop_index = _masm.oop_recorder()->find_index(obj);\n+        constant_addr = _masm.address_constant((address) obj, oop_Relocation::spec(oop_index));\n+        break;\n+      }\n+      case T_ADDRESS: {\n+        address addr = (address) con.get_jobject();\n+        constant_addr = _masm.address_constant(addr);\n+        break;\n@@ -149,8 +148,9 @@\n-      assert((constant_addr - _masm.code()->consts()->start()) == con.offset(),\n-             \"must be: %d == %d\", (int)(constant_addr - _masm.code()->consts()->start()), (int)(con.offset()));\n-\n-      \/\/ Expand jump-table\n-      address last_addr = NULL;\n-      for (uint j = 1; j < n->outcnt(); j++) {\n-        last_addr = _masm.address_constant(dummy + j);\n-        if (last_addr == NULL) {\n+      \/\/ We use T_VOID as marker for jump-table entries (labels) which\n+      \/\/ need an internal word relocation.\n+      case T_VOID: {\n+        MachConstantNode* n = (MachConstantNode*) con.get_jobject();\n+        \/\/ Fill the jump-table with a dummy word.  The real value is\n+        \/\/ filled in later in fill_jump_table.\n+        address dummy = (address) n;\n+        constant_addr = _masm.address_constant(dummy);\n+        if (constant_addr == NULL) {\n@@ -159,1 +159,11 @@\n-      }\n+        assert((constant_addr - _masm.code()->consts()->start()) == con.offset(),\n+              \"must be: %d == %d\", (int)(constant_addr - _masm.code()->consts()->start()), (int)(con.offset()));\n+\n+        \/\/ Expand jump-table\n+        address last_addr = NULL;\n+        for (uint j = 1; j < n->outcnt(); j++) {\n+          last_addr = _masm.address_constant(dummy + j);\n+          if (last_addr == NULL) {\n+            return false;\n+          }\n+        }\n@@ -161,7 +171,7 @@\n-      address start = _masm.code()->consts()->start();\n-      address new_constant_addr = last_addr - ((n->outcnt() - 1) * sizeof(address));\n-      \/\/ Expanding the jump-table could result in an expansion of the const code section.\n-      \/\/ In that case, we need to check if the new constant address matches the offset.\n-      assert((constant_addr - start == con.offset()) || (new_constant_addr - start == con.offset()),\n-             \"must be: %d == %d or %d == %d (after an expansion)\", (int)(constant_addr - start), (int)(con.offset()),\n-             (int)(new_constant_addr - start), (int)(con.offset()));\n+        address start = _masm.code()->consts()->start();\n+        address new_constant_addr = last_addr - ((n->outcnt() - 1) * sizeof(address));\n+        \/\/ Expanding the jump-table could result in an expansion of the const code section.\n+        \/\/ In that case, we need to check if the new constant address matches the offset.\n+        assert((constant_addr - start == con.offset()) || (new_constant_addr - start == con.offset()),\n+              \"must be: %d == %d or %d == %d (after an expansion)\", (int)(constant_addr - start), (int)(con.offset()),\n+              (int)(new_constant_addr - start), (int)(con.offset()));\n@@ -169,9 +179,10 @@\n-      continue; \/\/ Loop\n-    }\n-    case T_METADATA: {\n-      Metadata* obj = con.get_metadata();\n-      int metadata_index = _masm.oop_recorder()->find_index(obj);\n-      constant_addr = _masm.address_constant((address) obj, metadata_Relocation::spec(metadata_index));\n-      break;\n-    }\n-    default: ShouldNotReachHere();\n+        continue; \/\/ Loop\n+      }\n+      case T_METADATA: {\n+        Metadata* obj = con.get_metadata();\n+        int metadata_index = _masm.oop_recorder()->find_index(obj);\n+        constant_addr = _masm.address_constant((address) obj, metadata_Relocation::spec(metadata_index));\n+        break;\n+      }\n+      default: ShouldNotReachHere();\n+      }\n@@ -221,0 +232,6 @@\n+ConstantTable::Constant ConstantTable::add(MachConstantNode* n, BasicType bt, GrowableArray<jvalue>* array) {\n+  Constant con(bt, array);\n+  add(con);\n+  return con;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":77,"deletions":60,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+    bool _is_array;\n@@ -44,0 +45,1 @@\n+      GrowableArray<jvalue>* _array;\n@@ -50,1 +52,1 @@\n-    Constant() : _type(T_ILLEGAL), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = 0; }\n+    Constant() : _type(T_ILLEGAL), _is_array(false), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = 0; }\n@@ -53,0 +55,1 @@\n+      _is_array(false),\n@@ -62,0 +65,1 @@\n+      _is_array(false),\n@@ -68,0 +72,13 @@\n+    Constant(BasicType type, GrowableArray<jvalue>* array) :\n+      _type(type),\n+      _is_array(true),\n+      _offset(-1),\n+      _freq(0.0f),\n+      _can_be_reused(false)\n+    {\n+      assert(is_java_primitive(type), \"not applicable for %s\", type2name(type));\n+      _v._array = new GrowableArray<jvalue>(array->length());\n+      for (jvalue ele : *array) {\n+        _v._array->append(ele);\n+      }\n+    }\n@@ -72,0 +89,1 @@\n+    bool is_array()       const    { return _is_array; }\n@@ -81,0 +99,2 @@\n+    GrowableArray<jvalue>* get_array() const { return _v._array; }\n+\n@@ -127,0 +147,1 @@\n+  Constant add(MachConstantNode* n, BasicType bt, GrowableArray<jvalue>* array);\n","filename":"src\/hotspot\/share\/opto\/constantTable.hpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"}]}