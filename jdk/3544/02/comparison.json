{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,9 @@\n-    \/\/ flag inidicating whether to omit the call to C_Initialize()\n+    \/\/ short ms value to indicate how often native cleaner thread is called\n+    private int resourceCleanerShortInterval = 2_000;\n+    \/\/ long ms value to indicate how often native cleaner thread is called\n+    private int resourceCleanerLongInterval = 60_000;\n+\n+    \/\/ should Token be destroyed after logout()\n+    private boolean destroyTokenAfterLogout;\n+\n+    \/\/ flag indicating whether to omit the call to C_Initialize()\n@@ -280,0 +288,12 @@\n+    boolean getDestroyTokenAfterLogout() {\n+        return destroyTokenAfterLogout;\n+    }\n+\n+    int getResourceCleanerShortInterval() {\n+        return resourceCleanerShortInterval;\n+    }\n+\n+    int getResourceCleanerLongInterval() {\n+        return resourceCleanerLongInterval;\n+    }\n+\n@@ -414,0 +434,12 @@\n+            } else if (word.equals(\"cleaner.shortInterval\")) {\n+                resourceCleanerShortInterval = parseIntegerEntry(word);\n+                if (resourceCleanerShortInterval < 1_000) {\n+                    throw excLine(word + \" must be at least 1000 ms\");\n+                }\n+            } else if (word.equals(\"cleaner.longInterval\")) {\n+                resourceCleanerLongInterval = parseIntegerEntry(word);\n+                if (resourceCleanerLongInterval < 1_000) {\n+                    throw excLine(word + \" must be at least 1000 ms\");\n+                }\n+            } else if (word.equals(\"destroyTokenAfterLogout\")) {\n+                destroyTokenAfterLogout = parseBooleanEntry(word);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,4 @@\n+    synchronized void clear() {\n+        strongCache.clear();\n+        cacheReference = null;\n+    }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/KeyCache.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import sun.security.util.Debug;\n@@ -144,2 +143,2 @@\n-        this.keyIDHolder = new NativeKeyHolder(this, keyID, session, extractKeyInfo,\n-            tokenObject);\n+        this.keyIDHolder = new NativeKeyHolder(this, keyID, session,\n+                extractKeyInfo, tokenObject);\n@@ -168,0 +167,12 @@\n+    \/\/ Called by the NativeResourceCleaner at specified intervals\n+    \/\/ See NativeResourceCleaner for more information\n+    static boolean drainRefQueue() {\n+        boolean found = false;\n+        SessionKeyRef next;\n+        while ((next = (SessionKeyRef) SessionKeyRef.refQueue.poll()) != null) {\n+            found = true;\n+            next.dispose();\n+        }\n+        return found;\n+    }\n+\n@@ -884,1 +895,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -893,1 +904,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -1131,1 +1142,0 @@\n-\n@@ -1256,0 +1266,1 @@\n+\n@@ -1329,2 +1340,1 @@\n-    private static ReferenceQueue<P11Key> refQueue =\n-        new ReferenceQueue<P11Key>();\n+    static ReferenceQueue<P11Key> refQueue = new ReferenceQueue<>();\n@@ -1332,15 +1342,1 @@\n-        Collections.synchronizedSet(new HashSet<SessionKeyRef>());\n-\n-    static ReferenceQueue<P11Key> referenceQueue() {\n-        return refQueue;\n-    }\n-\n-    private static void drainRefQueueBounded() {\n-        while (true) {\n-            SessionKeyRef next = (SessionKeyRef) refQueue.poll();\n-            if (next == null) {\n-                break;\n-            }\n-            next.dispose();\n-        }\n-    }\n+        Collections.synchronizedSet(new HashSet<>());\n@@ -1357,1 +1353,2 @@\n-            throw new ProviderException(\"key must be associated with a session\");\n+            throw new ProviderException\n+                    (\"key must be associated with a session\");\n@@ -1363,1 +1360,0 @@\n-        drainRefQueueBounded();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,4 +85,0 @@\n-    long idInternal() {\n-        return id;\n-    }\n-\n@@ -115,0 +111,2 @@\n+    \/\/ regular close which will not close sessions when there are objects(keys)\n+    \/\/ still associated with them\n@@ -116,1 +114,13 @@\n-        if (hasObjects()) {\n+        close(true);\n+    }\n+\n+    \/\/ forced close which will close sessions regardless if there are objects\n+    \/\/ associated with them. Note that closing the sessions this way may\n+    \/\/ lead to those associated objects(keys) un-usable. Thus should only be\n+    \/\/ used for scenarios such as the token is about to be removed, etc.\n+    void kill() {\n+        close(false);\n+    }\n+\n+    private void close(boolean checkObjCtr) {\n+        if (hasObjects() && checkObjCtr) {\n@@ -118,1 +128,1 @@\n-                \"Internal error: close session with active objects\");\n+                    \"Internal error: close session with active objects\");\n@@ -122,1 +132,0 @@\n-}\n@@ -124,0 +133,12 @@\n+    \/\/ Called by the NativeResourceCleaner at specified intervals\n+    \/\/ See NativeResourceCleaner for more information\n+    static boolean drainRefQueue() {\n+        boolean found = false;\n+        SessionRef next;\n+        while ((next = (SessionRef) SessionRef.refQueue.poll())!= null) {\n+            found = true;\n+            next.dispose();\n+        }\n+        return found;\n+    }\n+}\n@@ -132,2 +153,1 @@\n-    private static ReferenceQueue<Session> refQueue =\n-        new ReferenceQueue<Session>();\n+    static ReferenceQueue<Session> refQueue = new ReferenceQueue<>();\n@@ -136,17 +156,1 @@\n-        Collections.synchronizedSortedSet(new TreeSet<SessionRef>());\n-\n-    static ReferenceQueue<Session> referenceQueue() {\n-        return refQueue;\n-    }\n-\n-    static int totalCount() {\n-        return refList.size();\n-    }\n-\n-    private static void drainRefQueueBounded() {\n-        while (true) {\n-            SessionRef next = (SessionRef) refQueue.poll();\n-            if (next == null) break;\n-            next.dispose();\n-        }\n-    }\n+        Collections.synchronizedSortedSet(new TreeSet<>());\n@@ -163,2 +167,0 @@\n-        \/\/ TBD: run at some interval and not every time?\n-        drainRefQueueBounded();\n@@ -173,3 +175,1 @@\n-        } catch (PKCS11Exception e1) {\n-            \/\/ ignore\n-        } catch (ProviderException e2) {\n+        } catch (PKCS11Exception | ProviderException e1) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Session.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-\n@@ -33,1 +32,0 @@\n-\n@@ -174,1 +172,3 @@\n-        closeSession(session);\n+\n+        session.kill();\n+        activeSessions.decrementAndGet();\n@@ -182,1 +182,0 @@\n-\n@@ -191,0 +190,5 @@\n+    void clearPools() {\n+        objSessions.closeAll();\n+        opSessions.closeAll();\n+    }\n+\n@@ -199,0 +203,1 @@\n+\n@@ -241,0 +246,1 @@\n+        private volatile boolean closed = false;\n@@ -263,1 +269,1 @@\n-            if (!pool.offer(session)) {\n+            if (closed || !pool.offer(session)) {\n@@ -271,0 +277,3 @@\n+            \/\/ quick return path\n+            if (pool.size() == 0) return;\n+\n@@ -294,0 +303,9 @@\n+        \/\/ empty out all sessions inside 'pool' and close them.\n+        \/\/ however the Pool can still accept sessions\n+        void closeAll() {\n+            closed = true;\n+            Session s;\n+            while ((s = pool.poll()) != null) {\n+                mgr.killSession(s);\n+            }\n+        }\n@@ -295,1 +313,0 @@\n-\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SessionManager.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import javax.security.auth.callback.ConfirmationCallback;\n@@ -43,1 +42,0 @@\n-import javax.security.auth.callback.TextOutputCallback;\n@@ -91,0 +89,2 @@\n+    static NativeResourceCleaner cleaner;\n+\n@@ -909,1 +909,1 @@\n-    private static class TokenPoller implements Runnable {\n+    private static class TokenPoller extends Thread {\n@@ -912,0 +912,1 @@\n+\n@@ -913,0 +914,4 @@\n+            super((ThreadGroup)null, \"Poller-\" + provider.getName());\n+            setContextClassLoader(null);\n+            setDaemon(true);\n+            setPriority(Thread.MIN_PRIORITY);\n@@ -916,0 +921,1 @@\n+        @Override\n@@ -944,7 +950,2 @@\n-        final TokenPoller poller = new TokenPoller(this);\n-        Thread t = new Thread(null, poller, \"Poller \" + getName(), 0, false);\n-        t.setContextClassLoader(null);\n-        t.setDaemon(true);\n-        t.setPriority(Thread.MIN_PRIORITY);\n-        t.start();\n-        this.poller = poller;\n+        poller = new TokenPoller(this);\n+        poller.start();\n@@ -973,0 +974,50 @@\n+    private class NativeResourceCleaner extends Thread {\n+        private long sleepMillis = config.getResourceCleanerShortInterval();\n+        private int count = 0;\n+        boolean keyRefFound, sessRefFound;\n+\n+        private NativeResourceCleaner() {\n+            super((ThreadGroup)null, \"Cleanup-SunPKCS11\");\n+            setContextClassLoader(null);\n+            setDaemon(true);\n+            setPriority(Thread.MIN_PRIORITY);\n+        }\n+\n+        \/*\n+         * The cleaner.shortInterval and cleaner.longInterval properties\n+         * may be defined in the pkcs11 config file and are specified in milliseconds\n+         * Minimum value is 1000ms.  Default values :\n+         *  cleaner.shortInterval : 2000ms\n+         *  cleaner.longInterval  : 60000ms\n+         *\n+         * The cleaner thread runs at cleaner.shortInterval intervals\n+         * while P11Key or Session references continue to be found for cleaning.\n+         * If 100 iterations occur with no references being found, then the interval\n+         * period moves to cleaner.longInterval value. The cleaner thread moves back\n+         * to short interval checking if a resource is found\n+         *\/\n+        @Override\n+        public void run() {\n+            while (true) {\n+                try {\n+                    sleep(sleepMillis);\n+                } catch (InterruptedException ie) {\n+                    break;\n+                }\n+                keyRefFound = P11Key.drainRefQueue();\n+                sessRefFound = Session.drainRefQueue();\n+                if (!keyRefFound && !sessRefFound) {\n+                    count++;\n+                    if (count > 100) {\n+                        \/\/ no reference freed for some time\n+                        \/\/ increase the sleep time\n+                        sleepMillis = config.getResourceCleanerLongInterval();\n+                    }\n+                } else {\n+                    count = 0;\n+                    sleepMillis = config.getResourceCleanerShortInterval();\n+                }\n+            }\n+        }\n+    }\n+\n@@ -988,1 +1039,4 @@\n-        createPoller();\n+        \/\/ keep polling for token insertion unless configured not to\n+        if (removable && !config.getDestroyTokenAfterLogout()) {\n+            createPoller();\n+        }\n@@ -1135,0 +1189,4 @@\n+        if (cleaner == null) {\n+            cleaner = new NativeResourceCleaner();\n+            cleaner.start();\n+        }\n@@ -1349,1 +1407,1 @@\n-        if (hasValidToken() == false) {\n+        if (!hasValidToken()) {\n@@ -1351,0 +1409,1 @@\n+\n@@ -1354,1 +1413,0 @@\n-\n@@ -1466,1 +1524,0 @@\n-\n@@ -1492,1 +1549,1 @@\n-            if (token.isLoggedInNow(null) == false) {\n+            if (!token.isLoggedInNow(null)) {\n@@ -1496,0 +1553,3 @@\n+                if (config.getDestroyTokenAfterLogout()) {\n+                    token.destroy();\n+                }\n@@ -1503,1 +1563,0 @@\n-\n@@ -1524,0 +1583,3 @@\n+            if (config.getDestroyTokenAfterLogout()) {\n+                token.destroy();\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":78,"deletions":16,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -295,1 +295,4 @@\n-        valid = false;\n+        secretCache.clear();\n+        privateCache.clear();\n+\n+        sessionManager.clearPools();\n@@ -297,0 +300,1 @@\n+        valid = false;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-\n@@ -27,1 +26,0 @@\n-import java.io.BufferedReader;\n@@ -32,1 +30,0 @@\n-import java.io.InputStreamReader;\n@@ -110,1 +107,1 @@\n-    static Provider pkcs11;\n+    static Provider pkcs11 = newPKCS11Provider();\n@@ -112,3 +109,1 @@\n-    \/\/ Goes through ServiceLoader instead of Provider.getInstance() since it\n-    \/\/ works on all platforms\n-    static {\n+    public static Provider newPKCS11Provider() {\n@@ -139,1 +134,1 @@\n-        pkcs11 = p;\n+        return p;\n@@ -142,1 +137,1 @@\n-    \/\/ Return a SunPKCS11 provider configured with the specified config file\n+    \/\/ Return the static test SunPKCS11 provider configured with the specified config file\n@@ -144,1 +139,6 @@\n-        if (pkcs11 == null) {\n+        return getSunPKCS11(config, pkcs11);\n+    }\n+\n+    \/\/ Return the Provider p configured with the specified config file\n+    static Provider getSunPKCS11(String config, Provider p) throws Exception {\n+        if (p == null) {\n@@ -147,1 +147,1 @@\n-        return pkcs11.configure(config);\n+        return p.configure(config);\n@@ -539,0 +539,1 @@\n+    \/\/ Run NSS testing on a Provider p configured with test nss config\n@@ -540,0 +541,10 @@\n+        String nssConfig = getNssConfig();\n+        if (nssConfig == null) {\n+            \/\/ issue loading libraries\n+            return;\n+        }\n+        Provider p = getSunPKCS11(nssConfig);\n+        test.premain(p);\n+    }\n+\n+    public static String getNssConfig() throws Exception {\n@@ -542,1 +553,1 @@\n-            return;\n+            return null;\n@@ -544,1 +555,0 @@\n-        String base = getBase();\n@@ -547,1 +557,1 @@\n-            return;\n+            return null;\n@@ -550,0 +560,2 @@\n+        String base = getBase();\n+\n@@ -554,2 +566,2 @@\n-                                customDBdir :\n-                                base + SEP + \"nss\" + SEP + \"db\";\n+                customDBdir :\n+                base + SEP + \"nss\" + SEP + \"db\";\n@@ -561,4 +573,0 @@\n-        String p11config = (customConfig != null) ?\n-                                customConfig :\n-                                base + SEP + \"nss\" + SEP + customConfigName;\n-\n@@ -567,2 +575,3 @@\n-        Provider p = getSunPKCS11(p11config);\n-        test.premain(p);\n+        return (customConfig != null) ?\n+                customConfig :\n+                base + SEP + \"nss\" + SEP + customConfigName;\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":32,"deletions":23,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,12 @@\n+name = NSS\n+\n+slot = 2\n+\n+library = ${pkcs11test.nss.lib}\n+\n+nssArgs = \"configdir='${pkcs11test.nss.db}' certPrefix='' keyPrefix='' secmod='secmod.db' flags=readOnly\"\n+\n+destroyTokenAfterLogout = true\n+cleaner.longInterval = 10000\n+cleaner.shortInterval = 1000\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins-nss.txt","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import sun.security.pkcs11.SunPKCS11;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.auth.login.LoginException;\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.security.KeyStore;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.util.Iterator;\n+import java.util.ServiceConfigurationError;\n+import java.util.ServiceLoader;\n+\n+import jdk.test.lib.util.ForceGC;\n+\n+public class MultipleLogins {\n+    private static final String KS_TYPE = \"PKCS11\";\n+    private static final int NUM_PROVIDERS = 20;\n+    private static final SunPKCS11[] providers = new SunPKCS11[NUM_PROVIDERS];\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i =0; i < NUM_PROVIDERS; i++) {\n+            String nssConfig = PKCS11Test.getNssConfig();\n+            if (nssConfig == null) {\n+                throw new RuntimeException(\"issue setting up config\");\n+            }\n+            providers[i] =\n+                    (SunPKCS11)PKCS11Test.newPKCS11Provider()\n+                    .configure(nssConfig);\n+            Security.addProvider(providers[i]);\n+            test(providers[i]);\n+        }\n+\n+        WeakReference<SunPKCS11>[] weakRef = new WeakReference[NUM_PROVIDERS];\n+        for (int i =0; i < NUM_PROVIDERS; i++) {\n+            weakRef[i] = new WeakReference<>(providers[i]);\n+            providers[i].logout();\n+\n+            if (i == 0) {\n+                \/\/ one provider stays for use with clean up thread\n+                continue;\n+            }\n+\n+            try {\n+                providers[i].login(new Subject(), new PasswordCallbackHandler());\n+                throw new RuntimeException(\"Expected LoginException\");\n+            } catch (LoginException le) {\n+                \/\/ expected\n+            }\n+\n+            Security.removeProvider(providers[i].getName());\n+            providers[i] = null;\n+\n+            ForceGC gc = new ForceGC();\n+            int finalI = i;\n+            gc.await(() -> weakRef[finalI].get() == null);\n+            if (!weakRef[i].refersTo(null)) {\n+                throw new RuntimeException(\"Expected SunPKCS11 Provider to be GC'ed..\");\n+            }\n+        }\n+    }\n+\n+    private static void test(SunPKCS11 p) throws Exception {\n+        KeyStore ks = KeyStore.getInstance(KS_TYPE, p);\n+\n+        p.setCallbackHandler(new PasswordCallbackHandler());\n+        try {\n+            ks.load(null, (char[]) null);\n+        } catch (IOException e) {\n+            if (!e.getMessage().contains(\"load failed\")) {\n+                \/\/ we expect the keystore load to fail\n+                throw new RuntimeException(\"unexpected exception\", e);\n+            }\n+        }\n+\n+        p.logout();\n+\n+        try {\n+            ks.load(null, (char[]) null);\n+        } catch (IOException e) {\n+            if (e.getCause() instanceof LoginException &&\n+                    e.getCause().getMessage().contains(\"No token present\")) {\n+                \/\/ expected\n+            } else {\n+                throw new RuntimeException(\"Token was present\", e);\n+            }\n+        }\n+    }\n+\n+    public static class PasswordCallbackHandler implements CallbackHandler {\n+        public void handle(Callback[] callbacks)\n+                throws IOException, UnsupportedCallbackException {\n+            if (!(callbacks[0] instanceof PasswordCallback)) {\n+                throw new UnsupportedCallbackException(callbacks[0]);\n+            }\n+            PasswordCallback pc = (PasswordCallback)callbacks[0];\n+            pc.setPassword(null);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# @test\n+# @bug 7777777\n+# @summary\n+# @library \/test\/lib\/\n+# @build jdk.test.lib.util.ForceGC\n+# @run shell MultipleLogins.sh\n+\n+# set a few environment variables so that the shell-script can run stand-alone\n+# in the source directory\n+\n+# if running by hand on windows, change TESTSRC and TESTCLASSES to \".\"\n+if [ \"${TESTSRC}\" = \"\" ] ; then\n+    TESTSRC=`pwd`\n+fi\n+if [ \"${TESTCLASSES}\" = \"\" ] ; then\n+    TESTCLASSES=`pwd`\n+fi\n+\n+if [ \"${TESTCLASSPATH}\" = \"\" ] ; then\n+    TESTCLASSPATH=`pwd`\n+fi\n+\n+if [ \"${COMPILEJAVA}\" = \"\" ]; then\n+    COMPILEJAVA=\"${TESTJAVA}\"\n+fi\n+echo TESTSRC=${TESTSRC}\n+echo TESTCLASSES=${TESTCLASSES}\n+echo TESTJAVA=${TESTJAVA}\n+echo COMPILEJAVA=${COMPILEJAVA}\n+echo \"\"\n+\n+# let java test exit if platform unsupported\n+\n+OS=`uname -s`\n+case \"$OS\" in\n+  Linux )\n+    FS=\"\/\"\n+    PS=\":\"\n+    CP=\"${FS}bin${FS}cp\"\n+    CHMOD=\"${FS}bin${FS}chmod\"\n+    ;;\n+  Darwin )\n+    FS=\"\/\"\n+    PS=\":\"\n+    CP=\"${FS}bin${FS}cp\"\n+    CHMOD=\"${FS}bin${FS}chmod\"\n+    ;;\n+  AIX )\n+    FS=\"\/\"\n+    PS=\":\"\n+    CP=\"${FS}bin${FS}cp\"\n+    CHMOD=\"${FS}bin${FS}chmod\"\n+    ;;\n+  Windows* )\n+    FS=\"\\\\\"\n+    PS=\";\"\n+    CP=\"cp\"\n+    CHMOD=\"chmod\"\n+    ;;\n+  CYGWIN* )\n+    FS=\"\/\"\n+    PS=\";\"\n+    CP=\"cp\"\n+    CHMOD=\"chmod\"\n+    #\n+    # javac does not like \/cygdrive produced by `pwd`\n+    #\n+    TESTSRC=`cygpath -d ${TESTSRC}`\n+    ;;\n+  * )\n+    echo \"Unrecognized system!\"\n+    exit 1;\n+    ;;\n+esac\n+\n+# first make cert\/key DBs writable\n+\n+${CP} ${TESTSRC}${FS}..${FS}nss${FS}db${FS}cert8.db ${TESTCLASSES}\n+${CHMOD} +w ${TESTCLASSES}${FS}cert8.db\n+\n+${CP} ${TESTSRC}${FS}..${FS}nss${FS}db${FS}key3.db ${TESTCLASSES}\n+${CHMOD} +w ${TESTCLASSES}${FS}key3.db\n+\n+# compile test\n+${COMPILEJAVA}${FS}bin${FS}javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} \\\n+        -classpath ${TESTCLASSPATH} \\\n+        -d ${TESTCLASSES} \\\n+        --add-modules jdk.crypto.cryptoki \\\n+        --add-exports jdk.crypto.cryptoki\/sun.security.pkcs11=ALL-UNNAMED \\\n+        ${TESTSRC}${FS}..${FS}..${FS}..${FS}..${FS}..${FS}lib${FS}jdk${FS}test${FS}lib${FS}artifacts${FS}*.java \\\n+        ${TESTSRC}${FS}MultipleLogins.java \\\n+        ${TESTSRC}${FS}..${FS}PKCS11Test.java\n+\n+# run test\n+${TESTJAVA}${FS}bin${FS}java ${TESTVMOPTS} \\\n+        -classpath ${TESTCLASSPATH} \\\n+        --add-modules jdk.crypto.cryptoki \\\n+        --add-exports jdk.crypto.cryptoki\/sun.security.pkcs11=ALL-UNNAMED \\\n+        -DCUSTOM_DB_DIR=${TESTCLASSES} \\\n+        -DCUSTOM_P11_CONFIG=${TESTSRC}${FS}MultipleLogins-nss.txt \\\n+        -DNO_DEFAULT=true \\\n+        -DNO_DEIMOS=true \\\n+        -Dtest.src=${TESTSRC} \\\n+        -Dtest.classes=${TESTCLASSES} \\\n+        -Djava.security.debug=${DEBUG} \\\n+        MultipleLogins\n+\n+# save error status\n+status=$?\n+\n+# return\n+exit $status\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins.sh","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"}]}