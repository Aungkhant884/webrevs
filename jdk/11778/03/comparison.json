{"files":[{"patch":"@@ -367,6 +367,0 @@\n-  \/\/ handle the case of an anchor explicitly set in continuation code that doesn't have a callee\n-  JavaThread* thread = reg_map->thread();\n-  if (thread->has_last_Java_frame() && fr.sp() == thread->last_Java_sp()) {\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"runtime\/clearLastJavaFrameMark.hpp\"\n@@ -71,2 +72,4 @@\n-  \/\/ Verify the head (no_frames) of the thread is bad before fixing it.\n-  ZVerify::verify_thread_head_bad(_jt);\n+  {\n+    \/\/ It isn't safe to trace through this code as that might involve walking through\n+    \/\/ continuation oops that have not been fixed up yet.\n+    ClearLastJavaFrameMark dstm(_jt);\n@@ -74,3 +77,2 @@\n-  \/\/ Process the non-frame part of the thread\n-  _jt->oops_do_no_frames(closure_from_context(context), &_cb_cl);\n-  ZThreadLocalData::do_invisible_root(_jt, ZBarrier::load_barrier_on_invisible_root_oop_field);\n+    \/\/ Verify the head (no_frames) of the thread is bad before fixing it.\n+    ZVerify::verify_thread_head_bad(_jt);\n@@ -78,3 +80,8 @@\n-  \/\/ Verification of frames is done after processing of the \"head\" (no_frames).\n-  \/\/ The reason is that the exception oop is fiddled with during frame processing.\n-  ZVerify::verify_thread_frames_bad(_jt);\n+    \/\/ Process the non-frame part of the thread\n+    _jt->oops_do_no_frames(closure_from_context(context), &_cb_cl);\n+    ZThreadLocalData::do_invisible_root(_jt, ZBarrier::load_barrier_on_invisible_root_oop_field);\n+\n+    \/\/ Verification of frames is done after processing of the \"head\" (no_frames).\n+    \/\/ The reason is that the exception oop is fiddled with during frame processing.\n+    ZVerify::verify_thread_frames_bad(_jt);\n+  }\n@@ -97,0 +104,4 @@\n+  \/\/ It isn't safe to trace through this code as that might involve walking through\n+  \/\/ continuation oops that have not been fixed up yet.\n+  ClearLastJavaFrameMark dstm(_jt);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zStackWatermark.cpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/stackWatermark.hpp\"\n@@ -390,0 +391,1 @@\n+  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/clearLastJavaFrameMark.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+\n+DEBUG_ONLY(THREAD_LOCAL bool ClearLastJavaFrameMark::_is_active = false;)\n+\n+ClearLastJavaFrameMark::ClearLastJavaFrameMark(JavaThread* jt)\n+  : _jt(nullptr),\n+    _sp(nullptr) {\n+  if (jt == Thread::current()) {\n+    \/\/ This class only clears the frame anchor for the current thread.\n+    \/\/ We can't safely clear the frame anchor of another thread. Besides,\n+    \/\/ the point of this class is to protect against stack walks from\n+    \/\/ the current thread in a given scope.\n+    _jt = jt;\n+    _sp = begin(jt);\n+  }\n+}\n+\n+ClearLastJavaFrameMark::~ClearLastJavaFrameMark() {\n+  if (_jt != nullptr) {\n+    end(_jt, _sp);\n+  }\n+}\n+\n+intptr_t* ClearLastJavaFrameMark::begin(JavaThread* jt) {\n+  assert(!_is_active, \"nesting not supported\");\n+  DEBUG_ONLY(_is_active = true;)\n+  intptr_t* sp = jt->frame_anchor()->last_Java_sp();\n+  jt->frame_anchor()->set_last_Java_sp(NULL);\n+  return sp;\n+}\n+\n+void ClearLastJavaFrameMark::end(JavaThread* jt, intptr_t* sp) {\n+  assert(_is_active, \"mismatched begin and end\");\n+  jt->frame_anchor()->set_last_Java_sp(sp);\n+  DEBUG_ONLY(_is_active = false;)\n+}\n","filename":"src\/hotspot\/share\/runtime\/clearLastJavaFrameMark.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CLEARLASTJAVAFRAMEMARK_HPP\n+#define SHARE_RUNTIME_CLEARLASTJAVAFRAMEMARK_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class JavaThread;\n+\n+\/\/ Use this class to mark a section of code where stack tracing from the\n+\/\/ current thread is not safe and should be avoided.\n+class ClearLastJavaFrameMark : public StackObj {\n+  DEBUG_ONLY(static THREAD_LOCAL bool _is_active;)\n+  JavaThread* _jt;\n+  intptr_t* _sp;\n+\n+  static intptr_t* begin(JavaThread* jt);\n+  static void end(JavaThread* jt, intptr_t* sp);\n+\n+public:\n+  ClearLastJavaFrameMark(JavaThread* jt);\n+  ~ClearLastJavaFrameMark();\n+\n+  DEBUG_ONLY(static bool is_active() { return _is_active; })\n+};\n+\n+\n+#endif \/\/ SHARE_RUNTIME_CLEARLASTJAVAFRAMEMARK_HPP\n","filename":"src\/hotspot\/share\/runtime\/clearLastJavaFrameMark.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -50,0 +50,2 @@\n+  static inline void avoid_lazy_thaw_arguments(RegisterMap* map);\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,26 @@\n+inline void ContinuationHelper::avoid_lazy_thaw_arguments(RegisterMap* map) {\n+  \/\/ When we lazy thaw frames, we can end up with a compiled method as the top frame,\n+  \/\/ but it doesn't have a callee. So we don't want to preserve its arguments.\n+\n+  if (!map->update_map()) {\n+    return;\n+  }\n+\n+  JavaThread* thread = map->thread();\n+\n+  if (!thread->has_last_Java_frame()) {\n+    return;\n+  }\n+\n+  frame f = thread->last_frame();\n+  if (!CodeCache::contains(f.pc())) {\n+    return;\n+  }\n+\n+  if (f.oop_map() == nullptr) {\n+    return;\n+  }\n+\n+  map->set_include_argument_oops(false);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+#include \"runtime\/clearLastJavaFrameMark.hpp\"\n@@ -754,5 +755,5 @@\n-  \/\/ We set the last_Java frame. But the stack isn't really parsable here. So we\n-  \/\/ clear it to make sure JFR understands not to try and walk stacks from events\n-  \/\/ in here.\n-  intptr_t* sp = thread->frame_anchor()->last_Java_sp();\n-  thread->frame_anchor()->set_last_Java_sp(NULL);\n+  {\n+    \/\/ We set the last_Java frame. But the stack isn't really parsable here. So we\n+    \/\/ clear it to make sure JFR understands not to try and walk stacks from events\n+    \/\/ in here.\n+    ClearLastJavaFrameMark dstm(thread);\n@@ -760,2 +761,3 @@\n-  \/\/ Unpack the interpreter frames and any adapter frame (c2 only) we might create.\n-  array->unpack_to_stack(stub_frame, exec_mode, info->caller_actual_parameters());\n+    \/\/ Unpack the interpreter frames and any adapter frame (c2 only) we might create.\n+    array->unpack_to_stack(stub_frame, exec_mode, info->caller_actual_parameters());\n+  }\n@@ -763,1 +765,0 @@\n-  thread->frame_anchor()->set_last_Java_sp(sp);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/continuationHelper.inline.hpp\"\n@@ -69,0 +70,2 @@\n+  \/\/ handle the case of an anchor explicitly set in continuation code that doesn't have a callee\n+  ContinuationHelper::avoid_lazy_thaw_arguments(this);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1339,7 +1339,3 @@\n-  DEBUG_ONLY(verify_frame_info();)\n-\n-  if (has_last_Java_frame()) {\n-    \/\/ Traverse the monitor chunks\n-    for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n-      chunk->oops_do(f);\n-    }\n+  \/\/ Traverse the monitor chunks\n+  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+    chunk->oops_do(f);\n@@ -1383,0 +1379,2 @@\n+  DEBUG_ONLY(verify_frame_info();)\n+\n@@ -1386,0 +1384,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"}]}