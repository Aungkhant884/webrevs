{"files":[{"patch":"@@ -94,0 +94,1 @@\n+  BasicType bt = access.type();\n@@ -98,1 +99,1 @@\n-    if (access.type() == T_DOUBLE) {\n+    if (bt == T_DOUBLE) {\n@@ -103,2 +104,2 @@\n-    store = kit->store_to_memory(kit->control(), access.addr().node(), val.node(), access.type(),\n-                                     access.addr().type(), mo, requires_atomic_access, unaligned, mismatched, unsafe);\n+    store = kit->store_to_memory(kit->control(), access.addr().node(), val.node(), bt,\n+                                 access.addr().type(), mo, requires_atomic_access, unaligned, mismatched, unsafe);\n@@ -106,1 +107,0 @@\n-    assert(!requires_atomic_access, \"not yet supported\");\n@@ -116,1 +116,1 @@\n-    StoreNode* st = StoreNode::make(gvn, ctl, mem, access.addr().node(), adr_type, val.node(), access.type(), mo);\n+    StoreNode* st = StoreNode::make(gvn, ctl, mem, access.addr().node(), adr_type, val.node(), bt, mo, requires_atomic_access);\n@@ -159,1 +159,0 @@\n-      assert(!requires_atomic_access, \"can't ensure atomicity\");\n@@ -163,2 +162,2 @@\n-                            adr_type, val_type, access.type(), mo, dep, unaligned,\n-                            mismatched, unsafe, access.barrier_data());\n+                            adr_type, val_type, access.type(), mo, dep, requires_atomic_access,\n+                            unaligned, mismatched, unsafe, access.barrier_data());\n@@ -172,1 +171,0 @@\n-    assert(!requires_atomic_access, \"not yet supported\");\n@@ -179,2 +177,2 @@\n-    load = LoadNode::make(gvn, control, mem, adr, adr_type, val_type, access.type(), mo,\n-                          dep, unaligned, mismatched, unsafe, access.barrier_data());\n+    load = LoadNode::make(gvn, control, mem, adr, adr_type, val_type, access.type(), mo, dep,\n+                          requires_atomic_access, unaligned, mismatched, unsafe, access.barrier_data());\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1538,8 +1538,1 @@\n-  Node* ld;\n-  if (require_atomic_access && bt == T_LONG) {\n-    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);\n-  } else if (require_atomic_access && bt == T_DOUBLE) {\n-    ld = LoadDNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);\n-  } else {\n-    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);\n-  }\n+  Node* ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, require_atomic_access, unaligned, mismatched, unsafe, barrier_data);\n@@ -1565,8 +1558,1 @@\n-  Node* st;\n-  if (require_atomic_access && bt == T_LONG) {\n-    st = StoreLNode::make_atomic(ctl, mem, adr, adr_type, val, mo);\n-  } else if (require_atomic_access && bt == T_DOUBLE) {\n-    st = StoreDNode::make_atomic(ctl, mem, adr, adr_type, val, mo);\n-  } else {\n-    st = StoreNode::make(_gvn, ctl, mem, adr, adr_type, val, bt, mo);\n-  }\n+  Node* st = StoreNode::make(_gvn, ctl, mem, adr, adr_type, val, bt, mo, require_atomic_access);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -361,6 +361,1 @@\n-  Node* ld;\n-  if (require_atomic_access && bt == T_LONG) {\n-    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo);\n-  } else {\n-    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo);\n-  }\n+  Node* ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, LoadNode::DependsOnlyOnTest, require_atomic_access);\n@@ -378,6 +373,1 @@\n-  Node* st;\n-  if (require_atomic_access && bt == T_LONG) {\n-    st = StoreLNode::make_atomic(ctl, mem, adr, adr_type, val, mo);\n-  } else {\n-    st = StoreNode::make(_gvn, ctl, mem, adr, adr_type, val, bt, mo);\n-  }\n+  Node* st = StoreNode::make(_gvn, ctl, mem, adr, adr_type, val, bt, mo, require_atomic_access);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1148,1 +1148,1 @@\n-  mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt, MemNode::unordered);\n+  mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -962,1 +962,1 @@\n-        mem = StoreNode::make(_igvn, ctrl, mem, p1, adr_type, intcon(0), T_INT, MemNode::unordered);\n+        mem = StoreNode::make(_igvn, ctrl, mem, p1, adr_type, intcon(0), T_INT);\n@@ -1020,1 +1020,1 @@\n-                         false \/*unaligned*\/, is_mismatched));\n+                         false \/*require_atomic_access*\/, false \/*unaligned*\/, is_mismatched));\n@@ -1022,2 +1022,1 @@\n-          StoreNode::make(_igvn, *ctrl, (*mem)->memory_at(d_alias_idx), dptr, adr_type,\n-                          sval, T_INT, MemNode::unordered));\n+          StoreNode::make(_igvn, *ctrl, (*mem)->memory_at(d_alias_idx), dptr, adr_type, sval, T_INT));\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -864,2 +864,2 @@\n-Node *LoadNode::make(PhaseGVN& gvn, Node *ctl, Node *mem, Node *adr, const TypePtr* adr_type, const Type *rt, BasicType bt, MemOrd mo,\n-                     ControlDependency control_dependency, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {\n+Node* LoadNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, const Type* rt, BasicType bt, MemOrd mo,\n+                     ControlDependency control_dependency, bool require_atomic_access, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {\n@@ -887,1 +887,1 @@\n-  case T_LONG:    load = new LoadLNode (ctl, mem, adr, adr_type, rt->is_long(), mo, control_dependency); break;\n+  case T_LONG:    load = new LoadLNode (ctl, mem, adr, adr_type, rt->is_long(), mo, control_dependency, require_atomic_access); break;\n@@ -889,1 +889,1 @@\n-  case T_DOUBLE:  load = new LoadDNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency); break;\n+  case T_DOUBLE:  load = new LoadDNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency, require_atomic_access); break;\n@@ -925,36 +925,0 @@\n-LoadLNode* LoadLNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, const Type* rt, MemOrd mo,\n-                                  ControlDependency control_dependency, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {\n-  bool require_atomic = true;\n-  LoadLNode* load = new LoadLNode(ctl, mem, adr, adr_type, rt->is_long(), mo, control_dependency, require_atomic);\n-  if (unaligned) {\n-    load->set_unaligned_access();\n-  }\n-  if (mismatched) {\n-    load->set_mismatched_access();\n-  }\n-  if (unsafe) {\n-    load->set_unsafe_access();\n-  }\n-  load->set_barrier_data(barrier_data);\n-  return load;\n-}\n-\n-LoadDNode* LoadDNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, const Type* rt, MemOrd mo,\n-                                  ControlDependency control_dependency, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {\n-  bool require_atomic = true;\n-  LoadDNode* load = new LoadDNode(ctl, mem, adr, adr_type, rt, mo, control_dependency, require_atomic);\n-  if (unaligned) {\n-    load->set_unaligned_access();\n-  }\n-  if (mismatched) {\n-    load->set_mismatched_access();\n-  }\n-  if (unsafe) {\n-    load->set_unsafe_access();\n-  }\n-  load->set_barrier_data(barrier_data);\n-  return load;\n-}\n-\n-\n-\n@@ -1292,1 +1256,1 @@\n-                        is_unaligned_access(), is_mismatched_access());\n+                        false \/*require_atomic_access*\/, is_unaligned_access(), is_mismatched_access());\n@@ -1312,1 +1276,1 @@\n-                        is_unaligned_access(), is_mismatched_access());\n+                        false \/*require_atomic_access*\/, is_unaligned_access(), is_mismatched_access());\n@@ -1335,0 +1299,2 @@\n+  bool require_atomic_access = (Opcode() == Op_LoadL && ((LoadLNode*)this)->require_atomic_access()) ||\n+                               (Opcode() == Op_LoadD && ((LoadDNode*)this)->require_atomic_access());\n@@ -1337,1 +1303,1 @@\n-                        is_unaligned_access(), is_mismatched);\n+                        require_atomic_access, is_unaligned_access(), is_mismatched);\n@@ -1355,1 +1321,4 @@\n-  StoreNode* st = StoreNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address), raw_adr_type(), val, bt, _mo);\n+  bool require_atomic_access = (Opcode() == Op_StoreL && ((StoreLNode*)this)->require_atomic_access()) ||\n+                               (Opcode() == Op_StoreD && ((StoreDNode*)this)->require_atomic_access());\n+  StoreNode* st = StoreNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address),\n+                                  raw_adr_type(), val, bt, _mo, require_atomic_access);\n@@ -2585,1 +2554,1 @@\n-StoreNode* StoreNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, BasicType bt, MemOrd mo) {\n+StoreNode* StoreNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, BasicType bt, MemOrd mo, bool require_atomic_access) {\n@@ -2597,1 +2566,1 @@\n-  case T_LONG:    return new StoreLNode(ctl, mem, adr, adr_type, val, mo);\n+  case T_LONG:    return new StoreLNode(ctl, mem, adr, adr_type, val, mo, require_atomic_access);\n@@ -2599,1 +2568,1 @@\n-  case T_DOUBLE:  return new StoreDNode(ctl, mem, adr, adr_type, val, mo);\n+  case T_DOUBLE:  return new StoreDNode(ctl, mem, adr, adr_type, val, mo, require_atomic_access);\n@@ -2623,11 +2592,0 @@\n-StoreLNode* StoreLNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo) {\n-  bool require_atomic = true;\n-  return new StoreLNode(ctl, mem, adr, adr_type, val, mo, require_atomic);\n-}\n-\n-StoreDNode* StoreDNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo) {\n-  bool require_atomic = true;\n-  return new StoreDNode(ctl, mem, adr, adr_type, val, mo, require_atomic);\n-}\n-\n-\n@@ -3200,1 +3158,1 @@\n-    mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT);\n@@ -3259,1 +3217,1 @@\n-    mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT, MemNode::unordered);\n+    mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase->zerocon(T_INT), T_INT);\n@@ -4283,1 +4241,1 @@\n-                                  phase->longcon(con), T_LONG, MemNode::unordered);\n+                                  phase->longcon(con), T_LONG);\n@@ -4290,1 +4248,1 @@\n-                                    phase->intcon(con0), T_INT, MemNode::unordered);\n+                                    phase->intcon(con0), T_INT);\n@@ -4298,1 +4256,1 @@\n-                                    phase->intcon(con1), T_INT, MemNode::unordered);\n+                                    phase->intcon(con1), T_INT);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":21,"deletions":63,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-  static Node* make(PhaseGVN& gvn, Node *c, Node *mem, Node *adr,\n-                    const TypePtr* at, const Type *rt, BasicType bt,\n+  static Node* make(PhaseGVN& gvn, Node* c, Node* mem, Node* adr,\n+                    const TypePtr* at, const Type* rt, BasicType bt,\n@@ -232,1 +232,1 @@\n-                    bool unaligned = false, bool mismatched = false, bool unsafe = false,\n+                    bool require_atomic_access = false, bool unaligned = false, bool mismatched = false, bool unsafe = false,\n@@ -417,3 +417,1 @@\n-  static LoadLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,\n-                                const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,\n-                                bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);\n+\n@@ -469,3 +467,1 @@\n-  static LoadDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,\n-                                const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,\n-                                bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);\n+\n@@ -612,2 +608,3 @@\n-  static StoreNode* make(PhaseGVN& gvn, Node *c, Node *mem, Node *adr,\n-                         const TypePtr* at, Node *val, BasicType bt, MemOrd mo);\n+  static StoreNode* make(PhaseGVN& gvn, Node* c, Node* mem, Node* adr,\n+                         const TypePtr* at, Node* val, BasicType bt,\n+                         MemOrd mo = MemNode::unordered, bool require_atomic_access = false);\n@@ -694,1 +691,1 @@\n-  static StoreLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);\n+\n@@ -730,1 +727,1 @@\n-  static StoreDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 8251871\n+ * @bug 8251871 8285301\n@@ -32,1 +32,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -53,0 +53,2 @@\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+AlwaysAtomicAccesses\n+ *      compiler.arraycopy.TestArrayCopyConjoint\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyConjoint.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 8251871\n+ * @bug 8251871 8285301\n@@ -32,1 +32,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -53,0 +53,2 @@\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+AlwaysAtomicAccesses\n+ *      compiler.arraycopy.TestArrayCopyDisjoint\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyDisjoint.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6700100 8156760 8248226\n+ * @bug 6700100 8156760 8248226 8285301\n@@ -45,0 +45,4 @@\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileCommand=dontinline,compiler.arraycopy.TestInstanceCloneAsLoadsStores::m*\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+AlwaysAtomicAccesses\n+ *                   compiler.arraycopy.TestInstanceCloneAsLoadsStores\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestInstanceCloneAsLoadsStores.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test TestAlwaysAtomicAccesses\n+ * @bug 8285301\n+ * @summary Test memory accesses with AlwaysAtomicAccesses.\n+ * @run main\/othervm -Xcomp -XX:+UnlockExperimentalVMOptions -XX:+AlwaysAtomicAccesses\n+ *                   compiler.membars.TestAlwaysAtomicAccesses\n+ *\/\n+\n+package compiler.membars;\n+\n+public class TestAlwaysAtomicAccesses {\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Test passed\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestAlwaysAtomicAccesses.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"}]}