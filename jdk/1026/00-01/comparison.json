{"files":[{"patch":"@@ -96,1 +96,0 @@\n-\n@@ -98,1 +97,1 @@\n-\n+    static final ListN<?> EMPTY_LIST_NULLS;\n@@ -100,1 +99,0 @@\n-\n@@ -107,1 +105,2 @@\n-            EMPTY_LIST = new ListN<>(new Object[0]);\n+            EMPTY_LIST = new ListN<>(new Object[0], false);\n+            EMPTY_LIST_NULLS = new ListN<>(new Object[0], true);\n@@ -110,1 +109,2 @@\n-            archivedObjects = new Object[] { EMPTY, EMPTY_LIST, EMPTY_SET, EMPTY_MAP };\n+            archivedObjects =\n+                new Object[] { EMPTY, EMPTY_LIST, EMPTY_LIST_NULLS, EMPTY_SET, EMPTY_MAP };\n@@ -114,2 +114,3 @@\n-            EMPTY_SET = (SetN)archivedObjects[2];\n-            EMPTY_MAP = (MapN)archivedObjects[3];\n+            EMPTY_LIST_NULLS = (ListN)archivedObjects[2];\n+            EMPTY_SET = (SetN)archivedObjects[3];\n+            EMPTY_MAP = (MapN)archivedObjects[4];\n@@ -189,1 +190,1 @@\n-        return new ListN<>(tmp);\n+        return new ListN<>(tmp, false);\n@@ -207,1 +208,1 @@\n-        for (Object o : input) {\n+        for (Object o : input) { \/\/ implicit null check of 'input' array\n@@ -211,1 +212,1 @@\n-        switch (input.length) { \/\/ implicit null check of elements\n+        switch (input.length) {\n@@ -219,1 +220,1 @@\n-                return (List<E>) new ListN<>(input);\n+                return (List<E>) new ListN<>(input, false);\n@@ -240,1 +241,1 @@\n-            return (List<E>) EMPTY_LIST;\n+            return (List<E>) EMPTY_LIST_NULLS;\n@@ -242,1 +243,1 @@\n-            return new ListNNullsAllowed<>((E[])input);\n+            return new ListN<>((E[])input, true);\n@@ -614,1 +615,1 @@\n-    static class ListN<E> extends AbstractImmutableList<E>\n+    static final class ListN<E> extends AbstractImmutableList<E>\n@@ -620,2 +621,7 @@\n-        private ListN(E[] array) {\n-            elements = array;\n+        @Stable\n+        private final boolean allowNulls;\n+\n+        \/\/ caller must ensure that elements has no nulls if allowNulls is false\n+        private ListN(E[] elements, boolean allowNulls) {\n+            this.elements = elements;\n+            this.allowNulls = allowNulls;\n@@ -644,5 +650,0 @@\n-        @java.io.Serial\n-        private void readObjectNoData() throws ObjectStreamException {\n-            throw new InvalidObjectException(\"not serial proxy\");\n-        }\n-\n@@ -651,1 +652,1 @@\n-            return new CollSer(CollSer.IMM_LIST, elements);\n+            return new CollSer(allowNulls ? CollSer.IMM_LIST_NULLS : CollSer.IMM_LIST, elements);\n@@ -673,6 +674,0 @@\n-    }\n-\n-    static final class ListNNullsAllowed<E> extends ListN<E> {\n-        private ListNNullsAllowed(E[] array) {\n-            super(array);\n-        }\n@@ -682,12 +677,7 @@\n-            Object[] es = ((ListN)this).elements;\n-            if (o == null) {\n-                for (int i = 0; i < es.length; i++) {\n-                    if (es[i] == null) {\n-                        return i;\n-                    }\n-                }\n-            } else {\n-                for (int i = 0; i < es.length; i++) {\n-                    if (o.equals(es[i])) {\n-                        return i;\n-                    }\n+            if (!allowNulls && o == null) {\n+                throw new NullPointerException();\n+            }\n+            Object[] es = elements;\n+            for (int i = 0; i < es.length; i++) {\n+                if (Objects.equals(o, es[i])) {\n+                    return i;\n@@ -701,12 +691,7 @@\n-            Object[] es = ((ListN)this).elements;\n-            if (o == null) {\n-                for (int i = es.length - 1; i >= 0; i--) {\n-                    if (es[i] == null) {\n-                        return i;\n-                    }\n-                }\n-            } else {\n-                for (int i = es.length - 1; i >= 0; i--) {\n-                    if (o.equals(es[i])) {\n-                        return i;\n-                    }\n+            if (!allowNulls && o == null) {\n+                throw new NullPointerException();\n+            }\n+            Object[] es = elements;\n+            for (int i = es.length - 1; i >= 0; i--) {\n+                if (Objects.equals(o, es[i])) {\n+                    return i;\n@@ -717,10 +702,0 @@\n-\n-        @java.io.Serial\n-        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-            throw new InvalidObjectException(\"not serial proxy\");\n-        }\n-\n-        @java.io.Serial\n-        private Object writeReplace() {\n-            return new CollSer(CollSer.IMM_LIST_NULLS, ((ListN) this).elements);\n-        }\n@@ -1468,1 +1443,1 @@\n-   @java.io.Serial\n+    @java.io.Serial\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":38,"deletions":63,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1167,3 +1167,4 @@\n-     * the list will be in this stream's encounter order, if one exists. There are no\n-     * guarantees on the implementation type, mutability, serializability, or\n-     * thread-safety of the returned List.\n+     * the list will be in this stream's encounter order, if one exists. The returned List\n+     * is unmodifiable; calls to any mutator method will always cause\n+     * {@code UnsupportedOperationException} to be thrown. There are no\n+     * guarantees on the implementation type or serializability of the returned List.\n@@ -1178,1 +1179,4 @@\n-     * @implSpec The default implementation returns a List produced as if by the following:\n+     * @apiNote If more control over the returned object is required, use\n+     * {@link Collectors#toCollection(Supplier)}.\n+     *\n+     * @implSpec The implementation in this interface returns a List produced as if by the following:\n@@ -1183,2 +1187,2 @@\n-     * @apiNote If more control over the returned object is required, use\n-     * {@link Collectors#toCollection(Supplier)}.\n+     * @implNote Most instances of Stream will override this method and provide an implementation\n+     * that is highly optimized compared to the implementation in this interface.\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Stream.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.function.Function;\n@@ -31,1 +30,0 @@\n-import static java.util.Comparator.*;\n@@ -34,0 +32,2 @@\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n@@ -61,1 +61,1 @@\n-    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n@@ -65,0 +65,1 @@\n+        assertFalse(objects.contains(null));\n@@ -68,2 +69,2 @@\n-    public void testDefaultOps(String name, TestData.OfRef<Integer> data) {\n-        List<Integer> objects = exerciseTerminalOps(data, s -> DefaultMethodStreams.delegateTo(s).toList());\n+    public void testOpsWithNull(String name, TestData.OfRef<Integer> data) {\n+        List<Integer> objects = exerciseTerminalOps(data, s -> s.toList());\n@@ -71,0 +72,1 @@\n+        assertTrue(objects.contains(null));\n@@ -73,45 +75,0 @@\n-    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n-    public void testOpsWithMap(String name, TestData.OfRef<Integer> data) {\n-        \/\/ Retain the size of the source\n-        \/\/ This should kick in the parallel evaluation optimization for tasks stuffing elements into a shared array\n-\n-        List<Integer> objects = exerciseTerminalOps(data, s -> s.map(i -> i == null ? 0 : (Integer) (i + i)), s -> s.toList());\n-        assertTrue(objects.size() == data.size());\n-    }\n-\n-    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n-    public void testOpsWithSorted(String name, TestData.OfRef<Integer> data) {\n-        \/\/ Retain the size of the source\n-        \/\/ This should kick in the parallel evaluation optimization for tasks stuffing elements into a shared array\n-\n-        List<Integer> objects = exerciseTerminalOps(data, s -> s.sorted(nullsLast(naturalOrder())), s -> s.toList());\n-        assertTrue(objects.size() == data.size());\n-    }\n-\n-    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n-    public void testOpsWithFlatMap(String name, TestData.OfRef<Integer> data) {\n-        \/\/ Double the size of the source\n-        \/\/ Fixed size optimizations will not be used\n-\n-        List<Object> objects = exerciseTerminalOps(data,\n-                                                   s -> s.flatMap(e -> Arrays.stream(new Object[] { e, e })),\n-                                                   s -> s.toList());\n-        assertTrue(objects.size() == data.size() * 2);\n-    }\n-\n-    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n-    public void testOpsWithFilter(String name, TestData.OfRef<Integer> data) {\n-        \/\/ Reduce the size of the source\n-        \/\/ Fixed size optimizations will not be used\n-\n-        exerciseTerminalOps(data, s -> s.filter(i -> i == null ? false : LambdaTestHelpers.pEven.test(i)), s -> s.toList());\n-    }\n-\n-    private List<Function<Stream<Integer>, Stream<Integer>>> uniqueAndSortedPermutations =\n-            LambdaTestHelpers.permuteStreamFunctions(Arrays.asList(\n-                    s -> s.distinct(),\n-                    s -> s.distinct(),\n-                    s -> s.sorted(),\n-                    s -> s.sorted()\n-            ));\n-\n@@ -119,38 +76,4 @@\n-    public void testDistinctAndSortedPermutations(String name, TestData.OfRef<Integer> data) {\n-        for (Function<Stream<Integer>, Stream<Integer>> f : uniqueAndSortedPermutations) {\n-            exerciseTerminalOps(data, f, s -> s.toList());\n-        }\n-    }\n-\n-    private List<Function<Stream<Integer>, Stream<Integer>>> statefulOpPermutations =\n-            LambdaTestHelpers.permuteStreamFunctions(Arrays.asList(\n-                    s -> s.limit(10),\n-                    s -> s.distinct(),\n-                    s -> s.sorted()\n-            ));\n-\n-    private <T extends Object> ResultAsserter<List<T>> statefulOpResultAsserter(TestData.OfRef<Integer> data) {\n-        return (act, exp, ord, par) -> {\n-            if (par) {\n-                if (!data.isOrdered()) {\n-                    \/\/ Relax the checking if the data source is unordered\n-                    \/\/ It is not exactly possible to determine if the limit\n-                    \/\/ operation is present and if it is before or after\n-                    \/\/ the sorted operation\n-                    \/\/ If the limit operation is present and before the sorted\n-                    \/\/ operation then the sub-set output after limit is a\n-                    \/\/ non-deterministic sub-set of the source\n-                    List<Integer> expected = new ArrayList<>();\n-                    data.forEach(expected::add);\n-\n-                    assertEquals(act.size(), exp.size());\n-                    assertTrue(expected.containsAll(act));\n-                    return;\n-                }\n-                else if (!ord) {\n-                    LambdaTestHelpers.assertContentsUnordered(act, exp);\n-                    return;\n-                }\n-            }\n-            assertEquals(act, exp);\n-        };\n+    public void testDefaultOps(String name, TestData.OfRef<Integer> data) {\n+        List<Integer> objects = exerciseTerminalOps(data, s -> DefaultMethodStreams.delegateTo(s).toList());\n+        checkUnmodifiable(objects);\n+        assertFalse(objects.contains(null));\n@@ -159,8 +82,5 @@\n-    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class,\n-          groups = { \"serialization-hostile\" })\n-    public void testStatefulOpPermutations(String name, TestData.OfRef<Integer> data) {\n-        for (Function<Stream<Integer>, Stream<Integer>> f : statefulOpPermutations) {\n-            withData(data).terminal(f, s -> s.toList())\n-                    .resultAsserter(statefulOpResultAsserter(data))\n-                    .exercise();\n-        }\n+    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testDefaultOpsWithNull(String name, TestData.OfRef<Integer> data) {\n+        List<Integer> objects = exerciseTerminalOps(data, s -> DefaultMethodStreams.delegateTo(s).toList());\n+        checkUnmodifiable(objects);\n+        assertTrue(objects.contains(null));\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ToListOpTest.java","additions":16,"deletions":96,"binary":false,"changes":112,"status":"modified"}]}