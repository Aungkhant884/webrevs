{"files":[{"patch":"@@ -96,1 +96,0 @@\n-\n@@ -98,1 +97,1 @@\n-\n+    static final ListN<?> EMPTY_LIST_NULLS;\n@@ -100,1 +99,0 @@\n-\n@@ -107,1 +105,2 @@\n-            EMPTY_LIST = new ListN<>(new Object[0]);\n+            EMPTY_LIST = new ListN<>(new Object[0], false);\n+            EMPTY_LIST_NULLS = new ListN<>(new Object[0], true);\n@@ -110,1 +109,2 @@\n-            archivedObjects = new Object[] { EMPTY, EMPTY_LIST, EMPTY_SET, EMPTY_MAP };\n+            archivedObjects =\n+                new Object[] { EMPTY, EMPTY_LIST, EMPTY_LIST_NULLS, EMPTY_SET, EMPTY_MAP };\n@@ -114,2 +114,3 @@\n-            EMPTY_SET = (SetN)archivedObjects[2];\n-            EMPTY_MAP = (MapN)archivedObjects[3];\n+            EMPTY_LIST_NULLS = (ListN)archivedObjects[2];\n+            EMPTY_SET = (SetN)archivedObjects[3];\n+            EMPTY_MAP = (MapN)archivedObjects[4];\n@@ -123,1 +124,4 @@\n-                    return ImmutableCollections.ListN.fromTrustedArray(array);\n+                    return ImmutableCollections.listFromTrustedArray(array);\n+                }\n+                public <E> List<E> listFromTrustedArrayNullsAllowed(Object[] array) {\n+                    return ImmutableCollections.listFromTrustedArrayNullsAllowed(array);\n@@ -151,1 +155,1 @@\n-    \/\/ ---------- List Implementations ----------\n+    \/\/ ---------- List Static Factory Methods ----------\n@@ -153,1 +157,8 @@\n-    \/\/ make a copy, short-circuiting based on implementation class\n+    \/**\n+     * Copies a collection into a new List, unless the arg is already a safe,\n+     * unmodifiable list, in which case the arg itself is returned.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n@@ -163,0 +174,75 @@\n+    \/**\n+     * Creates a new List from an untrusted array, creating a new array for internal\n+     * storage, and checking for and rejecting null elements.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n+    @SafeVarargs\n+    static <E> List<E> listFromArray(E... input) {\n+        \/\/ copy and check manually to avoid TOCTOU\n+        @SuppressWarnings(\"unchecked\")\n+        E[] tmp = (E[])new Object[input.length]; \/\/ implicit nullcheck of input\n+        for (int i = 0; i < input.length; i++) {\n+            tmp[i] = Objects.requireNonNull(input[i]);\n+        }\n+        return new ListN<>(tmp, false);\n+    }\n+\n+    \/**\n+     * Creates a new List from a trusted array, checking for and rejecting null\n+     * elements.\n+     *\n+     * <p>A trusted array has no references retained by the caller. It can therefore be\n+     * safely reused as the List's internal storage, avoiding a defensive copy. Declared\n+     * with Object... instead of E... as the parameter type so that varargs calls don't\n+     * accidentally create an array of type other than Object[].\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <E> List<E> listFromTrustedArray(Object... input) {\n+        for (Object o : input) { \/\/ implicit null check of 'input' array\n+            Objects.requireNonNull(o);\n+        }\n+\n+        switch (input.length) {\n+            case 0:\n+                return (List<E>) ImmutableCollections.EMPTY_LIST;\n+            case 1:\n+                return (List<E>) new List12<>(input[0]);\n+            case 2:\n+                return (List<E>) new List12<>(input[0], input[1]);\n+            default:\n+                return (List<E>) new ListN<>(input, false);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new List from a trusted array, allowing null elements.\n+     *\n+     * <p>A trusted array has no references retained by the caller. It can therefore be\n+     * safely reused as the List's internal storage, avoiding a defensive copy. Declared\n+     * with Object... instead of E... as the parameter type so that varargs calls don't\n+     * accidentally create an array of type other than Object[].\n+     *\n+     * <p>Avoids creating a List12 instance, as it cannot accommodate null elements.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <E> List<E> listFromTrustedArrayNullsAllowed(Object... input) {\n+        if (input.length == 0) {\n+            return (List<E>) EMPTY_LIST_NULLS;\n+        } else {\n+            return new ListN<>((E[])input, true);\n+        }\n+    }\n+\n+    \/\/ ---------- List Implementations ----------\n+\n@@ -459,1 +545,1 @@\n-            \/\/ enable constant folding optimizations over single-element lists\n+            \/\/ enables constant folding optimizations over single-element lists\n@@ -535,15 +621,2 @@\n-        private ListN(E[] array) {\n-            elements = array;\n-        }\n-\n-        \/\/ creates a new internal array, and checks and rejects null elements\n-        @SafeVarargs\n-        static <E> List<E> fromArray(E... input) {\n-            \/\/ copy and check manually to avoid TOCTOU\n-            @SuppressWarnings(\"unchecked\")\n-            E[] tmp = (E[])new Object[input.length]; \/\/ implicit nullcheck of input\n-            for (int i = 0; i < input.length; i++) {\n-                tmp[i] = Objects.requireNonNull(input[i]);\n-            }\n-            return new ListN<>(tmp);\n-        }\n+        @Stable\n+        private final boolean allowNulls;\n@@ -551,9 +624,4 @@\n-        \/\/ Avoids creating a new array, but checks and rejects null elements.\n-        \/\/ Declared with Object... arg so that varargs calls don't accidentally\n-        \/\/ create an array of a subtype.\n-        @SuppressWarnings(\"unchecked\")\n-        static <E> List<E> fromTrustedArray(Object... input) {\n-            for (Object o : input) {\n-                Objects.requireNonNull(o);\n-            }\n-            return new ListN<>((E[])input);\n+        \/\/ caller must ensure that elements has no nulls if allowNulls is false\n+        private ListN(E[] elements, boolean allowNulls) {\n+            this.elements = elements;\n+            this.allowNulls = allowNulls;\n@@ -584,1 +652,1 @@\n-            return new CollSer(CollSer.IMM_LIST, elements);\n+            return new CollSer(allowNulls ? CollSer.IMM_LIST_NULLS : CollSer.IMM_LIST, elements);\n@@ -606,0 +674,28 @@\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            if (!allowNulls && o == null) {\n+                throw new NullPointerException();\n+            }\n+            Object[] es = elements;\n+            for (int i = 0; i < es.length; i++) {\n+                if (Objects.equals(o, es[i])) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            if (!allowNulls && o == null) {\n+                throw new NullPointerException();\n+            }\n+            Object[] es = elements;\n+            for (int i = es.length - 1; i >= 0; i--) {\n+                if (Objects.equals(o, es[i])) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n@@ -1228,3 +1324,4 @@\n-    static final int IMM_LIST = 1;\n-    static final int IMM_SET = 2;\n-    static final int IMM_MAP = 3;\n+    static final int IMM_LIST       = 1;\n+    static final int IMM_SET        = 2;\n+    static final int IMM_MAP        = 3;\n+    static final int IMM_LIST_NULLS = 4;\n@@ -1235,2 +1332,5 @@\n-     * {@code List}, 2 for an immutable {@code Set}, and 3 for\n-     * an immutable {@code Map}. Any other value causes an\n+     * {@code List}, 2 for an immutable {@code Set}, 3 for\n+     * an immutable {@code Map}, and 4 for an immutable\n+     * {@code List} that allows null elements.\n+     *\n+     * Any other value causes an\n@@ -1343,1 +1443,1 @@\n-   @java.io.Serial\n+    @java.io.Serial\n@@ -1355,0 +1455,3 @@\n+                case IMM_LIST_NULLS:\n+                    return ImmutableCollections.listFromTrustedArrayNullsAllowed(\n+                            Arrays.copyOf(array, array.length, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":145,"deletions":42,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -845,1 +845,1 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3);\n@@ -864,1 +864,1 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4);\n@@ -884,1 +884,1 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5);\n@@ -905,2 +905,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6);\n@@ -928,2 +928,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7);\n@@ -952,2 +952,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7, e8);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7, e8);\n@@ -977,2 +977,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7, e8, e9);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7, e8, e9);\n@@ -1003,2 +1003,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7, e8, e9, e10);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7, e8, e9, e10);\n@@ -1045,1 +1045,1 @@\n-                return ImmutableCollections.ListN.fromArray(elements);\n+                return ImmutableCollections.listFromArray(elements);\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -47,0 +48,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -623,0 +625,5 @@\n+    @Override\n+    public List<P_OUT> toList() {\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(this.toArray());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ReferencePipeline.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1165,0 +1165,34 @@\n+    \/**\n+     * Accumulates the elements of this stream into a {@code List}. The elements in\n+     * the list will be in this stream's encounter order, if one exists. The returned List\n+     * is unmodifiable; calls to any mutator method will always cause\n+     * {@code UnsupportedOperationException} to be thrown. There are no\n+     * guarantees on the implementation type or serializability of the returned List.\n+     *\n+     * <p>The returned instance may be <a href=\"..\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+     * Callers should make no assumptions about the identity of the returned instances.\n+     * Identity-sensitive operations on these instances (reference equality ({@code ==}),\n+     * identity hash code, and synchronization) are unreliable and should be avoided.\n+     *\n+     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal operation<\/a>.\n+     *\n+     * @apiNote If more control over the returned object is required, use\n+     * {@link Collectors#toCollection(Supplier)}.\n+     *\n+     * @implSpec The implementation in this interface returns a List produced as if by the following:\n+     * <pre>{@code\n+     * Collections.unmodifiableList(new ArrayList<>(Arrays.asList(this.toArray())))\n+     * }<\/pre>\n+     *\n+     * @implNote Most instances of Stream will override this method and provide an implementation\n+     * that is highly optimized compared to the implementation in this interface.\n+     *\n+     * @return a List containing the stream elements\n+     *\n+     * @since 16\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    default List<T> toList() {\n+        return (List<T>) Collections.unmodifiableList(new ArrayList<>(Arrays.asList(this.toArray())));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Stream.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+    <E> List<E> listFromTrustedArrayNullsAllowed(Object[] array);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilCollectionAccess.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.tests.java.util.stream;\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.*;\n+import java.util.stream.*;\n+\n+import static java.util.stream.LambdaTestHelpers.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+\/**\n+ * ToListOpTest\n+ *\/\n+@Test\n+public class ToListOpTest extends OpTestCase {\n+\n+    public void testToList() {\n+        assertCountSum(countTo(0).stream().toList(), 0, 0);\n+        assertCountSum(countTo(10).stream().toList(), 10, 55);\n+    }\n+\n+    private void checkUnmodifiable(List<Integer> list) {\n+        try {\n+            list.add(Integer.MIN_VALUE);\n+            fail(\"List.add did not throw UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException ignore) { }\n+\n+        if (list.size() > 0) {\n+            try {\n+                list.set(0, Integer.MAX_VALUE);\n+                fail(\"List.set did not throw UnsupportedOperationException\");\n+            } catch (UnsupportedOperationException ignore) { }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testOps(String name, TestData.OfRef<Integer> data) {\n+        List<Integer> objects = exerciseTerminalOps(data, s -> s.toList());\n+        checkUnmodifiable(objects);\n+        assertFalse(objects.contains(null));\n+    }\n+\n+    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testOpsWithNull(String name, TestData.OfRef<Integer> data) {\n+        List<Integer> objects = exerciseTerminalOps(data, s -> s.toList());\n+        checkUnmodifiable(objects);\n+        assertTrue(objects.contains(null));\n+    }\n+\n+    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testDefaultOps(String name, TestData.OfRef<Integer> data) {\n+        List<Integer> objects = exerciseTerminalOps(data, s -> DefaultMethodStreams.delegateTo(s).toList());\n+        checkUnmodifiable(objects);\n+        assertFalse(objects.contains(null));\n+    }\n+\n+    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testDefaultOpsWithNull(String name, TestData.OfRef<Integer> data) {\n+        List<Integer> objects = exerciseTerminalOps(data, s -> DefaultMethodStreams.delegateTo(s).toList());\n+        checkUnmodifiable(objects);\n+        assertTrue(objects.contains(null));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ToListOpTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}