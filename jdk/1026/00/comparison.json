{"files":[{"patch":"@@ -123,1 +123,4 @@\n-                    return ImmutableCollections.ListN.fromTrustedArray(array);\n+                    return ImmutableCollections.listFromTrustedArray(array);\n+                }\n+                public <E> List<E> listFromTrustedArrayNullsAllowed(Object[] array) {\n+                    return ImmutableCollections.listFromTrustedArrayNullsAllowed(array);\n@@ -151,1 +154,1 @@\n-    \/\/ ---------- List Implementations ----------\n+    \/\/ ---------- List Static Factory Methods ----------\n@@ -153,1 +156,8 @@\n-    \/\/ make a copy, short-circuiting based on implementation class\n+    \/**\n+     * Copies a collection into a new List, unless the arg is already a safe,\n+     * unmodifiable list, in which case the arg itself is returned.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n@@ -163,0 +173,75 @@\n+    \/**\n+     * Creates a new List from an untrusted array, creating a new array for internal\n+     * storage, and checking for and rejecting null elements.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n+    @SafeVarargs\n+    static <E> List<E> listFromArray(E... input) {\n+        \/\/ copy and check manually to avoid TOCTOU\n+        @SuppressWarnings(\"unchecked\")\n+        E[] tmp = (E[])new Object[input.length]; \/\/ implicit nullcheck of input\n+        for (int i = 0; i < input.length; i++) {\n+            tmp[i] = Objects.requireNonNull(input[i]);\n+        }\n+        return new ListN<>(tmp);\n+    }\n+\n+    \/**\n+     * Creates a new List from a trusted array, checking for and rejecting null\n+     * elements.\n+     *\n+     * <p>A trusted array has no references retained by the caller. It can therefore be\n+     * safely reused as the List's internal storage, avoiding a defensive copy. Declared\n+     * with Object... instead of E... as the parameter type so that varargs calls don't\n+     * accidentally create an array of type other than Object[].\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <E> List<E> listFromTrustedArray(Object... input) {\n+        for (Object o : input) {\n+            Objects.requireNonNull(o);\n+        }\n+\n+        switch (input.length) { \/\/ implicit null check of elements\n+            case 0:\n+                return (List<E>) ImmutableCollections.EMPTY_LIST;\n+            case 1:\n+                return (List<E>) new List12<>(input[0]);\n+            case 2:\n+                return (List<E>) new List12<>(input[0], input[1]);\n+            default:\n+                return (List<E>) new ListN<>(input);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new List from a trusted array, allowing null elements.\n+     *\n+     * <p>A trusted array has no references retained by the caller. It can therefore be\n+     * safely reused as the List's internal storage, avoiding a defensive copy. Declared\n+     * with Object... instead of E... as the parameter type so that varargs calls don't\n+     * accidentally create an array of type other than Object[].\n+     *\n+     * <p>Avoids creating a List12 instance, as it cannot accommodate null elements.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <E> List<E> listFromTrustedArrayNullsAllowed(Object... input) {\n+        if (input.length == 0) {\n+            return (List<E>) EMPTY_LIST;\n+        } else {\n+            return new ListNNullsAllowed<>((E[])input);\n+        }\n+    }\n+\n+    \/\/ ---------- List Implementations ----------\n+\n@@ -459,1 +544,1 @@\n-            \/\/ enable constant folding optimizations over single-element lists\n+            \/\/ enables constant folding optimizations over single-element lists\n@@ -529,1 +614,1 @@\n-    static final class ListN<E> extends AbstractImmutableList<E>\n+    static class ListN<E> extends AbstractImmutableList<E>\n@@ -539,23 +624,0 @@\n-        \/\/ creates a new internal array, and checks and rejects null elements\n-        @SafeVarargs\n-        static <E> List<E> fromArray(E... input) {\n-            \/\/ copy and check manually to avoid TOCTOU\n-            @SuppressWarnings(\"unchecked\")\n-            E[] tmp = (E[])new Object[input.length]; \/\/ implicit nullcheck of input\n-            for (int i = 0; i < input.length; i++) {\n-                tmp[i] = Objects.requireNonNull(input[i]);\n-            }\n-            return new ListN<>(tmp);\n-        }\n-\n-        \/\/ Avoids creating a new array, but checks and rejects null elements.\n-        \/\/ Declared with Object... arg so that varargs calls don't accidentally\n-        \/\/ create an array of a subtype.\n-        @SuppressWarnings(\"unchecked\")\n-        static <E> List<E> fromTrustedArray(Object... input) {\n-            for (Object o : input) {\n-                Objects.requireNonNull(o);\n-            }\n-            return new ListN<>((E[])input);\n-        }\n-\n@@ -582,0 +644,5 @@\n+        @java.io.Serial\n+        private void readObjectNoData() throws ObjectStreamException {\n+            throw new InvalidObjectException(\"not serial proxy\");\n+        }\n+\n@@ -608,0 +675,54 @@\n+    static final class ListNNullsAllowed<E> extends ListN<E> {\n+        private ListNNullsAllowed(E[] array) {\n+            super(array);\n+        }\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            Object[] es = ((ListN)this).elements;\n+            if (o == null) {\n+                for (int i = 0; i < es.length; i++) {\n+                    if (es[i] == null) {\n+                        return i;\n+                    }\n+                }\n+            } else {\n+                for (int i = 0; i < es.length; i++) {\n+                    if (o.equals(es[i])) {\n+                        return i;\n+                    }\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            Object[] es = ((ListN)this).elements;\n+            if (o == null) {\n+                for (int i = es.length - 1; i >= 0; i--) {\n+                    if (es[i] == null) {\n+                        return i;\n+                    }\n+                }\n+            } else {\n+                for (int i = es.length - 1; i >= 0; i--) {\n+                    if (o.equals(es[i])) {\n+                        return i;\n+                    }\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+            throw new InvalidObjectException(\"not serial proxy\");\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() {\n+            return new CollSer(CollSer.IMM_LIST_NULLS, ((ListN) this).elements);\n+        }\n+    }\n+\n@@ -1228,3 +1349,4 @@\n-    static final int IMM_LIST = 1;\n-    static final int IMM_SET = 2;\n-    static final int IMM_MAP = 3;\n+    static final int IMM_LIST       = 1;\n+    static final int IMM_SET        = 2;\n+    static final int IMM_MAP        = 3;\n+    static final int IMM_LIST_NULLS = 4;\n@@ -1235,2 +1357,5 @@\n-     * {@code List}, 2 for an immutable {@code Set}, and 3 for\n-     * an immutable {@code Map}. Any other value causes an\n+     * {@code List}, 2 for an immutable {@code Set}, 3 for\n+     * an immutable {@code Map}, and 4 for an immutable\n+     * {@code List} that allows null elements.\n+     *\n+     * Any other value causes an\n@@ -1355,0 +1480,3 @@\n+                case IMM_LIST_NULLS:\n+                    return ImmutableCollections.listFromTrustedArrayNullsAllowed(\n+                            Arrays.copyOf(array, array.length, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":161,"deletions":33,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -845,1 +845,1 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3);\n@@ -864,1 +864,1 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4);\n@@ -884,1 +884,1 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5);\n@@ -905,2 +905,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6);\n@@ -928,2 +928,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7);\n@@ -952,2 +952,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7, e8);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7, e8);\n@@ -977,2 +977,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7, e8, e9);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7, e8, e9);\n@@ -1003,2 +1003,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7, e8, e9, e10);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7, e8, e9, e10);\n@@ -1045,1 +1045,1 @@\n-                return ImmutableCollections.ListN.fromArray(elements);\n+                return ImmutableCollections.listFromArray(elements);\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -47,0 +48,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -623,0 +625,5 @@\n+    @Override\n+    public List<P_OUT> toList() {\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(this.toArray());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ReferencePipeline.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1165,0 +1165,30 @@\n+    \/**\n+     * Accumulates the elements of this stream into a {@code List}. The elements in\n+     * the list will be in this stream's encounter order, if one exists. There are no\n+     * guarantees on the implementation type, mutability, serializability, or\n+     * thread-safety of the returned List.\n+     *\n+     * <p>The returned instance may be <a href=\"..\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+     * Callers should make no assumptions about the identity of the returned instances.\n+     * Identity-sensitive operations on these instances (reference equality ({@code ==}),\n+     * identity hash code, and synchronization) are unreliable and should be avoided.\n+     *\n+     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal operation<\/a>.\n+     *\n+     * @implSpec The default implementation returns a List produced as if by the following:\n+     * <pre>{@code\n+     * Collections.unmodifiableList(new ArrayList<>(Arrays.asList(this.toArray())))\n+     * }<\/pre>\n+     *\n+     * @apiNote If more control over the returned object is required, use\n+     * {@link Collectors#toCollection(Supplier)}.\n+     *\n+     * @return a List containing the stream elements\n+     *\n+     * @since 16\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    default List<T> toList() {\n+        return (List<T>) Collections.unmodifiableList(new ArrayList<>(Arrays.asList(this.toArray())));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Stream.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+    <E> List<E> listFromTrustedArrayNullsAllowed(Object[] array);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilCollectionAccess.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.tests.java.util.stream;\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.stream.*;\n+\n+import static java.util.Comparator.*;\n+import static java.util.stream.LambdaTestHelpers.*;\n+import static org.testng.Assert.assertEquals;\n+\n+\n+\/**\n+ * ToListOpTest\n+ *\/\n+@Test\n+public class ToListOpTest extends OpTestCase {\n+\n+    public void testToList() {\n+        assertCountSum(countTo(0).stream().toList(), 0, 0);\n+        assertCountSum(countTo(10).stream().toList(), 10, 55);\n+    }\n+\n+    private void checkUnmodifiable(List<Integer> list) {\n+        try {\n+            list.add(Integer.MIN_VALUE);\n+            fail(\"List.add did not throw UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException ignore) { }\n+\n+        if (list.size() > 0) {\n+            try {\n+                list.set(0, Integer.MAX_VALUE);\n+                fail(\"List.set did not throw UnsupportedOperationException\");\n+            } catch (UnsupportedOperationException ignore) { }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testOps(String name, TestData.OfRef<Integer> data) {\n+        List<Integer> objects = exerciseTerminalOps(data, s -> s.toList());\n+        checkUnmodifiable(objects);\n+    }\n+\n+    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testDefaultOps(String name, TestData.OfRef<Integer> data) {\n+        List<Integer> objects = exerciseTerminalOps(data, s -> DefaultMethodStreams.delegateTo(s).toList());\n+        checkUnmodifiable(objects);\n+    }\n+\n+    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testOpsWithMap(String name, TestData.OfRef<Integer> data) {\n+        \/\/ Retain the size of the source\n+        \/\/ This should kick in the parallel evaluation optimization for tasks stuffing elements into a shared array\n+\n+        List<Integer> objects = exerciseTerminalOps(data, s -> s.map(i -> i == null ? 0 : (Integer) (i + i)), s -> s.toList());\n+        assertTrue(objects.size() == data.size());\n+    }\n+\n+    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testOpsWithSorted(String name, TestData.OfRef<Integer> data) {\n+        \/\/ Retain the size of the source\n+        \/\/ This should kick in the parallel evaluation optimization for tasks stuffing elements into a shared array\n+\n+        List<Integer> objects = exerciseTerminalOps(data, s -> s.sorted(nullsLast(naturalOrder())), s -> s.toList());\n+        assertTrue(objects.size() == data.size());\n+    }\n+\n+    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testOpsWithFlatMap(String name, TestData.OfRef<Integer> data) {\n+        \/\/ Double the size of the source\n+        \/\/ Fixed size optimizations will not be used\n+\n+        List<Object> objects = exerciseTerminalOps(data,\n+                                                   s -> s.flatMap(e -> Arrays.stream(new Object[] { e, e })),\n+                                                   s -> s.toList());\n+        assertTrue(objects.size() == data.size() * 2);\n+    }\n+\n+    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testOpsWithFilter(String name, TestData.OfRef<Integer> data) {\n+        \/\/ Reduce the size of the source\n+        \/\/ Fixed size optimizations will not be used\n+\n+        exerciseTerminalOps(data, s -> s.filter(i -> i == null ? false : LambdaTestHelpers.pEven.test(i)), s -> s.toList());\n+    }\n+\n+    private List<Function<Stream<Integer>, Stream<Integer>>> uniqueAndSortedPermutations =\n+            LambdaTestHelpers.permuteStreamFunctions(Arrays.asList(\n+                    s -> s.distinct(),\n+                    s -> s.distinct(),\n+                    s -> s.sorted(),\n+                    s -> s.sorted()\n+            ));\n+\n+    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n+    public void testDistinctAndSortedPermutations(String name, TestData.OfRef<Integer> data) {\n+        for (Function<Stream<Integer>, Stream<Integer>> f : uniqueAndSortedPermutations) {\n+            exerciseTerminalOps(data, f, s -> s.toList());\n+        }\n+    }\n+\n+    private List<Function<Stream<Integer>, Stream<Integer>>> statefulOpPermutations =\n+            LambdaTestHelpers.permuteStreamFunctions(Arrays.asList(\n+                    s -> s.limit(10),\n+                    s -> s.distinct(),\n+                    s -> s.sorted()\n+            ));\n+\n+    private <T extends Object> ResultAsserter<List<T>> statefulOpResultAsserter(TestData.OfRef<Integer> data) {\n+        return (act, exp, ord, par) -> {\n+            if (par) {\n+                if (!data.isOrdered()) {\n+                    \/\/ Relax the checking if the data source is unordered\n+                    \/\/ It is not exactly possible to determine if the limit\n+                    \/\/ operation is present and if it is before or after\n+                    \/\/ the sorted operation\n+                    \/\/ If the limit operation is present and before the sorted\n+                    \/\/ operation then the sub-set output after limit is a\n+                    \/\/ non-deterministic sub-set of the source\n+                    List<Integer> expected = new ArrayList<>();\n+                    data.forEach(expected::add);\n+\n+                    assertEquals(act.size(), exp.size());\n+                    assertTrue(expected.containsAll(act));\n+                    return;\n+                }\n+                else if (!ord) {\n+                    LambdaTestHelpers.assertContentsUnordered(act, exp);\n+                    return;\n+                }\n+            }\n+            assertEquals(act, exp);\n+        };\n+    }\n+\n+    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class,\n+          groups = { \"serialization-hostile\" })\n+    public void testStatefulOpPermutations(String name, TestData.OfRef<Integer> data) {\n+        for (Function<Stream<Integer>, Stream<Integer>> f : statefulOpPermutations) {\n+            withData(data).terminal(f, s -> s.toList())\n+                    .resultAsserter(statefulOpResultAsserter(data))\n+                    .exercise();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ToListOpTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"}]}