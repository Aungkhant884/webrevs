{"files":[{"patch":"@@ -159,1 +159,2 @@\n-     * unmodifiable list, in which case the arg itself is returned.\n+     * null-prohibiting unmodifiable list, in which case the arg itself is returned.\n+     * Null argument or null elements in the argument will result in NPE.\n@@ -167,1 +168,1 @@\n-        if (coll instanceof AbstractImmutableList && coll.getClass() != SubList.class) {\n+        if (coll instanceof List12 || (coll instanceof ListN && ! ((ListN<?>)coll).allowNulls)) {\n@@ -170,1 +171,1 @@\n-            return (List<E>)List.of(coll.toArray());\n+            return (List<E>)List.of(coll.toArray()); \/\/ implicit nullcheck of coll\n@@ -308,1 +309,1 @@\n-                if (!oit.hasNext() || !get(i).equals(oit.next())) {\n+                if (!oit.hasNext() || !Objects.equals(get(i), oit.next())) {\n@@ -315,22 +316,0 @@\n-        @Override\n-        public int indexOf(Object o) {\n-            Objects.requireNonNull(o);\n-            for (int i = 0, s = size(); i < s; i++) {\n-                if (o.equals(get(i))) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public int lastIndexOf(Object o) {\n-            Objects.requireNonNull(o);\n-            for (int i = size() - 1; i >= 0; i--) {\n-                if (o.equals(get(i))) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-\n@@ -341,1 +320,1 @@\n-                hash = 31 * hash + get(i).hashCode();\n+                hash = 31 * hash + Objects.hashCode(get(i));\n@@ -450,1 +429,1 @@\n-        private final List<E> root;\n+        private final AbstractImmutableList<E> root;\n@@ -458,1 +437,2 @@\n-        private SubList(List<E> root, int offset, int size) {\n+        private SubList(AbstractImmutableList<E> root, int offset, int size) {\n+            assert root instanceof List12 || root instanceof ListN;\n@@ -475,1 +455,1 @@\n-        static <E> SubList<E> fromList(List<E> list, int fromIndex, int toIndex) {\n+        static <E> SubList<E> fromList(AbstractImmutableList<E> list, int fromIndex, int toIndex) {\n@@ -508,0 +488,30 @@\n+        private boolean allowNulls() {\n+            return root instanceof ListN && ((ListN<?>)root).allowNulls;\n+        }\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            if (!allowNulls() && o == null) {\n+                throw new NullPointerException();\n+            }\n+            for (int i = 0, s = size(); i < s; i++) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            if (!allowNulls() && o == null) {\n+                throw new NullPointerException();\n+            }\n+            for (int i = size() - 1; i >= 0; i--) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n@@ -575,0 +585,24 @@\n+        @Override\n+        public int indexOf(Object o) {\n+            Objects.requireNonNull(o);\n+            if (o.equals(e0)) {\n+                return 0;\n+            } else if (e1 != EMPTY && o.equals(e1)) {\n+                return 1;\n+            } else {\n+                return -1;\n+            }\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            Objects.requireNonNull(o);\n+            if (e1 != EMPTY && o.equals(e1)) {\n+                return 1;\n+            } else if (o.equals(e0)) {\n+                return 0;\n+            } else {\n+                return -1;\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":64,"deletions":30,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,1 +232,10 @@\n-                List.of(integerArray))) {\n+                List.of(integerArray),\n+                Stream.<Integer>empty().toList(),\n+                Stream.of(1).toList(),\n+                Stream.of(1, 2).toList(),\n+                Stream.of(1, 2, 3).toList(),\n+                Stream.of(1, 2, 3, 4).toList(),\n+                Stream.of((Integer)null).toList(),\n+                Stream.of(1, null).toList(),\n+                Stream.of(1, null, 3).toList(),\n+                Stream.of(1, null, 3, 4).toList())) {\n@@ -1099,0 +1108,9 @@\n+\n+        int hashCode = 1;\n+        for (Integer i : l)\n+            hashCode = 31 * hashCode + (i == null ? 0 : i.hashCode());\n+        check(l.hashCode() == hashCode);\n+\n+        var t = new ArrayList<>(l);\n+        check(t.equals(l));\n+        check(l.equals(t));\n@@ -1134,0 +1152,7 @@\n+        if (c instanceof Set) {\n+            int hashCode = 0;\n+            for (Integer i : c)\n+                hashCode = hashCode + (i == null ? 0 : i.hashCode());\n+            check(c.hashCode() == hashCode);\n+        }\n+\n@@ -1233,0 +1258,9 @@\n+        int hashCode = 0;\n+        for (var e : m.entrySet()) {\n+            int entryHash = (e.getKey() == null ? 0 : e.getKey().hashCode()) ^\n+                            (e.getValue() == null ? 0 : e.getValue().hashCode());\n+            check(e.hashCode() == entryHash);\n+            hashCode += entryHash;\n+        }\n+        check(m.hashCode() == hashCode);\n+\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -362,0 +363,13 @@\n+    @Test(expectedExceptions=NullPointerException.class)\n+    public void copyOfRejectsNullElements2() {\n+        List<String> list = List.copyOf(Stream.of(\"a\", null, \"c\").toList());\n+    }\n+\n+    @Test\n+    public void copyOfCopiesNullAllowingList() {\n+        List<String> orig = Stream.of(\"a\", \"b\", \"c\").toList();\n+        List<String> copy = List.copyOf(orig);\n+\n+        assertNotSame(orig, copy);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/List\/ListFactories.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}