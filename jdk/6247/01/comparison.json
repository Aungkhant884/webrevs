{"files":[{"patch":"@@ -509,2 +509,6 @@\n-  format %{ \"fcvtzs  $dst, T2D, $src\\n\\t\"\n-            \"xtn     $dst, T2S, $dst, T2D\\t# convert 2D to 2I vector\"\n+  effect(TEMP_DEF dst);\n+  format %{ \"ins      $dst, D, $src, 0, 1\\n\\t\"\n+            \"fcvtzdw  rscratch1, $src\\n\\t\"\n+            \"fcvtzdw  rscratch2, $dst\\n\\t\"\n+            \"fmovs    $dst, rscratch1\\n\\t\"\n+            \"mov      $dst, T2S, 1, rscratch2\\t#convert 2D to 2I vector\"\n@@ -513,2 +517,7 @@\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($dst$$reg), __ T2D);\n+    __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n+    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n+    \/\/ saturation arithmetic. See JDK-8276151.\n+    __ fcvtzdw(rscratch1, as_FloatRegister($src$$reg));\n+    __ fcvtzdw(rscratch2, as_FloatRegister($dst$$reg));\n+    __ fmovs(as_FloatRegister($dst$$reg), rscratch1);\n+    __ mov(as_FloatRegister($dst$$reg), __ T2S, 1, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -275,3 +275,2 @@\n-dnl\n-define(`VECTOR_CAST_F2I_L', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$5 src)\n+\n+instruct vcvt4Fto4S(vecD dst, vecX src)\n@@ -279,4 +278,4 @@\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"fcvtzs  $dst, T$6, $src\\n\\t\"\n-            \"xtn     $dst, T$7, $dst, T$6\\t# convert $1$2 to $1$3 vector\"\n+  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"fcvtzs  $dst, T4S, $src\\n\\t\"\n+            \"xtn     $dst, T4H, $dst, T4S\\t# convert 4F to 4S vector\"\n@@ -285,2 +284,2 @@\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T$6, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T$7, as_FloatRegister($dst$$reg), __ T$6);\n+    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n+    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n@@ -289,5 +288,24 @@\n-%}')dnl\n-dnl               $1 $2 $3 $4 $5 $6  $7\n-VECTOR_CAST_F2I_L(4, F, S, D, X, 4S, 4H)\n-VECTOR_CAST_F2I_L(2, D, I, D, X, 2D, 2S)\n-dnl\n+%}\n+\n+instruct vcvt2Dto2I(vecD dst, vecX src)\n+%{\n+  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"ins      $dst, D, $src, 0, 1\\n\\t\"\n+            \"fcvtzdw  rscratch1, $src\\n\\t\"\n+            \"fcvtzdw  rscratch2, $dst\\n\\t\"\n+            \"fmovs    $dst, rscratch1\\n\\t\"\n+            \"mov      $dst, T2S, 1, rscratch2\\t#convert 2D to 2I vector\"\n+  %}\n+  ins_encode %{\n+    __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n+    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n+    \/\/ saturation arithmetic. See JDK-8276151.\n+    __ fcvtzdw(rscratch1, as_FloatRegister($src$$reg));\n+    __ fcvtzdw(rscratch2, as_FloatRegister($dst$$reg));\n+    __ fmovs(as_FloatRegister($dst$$reg), rscratch1);\n+    __ mov(as_FloatRegister($dst$$reg), __ T2S, 1, rscratch2);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.test.lib.Utils;\n@@ -42,0 +43,1 @@\n+ * @key randomness\n@@ -43,0 +45,1 @@\n+ * @library \/test\/lib\n@@ -44,1 +47,1 @@\n- * @run testng\/othervm -XX:-TieredCompilation compiler.vectorapi.VectorCastShape128Test\n+ * @run testng\/othervm -XX:-TieredCompilation -XX:CompileThreshold=100 compiler.vectorapi.VectorCastShape128Test\n@@ -57,2 +60,2 @@\n-    private static final int NUM_ITER = 50000;\n-    private static final int LENGTH = 512;\n+    private static final int NUM_ITER = 10000;\n+    private static final int LENGTH = 1024;\n@@ -72,0 +75,45 @@\n+    public static float [] fspecial = {\n+        0.0f,\n+        -0.0f,\n+        Float.MAX_VALUE,\n+        Float.MIN_VALUE,\n+        -Float.MAX_VALUE,\n+        -Float.MIN_VALUE,\n+        Float.NaN,\n+        Float.POSITIVE_INFINITY,\n+        Float.NEGATIVE_INFINITY,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+        Long.MAX_VALUE,\n+        Long.MIN_VALUE,\n+    };\n+\n+    public static double [] dspecial = {\n+        0.0,\n+        -0.0,\n+        Double.MAX_VALUE,\n+        Double.MIN_VALUE,\n+        -Double.MAX_VALUE,\n+        -Double.MIN_VALUE,\n+        Double.NaN,\n+        Double.POSITIVE_INFINITY,\n+        Double.NEGATIVE_INFINITY,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+        Long.MIN_VALUE,\n+        Long.MAX_VALUE,\n+    };\n+\n+    public static int [] ispecial = {\n+        0,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+    };\n+\n+    public static long [] lspecial = {\n+        0,\n+        Long.MAX_VALUE,\n+        Long.MIN_VALUE,\n+    };\n+\n+\n@@ -85,1 +133,1 @@\n-        Random r = new Random();\n+        Random r = Utils.getRandomInstance();\n@@ -91,2 +139,11 @@\n-            fa[i] = r.nextFloat();\n-            da[i] = r.nextDouble();\n+            fa[i] = ia[i] + r.nextFloat();\n+            da[i] = la[i] + r.nextDouble();\n+        }\n+\n+        \/\/ Replicate to make sure the values get tested, as some elements may be\n+        \/\/ ignored for some vector conversions.\n+        for (int i = 0; i < 4; i++) {\n+            System.arraycopy(ispecial, 0, ia, ispecial.length * i, ispecial.length);\n+            System.arraycopy(lspecial, 0, la, lspecial.length * i, lspecial.length);\n+            System.arraycopy(fspecial, 0, fa, fspecial.length * i, fspecial.length);\n+            System.arraycopy(dspecial, 0, da, dspecial.length * i, dspecial.length);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCastShape128Test.java","additions":63,"deletions":6,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.test.lib.Utils;\n@@ -42,0 +43,1 @@\n+ * @key randomness\n@@ -43,0 +45,1 @@\n+ * @library \/test\/lib\n@@ -44,1 +47,1 @@\n- * @run testng\/othervm -XX:-TieredCompilation compiler.vectorapi.VectorCastShape64Test\n+ * @run testng\/othervm -XX:-TieredCompilation -XX:CompileThreshold=100 compiler.vectorapi.VectorCastShape64Test\n@@ -57,2 +60,2 @@\n-    private static final int NUM_ITER = 50000;\n-    private static final int LENGTH = 512;\n+    private static final int NUM_ITER = 10000;\n+    private static final int LENGTH = 1024;\n@@ -72,0 +75,44 @@\n+    public static float [] fspecial = {\n+        0.0f,\n+        -0.0f,\n+        Float.MAX_VALUE,\n+        Float.MIN_VALUE,\n+        -Float.MAX_VALUE,\n+        -Float.MIN_VALUE,\n+        Float.NaN,\n+        Float.POSITIVE_INFINITY,\n+        Float.NEGATIVE_INFINITY,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+        Long.MAX_VALUE,\n+        Long.MIN_VALUE,\n+    };\n+\n+    public static double [] dspecial = {\n+        0.0,\n+        -0.0,\n+        Double.MAX_VALUE,\n+        Double.MIN_VALUE,\n+        -Double.MAX_VALUE,\n+        -Double.MIN_VALUE,\n+        Double.NaN,\n+        Double.POSITIVE_INFINITY,\n+        Double.NEGATIVE_INFINITY,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+        Long.MIN_VALUE,\n+        Long.MAX_VALUE,\n+    };\n+\n+    public static int [] ispecial = {\n+        0,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+    };\n+\n+    public static long [] lspecial = {\n+        0,\n+        Long.MAX_VALUE,\n+        Long.MIN_VALUE,\n+    };\n+\n@@ -85,1 +132,1 @@\n-        Random r = new Random();\n+        Random r = Utils.getRandomInstance();\n@@ -91,2 +138,11 @@\n-            fa[i] = r.nextFloat();\n-            da[i] = r.nextDouble();\n+            fa[i] = ia[i] + r.nextFloat();\n+            da[i] = la[i] + r.nextDouble();\n+        }\n+\n+        \/\/ Replicate to make sure the values get tested, as some elements may be\n+        \/\/ ignored for some vector conversions.\n+        for (int i = 0; i < 4; i++) {\n+            System.arraycopy(ispecial, 0, ia, ispecial.length * i, ispecial.length);\n+            System.arraycopy(lspecial, 0, la, lspecial.length * i, lspecial.length);\n+            System.arraycopy(fspecial, 0, fa, fspecial.length * i, fspecial.length);\n+            System.arraycopy(dspecial, 0, da, dspecial.length * i, dspecial.length);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCastShape64Test.java","additions":62,"deletions":6,"binary":false,"changes":68,"status":"modified"}]}