{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1609,0 +1609,5 @@\n+     * <p>\n+     * In cases where {@code ClassLoader.registerAsParallelCapable} is called from a context where\n+     * there is no caller frame on the stack (e.g. when called directly\n+     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n+     * <\/p>\n@@ -1612,0 +1617,1 @@\n+     * @throws IllegalCallerException if there is no caller frame on the stack.\n@@ -1620,1 +1626,4 @@\n-        return (caller != null) ? registerAsParallelCapable(caller): false;\n+        if (caller == null) {\n+            throw new IllegalCallerException(\"no caller frame\");\n+        }\n+        return registerAsParallelCapable(caller);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        Path launcher = Paths.get(System.getProperty(\"test.nativepath\"), \"NullCallerClassLoaderTest\");\n+        Path launcher = Path.of(System.getProperty(\"test.nativepath\"), \"NullCallerClassLoaderTest\");\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/exeNullCallerClassLoaderTest\/NullCallerClassLoaderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,11 @@\n+static jclass class_IllegalCallerException;\n+\n+int checkAndClearIllegalCallerExceptionThrown(JNIEnv *env) {\n+    jthrowable t = (*env)->ExceptionOccurred(env);\n+    if ((*env)->IsInstanceOf(env, t, class_IllegalCallerException) == JNI_TRUE) {\n+        (*env)->ExceptionClear(env);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+\n@@ -46,0 +57,2 @@\n+    class_IllegalCallerException = (*env)->FindClass(env, \"java\/lang\/IllegalCallerException\");\n+    assert (class_IllegalCallerException != NULL);\n@@ -53,2 +66,2 @@\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        (*env)->ExceptionDescribe(env);\n+    if ((rc = checkAndClearIllegalCallerExceptionThrown(env)) != JNI_TRUE) {\n+        printf(\"ERROR: Didn't get the expected IllegalCallerException.\\n\");\n@@ -57,4 +70,2 @@\n-    if (b != JNI_FALSE) {\n-        printf(\"ERROR: Unexpected true return value.\\n\");\n-        exit(1);\n-    }\n+\n+    printf(\"Expected IllegalCallerException was thrown\\n\");\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/exeNullCallerClassLoaderTest\/exeNullCallerClassLoaderTest.c","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"}]}