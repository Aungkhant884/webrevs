{"files":[{"patch":"@@ -72,1 +72,0 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -214,3 +213,3 @@\n-#if INCLUDE_G1GC\n-      address start = (address)G1CollectedHeap::heap()->reserved().start();\n-      address end = (address)G1CollectedHeap::heap()->reserved().end();\n+      assert(UseG1GC, \"used by G1 only\");\n+      address start = (address)Universe::heap()->reserved().start();\n+      address end = (address)Universe::heap()->reserved().end();\n@@ -219,1 +218,0 @@\n-#endif\n@@ -1572,3 +1570,2 @@\n-#if INCLUDE_G1GC\n-      mapping_offset = requested_base - (char*)G1CollectedHeap::heap()->reserved().start();\n-#endif\n+      assert(UseG1GC, \"used by G1 only\");\n+      mapping_offset = requested_base - (char*)Universe::heap()->reserved().start();\n@@ -2028,2 +2025,4 @@\n-  log_info(cds)(\"The current max heap size = \" SIZE_FORMAT \"M, HeapRegion::GrainBytes = \" SIZE_FORMAT,\n-                MaxHeapSize\/M, HeapRegion::GrainBytes);\n+  log_info(cds)(\"The current max heap size = \" SIZE_FORMAT \"M\", MaxHeapSize\/M);\n+  if (UseG1GC) {\n+    log_info(cds)(\"HeapRegion::GrainBytes = \" SIZE_FORMAT, HeapRegion::GrainBytes);\n+  }\n@@ -2035,4 +2034,2 @@\n-                UseCompressedOops ? p2i(CompressedOops::begin()) :\n-                                    UseG1GC ? p2i((address)G1CollectedHeap::heap()->reserved().start()) : 0L,\n-                UseCompressedOops ? p2i(CompressedOops::end()) :\n-                                    UseG1GC ? p2i((address)G1CollectedHeap::heap()->reserved().end()) : 0L);\n+                UseCompressedOops ? p2i(CompressedOops::begin()) : p2i((address)Universe::heap()->reserved().start()),\n+                UseCompressedOops ? p2i(CompressedOops::end()) : p2i((address)Universe::heap()->reserved().end()));\n@@ -2097,1 +2094,1 @@\n-    MemRegion heap_range = G1CollectedHeap::heap()->reserved();\n+    MemRegion heap_range = Universe::heap()->reserved();\n@@ -2100,5 +2097,6 @@\n-    address heap_end = (address)heap_range.end();\n-    address mapped_heap_region_end = (address)_mapped_heap_memregion.end();\n-    assert(heap_end >= mapped_heap_region_end, \"must be\");\n-    assert(heap_end - mapped_heap_region_end < (intx)(HeapRegion::GrainBytes),\n-           \"must be at the top of the heap to avoid fragmentation\");\n+    if (UseG1GC) {\n+      address heap_end = (address)heap_range.end();\n+      address mapped_heap_region_end = (address)_mapped_heap_memregion.end();\n+      assert(heap_end - mapped_heap_region_end < (intx)(HeapRegion::GrainBytes),\n+             \"must be at the top of the heap to avoid fragmentation\");\n+    }\n@@ -2115,1 +2113,1 @@\n-  assert(UseG1GC, \"the following code assumes G1\");\n+  assert(UseG1GC, \"used by G1 only\");\n@@ -2129,1 +2127,1 @@\n-  HeapWord* start = G1CollectedHeap::heap()->alloc_archive_region(word_size, (HeapWord*)requested_start);\n+  HeapWord* start = Universe::heap()->alloc_archive_space(word_size, (HeapWord*)requested_start);\n@@ -2144,1 +2142,1 @@\n-    dealloc_heap_region();\n+    handle_failed_mapping();\n@@ -2153,1 +2151,1 @@\n-    dealloc_heap_region();\n+    handle_failed_mapping();\n@@ -2176,1 +2174,1 @@\n-      dealloc_heap_region();\n+      handle_failed_mapping();\n@@ -2213,6 +2211,1 @@\n-\n-    \/\/ Populate the archive regions' G1BlockOffsetTableParts. That ensures\n-    \/\/ fast G1BlockOffsetTablePart::block_start operations for any given address\n-    \/\/ within the archive regions when trying to find start of an object\n-    \/\/ (e.g. during card table scanning).\n-    G1CollectedHeap::heap()->populate_archive_regions_bot_part(_mapped_heap_memregion);\n+    Universe::heap()->fixup_archive_space(_mapped_heap_memregion);\n@@ -2223,2 +2216,2 @@\n-void FileMapInfo::dealloc_heap_region() {\n-  G1CollectedHeap::heap()->dealloc_archive_regions(_mapped_heap_memregion);\n+void FileMapInfo::handle_failed_mapping() {\n+  Universe::heap()->handle_archive_space_failure(_mapped_heap_memregion);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":26,"deletions":33,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -551,1 +551,1 @@\n-  void  dealloc_heap_region() NOT_CDS_JAVA_HEAP_RETURN;\n+  void  handle_failed_mapping() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -531,1 +531,1 @@\n-HeapWord* G1CollectedHeap::alloc_archive_region(size_t word_size, HeapWord* preferred_addr) {\n+HeapWord* G1CollectedHeap::alloc_archive_space(size_t word_size, HeapWord* preferred_addr) {\n@@ -578,1 +578,1 @@\n-void G1CollectedHeap::populate_archive_regions_bot_part(MemRegion range) {\n+void G1CollectedHeap::fixup_archive_space(MemRegion range) {\n@@ -587,1 +587,1 @@\n-void G1CollectedHeap::dealloc_archive_regions(MemRegion range) {\n+void G1CollectedHeap::handle_archive_space_failure(MemRegion range) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -714,1 +714,1 @@\n-  HeapWord* alloc_archive_region(size_t word_size, HeapWord* preferred_addr);\n+  HeapWord* alloc_archive_space(size_t word_size, HeapWord* preferred_addr) override;\n@@ -716,3 +716,5 @@\n-  \/\/ Populate the G1BlockOffsetTablePart for archived regions with the given\n-  \/\/ memory range.\n-  void populate_archive_regions_bot_part(MemRegion range);\n+  \/\/ Populate the G1BlockOffsetTableParts for the archived regions in the given range.\n+  \/\/ That ensures fast G1BlockOffsetTablePart::block_start operations for any given\n+  \/\/ address within the archive regions when trying to find start of an object\n+  \/\/ (e.g. during card table scanning).\n+  void fixup_archive_space(MemRegion range) override;\n@@ -721,1 +723,1 @@\n-  \/\/ which had been allocated by alloc_archive_regions. This should be called\n+  \/\/ which had been allocated by alloc_archive_space. This should be called\n@@ -724,1 +726,1 @@\n-  void dealloc_archive_regions(MemRegion range);\n+  void handle_archive_space_failure(MemRegion range) override;\n@@ -1048,4 +1050,0 @@\n-  MemRegion reserved() const {\n-    return _hrm.reserved();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -210,0 +210,3 @@\n+  MemRegion reserved() const {\n+    return _reserved;\n+  }\n@@ -521,0 +524,14 @@\n+  \/\/ Commit the heap memory for CDS heap archive area according to the requested size.\n+  \/\/ Preferred address is treated as a hint for the location of the archive area in the heap.\n+  \/\/ The returned memory range may or may start at the preferred address.\n+  \/\/ Return MemRegion corresponding to the commited heap memory.\n+  virtual HeapWord* alloc_archive_space(size_t word_size, HeapWord* preferred_addr) { return nullptr; }\n+\n+  \/\/ This must be called after alloc_archive_space, and after class loading has occurred.\n+  \/\/ GC policy can take necessary actions to make the archive space usable,\n+  \/\/ such as inserting filler objects to make it parseable, or updating block offset table.\n+  virtual void fixup_archive_space(MemRegion range) { return; }\n+\n+  \/\/ Handle any failure in loading the CDS archive area.\n+  virtual void handle_archive_space_failure(MemRegion range) { return; }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}