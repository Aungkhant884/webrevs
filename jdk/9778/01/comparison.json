{"files":[{"patch":"@@ -4407,0 +4407,82 @@\n+\n+bool Arguments::parse_malloc_limit_size(const char* s, size_t* out) {\n+  julong limit = 0;\n+  Arguments::ArgsRange range = parse_memory_size(s, &limit, 1, SIZE_MAX);\n+  switch (range) {\n+  case ArgsRange::arg_in_range: *out = (size_t)limit; return true;\n+  case ArgsRange::arg_too_big: \/\/ only possible on 32-bit\n+    vm_exit_during_initialization(\"MallocLimit: too large\", s);\n+    break;\n+  case ArgsRange::arg_too_small:\n+    vm_exit_during_initialization(\"MallocLimit: limit must be > 0\");\n+    break;\n+  default:\n+    \/\/ fall through\n+    break;\n+  }\n+  return false;\n+}\n+\n+\/\/ Helper for parse_malloc_limits\n+void Arguments::parse_single_category_limit(char* expression, size_t limits[mt_number_of_types]) {\n+  \/\/ <category>:<limit>\n+  char* colon = ::strchr(expression, ':');\n+  if (colon == nullptr) {\n+    vm_exit_during_initialization(\"MallocLimit: colon missing\", expression);\n+  }\n+  *colon = '\\0';\n+  MEMFLAGS f = NMTUtil::string_to_flag(expression);\n+  if (f == mtNone) {\n+    vm_exit_during_initialization(\"MallocLimit: invalid nmt category\", expression);\n+  }\n+  if (parse_malloc_limit_size(colon + 1, limits + (int)f) == false) {\n+    vm_exit_during_initialization(\"Invalid MallocLimit size\", colon + 1);\n+  }\n+}\n+\n+\/\/ Parse diagnostic NMT switch \"MallocLimit\" and return the found limits.\n+\/\/ 1) If option is not given, it will set all limits to 0 (aka \"no limit\").\n+\/\/ 2) If option is given in the global form (-XX:MallocLimit=<size>), it\n+\/\/    will return the size in *total_limit.\n+\/\/ 3) If option is given in its per-NMT-category form (-XX:MallocLimit=<category>:<size>[,<category>:<size>]),\n+\/\/    it will return all found limits in the limits array.\n+\/\/ 4) If option is malformed, it will exit the VM.\n+\/\/ For (2) and (3), limits not affected by the switch will be set to 0.\n+void Arguments::parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]) {\n+\n+  \/\/ Reset output to 0\n+  *total_limit = 0;\n+  for (int i = 0; i < mt_number_of_types; i ++) {\n+    limits[i] = 0;\n+  }\n+\n+  \/\/ We are done if the option is not given.\n+  if (MallocLimit == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ Global form?\n+  if (parse_malloc_limit_size(MallocLimit, total_limit)) {\n+    return;\n+  }\n+\n+  \/\/ No. So it must be in category-specific form: MallocLimit=<nmt category>:<size>[,<nmt category>:<size> ..]\n+  char* copy = os::strdup(MallocLimit);\n+  if (copy == nullptr) {\n+    vm_exit_out_of_memory(strlen(MallocLimit), OOM_MALLOC_ERROR, \"MallocLimit\");\n+  }\n+\n+  char* p = copy, *q;\n+  do {\n+    q = p;\n+    p = ::strchr(q, ',');\n+    if (p != nullptr) {\n+      *p = '\\0';\n+      p ++;\n+    }\n+    parse_single_category_limit(q, limits);\n+  } while (p != nullptr);\n+\n+  os::free(copy);\n+\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -482,0 +482,4 @@\n+  \/\/ Helpers for parse_malloc_limits\n+  static bool parse_malloc_limit_size(const char* s, size_t* out);\n+  static void parse_single_category_limit(char* expression, size_t limits[mt_number_of_types]);\n+\n@@ -656,0 +660,10 @@\n+  \/\/ Parse diagnostic NMT switch \"MallocLimit\" and return the found limits.\n+  \/\/ 1) If option is not given, it will set all limits to 0 (aka \"no limit\").\n+  \/\/ 2) If option is given in the global form (-XX:MallocLimit=<size>), it\n+  \/\/    will return the size in *total_limit.\n+  \/\/ 3) If option is given in its per-NMT-category form (-XX:MallocLimit=<category>:<size>[,<category>:<size>]),\n+  \/\/    it will return all found limits in the limits array.\n+  \/\/ 4) If option is malformed, it will exit the VM.\n+  \/\/ For (2) and (3), limits not affected by the switch will be set to 0.\n+  static void parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1368,0 +1368,9 @@\n+  product(ccstr, MallocLimit, nullptr, DIAGNOSTIC,                          \\\n+          \"Limit malloc allocation size from hotspot (requires NMT). \"      \\\n+          \"Reaching the limit will trigger a fatal error.\"                  \\\n+          \"Usage:\"                                                          \\\n+          \"- MallocLimit=<size> to set a total limit. \"                     \\\n+          \"- MallocLimit=<NMT category>:<size>[,<NMT category>:<size>..] \"  \\\n+          \"  to set one or more category-specific limits.\"                  \\\n+          \"Example: -XX:MallocLimit=compiler:500m\")                         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n@@ -26,0 +27,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/arguments.hpp\"\n@@ -33,0 +36,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -37,0 +41,2 @@\n+size_t MallocMemorySummary::_limits_per_category[mt_number_of_types] = { 0 };\n+size_t MallocMemorySummary::_total_limit = 0;\n@@ -109,0 +115,50 @@\n+  initialize_limit_handling();\n+}\n+\n+void MallocMemorySummary::initialize_limit_handling() {\n+  \/\/ Initialize limit handling.\n+  Arguments::parse_malloc_limits(&_total_limit, _limits_per_category);\n+\n+  if (_total_limit > 0) {\n+    log_info(nmt)(\"MallocLimit: total limit: \" SIZE_FORMAT, _total_limit);\n+  } else {\n+    for (int i = 0; i < mt_number_of_types; i ++) {\n+      if (_limits_per_category[i] > 0) {\n+        log_info(nmt)(\"MallocLimit: category \\\"%s\\\" limit: \" SIZE_FORMAT,\n+                      NMTUtil::flag_to_name((MEMFLAGS)i), _limits_per_category[i]);\n+      }\n+    }\n+  }\n+}\n+\n+void MallocMemorySummary::total_limit_reached(size_t size, size_t limit) {\n+  \/\/ Assert in both debug and release, but allow error reporting to malloc beyond limits.\n+  if (!VMError::is_error_reported()) {\n+    guarantee(false,\n+              \"MallocLimit: reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n+              size, limit);\n+  }\n+}\n+\n+void MallocMemorySummary::category_limit_reached(size_t size, size_t limit, MEMFLAGS flag) {\n+  \/\/ Assert in both debug and release, but allow error reporting to malloc beyond limits.\n+  if (!VMError::is_error_reported()) {\n+    guarantee(false,\n+              \"MallocLimit: category \\\"%s\\\" reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n+              NMTUtil::flag_to_name(flag), size, limit);\n+  }\n+}\n+\n+void MallocMemorySummary::print_limits(outputStream* st) {\n+  if (_total_limit != 0) {\n+    st->print(\"MallocLimit: \" SIZE_FORMAT, _total_limit);\n+  } else {\n+    bool first = true;\n+    for (int i = 0; i < mt_number_of_types; i ++) {\n+      if (_limits_per_category[i] > 0) {\n+        st->print(\"%s%s:\" SIZE_FORMAT, (first ? \"MallocLimit: \" : \", \"),\n+                  NMTUtil::flag_to_name((MEMFLAGS)i), _limits_per_category[i]);\n+        first = false;\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n@@ -192,0 +193,28 @@\n+  \/\/ Malloc Limit handling (-XX:MallocLimit)\n+  static size_t _limits_per_category[mt_number_of_types];\n+  static size_t _total_limit;\n+\n+  static void initialize_limit_handling();\n+  static void total_limit_reached(size_t size, size_t limit);\n+  static void category_limit_reached(size_t size, size_t limit, MEMFLAGS flag);\n+\n+  static void check_limits_after_allocation(MEMFLAGS flag) {\n+    \/\/ We can only either have a total limit or category specific limits,\n+    \/\/ not both.\n+    if (_total_limit != 0) {\n+      size_t s = as_snapshot()->total();\n+      if (s > _total_limit) {\n+        total_limit_reached(s, _total_limit);\n+      }\n+    } else {\n+      size_t per_cat_limit = _limits_per_category[(int)flag];\n+      if (per_cat_limit > 0) {\n+        const MallocMemory* mm = as_snapshot()->by_type(flag);\n+        size_t s = mm->malloc_size() + mm->arena_size();\n+        if (s > per_cat_limit) {\n+          category_limit_reached(s, per_cat_limit, flag);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -197,0 +226,1 @@\n+     check_limits_after_allocation(flag);\n@@ -213,0 +243,1 @@\n+     check_limits_after_allocation(flag);\n@@ -237,0 +268,2 @@\n+\n+  static void print_limits(outputStream* st);\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2028, 2022 SAP SE. All rights reserved.\n@@ -76,0 +77,4 @@\n+  } else {\n+    if (MallocLimit != nullptr) {\n+      warning(\"MallocLimit will be ignored since NMT is disabled.\");\n+    }\n@@ -113,0 +118,1 @@\n+    MallocMemorySummary::print_limits(output);\n@@ -157,0 +163,1 @@\n+  MallocMemorySummary::print_limits(out);\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#define MEMORY_TYPE_DECLARE_NAME(type, human_readable) \\\n-  human_readable,\n-\n@@ -35,1 +32,4 @@\n-const char* NMTUtil::_memory_type_names[] = {\n+#define MEMORY_TYPE_DECLARE_NAME(type, human_readable) \\\n+  { #type, human_readable },\n+\n+NMTUtil::S NMTUtil::_strings[] = {\n@@ -89,0 +89,16 @@\n+\n+\/\/ Given a string, return associated flag. mtNone if name is invalid.\n+\/\/ String can be either the human readable name or the\n+\/\/ stringified enum (with or without leading \"mt\"). In all cases, case is ignored.\n+MEMFLAGS NMTUtil::string_to_flag(const char* s) {\n+  for (int i = 0; i < mt_number_of_types; i ++) {\n+    assert(::strlen(_strings[i].enum_s) > 2, \"Sanity\"); \/\/ should always start with \"mt\"\n+    if (::strcasecmp(_strings[i].human_readable, s) == 0 ||\n+        ::strcasecmp(_strings[i].enum_s, s) == 0 ||\n+        ::strcasecmp(_strings[i].enum_s + 2, s) == 0) \/\/ \"mtXXX\" -> match also \"XXX\" or \"xxx\"\n+    {\n+      return (MEMFLAGS)i;\n+    }\n+  }\n+  return mtNone;\n+}\n","filename":"src\/hotspot\/share\/services\/nmtCommon.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    return _memory_type_names[flag_to_index(flag)];\n+    return _strings[flag_to_index(flag)].human_readable;\n@@ -118,0 +118,5 @@\n+  \/\/ Given a string, return associated flag. mtNone if name is invalid.\n+  \/\/ String can be either the human readable name or the\n+  \/\/ stringified enum (with or without leading \"mt\". In all cases, case is ignored.\n+  static MEMFLAGS string_to_flag(const char* name);\n+\n@@ -122,1 +127,5 @@\n-  static const char* _memory_type_names[mt_number_of_types];\n+  struct S {\n+    const char* enum_s; \/\/ e.g. \"mtNMT\"\n+    const char* human_readable; \/\/ e.g. \"Native Memory Tracking\"\n+  };\n+  static S _strings[mt_number_of_types];\n","filename":"src\/hotspot\/share\/services\/nmtCommon.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=global_limit\n+ * @summary Verify -XX:MallocLimit with a global limit\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest global_limit\n+ *\/\n+\n+\/*\n+ * @test id=compiler_limit\n+ * @summary Verify -XX:MallocLimit with a compiler-specific limit (for \"mtCompiler\" category)\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest compiler_limit\n+ *\/\n+\n+\/*\n+ * @test id=test_multi_limit\n+ * @summary Verify -XX:MallocLimit with multiple limits\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest multi_limit\n+ *\/\n+\n+\/*\n+ * @test id=test_valid_settings\n+ * @summary Verify -XX:MallocLimit rejects invalid settings\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest valid_settings\n+ *\/\n+\n+\/*\n+ * @test id=test_invalid_settings\n+ * @summary Verify -XX:MallocLimit rejects invalid settings\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest invalid_settings\n+ *\/\n+\n+\/*\n+ * @test id=test_limit_without_nmt\n+ * @summary Verify that the VM warns if -XX:MallocLimit is given but NMT is disabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest limit_without_nmt\n+ *\/\n+\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+public class MallocLimitTest {\n+\n+    private static ProcessBuilder processBuilderWithSetting(String... extra_settings) {\n+        String[] vmargs = new String[] {\n+            \"-XX:+UnlockDiagnosticVMOptions\", \/\/ MallocLimit is diagnostic\n+            \"-Xmx64m\", \"-XX:-CreateCoredumpOnCrash\", \"-Xlog:nmt\",\n+            \"-XX:NativeMemoryTracking=summary\"\n+        };\n+        String[] vmargs2 = new String[] { \"-version\" };\n+        String[] both = Stream.concat(Stream.concat(Arrays.stream(vmargs), Arrays.stream(extra_settings)), Arrays.stream(vmargs2))\n+                .toArray(String[]::new);\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(both);\n+        return pb;\n+    }\n+\n+    private static void test_global_limit() throws IOException {\n+        long small_memory_size = 1024*1024; \/\/ 1m\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + small_memory_size);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"[nmt] MallocLimit: total limit: \" + small_memory_size);\n+        String s = output.firstMatch(\".*MallocLimit: reached limit \\\\(size: (\\\\d+), limit: \" + small_memory_size + \"\\\\).*\", 1);\n+        Asserts.assertNotNull(s);\n+        long size = Long.parseLong(s);\n+        Asserts.assertGreaterThan(size, small_memory_size);\n+    }\n+\n+    private static void test_compiler_limit() throws IOException {\n+        \/\/ Here, we count on the VM, running with -Xcomp and with 1m of arena space allowed, will start a compilation\n+        \/\/ and then trip over the limit.\n+        \/\/ If limit is too small, Compiler stops too early and we won't get a Retry file (see below, we check that).\n+        \/\/ If limit is too large, we may not trigger it for java -version.\n+        \/\/ 1m seems to work out fine.\n+        long small_memory_size = 1024*1024; \/\/ 1m\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=compiler:\" + small_memory_size,\n+                \"-Xcomp\" \/\/ make sure we hit the compiler category limit\n+        );\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Compiler\\\" limit: \" + small_memory_size);\n+        String s = output.firstMatch(\".*MallocLimit: category \\\"Compiler\\\" reached limit \\\\(size: (\\\\d+), limit: \" + small_memory_size + \"\\\\).*\", 1);\n+        Asserts.assertNotNull(s);\n+        long size = Long.parseLong(s);\n+        output.shouldContain(\"Compiler replay data is saved as\");\n+        Asserts.assertGreaterThan(size, small_memory_size);\n+    }\n+\n+    private static void test_multi_limit() throws IOException {\n+        long small_memory_size = 1024; \/\/ 1k\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=mtOther:2g,compiler:1g,internal:\" + small_memory_size);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Compiler\\\" limit: 1073741824\");\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Internal\\\" limit: \" + small_memory_size);\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Other\\\" limit: 2147483648\");\n+        String s = output.firstMatch(\".*MallocLimit: category \\\"Internal\\\" reached limit \\\\(size: (\\\\d+), limit: \" + small_memory_size + \"\\\\).*\", 1);\n+        long size = Long.parseLong(s);\n+        Asserts.assertGreaterThan(size, small_memory_size);\n+    }\n+\n+    private static void test_valid_setting(String setting, String... expected_output) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + setting);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0);\n+        for (String expected : expected_output) {\n+            output.shouldContain(expected);\n+        }\n+    }\n+\n+    private static void test_valid_settings() throws IOException {\n+        \/\/ Test a number of valid settings.\n+        test_valid_setting(\n+                \"2097152k\",\n+                \"[nmt] MallocLimit: total limit: 2147483648\",\n+                \"[nmt] NMT initialized: summary\"\n+        );\n+        test_valid_setting(\n+                \"gc:1234567891,mtInternal:987654321,Object Monitors:1g\",\n+                \"[nmt] MallocLimit: category \\\"GC\\\" limit: 1234567891\",\n+                \"[nmt] MallocLimit: category \\\"Internal\\\" limit: 987654321\",\n+                \"[nmt] MallocLimit: category \\\"Object Monitors\\\" limit: 1073741824\",\n+                \"[nmt] NMT initialized: summary\"\n+        );\n+        \/\/ Set all categories individually:\n+        test_valid_setting(\n+                \"JavaHeap:1024m,Class:1025m,Thread:1026m,ThreadStack:1027m,Code:1028m,GC:1029m,GCCardSet:1030m,Compiler:1031m,JVMCI:1032m,\" +\n+                        \"Internal:1033m,Other:1034m,Symbol:1035m,NMT:1036m,ClassShared:1037m,Chunk:1038m,Test:1039m,Tracing:1040m,Logging:1041m,\" +\n+                        \"Statistics:1042m,Arguments:1043m,Module:1044m,Safepoint:1045m,Synchronizer:1046m,Serviceability:1047m,Metaspace:1048m,StringDedup:1049m,ObjectMonitor:1050m\",\n+                \"[nmt] MallocLimit: category \\\"Java Heap\\\" limit: 1073741824\",\n+                \"[nmt] MallocLimit: category \\\"Class\\\" limit: 1074790400\",\n+                \"[nmt] MallocLimit: category \\\"Thread\\\" limit: 1075838976\",\n+                \"[nmt] MallocLimit: category \\\"Thread Stack\\\" limit: 1076887552\",\n+                \"[nmt] MallocLimit: category \\\"Code\\\" limit: 1077936128\",\n+                \"[nmt] MallocLimit: category \\\"GC\\\" limit: 1078984704\",\n+                \"[nmt] MallocLimit: category \\\"GCCardSet\\\" limit: 1080033280\",\n+                \"[nmt] MallocLimit: category \\\"Compiler\\\" limit: 1081081856\",\n+                \"[nmt] MallocLimit: category \\\"JVMCI\\\" limit: 1082130432\",\n+                \"[nmt] MallocLimit: category \\\"Internal\\\" limit: 1083179008\",\n+                \"[nmt] MallocLimit: category \\\"Other\\\" limit: 1084227584\",\n+                \"[nmt] MallocLimit: category \\\"Symbol\\\" limit: 1085276160\",\n+                \"[nmt] MallocLimit: category \\\"Native Memory Tracking\\\" limit: 1086324736\",\n+                \"[nmt] MallocLimit: category \\\"Shared class space\\\" limit: 1087373312\",\n+                \"[nmt] MallocLimit: category \\\"Arena Chunk\\\" limit: 1088421888\",\n+                \"[nmt] MallocLimit: category \\\"Test\\\" limit: 1089470464\",\n+                \"[nmt] MallocLimit: category \\\"Tracing\\\" limit: 1090519040\",\n+                \"[nmt] MallocLimit: category \\\"Logging\\\" limit: 1091567616\",\n+                \"[nmt] MallocLimit: category \\\"Statistics\\\" limit: 1092616192\",\n+                \"[nmt] MallocLimit: category \\\"Arguments\\\" limit: 1093664768\",\n+                \"[nmt] MallocLimit: category \\\"Module\\\" limit: 1094713344\",\n+                \"[nmt] MallocLimit: category \\\"Safepoint\\\" limit: 1095761920\",\n+                \"[nmt] MallocLimit: category \\\"Synchronization\\\" limit: 1096810496\",\n+                \"[nmt] MallocLimit: category \\\"Serviceability\\\" limit: 1097859072\",\n+                \"[nmt] MallocLimit: category \\\"Metaspace\\\" limit: 1098907648\",\n+                \"[nmt] MallocLimit: category \\\"String Deduplication\\\" limit: 1099956224\",\n+                \"[nmt] MallocLimit: category \\\"Object Monitors\\\" limit: 1101004800\",\n+                \"[nmt] NMT initialized: summary\"\n+        );\n+    }\n+\n+    private static void test_invalid_setting(String setting, String expected_error) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + setting);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(expected_error);\n+    }\n+\n+    private static void test_invalid_settings() throws IOException {\n+        \/\/ Test a number of invalid settings the parser should catch. VM should abort in initialization.\n+        test_invalid_setting(\"gc\", \"MallocLimit: colon missing: gc\");\n+        test_invalid_setting(\"gc:abc\", \"Invalid MallocLimit size: abc\");\n+        test_invalid_setting(\"abcd:10m\", \"MallocLimit: invalid nmt category: abcd\");\n+        test_invalid_setting(\"nmt:100m,abcd:10m\", \"MallocLimit: invalid nmt category: abcd\");\n+        test_invalid_setting(\"0\", \"MallocLimit: limit must be > 0\");\n+        test_invalid_setting(\"GC:0\", \"MallocLimit: limit must be > 0\");\n+    }\n+\n+    private static void test_limit_without_nmt() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:NativeMemoryTracking=off\", \/\/ overrides \"summary\" from processBuilderWithSetting()\n+                \"-XX:MallocLimit=3g\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0); \/\/ Not a fatal error, just a warning\n+        output.shouldContain(\"MallocLimit will be ignored since NMT is disabled\");\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args[0].equals(\"global_limit\")) {\n+            test_global_limit();\n+        } else if (args[0].equals(\"compiler_limit\")) {\n+            test_compiler_limit();\n+        } else if (args[0].equals(\"multi_limit\")) {\n+            test_multi_limit();\n+        } else if (args[0].equals(\"valid_settings\")) {\n+            test_valid_settings();\n+        } else if (args[0].equals(\"invalid_settings\")) {\n+            test_invalid_settings();\n+        } else if (args[0].equals(\"limit_without_nmt\")) {\n+            test_limit_without_nmt();\n+        } else {\n+            throw new RuntimeException(\"invalid test: \" + args[0]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocLimitTest.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"}]}