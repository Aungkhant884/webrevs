{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -214,0 +230,1 @@\n+                if (!success) weakDelay(c);\n@@ -224,0 +241,1 @@\n+                if (!success) weakDelay(c);\n@@ -234,0 +252,1 @@\n+                if (!success) weakDelay(c);\n@@ -244,0 +263,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestBoolean.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -243,0 +259,1 @@\n+                if (!success) weakDelay(c);\n@@ -253,0 +270,1 @@\n+                if (!success) weakDelay(c);\n@@ -263,0 +281,1 @@\n+                if (!success) weakDelay(c);\n@@ -273,0 +292,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestByte.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -261,0 +277,1 @@\n+                if (!success) weakDelay(c);\n@@ -271,0 +288,1 @@\n+                if (!success) weakDelay(c);\n@@ -281,0 +299,1 @@\n+                if (!success) weakDelay(c);\n@@ -291,0 +310,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestChar.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -243,0 +259,1 @@\n+                if (!success) weakDelay(c);\n@@ -253,0 +270,1 @@\n+                if (!success) weakDelay(c);\n@@ -263,0 +281,1 @@\n+                if (!success) weakDelay(c);\n@@ -273,0 +292,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestDouble.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -243,0 +259,1 @@\n+                if (!success) weakDelay(c);\n@@ -253,0 +270,1 @@\n+                if (!success) weakDelay(c);\n@@ -263,0 +281,1 @@\n+                if (!success) weakDelay(c);\n@@ -273,0 +292,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestFloat.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -261,0 +277,1 @@\n+                if (!success) weakDelay(c);\n@@ -271,0 +288,1 @@\n+                if (!success) weakDelay(c);\n@@ -281,0 +299,1 @@\n+                if (!success) weakDelay(c);\n@@ -291,0 +310,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestInt.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -261,0 +277,1 @@\n+                if (!success) weakDelay(c);\n@@ -271,0 +288,1 @@\n+                if (!success) weakDelay(c);\n@@ -281,0 +299,1 @@\n+                if (!success) weakDelay(c);\n@@ -291,0 +310,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestLong.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -214,0 +230,1 @@\n+                if (!success) weakDelay(c);\n@@ -224,0 +241,1 @@\n+                if (!success) weakDelay(c);\n@@ -234,0 +252,1 @@\n+                if (!success) weakDelay(c);\n@@ -244,0 +263,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestObject.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -261,0 +277,1 @@\n+                if (!success) weakDelay(c);\n@@ -271,0 +288,1 @@\n+                if (!success) weakDelay(c);\n@@ -281,0 +299,1 @@\n+                if (!success) weakDelay(c);\n@@ -291,0 +310,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestShort.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestBoolean.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestByte.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestChar.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestDouble.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestFloat.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestInt.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestLong.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestObject.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -89,0 +97,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestShort.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,9 @@\n-    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 10);\n+\n+    \/\/ More resilience for Weak* tests. These operations may spuriously\n+    \/\/ fail, and so we do several attemps with linear backoff on failure.\n+    \/\/ Because the backoff grows linearly, and the delays might be granular\n+    \/\/ to OS limits, the worst-case total time on test would be at least:\n+    \/\/    Tfail = delay * attempts * (attempts + 1) \/ 2 [ms]\n+    \/\/\n+    static final int WEAK_ATTEMPTS = Integer.getInteger(\"weakAttempts\", 50);\n+    static final int WEAK_BASE_DELAY_MS = Integer.getInteger(\"weakBaseDelay\", 10);\n@@ -93,0 +101,8 @@\n+    static void weakDelay(int multiplier) {\n+        try {\n+            Thread.sleep(WEAK_BASE_DELAY_MS * Math.max(1, multiplier));\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n@@ -305,0 +321,1 @@\n+                if (!success) weakDelay(c);\n@@ -315,0 +332,1 @@\n+                if (!success) weakDelay(c);\n@@ -325,0 +343,1 @@\n+                if (!success) weakDelay(c);\n@@ -335,0 +354,1 @@\n+                if (!success) weakDelay(c);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/X-UnsafeAccessTest.java.template","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleBaseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessBoolean.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessChar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessDouble.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessFloat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessInt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessLong.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessShort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessString.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsChar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsDouble.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsFloat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsInt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsLong.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsShort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessBoolean.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessChar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessDouble.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessFloat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessInt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessLong.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessShort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessString.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestAccess.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestByteArrayView.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestMethodHandleAccess.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}