{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    static int timeout = 5000;\n+    static int timeoutMillis = 5000;\n@@ -49,2 +49,0 @@\n-        long startTime = System.currentTimeMillis();\n-\n@@ -64,3 +62,1 @@\n-        while (System.currentTimeMillis() < startTime + timeout) {\n-            sleep(1000);\n-        }\n+        sleep(timeoutMillis);\n","filename":"test\/hotspot\/jtreg\/gc\/cslocker\/TestCSLocker.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-    public static final long MAX_MILLIS_FOR_RUN = 50 * 1000; \/\/ The maximum runtime for the actual test.\n+    public static final long MAX_NANOS_FOR_RUN = 50L * 1_000_000_000L; \/\/ The maximum runtime for the actual test.\n@@ -96,1 +96,1 @@\n-        long start_millis = System.currentTimeMillis();\n+        long start_nanos = System.nanoTime();\n@@ -99,2 +99,2 @@\n-            long current_millis = System.currentTimeMillis();\n-            if ((current_millis - start_millis) > MAX_MILLIS_FOR_RUN) {\n+            long current_nanos = System.nanoTime();\n+            if ((current_nanos - start_nanos) > MAX_NANOS_FOR_RUN) {\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegionsClearMarkBits.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,1 @@\n-        long timeout = 2000;\n-        long startTime = System.currentTimeMillis();\n+        long timeoutMillis = 2000;\n@@ -69,4 +68,1 @@\n-            while (System.currentTimeMillis() < startTime + timeout) {\n-                System.out.println(\"Sleeping to let periodic GC trigger...\");\n-                Thread.sleep(200);\n-            }\n+            Thread.sleep(timeoutMillis);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestPeriodicCollectionJNI.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-        long duration = Integer.parseInt(args[0]) * 1000L;\n+        long durationNanos = Integer.parseInt(args[0]) * 1_000_000_000L;\n@@ -185,1 +185,1 @@\n-        long startTime = System.currentTimeMillis();\n+        long startTimeNanos = System.nanoTime();\n@@ -222,1 +222,1 @@\n-        while ((System.currentTimeMillis() - startTime < duration) && error == null) {\n+        while ((System.nanoTime() - startTimeNanos < durationNanos) && error == null) {\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestNoAllocationsInHRegions.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,1 @@\n-        long duration = Integer.parseInt(args[0]) * 1000;\n+        long durationNanos = Integer.parseInt(args[0]) * 1_000_000_000L;\n@@ -227,1 +227,1 @@\n-        long startTime = System.currentTimeMillis();\n+        long startTimeNanos = System.nanoTime();\n@@ -241,1 +241,1 @@\n-        while (System.currentTimeMillis() - startTime < duration) {\n+        while (System.nanoTime() - startTimeNanos < durationNanos) {\n","filename":"test\/hotspot\/jtreg\/gc\/logging\/TestUnifiedLoggingSwitchStress.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    private static final long MAX_REWRITE_TIME = 30*1000; \/\/ ms\n+    private static final long MAX_REWRITE_TIME_NS = 30L * 1_000_000_000L; \/\/ 30s in ns\n@@ -214,1 +214,1 @@\n-        long timeBeforeRewrite = System.currentTimeMillis();\n+        long timeBeforeRewriteNanos = System.nanoTime();\n@@ -232,1 +232,1 @@\n-                if (System.currentTimeMillis() - timeBeforeRewrite >= MAX_REWRITE_TIME) {\n+                if (System.nanoTime() - timeBeforeRewriteNanos >= MAX_REWRITE_TIME_NS) {\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringDedupStress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    private static final int TIME_MSEC = 120000;\n+    private static final long TIME_NSEC = 120L * 1_000_000_000L;\n@@ -63,3 +63,3 @@\n-        long start = System.currentTimeMillis();\n-        long current = start;\n-        while (current - start < TIME_MSEC) {\n+        long startNanos = System.nanoTime();\n+        long currentNanos = startNanos;\n+        while (currentNanos - startNanos < TIME_NSEC) {\n@@ -69,1 +69,1 @@\n-            current = System.currentTimeMillis();\n+            currentNanos = System.nanoTime();\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestJNIGlobalRefs.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        final long startTime = System.currentTimeMillis();\n+        final long startTimeNanos = System.nanoTime();\n@@ -179,2 +179,2 @@\n-        long spentTime = System.currentTimeMillis() - startTime;\n-        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ STEP_MS \/ 4;\n+        long spentTimeNanos = System.nanoTime() - startTimeNanos;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - (spentTimeNanos \/ 1_000_000L)) \/ STEP_MS \/ 4;\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-        final long startTime = System.currentTimeMillis();\n+        final long startTimeNanos = System.nanoTime();\n@@ -176,2 +176,2 @@\n-        long spentTime = System.currentTimeMillis() - startTime;\n-        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ STEP_MS \/ 4;\n+        long spentTimeNanos = System.nanoTime() - startTimeNanos;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - (spentTimeNanos \/ 1_000_000L)) \/ STEP_MS \/ 4;\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestPauseNotifications.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-    public static void warmUp(long warmupEndTime, int size, long seed) {\n+    public static void warmUp(long warmupEndTimeNanos, int size, long seed) {\n@@ -70,1 +70,1 @@\n-        while (System.currentTimeMillis() < warmupEndTime) {\n+        while (System.nanoTime() - warmupEndTimeNanos < 0) {\n@@ -81,1 +81,1 @@\n-    public static void runTest(long endTime, int size, double alive, long seed) {\n+    public static void runTest(long endTimeNanos, int size, double alive, long seed) {\n@@ -94,1 +94,1 @@\n-            while (!hadError && (System.currentTimeMillis() < endTime)) {\n+            while (!hadError && (System.nanoTime() - endTimeNanos < 0)) {\n@@ -139,2 +139,2 @@\n-        int warmupDuration = Integer.parseInt(args[1]);\n-        System.out.println(\"WarmUp Duration = \" + warmupDuration);\n+        long warmupDurationNanos = 1_000_000L * Integer.parseInt(args[1]);\n+        System.out.println(\"WarmUp Duration Nanos = \" + warmupDurationNanos);\n@@ -146,2 +146,2 @@\n-        int mainDuration = Integer.parseInt(args[4]);\n-        System.out.println(\"Main Duration = \" + mainDuration);\n+        long mainDurationNanos = 1_000_000L * Integer.parseInt(args[4]);\n+        System.out.println(\"Main Duration Nanos = \" + mainDurationNanos);\n@@ -157,1 +157,1 @@\n-        long warmupStartTime = System.currentTimeMillis();\n+        long warmupStartTimeNanos = System.nanoTime();\n@@ -162,1 +162,1 @@\n-                    warmUp(warmupStartTime + warmupDuration, warmupIterations, seed);\n+                    warmUp(warmupStartTimeNanos + warmupDurationNanos, warmupIterations, seed);\n@@ -173,1 +173,1 @@\n-        long startTime = System.currentTimeMillis();\n+        long startTimeNanos = System.nanoTime();\n@@ -178,1 +178,1 @@\n-                    runTest(startTime + mainDuration, mainIterations, liveFrac, seed);\n+                    runTest(startTimeNanos + mainDurationNanos, mainIterations, liveFrac, seed);\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestJNIBlockFullGC\/TestJNIBlockFullGC.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-        new TestMultiThreadStressRSet().test(time * 1000, threads);\n+        new TestMultiThreadStressRSet().test(time * 1_000_000_000L, threads);\n@@ -150,1 +150,1 @@\n-     * @param timeInMillis how long to stress\n+     * @param timeInNanos how long to stress\n@@ -153,2 +153,2 @@\n-    public void test(long timeInMillis, int maxThreads) {\n-        if (timeInMillis <= 0 || maxThreads <= 0) {\n+    public void test(long timeInNanos, int maxThreads) {\n+        if (timeInNanos <= 0 || maxThreads <= 0) {\n@@ -157,1 +157,1 @@\n-        System.out.println(\"%% Time to work: \" + timeInMillis \/ 1000 + \"s\");\n+        System.out.println(\"%% Time to work: \" + timeInNanos \/ 1_000_000_000L + \"s\");\n@@ -159,1 +159,1 @@\n-        long finish = System.currentTimeMillis() + timeInMillis;\n+        long finishNanos = System.nanoTime() + timeInNanos;\n@@ -166,1 +166,1 @@\n-            while (System.currentTimeMillis() < finish && errorMessage == null) {\n+            while (System.nanoTime() - finishNanos < 0 && errorMessage == null) {\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestMultiThreadStressRSet.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-    public final long start;\n+    public final long startNanos;\n@@ -147,1 +147,1 @@\n-    public final long finishAt;\n+    public final long finishAtNanos;\n@@ -154,1 +154,1 @@\n-    TestStressRSetCoarsening(int objPerRegions, int regsToRefresh, int timeout) {\n+    TestStressRSetCoarsening(int objPerRegions, int regsToRefresh, int timeoutSec) {\n@@ -157,2 +157,2 @@\n-        this.start = System.currentTimeMillis();\n-        this.finishAt = start + timeout * 900; \/\/ 10% ahead of jtreg timeout\n+        this.startNanos = System.nanoTime();\n+        this.finishAtNanos = startNanos + (timeoutSec * 900_000_000L); \/\/ 10% ahead of jtreg timeout\n@@ -287,1 +287,1 @@\n-                            if (System.currentTimeMillis() > finishAt) {\n+                            if (System.nanoTime() - finishAtNanos > 0) {\n@@ -325,1 +325,1 @@\n-        long now = System.currentTimeMillis();\n+        long nowNanos = System.nanoTime();\n@@ -327,1 +327,1 @@\n-        System.out.println(\"%%   Time spent          : \" + ((now - start) \/ 1000) + \" seconds\");\n+        System.out.println(\"%%   Time spent          : \" + ((nowNanos - startNanos) \/ 1_000_000_000L) + \" seconds\");\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressRSetCoarsening.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,3 +60,3 @@\n-        long durationMillis = Long.valueOf(args[0]);\n-        long start = System.currentTimeMillis();\n-        while (System.currentTimeMillis() - start < durationMillis) {\n+        long durationNanos = Long.valueOf(args[0]) * 1_000_000L;\n+        long startNanos = System.nanoTime();\n+        while (System.nanoTime() - startNanos < durationNanos) {\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,11 +136,4 @@\n-        long durationMS = (long) (1000 * durationSec);\n-        long start = System.currentTimeMillis();\n-        long now = start;\n-        long soFar = now - start;\n-        while (soFar < durationMS) {\n-            try {\n-                Thread.sleep(durationMS - soFar);\n-            } catch (Exception e) {\n-            }\n-            now = System.currentTimeMillis();\n-            soFar = now - start;\n+        try {\n+            Thread.sleep(durationSec * 1000L);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Test Failure, did not expect an InterruptedException\", e);\n@@ -148,0 +141,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestExcessGCLockerCollections.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,3 +81,3 @@\n-    private final int minGCWaitMS = 1000;\n-    private final int minFreeWaitElapsedMS = 30000;\n-    private final int minFreeCriticalWaitMS;\n+    private final long minGCWaitNanos = 1_000_000_000L;\n+    private final long minFreeWaitElapsedNanos = 30L * 1_000_000_000L;\n+    private final long minFreeCriticalWaitNanos;\n@@ -86,2 +86,2 @@\n-    private long lastGCDetected = System.currentTimeMillis();\n-    private long lastFree = System.currentTimeMillis();\n+    private long lastGCDetectedNanos = System.nanoTime();\n+    private long lastFreeNanos = System.nanoTime();\n@@ -89,2 +89,2 @@\n-    public MemoryWatcher(String mxBeanName, int minFreeCriticalWaitMS) {\n-        this.minFreeCriticalWaitMS = minFreeCriticalWaitMS;\n+    public MemoryWatcher(String mxBeanName, long minFreeCriticalWaitNanos) {\n+        this.minFreeCriticalWaitNanos = minFreeCriticalWaitNanos;\n@@ -114,1 +114,1 @@\n-        long now = System.currentTimeMillis();\n+        long nowNanos = System.nanoTime();\n@@ -118,1 +118,1 @@\n-            lastGCDetected = now;\n+            lastGCDetectedNanos = nowNanos;\n@@ -124,2 +124,2 @@\n-        long elapsed = now - lastFree;\n-        long timeSinceLastGC = now - lastGCDetected;\n+        long elapsedNanos = nowNanos - lastFreeNanos;\n+        long timeSinceLastGCNanos = nowNanos - lastGCDetectedNanos;\n@@ -127,2 +127,2 @@\n-        if (usage > criticalThresholdPromille && elapsed > minFreeCriticalWaitMS) {\n-            lastFree = now;\n+        if (usage > criticalThresholdPromille && elapsedNanos > minFreeCriticalWaitNanos) {\n+            lastFreeNanos = nowNanos;\n@@ -131,2 +131,2 @@\n-            if (elapsed > minFreeWaitElapsedMS || timeSinceLastGC > minGCWaitMS) {\n-                lastFree = now;\n+            if (elapsedNanos > minFreeWaitElapsedNanos || timeSinceLastGCNanos > minGCWaitNanos) {\n+                lastFreeNanos = nowNanos;\n@@ -155,2 +155,2 @@\n-    public MemoryUser(String mxBeanName, int minFreeCriticalWaitMS) {\n-        watcher = new MemoryWatcher(mxBeanName, minFreeCriticalWaitMS);\n+    public MemoryUser(String mxBeanName, long minFreeCriticalWaitNanos) {\n+        watcher = new MemoryWatcher(mxBeanName, minFreeCriticalWaitNanos);\n@@ -195,2 +195,2 @@\n-    private static Exitable startMemoryUser(String mxBeanName, int minFreeCriticalWaitMS) {\n-        MemoryUser task = new MemoryUser(mxBeanName, minFreeCriticalWaitMS);\n+    private static Exitable startMemoryUser(String mxBeanName, long minFreeCriticalWaitNanos) {\n+        MemoryUser task = new MemoryUser(mxBeanName, minFreeCriticalWaitNanos);\n@@ -210,3 +210,3 @@\n-        int minFreeCriticalWaitMS = args.length > 2 ? Integer.parseInt(args[2]) : 500;\n-\n-        long startMS = System.currentTimeMillis();\n+        long minFreeCriticalWaitNanos = args.length > 2\n+            ? Integer.parseInt(args[2]) * 1_000_000L\n+            : 500_000_000L;\n@@ -216,1 +216,1 @@\n-        Exitable memoryUser = startMemoryUser(mxBeanName, minFreeCriticalWaitMS);\n+        Exitable memoryUser = startMemoryUser(mxBeanName, minFreeCriticalWaitNanos);\n@@ -218,3 +218,4 @@\n-        long durationMS = durationMinutes * 60 * 1000;\n-        while ((System.currentTimeMillis() - startMS) < durationMS) {\n-            ThreadUtils.sleep(10 * 1010);\n+        try {\n+            Thread.sleep(durationMinutes * 60_000L);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Test Failure, did not except an InterruptedException\", e);\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLocker.java","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,1 +372,1 @@\n-    long start = System.currentTimeMillis();\n+    long startNanos = System.nanoTime();\n@@ -378,2 +378,2 @@\n-    long end = System.currentTimeMillis();\n-    float secs = ((float)(end-start))\/1000.0F;\n+    long endNanos = System.nanoTime();\n+    float secs = (endNanos - startNanos) \/ 1_000_000_000F;\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcold\/TestGCOld.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-            String prefix = \"long\" + System.currentTimeMillis();\n+            String prefix = \"long\" + (System.nanoTime() % 10000); \/\/ limit to 4 digits after changing from milliseconds to nanoseconds, else the key will use more memory\n@@ -107,1 +107,1 @@\n-    private static long endTime;\n+    private static long endTimeNanos;\n@@ -140,1 +140,1 @@\n-               if (System.currentTimeMillis() >= endTime) {\n+               if (System.nanoTime() - endTimeNanos >= 0) {\n@@ -168,1 +168,1 @@\n-        for (int i = 0; i < 4 && System.currentTimeMillis() < endTime; i++) {\n+        for (int i = 0; i < 4 && System.nanoTime() - endTimeNanos < 0; i++) {\n@@ -194,3 +194,3 @@\n-        int timeout = Integer.parseInt(args[0]) * 1000;\n-        System.out.println(\"Running with timeout of \" + timeout + \"ms\");\n-        endTime = System.currentTimeMillis() + timeout;\n+        long timeoutNanos = Integer.parseInt(args[0]) * 1_000_000_000L;\n+        System.out.println(\"Running with timeout of \" + timeoutNanos + \"ns\");\n+        endTimeNanos = System.nanoTime() + timeoutNanos;\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGC.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}