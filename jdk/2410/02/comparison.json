{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,7 @@\n+bool DictionaryEntry::is_valid_protection_domain(Handle protection_domain) {\n+\n+  return protection_domain() == NULL || !java_lang_System::allow_security_manager()\n+        ? true\n+        : contains_protection_domain(protection_domain());\n+}\n+\n@@ -136,3 +143,0 @@\n-  \/\/ Lock the pd_set list.  This lock cannot safepoint since the caller holds\n-  \/\/ a Dictionary entry, which can be moved if the Dictionary is resized.\n-  MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n@@ -141,0 +145,1 @@\n+    MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n@@ -163,0 +168,3 @@\n+  \/\/ Lock the pd_set list.  This lock cannot safepoint since the caller holds\n+  \/\/ a Dictionary entry, which can be moved if the Dictionary is resized.\n+  MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n@@ -166,1 +174,3 @@\n-    if (current->object_no_keepalive() == protection_domain) return true;\n+    if (current->object_no_keepalive() == protection_domain) {\n+      return true;\n+    }\n@@ -286,0 +296,1 @@\n+\n@@ -310,1 +321,0 @@\n-\n@@ -315,0 +325,1 @@\n+  assert(java_lang_System::allow_security_manager(), \"only needed if security manager allowed\");\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,8 +156,1 @@\n-  bool is_valid_protection_domain(Handle protection_domain) {\n-    if (!ProtectionDomainVerification) return true;\n-\n-    return protection_domain() == NULL\n-         ? true\n-         : contains_protection_domain(protection_domain());\n-  }\n-\n+  inline bool is_valid_protection_domain(Handle protection_domain);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4385,0 +4385,2 @@\n+int java_lang_System::_static_allow_security_offset;\n+int java_lang_System::_static_never_offset;\n@@ -4390,1 +4392,3 @@\n-  macro(_static_security_offset, k, \"security\", security_manager_signature, true)\n+  macro(_static_security_offset, k, \"security\", security_manager_signature, true); \\\n+  macro(_static_allow_security_offset, k, \"allowSecurityManager\", int_signature, true); \\\n+  macro(_static_never_offset, k, \"NEVER\", int_signature, true)\n@@ -4397,0 +4401,20 @@\n+\/\/ This field tells us that a security manager can never be installed so we\n+\/\/ can completely skip populating the ProtectionDomainCacheTable.\n+bool java_lang_System::allow_security_manager() {\n+  static int initialized = false;\n+  static bool allowed = true; \/\/ default\n+  if (!initialized) {\n+    oop base = vmClasses::System_klass()->static_field_base_raw();\n+    int never = base->int_field(_static_never_offset);\n+    allowed = (base->int_field(_static_allow_security_offset) != never);\n+  }\n+  return allowed;\n+}\n+\n+\/\/ This field means that a security manager can be installed so we still have to\n+\/\/ populate the ProtectionDomainCacheTable.\n+bool java_lang_System::has_security_manager() {\n+  oop base = vmClasses::System_klass()->static_field_base_raw();\n+  return base->obj_field(_static_security_offset) != NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1375,0 +1375,2 @@\n+  static int _static_allow_security_offset;\n+  static int _static_never_offset;\n@@ -1380,0 +1382,2 @@\n+  static bool allow_security_manager();\n+  static bool has_security_manager();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -69,0 +70,3 @@\n+  \/\/ The dictionary entries _pd_set field should be null also, so nothing to do.\n+  assert(java_lang_System::allow_security_manager(), \"should not be called otherwise\");\n+\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,0 +463,3 @@\n+  assert(class_loader() != NULL, \"Should not call this\");\n+  assert(protection_domain() != NULL, \"Should not call this\");\n+\n@@ -470,12 +473,4 @@\n-    if (class_loader() != NULL) {\n-      ls.print(\"class loader: \");\n-      class_loader()->print_value_on(&ls);\n-    } else {\n-      ls.print_cr(\"class loader: NULL\");\n-    }\n-    if (protection_domain() != NULL) {\n-      ls.print(\" protection domain: \");\n-      protection_domain()->print_value_on(&ls);\n-    } else {\n-      ls.print_cr(\" protection domain: NULL\");\n-    }\n+    ls.print(\"class loader: \");\n+    class_loader()->print_value_on(&ls);\n+    ls.print(\" protection domain: \");\n+    protection_domain()->print_value_on(&ls);\n@@ -486,4 +481,2 @@\n-  \/\/ This handle and the class_loader handle passed in keeps this class from\n-  \/\/ being unloaded through several GC points.\n-  \/\/ The class_loader handle passed in is the initiating loader.\n-  Handle mirror(THREAD, klass->java_mirror());\n+  \/\/ We only have to call checkPackageAccess if there's a security manager installed.\n+  if (java_lang_System::has_security_manager()) {\n@@ -491,9 +484,4 @@\n-  InstanceKlass* system_loader = vmClasses::ClassLoader_klass();\n-  JavaCalls::call_special(&result,\n-                         class_loader,\n-                         system_loader,\n-                         vmSymbols::checkPackageAccess_name(),\n-                         vmSymbols::class_protectiondomain_signature(),\n-                         mirror,\n-                         protection_domain,\n-                         THREAD);\n+    \/\/ This handle and the class_loader handle passed in keeps this class from\n+    \/\/ being unloaded through several GC points.\n+    \/\/ The class_loader handle passed in is the initiating loader.\n+    Handle mirror(THREAD, klass->java_mirror());\n@@ -501,5 +489,9 @@\n-  if (HAS_PENDING_EXCEPTION) {\n-    log_debug(protectiondomain)(\"DENIED !!!!!!!!!!!!!!!!!!!!!\");\n-  } else {\n-   log_debug(protectiondomain)(\"granted\");\n-  }\n+    InstanceKlass* system_loader = vmClasses::ClassLoader_klass();\n+    JavaCalls::call_special(&result,\n+                           class_loader,\n+                           system_loader,\n+                           vmSymbols::checkPackageAccess_name(),\n+                           vmSymbols::class_protectiondomain_signature(),\n+                           mirror,\n+                           protection_domain,\n+                           THREAD);\n@@ -507,1 +499,8 @@\n-  if (HAS_PENDING_EXCEPTION) return;\n+    if (HAS_PENDING_EXCEPTION) {\n+      log_debug(protectiondomain)(\"DENIED !!!!!!!!!!!!!!!!!!!!!\");\n+    } else {\n+     log_debug(protectiondomain)(\"granted\");\n+    }\n+\n+    if (HAS_PENDING_EXCEPTION) return;\n+  }\n@@ -511,0 +510,3 @@\n+  \/\/ We still have to add the protection_domain to the dictionary in case a new\n+  \/\/ security manager is installed later. Calls to load the same class with class loader\n+  \/\/ and protection domain are expected to succeed.\n@@ -892,5 +894,4 @@\n-  \/\/ return if the protection domain in NULL\n-  if (protection_domain() == NULL) return loaded_class;\n-\n-  \/\/ Check the protection domain has the right access\n-  if (dictionary->is_valid_protection_domain(name_hash, name,\n+  \/\/ Check if the protection domain is present it has the right access\n+  if (protection_domain() != NULL &&\n+     java_lang_System::allow_security_manager() &&\n+     !dictionary->is_valid_protection_domain(name_hash, name,\n@@ -898,1 +899,2 @@\n-    return loaded_class;\n+    \/\/ Verify protection domain. If it fails an exception is thrown\n+    validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n@@ -901,3 +903,0 @@\n-  \/\/ Verify protection domain. If it fails an exception is thrown\n-  validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n-\n@@ -1764,6 +1763,10 @@\n-    \/\/ Oops referenced by the protection domain cache table may get unreachable independently\n-    \/\/ of the class loader (eg. cached protection domain oops). So we need to\n-    \/\/ explicitly unlink them here.\n-    \/\/ All protection domain oops are linked to the caller class, so if nothing\n-    \/\/ unloads, this is not needed.\n-    _pd_cache_table->trigger_cleanup();\n+    if (java_lang_System::allow_security_manager()) {\n+      \/\/ Oops referenced by the protection domain cache table may get unreachable independently\n+      \/\/ of the class loader (eg. cached protection domain oops). So we need to\n+      \/\/ explicitly unlink them here.\n+      \/\/ All protection domain oops are linked to the caller class, so if nothing\n+      \/\/ unloads, this is not needed.\n+      _pd_cache_table->trigger_cleanup();\n+    } else {\n+      assert(_pd_cache_table->number_of_entries() == 0, \"should be empty\");\n+    }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":49,"deletions":46,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -680,3 +680,0 @@\n-  develop(bool, ProtectionDomainVerification, true,                         \\\n-          \"Verify protection domain before resolution in system dictionary\")\\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+    \/\/ @implNote The HotSpot JVM hardcodes the value of NEVER.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,3 +44,4 @@\n-        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n-        out.shouldContain(\"[protectiondomain] Checking package access\");\n-        out.shouldContain(\"[protectiondomain] pd set count = #\");\n+        new OutputAnalyzer(pb.start())\n+        .shouldHaveExitValue(0)\n+        .shouldContain(\"[protectiondomain] Checking package access\")\n+        .shouldContain(\"[protectiondomain] pd set count = #\");\n@@ -52,3 +53,14 @@\n-        out = new OutputAnalyzer(pb.start());\n-        out.shouldContain(\"[protectiondomain] Checking package access\");\n-        out.shouldNotContain(\"pd set count = #\");\n+        new OutputAnalyzer(pb.start())\n+        .shouldHaveExitValue(0)\n+        .shouldContain(\"[protectiondomain] Checking package access\")\n+        .shouldNotContain(\"pd set count = #\");\n+\n+        \/\/ -Xlog:protectiondomain=debug\n+        pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:protectiondomain=trace\",\n+                                                   \"-Xmx128m\",\n+                                                   \"-Djava.security.manager=disallow\",\n+                                                   Hello.class.getName());\n+        new OutputAnalyzer(pb.start())\n+        .shouldHaveExitValue(0)\n+        .shouldNotContain(\"[protectiondomain] Checking package access\")\n+        .shouldNotContain(\"pd set count = #\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ProtectionDomainVerificationTest.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"}]}