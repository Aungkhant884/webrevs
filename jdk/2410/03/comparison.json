{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,7 @@\n+bool DictionaryEntry::is_valid_protection_domain(Handle protection_domain) {\n+\n+  return protection_domain() == NULL || !java_lang_System::allow_security_manager()\n+        ? true\n+        : contains_protection_domain(protection_domain());\n+}\n+\n@@ -136,3 +143,0 @@\n-  \/\/ Lock the pd_set list.  This lock cannot safepoint since the caller holds\n-  \/\/ a Dictionary entry, which can be moved if the Dictionary is resized.\n-  MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n@@ -141,0 +145,1 @@\n+    MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n@@ -163,0 +168,3 @@\n+  \/\/ Lock the pd_set list.  This lock cannot safepoint since the caller holds\n+  \/\/ a Dictionary entry, which can be moved if the Dictionary is resized.\n+  MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n@@ -166,1 +174,3 @@\n-    if (current->object_no_keepalive() == protection_domain) return true;\n+    if (current->object_no_keepalive() == protection_domain) {\n+      return true;\n+    }\n@@ -286,0 +296,1 @@\n+\n@@ -310,1 +321,0 @@\n-\n@@ -315,0 +325,1 @@\n+  assert(java_lang_System::allow_security_manager(), \"only needed if security manager allowed\");\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,8 +156,1 @@\n-  bool is_valid_protection_domain(Handle protection_domain) {\n-    if (!ProtectionDomainVerification) return true;\n-\n-    return protection_domain() == NULL\n-         ? true\n-         : contains_protection_domain(protection_domain());\n-  }\n-\n+  inline bool is_valid_protection_domain(Handle protection_domain);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4385,0 +4385,2 @@\n+int java_lang_System::_static_allow_security_offset;\n+int java_lang_System::_static_never_offset;\n@@ -4390,1 +4392,3 @@\n-  macro(_static_security_offset, k, \"security\", security_manager_signature, true)\n+  macro(_static_security_offset, k, \"security\", security_manager_signature, true); \\\n+  macro(_static_allow_security_offset, k, \"allowSecurityManager\", int_signature, true); \\\n+  macro(_static_never_offset, k, \"NEVER\", int_signature, true)\n@@ -4397,0 +4401,19 @@\n+\/\/ This field tells us that a security manager can never be installed so we\n+\/\/ can completely skip populating the ProtectionDomainCacheTable.\n+bool java_lang_System::allow_security_manager() {\n+  static int initialized = false;\n+  static bool allowed = true; \/\/ default\n+  if (!initialized) {\n+    oop base = vmClasses::System_klass()->static_field_base_raw();\n+    int never = base->int_field(_static_never_offset);\n+    allowed = (base->int_field(_static_allow_security_offset) != never);\n+  }\n+  return allowed;\n+}\n+\n+\/\/ This field tells us that a security manager is installed.\n+bool java_lang_System::has_security_manager() {\n+  oop base = vmClasses::System_klass()->static_field_base_raw();\n+  return base->obj_field(_static_security_offset) != NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1375,0 +1375,2 @@\n+  static int _static_allow_security_offset;\n+  static int _static_never_offset;\n@@ -1380,0 +1382,2 @@\n+  static bool allow_security_manager();\n+  static bool has_security_manager();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -69,0 +70,3 @@\n+  \/\/ The dictionary entries _pd_set field should be null also, so nothing to do.\n+  assert(java_lang_System::allow_security_manager(), \"should not be called otherwise\");\n+\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,8 +463,28 @@\n-  JavaValue result(T_VOID);\n-  LogTarget(Debug, protectiondomain) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm(THREAD);\n-    \/\/ Print out trace information\n-    LogStream ls(lt);\n-    ls.print_cr(\"Checking package access\");\n-    if (class_loader() != NULL) {\n+  assert(class_loader() != NULL, \"Should not call this\");\n+  assert(protection_domain() != NULL, \"Should not call this\");\n+\n+  \/\/ We only have to call checkPackageAccess if there's a security manager installed.\n+  if (java_lang_System::has_security_manager()) {\n+\n+    \/\/ This handle and the class_loader handle passed in keeps this class from\n+    \/\/ being unloaded through several GC points.\n+    \/\/ The class_loader handle passed in is the initiating loader.\n+    Handle mirror(THREAD, klass->java_mirror());\n+\n+    InstanceKlass* system_loader = vmClasses::ClassLoader_klass();\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_special(&result,\n+                           class_loader,\n+                           system_loader,\n+                           vmSymbols::checkPackageAccess_name(),\n+                           vmSymbols::class_protectiondomain_signature(),\n+                           mirror,\n+                           protection_domain,\n+                           THREAD);\n+\n+    LogTarget(Debug, protectiondomain) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm(THREAD);\n+      \/\/ Print out trace information\n+      LogStream ls(lt);\n+      ls.print_cr(\"Checking package access\");\n@@ -473,4 +493,0 @@\n-    } else {\n-      ls.print_cr(\"class loader: NULL\");\n-    }\n-    if (protection_domain() != NULL) {\n@@ -479,2 +495,6 @@\n-    } else {\n-      ls.print_cr(\" protection domain: NULL\");\n+      ls.print(\" loading: \"); klass->print_value_on(&ls);\n+      if (HAS_PENDING_EXCEPTION) {\n+        ls.print_cr(\" DENIED !!!!!!!!!!!!!!!!!!!!!\");\n+      } else {\n+        ls.print_cr(\" granted\");\n+      }\n@@ -482,8 +502,0 @@\n-    ls.print(\" loading: \"); klass->print_value_on(&ls);\n-    ls.cr();\n-  }\n-\n-  \/\/ This handle and the class_loader handle passed in keeps this class from\n-  \/\/ being unloaded through several GC points.\n-  \/\/ The class_loader handle passed in is the initiating loader.\n-  Handle mirror(THREAD, klass->java_mirror());\n@@ -491,14 +503,1 @@\n-  InstanceKlass* system_loader = vmClasses::ClassLoader_klass();\n-  JavaCalls::call_special(&result,\n-                         class_loader,\n-                         system_loader,\n-                         vmSymbols::checkPackageAccess_name(),\n-                         vmSymbols::class_protectiondomain_signature(),\n-                         mirror,\n-                         protection_domain,\n-                         THREAD);\n-\n-  if (HAS_PENDING_EXCEPTION) {\n-    log_debug(protectiondomain)(\"DENIED !!!!!!!!!!!!!!!!!!!!!\");\n-  } else {\n-   log_debug(protectiondomain)(\"granted\");\n+    if (HAS_PENDING_EXCEPTION) return;\n@@ -507,2 +506,0 @@\n-  if (HAS_PENDING_EXCEPTION) return;\n-\n@@ -511,0 +508,3 @@\n+  \/\/ We still have to add the protection_domain to the dictionary in case a new\n+  \/\/ security manager is installed later. Calls to load the same class with class loader\n+  \/\/ and protection domain are expected to succeed.\n@@ -892,5 +892,4 @@\n-  \/\/ return if the protection domain in NULL\n-  if (protection_domain() == NULL) return loaded_class;\n-\n-  \/\/ Check the protection domain has the right access\n-  if (dictionary->is_valid_protection_domain(name_hash, name,\n+  \/\/ Check if the protection domain is present it has the right access\n+  if (protection_domain() != NULL &&\n+     java_lang_System::allow_security_manager() &&\n+     !dictionary->is_valid_protection_domain(name_hash, name,\n@@ -898,1 +897,2 @@\n-    return loaded_class;\n+    \/\/ Verify protection domain. If it fails an exception is thrown\n+    validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n@@ -901,3 +901,0 @@\n-  \/\/ Verify protection domain. If it fails an exception is thrown\n-  validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n-\n@@ -1764,6 +1761,10 @@\n-    \/\/ Oops referenced by the protection domain cache table may get unreachable independently\n-    \/\/ of the class loader (eg. cached protection domain oops). So we need to\n-    \/\/ explicitly unlink them here.\n-    \/\/ All protection domain oops are linked to the caller class, so if nothing\n-    \/\/ unloads, this is not needed.\n-    _pd_cache_table->trigger_cleanup();\n+    if (java_lang_System::allow_security_manager()) {\n+      \/\/ Oops referenced by the protection domain cache table may get unreachable independently\n+      \/\/ of the class loader (eg. cached protection domain oops). So we need to\n+      \/\/ explicitly unlink them here.\n+      \/\/ All protection domain oops are linked to the caller class, so if nothing\n+      \/\/ unloads, this is not needed.\n+      _pd_cache_table->trigger_cleanup();\n+    } else {\n+      assert(_pd_cache_table->number_of_entries() == 0, \"should be empty\");\n+    }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":54,"deletions":53,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -680,3 +680,0 @@\n-  develop(bool, ProtectionDomainVerification, true,                         \\\n-          \"Verify protection domain before resolution in system dictionary\")\\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,4 +43,5 @@\n-                                                                  Hello.class.getName());\n-        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n-        out.shouldContain(\"[protectiondomain] Checking package access\");\n-        out.shouldContain(\"[protectiondomain] pd set count = #\");\n+                                                                  Hello.class.getName(), \"security_manager\");\n+        new OutputAnalyzer(pb.start())\n+        .shouldHaveExitValue(0)\n+        .shouldContain(\"[protectiondomain] Checking package access\")\n+        .shouldContain(\"[protectiondomain] pd set count = #\");\n@@ -51,4 +52,15 @@\n-                                                                  Hello.class.getName());\n-        out = new OutputAnalyzer(pb.start());\n-        out.shouldContain(\"[protectiondomain] Checking package access\");\n-        out.shouldNotContain(\"pd set count = #\");\n+                                                                  Hello.class.getName(), \"security_manager\");\n+        new OutputAnalyzer(pb.start())\n+        .shouldHaveExitValue(0)\n+        .shouldContain(\"[protectiondomain] Checking package access\")\n+        .shouldNotContain(\"pd set count = #\");\n+\n+        \/\/ -Xlog:protectiondomain=debug\n+        pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:protectiondomain=trace\",\n+                                                   \"-Xmx128m\",\n+                                                   \"-Djava.security.manager=disallow\",\n+                                                   Hello.class.getName());\n+        new OutputAnalyzer(pb.start())\n+        .shouldHaveExitValue(0)\n+        .shouldNotContain(\"[protectiondomain] Checking package access\")\n+        .shouldNotContain(\"pd set count = #\");\n@@ -59,0 +71,4 @@\n+            if (args.length == 1) {\n+              \/\/ Need a security manager to trigger logging.\n+              System.setSecurityManager(new SecurityManager());\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ProtectionDomainVerificationTest.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"}]}