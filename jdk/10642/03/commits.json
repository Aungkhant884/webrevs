[{"commit":{"message":"Remove the atomic operation to \"_index\""},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp"}],"sha":"84556aebd2d34840083c52726d99a76512e68b80"},{"commit":{"message":"Remove rscratch3 for count_bytecode() and histogram_bytecode()"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp"}],"sha":"bbbc3020495367495bc651cf51939f1a2cb60e29"},{"commit":{"message":"Introduce atomic_orrw\n\nIntroduce atomic_orrw() function as suggested by aph.\nBesides, remove atomic_incw(). It's dead code."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp"}],"sha":"0db3975850e5ee3c35aa33e2e12591ab809633d9"},{"commit":{"message":"8295023: Interpreter(AArch64): Implement -XX:+PrintBytecodeHistogram and -XX:+PrintBytecodePairHistogram options\n\nIn this patch, we implement functions histogram_bytecode() and\nhistogram_bytecode_pair() for interpreter AArch64 part. Similar to\ncount_bytecode(), we use atomic operations to update the counters as\nwell.\n\nHere shows part of the message produced with -XX:+PrintBytecodeHistogram\nand -XX:+PrintBytecodePairHistogram options after this patch.\n\n```\n$ java -XX:+PrintBytecodeHistogram --version | head -20\nopenjdk 20-internal 2023-03-21\nOpenJDK Runtime Environment (fastdebug build 20-internal-adhoc.haosun.jdk-src-dev)\nOpenJDK 64-Bit Server VM (fastdebug build 20-internal-adhoc.haosun.jdk-src-dev, mixed mode)\n\nHistogram of 5004099 executed bytecodes:\n\n  absolute  relative  code    name\n----------------------------------------------------------------------\n    319124     6.38%    dc    fast_aload_0\n    313397     6.26%    e0    fast_iload\n    251436     5.02%    b6    invokevirtual\n    227428     4.54%    19    aload\n    166054     3.32%    a7    goto\n    159167     3.18%    2b    aload_1\n    151803     3.03%    de    fast_aaccess_0\n    136787     2.73%    1b    iload_1\n    124037     2.48%    36    istore\n    118791     2.37%    84    iinc\n    118121     2.36%    1c    iload_2\n    110484     2.21%    a2    if_icmpge\n\n$ java -XX:+PrintBytecodePairHistogram --version | head -20\nopenjdk 20-internal 2023-03-21\nOpenJDK Runtime Environment (fastdebug build 20-internal-adhoc.haosun.jdk-src-dev)\nOpenJDK 64-Bit Server VM (fastdebug build 20-internal-adhoc.haosun.jdk-src-dev, mixed mode)\n\nHistogram of 4804441 executed bytecode pairs:\n\n  absolute  relative    codes    1st bytecode        2nd bytecode\n----------------------------------------------------------------------\n     77602    1.615%    84 a7    iinc                goto\n     49749    1.035%    36 e0    istore              fast_iload\n     48931    1.018%    e0 10    fast_iload          bipush\n     46294    0.964%    e0 b6    fast_iload          invokevirtual\n     42661    0.888%    a7 e0    goto                fast_iload\n     42243    0.879%    3a 19    astore              aload\n     40138    0.835%    19 b9    aload               invokeinterface\n     36617    0.762%    dc 2b    fast_aload_0        aload_1\n     35745    0.744%    b7 dc    invokespecial       fast_aload_0\n     35384    0.736%    19 b6    aload               invokevirtual\n     35035    0.729%    b6 de    invokevirtual       fast_aaccess_0\n     34667    0.722%    dc b6    fast_aload_0        invokevirtual\n```\n\nIn order to verfiy the correctness, I took the trace information\nproduced by -XX:+TraceBytecodes as a cross reference. The hit times for\nsome bytecodes\/bytecode pairs can be obtained via parsing the trace.\nThen I compared the hit times with the corresponding \"absolute\" columns.\nI randomly selected several bytecodes\/bytecode pairs, and the manual\ncomparion results showed that \"absolute\" columns are correct.\n\nNote-1: count_bytecode() is updated. 1) caller-saved registers are used\nas temporary registers and there is no need to save\/restore them. 2)\natomic_addw() should be used since the counter is of int type.\n\nNote-2: As shown by the update in file templateInterpreterGenerator.cpp,\nfunction histogram_bytecode() should be invoked only inside !PRODUCT\nscope."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp"},{"filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp"}],"sha":"7e8b738ae0441fa5ccdcd76c3c4ec06e50bb447e"}]