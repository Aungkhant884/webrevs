{"files":[{"patch":"@@ -1893,18 +1893,0 @@\n-void MacroAssembler::atomic_incw(Register counter_addr, Register tmp, Register tmp2) {\n-  if (UseLSE) {\n-    mov(tmp, 1);\n-    ldadd(Assembler::word, tmp, zr, counter_addr);\n-    return;\n-  }\n-  Label retry_load;\n-  prfm(Address(counter_addr), PSTL1STRM);\n-  bind(retry_load);\n-  \/\/ flush and load exclusive from the memory location\n-  ldxrw(tmp, counter_addr);\n-  addw(tmp, tmp, 1);\n-  \/\/ if we store+flush with no intervening write tmp will be zero\n-  stxrw(tmp2, tmp, counter_addr);\n-  cbnzw(tmp2, retry_load);\n-}\n-\n-\n@@ -2793,0 +2775,14 @@\n+\/\/ Atomic bitwise OR on word in memory addr with operand op.\n+\/\/ Note-1: the value in memory addr can be optionally shifted.\n+\/\/ Note-2: the final computation result is stored in register result as well.\n+void MacroAssembler::atomic_orrw(Register addr, Register op, Register result, Register tmp,\n+                                 enum shift_kind kind, unsigned shift) {\n+  Label retry_load;\n+  prfm(Address(addr), PSTL1STRM);\n+  bind(retry_load);\n+  ldxrw(result, addr);\n+  orrw(result, op, result, kind, shift);\n+  stxrw(tmp, result, addr);\n+  cbnzw(tmp, retry_load);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -113,7 +113,0 @@\n-  \/\/ Helper functions for statistics gathering.\n-  \/\/ Unconditional atomic increment.\n-  void atomic_incw(Register counter_addr, Register tmp, Register tmp2);\n-  void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {\n-    lea(tmp1, counter_addr);\n-    atomic_incw(tmp1, tmp2, tmp3);\n-  }\n@@ -1072,0 +1065,6 @@\n+  \/\/ Atomic bitwise OR on word in memory addr with operand op.\n+  \/\/ Note-1: the value in memory addr can be optionally shifted.\n+  \/\/ Note-2: the final computation result is stored in register result as well.\n+  void atomic_orrw(Register addr, Register op, Register result, Register tmp,\n+                   enum shift_kind kind = Assembler::LSL, unsigned shift = 0);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2002,7 +2002,4 @@\n-  __ prfm(Address(index_addr), PSTL1STRM);\n-  __ bind(L);\n-  __ ldxrw(rscratch2, index_addr);\n-  __ orrw(index, rscratch1, rscratch2, Assembler::LSR,\n-          BytecodePairHistogram::log2_number_of_codes);\n-  __ stxrw(rscratch2, index, index_addr);\n-  __ cbnzw(rscratch2, L);  \/\/ retry to load _index\n+  __ atomic_orrw(index_addr, rscratch1, index,\n+                 \/* tmp *\/ rscratch2,\n+                 \/* kind *\/ Assembler::LSR,\n+                 \/* shift *\/ BytecodePairHistogram::log2_number_of_codes);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}