{"files":[{"patch":"@@ -1443,0 +1443,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 6 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 6 : FLOATPRESSURE;\n+}\n+\n@@ -13668,1 +13678,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -13683,1 +13693,1 @@\n-                 $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, noreg, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+extern RegMask _FLOAT_REG_mask;\n@@ -353,0 +354,1 @@\n+RegMask _FLOAT_REG_mask;\n@@ -428,0 +430,4 @@\n+  \/\/ _FLOAT_REG_LEGACY_mask\/_FLOAT_REG_EVEX_mask is generated by adlc\n+  \/\/ from the float_reg_legacy\/float_reg_evex register class.\n+  _FLOAT_REG_mask = VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask;\n+\n@@ -1761,0 +1767,14 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? _INT_REG_mask.Size() : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ After experiment around with different values, the following default threshold\n+  \/\/ works best for LCM's register pressure scheduling on x64.\n+  uint dec_count  = VM_Version::supports_evex() ? 4 : 2;\n+  uint default_float_pressure_threshold = _FLOAT_REG_mask.Size() - dec_count;\n+  return (FLOATPRESSURE == -1) ? default_float_pressure_threshold : FLOATPRESSURE;\n+}\n+\n@@ -12908,1 +12928,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -12923,1 +12943,1 @@\n-                 $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, $cx1$$Register, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2168,80 +2168,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/*\n-     *  See the full description in MacroAssembler::biased_locking_enter().\n-     *\n-     *  if( (mark_word & biased_lock_mask) == biased_lock_pattern ) {\n-     *    \/\/ The object is biased.\n-     *    proto_node = klass->prototype_header;\n-     *    o_node = thread | proto_node;\n-     *    x_node = o_node ^ mark_word;\n-     *    if( (x_node & ~age_mask) == 0 ) { \/\/ Biased to the current thread ?\n-     *      \/\/ Done.\n-     *    } else {\n-     *      if( (x_node & biased_lock_mask) != 0 ) {\n-     *        \/\/ The klass's prototype header is no longer biased.\n-     *        cas(&mark_word, mark_word, proto_node)\n-     *        goto cas_lock;\n-     *      } else {\n-     *        \/\/ The klass's prototype header is still biased.\n-     *        if( (x_node & epoch_mask) != 0 ) { \/\/ Expired epoch?\n-     *          old = mark_word;\n-     *          new = o_node;\n-     *        } else {\n-     *          \/\/ Different thread or anonymous biased.\n-     *          old = mark_word & (epoch_mask | age_mask | biased_lock_mask);\n-     *          new = thread | old;\n-     *        }\n-     *        \/\/ Try to rebias.\n-     *        if( cas(&mark_word, old, new) == 0 ) {\n-     *          \/\/ Done.\n-     *        } else {\n-     *          goto slow_path; \/\/ Failed.\n-     *        }\n-     *      }\n-     *    }\n-     *  } else {\n-     *    \/\/ The object is not biased.\n-     *    cas_lock:\n-     *    if( FastLock(obj) == 0 ) {\n-     *      \/\/ Done.\n-     *    } else {\n-     *      slow_path:\n-     *      OptoRuntime::complete_monitor_locking_Java(obj);\n-     *    }\n-     *  }\n-     *\/\n-\n-    region  = new RegionNode(5);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    Node* fast_lock_region  = new RegionNode(3);\n-    Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ First, check mark word for the biased lock pattern.\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-\n-    \/\/ Get fast path - mark word has the biased lock pattern.\n-    ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern, true);\n-    \/\/ fast_lock_region->in(1) is set to slow path.\n-    fast_lock_mem_phi->init_req(1, mem);\n-\n-    \/\/ Now check that the lock is biased to the current thread and has\n-    \/\/ the same epoch and bias as Klass::_prototype_header.\n-\n-    \/\/ Special-case a fresh allocation to avoid building nodes:\n-    Node* klass_node = AllocateNode::Ideal_klass(obj, &_igvn);\n-    if (klass_node == NULL) {\n-      Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n-      klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)->is_ptr()));\n-#ifdef _LP64\n-      if (UseCompressedClassPointers && klass_node->is_DecodeNKlass()) {\n-        assert(klass_node->in(1)->Opcode() == Op_LoadNKlass, \"sanity\");\n-        klass_node->in(1)->init_req(0, ctrl);\n-      } else\n-#endif\n-      klass_node->init_req(0, ctrl);\n-    }\n-    Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X->basic_type());\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n@@ -2249,109 +2172,3 @@\n-    Node* thread = transform_later(new ThreadLocalNode());\n-    Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));\n-    Node* x_node = transform_later(new XorXNode(o_node, mark_node));\n-\n-    \/\/ Get slow path - mark word does NOT match the value.\n-    STATIC_ASSERT(markWord::age_mask_in_place <= INT_MAX);\n-    Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,\n-                                      (~(int)markWord::age_mask_in_place), 0);\n-    \/\/ region->in(3) is set to fast path - the object is biased to the current thread.\n-    mem_phi->init_req(3, mem);\n-\n-\n-    \/\/ Mark word does NOT match the value (thread | Klass::_prototype_header).\n-\n-\n-    \/\/ First, check biased pattern.\n-    \/\/ Get fast path - _prototype_header has the same biased lock pattern.\n-    ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,\n-                          markWord::biased_lock_mask_in_place, 0, true);\n-\n-    not_biased_ctrl = fast_lock_region->in(2); \/\/ Slow path\n-    \/\/ fast_lock_region->in(2) - the prototype header is no longer biased\n-    \/\/ and we have to revoke the bias on this object.\n-    \/\/ We are going to try to reset the mark of this object to the prototype\n-    \/\/ value and fall through to the CAS-based locking scheme.\n-    Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n-    Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,\n-                                          proto_node, mark_node);\n-    transform_later(cas);\n-    Node* proj = transform_later(new SCMemProjNode(cas));\n-    fast_lock_mem_phi->init_req(2, proj);\n-\n-\n-    \/\/ Second, check epoch bits.\n-    Node* rebiased_region  = new RegionNode(3);\n-    Node* old_phi = new PhiNode( rebiased_region, TypeX_X);\n-    Node* new_phi = new PhiNode( rebiased_region, TypeX_X);\n-\n-    \/\/ Get slow path - mark word does NOT match epoch bits.\n-    Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,\n-                                      markWord::epoch_mask_in_place, 0);\n-    \/\/ The epoch of the current bias is not valid, attempt to rebias the object\n-    \/\/ toward the current thread.\n-    rebiased_region->init_req(2, epoch_ctrl);\n-    old_phi->init_req(2, mark_node);\n-    new_phi->init_req(2, o_node);\n-\n-    \/\/ rebiased_region->in(1) is set to fast path.\n-    \/\/ The epoch of the current bias is still valid but we know\n-    \/\/ nothing about the owner; it might be set or it might be clear.\n-    Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |\n-                             markWord::age_mask_in_place |\n-                             markWord::epoch_mask_in_place);\n-    Node* old = transform_later(new AndXNode(mark_node, cmask));\n-    cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* new_mark = transform_later(new OrXNode(cast_thread, old));\n-    old_phi->init_req(1, old);\n-    new_phi->init_req(1, new_mark);\n-\n-    transform_later(rebiased_region);\n-    transform_later(old_phi);\n-    transform_later(new_phi);\n-\n-    \/\/ Try to acquire the bias of the object using an atomic operation.\n-    \/\/ If this fails we will go in to the runtime to revoke the object's bias.\n-    cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);\n-    transform_later(cas);\n-    proj = transform_later(new SCMemProjNode(cas));\n-\n-    \/\/ Get slow path - Failed to CAS.\n-    not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);\n-    mem_phi->init_req(4, proj);\n-    \/\/ region->in(4) is set to fast path - the object is rebiased to the current thread.\n-\n-    \/\/ Failed to CAS.\n-    slow_path  = new RegionNode(3);\n-    Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    slow_path->init_req(1, not_biased_ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(1, proj);\n-\n-    \/\/ Call CAS-based locking scheme (FastLock node).\n-\n-    transform_later(fast_lock_region);\n-    transform_later(fast_lock_mem_phi);\n-\n-    \/\/ Get slow path - FastLock failed to lock the object.\n-    ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, fast_lock_mem_phi);\n-    \/\/ region->in(2) is set to fast path - the object is locked to the current thread.\n-\n-    slow_path->init_req(2, ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(2, fast_lock_mem_phi);\n-\n-    transform_later(slow_path);\n-    transform_later(slow_mem);\n-    \/\/ Reset lock's memory edge.\n-    lock->set_req(TypeFunc::Memory, slow_mem);\n-\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ Optimize test; set region slot 2\n-    slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, mem);\n-  }\n+  \/\/ Optimize test; set region slot 2\n+  slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n+  mem_phi->init_req(2, mem);\n@@ -2407,17 +2224,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/\/ Check for biased locking unlock case, which is a no-op.\n-    \/\/ See the full description in MacroAssembler::biased_locking_exit().\n-    region  = new RegionNode(4);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-    mem_phi->init_req(3, mem);\n-\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-    ctrl = opt_bits_test(ctrl, region, 3, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern);\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-  }\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":9,"deletions":206,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -1837,7 +1837,0 @@\n-  AllocateNode* alloc = is_new_object_mark_load(phase);\n-  if (alloc != NULL && alloc->Opcode() == Op_Allocate && UseBiasedLocking) {\n-    InitializeNode* init = alloc->initialization();\n-    Node* control = init->proj_out(0);\n-    return alloc->make_ideal_mark(phase, address, control, mem);\n-  }\n-\n@@ -2106,1 +2099,1 @@\n-  if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n+  if (alloc != NULL) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"}]}