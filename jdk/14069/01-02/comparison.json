{"files":[{"patch":"@@ -2770,1 +2770,1 @@\n-  Label success, failure, anonymous, not_anonymous, object_has_monitor, notRecursive;\n+  Label success, failure, object_has_monitor, notRecursive;\n@@ -2845,11 +2845,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    \/\/ Some other platforms use a C2HandleAnonOMOwnerStub stub.\n-    \/\/ This doesn't work well here, because we reach here for native wrappers, too.\n-    \/\/ In addition, the stub may be out of range for conditional branches.\n-    \/\/ The fixup code is not long, so we do it among other special cases below.\n-\n-    \/\/ If the owner is anonymous, we need to fix it.\n-    andi_(R0, temp, ObjectMonitor::ANONYMOUS_OWNER);\n-    bne(CCR0, anonymous);\n-  }\n-\n+  \/\/ In case of LM_LIGHTWEIGHT, we may reach here with (temp & ObjectMonitor::ANONYMOUS_OWNER) != 0.\n+  \/\/ This is handled like owner thread mismatches: We take the slow path.\n@@ -2859,1 +2850,0 @@\n-  bind(not_anonymous);\n@@ -2870,16 +2860,0 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    bind(anonymous);\n-    \/\/ Fix owner to be the current thread.\n-    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), current_header);\n-\n-    \/\/ Pop owner object from lock-stack.\n-    lwz(temp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n-    addi(temp, temp, -oopSize);\n-#ifdef ASSERT\n-    li(R0, 0);\n-    stwx(R0, temp, R16_thread);\n-#endif\n-    stw(temp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n-    b(not_anonymous);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":3,"deletions":29,"binary":false,"changes":32,"status":"modified"}]}