{"files":[{"patch":"@@ -608,19 +608,0 @@\n-  # Optional POSIX functionality needed by the JVM\n-  #\n-  # Check if clock_gettime is available and in which library. This indicates\n-  # availability of CLOCK_MONOTONIC for hotspot. But we don't need to link, so\n-  # don't let it update LIBS.\n-  save_LIBS=\"$LIBS\"\n-  AC_SEARCH_LIBS(clock_gettime, rt, [HAS_CLOCK_GETTIME=true], [])\n-  if test \"x$LIBS\" = \"x-lrt \"; then\n-    CLOCK_GETTIME_IN_LIBRT=true\n-  fi\n-  LIBS=\"$save_LIBS\"\n-\n-  if test \"x$HAS_CLOCK_GETTIME\" = \"xtrue\"; then\n-    OS_CFLAGS_JVM=\"$OS_CFLAGS_JVM -DSUPPORTS_CLOCK_MONOTONIC\"\n-    if test \"x$CLOCK_GETTIME_IN_LIBRT\" = \"xtrue\"; then\n-      OS_CFLAGS_JVM=\"$OS_CFLAGS_JVM -DNEEDS_LIBRT\"\n-    fi\n-  fi\n-\n","filename":"make\/autoconf\/flags-cflags.m4","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -111,0 +111,7 @@\n+    if test \"x$OPENJDK_TARGET_OS\" = xlinux; then\n+      # Hotspot needs to link librt to get the clock_* functions.\n+      # But once our supported minimum build and runtime platform\n+      # has glibc 2.17, this can be removed as the functions are\n+      # in libc.\n+      OS_LDFLAGS_JVM_ONLY=\"-lrt\"\n+    fi\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -962,15 +962,0 @@\n-jlong os::javaTimeMillis() {\n-  timeval time;\n-  int status = gettimeofday(&time, NULL);\n-  assert(status != -1, \"aix error at gettimeofday()\");\n-  return jlong(time.tv_sec) * 1000 + jlong(time.tv_usec \/ 1000);\n-}\n-\n-void os::javaTimeSystemUTC(jlong &seconds, jlong &nanos) {\n-  timeval time;\n-  int status = gettimeofday(&time, NULL);\n-  assert(status != -1, \"aix error at gettimeofday()\");\n-  seconds = jlong(time.tv_sec);\n-  nanos = jlong(time.tv_usec) * 1000;\n-}\n-\n@@ -3293,1 +3278,0 @@\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -126,2 +126,0 @@\n-#else\n-int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;\n@@ -792,21 +790,0 @@\n-jlong os::javaTimeMillis() {\n-  timeval time;\n-  int status = gettimeofday(&time, NULL);\n-  assert(status != -1, \"bsd error\");\n-  return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec \/ 1000);\n-}\n-\n-void os::javaTimeSystemUTC(jlong &seconds, jlong &nanos) {\n-  timeval time;\n-  int status = gettimeofday(&time, NULL);\n-  assert(status != -1, \"bsd error\");\n-  seconds = jlong(time.tv_sec);\n-  nanos = jlong(time.tv_usec) * 1000;\n-}\n-\n-#ifndef __APPLE__\n-  #ifndef CLOCK_MONOTONIC\n-    #define CLOCK_MONOTONIC (1)\n-  #endif\n-#endif\n-\n@@ -819,7 +796,1 @@\n-  struct timespec res;\n-  struct timespec tp;\n-  if (::clock_getres(CLOCK_MONOTONIC, &res) == 0 &&\n-      ::clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {\n-    \/\/ yes, monotonic clock is supported\n-    _clock_gettime = ::clock_gettime;\n-  }\n+  \/\/ Nothing to do\n@@ -857,16 +828,5 @@\n-#else \/\/ __APPLE__\n-\n-jlong os::javaTimeNanos() {\n-  if (os::supports_monotonic_clock()) {\n-    struct timespec tp;\n-    int status = Bsd::_clock_gettime(CLOCK_MONOTONIC, &tp);\n-    assert(status == 0, \"gettime error\");\n-    jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);\n-    return result;\n-  } else {\n-    timeval time;\n-    int status = gettimeofday(&time, NULL);\n-    assert(status != -1, \"bsd error\");\n-    jlong usecs = jlong(time.tv_sec) * (1000 * 1000) + jlong(time.tv_usec);\n-    return 1000 * usecs;\n-  }\n+void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n+  info_ptr->max_value = ALL_64_BITS;\n+  info_ptr->may_skip_backward = false;      \/\/ not subject to resetting or drifting\n+  info_ptr->may_skip_forward = false;       \/\/ not subject to resetting or drifting\n+  info_ptr->kind = JVMTI_TIMER_ELAPSED;     \/\/ elapsed not CPU time\n@@ -877,19 +837,0 @@\n-void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n-  if (os::supports_monotonic_clock()) {\n-    info_ptr->max_value = ALL_64_BITS;\n-\n-    \/\/ CLOCK_MONOTONIC - amount of time since some arbitrary point in the past\n-    info_ptr->may_skip_backward = false;      \/\/ not subject to resetting or drifting\n-    info_ptr->may_skip_forward = false;       \/\/ not subject to resetting or drifting\n-  } else {\n-    \/\/ gettimeofday - based on time in seconds since the Epoch thus does not wrap\n-    info_ptr->max_value = ALL_64_BITS;\n-\n-    \/\/ gettimeofday is a real time clock so it skips\n-    info_ptr->may_skip_backward = true;\n-    info_ptr->may_skip_forward = true;\n-  }\n-\n-  info_ptr->kind = JVMTI_TIMER_ELAPSED;                \/\/ elapsed not CPU time\n-}\n-\n@@ -2815,1 +2756,0 @@\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":6,"deletions":66,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-#else\n-  static int (*_clock_gettime)(clockid_t, struct timespec *);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-#ifdef __APPLE__\n+  \/\/ macOS and other mainline BSD derivatives support this\n@@ -115,3 +115,0 @@\n-#else\n-  return Bsd::_clock_gettime != NULL;\n-#endif\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,3 +59,4 @@\n-    timeval current_time;\n-    if (gettimeofday(&current_time, NULL) != 0) {\n-      \/\/ Error getting current time\n+    struct timespec tp;\n+    int status = clock_gettime(CLOCK_REALTIME, &tp);\n+    assert(status == 0, \"clock_gettime error: %s\", os::strerror(errno));\n+    if (status != 0) {\n@@ -64,1 +65,1 @@\n-    *resultp = current_time.tv_sec * NANOS_PER_SEC + 1000L * current_time.tv_usec;\n+    *resultp = tp.tv_sec * NANOS_PER_SEC + tp.tv_nsec;\n","filename":"src\/hotspot\/os\/bsd\/os_perf_bsd.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1271,4 +1271,0 @@\n-#ifndef SUPPORTS_CLOCK_MONOTONIC\n-#error \"Build platform doesn't support clock_gettime and related functionality\"\n-#endif\n-\n@@ -1303,32 +1299,0 @@\n-jlong os::javaTimeMillis() {\n-  if (os::Posix::supports_clock_gettime()) {\n-    struct timespec ts;\n-    int status = os::Posix::clock_gettime(CLOCK_REALTIME, &ts);\n-    assert_status(status == 0, status, \"gettime error\");\n-    return jlong(ts.tv_sec) * MILLIUNITS +\n-           jlong(ts.tv_nsec) \/ NANOUNITS_PER_MILLIUNIT;\n-  } else {\n-    timeval time;\n-    int status = gettimeofday(&time, NULL);\n-    assert(status != -1, \"linux error\");\n-    return jlong(time.tv_sec) * MILLIUNITS  +\n-           jlong(time.tv_usec) \/ (MICROUNITS \/ MILLIUNITS);\n-  }\n-}\n-\n-void os::javaTimeSystemUTC(jlong &seconds, jlong &nanos) {\n-  if (os::Posix::supports_clock_gettime()) {\n-    struct timespec ts;\n-    int status = os::Posix::clock_gettime(CLOCK_REALTIME, &ts);\n-    assert_status(status == 0, status, \"gettime error\");\n-    seconds = jlong(ts.tv_sec);\n-    nanos = jlong(ts.tv_nsec);\n-  } else {\n-    timeval time;\n-    int status = gettimeofday(&time, NULL);\n-    assert(status != -1, \"linux error\");\n-    seconds = jlong(time.tv_sec);\n-    nanos = jlong(time.tv_usec) * (NANOUNITS \/ MICROUNITS);\n-  }\n-}\n-\n@@ -1355,1 +1319,1 @@\n-      os::Posix::clock_getres(clockid, &tp) == 0 && tp.tv_sec == 0) {\n+      clock_getres(clockid, &tp) == 0 && tp.tv_sec == 0) {\n@@ -1361,35 +1325,0 @@\n-jlong os::javaTimeNanos() {\n-  if (os::supports_monotonic_clock()) {\n-    struct timespec tp;\n-    int status = os::Posix::clock_gettime(CLOCK_MONOTONIC, &tp);\n-    assert(status == 0, \"gettime error\");\n-    jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);\n-    return result;\n-  } else {\n-    timeval time;\n-    int status = gettimeofday(&time, NULL);\n-    assert(status != -1, \"linux error\");\n-    jlong usecs = jlong(time.tv_sec) * (1000 * 1000) + jlong(time.tv_usec);\n-    return 1000 * usecs;\n-  }\n-}\n-\n-void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n-  if (os::supports_monotonic_clock()) {\n-    info_ptr->max_value = ALL_64_BITS;\n-\n-    \/\/ CLOCK_MONOTONIC - amount of time since some arbitrary point in the past\n-    info_ptr->may_skip_backward = false;      \/\/ not subject to resetting or drifting\n-    info_ptr->may_skip_forward = false;       \/\/ not subject to resetting or drifting\n-  } else {\n-    \/\/ gettimeofday - based on time in seconds since the Epoch thus does not wrap\n-    info_ptr->max_value = ALL_64_BITS;\n-\n-    \/\/ gettimeofday is a real time clock so it skips\n-    info_ptr->may_skip_backward = true;\n-    info_ptr->may_skip_forward = true;\n-  }\n-\n-  info_ptr->kind = JVMTI_TIMER_ELAPSED;                \/\/ elapsed not CPU time\n-}\n-\n@@ -4347,3 +4276,2 @@\n-  int rc = os::Posix::clock_gettime(clockid, &tp);\n-  assert(rc == 0, \"clock_gettime is expected to return 0 code\");\n-\n+  int status = clock_gettime(clockid, &tp);\n+  assert(status == 0, \"clock_gettime error: %s\", os::strerror(errno));\n@@ -4457,6 +4385,0 @@\n-\n-  \/\/ Always warn if no monotonic clock available\n-  if (!os::Posix::supports_monotonic_clock()) {\n-    warning(\"No monotonic clock was available - timed services may \"    \\\n-            \"be adversely affected if the time-of-day clock changes\");\n-  }\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":81,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvmtifiles\/jvmti.h\"\n@@ -1118,17 +1119,0 @@\n-\/\/ Not all POSIX types and API's are available on all notionally \"posix\"\n-\/\/ platforms. If we have build-time support then we will check for actual\n-\/\/ runtime support via dlopen\/dlsym lookup. This allows for running on an\n-\/\/ older OS version compared to the build platform. But if there is no\n-\/\/ build time support then there cannot be any runtime support as we do not\n-\/\/ know what the runtime types would be (for example clockid_t might be an\n-\/\/ int or int64_t).\n-\/\/\n-#ifdef SUPPORTS_CLOCK_MONOTONIC\n-\n-\/\/ This means we have clockid_t, clock_gettime et al and CLOCK_MONOTONIC\n-\n-int (*os::Posix::_clock_gettime)(clockid_t, struct timespec *) = NULL;\n-int (*os::Posix::_clock_getres)(clockid_t, struct timespec *) = NULL;\n-\n-bool os::Posix::_supports_monotonic_clock = false;\n-\n@@ -1146,38 +1130,1 @@\n-  \/\/ 1. Check for CLOCK_MONOTONIC support.\n-\n-  void* handle = NULL;\n-\n-  \/\/ For older linux we need librt, for other OS we can find\n-  \/\/ this function in regular libc.\n-#ifdef NEEDS_LIBRT\n-  \/\/ We do dlopen's in this particular order due to bug in linux\n-  \/\/ dynamic loader (see 6348968) leading to crash on exit.\n-  handle = dlopen(\"librt.so.1\", RTLD_LAZY);\n-  if (handle == NULL) {\n-    handle = dlopen(\"librt.so\", RTLD_LAZY);\n-  }\n-#endif\n-\n-  if (handle == NULL) {\n-    handle = RTLD_DEFAULT;\n-  }\n-\n-  int (*clock_getres_func)(clockid_t, struct timespec*) =\n-    (int(*)(clockid_t, struct timespec*))dlsym(handle, \"clock_getres\");\n-  int (*clock_gettime_func)(clockid_t, struct timespec*) =\n-    (int(*)(clockid_t, struct timespec*))dlsym(handle, \"clock_gettime\");\n-  if (clock_getres_func != NULL && clock_gettime_func != NULL) {\n-    _clock_gettime = clock_gettime_func;\n-    _clock_getres = clock_getres_func;\n-    \/\/ We assume that if both clock_gettime and clock_getres support\n-    \/\/ CLOCK_MONOTONIC then the OS provides true high-res monotonic clock.\n-    struct timespec res;\n-    struct timespec tp;\n-    if (clock_getres_func(CLOCK_MONOTONIC, &res) == 0 &&\n-        clock_gettime_func(CLOCK_MONOTONIC, &tp) == 0) {\n-      \/\/ Yes, monotonic clock is supported.\n-      _supports_monotonic_clock = true;\n-    }\n-  }\n-\n-  \/\/ 2. Check for pthread_condattr_setclock support.\n+  \/\/ Check for pthread_condattr_setclock support.\n@@ -1198,1 +1145,1 @@\n-  if (_pthread_condattr_setclock != NULL && _clock_gettime != NULL) {\n+  if (_pthread_condattr_setclock != NULL) {\n@@ -1214,2 +1161,1 @@\n-  log_info(os)(\"Use of CLOCK_MONOTONIC is%s supported\",\n-               (_clock_gettime != NULL ? \"\" : \" not\"));\n+  log_info(os)(\"Use of CLOCK_MONOTONIC is supported\");\n@@ -1222,14 +1168,0 @@\n-#else \/\/ !SUPPORTS_CLOCK_MONOTONIC\n-\n-void os::Posix::init(void) {\n-  pthread_init_common();\n-}\n-\n-void os::Posix::init_2(void) {\n-  log_info(os)(\"Use of CLOCK_MONOTONIC is not supported\");\n-  log_info(os)(\"Use of pthread_condattr_setclock is not supported\");\n-  log_info(os)(\"Relative timed-wait using pthread_cond_timedwait is associated with the default clock\");\n-}\n-\n-#endif \/\/ SUPPORTS_CLOCK_MONOTONIC\n-\n@@ -1287,1 +1219,0 @@\n-\/\/ This is only used with gettimeofday, when clock_gettime is not available.\n@@ -1322,2 +1253,0 @@\n-#ifdef SUPPORTS_CLOCK_MONOTONIC\n-\n@@ -1325,15 +1254,3 @@\n-  \/\/ need to ensure we have a runtime check for clock_gettime support\n-  if (!isAbsolute && os::Posix::supports_monotonic_clock()) {\n-    if (!_use_clock_monotonic_condattr || isRealtime) {\n-      clock = CLOCK_REALTIME;\n-    }\n-    struct timespec now;\n-    int status = os::Posix::clock_gettime(clock, &now);\n-    assert_status(status == 0, status, \"clock_gettime\");\n-    calc_rel_time(abstime, timeout, now.tv_sec, now.tv_nsec, NANOUNITS);\n-    DEBUG_ONLY(max_secs += now.tv_sec;)\n-  } else {\n-\n-#else\n-\n-  { \/\/ Match the block scope.\n+  if (isAbsolute || (!_use_clock_monotonic_condattr || isRealtime)) {\n+    clock = CLOCK_REALTIME;\n+  }\n@@ -1341,1 +1258,3 @@\n-#endif \/\/ SUPPORTS_CLOCK_MONOTONIC\n+  struct timespec now;\n+  int status = clock_gettime(clock, &now);\n+  assert(status == 0, \"clock_gettime error: %s\", os::strerror(errno));\n@@ -1343,10 +1262,4 @@\n-    \/\/ Time-of-day clock is all we can reliably use.\n-    struct timeval now;\n-    int status = gettimeofday(&now, NULL);\n-    assert_status(status == 0, errno, \"gettimeofday\");\n-    if (isAbsolute) {\n-      unpack_abs_time(abstime, timeout, now.tv_sec);\n-    } else {\n-      calc_rel_time(abstime, timeout, now.tv_sec, now.tv_usec, MICROUNITS);\n-    }\n-    DEBUG_ONLY(max_secs += now.tv_sec;)\n+  if (!isAbsolute) {\n+    calc_rel_time(abstime, timeout, now.tv_sec, now.tv_nsec, NANOUNITS);\n+  } else {\n+    unpack_abs_time(abstime, timeout, now.tv_sec);\n@@ -1354,0 +1267,1 @@\n+  DEBUG_ONLY(max_secs += now.tv_sec;)\n@@ -1369,0 +1283,42 @@\n+\/\/ Common (partly) shared time functions\n+\n+jlong os::javaTimeMillis() {\n+  struct timespec ts;\n+  int status = clock_gettime(CLOCK_REALTIME, &ts);\n+  assert(status == 0, \"clock_gettime error: %s\", os::strerror(errno));\n+  return jlong(ts.tv_sec) * MILLIUNITS +\n+    jlong(ts.tv_nsec) \/ NANOUNITS_PER_MILLIUNIT;\n+}\n+\n+void os::javaTimeSystemUTC(jlong &seconds, jlong &nanos) {\n+  struct timespec ts;\n+  int status = clock_gettime(CLOCK_REALTIME, &ts);\n+  assert(status == 0, \"clock_gettime error: %s\", os::strerror(errno));\n+  seconds = jlong(ts.tv_sec);\n+  nanos = jlong(ts.tv_nsec);\n+}\n+\n+\/\/ macOS and AIX have platform specific implementations for javaTimeNanos()\n+#if !defined(__APPLE__) && !defined(AIX)\n+\n+jlong os::javaTimeNanos() {\n+  struct timespec tp;\n+  int status = clock_gettime(CLOCK_MONOTONIC, &tp);\n+  assert(status == 0, \"clock_gettime error: %s\", os::strerror(errno));\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec);\n+  return result;\n+}\n+\n+\/\/ for timer info max values which include all bits\n+#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n+\n+void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n+  \/\/ CLOCK_MONOTONIC - amount of time since some arbitrary point in the past\n+  info_ptr->max_value = ALL_64_BITS;\n+  info_ptr->may_skip_backward = false;      \/\/ not subject to resetting or drifting\n+  info_ptr->may_skip_forward = false;       \/\/ not subject to resetting or drifting\n+  info_ptr->kind = JVMTI_TIMER_ELAPSED;     \/\/ elapsed not CPU time\n+}\n+\n+#endif \/\/ ! APPLE && !AIX\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":57,"deletions":101,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -95,8 +95,0 @@\n-#ifdef SUPPORTS_CLOCK_MONOTONIC\n-\n-private:\n-  static bool _supports_monotonic_clock;\n-  \/\/ These need to be members so we can access them from inline functions\n-  static int (*_clock_gettime)(clockid_t, struct timespec *);\n-  static int (*_clock_getres)(clockid_t, struct timespec *);\n-public:\n@@ -104,7 +96,0 @@\n-  static bool supports_clock_gettime();\n-  static int clock_gettime(clockid_t clock_id, struct timespec *tp);\n-  static int clock_getres(clockid_t clock_id, struct timespec *tp);\n-#else\n-  static bool supports_monotonic_clock() { return false; }\n-  static bool supports_clock_gettime() { return false; }\n-#endif\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-#ifdef SUPPORTS_CLOCK_MONOTONIC\n-\n@@ -54,13 +52,1 @@\n-  return _supports_monotonic_clock;\n-}\n-\n-inline bool os::Posix::supports_clock_gettime() {\n-  return _clock_gettime != NULL;\n-}\n-\n-inline int os::Posix::clock_gettime(clockid_t clock_id, struct timespec *tp) {\n-  return _clock_gettime != NULL ? _clock_gettime(clock_id, tp) : -1;\n-}\n-\n-inline int os::Posix::clock_getres(clockid_t clock_id, struct timespec *tp) {\n-  return _clock_getres != NULL ? _clock_getres(clock_id, tp) : -1;\n+  return true;\n@@ -69,2 +55,0 @@\n-#endif \/\/ SUPPORTS_CLOCK_MONOTONIC\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.inline.hpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"}]}