{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import jdk.internal.event.DeserializationEvent;\n@@ -1326,1 +1327,2 @@\n-     * Invoke the serialization filter if non-null.\n+     * Invokes the serialization filter if non-null.\n+     *\n@@ -1329,0 +1331,2 @@\n+     * Logs and\/or commits a {@code DeserializationEvent}, if configured.\n+     *\n@@ -1336,0 +1340,5 @@\n+        \/\/ Info about the stream is not available if overridden by subclass, return 0\n+        long bytesRead = (bin == null) ? 0 : bin.getBytesRead();\n+        RuntimeException ex = null;\n+        ObjectInputFilter.Status status = null;\n+\n@@ -1337,4 +1346,0 @@\n-            RuntimeException ex = null;\n-            ObjectInputFilter.Status status;\n-            \/\/ Info about the stream is not available if overridden by subclass, return 0\n-            long bytesRead = (bin == null) ? 0 : bin.getBytesRead();\n@@ -1358,6 +1363,17 @@\n-            if (status == null ||\n-                    status == ObjectInputFilter.Status.REJECTED) {\n-                InvalidClassException ice = new InvalidClassException(\"filter status: \" + status);\n-                ice.initCause(ex);\n-                throw ice;\n-            }\n+        }\n+        DeserializationEvent event = new DeserializationEvent();\n+        if (event.shouldCommit()) {\n+            event.filterConfigured = serialFilter != null;\n+            event.filterStatus = status != null ? status.name() : null;\n+            event.type = clazz;\n+            event.arrayLength = arrayLength;\n+            event.objectReferences = totalObjectRefs;\n+            event.depth = depth;\n+            event.bytesRead = bytesRead;\n+            event.exceptionMessage = ex != null ? ex.toString() : null;\n+            event.commit();\n+        }\n+        if (serialFilter != null && (status == null || status == ObjectInputFilter.Status.REJECTED)) {\n+            InvalidClassException ice = new InvalidClassException(\"filter status: \" + status);\n+            ice.initCause(ex);\n+            throw ice;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.event;\n+\n+\/**\n+ * Event details relating to deserialization.\n+ *\/\n+\n+public final class DeserializationEvent extends Event {\n+    public boolean filterConfigured;\n+    public String filterStatus;\n+    public Class<?> type;\n+    public int arrayLength;\n+    public long objectReferences;\n+    public long depth;\n+    public long bytesRead;\n+    public String exceptionMessage;\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/DeserializationEvent.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.MirrorEvent;\n+\n+@Category({\"Java Development Kit\", \"Serialization\"})\n+@Label(\"Deserialization\")\n+@Name(\"jdk.Deserialization\")\n+@Description(\"Results of deserialiation and ObjectInputFilter checks\")\n+@MirrorEvent(className = \"jdk.internal.event.DeserializationEvent\")\n+public final class DeserializationEvent extends AbstractJDKEvent {\n+\n+    @Label(\"Filter configured\")\n+    public boolean filterConfigured;\n+\n+    @Label(\"Filter Status\")\n+    public String filterStatus;\n+\n+    @Label (\"Type\")\n+    public Class<?> type;\n+\n+    @Label (\"Array Length\")\n+    public int arrayLength;\n+\n+    @Label (\"Object References\")\n+    public long objectReferences;\n+\n+    @Label (\"Depth\")\n+    public long depth;\n+\n+    @Label (\"Bytes Read\")\n+    public long bytesRead;\n+\n+    @Label (\"Exception Message\")\n+    public String exceptionMessage;\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/DeserializationEvent.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.jfr.events.DeserializationEvent;\n@@ -58,0 +59,2 @@\n+        DeserializationEvent.class,\n+        ProcessStartEvent.class,\n@@ -61,2 +64,1 @@\n-        X509ValidationEvent.class,\n-        ProcessStartEvent.class\n+        X509ValidationEvent.class\n@@ -76,0 +78,2 @@\n+        jdk.internal.event.DeserializationEvent.class,\n+        jdk.internal.event.ProcessStartEvent.class,\n@@ -80,1 +84,1 @@\n-        jdk.internal.event.ProcessStartEvent.class,\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -668,0 +668,5 @@\n+    <event name=\"jdk.Deserialization\">\n+       <setting name=\"enabled\">false<\/setting>\n+       <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -668,0 +668,5 @@\n+    <event name=\"jdk.Deserialization\">\n+       <setting name=\"enabled\">false<\/setting>\n+       <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,12 @@\n+\n+\/* @test\n+ * @bug 8261160\n+ * @summary Add a deserialization JFR event\n+ * @build GlobalFilterTest SerialFilterTest\n+ * @requires vm.hasJFR\n+ * @run testng\/othervm\/policy=security.policy\n+ *        -XX:StartFlightRecording=name=DeserializationEvent,dumponexit=true\n+ *        -Djava.security.properties=${test.src}\/java.security-extra1\n+ *        -Djava.security.debug=properties GlobalFilterTest\n+ *\/\n+\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/GlobalFilterTest.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,414 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.io;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InvalidClassException;\n+import java.io.ObjectInputFilter.Status;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.serial.SerialObjectBuilder;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8261160\n+ * @summary Add a deserialization JFR event\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run testng\/othervm jdk.jfr.event.io.TestDeserializationEvent\n+ *\/\n+public class TestDeserializationEvent {\n+\n+    public record R() implements Serializable { }\n+\n+    @DataProvider(name = \"scenarios\")\n+    public Object[][] scenarios() throws Exception {\n+        byte[] ba1 = serialize(new R());\n+        byte[] ba2 = serialize(new int[] { 56, 67, 58, 59, 60 });\n+        byte[] ba3 = serialize(new R[] { new R(), new R() });\n+        byte[] ba4 = serialize(new char[][] { new char[] {'a', 'b'}, new char[] {'c'} });\n+\n+        \/\/ data provider columns- 1:id, 2:deserialize-operation, 3:expected-event-checkers\n+        return new Object[][] {\n+            {   1,  \/\/ single stream object, R\n+                (Runnable)() -> deserialize(ba1),\n+                List.of(\n+                    Set.of(\n+                        assertFilterStatus(null),\n+                        assertType(R.class),\n+                        assertArrayLength(-1),\n+                        assertObjectReferences(1),\n+                        assertDepth(1),\n+                        assertHasBytesRead(),\n+                        assertExceptionMessage(null))) },\n+            {   2,  \/\/ primitive int array\n+                (Runnable)() -> deserialize(ba2),\n+                List.of(\n+                    Set.of(  \/\/ TC_CLASS, for array class int[]\n+                        assertType(int[].class),\n+                        assertArrayLength(-1)),\n+                    Set.of(  \/\/ TC_ARRAY, actual array\n+                        assertType(int[].class),\n+                        assertArrayLength(5))) },\n+            {   3,  \/\/ reference array, R\n+                (Runnable)() -> deserialize(ba3),\n+                List.of(\n+                    Set.of(  \/\/ TC_CLASS, for array class R[]\n+                        assertType(R[].class),\n+                        assertArrayLength(-1)),\n+                    Set.of(  \/\/ TC_ARRAY, actual array\n+                        assertType(R[].class),\n+                        assertArrayLength(2)),\n+                    Set.of(  \/\/ TC_CLASS, for R\n+                        assertType(R.class),\n+                        assertArrayLength(-1)),\n+                    Set.of(  \/\/ TC_REFERENCE, for TC_CLASS relating second stream obj\n+                        assertType(null),\n+                        assertArrayLength(-1))) },\n+            {  4,  \/\/ multi-dimensional prim char array\n+               (Runnable)() -> deserialize(ba4),\n+               List.of(\n+                    Set.of(  \/\/ TC_CLASS, for array class char[][]\n+                        assertType(char[][].class),\n+                        assertArrayLength(-1),\n+                        assertDepth(1)),\n+                    Set.of(  \/\/ TC_ARRAY, actual char[][] array\n+                        assertType(char[][].class),\n+                        assertArrayLength(2),\n+                        assertDepth(1)),\n+                    Set.of(  \/\/ TC_CLASS, for array class char[]\n+                        assertType(char[].class),\n+                        assertArrayLength(-1),\n+                        assertDepth(2)),\n+                    Set.of(  \/\/ TC_ARRAY, first char[] array\n+                        assertType(char[].class),\n+                        assertArrayLength(2),\n+                        assertDepth(2)),\n+                    Set.of(  \/\/ TC_REFERENCE, for TC_CLASS relating to second stream array\n+                        assertType(null),\n+                        assertArrayLength(-1),\n+                        assertDepth(2)),\n+                    Set.of(  \/\/ TC_ARRAY, second char[] array\n+                        assertType(char[].class),\n+                        assertArrayLength(1),\n+                        assertDepth(2))) }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"scenarios\")\n+    public void test(int id,\n+                     Runnable thunk,\n+                     List<Set<Consumer<RecordedEvent>>> expectedValuesChecker)\n+       throws IOException\n+    {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            thunk.run();\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), expectedValuesChecker.size());\n+            assertEventList(events, expectedValuesChecker);\n+        }\n+    }\n+\n+    static final Class<InvalidClassException> ICE = InvalidClassException.class;\n+\n+    @DataProvider(name = \"filterDisallowedValues\")\n+    public Object[][] filterDisallowedValues() {\n+        return new Object[][] {\n+                { Status.REJECTED,   \"REJECTED\" },\n+                { null,              null       }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"filterDisallowedValues\")\n+    public void testFilterDisallow(Status filterStatus,\n+                                   String expectedValue)\n+        throws Exception\n+    {\n+        try (Recording recording = new Recording();\n+             var bais = new ByteArrayInputStream(serialize(new R()));\n+             var ois = new ObjectInputStream(bais)) {\n+            ois.setObjectInputFilter(fv -> filterStatus);\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            assertThrows(ICE, () -> ois.readObject());\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), 1);\n+            assertEquals(events.get(0).getEventType().getName(), \"jdk.Deserialization\");\n+            assertFilterConfigured(true).accept(events.get(0));\n+            assertFilterStatus(expectedValue).accept(events.get(0));\n+        }\n+    }\n+\n+    @DataProvider(name = \"filterAllowedValues\")\n+    public Object[][] filterAllowedValues() {\n+        return new Object[][] {\n+                { Status.ALLOWED,   \"ALLOWED\"   },\n+                { Status.UNDECIDED, \"UNDECIDED\" },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"filterAllowedValues\")\n+    public void testFilterAllowed(Status filterStatus,\n+                                  String expectedValue) throws Exception {\n+        try (Recording recording = new Recording();\n+             var bais = new ByteArrayInputStream(serialize(new R()));\n+             var ois = new ObjectInputStream(bais)) {\n+            ois.setObjectInputFilter(fv -> filterStatus);\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            ois.readObject();\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), 1);\n+            assertEquals(events.get(0).getEventType().getName(), \"jdk.Deserialization\");\n+            assertFilterConfigured(true).accept(events.get(0));\n+            assertFilterStatus(expectedValue).accept(events.get(0));\n+        }\n+    }\n+\n+    static class XYZException extends RuntimeException { }\n+\n+    @Test\n+    public void testException() throws Exception {\n+        try (Recording recording = new Recording();\n+             var bais = new ByteArrayInputStream(serialize(new R()));\n+             var ois = new ObjectInputStream(bais)) {\n+            ois.setObjectInputFilter(fv -> { throw new XYZException(); });\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            InvalidClassException ice = expectThrows(ICE, () -> ois.readObject());\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), 1);\n+            assertEquals(events.get(0).getEventType().getName(), \"jdk.Deserialization\");\n+            assertFilterConfigured(true).accept(events.get(0));\n+            assertExceptionMessage(\"jdk.jfr.event.io.TestDeserializationEvent$XYZException\").accept(events.get(0));\n+        }\n+    }\n+\n+    static void assertEventList(List<RecordedEvent> actualEvents,\n+                                List<Set<Consumer<RecordedEvent>>> expectedValuesChecker) {\n+        int found = 0;\n+        for (RecordedEvent recordedEvent : actualEvents) {\n+            assertEquals(recordedEvent.getEventType().getName(), \"jdk.Deserialization\");\n+            out.println(\"Checking recorded event:\" + recordedEvent);\n+            Set<Consumer<RecordedEvent>> checkers = expectedValuesChecker.get(found);\n+            for (Consumer<RecordedEvent> checker : checkers) {\n+                out.println(\"  checking:\" + checker);\n+                checker.accept(recordedEvent);\n+            }\n+            assertFilterConfigured(false).accept(recordedEvent); \/\/ no filter expected\n+            assertExceptionMessage(null).accept(recordedEvent);  \/\/ no exception expected\n+            found++;\n+        }\n+        assertEquals(found, expectedValuesChecker.size());\n+    }\n+\n+    static Consumer<RecordedEvent> assertFilterConfigured(boolean expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"filterConfigured\"));\n+                assertEquals((boolean)recordedEvent.getValue(\"filterConfigured\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertFilterConfigured, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertFilterStatus(String expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"filterStatus\"));\n+                assertEquals(recordedEvent.getValue(\"filterStatus\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertFilterStatus, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertType(Class expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"type\"));\n+                if (expectedValue == null && recordedEvent.getValue(\"type\") == null)\n+                    return;\n+\n+                if (recordedEvent.getValue(\"type\") instanceof RecordedClass recordedClass)\n+                    assertEquals(recordedClass.getName(), expectedValue.getName());\n+                else\n+                    fail(\"Expected RecordedClass, got:\" + recordedEvent.getValue(\"type\") .getClass());\n+            }\n+            @Override public String toString() {\n+                return \"assertType, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertArrayLength(int expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"arrayLength\"));\n+                assertEquals((int)recordedEvent.getValue(\"arrayLength\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertArrayLength, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertObjectReferences(long expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"objectReferences\"));\n+                assertEquals((long)recordedEvent.getValue(\"objectReferences\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertObjectReferences, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertDepth(long expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"depth\"));\n+                assertEquals((long)recordedEvent.getValue(\"depth\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertDepth, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertHasBytesRead() {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"bytesRead\"));\n+            }\n+            @Override public String toString() {\n+                return \"assertHasBytesRead,\";\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertBytesRead(long expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertHasBytesRead().accept(recordedEvent);\n+                assertEquals((long)recordedEvent.getValue(\"bytesRead\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertBytesRead, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertExceptionMessage(String expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"exceptionMessage\"));\n+                assertEquals(recordedEvent.getValue(\"exceptionMessage\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertExceptionMessage, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static <T> byte[] serialize(T obj) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(obj);\n+        oos.close();\n+        return baos.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T deserialize(byte[] streamBytes) {\n+        try {\n+            ByteArrayInputStream bais = new ByteArrayInputStream(streamBytes);\n+            ObjectInputStream ois  = new ObjectInputStream(bais);\n+            return (T) ois.readObject();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ ---\n+    static volatile boolean initializedFoo; \/\/ false\n+    \/\/ Do not inadvertently initialize this class, Foo.\n+    static class Foo implements Serializable {\n+        static { TestDeserializationEvent.initializedFoo = true; }\n+    }\n+\n+    \/**\n+     * Checks that the creation and recording of the Deserialization event does\n+     * not inadvertently trigger initialization of the class of the stream\n+     * object, when deserialization is rejected by the filter.\n+     *\/\n+    @Test\n+    public void testRejectedClassNotInitialized() throws Exception {\n+        byte[] bytes = SerialObjectBuilder.newBuilder(\"Foo\").build();\n+        assertFalse(initializedFoo);  \/\/ sanity\n+\n+        try (Recording recording = new Recording();\n+             var bais = new ByteArrayInputStream(bytes);\n+             var ois = new ObjectInputStream(bais)) {\n+            ois.setObjectInputFilter(fv -> Status.REJECTED);\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            assertThrows(ICE, () -> ois.readObject());\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), 1);\n+            assertEquals(events.get(0).getEventType().getName(), \"jdk.Deserialization\");\n+            assertFilterConfigured(true).accept(events.get(0));\n+            assertFilterStatus(\"REJECTED\").accept(events.get(0));\n+            assertFalse(initializedFoo);\n+            assertType(Foo.class);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestDeserializationEvent.java","additions":414,"deletions":0,"binary":false,"changes":414,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,0 +181,1 @@\n+        insertSetting(doc, EventNames.Deserialization, \"threshold\", \"0 ns\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestDefaultConfigurations.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-        Asserts.assertFalse(lowerCased.contains(\"config\") && !lowerCased.contains(\"configuration\"), \"Use 'configuration' instead of 'config' in name\");\n+        Asserts.assertFalse(lowerCased.contains(\"config\") && !(lowerCased.contains(\"configuration\") || lowerCased.contains(\"filterconfigured\")), \"Use 'configuration' instead of 'config' in name\");\n@@ -217,1 +217,1 @@\n-        Asserts.assertFalse(lowerCased.contains(\"stat\") && !(lowerCased.contains(\"state\") ||lowerCased.contains(\"statistic\")) , \"Use 'statistics' instead of 'stat' in name\");\n+        Asserts.assertFalse(lowerCased.contains(\"stat\") && !(lowerCased.contains(\"state\") ||lowerCased.contains(\"statistic\") ||lowerCased.contains(\"filterstatus\")) , \"Use 'statistics' instead of 'stat' in name\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestEventMetadata.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,0 +209,1 @@\n+        settingValues.put(EventNames.Deserialization + \"#threshold\", \"0 ns\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestActiveSettingEvent.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -201,0 +201,2 @@\n+    public final static String Deserialization = PREFIX + \"Deserialization\";\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}