{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3206,0 +3206,189 @@\n+int C2_MacroAssembler::arrays_hashcode_elsize(BasicType eltype) {\n+  switch (eltype) {\n+  case T_BOOLEAN: return sizeof(jboolean);\n+  case T_BYTE:  return sizeof(jbyte);\n+  case T_SHORT: return sizeof(jshort);\n+  case T_CHAR:  return sizeof(jchar);\n+  case T_INT:   return sizeof(jint);\n+  default:\n+    ShouldNotReachHere();\n+    return -1;\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elload(Register dst, Address src, BasicType eltype) {\n+  switch (eltype) {\n+  \/\/ T_BOOLEAN used as surrogate for unsigned byte\n+  case T_BOOLEAN: movzbl(dst, src);   break;\n+  case T_BYTE:    movsbl(dst, src);   break;\n+  case T_SHORT:   movswl(dst, src);   break;\n+  case T_CHAR:    movzwl(dst, src);   break;\n+  case T_INT:     movl(dst, src);     break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype) {\n+  const int vlen = Assembler::AVX_256bit;\n+  switch (eltype) {\n+  case T_BOOLEAN: vector_unsigned_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_BYTE:      vector_signed_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_SHORT:     vector_signed_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n+  case T_CHAR:    vector_unsigned_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n+  case T_INT:\n+    \/\/ do nothing\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode(Register ary1, Register cnt1, Register result,\n+                                        Register index, Register tmp2, Register tmp3, XMMRegister vnext,\n+                                        XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                                        XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                                        XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                                        BasicType eltype) {\n+  ShortBranchVerifier sbv(this);\n+  assert(UseAVX >= 2, \"AVX2 intrinsics are required\");\n+  assert_different_registers(ary1, cnt1, result, index, tmp2, tmp3);\n+  assert_different_registers(vnext, vcoef0, vcoef1, vcoef2, vcoef3, vresult0, vresult1, vresult2, vresult3, vtmp0, vtmp1, vtmp2, vtmp3);\n+\n+  Label SHORT_UNROLLED_BEGIN, SHORT_UNROLLED_LOOP_BEGIN,\n+        SHORT_UNROLLED_LOOP_EXIT,\n+        UNROLLED_SCALAR_LOOP_BEGIN, UNROLLED_SCALAR_SKIP, UNROLLED_SCALAR_RESUME,\n+        UNROLLED_VECTOR_LOOP_BEGIN,\n+        END;\n+  switch (eltype) {\n+  case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode(unsigned byte) {\"); break;\n+  case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode(char) {\");          break;\n+  case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode(byte) {\");          break;\n+  case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode(short) {\");         break;\n+  case T_INT:     BLOCK_COMMENT(\"arrays_hashcode(int) {\");           break;\n+  default:        BLOCK_COMMENT(\"arrays_hashcode {\");                break;\n+  }\n+\n+  \/\/ For \"renaming\" for readibility of the code\n+  XMMRegister vcoef[] = { vcoef0, vcoef1, vcoef2, vcoef3 },\n+              vresult[] = { vresult0, vresult1, vresult2, vresult3 },\n+              vtmp[] = { vtmp0, vtmp1, vtmp2, vtmp3 };\n+\n+  const int elsize = arrays_hashcode_elsize(eltype);\n+\n+  \/*\n+    if (cnt1 >= 2) {\n+      if (cnt1 >= 32) {\n+        UNROLLED VECTOR LOOP\n+      }\n+      UNROLLED SCALAR LOOP\n+    }\n+    SINGLE SCALAR\n+   *\/\n+\n+  cmpl(cnt1, 32);\n+  jcc(Assembler::less, SHORT_UNROLLED_BEGIN);\n+\n+  \/\/ cnt1 >= 32 && generate_vectorized_loop\n+  xorl(index, index);\n+\n+  \/\/ vresult = IntVector.zero(I256);\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpxor(vresult[idx], vresult[idx]);\n+  }\n+  \/\/ vnext = IntVector.broadcast(I256, power_of_31_backwards[0]);\n+  Register bound = tmp2;\n+  Register next = tmp3;\n+  lea(tmp2, ExternalAddress(StubRoutines::x86::arrays_hashcode_powers_of_31() + (0 * sizeof(jint))));\n+  movl(next, Address(tmp2, 0));\n+  movdl(vnext, next);\n+  vpbroadcastd(vnext, vnext, Assembler::AVX_256bit);\n+\n+  \/\/ index = 0;\n+  \/\/ bound = cnt1 & ~(32 - 1);\n+  movl(bound, cnt1);\n+  andl(bound, ~(32 - 1));\n+  \/\/ for (; index < bound; index += 32) {\n+  bind(UNROLLED_VECTOR_LOOP_BEGIN);\n+  \/\/ result *= next;\n+  imull(result, next);\n+  \/\/ loop fission to upfront the cost of fetching from memory, OOO execution\n+  \/\/ can then hopefully do a better job of prefetching\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvload(vtmp[idx], Address(ary1, index, Address::times(elsize), 8 * idx * elsize), eltype);\n+  }\n+  \/\/ vresult = vresult * vnext + ary1[index+8*idx:index+8*idx+7];\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpmulld(vresult[idx], vresult[idx], vnext, Assembler::AVX_256bit);\n+    arrays_hashcode_elvcast(vtmp[idx], eltype);\n+    vpaddd(vresult[idx], vresult[idx], vtmp[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ index += 32;\n+  addl(index, 32);\n+  \/\/ index < bound;\n+  cmpl(index, bound);\n+  jcc(Assembler::less, UNROLLED_VECTOR_LOOP_BEGIN);\n+  \/\/ }\n+\n+  lea(ary1, Address(ary1, bound, Address::times(elsize)));\n+  subl(cnt1, bound);\n+  \/\/ release bound\n+\n+  \/\/ vresult *= IntVector.fromArray(I256, power_of_31_backwards, 1);\n+  for (int idx = 0; idx < 4; idx++) {\n+    lea(tmp2, ExternalAddress(StubRoutines::x86::arrays_hashcode_powers_of_31() + ((8 * idx + 1) * sizeof(jint))));\n+    arrays_hashcode_elvload(vcoef[idx], Address(tmp2, 0), T_INT);\n+    vpmulld(vresult[idx], vresult[idx], vcoef[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ result += vresult.reduceLanes(ADD);\n+  for (int idx = 0; idx < 4; idx++) {\n+    reduceI(Op_AddReductionVI, 256\/(sizeof(jint) * 8), result, result, vresult[idx], vtmp[(idx * 2 + 0) % 4], vtmp[(idx * 2 + 1) % 4]);\n+  }\n+\n+  \/\/ } else if (cnt1 < 32) {\n+\n+  bind(SHORT_UNROLLED_BEGIN);\n+  \/\/ int i = 1;\n+  movl(index, 1);\n+  cmpl(index, cnt1);\n+  jcc(Assembler::greaterEqual, SHORT_UNROLLED_LOOP_EXIT);\n+\n+  \/\/ for (; i < cnt1 ; i += 2) {\n+  bind(SHORT_UNROLLED_LOOP_BEGIN);\n+  movl(tmp3, 961);\n+  imull(result, tmp3);\n+  arrays_hashcode_elload(tmp2, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n+  movl(tmp3, tmp2);\n+  shll(tmp3, 5);\n+  subl(tmp3, tmp2);\n+  addl(result, tmp3);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize)), eltype);\n+  addl(result, tmp3);\n+  addl(index, 2);\n+  cmpl(index, cnt1);\n+  jccb(Assembler::less, SHORT_UNROLLED_LOOP_BEGIN);\n+\n+  \/\/ }\n+  \/\/ if (i >= cnt1) {\n+  bind(SHORT_UNROLLED_LOOP_EXIT);\n+  jccb(Assembler::greater, END);\n+  movl(tmp2, result);\n+  shll(result, 5);\n+  subl(result, tmp2);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n+  addl(result, tmp3);\n+  \/\/ }\n+  bind(END);\n+\n+  BLOCK_COMMENT(\"} \/\/ arrays_hashcode\");\n+\n+} \/\/ arrays_hashcode\n+\n@@ -4688,0 +4877,27 @@\n+void C2_MacroAssembler::vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                                           BasicType from_elem_bt, BasicType to_elem_bt) {\n+  switch (from_elem_bt) {\n+    case T_BYTE:\n+      switch (to_elem_bt) {\n+        case T_SHORT: vpmovsxbw(dst, src, vlen_enc); break;\n+        case T_INT:   vpmovsxbd(dst, src, vlen_enc); break;\n+        case T_LONG:  vpmovsxbq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_SHORT:\n+      switch (to_elem_bt) {\n+        case T_INT:  vpmovsxwd(dst, src, vlen_enc); break;\n+        case T_LONG: vpmovsxwq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_INT:\n+      assert(to_elem_bt == T_LONG, \"\");\n+      vpmovsxdq(dst, src, vlen_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":217,"deletions":1,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,13 @@\n+  void arrays_hashcode(Register str1, Register cnt1, Register result,\n+                       Register tmp1, Register tmp2, Register tmp3, XMMRegister vnext,\n+                       XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                       XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                       XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                       BasicType eltype);\n+\n+  \/\/ helper functions for arrays_hashcode\n+  int arrays_hashcode_elsize(BasicType eltype);\n+  void arrays_hashcode_elload(Register dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype);\n+  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype);\n@@ -312,0 +325,3 @@\n+\n+  void vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                          BasicType from_elem_bt, BasicType to_elem_bt);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,0 +230,37 @@\n+jint StubRoutines::x86::_arrays_hashcode_powers_of_31[] =\n+{\n+     2111290369,\n+    -2010103841,\n+      350799937,\n+       11316127,\n+      693101697,\n+     -254736545,\n+      961614017,\n+       31019807,\n+    -2077209343,\n+      -67006753,\n+     1244764481,\n+    -2038056289,\n+      211350913,\n+     -408824225,\n+     -844471871,\n+     -997072353,\n+     1353309697,\n+     -510534177,\n+     1507551809,\n+     -505558625,\n+     -293403007,\n+      129082719,\n+    -1796951359,\n+     -196513505,\n+    -1807454463,\n+     1742810335,\n+      887503681,\n+       28629151,\n+         923521,\n+          29791,\n+            961,\n+             31,\n+              1,\n+};\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,2 @@\n+  \/\/ table for arrays_hashcode\n+  static jint _arrays_hashcode_powers_of_31[];\n@@ -328,0 +330,1 @@\n+  static address arrays_hashcode_powers_of_31() { return (address)_arrays_hashcode_powers_of_31; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1698,0 +1698,7 @@\n+  if (UseAVX >= 2) {\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, true);\n+  } else if (UseVectorizedHashCodeIntrinsic) {\n+    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic))\n+      warning(\"vectorizedHashCode intrinsics are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n+  }\n@@ -1705,0 +1712,6 @@\n+  if (UseVectorizedHashCodeIntrinsic) {\n+    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic)) {\n+      warning(\"vectorizedHashCode intrinsic is not available in 32-bit VM\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDX int register\n@@ -311,1 +311,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDI int register\n@@ -12077,0 +12077,26 @@\n+instruct arrays_hashcode(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result, immU8 basic_type,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1) (Binary result basic_type)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL ary1, USE_KILL cnt1,\n+         USE basic_type, KILL cr);\n+\n+  format %{ \"Array HashCode array[] $ary1,$cnt1,$result,$basic_type -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, (BasicType)$basic_type$$constant);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -608,2 +608,2 @@\n-  \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals use many memorys edges,\n-  \/\/ but writes none\n+  \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.(equals\/hashCode)\n+  \/\/ use many memorys edges, but writes none\n@@ -616,1 +616,2 @@\n-        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ))\n+        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"VectorizedHashCode\")==0 ))\n@@ -899,0 +900,1 @@\n+        strcmp(_matrule->_rChild->_opType,\"VectorizedHashCode\")==0 ||\n@@ -907,1 +909,1 @@\n-        \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals\n+        \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.equals\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,0 +224,1 @@\n+    case vmIntrinsics::_vectorizedHashCode:\n@@ -530,0 +531,3 @@\n+  case vmIntrinsics::_vectorizedHashCode:\n+    if (!UseVectorizedHashCodeIntrinsic) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,0 +353,4 @@\n+  do_intrinsic(_vectorizedHashCode,       jdk_internal_util_ArraysSupport, vectorizedHashCode_name,  vectorizedHashCode_signature, F_S)   \\\n+   do_name(     vectorizedHashCode_name,                         \"vectorizedHashCode\")                                  \\\n+   do_signature(vectorizedHashCode_signature,                    \"(Ljava\/lang\/Object;IIII)I\")                           \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -568,0 +568,2 @@\n+        Op_VectorizedHashCode,\n+        { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,0 +224,3 @@\n+  case vmIntrinsics::_vectorizedHashCode:\n+    if (!Matcher::match_rule_supported(Op_VectorizedHashCode)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -514,0 +514,1 @@\n+macro(VectorizedHashCode)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -812,0 +812,1 @@\n+    case Op_VectorizedHashCode:\n@@ -3444,2 +3445,2 @@\n-              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp ||\n-              op == Op_CountPositives ||\n+              op == Op_FastLock || op == Op_AryEq ||\n+              op == Op_StrComp || op == Op_CountPositives ||\n@@ -3447,1 +3448,2 @@\n-              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n+              op == Op_StrEquals || op == Op_VectorizedHashCode ||\n+              op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,15 @@\n+uint VectorizedHashCodeNode::match_edge(uint idx) const {\n+  \/\/ Do not match memory edge.\n+  return idx >= 2 && idx <=  5; \/\/ VectorizedHashCodeNode (Binary ary1 cnt1) (Binary result bt)\n+}\n+\n+Node* VectorizedHashCodeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+}\n+\n+const Type* VectorizedHashCodeNode::Value(PhaseGVN* phase) const {\n+  if (in(0) && phase->type(in(0)) == Type::TOP) return Type::TOP;\n+  return bottom_type();\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,0 +169,14 @@\n+\/\/------------------------------VectorizedHashCodeNode----------------------\n+class VectorizedHashCodeNode: public Node {\n+ public:\n+  VectorizedHashCodeNode(Node* control, Node* ary_mem, Node* arg1, Node* cnt1, Node* result, Node* basic_type)\n+    : Node(control, ary_mem, arg1, cnt1, result, basic_type) {};\n+  virtual int Opcode() const;\n+  virtual bool depends_only_on_test() const { return false; }\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n+  virtual uint match_edge(uint idx) const;\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+};\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,0 +204,1 @@\n+    case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -310,0 +310,2 @@\n+  case vmIntrinsics::_vectorizedHashCode:       return inline_vectorizedHashCode();\n+\n@@ -1069,0 +1071,1 @@\n+\n@@ -5927,0 +5930,32 @@\n+\/\/------------------------------inline_vectorizedHashcode----------------------------\n+bool LibraryCallKit::inline_vectorizedHashCode() {\n+  assert(UseVectorizedHashCodeIntrinsic, \"not implemented on this platform\");\n+\n+  assert(callee()->signature()->size() == 5, \"vectorizedHashCode has 5 parameters\");\n+  Node* array          = argument(0);\n+  Node* offset         = argument(1);\n+  Node* length         = argument(2);\n+  Node* initialValue   = argument(3);\n+  Node* basic_type     = argument(4);\n+\n+  array = must_be_not_null(array, true);\n+  if (basic_type == top()) {\n+    return false; \/\/ failed input validation\n+  }\n+\n+  const TypeInt* basic_type_t = _gvn.type(basic_type)->is_int();\n+  if (!basic_type_t->is_con()) {\n+    return false; \/\/ Only intrinsify if mode argument is constant\n+  }\n+  BasicType bt = (BasicType)basic_type_t->get_con();\n+\n+  \/\/ Resolve address of first element\n+  Node* array_start = array_element_address(array, offset, bt);\n+\n+  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(TypeAryPtr::get_array_body_type(bt)),\n+    array_start, length, initialValue, basic_type)));\n+  clear_upper_avx();\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,1 @@\n+  bool inline_vectorizedHashCode();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -852,0 +852,1 @@\n+      case Op_VectorizedHashCode:\n@@ -1020,0 +1021,1 @@\n+      case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -5831,0 +5831,1 @@\n+    case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1070,0 +1070,1 @@\n+    case Op_VectorizedHashCode:\n@@ -2247,0 +2248,1 @@\n+    case Op_VectorizedHashCode:\n@@ -2386,6 +2388,0 @@\n-    case Op_VectorCmpMasked: {\n-      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n-      n->set_req(2, pair1);\n-      n->del_req(3);\n-      break;\n-    }\n@@ -2423,1 +2419,2 @@\n-    case Op_StrIndexOf: {\n+    case Op_StrIndexOf:\n+    case Op_VectorizedHashCode: {\n@@ -2432,0 +2429,1 @@\n+    case Op_EncodeISOArray:\n@@ -2433,2 +2431,1 @@\n-    case Op_StrInflatedCopy:\n-    case Op_EncodeISOArray: {\n+    case Op_StrInflatedCopy: {\n@@ -2461,0 +2458,1 @@\n+    case Op_VectorCmpMasked:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -360,0 +360,3 @@\n+  product(bool, UseVectorizedHashCodeIntrinsic, false, DIAGNOSTIC,           \\\n+          \"Enables intrinsification of ArraysSupport.vectorizedHashCode()\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,5 +192,5 @@\n-        int h = 0;\n-        for (byte v : value) {\n-            h = 31 * h + (v & 0xff);\n-        }\n-        return h;\n+        return switch (value.length) {\n+            case 0 -> 0;\n+            case 1 -> value[0] & 0xff;\n+            default -> ArraysSupport.vectorizedHashCode(value, 0, value.length, 0, ArraysSupport.T_BOOLEAN);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -415,6 +415,5 @@\n-        int h = 0;\n-        int length = value.length >> 1;\n-        for (int i = 0; i < length; i++) {\n-            h = 31 * h + getChar(value, i);\n-        }\n-        return h;\n+        return switch (value.length) {\n+            case 0 -> 0;\n+            case 2 -> getChar(value, 0);\n+            default -> ArraysSupport.vectorizedHashCode(value, 0, value.length >> 1, 0, ArraysSupport.T_CHAR);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2467,1 +2467,3 @@\n-\n+            public char getUTF16Char(byte[] bytes, int index) {\n+                return StringUTF16.getChar(bytes, index);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -4269,1 +4270,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4271,1 +4272,1 @@\n-\n+        }\n@@ -4277,1 +4278,0 @@\n-\n@@ -4298,1 +4298,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4300,6 +4300,6 @@\n-\n-        int result = 1;\n-        for (int element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return switch (a.length) {\n+            case 0 -> 1;\n+            case 1 -> 31 + a[0];\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_INT);\n+        };\n@@ -4325,1 +4325,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4327,6 +4327,6 @@\n-\n-        int result = 1;\n-        for (short element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return switch (a.length) {\n+            case 0 -> 1;\n+            case 1 -> 31 + (int)a[0];\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_SHORT);\n+        };\n@@ -4352,1 +4352,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4354,6 +4354,6 @@\n-\n-        int result = 1;\n-        for (char element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return switch (a.length) {\n+            case 0 -> 1;\n+            case 1 -> 31 + (int)a[0];\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_CHAR);\n+        };\n@@ -4379,1 +4379,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4381,6 +4381,6 @@\n-\n-        int result = 1;\n-        for (byte element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return switch (a.length) {\n+            case 0 -> 1;\n+            case 1 -> 31 + (int)a[0];\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_BYTE);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,0 +345,10 @@\n+    \/**\n+     * Get the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     * @return the char value\n+     *\/\n+    char getUTF16Char(byte[] bytes, int index);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -163,0 +165,99 @@\n+    \/\/ Possible values for the type operand of the NEWARRAY instruction.\n+    \/\/ See https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-6.html#jvms-6.5.newarray.\n+\n+    public static final int T_BOOLEAN = 4;\n+    public static final int T_CHAR = 5;\n+    public static final int T_FLOAT = 6;\n+    public static final int T_DOUBLE = 7;\n+    public static final int T_BYTE = 8;\n+    public static final int T_SHORT = 9;\n+    public static final int T_INT = 10;\n+    public static final int T_LONG = 11;\n+\n+    \/**\n+     * Calculate the hash code for an array in a way that enables efficient\n+     * vectorization.\n+     *\n+     * <p>This method does not perform type checks or bounds checks.  It is the\n+     * responsibility of the caller to perform such checks before calling this\n+     * method.\n+     *\n+     * @param array for which to calculate hash code\n+     * @param fromIndex start index, scaled to basicType\n+     * @param length number of elements to include in the hash\n+     * @param initialValue the initial value for the hash (typically constant 0 or 1)\n+     * @param basicType type constant denoting how to interpret the array content.\n+     *                  T_BOOLEAN is used to signify unsigned bytes, and T_CHAR might be used\n+     *                  even if array is a byte[].\n+     * @implNote currently basicType must be constant at the call site for this method\n+     *           to be intrinsified.\n+     *\n+     * @return the calculated hash value\n+     *\/\n+    @IntrinsicCandidate\n+    public static int vectorizedHashCode(Object array, int fromIndex, int length, int initialValue,\n+                                         int basicType) {\n+        return switch (basicType) {\n+            case T_BOOLEAN -> signedHashCode(initialValue, (byte[]) array, fromIndex, length);\n+            case T_CHAR -> array instanceof byte[]\n+                    ? utf16hashCode(initialValue, (byte[]) array, fromIndex, length)\n+                    : hashCode(initialValue, (char[]) array, fromIndex, length);\n+            case T_BYTE -> hashCode(initialValue, (byte[]) array, fromIndex, length);\n+            case T_SHORT -> hashCode(initialValue, (short[]) array, fromIndex, length);\n+            case T_INT -> hashCode(initialValue, (int[]) array, fromIndex, length);\n+                default -> throw new IllegalArgumentException(\"unrecognized basic type: \" + basicType);\n+        };\n+    }\n+\n+    private static int signedHashCode(int result, byte[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + (a[i] & 0xff);\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(int result, byte[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(int result, char[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(int result, short[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(int result, int[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    \/*\n+     * fromIndex and length must be scaled to char indexes.\n+     *\/\n+    public static int utf16hashCode(int result, byte[] value, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + JLA.getUTF16Char(value, i);\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ArraysSupport.java","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic hashCode functionality and stability\n+ * @run main\/othervm -XX:+CompactStrings HashCode\n+ * @run main\/othervm -XX:-CompactStrings HashCode\n+ *\/\n+\n+public class HashCode {\n+    private static String [] tests = { \"\", \" \", \"a\", \"å\",\n+                                       \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.  -- Charles Dickens, Tale of Two Cities\",\n+                                       \"C'était le meilleur des temps, c'était le pire des temps, c'était l'âge de la sagesse, c'était l'âge de la folie, c'était l'époque de la croyance, c'était l'époque de l'incrédulité, c'était la saison de la Lumière, c'était C'était la saison des Ténèbres, c'était le printemps de l'espoir, c'était l'hiver du désespoir, nous avions tout devant nous, nous n'avions rien devant nous, nous allions tous directement au Ciel, nous allions tous directement dans l'autre sens bref, la période ressemblait tellement à la période actuelle, que certaines de ses autorités les plus bruyantes ont insisté pour qu'elle soit reçue, pour le bien ou pour le mal, au degré superlatif de la comparaison seulement. -- Charles Dickens, Tale of Two Cities (in French)\",\n+                                       \"禅\",\n+                                       \"禅道修行を志した雲水は、一般に参禅のしきたりを踏んだうえで一人の師につき、各地にある専門道場と呼ばれる養成寺院に入門し、与えられた公案に取り組むことになる。公案は、師家（老師）から雲水が悟りの境地へと進んで行くために手助けとして課す問題であり、悟りの境地に達していない人には容易に理解し難い難問だが、屁理屈や詭弁が述べられているわけではなく、頓知や謎かけとも異なる。\"\n+    };\n+\n+    private static int [] expected = { 0, 32, 97, 229, 1094896285, -331808333, 31109, 349367663 };\n+\n+    public static void main(String [] args) throws Exception {\n+        for (int j = 0; j < 20_000; j++) {\n+            for (int i = 0; i < tests.length; i++) {\n+                \/\/ Force use of a new String without cached hash\n+                String s = new String(tests[i].getBytes(\"UTF-8\"), \"UTF-8\");\n+                int e = expected[i];\n+                int hashCode = s.hashCode();\n+                if (hashCode != e)\n+                    throw new RuntimeException(\"String \\\"\" + s + \"\\\": \"\n+                            + \" e = \" + e\n+                            + \", hashCode = \" + hashCode\n+                            + \", repetition = \" + j);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/HashCode.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic array hashCode functionality\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.util=ALL-UNNAMED -Xcomp -Xbatch HashCode\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+public class HashCode {\n+    private static String[] tests = { \"\", \" \", \"a\", \"abcdefg\",\n+            \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.  -- Charles Dickens, Tale of Two Cities\",\n+            \"C'était le meilleur des temps, c'était le pire des temps, c'était l'âge de la sagesse, c'était l'âge de la folie, c'était l'époque de la croyance, c'était l'époque de l'incrédulité, c'était la saison de la Lumière, c'était C'était la saison des Ténèbres, c'était le printemps de l'espoir, c'était l'hiver du désespoir, nous avions tout devant nous, nous n'avions rien devant nous, nous allions tous directement au Ciel, nous allions tous directement dans l'autre sens bref, la période ressemblait tellement à la période actuelle, que certaines de ses autorités les plus bruyantes ont insisté pour qu'elle soit reçue, pour le bien ou pour le mal, au degré superlatif de la comparaison seulement. -- Charles Dickens, Tale of Two Cities (in French)\",\n+            \"禅道修行を志した雲水は、一般に参禅のしきたりを踏んだうえで一人の師につき、各地にある専門道場と呼ばれる養成寺院に入門し、与えられた公案に取り組むことになる。公案は、師家（老師）から雲水が悟りの境地へと進んで行くために手助けとして課す問題であり、悟りの境地に達していない人には容易に理解し難い難問だが、屁理屈や詭弁が述べられているわけではなく、頓知や謎かけとも異なる。\"\n+    };\n+\n+    byte[][] zeroes = new byte[64][];\n+    private static byte[][] testBytes = new byte[tests.length][];\n+    private static short[][] testShorts = new short[tests.length][];\n+    private static char[][] testChars = new char[tests.length][];\n+    private static int[][] testInts = new int[tests.length][];\n+\n+    private static int[] expected = { 1, 63, 128, 536518979, -1174896354, -1357593156, 428276276};\n+    private static int[] expectedUnsigned = { 1, 63, 128, 536518979, -1174896354, 584369596, -2025326028};\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Deep introspection into range-based hash functions\n+        Class<?> arraysSupport = Class.forName(\"jdk.internal.util.ArraysSupport\");\n+        Method vectorizedHashCode = arraysSupport.getDeclaredMethod(\"vectorizedHashCode\", Object.class, int.class, int.class, int.class, int.class);\n+        vectorizedHashCode.setAccessible(true);\n+\n+        for (int i = 0; i < tests.length; i++) {\n+            testBytes[i] = tests[i].getBytes(\"UTF-8\");\n+            int len = testBytes[i].length;\n+            testChars[i] = new char[len];\n+            testShorts[i] = new short[len];\n+            testInts[i] = new int[len];\n+            for (int j = 0; j < len; j++) {\n+                testChars[i][j] = (char) testBytes[i][j];\n+                testShorts[i][j] = testBytes[i][j];\n+                testInts[i][j] = testBytes[i][j];\n+            }\n+        }\n+\n+        boolean failed = false;\n+        try {\n+            int zeroResult = 1;\n+            for (int i = 0; i < 64; i++) {\n+                byte[] zeroes = new byte[i];\n+                byte[] extraZeroes = new byte[i + 47];\n+                for (int j = 0; j < 10_000; j++) {\n+                    int hashCode = Arrays.hashCode(zeroes);\n+                    if (hashCode != zeroResult) {\n+                        throw new RuntimeException(\"byte[] \\\"\" + Arrays.toString(zeroes) + \"\\\": \"\n+                                + \" e = \" + zeroResult\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                    hashCode = (int) vectorizedHashCode.invoke(null, extraZeroes, 17, i, 1, \/* ArraysSupport.T_BYTE *\/ 8);\n+                    if (hashCode != zeroResult) {\n+                        throw new RuntimeException(\"byte[] subrange \\\"\" + Arrays.toString(extraZeroes)\n+                                + \"\\\" at offset 17, limit \" + i + \": \"\n+                                + \" e = \" + zeroResult\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+                zeroResult *= 31;\n+            }\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 64; j++) {\n+                    int e = expected[i];\n+                    int hashCode = Arrays.hashCode(testBytes[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"byte[] \\\"\" + Arrays.toString(testBytes[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"byte[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        try {\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 64; j++) {\n+                    int e = expected[i];\n+                    int hashCode = Arrays.hashCode(testShorts[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"short[] \\\"\" + Arrays.toString(testShorts[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"short[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        try {\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 64; j++) {\n+                    int e = expected[i];\n+                    int hashCode = Arrays.hashCode(testInts[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"int[] \\\"\" + Arrays.toString(testInts[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"int[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        try {\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 64; j++) {\n+                    int e = expectedUnsigned[i];\n+                    int hashCode = Arrays.hashCode(testChars[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"char[] \\\"\" + Arrays.toString(testChars[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"char[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        if (failed) {\n+            throw new RuntimeException(\"Some tests failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Arrays\/HashCode.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/Arrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -36,0 +37,2 @@\n+import java.util.Arrays;\n+import java.util.Random;\n@@ -37,0 +40,4 @@\n+import java.io.UnsupportedEncodingException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n@@ -86,0 +93,62 @@\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @State(Scope.Thread)\n+    @Warmup(iterations = 5, time = 1)\n+    @Measurement(iterations = 5, time = 1)\n+    @Fork(value = 3, jvmArgsAppend = {\"--add-exports\", \"java.base\/java.lang=ALL-UNNAMED\", \"--add-opens\", \"java.base\/java.lang=ALL-UNNAMED\"})\n+    public static class Algorithm {\n+\n+        private final static String alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+        private final static MethodHandle defaultLatin1HashCodeMH;\n+        private final static MethodHandle defaultUTF16HashCodeMH;\n+\n+        static {\n+            try {\n+                Class<?> stringLatin1 = Class.forName(\"java.lang.StringLatin1\");\n+                Method stringLatin1HashCode = stringLatin1.getDeclaredMethod(\"hashCode\", byte[].class);\n+                stringLatin1HashCode.setAccessible(true);\n+\n+                defaultLatin1HashCodeMH = MethodHandles.lookup().unreflect(stringLatin1HashCode);\n+\n+                Class<?> stringUTF16 = Class.forName(\"java.lang.StringUTF16\");\n+                Method stringUTF16HashCode = stringUTF16.getDeclaredMethod(\"hashCode\", byte[].class);\n+                stringUTF16HashCode.setAccessible(true);\n+\n+                defaultUTF16HashCodeMH = MethodHandles.lookup().unreflect(stringUTF16HashCode);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Param({\"1\", \"10\", \"100\", \"10000\"})\n+        private int size;\n+\n+        private byte[] latin1;\n+        private byte[] utf16;\n+\n+        @Setup\n+        public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+            Random rnd = new Random(42);\n+\n+            char[] str = new char[size];\n+            for (int i = 0; i < size; i++) {\n+                str[i] = alphabet.charAt(rnd.nextInt(alphabet.length()));\n+            }\n+            latin1 = new String(str).getBytes(\"US-ASCII\");\n+            utf16 = new String(str).getBytes(\"UTF-16\");\n+            \/\/ strip out byte order byte(s)\n+            utf16 = Arrays.copyOfRange(utf16, utf16.length - str.length * 2, utf16.length);\n+        }\n+\n+        @Benchmark\n+        public int defaultLatin1() throws Throwable {\n+            return (int)defaultLatin1HashCodeMH.invokeExact(latin1);\n+        }\n+\n+        @Benchmark\n+        public int defaultUTF16() throws Throwable {\n+            return (int)defaultUTF16HashCodeMH.invokeExact(utf16);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringHashCode.java","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.io.UnsupportedEncodingException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Performance test of Arrays.hashCode() methods\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class ArraysHashCode {\n+\n+    @Param({\"1\", \"10\", \"100\", \"10000\"})\n+    private int size;\n+\n+    private byte[] bytes;\n+    private char[] chars;\n+    private short[] shorts;\n+    private int[] ints;\n+    private byte[][] multibytes;\n+    private char[][] multichars;\n+    private short[][] multishorts;\n+    private int[][] multiints;\n+\n+    @Setup\n+    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+        Random rnd = new Random(42);\n+\n+        bytes = new byte[size];\n+        chars = new char[size];\n+        shorts = new short[size];\n+        ints = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            int next = rnd.nextInt();\n+            bytes[i] = (byte)next;\n+            chars[i] = (char)next;\n+            shorts[i] = (short)next;\n+            ints[i] = next;\n+        }\n+\n+        multibytes = new byte[100][];\n+        multichars = new char[100][];\n+        multishorts = new short[100][];\n+        multiints = new int[100][];\n+        for (int i = 0; i < 100; i++) {\n+            int next = rnd.nextInt(size + 1);\n+            multibytes[i] = new byte[next];\n+            multichars[i] = new char[next];\n+            multishorts[i] = new short[next];\n+            multiints[i] = new int[next];\n+            for (int j = 0; j < next; j++) {\n+                int nextj = rnd.nextInt();\n+                multibytes[i][j] = (byte)nextj;\n+                multichars[i][j] = (char)nextj;\n+                multishorts[i][j] = (short)nextj;\n+                multiints[i][j] = nextj;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public int bytes() throws Throwable {\n+        return Arrays.hashCode(bytes);\n+    }\n+\n+    @Benchmark\n+    public int chars() throws Throwable {\n+        return Arrays.hashCode(chars);\n+    }\n+\n+    @Benchmark\n+    public int shorts() throws Throwable {\n+        return Arrays.hashCode(shorts);\n+    }\n+\n+    @Benchmark\n+    public int ints() throws Throwable {\n+        return Arrays.hashCode(ints);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(100)\n+    public void multibytes(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < multibytes.length; i++) {\n+            bh.consume(Arrays.hashCode(multibytes[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(100)\n+    public void multichars(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < multichars.length; i++) {\n+            bh.consume(Arrays.hashCode(multichars[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(100)\n+    public void multishorts(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < multishorts.length; i++) {\n+            bh.consume(Arrays.hashCode(multishorts[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(100)\n+    public void multiints(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < multibytes.length; i++) {\n+            bh.consume(Arrays.hashCode(multiints[i]));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysHashCode.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}