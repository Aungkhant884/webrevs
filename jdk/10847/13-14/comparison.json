{"files":[{"patch":"@@ -3250,1 +3250,1 @@\n-void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype) {\n+void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype, bool is_string_hashcode) {\n@@ -3253,1 +3253,5 @@\n-    vector_unsigned_cast(dst, dst, Assembler::AVX_256bit, T_BYTE, T_INT);\n+    if (is_string_hashcode) {\n+      vector_unsigned_cast(dst, dst, Assembler::AVX_256bit, T_BYTE, T_INT);\n+    } else {\n+      vector_signed_cast(dst, dst, Assembler::AVX_256bit, T_BYTE, T_INT);\n+    }\n@@ -3256,0 +3260,2 @@\n+    vector_signed_cast(dst, dst, Assembler::AVX_256bit, T_SHORT, T_INT);\n+    break;\n@@ -3304,2 +3310,0 @@\n-  \/\/ vector loops does not currently support short and signed byte arrays for now, need to figure out how to properly sign-extend when loading into vectors\n-  const bool generate_vectorized_loop = is_unsigned || hashMode == VectorizedHashCodeNode::INT;\n@@ -3327,1 +3331,0 @@\n-  if (generate_vectorized_loop) {\n@@ -3363,1 +3366,1 @@\n-    arrays_hashcode_elvcast(vtmp[idx], eltype);\n+    arrays_hashcode_elvcast(vtmp[idx], eltype, is_string_hashcode);\n@@ -3386,2 +3389,0 @@\n-  } \/\/ generate_vectorized_loop\n-\n@@ -3420,1 +3421,0 @@\n-  jmp(END);\n@@ -4910,0 +4910,27 @@\n+void C2_MacroAssembler::vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                                           BasicType from_elem_bt, BasicType to_elem_bt) {\n+  switch (from_elem_bt) {\n+    case T_BYTE:\n+      switch (to_elem_bt) {\n+        case T_SHORT: vpmovsxbw(dst, src, vlen_enc); break;\n+        case T_INT:   vpmovsxbd(dst, src, vlen_enc); break;\n+        case T_LONG:  vpmovsxbq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_SHORT:\n+      switch (to_elem_bt) {\n+        case T_INT:  vpmovsxwd(dst, src, vlen_enc); break;\n+        case T_LONG: vpmovsxwq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_INT:\n+      assert(to_elem_bt == T_LONG, \"\");\n+      vpmovsxdq(dst, src, vlen_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":36,"deletions":9,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype);\n+  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype, bool is_string_hashcode);\n@@ -325,0 +325,3 @@\n+\n+  void vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                          BasicType from_elem_bt, BasicType to_elem_bt);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -415,5 +415,5 @@\n-        if (value.length == 0) {\n-            return 0;\n-        } else {\n-            return ArraysSupport.vectorizedHashCode(value, ArraysSupport.UTF16);\n-        }\n+        return switch (value.length) {\n+            case 0 -> 0;\n+            case 2 -> getChar(value, 0);\n+            default -> ArraysSupport.vectorizedHashCode(value, ArraysSupport.UTF16);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}