{"files":[{"patch":"@@ -3265,0 +3265,301 @@\n+int C2_MacroAssembler::arrays_hashcode_elsize(BasicType eltype) {\n+  switch (eltype) {\n+  case T_BYTE:  return sizeof(jbyte);\n+  case T_SHORT: return sizeof(jshort);\n+  case T_CHAR:  return sizeof(jchar);\n+  case T_INT:   return sizeof(jint);\n+  case T_FLOAT: return sizeof(jfloat);\n+  default:\n+    ShouldNotReachHere();\n+    return -1;\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elload(Register dst, Address src, BasicType eltype, bool is_string_hashcode) {\n+  switch (eltype) {\n+  case T_BYTE:\n+    if (is_string_hashcode) {\n+      movzbl(dst, src);\n+    } else {\n+      movsbl(dst, src);\n+    }\n+    break;\n+  case T_SHORT:\n+    movswl(dst, src);\n+    break;\n+  case T_CHAR:\n+    movzwl(dst, src);\n+    break;\n+  case T_INT:\n+    movl(dst, src);\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype) {\n+  switch (eltype) {\n+  case T_BYTE:\n+    vector_unsigned_cast(dst, dst, Assembler::AVX_256bit, T_BYTE, T_INT);\n+    break;\n+  case T_SHORT:\n+  case T_CHAR:\n+    vector_unsigned_cast(dst, dst, Assembler::AVX_256bit, T_SHORT, T_INT);\n+    break;\n+  case T_INT:\n+    \/\/ do nothing\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode(Register ary1, Register cnt1, Register result,\n+                                        Register index, Register coef, Register tmp, XMMRegister vnext,\n+                                        XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                                        XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                                        XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                                        int mode) {\n+  ShortBranchVerifier sbv(this);\n+  assert(UseAVX >= 2, \"AVX2 intrinsics are required\");\n+  assert_different_registers(ary1, cnt1, result, index, coef, tmp);\n+  assert_different_registers(vnext, vcoef0, vcoef1, vcoef2, vcoef3, vresult0, vresult1, vresult2, vresult3, vtmp0, vtmp1, vtmp2, vtmp3);\n+\n+  Label SHORT_UNROLLED_BEGIN, SHORT_UNROLLED_LOOP_BEGIN, SHORT_SCALAR_BEGIN, SHORT_SCALAR_LOOP_BEGIN,\n+        LONG, LONG_INIT, LONG_SCALAR_LOOP_BEGIN, LONG_SCALAR_LOOP_END, LONG_VECTOR_LOOP_BEGIN, LONG_VECTOR_LOOP_END,\n+        END;\n+\n+  \/\/ For \"renaming\" for readibility of the code\n+  Register bound;\n+  XMMRegister vcoef[] = { vcoef0, vcoef1, vcoef2, vcoef3 },\n+              vresult[] = { vresult0, vresult1, vresult2, vresult3 },\n+              vtmp[] = { vtmp0, vtmp1, vtmp2, vtmp3 };\n+\n+  const VectorizedHashCodeNode::HashMode hashMode = (VectorizedHashCodeNode::HashMode)mode;\n+  const BasicType eltype = VectorizedHashCodeNode::adr_basic_type(hashMode);\n+  const bool is_string_hashcode = hashMode == VectorizedHashCodeNode::LATIN1 || hashMode == VectorizedHashCodeNode::UTF16;\n+  const bool is_unsigned = is_string_hashcode || hashMode == VectorizedHashCodeNode::CHAR;\n+  const int elsize = arrays_hashcode_elsize(eltype);\n+  \/\/ vector loops does not currently support short and signed byte arrays for now, need to figure out how to properly sign-extend when loading into vectors\n+  const bool generate_vectorized_loop = is_unsigned || hashMode == VectorizedHashCodeNode::INT;\n+\n+  \/\/ int result = 0|1;\n+  movl(result, is_string_hashcode ? 0 : 1);\n+\n+  \/*\n+     if (cnt1 >= 4) {\n+       if (cnt1 >= 16) {\n+           UNROLLED VECTOR LOOP\n+           SINGLE VECTOR LOOP\n+       }\n+       UNROLLED SCALAR LOOP\n+   }\n+   SINGLE SCALAR LOOP\n+   *\/\n+\n+  if (hashMode == VectorizedHashCodeNode::UTF16) {\n+    shrl(cnt1, 1);\n+  }\n+  cmpl(cnt1, 4);\n+  jcc(Assembler::less, SHORT_SCALAR_BEGIN);\n+\n+  if (generate_vectorized_loop) {\n+    cmpl(cnt1, 32);\n+    jcc(Assembler::greaterEqual, LONG);\n+  }\n+  jmp(SHORT_UNROLLED_BEGIN);\n+\n+  address power_of_31_backwards = pc();\n+  emit_int32( 2111290369);\n+  emit_int32(-2010103841);\n+  emit_int32(  350799937);\n+  emit_int32(   11316127);\n+  emit_int32(  693101697);\n+  emit_int32( -254736545);\n+  emit_int32(  961614017);\n+  emit_int32(   31019807);\n+  emit_int32(-2077209343);\n+  emit_int32(  -67006753);\n+  emit_int32( 1244764481);\n+  emit_int32(-2038056289);\n+  emit_int32(  211350913);\n+  emit_int32( -408824225);\n+  emit_int32( -844471871);\n+  emit_int32( -997072353);\n+  emit_int32( 1353309697);\n+  emit_int32( -510534177);\n+  emit_int32( 1507551809);\n+  emit_int32( -505558625);\n+  emit_int32( -293403007);\n+  emit_int32(  129082719);\n+  emit_int32(-1796951359);\n+  emit_int32( -196513505);\n+  emit_int32(-1807454463);\n+  emit_int32( 1742810335);\n+  emit_int32(  887503681);\n+  emit_int32(   28629151);\n+  emit_int32(     923521);\n+  emit_int32(      29791);\n+  emit_int32(        961);\n+  emit_int32(         31);\n+  emit_int32(          1);\n+\n+  if (generate_vectorized_loop) {\n+  \/\/ if (cnt1 >= 32) {\n+  bind(LONG);\n+\n+  \/\/ int coef = 1;\n+  movl(coef, 1);\n+  \/\/ int i = cnt1 - 1;\n+  movl(index, cnt1);\n+  decrementl(index);\n+  \/\/ bound = cnt1 & ~(32-1);\n+  bound = cnt1;\n+  movl(bound, cnt1);\n+  andl(bound, ~(32-1));\n+\n+  \/\/ result = 0;\n+  if (!is_string_hashcode) {\n+    movl(result, 0);\n+  }\n+\n+  \/\/ for (; i >= bound; i -= 1) {\n+  bind(LONG_SCALAR_LOOP_BEGIN);\n+  \/\/ i >= bound;\n+  cmpl(index, bound);\n+  jccb(Assembler::less, LONG_SCALAR_LOOP_END);\n+  \/\/ result += coef * ary1[i];\n+  arrays_hashcode_elload(tmp, Address(ary1, index, Address::times(elsize)), eltype, is_string_hashcode);\n+  imull(tmp, coef);\n+  addl(result, tmp);\n+  \/\/ coef *= 31;\n+  movl(tmp, 31);\n+  imull(coef, tmp);\n+  \/\/ i -= 1;\n+  decrementl(index);\n+  jmpb(LONG_SCALAR_LOOP_BEGIN);\n+  bind(LONG_SCALAR_LOOP_END);\n+  \/\/ }\n+\n+  for (int idx = 0; idx < 4; idx++) {\n+    \/\/ vresult = IntVector.zero(I256);\n+    vpxor(vresult[idx], vresult[idx]);\n+  }\n+  \/\/ vnext = IntVector.broadcast(I256, power_of_31_backwards[0]);\n+  movdl(vnext, InternalAddress(power_of_31_backwards + (0 * sizeof(jint))));\n+  vpbroadcastd(vnext, vnext, Assembler::AVX_256bit);\n+  \/\/ vcoef = IntVector.fromArray(I256, power_of_31_backwards, 1);\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvload(vcoef[idx], InternalAddress(power_of_31_backwards + ((8 * idx + 1) * sizeof(jint))), T_INT);\n+  }\n+  \/\/ vcoef *= coef\n+  movdl(vtmp0, coef);\n+  vpbroadcastd(vtmp0, vtmp0, Assembler::AVX_256bit);\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpmulld(vcoef[idx], vcoef[idx], vtmp0, Assembler::AVX_256bit);\n+  }\n+\n+  \/\/ for (i &= ~(31); i >= 0; i -= 8*4) {\n+  \/\/ i &= ~(31);\n+  andl(index, ~(31));\n+  bind(LONG_VECTOR_LOOP_BEGIN);\n+  \/\/ loop fission to upfront the cost of fetching from memory, OOO execution\n+  \/\/ can then hopefully do a better job of prefetching\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvload(vtmp[idx], Address(ary1, index, Address::times(elsize), 8 * idx * elsize), eltype);\n+  }\n+  \/\/ vresult += vcoef * ary1[i+8*idx:i+8*idx+7]; vcoef *= vnext;\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvcast(vtmp[idx], eltype);\n+    vpmulld(vtmp[idx], vtmp[idx], vcoef[idx], Assembler::AVX_256bit);\n+    vpaddd(vresult[idx], vresult[idx], vtmp[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ i -= 32;\n+  subl(index, 32);\n+  \/\/ i >= 0;\n+  jccb(Assembler::less, LONG_VECTOR_LOOP_END);\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpmulld(vcoef[idx], vcoef[idx], vnext, Assembler::AVX_256bit);\n+  }\n+  jmp(LONG_VECTOR_LOOP_BEGIN);\n+  \/\/ }\n+\n+  bind(LONG_VECTOR_LOOP_END);\n+  \/\/ }\n+\n+  \/\/ result += vcoef0[0]; -- for the non-String cases that have a starting point of constant 1\n+  if (!is_string_hashcode) {\n+    movdl(coef, vcoef0);\n+    movl(tmp, 31);\n+    imull(coef, tmp);\n+    addl(result, coef);\n+  }\n+\n+  \/\/ result += vresult.reduceLanes(ADD);\n+  for (int idx = 0; idx < 4; idx++) {\n+    reduceI(Op_AddReductionVI, 256\/(sizeof(jint) * 8), result, result, vresult[idx], vtmp[(idx * 2 + 0) % 4], vtmp[(idx * 2 + 1) % 4]);\n+  }\n+  jmp(END);\n+  }\n+\n+  \/\/ } else if (cnt1 < 32) {\n+\n+  bind(SHORT_UNROLLED_BEGIN);\n+  \/\/ int i = 0;\n+  xorl(index, index);\n+  \/\/ int bound = cnt1 & ~(4 - 1);\n+  bound = coef;\n+  movl(bound, cnt1);\n+  andl(bound, ~(4-1));\n+\n+  \/\/ for (; i < bound; i += 4) {\n+  bind(SHORT_UNROLLED_LOOP_BEGIN);\n+  \/\/ i < bound;\n+  cmpl(index, bound);\n+  jccb(Assembler::greaterEqual, SHORT_SCALAR_LOOP_BEGIN);\n+  for (int idx = 0; idx < 4; idx++) {\n+    \/\/ h = (31 * h) or (h << 5 - h);\n+    movl(tmp, result);\n+    shll(result, 5);\n+    subl(result, tmp);\n+    \/\/ h += ary1[i];\n+    arrays_hashcode_elload(tmp, Address(ary1, index, Address::times(elsize), idx * elsize), eltype, is_string_hashcode);\n+    addl(result, tmp);\n+  }\n+  addl(index, 4);\n+  jmpb(SHORT_UNROLLED_LOOP_BEGIN);\n+  \/\/ }\n+  \/\/ for (; i < cnt1; i += 1) {\n+  bind(SHORT_SCALAR_BEGIN);\n+  xorl(index, index);\n+  bind(SHORT_SCALAR_LOOP_BEGIN);\n+  \/\/ i < cnt1;\n+  cmpl(index, cnt1);\n+  jcc(Assembler::greaterEqual, END);\n+\n+  \/\/ h = (31 * h) or (h << 5 - h);\n+  movl(tmp, result);\n+  shll(result, 5);\n+  subl(result, tmp);\n+  \/\/ h += ary1[i];\n+  arrays_hashcode_elload(tmp, Address(ary1, index, Address::times(elsize)), eltype, is_string_hashcode);\n+  addl(result, tmp);\n+  \/\/ i += 1;\n+  incrementl(index);\n+  jmpb(SHORT_SCALAR_LOOP_BEGIN);\n+  \/\/ }\n+\n+  \/\/ }\n+  bind(END);\n+\n+} \/\/ arrays_hashcode\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":301,"deletions":0,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -296,0 +296,13 @@\n+  void arrays_hashcode(Register str1, Register cnt1, Register result,\n+                       Register i, Register coef, Register tmp, XMMRegister vnext,\n+                       XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                       XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                       XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                       int mode);\n+\n+  \/\/ helper functions for arrays_hashcode\n+  int arrays_hashcode_elsize(BasicType eltype);\n+  void arrays_hashcode_elload(Register dst, Address src, BasicType eltype, bool is_string_hashcode);\n+  void arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype);\n+  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1669,0 +1669,7 @@\n+  if (UseAVX >= 2 && UseSSE >= 3) {\n+    FLAG_SET_ERGO_IF_DEFAULT(UseVectorizedHashCodeIntrinsic, true);\n+  } else if (UseVectorizedHashCodeIntrinsic) {\n+    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic))\n+      warning(\"vectorizedHashCode intrinsics are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n+  }\n@@ -1676,0 +1683,6 @@\n+  if (UseVectorizedHashCodeIntrinsic) {\n+    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic)) {\n+      warning(\"vectorizedHashCode intrinsic is not available in 32-bit VM\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDX int register\n@@ -311,1 +311,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDI int register\n@@ -12067,0 +12067,155 @@\n+instruct arrays_hashcodeLatin1(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3,\n+                         rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && ((VectorizedHashCodeNode*)n)->mode() == VectorizedHashCodeNode::LATIN1);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP result, USE_KILL ary1, USE_KILL cnt1, KILL cr);\n+\n+  format %{ \"Array HashCode byte[] $ary1,$cnt1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, VectorizedHashCodeNode::LATIN1);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct arrays_hashcodeUTF16(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result,\n+                          legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                          legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                          legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                          legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && ((VectorizedHashCodeNode*)n)->mode() == VectorizedHashCodeNode::UTF16);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP result, USE_KILL ary1, USE_KILL cnt1,\n+         KILL cr);\n+\n+  format %{ \"Array HashCode prim[] $ary1,$cnt1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, VectorizedHashCodeNode::UTF16);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct arrays_hashcodeB(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result,\n+                          legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                          legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                          legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                          legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && ((VectorizedHashCodeNode*)n)->mode() == VectorizedHashCodeNode::BYTE);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP result, USE_KILL ary1, USE_KILL cnt1,\n+         KILL cr);\n+\n+  format %{ \"Array HashCode byte[] $ary1,$cnt1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, VectorizedHashCodeNode::BYTE);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct arrays_hashcodeC(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result,\n+                          legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                          legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                          legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                          legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && ((VectorizedHashCodeNode*)n)->mode() == VectorizedHashCodeNode::CHAR);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP result, USE_KILL ary1, USE_KILL cnt1,\n+         KILL cr);\n+\n+  format %{ \"Array HashCode char[] $ary1,$cnt1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, VectorizedHashCodeNode::CHAR);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct arrays_hashcodeS(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result,\n+                          legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                          legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                          legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                          legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && ((VectorizedHashCodeNode*)n)->mode() == VectorizedHashCodeNode::SHORT);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP result, USE_KILL ary1, USE_KILL cnt1,\n+         KILL cr);\n+\n+  format %{ \"Array HashCode prim[] $ary1,$cnt1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, VectorizedHashCodeNode::SHORT);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct arrays_hashcodeI(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result,\n+                          legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                          legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                          legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                          legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && ((VectorizedHashCodeNode*)n)->mode() == VectorizedHashCodeNode::INT);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP result, USE_KILL ary1, USE_KILL cnt1, KILL cr);\n+\n+  format %{ \"Array HashCode prim[] $ary1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, VectorizedHashCodeNode::INT);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":157,"deletions":2,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -606,2 +606,2 @@\n-  \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals use many memorys edges,\n-  \/\/ but writes none\n+  \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.(equals\/hashCode)\n+  \/\/ use many memorys edges, but writes none\n@@ -614,1 +614,2 @@\n-        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ))\n+        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"VectorizedHashCode\")==0 ))\n@@ -897,0 +898,1 @@\n+        strcmp(_matrule->_rChild->_opType,\"VectorizedHashCode\")==0 ||\n@@ -905,1 +907,1 @@\n-        \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals\n+        \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.equals\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+    case vmIntrinsics::_vectorizedHashCode:\n@@ -524,0 +525,3 @@\n+  case vmIntrinsics::_vectorizedHashCode:\n+    if (!UseVectorizedHashCodeIntrinsic) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -347,0 +347,4 @@\n+  do_intrinsic(_vectorizedHashCode,       jdk_internal_util_ArraysSupport, vectorizedHashCode_name,  vectorizedHashCode_signature, F_S)   \\\n+   do_name(     vectorizedHashCode_name,                         \"vectorizedHashCode\")                                  \\\n+   do_signature(vectorizedHashCode_signature,                    \"(Ljava\/lang\/Object;B)I\")                              \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -568,0 +568,2 @@\n+        \/\/ Op_StrHashCode,\n+        \/\/ { { 2, ShenandoahLoad },                  { 3, ShenandoahLoad } }, \/\/FIXME: what variables are these\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,0 +224,3 @@\n+  case vmIntrinsics::_vectorizedHashCode:\n+    if (!Matcher::match_rule_supported(Op_VectorizedHashCode)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -512,0 +512,1 @@\n+macro(VectorizedHashCode)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -798,0 +798,1 @@\n+    case Op_VectorizedHashCode:\n@@ -3394,2 +3395,2 @@\n-              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp ||\n-              op == Op_CountPositives ||\n+              op == Op_FastLock || op == Op_AryEq ||\n+              op == Op_StrComp || op == Op_CountPositives ||\n@@ -3397,1 +3398,2 @@\n-              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n+              op == Op_StrEquals ||\n+              op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,0 +86,15 @@\n+uint VectorizedHashCodeNode::match_edge(uint idx) const {\n+  \/\/ Do not match memory edge.\n+  return idx == 2 || idx == 3; \/\/ VectorizedHashCodeNode (Binary ary1 cnt1)\n+}\n+\n+Node* VectorizedHashCodeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+}\n+\n+const Type* VectorizedHashCodeNode::Value(PhaseGVN* phase) const {\n+  if (in(0) && phase->type(in(0)) == Type::TOP) return Type::TOP;\n+  return bottom_type();\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -169,0 +169,40 @@\n+\/\/------------------------------VectorizedHashCodeNode----------------------\n+class VectorizedHashCodeNode: public Node {\n+ public:\n+  \/\/ Possible hashing modes, corresponding to the primitive being encoded,\n+  \/\/ as well as adjusting for special treatment of various encoding of String\n+  \/\/ arrays. Must correspond to declared constants in jdk.internal.util.ArraysSupport\n+  typedef enum HashModes { LATIN1 = 0, UTF16 = 1, BYTE = 2, CHAR = 3, SHORT = 4, INT = 5 } HashMode;\n+ private:\n+  HashMode _mode;\n+ public:\n+  VectorizedHashCodeNode(Node* control, Node* ary_mem, Node* arg1, Node* cnt1, HashMode mode)\n+    : Node(control, ary_mem, arg1, cnt1), _mode(mode) {};\n+  bool is_unsigned() const { return _mode == LATIN1 || _mode == UTF16 || _mode == CHAR; }\n+  HashMode mode() const { return _mode; }\n+  static BasicType adr_basic_type(HashMode mode) {\n+    switch (mode) {\n+    case LATIN1:\n+    case BYTE:\n+      return T_BYTE;\n+    case UTF16:\n+    case CHAR:\n+      return T_CHAR;\n+    case SHORT:\n+      return T_SHORT;\n+    case INT:\n+      return T_INT;\n+    default:\n+      ShouldNotReachHere();\n+      return T_ILLEGAL;\n+    }\n+  }\n+  virtual int Opcode() const;\n+  virtual bool depends_only_on_test() const { return false; }\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual const TypePtr* adr_type() const { return TypeAryPtr::get_array_body_type(adr_basic_type(_mode)); }\n+  virtual uint match_edge(uint idx) const;\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+};\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -204,0 +204,1 @@\n+    case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -310,0 +310,2 @@\n+  case vmIntrinsics::_vectorizedHashCode:       return inline_vectorizedHashCode();\n+\n@@ -1065,0 +1067,1 @@\n+\n@@ -5926,0 +5929,30 @@\n+\/\/------------------------------inline_vectorizedHashcode----------------------------\n+bool LibraryCallKit::inline_vectorizedHashCode() {\n+  assert(UseVectorizedHashCodeIntrinsic, \"not implemented on this platform\");\n+\n+  assert(callee()->signature()->size() == 2, \"vectorizedHashCode has 2 parameters\");\n+  Node* arg1 = argument(0);\n+  Node* mode = argument(1);\n+\n+  arg1 = must_be_not_null(arg1, true);\n+  if (mode == top()) {\n+    return false; \/\/ failed input validation\n+  }\n+\n+  const TypeInt* mode_t = _gvn.type(mode)->is_int();\n+  if (!mode_t->is_con()) {\n+    return false; \/\/ Only intrinsify if mode argument is constant\n+  }\n+  VectorizedHashCodeNode::HashMode mode_value = (VectorizedHashCodeNode::HashMode)mode_t->get_con();\n+\n+  BasicType bt = VectorizedHashCodeNode::adr_basic_type(mode_value);\n+  \/\/ Get start addr and length of first argument\n+  Node* arg1_start  = array_element_address(arg1, intcon(0), bt);\n+  Node* arg1_cnt    = load_array_length(arg1);\n+\n+  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(TypeAryPtr::get_array_body_type(bt)), arg1_start, arg1_cnt, mode_value)));\n+  clear_upper_avx();\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+  bool inline_vectorizedHashCode();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -852,0 +852,1 @@\n+      case Op_VectorizedHashCode:\n@@ -1020,0 +1021,1 @@\n+      case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5798,0 +5798,1 @@\n+    case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -211,0 +211,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1069,0 +1069,1 @@\n+    case Op_VectorizedHashCode:\n@@ -1705,0 +1706,2 @@\n+    fprintf(stderr, \"x = %d, _LAST_MACH_OPER = %d\\n\", x, _LAST_MACH_OPER);\n+    fprintf(stderr, \"dump n\\n\");\n@@ -1706,0 +1709,1 @@\n+    fprintf(stderr, \"dump svec\\n\");\n@@ -2246,0 +2250,1 @@\n+    case Op_VectorizedHashCode:\n@@ -2385,6 +2390,0 @@\n-    case Op_VectorCmpMasked: {\n-      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n-      n->set_req(2, pair1);\n-      n->del_req(3);\n-      break;\n-    }\n@@ -2460,0 +2459,2 @@\n+    case Op_VectorizedHashCode:\n+    case Op_VectorCmpMasked:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -354,0 +354,3 @@\n+  product(bool, UseVectorizedHashCodeIntrinsic, false, DIAGNOSTIC,           \\\n+          \"Enables intrinsification of ArraysSupport.vectorizedHashCode()\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+import jdk.internal.misc.Unsafe;\n@@ -192,5 +194,1 @@\n-        int h = 0;\n-        for (byte v : value) {\n-            h = 31 * h + (v & 0xff);\n-        }\n-        return h;\n+        return ArraysSupport.vectorizedHashCode(value, ArraysSupport.LATIN1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+import jdk.internal.misc.Unsafe;\n@@ -415,6 +417,1 @@\n-        int h = 0;\n-        int length = value.length >> 1;\n-        for (int i = 0; i < length; i++) {\n-            h = 31 * h + getChar(value, i);\n-        }\n-        return h;\n+        return ArraysSupport.vectorizedHashCode(value, ArraysSupport.UTF16);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2456,1 +2456,3 @@\n-\n+            public char getUTF16Char(byte[] bytes, int index) {\n+                return StringUTF16.getChar(bytes, index);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -4269,1 +4270,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4271,1 +4272,1 @@\n-\n+        }\n@@ -4277,1 +4278,0 @@\n-\n@@ -4298,1 +4298,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4300,6 +4300,2 @@\n-\n-        int result = 1;\n-        for (int element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return ArraysSupport.vectorizedHashCode(a, ArraysSupport.INT);\n@@ -4325,1 +4321,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4327,6 +4323,2 @@\n-\n-        int result = 1;\n-        for (short element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return ArraysSupport.vectorizedHashCode(a, ArraysSupport.SHORT);\n@@ -4352,1 +4344,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4354,6 +4346,2 @@\n-\n-        int result = 1;\n-        for (char element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return ArraysSupport.vectorizedHashCode(a, ArraysSupport.CHAR);\n@@ -4379,1 +4367,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4381,6 +4369,2 @@\n-\n-        int result = 1;\n-        for (byte element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return ArraysSupport.vectorizedHashCode(a, ArraysSupport.BYTE);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":15,"deletions":31,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -343,0 +343,10 @@\n+    \/**\n+     * Get the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     * @return the char value\n+     *\/\n+    char getUTF16Char(byte[] bytes, int index);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+     *\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleHashes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -163,0 +165,82 @@\n+    public static final byte LATIN1 = 0,\n+        UTF16 = 1,\n+        BYTE = 2,\n+        CHAR = 3,\n+        SHORT = 4,\n+        INT = 5;\n+\n+    \/**\n+     * Calculate the hash code for an array in a way that enables efficient\n+     * vectorization.\n+     *\n+     * <p>This method does not perform type checks or bounds checks.  It is the\n+     * responsibility of the caller to perform such checks before calling this\n+     * method.\n+     *\n+     * @param array for which to calculate hash code\n+     * @param mode describing array type and hash code calculation,\n+     * @return the calculated hash value\n+     *\/\n+    @IntrinsicCandidate\n+    public static int vectorizedHashCode(Object array, byte mode) {\n+        return switch (mode) {\n+            case LATIN1 -> latin1HashCode((byte[]) array);\n+            case UTF16 -> utf16hashCode((byte[]) array);\n+            case BYTE -> hashCode((byte[]) array);\n+            case CHAR -> hashCode((char[]) array);\n+            case SHORT -> hashCode((short[]) array);\n+            case INT -> hashCode((int[]) array);\n+            default -> throw new IllegalArgumentException(\"unrecognized mode: \" + mode);\n+        };\n+    }\n+\n+    private static int latin1HashCode(byte[] a) {\n+        int result = 0;\n+        for (byte value : a) {\n+            result = 31 * result + (value & 0xff);\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(byte[] a) {\n+        int result = 1;\n+        for (byte value : a) {\n+            result = 31 * result + value;\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(char[] a) {\n+        int result = 1;\n+        for (char value : a) {\n+            result = 31 * result + value;\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(short[] a) {\n+        int result = 1;\n+        for (short value : a) {\n+            result = 31 * result + value;\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(int[] a) {\n+        int result = 1;\n+        for (int value : a) {\n+            result = 31 * result + value;\n+        }\n+        return result;\n+    }\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    public static int utf16hashCode(byte[] value) {\n+        int len = value.length >> 1;\n+        int result = 0;\n+        for (int index = 0; index < len; index++) {\n+            result = 31 * result + JLA.getUTF16Char(value, index);\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ArraysSupport.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic hashCode functionality and stability\n+ * @run main\/othervm -XX:+CompactStrings HashCode\n+ * @run main\/othervm -XX:-CompactStrings HashCode\n+ *\/\n+\n+public class HashCode {\n+    private static String [] tests = { \"\", \" \", \"a\",\n+                                       \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.  -- Charles Dickens, Tale of Two Cities\",\n+                                       \"C'était le meilleur des temps, c'était le pire des temps, c'était l'âge de la sagesse, c'était l'âge de la folie, c'était l'époque de la croyance, c'était l'époque de l'incrédulité, c'était la saison de la Lumière, c'était C'était la saison des Ténèbres, c'était le printemps de l'espoir, c'était l'hiver du désespoir, nous avions tout devant nous, nous n'avions rien devant nous, nous allions tous directement au Ciel, nous allions tous directement dans l'autre sens bref, la période ressemblait tellement à la période actuelle, que certaines de ses autorités les plus bruyantes ont insisté pour qu'elle soit reçue, pour le bien ou pour le mal, au degré superlatif de la comparaison seulement. -- Charles Dickens, Tale of Two Cities (in French)\",\n+                                       \"禅\",\n+                                       \"禅道修行を志した雲水は、一般に参禅のしきたりを踏んだうえで一人の師につき、各地にある専門道場と呼ばれる養成寺院に入門し、与えられた公案に取り組むことになる。公案は、師家（老師）から雲水が悟りの境地へと進んで行くために手助けとして課す問題であり、悟りの境地に達していない人には容易に理解し難い難問だが、屁理屈や詭弁が述べられているわけではなく、頓知や謎かけとも異なる。\"\n+    };\n+\n+    private static int [] expected = { 0, 32, 97, 1094896285, -331808333, 31109, 349367663 };\n+\n+    public static void main(String [] args) throws Exception {\n+        for (int j = 0; j < 20_000; j++) {\n+            for (int i = 0; i < tests.length; i++) {\n+                \/\/ Force use of a new String without cached hash\n+                String s = new String(tests[i].getBytes(\"UTF-8\"), \"UTF-8\");\n+                int e = expected[i];\n+                int hashCode = s.hashCode();\n+                if (hashCode != e)\n+                    throw new RuntimeException(\"String \\\"\" + s + \"\\\": \"\n+                            + \" e = \" + e\n+                            + \", hashCode = \" + hashCode\n+                            + \", repetition = \" + j);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/HashCode.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2022, Oracle, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic array hashCode functionality\n+ * @run main\/othervm HashCode\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class HashCode {\n+    private static String[] tests = { \"\", \" \", \"a\", \"abcdefg\",\n+            \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.  -- Charles Dickens, Tale of Two Cities\",\n+            \"C'était le meilleur des temps, c'était le pire des temps, c'était l'âge de la sagesse, c'était l'âge de la folie, c'était l'époque de la croyance, c'était l'époque de l'incrédulité, c'était la saison de la Lumière, c'était C'était la saison des Ténèbres, c'était le printemps de l'espoir, c'était l'hiver du désespoir, nous avions tout devant nous, nous n'avions rien devant nous, nous allions tous directement au Ciel, nous allions tous directement dans l'autre sens bref, la période ressemblait tellement à la période actuelle, que certaines de ses autorités les plus bruyantes ont insisté pour qu'elle soit reçue, pour le bien ou pour le mal, au degré superlatif de la comparaison seulement. -- Charles Dickens, Tale of Two Cities (in French)\",\n+            \"禅道修行を志した雲水は、一般に参禅のしきたりを踏んだうえで一人の師につき、各地にある専門道場と呼ばれる養成寺院に入門し、与えられた公案に取り組むことになる。公案は、師家（老師）から雲水が悟りの境地へと進んで行くために手助けとして課す問題であり、悟りの境地に達していない人には容易に理解し難い難問だが、屁理屈や詭弁が述べられているわけではなく、頓知や謎かけとも異なる。\"\n+    };\n+\n+    byte[][] zeroes = new byte[64][];\n+    private static byte[][] testBytes = new byte[tests.length][];\n+    private static short[][] testShorts = new short[tests.length][];\n+    private static char[][] testChars = new char[tests.length][];\n+    private static int[][] testInts = new int[tests.length][];\n+\n+    private static int[] expected = { 1, 63, 128, 536518979, -1174896354, -1357593156, 428276276};\n+    private static int[] expectedUnsigned = { 1, 63, 128, 536518979, -1174896354, 584369596, -2025326028};\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < tests.length; i++) {\n+            testBytes[i] = tests[i].getBytes(\"UTF-8\");\n+            int len = testBytes[i].length;\n+            testChars[i] = new char[len];\n+            testShorts[i] = new short[len];\n+            testInts[i] = new int[len];\n+            for (int j = 0; j < len; j++) {\n+                testChars[i][j] = (char)testBytes[i][j];\n+                testShorts[i][j] = (short)testBytes[i][j];\n+                testInts[i][j] = (int)testBytes[i][j];\n+            }\n+        }\n+\n+        boolean failed = false;\n+        try {\n+            int zeroResult = 1;\n+            for (int i = 0; i < 64; i++) {\n+                byte[] zeroes = new byte[i];\n+                for (int j = 0; j < 10_000; j++) {\n+                    int hashCode = Arrays.hashCode(zeroes);\n+                    if (hashCode != zeroResult) {\n+                        throw new RuntimeException(\"byte[] \\\"\" + Arrays.toString(zeroes) + \"\\\": \"\n+                                + \" e = \" + zeroResult\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+                zeroResult *= 31;\n+            }\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 20_000; j++) {\n+                    int e = expected[i];\n+                    int hashCode = Arrays.hashCode(testBytes[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"byte[] \\\"\" + Arrays.toString(testBytes[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"byte[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        try {\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 20_000; j++) {\n+                    int e = expected[i];\n+                    int hashCode = Arrays.hashCode(testShorts[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"short[] \\\"\" + Arrays.toString(testShorts[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"short[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        try {\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 20_000; j++) {\n+                    int e = expected[i];\n+                    int hashCode = Arrays.hashCode(testInts[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"int[] \\\"\" + Arrays.toString(testInts[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"int[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        try {\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 20_000; j++) {\n+                    int e = expectedUnsigned[i];\n+                    int hashCode = Arrays.hashCode(testChars[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"char[] \\\"\" + Arrays.toString(testChars[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"char[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        if (failed) {\n+            throw new RuntimeException(\"Some tests failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Arrays\/HashCode.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -36,0 +37,1 @@\n+import java.util.Random;\n@@ -37,0 +39,4 @@\n+import java.io.UnsupportedEncodingException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n@@ -86,0 +92,60 @@\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @State(Scope.Thread)\n+    @Warmup(iterations = 5, time = 1)\n+    @Measurement(iterations = 5, time = 1)\n+    @Fork(value = 3, jvmArgsAppend = {\"--add-exports\", \"java.base\/java.lang=ALL-UNNAMED\", \"--add-opens\", \"java.base\/java.lang=ALL-UNNAMED\"})\n+    public static class Algorithm {\n+\n+        private final static String alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+        private final static MethodHandle defaultLatin1HashCodeMH;\n+        private final static MethodHandle defaultUTF16HashCodeMH;\n+\n+        static {\n+            try {\n+                Class<?> stringLatin1 = Class.forName(\"java.lang.StringLatin1\");\n+                Method stringLatin1HashCode = stringLatin1.getDeclaredMethod(\"hashCode\", byte[].class);\n+                stringLatin1HashCode.setAccessible(true);\n+\n+                defaultLatin1HashCodeMH = MethodHandles.lookup().unreflect(stringLatin1HashCode);\n+\n+                Class<?> stringUTF16 = Class.forName(\"java.lang.StringUTF16\");\n+                Method stringUTF16HashCode = stringUTF16.getDeclaredMethod(\"hashCode\", byte[].class);\n+                stringUTF16HashCode.setAccessible(true);\n+\n+                defaultUTF16HashCodeMH = MethodHandles.lookup().unreflect(stringUTF16HashCode);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Param({\"1\", \"10\", \"100\", \"10000\"})\n+        private int size;\n+\n+        private byte[] latin1;\n+        private byte[] utf16;\n+\n+        @Setup\n+        public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+            Random rnd = new Random(42);\n+\n+            char[] str = new char[size];\n+            for (int i = 0; i < size; i++) {\n+                str[i] = alphabet.charAt(rnd.nextInt(alphabet.length()));\n+            }\n+            latin1 = new String(str).getBytes(\"US-ASCII\");\n+            utf16 = new String(str).getBytes(\"UTF-16\");\n+        }\n+\n+        @Benchmark\n+        public int defaultLatin1() throws Throwable {\n+            return (int)defaultLatin1HashCodeMH.invokeExact(latin1);\n+        }\n+\n+        @Benchmark\n+        public int defaultUTF16() throws Throwable {\n+            return (int)defaultUTF16HashCodeMH.invokeExact(utf16);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringHashCode.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.io.UnsupportedEncodingException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Performance test of Arrays.hashCode() methods\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class ArraysHashCode {\n+\n+    @Param({\"1\", \"10\", \"100\", \"10000\"})\n+    private int size;\n+\n+    private byte[] bytes;\n+    private char[] chars;\n+    private short[] shorts;\n+    private int[] ints;\n+\n+    @Setup\n+    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+        Random rnd = new Random(42);\n+\n+        bytes = new byte[size];\n+        chars = new char[size];\n+        shorts = new short[size];\n+        ints = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            int next = rnd.nextInt();\n+            bytes[i] = (byte)next;\n+            chars[i] = (char)next;\n+            shorts[i] = (short)next;\n+            ints[i] = next;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int bytes() throws Throwable {\n+        return Arrays.hashCode(bytes);\n+    }\n+\n+    @Benchmark\n+    public int chars() throws Throwable {\n+        return Arrays.hashCode(chars);\n+    }\n+\n+    @Benchmark\n+    public int shorts() throws Throwable {\n+        return Arrays.hashCode(shorts);\n+    }\n+\n+    @Benchmark\n+    public int ints() throws Throwable {\n+        return Arrays.hashCode(ints);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysHashCode.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"}]}