{"files":[{"patch":"@@ -3208,0 +3208,1 @@\n+  case T_BOOLEAN: return sizeof(jboolean);\n@@ -3212,1 +3213,0 @@\n-  case T_FLOAT: return sizeof(jfloat);\n@@ -3219,1 +3219,1 @@\n-void C2_MacroAssembler::arrays_hashcode_elload(Register dst, Address src, BasicType eltype, bool is_string_hashcode) {\n+void C2_MacroAssembler::arrays_hashcode_elload(Register dst, Address src, BasicType eltype) {\n@@ -3221,16 +3221,6 @@\n-  case T_BYTE:\n-    if (is_string_hashcode) {\n-      movzbl(dst, src);\n-    } else {\n-      movsbl(dst, src);\n-    }\n-    break;\n-  case T_SHORT:\n-    movswl(dst, src);\n-    break;\n-  case T_CHAR:\n-    movzwl(dst, src);\n-    break;\n-  case T_INT:\n-    movl(dst, src);\n-    break;\n+  \/\/ T_BOOLEAN used as surrogate for unsigned byte\n+  case T_BOOLEAN: movzbl(dst, src);   break;\n+  case T_BYTE:    movsbl(dst, src);   break;\n+  case T_SHORT:   movswl(dst, src);   break;\n+  case T_CHAR:    movzwl(dst, src);   break;\n+  case T_INT:     movl(dst, src);     break;\n@@ -3250,1 +3240,2 @@\n-void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype, bool is_string_hashcode) {\n+void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype) {\n+  const int vlen = Assembler::AVX_256bit;\n@@ -3252,13 +3243,4 @@\n-  case T_BYTE:\n-    if (is_string_hashcode) {\n-      vector_unsigned_cast(dst, dst, Assembler::AVX_256bit, T_BYTE, T_INT);\n-    } else {\n-      vector_signed_cast(dst, dst, Assembler::AVX_256bit, T_BYTE, T_INT);\n-    }\n-    break;\n-  case T_SHORT:\n-    vector_signed_cast(dst, dst, Assembler::AVX_256bit, T_SHORT, T_INT);\n-    break;\n-  case T_CHAR:\n-    vector_unsigned_cast(dst, dst, Assembler::AVX_256bit, T_SHORT, T_INT);\n-    break;\n+  case T_BOOLEAN: vector_unsigned_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_BYTE:      vector_signed_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_SHORT:     vector_signed_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n+  case T_CHAR:    vector_unsigned_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n@@ -3278,1 +3260,1 @@\n-                                        int mode) {\n+                                        BasicType eltype) {\n@@ -3289,9 +3271,7 @@\n-\n-  switch (mode) {\n-  case VectorizedHashCodeNode::LATIN1: BLOCK_COMMENT(\"arrays_hashcode(LATIN1) {\"); break;\n-  case VectorizedHashCodeNode::UTF16:  BLOCK_COMMENT(\"arrays_hashcode(UTF16) {\");  break;\n-  case VectorizedHashCodeNode::BYTE:   BLOCK_COMMENT(\"arrays_hashcode(BYTE) {\");   break;\n-  case VectorizedHashCodeNode::CHAR:   BLOCK_COMMENT(\"arrays_hashcode(CHAR) {\");   break;\n-  case VectorizedHashCodeNode::SHORT:  BLOCK_COMMENT(\"arrays_hashcode(SHORT) {\");  break;\n-  case VectorizedHashCodeNode::INT:    BLOCK_COMMENT(\"arrays_hashcode(INT) {\");    break;\n-  default:                             BLOCK_COMMENT(\"arrays_hashcode {\");    break;\n+  switch (eltype) {\n+  case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode(unsigned byte) {\"); break;\n+  case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode(char) {\");          break;\n+  case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode(byte) {\");          break;\n+  case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode(short) {\");         break;\n+  case T_INT:     BLOCK_COMMENT(\"arrays_hashcode(int) {\");           break;\n+  default:        BLOCK_COMMENT(\"arrays_hashcode {\");                break;\n@@ -3305,4 +3285,0 @@\n-  const VectorizedHashCodeNode::HashMode hashMode = (VectorizedHashCodeNode::HashMode)mode;\n-  const BasicType eltype = VectorizedHashCodeNode::adr_basic_type(hashMode);\n-  const bool is_string_hashcode = hashMode == VectorizedHashCodeNode::LATIN1 || hashMode == VectorizedHashCodeNode::UTF16;\n-  const bool is_unsigned = is_string_hashcode || hashMode == VectorizedHashCodeNode::CHAR;\n@@ -3311,6 +3287,0 @@\n-  \/\/ int result = 0|1;\n-  if (is_string_hashcode) {\n-    xorl(result, result);\n-  } else {\n-    movl(result, 1);\n-  }\n@@ -3327,4 +3297,0 @@\n-  if (hashMode == VectorizedHashCodeNode::UTF16) {\n-    shrl(cnt1, 1);\n-  }\n-\n@@ -3356,3 +3322,1 @@\n-  if (!is_string_hashcode) {\n-    imull(result, next);\n-  }\n+  imull(result, next);\n@@ -3367,1 +3331,1 @@\n-    arrays_hashcode_elvcast(vtmp[idx], eltype, is_string_hashcode);\n+    arrays_hashcode_elvcast(vtmp[idx], eltype);\n@@ -3404,1 +3368,1 @@\n-  arrays_hashcode_elload(tmp2, Address(ary1, index, Address::times(elsize), -elsize), eltype, is_string_hashcode);\n+  arrays_hashcode_elload(tmp2, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n@@ -3409,1 +3373,1 @@\n-  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize)), eltype, is_string_hashcode);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize)), eltype);\n@@ -3422,1 +3386,1 @@\n-  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize), -elsize), eltype, is_string_hashcode);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":27,"deletions":63,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-                       int mode);\n+                       BasicType eltype);\n@@ -304,1 +304,1 @@\n-  void arrays_hashcode_elload(Register dst, Address src, BasicType eltype, bool is_string_hashcode);\n+  void arrays_hashcode_elload(Register dst, Address src, BasicType eltype);\n@@ -307,1 +307,1 @@\n-  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype, bool is_string_hashcode);\n+  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -12075,1 +12075,1 @@\n-instruct arrays_hashcode(rdi_RegP ary1, rdx_RegI cnt1, immI mode, rbx_RegI result,\n+instruct arrays_hashcode(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result, immU8 basic_type,\n@@ -12082,1 +12082,1 @@\n-  match(Set result (VectorizedHashCode ary1 (Binary cnt1 mode)));\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1) (Binary result basic_type)));\n@@ -12085,1 +12085,2 @@\n-         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP result, USE_KILL ary1, USE_KILL cnt1, KILL cr);\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL ary1, USE_KILL cnt1,\n+         USE basic_type, KILL cr);\n@@ -12087,1 +12088,1 @@\n-  format %{ \"Array HashCode byte[] $ary1,$cnt1 -> $result   \/\/ KILL all\" %}\n+  format %{ \"Array HashCode array[] $ary1,$cnt1,$result,$basic_type -> $result   \/\/ KILL all\" %}\n@@ -12095,1 +12096,1 @@\n-                       $tmp_vec13$$XMMRegister, $mode$$constant);\n+                       $tmp_vec13$$XMMRegister, (BasicType)$basic_type$$constant);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-   do_signature(vectorizedHashCode_signature,                    \"(Ljava\/lang\/Object;B)I\")                              \\\n+   do_signature(vectorizedHashCode_signature,                    \"(Ljava\/lang\/Object;IIII)I\")                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  return idx == 2 || idx == 3; \/\/ VectorizedHashCodeNode (Binary ary1 cnt1)\n+  return idx >= 2 && idx <=  5; \/\/ VectorizedHashCodeNode (Binary ary1 cnt1) (Binary result bt)\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,23 +172,2 @@\n-  \/\/ Possible hashing modes, corresponding to the primitive being encoded,\n-  \/\/ as well as adjusting for special treatment of various encoding of String\n-  \/\/ arrays. Must correspond to declared constants in jdk.internal.util.ArraysSupport\n-  typedef enum HashModes { LATIN1 = 0, UTF16 = 1, BYTE = 2, CHAR = 3, SHORT = 4, INT = 5 } HashMode;\n-  VectorizedHashCodeNode(Node* control, Node* ary_mem, Node* arg1, Node* cnt1, Node* mode)\n-    : Node(control, ary_mem, arg1, cnt1, mode) {};\n-  static BasicType adr_basic_type(HashMode mode) {\n-    switch (mode) {\n-    case LATIN1:\n-    case BYTE:\n-      return T_BYTE;\n-    case UTF16:\n-    case CHAR:\n-      return T_CHAR;\n-    case SHORT:\n-      return T_SHORT;\n-    case INT:\n-      return T_INT;\n-    default:\n-      ShouldNotReachHere();\n-      return T_ILLEGAL;\n-    }\n-  }\n+  VectorizedHashCodeNode(Node* control, Node* ary_mem, Node* arg1, Node* cnt1, Node* result, Node* basic_type)\n+    : Node(control, ary_mem, arg1, cnt1, result, basic_type) {};  \n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -5936,6 +5936,9 @@\n-  assert(callee()->signature()->size() == 2, \"vectorizedHashCode has 2 parameters\");\n-  Node* arg1 = argument(0);\n-  Node* mode = argument(1);\n-\n-  arg1 = must_be_not_null(arg1, true);\n-  if (mode == top()) {\n+  assert(callee()->signature()->size() == 5, \"vectorizedHashCode has 5 parameters\");\n+  Node* array          = argument(0);\n+  Node* offset         = argument(1);\n+  Node* length         = argument(2);\n+  Node* initialValue   = argument(3);\n+  Node* basic_type     = argument(4);\n+\n+  array = must_be_not_null(array, true);\n+  if (basic_type == top()) {\n@@ -5945,2 +5948,2 @@\n-  const TypeInt* mode_t = _gvn.type(mode)->is_int();\n-  if (!mode_t->is_con()) {\n+  const TypeInt* basic_type_t = _gvn.type(basic_type)->is_int();\n+  if (!basic_type_t->is_con()) {\n@@ -5949,5 +5952,4 @@\n-  VectorizedHashCodeNode::HashMode mode_value = (VectorizedHashCodeNode::HashMode)mode_t->get_con();\n-  BasicType bt = VectorizedHashCodeNode::adr_basic_type(mode_value);\n-  \/\/ Get start addr and length of first argument\n-  Node* arg1_start  = array_element_address(arg1, intcon(0), bt);\n-  Node* arg1_cnt    = load_array_length(arg1);\n+  BasicType bt = (BasicType)basic_type_t->get_con();\n+\n+  \/\/ Resolve address of first element\n+  Node* array_start = array_element_address(array, offset, bt);\n@@ -5955,1 +5957,2 @@\n-  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(TypeAryPtr::get_array_body_type(bt)), arg1_start, arg1_cnt, mode)));\n+  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(TypeAryPtr::get_array_body_type(bt)),\n+    array_start, length, initialValue, basic_type)));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2419,1 +2419,2 @@\n-    case Op_StrIndexOf: {\n+    case Op_StrIndexOf:\n+    case Op_VectorizedHashCode: {\n@@ -2430,2 +2431,1 @@\n-    case Op_StrInflatedCopy:\n-    case Op_VectorizedHashCode: {\n+    case Op_StrInflatedCopy: {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-            default -> ArraysSupport.vectorizedHashCode(value, ArraysSupport.LATIN1);\n+            default -> ArraysSupport.vectorizedHashCode(value, 0, value.length, 0, ArraysSupport.T_BOOLEAN);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-            default -> ArraysSupport.vectorizedHashCode(value, ArraysSupport.UTF16);\n+            default -> ArraysSupport.vectorizedHashCode(value, 0, value.length >> 1, 0, ArraysSupport.T_CHAR);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4304,1 +4304,1 @@\n-            default -> ArraysSupport.vectorizedHashCode(a, ArraysSupport.INT);\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_INT);\n@@ -4331,1 +4331,1 @@\n-            default -> ArraysSupport.vectorizedHashCode(a, ArraysSupport.SHORT);\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_SHORT);\n@@ -4358,1 +4358,1 @@\n-            default -> ArraysSupport.vectorizedHashCode(a, ArraysSupport.CHAR);\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_CHAR);\n@@ -4385,1 +4385,1 @@\n-            default -> ArraysSupport.vectorizedHashCode(a, ArraysSupport.BYTE);\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_BYTE);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -165,6 +165,11 @@\n-    public static final byte LATIN1 = 0,\n-        UTF16 = 1,\n-        BYTE = 2,\n-        CHAR = 3,\n-        SHORT = 4,\n-        INT = 5;\n+    \/\/ Possible values for the type operand of the NEWARRAY instruction.\n+    \/\/ See https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-6.html#jvms-6.5.newarray.\n+\n+    public static final int T_BOOLEAN = 4;\n+    public static final int T_CHAR = 5;\n+    public static final int T_FLOAT = 6;\n+    public static final int T_DOUBLE = 7;\n+    public static final int T_BYTE = 8;\n+    public static final int T_SHORT = 9;\n+    public static final int T_INT = 10;\n+    public static final int T_LONG = 11;\n@@ -181,1 +186,9 @@\n-     * @param mode describing array type and hash code calculation,\n+     * @param fromIndex start index, scaled to basicType\n+     * @param length number of elements to include in the hash\n+     * @param initialValue the initial value for the hash (typically constant 0 or 1)\n+     * @param basicType type constant denoting how to interpret the array content.\n+     *                  T_BOOLEAN is used to signify unsigned bytes, and T_CHAR might be used\n+     *                  even if array is a byte[].\n+     * @implNote currently basicType must be constant at the call site for this method\n+     *           to be intrinsified.\n+     *\n@@ -185,9 +198,11 @@\n-    public static int vectorizedHashCode(Object array, byte mode) {\n-        return switch (mode) {\n-            case LATIN1 -> latin1HashCode((byte[]) array);\n-            case UTF16 -> utf16hashCode((byte[]) array);\n-            case BYTE -> hashCode((byte[]) array);\n-            case CHAR -> hashCode((char[]) array);\n-            case SHORT -> hashCode((short[]) array);\n-            case INT -> hashCode((int[]) array);\n-            default -> throw new IllegalArgumentException(\"unrecognized mode: \" + mode);\n+    public static int vectorizedHashCode(Object array, int fromIndex, int length, int initialValue,\n+                                         int basicType) {\n+        return switch (basicType) {\n+            case T_BOOLEAN -> signedHashCode(initialValue, (byte[]) array, fromIndex, length);\n+            case T_CHAR -> array instanceof byte[]\n+                    ? utf16hashCode(initialValue, (byte[]) array, fromIndex, length)\n+                    : hashCode(initialValue, (char[]) array, fromIndex, length);\n+            case T_BYTE -> hashCode(initialValue, (byte[]) array, fromIndex, length);\n+            case T_SHORT -> hashCode(initialValue, (short[]) array, fromIndex, length);\n+            case T_INT -> hashCode(initialValue, (int[]) array, fromIndex, length);\n+                default -> throw new IllegalArgumentException(\"unrecognized basic type: \" + basicType);\n@@ -197,4 +212,4 @@\n-    private static int latin1HashCode(byte[] a) {\n-        int result = 0;\n-        for (byte value : a) {\n-            result = 31 * result + (value & 0xff);\n+    private static int signedHashCode(int result, byte[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + (a[i] & 0xff);\n@@ -205,4 +220,4 @@\n-    private static int hashCode(byte[] a) {\n-        int result = 1;\n-        for (byte value : a) {\n-            result = 31 * result + value;\n+    private static int hashCode(int result, byte[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n@@ -213,4 +228,4 @@\n-    private static int hashCode(char[] a) {\n-        int result = 1;\n-        for (char value : a) {\n-            result = 31 * result + value;\n+    private static int hashCode(int result, char[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n@@ -221,4 +236,4 @@\n-    private static int hashCode(short[] a) {\n-        int result = 1;\n-        for (short value : a) {\n-            result = 31 * result + value;\n+    private static int hashCode(int result, short[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n@@ -229,4 +244,4 @@\n-    private static int hashCode(int[] a) {\n-        int result = 1;\n-        for (int value : a) {\n-            result = 31 * result + value;\n+    private static int hashCode(int result, int[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n@@ -238,5 +253,7 @@\n-    public static int utf16hashCode(byte[] value) {\n-        int len = value.length >> 1;\n-        int result = 0;\n-        for (int index = 0; index < len; index++) {\n-            result = 31 * result + JLA.getUTF16Char(value, index);\n+    \/*\n+     * fromIndex and length must be scaled to char indexes.\n+     *\/\n+    public static int utf16hashCode(int result, byte[] value, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + JLA.getUTF16Char(value, i);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ArraysSupport.java","additions":58,"deletions":41,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle, Inc. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle, Inc. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run main\/othervm -Xcomp -Xbatch HashCode\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.util=ALL-UNNAMED -Xcomp -Xbatch HashCode\n@@ -30,0 +30,1 @@\n+import java.lang.reflect.Method;\n@@ -49,0 +50,6 @@\n+\n+        \/\/ Deep introspection into range-based hash functions\n+        Class<?> arraysSupport = Class.forName(\"jdk.internal.util.ArraysSupport\");\n+        Method vectorizedHashCode = arraysSupport.getDeclaredMethod(\"vectorizedHashCode\", Object.class, int.class, int.class, int.class, int.class);\n+        vectorizedHashCode.setAccessible(true);\n+\n@@ -56,3 +63,3 @@\n-                testChars[i][j] = (char)testBytes[i][j];\n-                testShorts[i][j] = (short)testBytes[i][j];\n-                testInts[i][j] = (int)testBytes[i][j];\n+                testChars[i][j] = (char) testBytes[i][j];\n+                testShorts[i][j] = testBytes[i][j];\n+                testInts[i][j] = testBytes[i][j];\n@@ -67,0 +74,1 @@\n+                byte[] extraZeroes = new byte[i + 47];\n@@ -75,0 +83,8 @@\n+                    hashCode = (int) vectorizedHashCode.invoke(null, extraZeroes, 17, i, 1, \/* ArraysSupport.T_BYTE *\/ 8);\n+                    if (hashCode != zeroResult) {\n+                        throw new RuntimeException(\"byte[] subrange \\\"\" + Arrays.toString(extraZeroes)\n+                                + \"\\\" at offset 17, limit \" + i + \": \"\n+                                + \" e = \" + zeroResult\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n@@ -79,1 +95,1 @@\n-                for (int j = 0; j < 20_000; j++) {\n+                for (int j = 0; j < 64; j++) {\n@@ -98,1 +114,1 @@\n-                for (int j = 0; j < 20_000; j++) {\n+                for (int j = 0; j < 64; j++) {\n@@ -117,1 +133,1 @@\n-                for (int j = 0; j < 20_000; j++) {\n+                for (int j = 0; j < 64; j++) {\n@@ -136,1 +152,1 @@\n-                for (int j = 0; j < 20_000; j++) {\n+                for (int j = 0; j < 64; j++) {\n","filename":"test\/jdk\/java\/util\/Arrays\/HashCode.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"}]}