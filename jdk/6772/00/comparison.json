{"files":[{"patch":"@@ -391,1 +391,1 @@\n-  out->print_cr(\"   maxchunksize      (Optional) Maximum size of an individual data chunk in bytes if\");\n+  out->print_cr(\"  maxchunksize       (Optional) Maximum size of an individual data chunk in bytes if\");\n@@ -396,1 +396,1 @@\n-  out->print_cr(\"   memorysize        (Optional) Overall memory size, in bytes if one of the following\");\n+  out->print_cr(\"  memorysize         (Optional) Overall memory size, in bytes if one of the following\");\n@@ -406,1 +406,5 @@\n-  out->print_cr(\"                     environment variable.)\");\n+  out->print_cr(\"                     environment variable)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  dumppath           (Optional) Path to the location where a recording file is written\");\n+  out->print_cr(\"                     in case the VM runs into a critical error, such as a system\");\n+  out->print_cr(\"                     crash. (STRING, The default location is the current directory)\");\n@@ -419,1 +423,2 @@\n-  out->print_cr(\"  samplethreads      (Optional) Flag for activating thread sampling. (BOOLEAN, true)\");\n+  out->print_cr(\"  samplethreads      (Optional) Flag for activating thread sampling. This value cannot\");\n+  out->print_cr(\"                     be changed once JFR has been initialized. (BOOLEAN, true)\");\n@@ -470,4 +475,0 @@\n-  if (_stack_depth.is_set()) {\n-    stack_depth = JfrJavaSupport::new_java_lang_Integer((jint)_stack_depth.value(), CHECK);\n-  }\n-\n@@ -475,4 +476,0 @@\n-  if (_global_buffer_count.is_set()) {\n-    global_buffer_count = JfrJavaSupport::new_java_lang_Long(_global_buffer_count.value(), CHECK);\n-  }\n-\n@@ -480,4 +477,0 @@\n-  if (_global_buffer_size.is_set()) {\n-    global_buffer_size = JfrJavaSupport::new_java_lang_Long(_global_buffer_size.value()._size, CHECK);\n-  }\n-\n@@ -485,4 +478,0 @@\n-  if (_thread_buffer_size.is_set()) {\n-    thread_buffer_size = JfrJavaSupport::new_java_lang_Long(_thread_buffer_size.value()._size, CHECK);\n-  }\n-\n@@ -490,4 +479,0 @@\n-  if (_max_chunk_size.is_set()) {\n-    max_chunk_size = JfrJavaSupport::new_java_lang_Long(_max_chunk_size.value()._size, CHECK);\n-  }\n-\n@@ -495,4 +480,0 @@\n-  if (_memory_size.is_set()) {\n-    memory_size = JfrJavaSupport::new_java_lang_Long(_memory_size.value()._size, CHECK);\n-  }\n-\n@@ -500,2 +481,23 @@\n-  if (_sample_threads.is_set()) {\n-    sample_threads = JfrJavaSupport::new_java_lang_Boolean(_sample_threads.value(), CHECK);\n+\n+  if (!JfrRecorder::is_created()) {\n+    if (_stack_depth.is_set()) {\n+      stack_depth = JfrJavaSupport::new_java_lang_Integer((jint)_stack_depth.value(), CHECK);\n+    }\n+    if (_global_buffer_count.is_set()) {\n+      global_buffer_count = JfrJavaSupport::new_java_lang_Long(_global_buffer_count.value(), CHECK);\n+    }\n+    if (_global_buffer_size.is_set()) {\n+      global_buffer_size = JfrJavaSupport::new_java_lang_Long(_global_buffer_size.value()._size, CHECK);\n+    }\n+    if (_thread_buffer_size.is_set()) {\n+      thread_buffer_size = JfrJavaSupport::new_java_lang_Long(_thread_buffer_size.value()._size, CHECK);\n+    }\n+    if (_max_chunk_size.is_set()) {\n+      max_chunk_size = JfrJavaSupport::new_java_lang_Long(_max_chunk_size.value()._size, CHECK);\n+    }\n+    if (_memory_size.is_set()) {\n+      memory_size = JfrJavaSupport::new_java_lang_Long(_memory_size.value()._size, CHECK);\n+    }\n+    if (_sample_threads.is_set()) {\n+      sample_threads = JfrJavaSupport::new_java_lang_Boolean(_sample_threads.value(), CHECK);\n+    }\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":32,"deletions":30,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @summary The test verifies JFR.configure command can only set certain options before JFR is started.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jcmd.TestJcmdConfigureReadOnly\n+ *\/\n+public class TestJcmdConfigureReadOnly {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Set an option before initializing JFR.\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.configure\", \"stackdepth=\" + 128);\n+        output.shouldContain(\"Stack depth: 128\");\n+        \/\/ JFR.start will initialize JFR.\n+        output = JcmdHelper.jcmd(\"JFR.start\");\n+        JcmdAsserts.assertRecordingHasStarted(output);\n+        \/\/ Attempt to set a new value after JFR initialization.\n+        output = JcmdHelper.jcmd(\"JFR.configure\", \"stackdepth=\" + 256);\n+        \/\/ After initialization, the option is considered read-only.\n+        output.shouldContain(\"Stack depth: 128\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdConfigureReadOnly.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}