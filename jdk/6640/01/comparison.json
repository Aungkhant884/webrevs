{"files":[{"patch":"@@ -1031,1 +1031,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1837,1 +1837,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -285,1 +285,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemory.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -706,31 +706,0 @@\n-WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))\n-  \/\/ Test that we can downgrade NMT levels but not upgrade them.\n-  if (MemTracker::tracking_level() == NMT_off) {\n-    MemTracker::transition_to(NMT_off);\n-    return MemTracker::tracking_level() == NMT_off;\n-  } else {\n-    assert(MemTracker::tracking_level() == NMT_detail, \"Should start out as detail tracking\");\n-    MemTracker::transition_to(NMT_summary);\n-    assert(MemTracker::tracking_level() == NMT_summary, \"Should be summary now\");\n-\n-    \/\/ Can't go to detail once NMT is set to summary.\n-    MemTracker::transition_to(NMT_detail);\n-    assert(MemTracker::tracking_level() == NMT_summary, \"Should still be summary now\");\n-\n-    \/\/ Shutdown sets tracking level to minimal.\n-    MemTracker::shutdown();\n-    assert(MemTracker::tracking_level() == NMT_minimal, \"Should be minimal now\");\n-\n-    \/\/ Once the tracking level is minimal, we cannot increase to summary.\n-    \/\/ The code ignores this request instead of asserting because if the malloc site\n-    \/\/ table overflows in another thread, it tries to change the code to summary.\n-    MemTracker::transition_to(NMT_summary);\n-    assert(MemTracker::tracking_level() == NMT_minimal, \"Should still be minimal now\");\n-\n-    \/\/ Really can never go up to detail, verify that the code would never do this.\n-    MemTracker::transition_to(NMT_detail);\n-    assert(MemTracker::tracking_level() == NMT_minimal, \"Should still be minimal now\");\n-    return MemTracker::tracking_level() == NMT_minimal;\n-  }\n-WB_END\n-\n@@ -2570,1 +2539,0 @@\n-  {CC\"NMTChangeTrackingLevel\", CC\"()Z\",               (void*)&WB_NMTChangeTrackingLevel},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1789,1 +1789,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n@@ -1803,1 +1803,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n@@ -1872,1 +1872,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n@@ -1908,1 +1908,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,6 +36,0 @@\n-\/\/ concurrent access counter\n-volatile int MallocSiteTable::_access_count = 0;\n-\n-\/\/ Tracking hashtable contention\n-NOT_PRODUCT(int MallocSiteTable::_peak_count = 0;)\n-\n@@ -205,6 +199,0 @@\n-void MallocSiteTable::shutdown() {\n-  AccessLock locker(&_access_count);\n-  locker.exclusiveLock();\n-  reset();\n-}\n-\n@@ -213,31 +201,1 @@\n-  AccessLock locker(&_access_count);\n-  if (locker.sharedLock()) {\n-    NOT_PRODUCT(_peak_count = MAX2(_peak_count, _access_count);)\n-    return walk(walker);\n-  }\n-  return false;\n-}\n-\n-\n-void MallocSiteTable::AccessLock::exclusiveLock() {\n-  int target;\n-  int val;\n-\n-  assert(_lock_state != ExclusiveLock, \"Can only call once\");\n-  assert(*_lock >= 0, \"Can not content exclusive lock\");\n-\n-  \/\/ make counter negative to block out shared locks\n-  do {\n-    val = *_lock;\n-    target = _MAGIC_ + *_lock;\n-  } while (Atomic::cmpxchg(_lock, val, target) != val);\n-\n-  \/\/ wait for all readers to exit\n-  while (*_lock != _MAGIC_) {\n-#ifdef _WINDOWS\n-    os::naked_short_sleep(1);\n-#else\n-    os::naked_yield();\n-#endif\n-  }\n-  _lock_state = ExclusiveLock;\n+  return walk(walker);\n@@ -247,47 +205,17 @@\n-\n-  AccessLock locker(&_access_count);\n-  if (locker.sharedLock()) {\n-      \/\/ Total number of allocation sites, include empty sites\n-    int total_entries = 0;\n-    \/\/ Number of allocation sites that have all memory freed\n-    int empty_entries = 0;\n-    \/\/ Number of captured call stack distribution\n-    int stack_depth_distribution[NMT_TrackingStackDepth + 1] = { 0 };\n-    \/\/ Chain lengths\n-    int lengths[table_size] = { 0 };\n-\n-    for (int i = 0; i < table_size; i ++) {\n-      int this_chain_length = 0;\n-      const MallocSiteHashtableEntry* head = _table[i];\n-      while (head != NULL) {\n-        total_entries ++;\n-        this_chain_length ++;\n-        if (head->size() == 0) {\n-          empty_entries ++;\n-        }\n-        const int callstack_depth = head->peek()->call_stack()->frames();\n-        assert(callstack_depth >= 0 && callstack_depth <= NMT_TrackingStackDepth,\n-               \"Sanity (%d)\", callstack_depth);\n-        stack_depth_distribution[callstack_depth] ++;\n-        head = head->next();\n-      }\n-      lengths[i] = this_chain_length;\n-    }\n-\n-    st->print_cr(\"Malloc allocation site table:\");\n-    st->print_cr(\"\\tTotal entries: %d\", total_entries);\n-    st->print_cr(\"\\tEmpty entries: %d (%2.2f%%)\", empty_entries, ((float)empty_entries * 100) \/ total_entries);\n-    st->cr();\n-\n-    \/\/ We report the hash distribution (chain length distribution) of the n shortest chains\n-    \/\/  - under the assumption that this usually contains all lengths. Reporting threshold\n-    \/\/  is 20, and the expected avg chain length is 5..6 (see table size).\n-    static const int chain_length_threshold = 20;\n-    int chain_length_distribution[chain_length_threshold] = { 0 };\n-    int over_threshold = 0;\n-    int longest_chain_length = 0;\n-    for (int i = 0; i < table_size; i ++) {\n-      if (lengths[i] >= chain_length_threshold) {\n-        over_threshold ++;\n-      } else {\n-        chain_length_distribution[lengths[i]] ++;\n+  \/\/ Total number of allocation sites, include empty sites\n+  int total_entries = 0;\n+  \/\/ Number of allocation sites that have all memory freed\n+  int empty_entries = 0;\n+  \/\/ Number of captured call stack distribution\n+  int stack_depth_distribution[NMT_TrackingStackDepth + 1] = { 0 };\n+  \/\/ Chain lengths\n+  int lengths[table_size] = { 0 };\n+\n+  for (int i = 0; i < table_size; i ++) {\n+    int this_chain_length = 0;\n+    const MallocSiteHashtableEntry* head = _table[i];\n+    while (head != NULL) {\n+      total_entries ++;\n+      this_chain_length ++;\n+      if (head->size() == 0) {\n+        empty_entries ++;\n@@ -295,1 +223,5 @@\n-      longest_chain_length = MAX2(longest_chain_length, lengths[i]);\n+      const int callstack_depth = head->peek()->call_stack()->frames();\n+      assert(callstack_depth >= 0 && callstack_depth <= NMT_TrackingStackDepth,\n+             \"Sanity (%d)\", callstack_depth);\n+      stack_depth_distribution[callstack_depth] ++;\n+      head = head->next();\n@@ -297,0 +229,2 @@\n+    lengths[i] = this_chain_length;\n+  }\n@@ -298,3 +232,15 @@\n-    st->print_cr(\"Hash distribution:\");\n-    if (chain_length_distribution[0] == 0) {\n-      st->print_cr(\"no empty buckets.\");\n+  st->print_cr(\"Malloc allocation site table:\");\n+  st->print_cr(\"\\tTotal entries: %d\", total_entries);\n+  st->print_cr(\"\\tEmpty entries: %d (%2.2f%%)\", empty_entries, ((float)empty_entries * 100) \/ total_entries);\n+  st->cr();\n+\n+  \/\/ We report the hash distribution (chain length distribution) of the n shortest chains\n+  \/\/  - under the assumption that this usually contains all lengths. Reporting threshold\n+  \/\/  is 20, and the expected avg chain length is 5..6 (see table size).\n+  static const int chain_length_threshold = 20;\n+  int chain_length_distribution[chain_length_threshold] = { 0 };\n+  int over_threshold = 0;\n+  int longest_chain_length = 0;\n+  for (int i = 0; i < table_size; i ++) {\n+    if (lengths[i] >= chain_length_threshold) {\n+      over_threshold ++;\n@@ -302,4 +248,1 @@\n-      st->print_cr(\"%d buckets are empty.\", chain_length_distribution[0]);\n-    }\n-    for (int len = 1; len < MIN2(longest_chain_length + 1, chain_length_threshold); len ++) {\n-      st->print_cr(\"%2d %s: %d.\", len, (len == 1 ? \"  entry\" : \"entries\"), chain_length_distribution[len]);\n+      chain_length_distribution[lengths[i]] ++;\n@@ -307,5 +250,2 @@\n-    if (longest_chain_length >= chain_length_threshold) {\n-      st->print_cr(\">=%2d entries: %d.\", chain_length_threshold, over_threshold);\n-    }\n-    st->print_cr(\"most entries: %d.\", longest_chain_length);\n-    st->cr();\n+    longest_chain_length = MAX2(longest_chain_length, lengths[i]);\n+  }\n@@ -313,7 +253,14 @@\n-    st->print_cr(\"Call stack depth distribution:\");\n-    for (int i = 0; i <= NMT_TrackingStackDepth; i ++) {\n-      st->print_cr(\"\\t%d: %d\", i, stack_depth_distribution[i]);\n-    }\n-    st->cr();\n-  } \/\/ lock\n-}\n+  st->print_cr(\"Hash distribution:\");\n+  if (chain_length_distribution[0] == 0) {\n+    st->print_cr(\"no empty buckets.\");\n+  } else {\n+    st->print_cr(\"%d buckets are empty.\", chain_length_distribution[0]);\n+  }\n+  for (int len = 1; len < MIN2(longest_chain_length + 1, chain_length_threshold); len ++) {\n+    st->print_cr(\"%2d %s: %d.\", len, (len == 1 ? \"  entry\" : \"entries\"), chain_length_distribution[len]);\n+  }\n+  if (longest_chain_length >= chain_length_threshold) {\n+    st->print_cr(\">=%2d entries: %d.\", chain_length_threshold, over_threshold);\n+  }\n+  st->print_cr(\"most entries: %d.\", longest_chain_length);\n+  st->cr();\n@@ -321,0 +268,6 @@\n+  st->print_cr(\"Call stack depth distribution:\");\n+  for (int i = 0; i <= NMT_TrackingStackDepth; i ++) {\n+    st->print_cr(\"\\t%d: %d\", i, stack_depth_distribution[i]);\n+  }\n+  st->cr();\n+}\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.cpp","additions":64,"deletions":111,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,43 +121,0 @@\n-  \/\/ This is a very special lock, that allows multiple shared accesses (sharedLock), but\n-  \/\/ once exclusive access (exclusiveLock) is requested, all shared accesses are\n-  \/\/ rejected forever.\n-  class AccessLock : public StackObj {\n-    enum LockState {\n-      NoLock,\n-      SharedLock,\n-      ExclusiveLock\n-    };\n-\n-   private:\n-    \/\/ A very large negative number. The only possibility to \"overflow\"\n-    \/\/ this number is when there are more than -min_jint threads in\n-    \/\/ this process, which is not going to happen in foreseeable future.\n-    const static int _MAGIC_ = min_jint;\n-\n-    LockState      _lock_state;\n-    volatile int*  _lock;\n-   public:\n-    AccessLock(volatile int* lock) :\n-      _lock_state(NoLock), _lock(lock) {\n-    }\n-\n-    ~AccessLock() {\n-      if (_lock_state == SharedLock) {\n-        Atomic::dec(_lock);\n-      }\n-    }\n-    \/\/ Acquire shared lock.\n-    \/\/ Return true if shared access is granted.\n-    inline bool sharedLock() {\n-      jint res = Atomic::add(_lock, 1);\n-      if (res < 0) {\n-        Atomic::dec(_lock);\n-        return false;\n-      }\n-      _lock_state = SharedLock;\n-      return true;\n-    }\n-    \/\/ Acquire exclusive lock\n-    void exclusiveLock();\n- };\n-\n@@ -166,3 +123,0 @@\n-  static void shutdown();\n-\n-  NOT_PRODUCT(static int access_peak_count() { return _peak_count; })\n@@ -177,8 +131,4 @@\n-    AccessLock locker(&_access_count);\n-    if (locker.sharedLock()) {\n-      NOT_PRODUCT(_peak_count = MAX2(_peak_count, _access_count);)\n-      MallocSite* site = malloc_site(bucket_idx, pos_idx);\n-      if (site != NULL) {\n-        stack = *site->call_stack();\n-        return true;\n-      }\n+    MallocSite* site = malloc_site(bucket_idx, pos_idx);\n+    if (site != NULL) {\n+      stack = *site->call_stack();\n+      return true;\n@@ -198,8 +148,3 @@\n-    AccessLock locker(&_access_count);\n-    if (locker.sharedLock()) {\n-      NOT_PRODUCT(_peak_count = MAX2(_peak_count, _access_count);)\n-      MallocSite* site = lookup_or_add(stack, bucket_idx, pos_idx, flags);\n-      if (site != NULL) site->allocate(size);\n-      return site != NULL;\n-    }\n-    return false;\n+    MallocSite* site = lookup_or_add(stack, bucket_idx, pos_idx, flags);\n+    if (site != NULL) site->allocate(size);\n+    return site != NULL;\n@@ -211,8 +156,4 @@\n-    AccessLock locker(&_access_count);\n-    if (locker.sharedLock()) {\n-      NOT_PRODUCT(_peak_count = MAX2(_peak_count, _access_count);)\n-      MallocSite* site = malloc_site(bucket_idx, pos_idx);\n-      if (site != NULL) {\n-        site->deallocate(size);\n-        return true;\n-      }\n+    MallocSite* site = malloc_site(bucket_idx, pos_idx);\n+    if (site != NULL) {\n+      site->deallocate(size);\n+      return true;\n@@ -254,3 +195,0 @@\n-  \/\/ Counter for counting concurrent access\n-  static volatile int                _access_count;\n-\n@@ -262,3 +200,0 @@\n-\n-\n-  NOT_PRODUCT(static int     _peak_count;)\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":12,"deletions":77,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -116,2 +116,1 @@\n-  \/\/ Tracking already shutdown, no housekeeping is needed anymore\n-  if (MemTracker::tracking_level() <= NMT_minimal) return;\n+  assert(MemTracker::enabled(), \"Sanity\");\n@@ -225,9 +224,1 @@\n-  bool ret = MallocSiteTable::allocation_at(stack, size, bucket_idx, pos_idx, flags);\n-\n-  \/\/ Something went wrong, could be OOM or overflow malloc site table.\n-  \/\/ We want to keep tracking data under OOM circumstance, so transition to\n-  \/\/ summary tracking.\n-  if (!ret) {\n-    MemTracker::transition_to(NMT_summary);\n-  }\n-  return ret;\n+  return MallocSiteTable::allocation_at(stack, size, bucket_idx, pos_idx, flags);\n@@ -251,12 +242,0 @@\n-bool MallocTracker::transition(NMT_TrackingLevel from, NMT_TrackingLevel to) {\n-  assert(from != NMT_off, \"Can not transition from off state\");\n-  assert(to != NMT_off, \"Can not transition to off state\");\n-  assert (from != NMT_minimal, \"cannot transition from minimal state\");\n-\n-  if (from == NMT_detail) {\n-    assert(to == NMT_minimal || to == NMT_summary, \"Just check\");\n-    MallocSiteTable::shutdown();\n-  }\n-  return true;\n-}\n-\n@@ -284,1 +263,1 @@\n-  if (level > NMT_minimal) {\n+  if (level >= NMT_summary) {\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-\n@@ -336,4 +335,0 @@\n-    if (level == NMT_minimal) {\n-      return;\n-    }\n-\n@@ -389,2 +384,0 @@\n-  static bool transition(NMT_TrackingLevel from, NMT_TrackingLevel to);\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -111,32 +111,0 @@\n-\n-\/\/ Shutdown can only be issued via JCmd, and NMT JCmd is serialized by lock\n-void MemTracker::shutdown() {\n-  \/\/ We can only shutdown NMT to minimal tracking level if it is ever on.\n-  if (tracking_level() > NMT_minimal) {\n-    transition_to(NMT_minimal);\n-  }\n-}\n-\n-bool MemTracker::transition_to(NMT_TrackingLevel level) {\n-  NMT_TrackingLevel current_level = tracking_level();\n-\n-  assert(level != NMT_off || current_level == NMT_off, \"Cannot transition NMT to off\");\n-\n-  if (current_level == level) {\n-    return true;\n-  } else if (current_level > level) {\n-    \/\/ Downgrade tracking level, we want to lower the tracking level first\n-    _tracking_level = level;\n-    \/\/ Make _tracking_level visible immediately.\n-    OrderAccess::fence();\n-    VirtualMemoryTracker::transition(current_level, level);\n-    MallocTracker::transition(current_level, level);\n-    ThreadStackTracker::transition(current_level, level);\n-  } else {\n-    \/\/ Upgrading tracking level is not supported and has never been supported.\n-    \/\/ Allocating and deallocating malloc tracking structures is not thread safe and\n-    \/\/ leads to inconsistencies unless a lot coarser locks are added.\n-  }\n-  return true;\n-}\n-\n@@ -145,1 +113,1 @@\n-  if (tracking_level() >= NMT_summary) {\n+  if (enabled()) {\n@@ -161,3 +129,2 @@\n-    NMT_TrackingLevel level = tracking_level();\n-    if (level >= NMT_summary) {\n-      report(level == NMT_summary, output, 1);\n+    if (enabled()) {\n+      report(tracking_level() == NMT_summary, output, 1);\n@@ -192,1 +159,0 @@\n-  NOT_PRODUCT(out->print_cr(\"Peak concurrent access: %d\", MallocSiteTable::access_peak_count());)\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":3,"deletions":37,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  static inline void shutdown() { }\n+  static inline bool enabled() { return false; }\n@@ -140,8 +140,3 @@\n-  \/\/ Shutdown native memory tracking.\n-  \/\/ This transitions the tracking level:\n-  \/\/  summary -> minimal\n-  \/\/  detail  -> minimal\n-  static void shutdown();\n-\n-  \/\/ Transition the tracking level to specified level\n-  static bool transition_to(NMT_TrackingLevel level);\n+  static inline bool enabled() {\n+    return _tracking_level >= NMT_summary;\n+  }\n@@ -183,1 +178,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n@@ -189,1 +184,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n@@ -196,1 +191,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n@@ -206,1 +201,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n@@ -209,2 +204,0 @@\n-      \/\/ Recheck to avoid potential racing during NMT shutdown\n-      if (tracking_level() < NMT_summary) return;\n@@ -218,1 +211,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n@@ -221,1 +214,0 @@\n-      if (tracking_level() < NMT_summary) return;\n@@ -230,1 +222,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n@@ -233,1 +225,0 @@\n-      if (tracking_level() < NMT_summary) return;\n@@ -246,1 +237,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n@@ -249,2 +240,0 @@\n-      \/\/ Recheck to avoid potential racing during NMT shutdown\n-      if (tracking_level() < NMT_summary) return;\n@@ -257,1 +246,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n@@ -260,1 +249,0 @@\n-      if (tracking_level() < NMT_summary) return;\n@@ -267,1 +255,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n@@ -275,1 +263,1 @@\n-    if (tracking_level() < NMT_summary) return;\n+    if (!enabled()) return;\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":14,"deletions":26,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+STATIC_ASSERT(NMT_off > NMT_unknown);\n+STATIC_ASSERT(NMT_summary > NMT_off);\n+STATIC_ASSERT(NMT_detail > NMT_summary);\n+\n@@ -35,1 +39,0 @@\n-\n@@ -67,1 +70,0 @@\n-    case NMT_minimal: return \"minimal\"; break;\n","filename":"src\/hotspot\/share\/services\/nmtCommon.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,4 +44,0 @@\n-\/\/ \"minimal\": after shutdown - NMT had been on at some point but has been switched off\n-\/\/             - nothing is tracked\n-\/\/             - malloc headers are allocated but not initialized not used\n-\/\/\n@@ -62,8 +58,0 @@\n-\/\/ Valid state transitions:\n-\/\/\n-\/\/ unknown ----> off\n-\/\/          |\n-\/\/          |--> summary --\n-\/\/          |              |\n-\/\/          |--> detail  --+--> minimal\n-\/\/\n@@ -73,1 +61,1 @@\n-\/\/ unknown < off < minimal < summary < detail\n+\/\/ unknown < off < summary < detail\n@@ -76,5 +64,4 @@\n-  NMT_unknown = 0,\n-  NMT_off     = 1,\n-  NMT_minimal = 2,\n-  NMT_summary = 3,\n-  NMT_detail  = 4\n+  NMT_unknown,\n+  NMT_off,\n+  NMT_summary,\n+  NMT_detail\n","filename":"src\/hotspot\/share\/services\/nmtCommon.hpp","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n@@ -45,13 +45,0 @@\n-bool ThreadStackTracker::transition(NMT_TrackingLevel from, NMT_TrackingLevel to) {\n-  assert (from != NMT_minimal, \"cannot convert from the lowest tracking level to anything\");\n-  if (to == NMT_minimal) {\n-    assert(from == NMT_summary || from == NMT_detail, \"Just check\");\n-    ThreadCritical tc;\n-    if (_simple_thread_stacks != NULL) {\n-      delete _simple_thread_stacks;\n-      _simple_thread_stacks = NULL;\n-    }\n-  }\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n@@ -75,1 +75,0 @@\n-  static bool transition(NMT_TrackingLevel from, NMT_TrackingLevel to);\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -674,17 +674,0 @@\n-\n-\/\/ Transition virtual memory tracking level.\n-bool VirtualMemoryTracker::transition(NMT_TrackingLevel from, NMT_TrackingLevel to) {\n-  assert (from != NMT_minimal, \"cannot convert from the lowest tracking level to anything\");\n-  if (to == NMT_minimal) {\n-    assert(from == NMT_summary || from == NMT_detail, \"Just check\");\n-    \/\/ Clean up virtual memory tracking data structures.\n-    ThreadCritical tc;\n-    \/\/ Check for potential race with other thread calling transition\n-    if (_reserved_regions != NULL) {\n-      delete _reserved_regions;\n-      _reserved_regions = NULL;\n-    }\n-  }\n-\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,2 +390,0 @@\n-  static bool transition(NMT_TrackingLevel from, NMT_TrackingLevel to);\n-\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8059100\n- * @summary Test that you can decrease NMT tracking level but not increase it.\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail ChangeTrackingLevel\n- *\/\n-\n-import sun.hotspot.WhiteBox;\n-\n-public class ChangeTrackingLevel {\n-\n-    public static WhiteBox wb = WhiteBox.getWhiteBox();\n-    public static void main(String args[]) throws Exception {\n-        boolean testChangeLevel = wb.NMTChangeTrackingLevel();\n-        if (testChangeLevel) {\n-            System.out.println(\"NMT level change test passed.\");\n-        } else {\n-            \/\/ it also fails if the VM asserts.\n-            throw new RuntimeException(\"NMT level change test failed\");\n-        }\n-    }\n-};\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/ChangeTrackingLevel.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -228,1 +228,0 @@\n-  public native boolean NMTChangeTrackingLevel();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-  public native boolean NMTChangeTrackingLevel();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}