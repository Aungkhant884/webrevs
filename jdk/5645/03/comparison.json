{"files":[{"patch":"@@ -342,1 +342,1 @@\n-            if (n > 0 ) {\n+            if (n > 0) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,4 +28,10 @@\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.nio.channels.spi.*;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.IllegalBlockingModeException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.channels.SelectableChannel;\n+import java.util.Arrays;\n@@ -33,0 +39,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -46,0 +53,1 @@\n+    private static final int DEFAULT_BUFFER_SIZE = 8192;\n@@ -51,2 +59,1 @@\n-        if (ch instanceof SelectableChannel) {\n-            SelectableChannel sc = (SelectableChannel)ch;\n+        if (ch instanceof SelectableChannel sc) {\n@@ -110,0 +117,86 @@\n+    @Override\n+    public byte[] readAllBytes() throws IOException {\n+        if (!(ch instanceof SeekableByteChannel sbc))\n+            return super.readAllBytes();\n+\n+        long length = sbc.size();\n+        long position = sbc.position();\n+        long size = length - position;\n+\n+        if (length <= 0 || size <= 0)\n+            return super.readAllBytes();\n+\n+        if (size > (long) Integer.MAX_VALUE) {\n+            String msg =\n+                String.format(\"Required array size too large: %d = %d - %d\",\n+                    size, length, position);\n+            throw new OutOfMemoryError(msg);\n+        }\n+\n+        int capacity = (int)size;\n+        byte[] buf = new byte[capacity];\n+\n+        int nread = 0;\n+        int n;\n+        for (;;) {\n+            \/\/ read to EOF which may read more or less than initial size, e.g.,\n+            \/\/ file is truncated while we are reading\n+            while ((n = read(buf, nread, capacity - nread)) > 0)\n+                nread += n;\n+\n+            \/\/ if last call to read() returned -1, we are done; otherwise,\n+            \/\/ try to read one more byte and if that fails we're done too\n+            if (n < 0 || (n = read()) < 0)\n+                break;\n+\n+            \/\/ one more byte was read; need to allocate a larger buffer\n+            capacity = Math.max(ArraysSupport.newLength(capacity,\n+                                                        1,         \/\/ min growth\n+                                                        capacity), \/\/ pref growth\n+                                DEFAULT_BUFFER_SIZE);\n+            buf = Arrays.copyOf(buf, capacity);\n+            buf[nread++] = (byte)n;\n+        }\n+        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);\n+    }\n+\n+    @Override\n+    public byte[] readNBytes(int len) throws IOException {\n+        if (len < 0)\n+            throw new IllegalArgumentException(\"len < 0\");\n+        if (len == 0)\n+            return new byte[0];\n+\n+        if (!(ch instanceof SeekableByteChannel sbc))\n+            return super.readAllBytes();\n+\n+        long length = sbc.size();\n+        long position = sbc.position();\n+        long size = length - position;\n+\n+        if (length <= 0 || size <= 0)\n+            return super.readNBytes(len);\n+\n+        int capacity = (int)Math.min(len, size);\n+        byte[] buf = new byte[capacity];\n+\n+        int remaining = capacity;\n+        int nread = 0;\n+        int n;\n+        do {\n+            n = read(buf, nread, remaining);\n+            if (n > 0) {\n+                nread += n;\n+                remaining -= n;\n+            } else if (n == 0) {\n+                \/\/ Block until a byte is read or EOF is detected\n+                byte b = (byte)read();\n+                if (b == -1 )\n+                    break;\n+                buf[nread++] = b;\n+                remaining--;\n+            }\n+        } while (n >= 0 && remaining > 0);\n+        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);\n+    }\n+\n@@ -112,2 +205,1 @@\n-        if (ch instanceof SeekableByteChannel) {\n-            SeekableByteChannel sbc = (SeekableByteChannel)ch;\n+        if (ch instanceof SeekableByteChannel sbc) {\n@@ -122,2 +214,1 @@\n-        if (ch instanceof SeekableByteChannel) {\n-            SeekableByteChannel sbc = (SeekableByteChannel)ch;\n+        if (ch instanceof SeekableByteChannel sbc) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":101,"deletions":10,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268435\n+ * @summary Verify ChannelInputStream methods readAllBytes and readNBytes\n+ * @library ..\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @modules java.base\/jdk.internal.util\n+ * @run testng\/othervm -Xmx8G ReadXBytes\n+ * @key randomness\n+ *\/\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import static java.nio.file.StandardOpenOption.READ;\n+import java.util.Random;\n+import jdk.internal.util.ArraysSupport;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import org.testng.Assert;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class ReadXBytes {\n+\n+    private static final Random RAND = RandomFactory.getRandom();\n+\n+    private static final int  BIG_LENGTH = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n+    private static final long HUGE_LENGTH = Integer.MAX_VALUE + 27L;\n+\n+    \/\/ --- Framework ---\n+\n+    \/\/ Creates a temporary file of a specified length with undefined content\n+    static Path createFile(long length) throws IOException {\n+        File file = File.createTempFile(\"foo\", \".bar\");\n+        file.deleteOnExit();\n+        try (RandomAccessFile raf = new RandomAccessFile(file, \"rw\")) {\n+            raf.setLength(length);\n+        }\n+        return file.toPath();\n+    }\n+\n+    \/\/ Creates a temporary file of a specified length with random content\n+    static Path createFileWithRandomContent(long length) throws IOException {\n+        Path file = createFile(length);\n+        try (RandomAccessFile raf = new RandomAccessFile(file.toFile(), \"rw\")) {\n+            long written = 0L;\n+            int bufLength = Math.min(32768, (int)Math.min(length, BIG_LENGTH));\n+            byte[] buf = new byte[bufLength];\n+            while (written < length) {\n+                RAND.nextBytes(buf);\n+                int len = (int)Math.min(bufLength, length - written);\n+                raf.write(buf, 0, len);\n+                written += len;\n+            }\n+        }\n+        return file;\n+    }\n+\n+    \/\/ Creates a file of a specified length\n+    @FunctionalInterface\n+    interface FileCreator {\n+        Path create(long length) throws IOException;\n+    }\n+\n+    \/\/ Performs a test for checking edge cases\n+    @FunctionalInterface\n+    interface EdgeTest {\n+        void test(long length, InputStream source) throws IOException;\n+    }\n+\n+    \/\/ Performs a test for evaluating correctness of content\n+    @FunctionalInterface\n+    interface DataTest {\n+        void test(long length, InputStream source, InputStream reference)\n+            throws IOException;\n+    }\n+\n+    \/\/ Construct for testing zero length, EOF, and IAE\n+    public void edgeTest(long length, FileCreator c, EdgeTest f)\n+        throws IOException {\n+        Path file = c.create(length);\n+        try (FileChannel fc = FileChannel.open(file, READ);\n+             InputStream cis = Channels.newInputStream(fc)) {\n+            f.test(length, cis);\n+        } finally {\n+            Files.delete(file);\n+        }\n+    }\n+\n+    \/\/ Construct for testing correctness of content\n+    public void dataTest(long length, FileCreator c, DataTest f)\n+        throws IOException {\n+        Path file = c.create(length);\n+        try (FileInputStream fis = new FileInputStream(file.toFile());\n+             FileChannel fc = FileChannel.open(file, READ);\n+             InputStream cis = Channels.newInputStream(fc)) {\n+            f.test(length, cis, fis);\n+        } finally {\n+            Files.delete(file);\n+        }\n+    }\n+\n+    \/\/ --- readAllBytes tests ---\n+\n+    \/\/ Verifies readAllBytes() behavior for an empty file\n+    @Test\n+    public void readAllBytesFromEmptyFile() throws IOException {\n+        edgeTest(0L, (length) -> createFile(length),\n+            (length, cis) -> {\n+                byte[] bytes = cis.readAllBytes();\n+                assertNotNull(bytes);\n+                assertEquals(bytes.length, 0L);\n+            }\n+        );\n+    }\n+\n+    \/\/ Verifies readAllBytes() behavior at EOF\n+    @Test\n+    public void readAllBytesAtEOF() throws IOException {\n+        edgeTest(RAND.nextInt(Short.MAX_VALUE), (length) -> createFile(length),\n+            (length, cis) -> {\n+                cis.skipNBytes(length);\n+                byte[] bytes = cis.readAllBytes();\n+                assertNotNull(bytes);\n+                assertEquals(bytes.length, 0);\n+            }\n+        );\n+    }\n+\n+    \/\/ Verifies readAllBytes() behavior for a maximal length source\n+    @Test\n+    public void readAllBytesFromMaxLengthFile() throws IOException {\n+        dataTest(BIG_LENGTH, (length) -> createFileWithRandomContent(length),\n+            (length, cis, fis) -> {\n+                byte[] cisBytes = cis.readAllBytes();\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, (long)length);\n+                byte[] fisBytes = fis.readAllBytes();\n+                assertEquals(cisBytes, fisBytes);\n+            }\n+        );\n+    }\n+\n+    \/\/ Verifies readAllBytes() throws OOME if the source is too large\n+    @Test(expectedExceptions = OutOfMemoryError.class)\n+    public void readAllBytesFromBeyondMaxLengthFile() throws IOException {\n+        dataTest(HUGE_LENGTH, (length) -> createFile(length),\n+            (length, cis, fis) -> {\n+                byte[] cisBytes = cis.readAllBytes();\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, (long)length);\n+                byte[] fisBytes = fis.readAllBytes();\n+                assertEquals(cisBytes, fisBytes);\n+            }\n+        );\n+    }\n+\n+    \/\/ Provides an array of lengths\n+    @DataProvider\n+    public Object[][] lengthProvider() throws IOException {\n+        return new Object[][] {\n+            {1 + RAND.nextInt(1)},\n+            {1 + RAND.nextInt(Byte.MAX_VALUE)},\n+            {1 + RAND.nextInt(Short.MAX_VALUE)},\n+            {1 + RAND.nextInt(1_000_000)},\n+            {1 + RAND.nextInt(BIG_LENGTH)}\n+        };\n+    }\n+\n+    \/\/ Verifies readAllBytes() accuracy for random lengths and initial positions\n+    @Test(dataProvider = \"lengthProvider\")\n+    public void readAllBytes(int len) throws IOException {\n+        dataTest(len, (length) -> createFileWithRandomContent(length),\n+            (length, cis, fis) -> {\n+                long position = RAND.nextInt(Math.toIntExact(length));\n+                cis.skipNBytes(position);\n+                byte[] cisBytes = cis.readAllBytes();\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, length - position);\n+                fis.skipNBytes(position);\n+                byte[] fisBytes = fis.readAllBytes();\n+                assertEquals(cisBytes, fisBytes);\n+            }\n+        );\n+    }\n+\n+    \/\/ --- readNBytes tests ---\n+\n+    \/\/ Verifies readNBytes() behavior for a negative length\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void readNBytesWithNegativeLength() throws IOException {\n+        edgeTest(0L, (length) -> createFile(length),\n+            (length, cis) -> {\n+                byte[] bytes = cis.readNBytes(-1);\n+                assertNotNull(bytes);\n+                assertEquals(bytes.length, (long)length);\n+            }\n+        );\n+    }\n+\n+    \/\/ Verifies readNBytes() for an empty file\n+    @Test\n+    public void readNBytesFromEmptyFile() throws IOException {\n+        edgeTest(0L, (length) -> createFile(length),\n+            (length, cis) -> {\n+                byte[] bytes = cis.readNBytes(1);\n+                assertNotNull(bytes);\n+                assertEquals(bytes.length, 0);\n+            }\n+        );\n+    }\n+\n+    \/\/ Verifies readNBytes() behavior at EOF\n+    @Test\n+    public void readNBytesAtEOF() throws IOException {\n+        edgeTest(RAND.nextInt(Short.MAX_VALUE), (length) -> createFile(length),\n+            (length, cis) -> {\n+                cis.skipNBytes(length);\n+                byte[] bytes = cis.readNBytes(1);\n+                assertNotNull(bytes);\n+                assertEquals(bytes.length, 0);\n+            }\n+        );\n+    }\n+\n+    \/\/ Verifies readNBytes() behavior for a maximal length source\n+    @Test\n+    public void readNBytesFromMaxLengthFile() throws IOException {\n+        dataTest(BIG_LENGTH, (length) -> createFileWithRandomContent(length),\n+            (length, cis, fis) -> {\n+                byte[] cisBytes = cis.readNBytes(BIG_LENGTH);\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, (long)length);\n+                byte[] fisBytes = fis.readNBytes(BIG_LENGTH);\n+                assertEquals(cisBytes, fisBytes);\n+            }\n+        );\n+    }\n+\n+    \/\/ Verifies readNBytes() beyond the maximum length source\n+    @Test\n+    public void readNBytesFromBeyondMaxLengthFile() throws IOException {\n+        dataTest(HUGE_LENGTH, (length) -> createFileWithRandomContent(length),\n+            (length, cis, fis) -> {\n+                assertTrue(BIG_LENGTH < length, length + \" >= \" + HUGE_LENGTH);\n+                int n = Math.toIntExact(length - BIG_LENGTH);\n+                cis.skipNBytes(BIG_LENGTH);\n+                byte[] cisBytes = cis.readNBytes(n);\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, n);\n+                fis.skipNBytes(BIG_LENGTH);\n+                byte[] fisBytes = fis.readNBytes(n);\n+                assertEquals(cisBytes, fisBytes);\n+            }\n+        );\n+    }\n+\n+    \/\/ Verifies readNBytes() accuracy for random lengths and initial positions\n+    @Test(dataProvider = \"lengthProvider\")\n+    public void readNBytes(int len) throws IOException {\n+        dataTest(len, (length) -> createFileWithRandomContent(length),\n+            (length, cis, fis) -> {\n+                int ilen = Math.toIntExact(len);\n+                int position = RAND.nextInt(ilen);\n+                int n = RAND.nextInt(ilen - position);\n+                cis.skipNBytes(position);\n+                byte[] cisBytes = cis.readNBytes(n);\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, n);\n+                fis.skipNBytes(position);\n+                byte[] fisBytes = fis.readNBytes(n);\n+                assertEquals(cisBytes, fisBytes);\n+            }\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/ReadXBytes.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"}]}