{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Arrays;\n@@ -33,0 +34,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -46,0 +48,1 @@\n+    private static final int DEFAULT_BUFFER_SIZE = 8192;\n@@ -110,0 +113,88 @@\n+    @Override\n+    public byte[] readAllBytes() throws IOException {\n+        if (!(ch instanceof SeekableByteChannel))\n+            return super.readAllBytes();\n+        SeekableByteChannel sbc = (SeekableByteChannel)ch;\n+\n+        long length = sbc.size();\n+        long position = sbc.position();\n+        long size = length - position;\n+\n+        if (length <= 0 || size <= 0)\n+            return super.readAllBytes();\n+\n+        if (size > (long) Integer.MAX_VALUE) {\n+            String msg =\n+                String.format(\"Required array size too large: %d = %d - %d\",\n+                    size, length, position);\n+            throw new OutOfMemoryError(msg);\n+        }\n+\n+        int capacity = (int)size;\n+        byte[] buf = new byte[capacity];\n+\n+        int nread = 0;\n+        int n;\n+        for (;;) {\n+            \/\/ read to EOF which may read more or less than initial size, e.g.,\n+            \/\/ file is truncated while we are reading\n+            while ((n = read(buf, nread, capacity - nread)) > 0)\n+                nread += n;\n+\n+            \/\/ if last call to read() returned -1, we are done; otherwise,\n+            \/\/ try to read one more byte and if that fails we're done too\n+            if (n < 0 || (n = read()) < 0)\n+                break;\n+\n+            \/\/ one more byte was read; need to allocate a larger buffer\n+            capacity = Math.max(ArraysSupport.newLength(capacity,\n+                                                        1,         \/\/ min growth\n+                                                        capacity), \/\/ pref growth\n+                                DEFAULT_BUFFER_SIZE);\n+            buf = Arrays.copyOf(buf, capacity);\n+            buf[nread++] = (byte)n;\n+        }\n+        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);\n+    }\n+\n+    @Override\n+    public byte[] readNBytes(int len) throws IOException {\n+        if (len < 0)\n+            throw new IllegalArgumentException(\"len < 0\");\n+        if (len == 0)\n+            return new byte[0];\n+\n+        if (!(ch instanceof SeekableByteChannel))\n+            return super.readAllBytes();\n+        SeekableByteChannel sbc = (SeekableByteChannel)ch;\n+\n+        long length = sbc.size();\n+        long position = sbc.position();\n+        long size = length - position;\n+\n+        if (length <= 0 || size <= 0)\n+            return super.readNBytes(len);\n+\n+        int capacity = (int)Math.min(len, size);\n+        byte[] buf = new byte[capacity];\n+\n+        int remaining = capacity;\n+        int nread = 0;\n+        int n;\n+        do {\n+            n = read(buf, nread, remaining);\n+            if (n > 0 ) {\n+                nread += n;\n+                remaining -= n;\n+            } else if (n == 0) {\n+                \/\/ Block until a byte is read or EOF is detected\n+                byte b = (byte)read();\n+                if (b == -1 )\n+                    break;\n+                buf[nread++] = b;\n+                remaining--;\n+            }\n+        } while (n >= 0 && remaining > 0);\n+        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4417152 4481572 6248930 6725399 6884800 8220477\n+ * @bug 4417152 4481572 6248930 6725399 6884800 8220477 8268435\n@@ -27,0 +27,5 @@\n+ * @library ..\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main Basic\n+ * @key randomness\n@@ -33,0 +38,4 @@\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n@@ -44,0 +53,2 @@\n+    static final Random RAND = RandomFactory.getRandom();\n+\n@@ -252,14 +263,46 @@\n-        FileInputStream fis = new FileInputStream(blah);\n-        FileChannel fc = fis.getChannel();\n-        InputStream is = Channels.newInputStream(fc);\n-        int messageSize = message.length() * ITERATIONS * 3 + 1;\n-        byte bb[] = new byte[messageSize];\n-\n-        int bytesRead = 0;\n-        int totalRead = 0;\n-        while (bytesRead != -1) {\n-            totalRead += bytesRead;\n-            long rem = Math.min(fc.size() - totalRead, (long)Integer.MAX_VALUE);\n-            if (is.available() != (int)rem)\n-                throw new RuntimeException(\"available not useful or not maximally useful\");\n-            bytesRead = is.read(bb, totalRead, messageSize - totalRead);\n+        try (FileInputStream fis = new FileInputStream(blah);\n+             FileChannel fc = fis.getChannel();\n+             InputStream is = Channels.newInputStream(fc)) {\n+            int messageSize = message.length() * ITERATIONS * 3 + 1;\n+            byte bb[] = new byte[messageSize];\n+\n+            int bytesRead = 0;\n+            int totalRead = 0;\n+            while (bytesRead != -1) {\n+                totalRead += bytesRead;\n+                long rem = Math.min(fc.size() - totalRead, (long)Integer.MAX_VALUE);\n+                if (is.available() != (int)rem)\n+                    throw new RuntimeException\n+                        (\"available() not useful or not maximally useful\");\n+                bytesRead = is.read(bb, totalRead, messageSize - totalRead);\n+            }\n+            if (is.available() != 0)\n+                throw new RuntimeException(\"available() should return 0 at EOF\");\n+\n+            String result = new String(bb, 0, totalRead, encoding);\n+            int len = message.length();\n+            for (int i=0; i<ITERATIONS; i++) {\n+                String segment = result.substring(i++ * len, i * len);\n+                if (!segment.equals(message))\n+                    throw new RuntimeException(\"Test failed\");\n+            }\n+\n+            \/\/ Test readAllBytes(): result should equal prefix of bb\n+            fc.position(0);\n+            byte[] allBytes = is.readAllBytes();\n+            final int toIndex = Math.min(allBytes.length, bb.length);\n+            assert toIndex == allBytes.length;\n+            int idx = Arrays.mismatch(bb, 0, toIndex, allBytes, 0, toIndex);\n+            if (idx != -1)\n+                throw new RuntimeException(\"Mismatch at relative index \" + idx);\n+\n+            \/\/ Test readNBytes(): result should equal sub-range of allBytes\n+            final int half = allBytes.length \/ 2;\n+            int p0 = RAND.nextInt(half);\n+            int p1 = half + RAND.nextInt(allBytes.length - half);\n+            fc.position(p0);\n+            len = p1 - p0;\n+            byte[] nBytes = is.readNBytes(len);\n+            idx = Arrays.mismatch(allBytes, p0, p1, nBytes, 0, len);\n+            if (idx != -1)\n+                throw new RuntimeException(\"Mismatch at relative index \" + idx);\n@@ -267,12 +310,0 @@\n-        if (is.available() != 0)\n-           throw new RuntimeException(\"available() should return 0 at EOF\");\n-\n-        String result = new String(bb, 0, totalRead, encoding);\n-        int len = message.length();\n-        for (int i=0; i<ITERATIONS; i++) {\n-            String segment = result.substring(i++ * len, i * len);\n-            if (!segment.equals(message))\n-                throw new RuntimeException(\"Test failed\");\n-        }\n-        is.close();\n-        fis.close();\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/Basic.java","additions":59,"deletions":28,"binary":false,"changes":87,"status":"modified"}]}