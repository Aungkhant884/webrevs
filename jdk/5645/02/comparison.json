{"files":[{"patch":"@@ -342,1 +342,1 @@\n-            if (n > 0 ) {\n+            if (n > 0) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,4 +28,10 @@\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.nio.channels.spi.*;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.IllegalBlockingModeException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.channels.SelectableChannel;\n+import java.util.Arrays;\n@@ -33,0 +39,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -46,0 +53,1 @@\n+    private static final int DEFAULT_BUFFER_SIZE = 8192;\n@@ -51,2 +59,1 @@\n-        if (ch instanceof SelectableChannel) {\n-            SelectableChannel sc = (SelectableChannel)ch;\n+        if (ch instanceof SelectableChannel sc) {\n@@ -110,0 +117,86 @@\n+    @Override\n+    public byte[] readAllBytes() throws IOException {\n+        if (!(ch instanceof SeekableByteChannel sbc))\n+            return super.readAllBytes();\n+\n+        long length = sbc.size();\n+        long position = sbc.position();\n+        long size = length - position;\n+\n+        if (length <= 0 || size <= 0)\n+            return super.readAllBytes();\n+\n+        if (size > (long) Integer.MAX_VALUE) {\n+            String msg =\n+                String.format(\"Required array size too large: %d = %d - %d\",\n+                    size, length, position);\n+            throw new OutOfMemoryError(msg);\n+        }\n+\n+        int capacity = (int)size;\n+        byte[] buf = new byte[capacity];\n+\n+        int nread = 0;\n+        int n;\n+        for (;;) {\n+            \/\/ read to EOF which may read more or less than initial size, e.g.,\n+            \/\/ file is truncated while we are reading\n+            while ((n = read(buf, nread, capacity - nread)) > 0)\n+                nread += n;\n+\n+            \/\/ if last call to read() returned -1, we are done; otherwise,\n+            \/\/ try to read one more byte and if that fails we're done too\n+            if (n < 0 || (n = read()) < 0)\n+                break;\n+\n+            \/\/ one more byte was read; need to allocate a larger buffer\n+            capacity = Math.max(ArraysSupport.newLength(capacity,\n+                                                        1,         \/\/ min growth\n+                                                        capacity), \/\/ pref growth\n+                                DEFAULT_BUFFER_SIZE);\n+            buf = Arrays.copyOf(buf, capacity);\n+            buf[nread++] = (byte)n;\n+        }\n+        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);\n+    }\n+\n+    @Override\n+    public byte[] readNBytes(int len) throws IOException {\n+        if (len < 0)\n+            throw new IllegalArgumentException(\"len < 0\");\n+        if (len == 0)\n+            return new byte[0];\n+\n+        if (!(ch instanceof SeekableByteChannel sbc))\n+            return super.readAllBytes();\n+\n+        long length = sbc.size();\n+        long position = sbc.position();\n+        long size = length - position;\n+\n+        if (length <= 0 || size <= 0)\n+            return super.readNBytes(len);\n+\n+        int capacity = (int)Math.min(len, size);\n+        byte[] buf = new byte[capacity];\n+\n+        int remaining = capacity;\n+        int nread = 0;\n+        int n;\n+        do {\n+            n = read(buf, nread, remaining);\n+            if (n > 0) {\n+                nread += n;\n+                remaining -= n;\n+            } else if (n == 0) {\n+                \/\/ Block until a byte is read or EOF is detected\n+                byte b = (byte)read();\n+                if (b == -1 )\n+                    break;\n+                buf[nread++] = b;\n+                remaining--;\n+            }\n+        } while (n >= 0 && remaining > 0);\n+        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);\n+    }\n+\n@@ -112,2 +205,1 @@\n-        if (ch instanceof SeekableByteChannel) {\n-            SeekableByteChannel sbc = (SeekableByteChannel)ch;\n+        if (ch instanceof SeekableByteChannel sbc) {\n@@ -122,2 +214,1 @@\n-        if (ch instanceof SeekableByteChannel) {\n-            SeekableByteChannel sbc = (SeekableByteChannel)ch;\n+        if (ch instanceof SeekableByteChannel sbc) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":101,"deletions":10,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268435\n+ * @summary Verify ChannelInputStream methods\n+ * @library ..\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @modules java.base\/jdk.internal.util\n+ * @run testng\/othervm -Xmx6G ChannelInputStream\n+ * @key randomness\n+ *\/\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.internal.util.ArraysSupport;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import org.testng.Assert;\n+import static org.testng.Assert.*;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class ChannelInputStream {\n+\n+    static final Random RAND = RandomFactory.getRandom();\n+\n+    static File createFile(long size) throws IOException {\n+        File file = File.createTempFile(\"foo\", \".bar\");\n+        file.deleteOnExit();\n+        RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n+        raf.setLength(size);\n+        raf.close();\n+        return file;\n+    }\n+\n+    @DataProvider\n+    public Object[][] provider() throws IOException {\n+\n+        Object[][] result = new Object[][] {\n+            {createFile(0L)},\n+            {createFile(RAND.nextInt(Short.MAX_VALUE))},\n+            {createFile(ArraysSupport.SOFT_MAX_ARRAY_LENGTH)},\n+            {createFile((long)Integer.MAX_VALUE + 27)}\n+        };\n+\n+        return result;\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void readAllBytes(File file) throws IOException {\n+        try (FileInputStream fis = new FileInputStream(file);\n+             FileChannel fc = fis.getChannel();\n+             InputStream cis = Channels.newInputStream(fc)) {\n+            long size = Files.size(file.toPath());\n+            if (size == 0L) {\n+                byte[] bytes = cis.readAllBytes();\n+                assertNotNull(bytes);\n+                assertEquals(bytes.length, 0);\n+            } else if (size > Integer.MAX_VALUE) {\n+                expectThrows(OutOfMemoryError.class, () -> cis.readAllBytes());\n+            } else {\n+                byte[] fisBytes = fis.readAllBytes();\n+                fc.position(0L);\n+                byte[] cisBytes = cis.readAllBytes();\n+                assertTrue(Arrays.equals(fisBytes, cisBytes));\n+\n+                \/\/ check behavior at what should be EOF\n+                cisBytes = cis.readAllBytes();\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, 0);\n+            }\n+        } finally {\n+            file.delete();\n+        }\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void readNBytes(File file) throws IOException {\n+        try (FileInputStream fis = new FileInputStream(file);\n+             FileChannel fc = fis.getChannel();\n+             InputStream cis = Channels.newInputStream(fc)) {\n+            long size = Files.size(file.toPath());\n+            if (size == 0L) {\n+                byte[] bytes = cis.readNBytes(1);\n+                assertNotNull(bytes);\n+                assertEquals(bytes.length, 0);\n+            } else if (size > Integer.MAX_VALUE) {\n+                expectThrows(OutOfMemoryError.class,\n+                             () -> cis.readNBytes(Integer.MAX_VALUE));\n+            } else {\n+                int length = Math.toIntExact(size);\n+                int half = length \/ 2;\n+                int position = RAND.nextInt(half);\n+                int count = RAND.nextInt(length - position);\n+                fc.position(position);\n+                byte[] fisBytes = fis.readNBytes(count);\n+                fc.position(position);\n+                byte[] cisBytes = cis.readNBytes(count);\n+                assertTrue(Arrays.equals(fisBytes, cisBytes));\n+\n+                \/\/ skip to EOF and check behavior there\n+                cis.skipNBytes(length - (position + count));\n+                cisBytes = cis.readNBytes(0);\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, 0);\n+            }\n+        } finally {\n+            file.delete();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"}]}