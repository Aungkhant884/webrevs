{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4417152 4481572 6248930 6725399 6884800 8220477 8268435\n+ * @bug 4417152 4481572 6248930 6725399 6884800 8220477\n@@ -27,5 +27,0 @@\n- * @library ..\n- * @library \/test\/lib\n- * @build jdk.test.lib.RandomFactory\n- * @run main Basic\n- * @key randomness\n@@ -38,4 +33,0 @@\n-import java.util.Arrays;\n-import java.util.Random;\n-\n-import jdk.test.lib.RandomFactory;\n@@ -53,2 +44,0 @@\n-    static final Random RAND = RandomFactory.getRandom();\n-\n@@ -263,46 +252,14 @@\n-        try (FileInputStream fis = new FileInputStream(blah);\n-             FileChannel fc = fis.getChannel();\n-             InputStream is = Channels.newInputStream(fc)) {\n-            int messageSize = message.length() * ITERATIONS * 3 + 1;\n-            byte bb[] = new byte[messageSize];\n-\n-            int bytesRead = 0;\n-            int totalRead = 0;\n-            while (bytesRead != -1) {\n-                totalRead += bytesRead;\n-                long rem = Math.min(fc.size() - totalRead, (long)Integer.MAX_VALUE);\n-                if (is.available() != (int)rem)\n-                    throw new RuntimeException\n-                        (\"available() not useful or not maximally useful\");\n-                bytesRead = is.read(bb, totalRead, messageSize - totalRead);\n-            }\n-            if (is.available() != 0)\n-                throw new RuntimeException(\"available() should return 0 at EOF\");\n-\n-            String result = new String(bb, 0, totalRead, encoding);\n-            int len = message.length();\n-            for (int i=0; i<ITERATIONS; i++) {\n-                String segment = result.substring(i++ * len, i * len);\n-                if (!segment.equals(message))\n-                    throw new RuntimeException(\"Test failed\");\n-            }\n-\n-            \/\/ Test readAllBytes(): result should equal prefix of bb\n-            fc.position(0);\n-            byte[] allBytes = is.readAllBytes();\n-            final int toIndex = Math.min(allBytes.length, bb.length);\n-            assert toIndex == allBytes.length;\n-            int idx = Arrays.mismatch(bb, 0, toIndex, allBytes, 0, toIndex);\n-            if (idx != -1)\n-                throw new RuntimeException(\"Mismatch at relative index \" + idx);\n-\n-            \/\/ Test readNBytes(): result should equal sub-range of allBytes\n-            final int half = allBytes.length \/ 2;\n-            int p0 = RAND.nextInt(half);\n-            int p1 = half + RAND.nextInt(allBytes.length - half);\n-            fc.position(p0);\n-            len = p1 - p0;\n-            byte[] nBytes = is.readNBytes(len);\n-            idx = Arrays.mismatch(allBytes, p0, p1, nBytes, 0, len);\n-            if (idx != -1)\n-                throw new RuntimeException(\"Mismatch at relative index \" + idx);\n+        FileInputStream fis = new FileInputStream(blah);\n+        FileChannel fc = fis.getChannel();\n+        InputStream is = Channels.newInputStream(fc);\n+        int messageSize = message.length() * ITERATIONS * 3 + 1;\n+        byte bb[] = new byte[messageSize];\n+\n+        int bytesRead = 0;\n+        int totalRead = 0;\n+        while (bytesRead != -1) {\n+            totalRead += bytesRead;\n+            long rem = Math.min(fc.size() - totalRead, (long)Integer.MAX_VALUE);\n+            if (is.available() != (int)rem)\n+                throw new RuntimeException(\"available not useful or not maximally useful\");\n+            bytesRead = is.read(bb, totalRead, messageSize - totalRead);\n@@ -310,0 +267,12 @@\n+        if (is.available() != 0)\n+           throw new RuntimeException(\"available() should return 0 at EOF\");\n+\n+        String result = new String(bb, 0, totalRead, encoding);\n+        int len = message.length();\n+        for (int i=0; i<ITERATIONS; i++) {\n+            String segment = result.substring(i++ * len, i * len);\n+            if (!segment.equals(message))\n+                throw new RuntimeException(\"Test failed\");\n+        }\n+        is.close();\n+        fis.close();\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/Basic.java","additions":28,"deletions":59,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268435\n+ * @summary Verify ChannelInputStream methods\n+ * @library ..\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @modules java.base\/jdk.internal.util\n+ * @run testng\/othervm -Xmx6G ChannelInputStream\n+ * @key randomness\n+ *\/\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.internal.util.ArraysSupport;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import org.testng.Assert;\n+import static org.testng.Assert.*;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class ChannelInputStream {\n+\n+    static final Random RAND = RandomFactory.getRandom();\n+\n+    static File createFile(long size) throws IOException {\n+        File file = File.createTempFile(\"foo\", \".bar\");\n+        file.deleteOnExit();\n+        RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n+        raf.setLength(size);\n+        raf.close();\n+        return file;\n+    }\n+\n+    @DataProvider\n+    public Object[][] provider() throws IOException {\n+\n+        Object[][] result = new Object[][] {\n+            {createFile(0L)},\n+            {createFile(RAND.nextInt(Short.MAX_VALUE))},\n+            {createFile(ArraysSupport.SOFT_MAX_ARRAY_LENGTH)},\n+            {createFile((long)Integer.MAX_VALUE + 27)}\n+        };\n+\n+        return result;\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void readAllBytes(File file) throws IOException {\n+        try (FileInputStream fis = new FileInputStream(file);\n+             FileChannel fc = fis.getChannel();\n+             InputStream cis = Channels.newInputStream(fc)) {\n+            long size = Files.size(file.toPath());\n+            if (size == 0L) {\n+                byte[] bytes = cis.readAllBytes();\n+                assertNotNull(bytes);\n+                assertEquals(bytes.length, 0);\n+            } else if (size > Integer.MAX_VALUE) {\n+                expectThrows(OutOfMemoryError.class, () -> cis.readAllBytes());\n+            } else {\n+                byte[] fisBytes = fis.readAllBytes();\n+                fc.position(0L);\n+                byte[] cisBytes = cis.readAllBytes();\n+                assertTrue(Arrays.equals(fisBytes, cisBytes));\n+\n+                \/\/ check behavior at what should be EOF\n+                cisBytes = cis.readAllBytes();\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, 0);\n+            }\n+        } finally {\n+            file.delete();\n+        }\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void readNBytes(File file) throws IOException {\n+        try (FileInputStream fis = new FileInputStream(file);\n+             FileChannel fc = fis.getChannel();\n+             InputStream cis = Channels.newInputStream(fc)) {\n+            long size = Files.size(file.toPath());\n+            if (size == 0L) {\n+                byte[] bytes = cis.readNBytes(1);\n+                assertNotNull(bytes);\n+                assertEquals(bytes.length, 0);\n+            } else if (size > Integer.MAX_VALUE) {\n+                expectThrows(OutOfMemoryError.class,\n+                             () -> cis.readNBytes(Integer.MAX_VALUE));\n+            } else {\n+                int length = Math.toIntExact(size);\n+                int half = length \/ 2;\n+                int position = RAND.nextInt(half);\n+                int count = RAND.nextInt(length - position);\n+                fc.position(position);\n+                byte[] fisBytes = fis.readNBytes(count);\n+                fc.position(position);\n+                byte[] cisBytes = cis.readNBytes(count);\n+                assertTrue(Arrays.equals(fisBytes, cisBytes));\n+\n+                \/\/ skip to EOF and check behavior there\n+                cis.skipNBytes(length - (position + count));\n+                cisBytes = cis.readNBytes(0);\n+                assertNotNull(cisBytes);\n+                assertEquals(cisBytes.length, 0);\n+            }\n+        } finally {\n+            file.delete();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"}]}