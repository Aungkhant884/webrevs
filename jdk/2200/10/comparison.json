{"files":[{"patch":"@@ -104,0 +104,8 @@\n+# Test and fix cpu on macos-aarch64, uname -p reports arm, buildsys expects aarch64\n+echo $OUT | grep arm-apple-darwin > \/dev\/null 2> \/dev\/null\n+if test $? = 0; then\n+  if [ `uname -m` = arm64 ]; then\n+    OUT=aarch64`echo $OUT | sed -e 's\/[^-]*\/\/'`\n+  fi\n+fi\n+\n","filename":"make\/autoconf\/build-aux\/config.guess","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -128,0 +128,3 @@\n+    # The expected format for <version> is either nn.n.n or nn.nn.nn. See\n+    # \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/AvailabilityVersions.h\n+\n@@ -133,1 +136,5 @@\n-    MACOSX_VERSION_MIN=10.12.0\n+    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = xaarch64; then\n+      MACOSX_VERSION_MIN=11.00.00\n+    else\n+      MACOSX_VERSION_MIN=10.12.0\n+    fi\n@@ -139,2 +146,1 @@\n-    # link to macosx APIs that are newer than the given OS version. The expected\n-    # format for <version> is either nn.n.n or nn.nn.nn. See \/usr\/include\/AvailabilityMacros.h.\n+    # link to macosx APIs that are newer than the given OS version.\n","filename":"make\/autoconf\/flags.m4","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-      AC_MSG_RESULT([no, $OPENJDK_TARGET_CPU])\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n@@ -267,4 +267,4 @@\n-    if test \"x$OPENJDK_TARGET_OS\" != xaix; then\n-      AC_MSG_RESULT([yes])\n-    else\n-      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS])\n+    if test \"x$OPENJDK_TARGET_OS\" = xaix || \\\n+        ( test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\" && \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ) ; then\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n@@ -272,0 +272,2 @@\n+    else\n+      AC_MSG_RESULT([yes])\n","filename":"make\/autoconf\/jvm-features.m4","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1180,1 +1180,1 @@\n-\t\t  $(CODESIGN) -s \"$(MACOSX_CODESIGN_IDENTITY)\" --timestamp --options runtime \\\n+\t\t  $(CODESIGN) -f -s \"$(MACOSX_CODESIGN_IDENTITY)\" --timestamp --options runtime \\\n","filename":"make\/common\/NativeCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,0 +91,3 @@\n+    ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)\n+      ADLCFLAGS += -DR18_RESERVED\n+    endif\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -500,1 +500,2 @@\n-        undef missing-field-initializers range-loop-analysis, \\\n+        undef missing-field-initializers range-loop-analysis \\\n+        deprecated-declarations c++11-narrowing, \\\n@@ -573,0 +574,1 @@\n+    DISABLED_WARNINGS_clang := deprecated-declarations, \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  SA_CFLAGS := -Damd64 -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \\\n+  SA_CFLAGS := -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \\\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-#if defined(_WIN64)\n+#if defined(__APPLE__) || defined(_WIN64)\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,27 @@\n+\/\/describe amount of space in bytes occupied by type on native stack\n+class NativeStack : public AllStatic {\n+public:\n+#ifdef __APPLE__\n+  static const int byteSpace        = sizeof(jbyte);\n+  static const int shortSpace       = sizeof(jshort);\n+  static const int intSpace         = sizeof(jint);\n+  static const int longSpace        = wordSize;\n+  static const int floatSpace       = intSpace;\n+  static const int doubleSpace      = longSpace;\n+#else\n+  static const int byteSpace        = wordSize;\n+  static const int shortSpace       = wordSize;\n+  static const int intSpace         = wordSize;\n+  static const int longSpace        = wordSize;\n+  static const int floatSpace       = intSpace;\n+  static const int doubleSpace      = longSpace;\n+#endif\n+};\n+\n+template <typename T>\n+static inline void store_and_inc(char* &to, T value, int inc_size) {\n+  to = align_up(to, inc_size);\n+  *(T *)to = value;\n+  to = to + inc_size;\n+}\n+\n@@ -54,0 +81,33 @@\n+\/\/ On macos\/aarch64 native stack is packed, int\/float are using only 4 bytes\n+\/\/ on stack. Natural alignment for types are still in place,\n+\/\/ for example double\/long should be 8 bytes alligned\n+\n+void InterpreterRuntime::SignatureHandlerGenerator::pass_byte() {\n+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));\n+\n+  if (_num_int_args < Argument::n_int_register_parameters_c-1) {\n+    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);\n+  } else {\n+    __ ldrb(r0, src);\n+    __ strb(r0, Address(to(), _stack_offset));\n+    _stack_offset += NativeStack::byteSpace;\n+  }\n+\n+  _num_int_args++;\n+}\n+\n+void InterpreterRuntime::SignatureHandlerGenerator::pass_short() {\n+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));\n+\n+  if (_num_int_args < Argument::n_int_register_parameters_c-1) {\n+    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);\n+  } else {\n+    _stack_offset = align_up(_stack_offset, NativeStack::shortSpace);\n+    __ ldrh(r0, src);\n+    __ strh(r0, Address(to(), _stack_offset));\n+    _stack_offset += NativeStack::shortSpace;\n+  }\n+\n+  _num_int_args++;\n+}\n+\n@@ -87,0 +147,1 @@\n+    _stack_offset = align_up(_stack_offset, NativeStack::intSpace);\n@@ -89,1 +150,1 @@\n-    _stack_offset += wordSize;\n+    _stack_offset += NativeStack::intSpace;\n@@ -128,0 +189,1 @@\n+    _stack_offset = align_up(_stack_offset, NativeStack::longSpace);\n@@ -130,1 +192,1 @@\n-    _stack_offset += wordSize;\n+    _stack_offset += NativeStack::longSpace;\n@@ -142,0 +204,1 @@\n+      _stack_offset = align_up(_stack_offset, NativeStack::floatSpace);\n@@ -144,1 +207,1 @@\n-    _stack_offset += wordSize;\n+    _stack_offset += NativeStack::floatSpace;\n@@ -155,0 +218,1 @@\n+    _stack_offset = align_up(_stack_offset, NativeStack::doubleSpace);\n@@ -157,1 +221,1 @@\n-    _stack_offset += wordSize;\n+    _stack_offset += NativeStack::doubleSpace;\n@@ -250,0 +314,1 @@\n+      _stack_offset = align_up(_stack_offset, wordSize);\n@@ -279,1 +344,1 @@\n-  intptr_t* _to;\n+  char*     _to;\n@@ -286,0 +351,28 @@\n+#ifdef __APPLE__\n+  virtual void pass_byte()\n+  {\n+    jbyte from_obj = *(jbyte *)(_from+Interpreter::local_offset_in_bytes(0));\n+    _from -= Interpreter::stackElementSize;\n+\n+    if (_num_int_args < Argument::n_int_register_parameters_c-1) {\n+      *_int_args++ = from_obj;\n+    } else {\n+      store_and_inc(_to, from_obj, NativeStack::byteSpace);\n+    }\n+    _num_int_args++;\n+  }\n+\n+  virtual void pass_short()\n+  {\n+    jshort from_obj = *(jshort *)(_from+Interpreter::local_offset_in_bytes(0));\n+    _from -= Interpreter::stackElementSize;\n+\n+    if (_num_int_args < Argument::n_int_register_parameters_c-1) {\n+      *_int_args++ = from_obj;\n+    } else {\n+      store_and_inc(_to, from_obj, NativeStack::shortSpace);\n+    }\n+    _num_int_args++;\n+  }\n+#endif\n+\n@@ -295,1 +388,2 @@\n-      *_to++ = from_obj;\n+      store_and_inc(_to, from_obj, NativeStack::intSpace);\n+\n@@ -309,1 +403,1 @@\n-      *_to++ = from_obj;\n+      store_and_inc(_to, from_obj, NativeStack::longSpace);\n@@ -323,1 +417,1 @@\n-      *_to++ = (*from_addr == 0) ? NULL : (intptr_t) from_addr;\n+      store_and_inc(_to, (*from_addr == 0) ? (intptr_t)NULL : (intptr_t) from_addr, wordSize);\n@@ -337,1 +431,2 @@\n-      *_to++ = from_obj;\n+      store_and_inc(_to, from_obj, NativeStack::floatSpace);\n+\n@@ -352,1 +447,1 @@\n-      *_to++ = from_obj;\n+      store_and_inc(_to, from_obj, NativeStack::doubleSpace);\n@@ -362,1 +457,1 @@\n-    _to   = to;\n+    _to   = (char *)to;\n","filename":"src\/hotspot\/cpu\/aarch64\/interpreterRT_aarch64.cpp","additions":106,"deletions":11,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+  void pass_byte();\n+  void pass_short();\n","filename":"src\/hotspot\/cpu\/aarch64\/interpreterRT_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  str(zr, Address(rthread, JavaThread::saved_fp_address_offset()));\n+  str(zr, Address(rthread, JavaFrameAnchor::saved_fp_address_offset()));\n@@ -5271,1 +5271,1 @@\n-  RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;\n+  RegSet saved_regs = RegSet::range(r0, r1) + BSD_ONLY(RegSet::range(r2, r17)) + lr - dst;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/vm_version.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -808,0 +808,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code unable to handle this, bailout.\n+          return -1;\n+#endif\n@@ -830,0 +835,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code unable to handle this, bailout.\n+          return -1;\n+#endif\n@@ -1363,0 +1373,4 @@\n+  if (out_arg_slots < 0) {\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+    CPU_APPLE     = 'a',\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,0 +211,2 @@\n+#elif defined(AARCH64)\n+static char cpu_arch[] = \"aarch64\";\n@@ -2174,1 +2176,1 @@\n-#ifdef __APPLE__\n+#if defined(__APPLE__) && defined(__x86_64__)\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1297,1 +1297,1 @@\n-                                EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n+                                EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC,\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP\n+\n+\/\/ Implementation of class atomic\n+\/\/ Note that memory_order_conservative requires a full barrier after atomic stores.\n+\/\/ See https:\/\/patchwork.kernel.org\/patch\/3575821\/\n+\n+template<size_t byte_size>\n+struct Atomic::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_and_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+    FULL_MEM_BARRIER;\n+    return res;\n+  }\n+\n+  template<typename D, typename I>\n+  D fetch_and_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_and_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+template<size_t byte_size>\n+template<typename T>\n+inline T Atomic::PlatformXchg<byte_size>::operator()(T volatile* dest,\n+                                                     T exchange_value,\n+                                                     atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+  T res = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n+}\n+\n+\/\/ __attribute__((unused)) on dest is to get rid of spurious GCC warnings.\n+template<size_t byte_size>\n+template<typename T>\n+inline T Atomic::PlatformCmpxchg<byte_size>::operator()(T volatile* dest __attribute__((unused)),\n+                                                        T compare_value,\n+                                                        T exchange_value,\n+                                                        atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+  if (order == memory_order_relaxed) {\n+    T value = compare_value;\n+    __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+    return value;\n+  } else {\n+    T value = compare_value;\n+    FULL_MEM_BARRIER;\n+    __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+    FULL_MEM_BARRIER;\n+    return value;\n+  }\n+}\n+\n+template<size_t byte_size>\n+struct Atomic::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n+{\n+  template <typename T>\n+  T operator()(const volatile T* p) const { T data; __atomic_load(const_cast<T*>(p), &data, __ATOMIC_ACQUIRE); return data; }\n+};\n+\n+template<size_t byte_size>\n+struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const { __atomic_store(const_cast<T*>(p), &v, __ATOMIC_RELEASE); }\n+};\n+\n+template<size_t byte_size>\n+struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const { release_store(p, v); OrderAccess::fence(); }\n+};\n+\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/atomic_bsd_aarch64.hpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_BYTES_BSD_AARCH64_INLINE_HPP\n+#define OS_CPU_BSD_AARCH64_BYTES_BSD_AARCH64_INLINE_HPP\n+\n+#ifdef __APPLE__\n+#include <libkern\/OSByteOrder.h>\n+#endif\n+\n+#if defined(__APPLE__)\n+#  define bswap_16(x) OSSwapInt16(x)\n+#  define bswap_32(x) OSSwapInt32(x)\n+#  define bswap_64(x) OSSwapInt64(x)\n+#else\n+#  error \"Unimplemented\"\n+#endif\n+\n+\/\/ Efficient swapping of data bytes from Java byte\n+\/\/ ordering to native byte ordering and vice versa.\n+inline u2   Bytes::swap_u2(u2 x) {\n+  return bswap_16(x);\n+}\n+\n+inline u4   Bytes::swap_u4(u4 x) {\n+  return bswap_32(x);\n+}\n+\n+inline u8 Bytes::swap_u8(u8 x) {\n+  return bswap_64(x);\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_BYTES_BSD_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/bytes_bsd_aarch64.inline.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_COPY_BSD_AARCH64_INLINE_HPP\n+#define OS_CPU_BSD_AARCH64_COPY_BSD_AARCH64_INLINE_HPP\n+\n+#define COPY_SMALL(from, to, count)                                     \\\n+{                                                                       \\\n+        long tmp0, tmp1, tmp2, tmp3;                                    \\\n+        long tmp4, tmp5, tmp6, tmp7;                                    \\\n+  __asm volatile(                                                       \\\n+\"       adr     %[t0], 0f;\\n\"                                           \\\n+\"       add     %[t0], %[t0], %[cnt], lsl #5;\\n\"                        \\\n+\"       br      %[t0];\\n\"                                               \\\n+\"       .align  5;\\n\"                                                   \\\n+\"0:\"                                                                    \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldr     %[t0], [%[s], #0];\\n\"                                   \\\n+\"       str     %[t0], [%[d], #0];\\n\"                                   \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldr     %[t2], [%[s], #16];\\n\"                                  \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       str     %[t2], [%[d], #16];\\n\"                                  \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       ldr     %[t4], [%[s], #32];\\n\"                                  \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       str     %[t4], [%[d], #32];\\n\"                                  \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       ldp     %[t4], %[t5], [%[s], #32];\\n\"                           \\\n+\"2:\"                                                                    \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       stp     %[t4], %[t5], [%[d], #32];\\n\"                           \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldr     %[t6], [%[s], #0];\\n\"                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #8];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #24];\\n\"                           \\\n+\"       ldp     %[t4], %[t5], [%[s], #40];\\n\"                           \\\n+\"       str     %[t6], [%[d]], #8;\\n\"                                   \\\n+\"       b       2b;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       ldp     %[t4], %[t5], [%[s], #32];\\n\"                           \\\n+\"       ldp     %[t6], %[t7], [%[s], #48];\\n\"                           \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       stp     %[t4], %[t5], [%[d], #32];\\n\"                           \\\n+\"       stp     %[t6], %[t7], [%[d], #48];\\n\"                           \\\n+\"1:\"                                                                    \\\n+                                                                        \\\n+  : [s]\"+r\"(from), [d]\"+r\"(to), [cnt]\"+r\"(count),                       \\\n+    [t0]\"=&r\"(tmp0), [t1]\"=&r\"(tmp1), [t2]\"=&r\"(tmp2), [t3]\"=&r\"(tmp3), \\\n+    [t4]\"=&r\"(tmp4), [t5]\"=&r\"(tmp5), [t6]\"=&r\"(tmp6), [t7]\"=&r\"(tmp7)  \\\n+  :                                                                     \\\n+  : \"memory\", \"cc\");                                                    \\\n+}\n+\n+static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n+  if (__builtin_expect(count <= 8, 1)) {\n+    COPY_SMALL(from, to, count);\n+    return;\n+  }\n+  _Copy_conjoint_words(from, to, count);\n+}\n+\n+static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  if (__builtin_constant_p(count)) {\n+    memcpy(to, from, count * sizeof(HeapWord));\n+    return;\n+  }\n+  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n+  if (__builtin_expect(count <= 8, 1)) {\n+    COPY_SMALL(from, to, count);\n+    return;\n+  }\n+  _Copy_disjoint_words(from, to, count);\n+}\n+\n+static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n+  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n+  if (__builtin_expect(count <= 8, 1)) {\n+    COPY_SMALL(from, to, count);\n+    return;\n+  }\n+  _Copy_disjoint_words(from, to, count);\n+}\n+\n+static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_words(from, to, count);\n+}\n+\n+static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_disjoint_words(from, to, count);\n+}\n+\n+static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n+  (void)memmove(to, from, count);\n+}\n+\n+static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n+  pd_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+  _Copy_conjoint_jshorts_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+  _Copy_conjoint_jints_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+  _Copy_conjoint_jlongs_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n+  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jshorts(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n+   _Copy_arrayof_conjoint_jints(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n+  assert(!UseCompressedOops, \"foo!\");\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_COPY_BSD_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/copy_bsd_aarch64.inline.hpp","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2016, Linaro Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#define CFUNC(x) _##x\n+\n+        .global CFUNC(_Copy_conjoint_words)\n+        .global CFUNC(_Copy_disjoint_words)\n+\n+s       .req    x0\n+d       .req    x1\n+count   .req    x2\n+t0      .req    x3\n+t1      .req    x4\n+t2      .req    x5\n+t3      .req    x6\n+t4      .req    x7\n+t5      .req    x8\n+t6      .req    x9\n+t7      .req    x10\n+\n+        .align  6\n+CFUNC(_Copy_disjoint_words):\n+        \/\/ Ensure 2 word aligned\n+        tbz     s, #3, fwd_copy_aligned\n+        ldr     t0, [s], #8\n+        str     t0, [d], #8\n+        sub     count, count, #1\n+\n+fwd_copy_aligned:\n+        \/\/ Bias s & d so we only pre index on the last copy\n+        sub     s, s, #16\n+        sub     d, d, #16\n+\n+        ldp     t0, t1, [s, #16]\n+        ldp     t2, t3, [s, #32]\n+        ldp     t4, t5, [s, #48]\n+        ldp     t6, t7, [s, #64]!\n+\n+        subs    count, count, #16\n+        blo     fwd_copy_drain\n+\n+fwd_copy_again:\n+        prfm    pldl1keep, [s, #256]\n+        stp     t0, t1, [d, #16]\n+        ldp     t0, t1, [s, #16]\n+        stp     t2, t3, [d, #32]\n+        ldp     t2, t3, [s, #32]\n+        stp     t4, t5, [d, #48]\n+        ldp     t4, t5, [s, #48]\n+        stp     t6, t7, [d, #64]!\n+        ldp     t6, t7, [s, #64]!\n+        subs    count, count, #8\n+        bhs     fwd_copy_again\n+\n+fwd_copy_drain:\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        stp     t4, t5, [d, #48]\n+        stp     t6, t7, [d, #64]!\n+\n+        \/\/ count is now -8..-1 for 0..7 words to copy\n+        adr     t0, 0f\n+        add     t0, t0, count, lsl #5\n+        br      t0\n+\n+        .align  5\n+        ret                             \/\/ -8 == 0 words\n+        .align  5\n+        ldr     t0, [s, #16]            \/\/ -7 == 1 word\n+        str     t0, [d, #16]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -6 = 2 words\n+        stp     t0, t1, [d, #16]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -5 = 3 words\n+        ldr     t2, [s, #32]\n+        stp     t0, t1, [d, #16]\n+        str     t2, [d, #32]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -4 = 4 words\n+        ldp     t2, t3, [s, #32]\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -3 = 5 words\n+        ldp     t2, t3, [s, #32]\n+        ldr     t4, [s, #48]\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        str     t4, [d, #48]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -2 = 6 words\n+        ldp     t2, t3, [s, #32]\n+        ldp     t4, t5, [s, #48]\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        stp     t4, t5, [d, #48]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -1 = 7 words\n+        ldp     t2, t3, [s, #32]\n+        ldp     t4, t5, [s, #48]\n+        ldr     t6, [s, #64]\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        stp     t4, t5, [d, #48]\n+        str     t6, [d, #64]\n+        \/\/ Is always aligned here, code for 7 words is one instruction\n+        \/\/ too large so it just falls through.\n+        .align  5\n+0:\n+        ret\n+\n+        .align  6\n+CFUNC(_Copy_conjoint_words):\n+        sub     t0, d, s\n+        cmp     t0, count, lsl #3\n+        bhs     CFUNC(_Copy_disjoint_words)\n+\n+        add     s, s, count, lsl #3\n+        add     d, d, count, lsl #3\n+\n+        \/\/ Ensure 2 word aligned\n+        tbz     s, #3, bwd_copy_aligned\n+        ldr     t0, [s, #-8]!\n+        str     t0, [d, #-8]!\n+        sub     count, count, #1\n+\n+bwd_copy_aligned:\n+        ldp     t0, t1, [s, #-16]\n+        ldp     t2, t3, [s, #-32]\n+        ldp     t4, t5, [s, #-48]\n+        ldp     t6, t7, [s, #-64]!\n+\n+        subs    count, count, #16\n+        blo     bwd_copy_drain\n+\n+bwd_copy_again:\n+        prfum   pldl1keep, [s, #-256]\n+        stp     t0, t1, [d, #-16]\n+        ldp     t0, t1, [s, #-16]\n+        stp     t2, t3, [d, #-32]\n+        ldp     t2, t3, [s, #-32]\n+        stp     t4, t5, [d, #-48]\n+        ldp     t4, t5, [s, #-48]\n+        stp     t6, t7, [d, #-64]!\n+        ldp     t6, t7, [s, #-64]!\n+        subs    count, count, #8\n+        bhs     bwd_copy_again\n+\n+bwd_copy_drain:\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        stp     t4, t5, [d, #-48]\n+        stp     t6, t7, [d, #-64]!\n+\n+        \/\/ count is now -8..-1 for 0..7 words to copy\n+        adr     t0, 0f\n+        add     t0, t0, count, lsl #5\n+        br      t0\n+\n+        .align  5\n+        ret                             \/\/ -8 == 0 words\n+        .align  5\n+        ldr     t0, [s, #-8]            \/\/ -7 == 1 word\n+        str     t0, [d, #-8]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -6 = 2 words\n+        stp     t0, t1, [d, #-16]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -5 = 3 words\n+        ldr     t2, [s, #-24]\n+        stp     t0, t1, [d, #-16]\n+        str     t2, [d, #-24]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -4 = 4 words\n+        ldp     t2, t3, [s, #-32]\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -3 = 5 words\n+        ldp     t2, t3, [s, #-32]\n+        ldr     t4, [s, #-40]\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        str     t4, [d, #-40]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -2 = 6 words\n+        ldp     t2, t3, [s, #-32]\n+        ldp     t4, t5, [s, #-48]\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        stp     t4, t5, [d, #-48]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -1 = 7 words\n+        ldp     t2, t3, [s, #-32]\n+        ldp     t4, t5, [s, #-48]\n+        ldr     t6, [s, #-56]\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        stp     t4, t5, [d, #-48]\n+        str     t6, [d, #-56]\n+        \/\/ Is always aligned here, code for 7 words is one instruction\n+        \/\/ too large so it just falls through.\n+        .align  5\n+0:\n+        ret\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/copy_bsd_aarch64.s","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_GLOBALS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_GLOBALS_BSD_AARCH64_HPP\n+\n+\n+\/\/ Sets the default values for platform dependent flags used by the runtime system.\n+\/\/ (see globals.hpp)\n+\n+define_pd_global(bool, DontYieldALot,            false);\n+define_pd_global(intx, ThreadStackSize,          2048); \/\/ 0 => use system default\n+define_pd_global(intx, VMThreadStackSize,        2048);\n+\n+define_pd_global(intx, CompilerThreadStackSize,  2048);\n+\n+define_pd_global(uintx,JVMInvokeMethodSlack,     8192);\n+\n+\/\/ Used on 64 bit platforms for UseCompressedOops base address\n+define_pd_global(uintx,HeapBaseMinAddress,       2*G);\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_GLOBALS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/globals_bsd_aarch64.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_ICACHE_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_ICACHE_AARCH64_HPP\n+\n+\/\/ Interface for updating the instruction cache.  Whenever the VM\n+\/\/ modifies code, part of the processor instruction cache potentially\n+\/\/ has to be flushed.\n+\n+class ICache : public AbstractICache {\n+ public:\n+  static void initialize();\n+  static void invalidate_word(address addr) {\n+    __clear_cache((char *)addr, (char *)(addr + 4));\n+  }\n+  static void invalidate_range(address start, int nbytes) {\n+    __clear_cache((char *)start, (char *)(start + nbytes));\n+  }\n+};\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_ICACHE_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/icache_bsd_aarch64.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP\n+\n+\/\/ Included in orderAccess.hpp header file.\n+\n+\/\/ Implementation of class OrderAccess.\n+\n+inline void OrderAccess::loadload()   { acquire(); }\n+inline void OrderAccess::storestore() { release(); }\n+inline void OrderAccess::loadstore()  { acquire(); }\n+inline void OrderAccess::storeload()  { fence(); }\n+\n+#define FULL_MEM_BARRIER  __sync_synchronize()\n+#define READ_MEM_BARRIER  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n+#define WRITE_MEM_BARRIER __atomic_thread_fence(__ATOMIC_RELEASE);\n+\n+inline void OrderAccess::acquire() {\n+  READ_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::release() {\n+  WRITE_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::fence() {\n+  FULL_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::cross_modify_fence_impl() {\n+  asm volatile(\"isb\" : : : \"memory\");\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/orderAccess_bsd_aarch64.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,737 @@\n+\/*\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"jvm.h\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/icBuffer.hpp\"\n+#include \"code\/vtableStubs.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"os_share_bsd.hpp\"\n+#include \"prims\/jniFastGetField.hpp\"\n+#include \"prims\/jvm_misc.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/safepointMechanism.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"signals_posix.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+\/\/ put OS-includes here\n+# include <sys\/types.h>\n+# include <sys\/mman.h>\n+# include <pthread.h>\n+# include <signal.h>\n+# include <errno.h>\n+# include <dlfcn.h>\n+# include <stdlib.h>\n+# include <stdio.h>\n+# include <unistd.h>\n+# include <sys\/resource.h>\n+# include <pthread.h>\n+# include <sys\/stat.h>\n+# include <sys\/time.h>\n+# include <sys\/utsname.h>\n+# include <sys\/socket.h>\n+# include <sys\/wait.h>\n+# include <pwd.h>\n+# include <poll.h>\n+#ifndef __OpenBSD__\n+# include <ucontext.h>\n+#endif\n+\n+#if !defined(__APPLE__) && !defined(__NetBSD__)\n+# include <pthread_np.h>\n+#endif\n+\n+\/\/ needed by current_stack_region() workaround for Mavericks\n+#if defined(__APPLE__)\n+# include <errno.h>\n+# include <sys\/types.h>\n+# include <sys\/sysctl.h>\n+# define DEFAULT_MAIN_THREAD_STACK_PAGES 2048\n+# define OS_X_10_9_0_KERNEL_MAJOR_VERSION 13\n+#endif\n+\n+#define SPELL_REG_SP \"sp\"\n+#define SPELL_REG_FP \"fp\"\n+\n+#ifdef __APPLE__\n+\/\/ see darwin-xnu\/osfmk\/mach\/arm\/_structs.h\n+\n+# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)\n+  \/\/ 10.5 UNIX03 member name prefixes\n+  #define DU3_PREFIX(s, m) __ ## s.__ ## m\n+# else\n+  #define DU3_PREFIX(s, m) s ## . ## m\n+# endif\n+#endif\n+\n+#define context_x    uc_mcontext->DU3_PREFIX(ss,x)\n+#define context_fp   uc_mcontext->DU3_PREFIX(ss,fp)\n+#define context_lr   uc_mcontext->DU3_PREFIX(ss,lr)\n+#define context_sp   uc_mcontext->DU3_PREFIX(ss,sp)\n+#define context_pc   uc_mcontext->DU3_PREFIX(ss,pc)\n+#define context_cpsr uc_mcontext->DU3_PREFIX(ss,cpsr)\n+#define context_esr  uc_mcontext->DU3_PREFIX(es,esr)\n+\n+address os::current_stack_pointer() {\n+#if defined(__clang__) || defined(__llvm__)\n+  void *sp;\n+  __asm__(\"mov %0, \" SPELL_REG_SP : \"=r\"(sp));\n+  return (address) sp;\n+#else\n+  register void *sp __asm__ (SPELL_REG_SP);\n+  return (address) sp;\n+#endif\n+}\n+\n+char* os::non_memory_address_word() {\n+  \/\/ Must never look like an address returned by reserve_memory,\n+  \/\/ even in its subfields (as defined by the CPU immediate fields,\n+  \/\/ if the CPU splits constants across multiple instructions).\n+\n+  \/\/ the return value used in computation of Universe::non_oop_word(), which\n+  \/\/ is loaded by cpu\/aarch64 by MacroAssembler::movptr(Register, uintptr_t)\n+  return (char*) 0xffffffffffff;\n+}\n+\n+address os::Posix::ucontext_get_pc(const ucontext_t * uc) {\n+  return (address)uc->context_pc;\n+}\n+\n+void os::Posix::ucontext_set_pc(ucontext_t * uc, address pc) {\n+  uc->context_pc = (intptr_t)pc ;\n+}\n+\n+intptr_t* os::Bsd::ucontext_get_sp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->context_sp;\n+}\n+\n+intptr_t* os::Bsd::ucontext_get_fp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->context_fp;\n+}\n+\n+address os::fetch_frame_from_context(const void* ucVoid,\n+                    intptr_t** ret_sp, intptr_t** ret_fp) {\n+\n+  address epc;\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+\n+  if (uc != NULL) {\n+    epc = os::Posix::ucontext_get_pc(uc);\n+    if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);\n+    if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);\n+  } else {\n+    epc = NULL;\n+    if (ret_sp) *ret_sp = (intptr_t *)NULL;\n+    if (ret_fp) *ret_fp = (intptr_t *)NULL;\n+  }\n+\n+  return epc;\n+}\n+\n+frame os::fetch_frame_from_context(const void* ucVoid) {\n+  intptr_t* sp;\n+  intptr_t* fp;\n+  address epc = fetch_frame_from_context(ucVoid, &sp, &fp);\n+  return frame(sp, fp, epc);\n+}\n+\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  \/\/ In compiled code, the stack banging is performed before LR\n+  \/\/ has been saved in the frame.  LR is live, and SP and FP\n+  \/\/ belong to the caller.\n+  intptr_t* fp = os::Bsd::ucontext_get_fp(uc);\n+  intptr_t* sp = os::Bsd::ucontext_get_sp(uc);\n+  address pc = (address)(uc->context_lr\n+                         - NativeInstruction::instruction_size);\n+  return frame(sp, fp, pc);\n+}\n+\n+\/\/ By default, gcc always saves frame pointer rfp on this stack. This\n+\/\/ may get turned off by -fomit-frame-pointer.\n+frame os::get_sender_for_C_frame(frame* fr) {\n+  return frame(fr->link(), fr->link(), fr->sender_pc());\n+}\n+\n+NOINLINE frame os::current_frame() {\n+  intptr_t *fp = *(intptr_t **)__builtin_frame_address(0);\n+  frame myframe((intptr_t*)os::current_stack_pointer(),\n+                (intptr_t*)fp,\n+                CAST_FROM_FN_PTR(address, os::current_frame));\n+  if (os::is_first_C_frame(&myframe)) {\n+    \/\/ stack is not walkable\n+    return frame();\n+  } else {\n+    return os::get_sender_for_C_frame(&myframe);\n+  }\n+}\n+\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n+  \/\/ Enable WXWrite: this function is called by the signal handler at arbitrary\n+  \/\/ point of execution.\n+  ThreadWXEnable wx(WXWrite, thread);\n+\n+\/*\n+  NOTE: does not seem to work on bsd.\n+  if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {\n+    \/\/ can't decode this kind of signal\n+    info = NULL;\n+  } else {\n+    assert(sig == info->si_signo, \"bad siginfo\");\n+  }\n+*\/\n+  \/\/ decide if this trap can be handled by a stub\n+  address stub = NULL;\n+\n+  address pc          = NULL;\n+\n+  \/\/%note os_trap_1\n+  if (info != NULL && uc != NULL && thread != NULL) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+\n+    if (StubRoutines::is_safefetch_fault(pc)) {\n+      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+      return true;\n+    }\n+\n+    \/\/ Handle ALL stack overflow variations here\n+    if (sig == SIGSEGV || sig == SIGBUS) {\n+      address addr = (address) info->si_addr;\n+\n+      \/\/ Make sure the high order byte is sign extended, as it may be masked away by the hardware.\n+      if ((uintptr_t(addr) & (uintptr_t(1) << 55)) != 0) {\n+        addr = address(uintptr_t(addr) | (uintptr_t(0xFF) << 56));\n+      }\n+\n+      \/\/ check if fault address is within thread stack\n+      if (thread->is_in_full_stack(addr)) {\n+        \/\/ stack overflow\n+        if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {\n+          return true; \/\/ continue\n+        }\n+      }\n+    }\n+\n+    \/\/ We test if stub is already set (by the stack overflow code\n+    \/\/ above) so it is not overwritten by the code that follows. This\n+    \/\/ check is not required on other platforms, because on other\n+    \/\/ platforms we check for SIGSEGV only or SIGBUS only, where here\n+    \/\/ we have to check for both SIGSEGV and SIGBUS.\n+    if (thread->thread_state() == _thread_in_Java && stub == NULL) {\n+      \/\/ Java thread running in Java code => find exception handler if any\n+      \/\/ a fault inside compiled code, the interpreter, or a stub\n+\n+      \/\/ Handle signal from NativeJump::patch_verified_entry().\n+      if ((sig == SIGILL)\n+          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: zombie_not_entrant\");\n+        }\n+        stub = SharedRuntime::get_handle_wrong_method_stub();\n+      } else if ((sig == SIGSEGV || sig == SIGBUS) && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n+        stub = SharedRuntime::get_poll_stub(pc);\n+#if defined(__APPLE__)\n+      \/\/ 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.\n+      \/\/ 64-bit Darwin may also use a SIGBUS (seen with compressed oops).\n+      \/\/ Catching SIGBUS here prevents the implicit SIGBUS NULL check below from\n+      \/\/ being called, so only do so if the implicit NULL check is not necessary.\n+      } else if (sig == SIGBUS && !MacroAssembler::uses_implicit_null_check(info->si_addr)) {\n+#else\n+      } else if (sig == SIGBUS \/* && info->si_code == BUS_OBJERR *\/) {\n+#endif\n+        \/\/ BugId 4454115: A read from a MappedByteBuffer can fault\n+        \/\/ here if the underlying file has been truncated.\n+        \/\/ Do not crash the VM in such a case.\n+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);\n+        CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n+        bool is_unsafe_arraycopy = (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc));\n+        if ((nm != NULL && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+          address next_pc = pc + NativeCall::instruction_size;\n+          if (is_unsafe_arraycopy) {\n+            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          }\n+          stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+        }\n+      } else if (sig == SIGILL && nativeInstruction_at(pc)->is_stop()) {\n+        \/\/ Pull a pointer to the error message out of the instruction\n+        \/\/ stream.\n+        const uint64_t *detail_msg_ptr\n+          = (uint64_t*)(pc + NativeInstruction::instruction_size);\n+        const char *detail_msg = (const char *)*detail_msg_ptr;\n+        const char *msg = \"stop\";\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: %s: (SIGILL)\", msg);\n+        }\n+\n+        return false;\n+      }\n+      else\n+\n+      if (sig == SIGFPE  &&\n+          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {\n+        stub =\n+          SharedRuntime::\n+          continuation_for_implicit_exception(thread,\n+                                              pc,\n+                                              SharedRuntime::\n+                                              IMPLICIT_DIVIDE_BY_ZERO);\n+#ifdef __APPLE__\n+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {\n+        Unimplemented();\n+#endif \/* __APPLE__ *\/\n+\n+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&\n+                 MacroAssembler::uses_implicit_null_check(info->si_addr)) {\n+          \/\/ Determination of interpreter\/vtable stub\/compiled code null exception\n+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);\n+      }\n+    } else if ((thread->thread_state() == _thread_in_vm ||\n+                 thread->thread_state() == _thread_in_native) &&\n+               sig == SIGBUS && \/* info->si_code == BUS_OBJERR && *\/\n+               thread->doing_unsafe_access()) {\n+      address next_pc = pc + NativeCall::instruction_size;\n+      if (UnsafeCopyMemory::contains_pc(pc)) {\n+        next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+      }\n+      stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+    }\n+\n+    \/\/ jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in\n+    \/\/ and the heap gets shrunk before the field access.\n+    if ((sig == SIGSEGV) || (sig == SIGBUS)) {\n+      address addr = JNI_FastGetField::find_slowcase_pc(pc);\n+      if (addr != (address)-1) {\n+        stub = addr;\n+      }\n+    }\n+  }\n+\n+#if defined(ASSERT) && defined(__APPLE__)\n+  \/\/ Execution protection violation\n+  \/\/\n+  \/\/ This should be kept as the last step in the triage.  We don't\n+  \/\/ have a dedicated trap number for a no-execute fault, so be\n+  \/\/ conservative and allow other handlers the first shot.\n+  if (UnguardOnExecutionViolation > 0 &&\n+      (sig == SIGBUS)) {\n+    static __thread address last_addr = (address) -1;\n+\n+    address addr = (address) info->si_addr;\n+    address pc = os::Posix::ucontext_get_pc(uc);\n+\n+    if (pc != addr && uc->context_esr == 0x9200004F) { \/\/TODO: figure out what this value means\n+      \/\/ We are faulting trying to write a R-X page\n+      pthread_jit_write_protect_np(false);\n+\n+      log_debug(os)(\"Writing protection violation \"\n+                    \"at \" INTPTR_FORMAT\n+                    \", unprotecting\", p2i(addr));\n+\n+      stub = pc;\n+\n+      last_addr = (address) -1;\n+    } else if (pc == addr && uc->context_esr == 0x8200000f) { \/\/TODO: figure out what this value means\n+      \/\/ We are faulting trying to execute a RW- page\n+\n+      if (addr != last_addr) {\n+        pthread_jit_write_protect_np(true);\n+\n+        log_debug(os)(\"Execution protection violation \"\n+                      \"at \" INTPTR_FORMAT\n+                      \", protecting\", p2i(addr));\n+\n+        stub = pc;\n+\n+        \/\/ Set last_addr so if we fault again at the same address, we don't end\n+        \/\/ up in an endless loop.\n+        last_addr = addr;\n+      }\n+    }\n+  }\n+#endif\n+\n+  if (stub != NULL) {\n+    \/\/ save all thread context in case we need to restore it\n+    if (thread != NULL) thread->set_saved_exception_pc(pc);\n+\n+    os::Posix::ucontext_set_pc(uc, stub);\n+    return true;\n+  }\n+\n+  return false; \/\/ Mute compiler\n+}\n+\n+void os::Bsd::init_thread_fpu_state(void) {\n+}\n+\n+bool os::is_allocatable(size_t bytes) {\n+  return true;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ thread stack\n+\n+\/\/ Minimum usable stack sizes required to get to user code. Space for\n+\/\/ HotSpot guard pages is added later.\n+size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;\n+\n+\/\/ return default stack size for thr_type\n+size_t os::Posix::default_stack_size(os::ThreadType thr_type) {\n+  \/\/ default stack size (compiler thread needs larger stack)\n+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);\n+  return s;\n+}\n+\n+\n+\/\/ Java thread:\n+\/\/\n+\/\/   Low memory addresses\n+\/\/    +------------------------+\n+\/\/    |                        |\\  Java thread created by VM does not have glibc\n+\/\/    |    glibc guard page    | - guard, attached Java thread usually has\n+\/\/    |                        |\/  1 glibc guard page.\n+\/\/ P1 +------------------------+ Thread::stack_base() - Thread::stack_size()\n+\/\/    |                        |\\\n+\/\/    |  HotSpot Guard Pages   | - red, yellow and reserved pages\n+\/\/    |                        |\/\n+\/\/    +------------------------+ JavaThread::stack_reserved_zone_base()\n+\/\/    |                        |\\\n+\/\/    |      Normal Stack      | -\n+\/\/    |                        |\/\n+\/\/ P2 +------------------------+ Thread::stack_base()\n+\/\/\n+\/\/ Non-Java thread:\n+\/\/\n+\/\/   Low memory addresses\n+\/\/    +------------------------+\n+\/\/    |                        |\\\n+\/\/    |  glibc guard page      | - usually 1 page\n+\/\/    |                        |\/\n+\/\/ P1 +------------------------+ Thread::stack_base() - Thread::stack_size()\n+\/\/    |                        |\\\n+\/\/    |      Normal Stack      | -\n+\/\/    |                        |\/\n+\/\/ P2 +------------------------+ Thread::stack_base()\n+\/\/\n+\/\/ ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from\n+\/\/    pthread_attr_getstack()\n+\n+static void current_stack_region(address * bottom, size_t * size) {\n+#ifdef __APPLE__\n+  pthread_t self = pthread_self();\n+  void *stacktop = pthread_get_stackaddr_np(self);\n+  *size = pthread_get_stacksize_np(self);\n+  \/\/ workaround for OS X 10.9.0 (Mavericks)\n+  \/\/ pthread_get_stacksize_np returns 128 pages even though the actual size is 2048 pages\n+  if (pthread_main_np() == 1) {\n+    \/\/ At least on Mac OS 10.12 we have observed stack sizes not aligned\n+    \/\/ to pages boundaries. This can be provoked by e.g. setrlimit() (ulimit -s xxxx in the\n+    \/\/ shell). Apparently Mac OS actually rounds upwards to next multiple of page size,\n+    \/\/ however, we round downwards here to be on the safe side.\n+    *size = align_down(*size, getpagesize());\n+\n+    if ((*size) < (DEFAULT_MAIN_THREAD_STACK_PAGES * (size_t)getpagesize())) {\n+      char kern_osrelease[256];\n+      size_t kern_osrelease_size = sizeof(kern_osrelease);\n+      int ret = sysctlbyname(\"kern.osrelease\", kern_osrelease, &kern_osrelease_size, NULL, 0);\n+      if (ret == 0) {\n+        \/\/ get the major number, atoi will ignore the minor amd micro portions of the version string\n+        if (atoi(kern_osrelease) >= OS_X_10_9_0_KERNEL_MAJOR_VERSION) {\n+          *size = (DEFAULT_MAIN_THREAD_STACK_PAGES*getpagesize());\n+        }\n+      }\n+    }\n+  }\n+  *bottom = (address) stacktop - *size;\n+#elif defined(__OpenBSD__)\n+  stack_t ss;\n+  int rslt = pthread_stackseg_np(pthread_self(), &ss);\n+\n+  if (rslt != 0)\n+    fatal(\"pthread_stackseg_np failed with error = %d\", rslt);\n+\n+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);\n+  *size   = ss.ss_size;\n+#else\n+  pthread_attr_t attr;\n+\n+  int rslt = pthread_attr_init(&attr);\n+\n+  \/\/ JVM needs to know exact stack location, abort if it fails\n+  if (rslt != 0)\n+    fatal(\"pthread_attr_init failed with error = %d\", rslt);\n+\n+  rslt = pthread_attr_get_np(pthread_self(), &attr);\n+\n+  if (rslt != 0)\n+    fatal(\"pthread_attr_get_np failed with error = %d\", rslt);\n+\n+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||\n+    pthread_attr_getstacksize(&attr, size) != 0) {\n+    fatal(\"Can not locate current stack attributes!\");\n+  }\n+\n+  pthread_attr_destroy(&attr);\n+#endif\n+  assert(os::current_stack_pointer() >= *bottom &&\n+         os::current_stack_pointer() < *bottom + *size, \"just checking\");\n+}\n+\n+address os::current_stack_base() {\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return (bottom + size);\n+}\n+\n+size_t os::current_stack_size() {\n+  \/\/ stack size includes normal stack and HotSpot guard pages\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return size;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ helper functions for fatal error handler\n+\n+void os::print_context(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  st->print_cr(\"Registers:\");\n+  st->print( \" x0=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 0]);\n+  st->print(\"  x1=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 1]);\n+  st->print(\"  x2=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 2]);\n+  st->print(\"  x3=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 3]);\n+  st->cr();\n+  st->print( \" x4=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 4]);\n+  st->print(\"  x5=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 5]);\n+  st->print(\"  x6=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 6]);\n+  st->print(\"  x7=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 7]);\n+  st->cr();\n+  st->print( \" x8=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 8]);\n+  st->print(\"  x9=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 9]);\n+  st->print(\" x10=\" INTPTR_FORMAT, (intptr_t)uc->context_x[10]);\n+  st->print(\" x11=\" INTPTR_FORMAT, (intptr_t)uc->context_x[11]);\n+  st->cr();\n+  st->print( \"x12=\" INTPTR_FORMAT, (intptr_t)uc->context_x[12]);\n+  st->print(\" x13=\" INTPTR_FORMAT, (intptr_t)uc->context_x[13]);\n+  st->print(\" x14=\" INTPTR_FORMAT, (intptr_t)uc->context_x[14]);\n+  st->print(\" x15=\" INTPTR_FORMAT, (intptr_t)uc->context_x[15]);\n+  st->cr();\n+  st->print( \"x16=\" INTPTR_FORMAT, (intptr_t)uc->context_x[16]);\n+  st->print(\" x17=\" INTPTR_FORMAT, (intptr_t)uc->context_x[17]);\n+  st->print(\" x18=\" INTPTR_FORMAT, (intptr_t)uc->context_x[18]);\n+  st->print(\" x19=\" INTPTR_FORMAT, (intptr_t)uc->context_x[19]);\n+  st->cr();\n+  st->print( \"x20=\" INTPTR_FORMAT, (intptr_t)uc->context_x[20]);\n+  st->print(\" x21=\" INTPTR_FORMAT, (intptr_t)uc->context_x[21]);\n+  st->print(\" x22=\" INTPTR_FORMAT, (intptr_t)uc->context_x[22]);\n+  st->print(\" x23=\" INTPTR_FORMAT, (intptr_t)uc->context_x[23]);\n+  st->cr();\n+  st->print( \"x24=\" INTPTR_FORMAT, (intptr_t)uc->context_x[24]);\n+  st->print(\" x25=\" INTPTR_FORMAT, (intptr_t)uc->context_x[25]);\n+  st->print(\" x26=\" INTPTR_FORMAT, (intptr_t)uc->context_x[26]);\n+  st->print(\" x27=\" INTPTR_FORMAT, (intptr_t)uc->context_x[27]);\n+  st->cr();\n+  st->print( \"x28=\" INTPTR_FORMAT, (intptr_t)uc->context_x[28]);\n+  st->print(\"  fp=\" INTPTR_FORMAT, (intptr_t)uc->context_fp);\n+  st->print(\"  lr=\" INTPTR_FORMAT, (intptr_t)uc->context_lr);\n+  st->print(\"  sp=\" INTPTR_FORMAT, (intptr_t)uc->context_sp);\n+  st->cr();\n+  st->print(  \"pc=\" INTPTR_FORMAT,  (intptr_t)uc->context_pc);\n+  st->print(\" cpsr=\" INTPTR_FORMAT, (intptr_t)uc->context_cpsr);\n+  st->cr();\n+\n+  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);\n+  st->print_cr(\"Top of Stack: (sp=\" INTPTR_FORMAT \")\", (intptr_t)sp);\n+  print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  address pc = os::Posix::ucontext_get_pc(uc);\n+  print_instructions(st, pc, 4\/*native instruction size*\/);\n+  st->cr();\n+}\n+\n+void os::print_register_info(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+\n+  st->print_cr(\"Register to memory mapping:\");\n+  st->cr();\n+\n+  \/\/ this is horrendously verbose but the layout of the registers in the\n+  \/\/ context does not match how we defined our abstract Register set, so\n+  \/\/ we can't just iterate through the gregs area\n+\n+  \/\/ this is only for the \"general purpose\" registers\n+\n+  st->print(\" x0=\"); print_location(st, uc->context_x[ 0]);\n+  st->print(\" x1=\"); print_location(st, uc->context_x[ 1]);\n+  st->print(\" x2=\"); print_location(st, uc->context_x[ 2]);\n+  st->print(\" x3=\"); print_location(st, uc->context_x[ 3]);\n+  st->print(\" x4=\"); print_location(st, uc->context_x[ 4]);\n+  st->print(\" x5=\"); print_location(st, uc->context_x[ 5]);\n+  st->print(\" x6=\"); print_location(st, uc->context_x[ 6]);\n+  st->print(\" x7=\"); print_location(st, uc->context_x[ 7]);\n+  st->print(\" x8=\"); print_location(st, uc->context_x[ 8]);\n+  st->print(\" x9=\"); print_location(st, uc->context_x[ 9]);\n+  st->print(\"x10=\"); print_location(st, uc->context_x[10]);\n+  st->print(\"x11=\"); print_location(st, uc->context_x[11]);\n+  st->print(\"x12=\"); print_location(st, uc->context_x[12]);\n+  st->print(\"x13=\"); print_location(st, uc->context_x[13]);\n+  st->print(\"x14=\"); print_location(st, uc->context_x[14]);\n+  st->print(\"x15=\"); print_location(st, uc->context_x[15]);\n+  st->print(\"x16=\"); print_location(st, uc->context_x[16]);\n+  st->print(\"x17=\"); print_location(st, uc->context_x[17]);\n+  st->print(\"x18=\"); print_location(st, uc->context_x[18]);\n+  st->print(\"x19=\"); print_location(st, uc->context_x[19]);\n+  st->print(\"x20=\"); print_location(st, uc->context_x[20]);\n+  st->print(\"x21=\"); print_location(st, uc->context_x[21]);\n+  st->print(\"x22=\"); print_location(st, uc->context_x[22]);\n+  st->print(\"x23=\"); print_location(st, uc->context_x[23]);\n+  st->print(\"x24=\"); print_location(st, uc->context_x[24]);\n+  st->print(\"x25=\"); print_location(st, uc->context_x[25]);\n+  st->print(\"x26=\"); print_location(st, uc->context_x[26]);\n+  st->print(\"x27=\"); print_location(st, uc->context_x[27]);\n+  st->print(\"x28=\"); print_location(st, uc->context_x[28]);\n+\n+  st->cr();\n+}\n+\n+void os::setup_fpu() {\n+}\n+\n+#ifndef PRODUCT\n+void os::verify_stack_alignment() {\n+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+}\n+#endif\n+\n+int os::extra_bang_size_in_bytes() {\n+  \/\/ AArch64 does not require the additional stack bang.\n+  return 0;\n+}\n+\n+void os::current_thread_enable_wx(WXMode mode) {\n+  pthread_jit_write_protect_np(mode == WXExec);\n+}\n+\n+extern \"C\" {\n+  int SpinPause() {\n+    return 0;\n+  }\n+\n+  void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+    if (from > to) {\n+      const jshort *end = from + count;\n+      while (from < end)\n+        *(to++) = *(from++);\n+    }\n+    else if (from < to) {\n+      const jshort *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        *(to--) = *(from--);\n+    }\n+  }\n+  void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+    if (from > to) {\n+      const jint *end = from + count;\n+      while (from < end)\n+        *(to++) = *(from++);\n+    }\n+    else if (from < to) {\n+      const jint *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        *(to--) = *(from--);\n+    }\n+  }\n+  void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+    if (from > to) {\n+      const jlong *end = from + count;\n+      while (from < end)\n+        os::atomic_copy64(from++, to++);\n+    }\n+    else if (from < to) {\n+      const jlong *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        os::atomic_copy64(from--, to--);\n+    }\n+  }\n+\n+  void _Copy_arrayof_conjoint_bytes(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count);\n+  }\n+  void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,\n+                                      HeapWord* to,\n+                                      size_t    count) {\n+    memmove(to, from, count * 2);\n+  }\n+  void _Copy_arrayof_conjoint_jints(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count * 4);\n+  }\n+  void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,\n+                                     HeapWord* to,\n+                                     size_t    count) {\n+    memmove(to, from, count * 8);\n+  }\n+};\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":737,"deletions":0,"binary":false,"changes":737,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_OS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_OS_BSD_AARCH64_HPP\n+\n+  static void setup_fpu();\n+\n+  static bool is_allocatable(size_t bytes);\n+\n+  \/\/ Used to register dynamic code cache area with the OS\n+  \/\/ Note: Currently only used in 64 bit Windows implementations\n+  static bool register_code_area(char *low, char *high) { return true; }\n+\n+  \/\/ Atomically copy 64 bits of data\n+  static void atomic_copy64(const volatile void *src, volatile void *dst) {\n+    *(jlong *) dst = *(const jlong *) src;\n+  }\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_OS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_PREFETCH_BSD_AARCH64_INLINE_HPP\n+#define OS_CPU_BSD_AARCH64_PREFETCH_BSD_AARCH64_INLINE_HPP\n+\n+#include \"runtime\/prefetch.hpp\"\n+\n+\n+inline void Prefetch::read (void *loc, intx interval) {\n+  if (interval >= 0)\n+    asm(\"prfm PLDL1KEEP, [%0, %1]\" : : \"r\"(loc), \"r\"(interval));\n+}\n+\n+inline void Prefetch::write(void *loc, intx interval) {\n+  if (interval >= 0)\n+    asm(\"prfm PSTL1KEEP, [%0, %1]\" : : \"r\"(loc), \"r\"(interval));\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_PREFETCH_BSD_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/prefetch_bsd_aarch64.inline.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+frame JavaThread::pd_last_frame() {\n+  assert(has_last_Java_frame(), \"must have last_Java_sp() when suspended\");\n+  vmassert(_anchor.last_Java_pc() != NULL, \"not walkable\");\n+  return frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());\n+}\n+\n+\/\/ For Forte Analyzer AsyncGetCallTrace profiling support - thread is\n+\/\/ currently interrupted by SIGPROF\n+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,\n+  void* ucontext, bool isInJava) {\n+  assert(Thread::current() == this, \"caller must be current thread\");\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava) {\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava) {\n+  assert(this->is_Java_thread(), \"must be JavaThread\");\n+  JavaThread* jt = (JavaThread *)this;\n+\n+  \/\/ If we have a last_Java_frame, then we should use it even if\n+  \/\/ isInJava == true.  It should be more reliable than ucontext info.\n+  if (jt->has_last_Java_frame() && jt->frame_anchor()->walkable()) {\n+    *fr_addr = jt->pd_last_frame();\n+    return true;\n+  }\n+\n+  \/\/ At this point, we don't have a last_Java_frame, so\n+  \/\/ we try to glean some information out of the ucontext\n+  \/\/ if we were running Java code when SIGPROF came in.\n+  if (isInJava) {\n+    ucontext_t* uc = (ucontext_t*) ucontext;\n+\n+    intptr_t* ret_fp;\n+    intptr_t* ret_sp;\n+    address addr = os::fetch_frame_from_context(uc, &ret_sp, &ret_fp);\n+    if (addr == NULL || ret_sp == NULL ) {\n+      \/\/ ucontext wasn't useful\n+      return false;\n+    }\n+\n+    if (MetaspaceShared::is_in_trampoline_frame(addr)) {\n+      \/\/ In the middle of a trampoline call. Bail out for safety.\n+      \/\/ This happens rarely so shouldn't affect profiling.\n+      return false;\n+    }\n+\n+    frame ret_frame(ret_sp, ret_fp, addr);\n+    if (!ret_frame.safe_for_sender(jt)) {\n+#if COMPILER2_OR_JVMCI\n+      \/\/ C2 and JVMCI use ebp as a general register see if NULL fp helps\n+      frame ret_frame2(ret_sp, NULL, addr);\n+      if (!ret_frame2.safe_for_sender(jt)) {\n+        \/\/ nothing else to try if the frame isn't good\n+        return false;\n+      }\n+      ret_frame = ret_frame2;\n+#else\n+      \/\/ nothing else to try if the frame isn't good\n+      return false;\n+#endif \/\/ COMPILER2_OR_JVMCI\n+    }\n+    *fr_addr = ret_frame;\n+    return true;\n+  }\n+\n+  \/\/ nothing else to try\n+  return false;\n+}\n+\n+void JavaThread::cache_global_variables() { }\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/thread_bsd_aarch64.cpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP\n+\n+ private:\n+  void pd_initialize() {\n+    _anchor.clear();\n+  }\n+\n+  frame pd_last_frame();\n+\n+ public:\n+  static ByteSize last_Java_fp_offset()          {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();\n+  }\n+\n+  static ByteSize saved_fp_address_offset() {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::saved_fp_address_offset();\n+  }\n+\n+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,\n+    bool isInJava);\n+\n+  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);\n+\n+private:\n+  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);\n+public:\n+\n+  static Thread *aarch64_get_thread_helper() {\n+    return Thread::current();\n+  }\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/thread_bsd_aarch64.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VMSTRUCTS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_VMSTRUCTS_BSD_AARCH64_HPP\n+\n+\/\/ These are the OS and CPU-specific fields, types and integer\n+\/\/ constants required by the Serviceability Agent. This file is\n+\/\/ referenced by vmStructs.cpp.\n+\n+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \\\n+                                                                                                                                     \\\n+  \/******************************\/                                                                                                   \\\n+  \/* Threads (NOTE: incomplete) *\/                                                                                                   \\\n+  \/******************************\/                                                                                                   \\\n+  nonstatic_field(OSThread,                      _thread_id,                                      OSThread::thread_id_t)             \\\n+  nonstatic_field(OSThread,                      _unique_thread_id,                               uint64_t)\n+\n+\n+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \\\n+                                                                          \\\n+  \/**********************\/                                                \\\n+  \/* Thread IDs         *\/                                                \\\n+  \/**********************\/                                                \\\n+                                                                          \\\n+  declare_unsigned_integer_type(OSThread::thread_id_t)\n+\n+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VMSTRUCTS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vmStructs_bsd_aarch64.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+#include <sys\/sysctl.h>\n+\n+int VM_Version::get_current_sve_vector_length() {\n+  ShouldNotCallThis();\n+  return -1;\n+}\n+\n+int VM_Version::set_and_get_current_sve_vector_length(int length) {\n+  ShouldNotCallThis();\n+  return -1;\n+}\n+\n+static bool cpu_has(const char* optional) {\n+  uint32_t val;\n+  size_t len = sizeof(val);\n+  if (sysctlbyname(optional, &val, &len, NULL, 0)) {\n+    return false;\n+  }\n+  return val;\n+}\n+\n+void VM_Version::get_os_cpu_info() {\n+  size_t sysctllen;\n+\n+  \/\/ hw.optional.floatingpoint always returns 1, see\n+  \/\/ https:\/\/github.com\/apple\/darwin-xnu\/blob\/master\/bsd\/kern\/kern_mib.c#L416.\n+  \/\/ ID_AA64PFR0_EL1 describes AdvSIMD always equals to FP field.\n+  assert(cpu_has(\"hw.optional.floatingpoint\"), \"should be\");\n+  assert(cpu_has(\"hw.optional.neon\"), \"should be\");\n+  _features = CPU_FP | CPU_ASIMD;\n+\n+  \/\/ Only few features are available via sysctl, see line 614\n+  \/\/ https:\/\/opensource.apple.com\/source\/xnu\/xnu-6153.141.1\/bsd\/kern\/kern_mib.c.auto.html\n+  if (cpu_has(\"hw.optional.armv8_crc32\"))     _features |= CPU_CRC32;\n+  if (cpu_has(\"hw.optional.armv8_1_atomics\")) _features |= CPU_LSE;\n+\n+  int cache_line_size;\n+  int hw_conf_cache_line[] = { CTL_HW, HW_CACHELINE };\n+  sysctllen = sizeof(cache_line_size);\n+  if (sysctl(hw_conf_cache_line, 2, &cache_line_size, &sysctllen, NULL, 0)) {\n+    cache_line_size = 16;\n+  }\n+  _icache_line_size = 16; \/\/ minimal line lenght CCSIDR_EL1 can hold\n+  _dcache_line_size = cache_line_size;\n+\n+  uint64_t dczid_el0;\n+  __asm__ (\n+    \"mrs %0, DCZID_EL0\\n\"\n+    : \"=r\"(dczid_el0)\n+  );\n+  if (!(dczid_el0 & 0x10)) {\n+    _zva_length = 4 << (dczid_el0 & 0xf);\n+  }\n+\n+  int family;\n+  sysctllen = sizeof(family);\n+  if (sysctlbyname(\"hw.cpufamily\", &family, &sysctllen, NULL, 0)) {\n+    family = 0;\n+  }\n+  _model = family;\n+  _cpu = CPU_APPLE;\n+}\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -1271,0 +1271,4 @@\n+  \/\/ Enable WXWrite: the function is called by c1 stub as a runtime function\n+  \/\/ (see another implementation above).\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/threadWXSetters.hpp\"\n@@ -51,0 +52,4 @@\n+  \/\/ Enable WXWrite: the function is called direclty from nmethod_entry_barrier\n+  \/\/ stub.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite));\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -974,0 +974,3 @@\n+  \/\/ Enable WXWrite: the function is called directly by interpreter.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -245,0 +245,2 @@\n+  void pass_byte()                               { \/* ignore *\/ }\n+  void pass_short()                              { \/* ignore *\/ }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,4 +127,5 @@\n-#define JVMCI_VM_ENTRY_MARK                   \\\n-  ThreadInVMfromNative __tiv(thread);         \\\n-  HandleMarkCleaner __hm(thread);             \\\n-  Thread* THREAD = thread;                    \\\n+#define JVMCI_VM_ENTRY_MARK                                       \\\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));       \\\n+  ThreadInVMfromNative __tiv(thread);                             \\\n+  HandleMarkCleaner __hm(thread);                                 \\\n+  Thread* THREAD = thread;                                        \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"runtime\/threadWXSetters.hpp\"\n@@ -1413,0 +1414,4 @@\n+\n+  \/\/ Enable WXWrite: the function called directly by compiled code.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3633,0 +3633,1 @@\n+    MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n@@ -3784,0 +3785,1 @@\n+  MACOS_AARCH64_ONLY(thread->init_wx());\n@@ -3857,0 +3859,1 @@\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n@@ -3924,0 +3927,4 @@\n+  \/\/ Go to the execute mode, the initial state of the thread on creation.\n+  \/\/ Use os interface as the thread is not a java one anymore.\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thr));         \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -436,0 +436,2 @@\n+    <xsl:text>MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));<\/xsl:text>\n+    <xsl:value-of select=\"$space\"\/>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-JNI_END\n\\ No newline at end of file\n+JNI_END\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -408,0 +408,1 @@\n+      MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));\n@@ -459,0 +460,1 @@\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));\n@@ -465,0 +467,1 @@\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-  ClearPendingJniExcCheck _clearCheck(env);\n+  ClearPendingJniExcCheck _clearCheck(env); \\\n+  MACOS_AARCH64_ONLY(ThreadWXEnable _wx(WXWrite, thread));\n","filename":"src\/hotspot\/share\/prims\/whitebox.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#include \"runtime\/threadWXSetters.hpp\"\n@@ -2458,0 +2459,3 @@\n+  \/\/ Enable WXWrite: current function is called from methods compiled by C2 directly\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1855,1 +1855,1 @@\n-          \"Unguard page and retry on no-execute fault (Win32 only) \"        \\\n+          \"Unguard page and retry on no-execute fault \"                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/threadWXSetters.hpp\"\n@@ -338,0 +339,1 @@\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite));                  \\\n@@ -360,0 +362,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -386,0 +389,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -394,0 +398,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -423,0 +428,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -447,0 +453,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -456,0 +463,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-\n@@ -112,0 +111,2 @@\n+\n+  MACOS_AARCH64_ONLY(_thread->enable_wx(WXExec));\n@@ -118,0 +119,2 @@\n+  MACOS_AARCH64_ONLY(_thread->enable_wx(WXWrite));\n+\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,5 @@\n+enum WXMode {\n+  WXWrite,\n+  WXExec\n+};\n+\n@@ -929,0 +934,5 @@\n+#if defined(__APPLE__) && defined(AARCH64)\n+  \/\/ Enables write or execute access to writeable and executable pages.\n+  static void current_thread_enable_wx(WXMode mode);\n+#endif \/\/ __APPLE__ && AARCH64\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/threadWXSetters.hpp\"\n@@ -761,0 +762,3 @@\n+  \/\/ Enable WXWrite: the function is called implicitly from java code.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -384,2 +384,0 @@\n-    case T_SHORT:\n-    case T_INT:\n@@ -387,0 +385,2 @@\n+      pass_byte();  _jni_offset++; _offset++;\n+      break;\n@@ -388,0 +388,4 @@\n+    case T_SHORT:\n+      pass_short();  _jni_offset++; _offset++;\n+      break;\n+    case T_INT:\n@@ -421,0 +425,2 @@\n+  virtual void pass_byte()             { pass_int(); };\n+  virtual void pass_short()            { pass_int(); };\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n@@ -289,0 +289,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n@@ -362,0 +364,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -491,20 +491,0 @@\n-\/\/ Safefetch allows to load a value from a location that's not known\n-\/\/ to be valid. If the load causes a fault, the error value is returned.\n-inline int SafeFetch32(int* adr, int errValue) {\n-  assert(StubRoutines::SafeFetch32_stub(), \"stub not yet generated\");\n-  return StubRoutines::SafeFetch32_stub()(adr, errValue);\n-}\n-inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {\n-  assert(StubRoutines::SafeFetchN_stub(), \"stub not yet generated\");\n-  return StubRoutines::SafeFetchN_stub()(adr, errValue);\n-}\n-\n-\n-\/\/ returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)\n-inline bool CanUseSafeFetch32() {\n-  return StubRoutines::SafeFetch32_stub() ? true : false;\n-}\n-\n-inline bool CanUseSafeFetchN() {\n-  return StubRoutines::SafeFetchN_stub() ? true : false;\n-}\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_STUBROUTINES_INLINE_HPP\n+#define SHARE_RUNTIME_STUBROUTINES_INLINE_HPP\n+\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threadWXSetters.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+\/\/ Safefetch allows to load a value from a location that's not known\n+\/\/ to be valid. If the load causes a fault, the error value is returned.\n+inline int SafeFetch32(int* adr, int errValue) {\n+  assert(StubRoutines::SafeFetch32_stub(), \"stub not yet generated\");\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));\n+  return StubRoutines::SafeFetch32_stub()(adr, errValue);\n+}\n+inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {\n+  assert(StubRoutines::SafeFetchN_stub(), \"stub not yet generated\");\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));\n+  return StubRoutines::SafeFetchN_stub()(adr, errValue);\n+}\n+\n+\n+\/\/ returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)\n+inline bool CanUseSafeFetch32() {\n+  return StubRoutines::SafeFetch32_stub() ? true : false;\n+}\n+\n+inline bool CanUseSafeFetchN() {\n+  return StubRoutines::SafeFetchN_stub() ? true : false;\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_STUBROUTINES_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.inline.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -109,0 +109,1 @@\n+#include \"runtime\/threadWXSetters.hpp\"\n@@ -327,0 +328,2 @@\n+\n+  MACOS_AARCH64_ONLY(DEBUG_ONLY(_wx_init = false));\n@@ -390,0 +393,2 @@\n+  MACOS_AARCH64_ONLY(this->init_wx());\n+\n@@ -2509,0 +2514,3 @@\n+  \/\/ Enable WXWrite: called directly from interpreter native wrapper.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n@@ -3445,0 +3453,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+\n@@ -3548,0 +3558,1 @@\n+  MACOS_AARCH64_ONLY(main_thread->init_wx());\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -840,0 +840,9 @@\n+\n+#if defined(__APPLE__) && defined(AARCH64)\n+ private:\n+  DEBUG_ONLY(bool _wx_init);\n+  WXMode _wx_state;\n+ public:\n+  void init_wx();\n+  WXMode enable_wx(WXMode new_state);\n+#endif \/\/ __APPLE__ && AARCH64\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -97,0 +97,21 @@\n+#if defined(__APPLE__) && defined(AARCH64)\n+inline void Thread::init_wx() {\n+  assert(this == Thread::current(), \"should only be called for current thread\");\n+  assert(!_wx_init, \"second init\");\n+  _wx_state = WXWrite;\n+  os::current_thread_enable_wx(_wx_state);\n+  DEBUG_ONLY(_wx_init = true);\n+}\n+\n+inline WXMode Thread::enable_wx(WXMode new_state) {\n+  assert(this == Thread::current(), \"should only be called for current thread\");\n+  assert(_wx_init, \"should be inited\");\n+  WXMode old = _wx_state;\n+  if (_wx_state != new_state) {\n+    _wx_state = new_state;\n+    os::current_thread_enable_wx(new_state);\n+  }\n+  return old;\n+}\n+#endif \/\/ __APPLE__ && AARCH64\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_THREADWXSETTERS_HPP\n+#define SHARE_RUNTIME_THREADWXSETTERS_HPP\n+\n+#include \"runtime\/thread.inline.hpp\"\n+\n+#if defined(__APPLE__) && defined(AARCH64)\n+class ThreadWXEnable  {\n+  Thread* _thread;\n+  WXMode _old_mode;\n+public:\n+  ThreadWXEnable(WXMode new_mode, Thread* thread = NULL) :\n+    _thread(thread ? thread : Thread::current()),\n+    _old_mode(_thread->enable_wx(new_mode))\n+  { }\n+  ~ThreadWXEnable() {\n+    _thread->enable_wx(_old_mode);\n+  }\n+};\n+#endif \/\/ __APPLE__ && AARCH64\n+\n+#endif \/\/ SHARE_RUNTIME_THREADWXSETTERS_HPP\n+\n","filename":"src\/hotspot\/share\/runtime\/threadWXSetters.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -572,0 +572,2 @@\n+#define MACOS_AARCH64_ONLY(x) MACOS_ONLY(AARCH64_ONLY(x))\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || defined(PPC64))\n+#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || defined(PPC64) || (defined(BSD) && defined (__aarch64__)))\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -213,0 +213,2 @@\n+#elif defined(__aarch64__)\n+        preferredJVM = \"server\";\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-#if defined(TARGET_OS_MAC)\n+\/\/ Condition was copied from\n+\/\/ Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/gssapi\/gssapi.h\n+#if TARGET_OS_MAC && (defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__))\n@@ -698,1 +700,1 @@\n-#if defined(TARGET_OS_MAC)\n+#if TARGET_OS_MAC && (defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__))\n","filename":"src\/java.security.jgss\/share\/native\/libj2gss\/gssapi.h","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,7 +47,1 @@\n-#define UNSUPPORTED_ARCH \"Unsupported architecture!\"\n-\n-#if defined(x86_64) && !defined(amd64)\n-#define amd64 1\n-#endif\n-\n-#if amd64\n+#if defined(amd64)\n@@ -55,0 +49,2 @@\n+#elif defined(aarch64)\n+#include \"sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h\"\n@@ -167,8 +163,1 @@\n-#if defined(__i386__)\n-    #define hsdb_thread_state_t     x86_thread_state32_t\n-    #define hsdb_float_state_t      x86_float_state32_t\n-    #define HSDB_THREAD_STATE       x86_THREAD_STATE32\n-    #define HSDB_FLOAT_STATE        x86_FLOAT_STATE32\n-    #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT\n-    #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE32_COUNT\n-#elif defined(__x86_64__)\n+#if defined(amd64)\n@@ -181,0 +170,7 @@\n+#elif defined(aarch64)\n+    #define hsdb_thread_state_t     arm_thread_state64_t\n+    #define hsdb_float_state_t      arm_neon_state64_t\n+    #define HSDB_THREAD_STATE       ARM_THREAD_STATE64\n+    #define HSDB_FLOAT_STATE        ARM_NEON_STATE64\n+    #define HSDB_THREAD_STATE_COUNT ARM_THREAD_STATE64_COUNT\n+    #define HSDB_FLOAT_STATE_COUNT  ARM_NEON_STATE64_COUNT\n@@ -465,0 +461,1 @@\n+#if defined(amd64)\n@@ -470,0 +467,9 @@\n+#elif defined(aarch64)\n+      if ((regs.r_sp < end && regs.r_sp >= beg) ||\n+          (regs.r_fp < end && regs.r_fp >= beg)) {\n+        set_lwp_id(ph, i, uid);\n+        break;\n+      }\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n@@ -501,1 +507,1 @@\n-#if amd64\n+#if defined(amd64)\n@@ -504,0 +510,6 @@\n+#elif defined(aarch64)\n+#define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG\n+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n@@ -509,0 +521,2 @@\n+#if defined(amd64)\n+\n@@ -537,0 +551,40 @@\n+#elif defined(aarch64)\n+\n+  regs[REG_INDEX(R0)] = gregs.r_r0;\n+  regs[REG_INDEX(R1)] = gregs.r_r1;\n+  regs[REG_INDEX(R2)] = gregs.r_r2;\n+  regs[REG_INDEX(R3)] = gregs.r_r3;\n+  regs[REG_INDEX(R4)] = gregs.r_r4;\n+  regs[REG_INDEX(R5)] = gregs.r_r5;\n+  regs[REG_INDEX(R6)] = gregs.r_r6;\n+  regs[REG_INDEX(R7)] = gregs.r_r7;\n+  regs[REG_INDEX(R8)] = gregs.r_r8;\n+  regs[REG_INDEX(R9)] = gregs.r_r9;\n+  regs[REG_INDEX(R10)] = gregs.r_r10;\n+  regs[REG_INDEX(R11)] = gregs.r_r11;\n+  regs[REG_INDEX(R12)] = gregs.r_r12;\n+  regs[REG_INDEX(R13)] = gregs.r_r13;\n+  regs[REG_INDEX(R14)] = gregs.r_r14;\n+  regs[REG_INDEX(R15)] = gregs.r_r15;\n+  regs[REG_INDEX(R16)] = gregs.r_r16;\n+  regs[REG_INDEX(R17)] = gregs.r_r17;\n+  regs[REG_INDEX(R18)] = gregs.r_r18;\n+  regs[REG_INDEX(R19)] = gregs.r_r19;\n+  regs[REG_INDEX(R20)] = gregs.r_r20;\n+  regs[REG_INDEX(R21)] = gregs.r_r21;\n+  regs[REG_INDEX(R22)] = gregs.r_r22;\n+  regs[REG_INDEX(R23)] = gregs.r_r23;\n+  regs[REG_INDEX(R24)] = gregs.r_r24;\n+  regs[REG_INDEX(R25)] = gregs.r_r25;\n+  regs[REG_INDEX(R26)] = gregs.r_r26;\n+  regs[REG_INDEX(R27)] = gregs.r_r27;\n+  regs[REG_INDEX(R28)] = gregs.r_r28;\n+  regs[REG_INDEX(FP)] = gregs.r_fp;\n+  regs[REG_INDEX(LR)] = gregs.r_lr;\n+  regs[REG_INDEX(SP)] = gregs.r_sp;\n+  regs[REG_INDEX(PC)] = gregs.r_pc;\n+\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n+\n@@ -538,1 +592,0 @@\n-#endif \/* amd64 *\/\n@@ -633,1 +686,2 @@\n-#if amd64\n+#undef NPRGREG\n+#if defined(amd64)\n@@ -635,2 +689,5 @@\n-#undef REG_INDEX\n-#define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg\n+#elif defined(aarch64)\n+#define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n@@ -644,0 +701,2 @@\n+#if defined(amd64)\n+\n@@ -672,1 +731,0 @@\n-  print_debug(\"set registers\\n\");\n@@ -674,1 +732,35 @@\n-  (*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);\n+#elif defined(aarch64)\n+\n+  primitiveArray[REG_INDEX(R0)] = state.__x[0];\n+  primitiveArray[REG_INDEX(R1)] = state.__x[1];\n+  primitiveArray[REG_INDEX(R2)] = state.__x[2];\n+  primitiveArray[REG_INDEX(R3)] = state.__x[3];\n+  primitiveArray[REG_INDEX(R4)] = state.__x[4];\n+  primitiveArray[REG_INDEX(R5)] = state.__x[5];\n+  primitiveArray[REG_INDEX(R6)] = state.__x[6];\n+  primitiveArray[REG_INDEX(R7)] = state.__x[7];\n+  primitiveArray[REG_INDEX(R8)] = state.__x[8];\n+  primitiveArray[REG_INDEX(R9)] = state.__x[9];\n+  primitiveArray[REG_INDEX(R10)] = state.__x[10];\n+  primitiveArray[REG_INDEX(R11)] = state.__x[11];\n+  primitiveArray[REG_INDEX(R12)] = state.__x[12];\n+  primitiveArray[REG_INDEX(R13)] = state.__x[13];\n+  primitiveArray[REG_INDEX(R14)] = state.__x[14];\n+  primitiveArray[REG_INDEX(R15)] = state.__x[15];\n+  primitiveArray[REG_INDEX(R16)] = state.__x[16];\n+  primitiveArray[REG_INDEX(R17)] = state.__x[17];\n+  primitiveArray[REG_INDEX(R18)] = state.__x[18];\n+  primitiveArray[REG_INDEX(R19)] = state.__x[19];\n+  primitiveArray[REG_INDEX(R20)] = state.__x[20];\n+  primitiveArray[REG_INDEX(R21)] = state.__x[21];\n+  primitiveArray[REG_INDEX(R22)] = state.__x[22];\n+  primitiveArray[REG_INDEX(R23)] = state.__x[23];\n+  primitiveArray[REG_INDEX(R24)] = state.__x[24];\n+  primitiveArray[REG_INDEX(R25)] = state.__x[25];\n+  primitiveArray[REG_INDEX(R26)] = state.__x[26];\n+  primitiveArray[REG_INDEX(R27)] = state.__x[27];\n+  primitiveArray[REG_INDEX(R28)] = state.__x[28];\n+  primitiveArray[REG_INDEX(FP)] = state.__fp;\n+  primitiveArray[REG_INDEX(LR)] = state.__lr;\n+  primitiveArray[REG_INDEX(SP)] = state.__sp;\n+  primitiveArray[REG_INDEX(PC)] = state.__pc;\n@@ -678,1 +770,3 @@\n-#endif \/* amd64 *\/\n+#endif\n+\n+  print_debug(\"set registers\\n\");\n@@ -680,0 +774,1 @@\n+  (*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/MacosxDebuggerLocal.m","additions":118,"deletions":23,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -33,0 +33,10 @@\n+#define UNSUPPORTED_ARCH \"Unsupported architecture!\"\n+\n+#if defined(__x86_64__) && !defined(amd64)\n+#define amd64 1\n+#endif\n+\n+#if defined(__arm64__) && !defined(aarch64)\n+#define aarch64 1\n+#endif\n+\n@@ -45,0 +55,1 @@\n+#if defined(amd64)\n@@ -75,0 +86,42 @@\n+#elif defined(aarch64)\n+\/*** registers copied from bsd\/arm64 *\/\n+typedef struct reg {\n+  register_t      r_r0;\n+  register_t      r_r1;\n+  register_t      r_r2;\n+  register_t      r_r3;\n+  register_t      r_r4;\n+  register_t      r_r5;\n+  register_t      r_r6;\n+  register_t      r_r7;\n+  register_t      r_r8;\n+  register_t      r_r9;\n+  register_t      r_r10;\n+  register_t      r_r11;\n+  register_t      r_r12;\n+  register_t      r_r13;\n+  register_t      r_r14;\n+  register_t      r_r15;\n+  register_t      r_r16;\n+  register_t      r_r17;\n+  register_t      r_r18;\n+  register_t      r_r19;\n+  register_t      r_r20;\n+  register_t      r_r21;\n+  register_t      r_r22;\n+  register_t      r_r23;\n+  register_t      r_r24;\n+  register_t      r_r25;\n+  register_t      r_r26;\n+  register_t      r_r27;\n+  register_t      r_r28;\n+  register_t      r_fp;\n+  register_t      r_lr;\n+  register_t      r_sp;\n+  register_t      r_pc;\n+} reg;\n+\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n+\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/libproc_impl.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#if defined(amd64)\n@@ -37,0 +38,4 @@\n+#elif defined(aarch64)\n+#include \"sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h\"\n+#else\n+#error UNSUPPORTED_ARCH\n@@ -38,0 +43,1 @@\n+#endif \/* __APPLE__ *\/\n@@ -198,0 +204,2 @@\n+\n+#if defined(amd64)\n@@ -219,0 +227,39 @@\n+\n+#elif defined(aarch64)\n+  print_debug(\" r_r0:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r0);\n+  print_debug(\" r_r1:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r1);\n+  print_debug(\" r_r2:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r2);\n+  print_debug(\" r_r3:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r3);\n+  print_debug(\" r_r4:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r4);\n+  print_debug(\" r_r5:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r5);\n+  print_debug(\" r_r6:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r6);\n+  print_debug(\" r_r7:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r7);\n+  print_debug(\" r_r8:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r8);\n+  print_debug(\" r_r9:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r9);\n+  print_debug(\" r_r10: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r10);\n+  print_debug(\" r_r11: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r11);\n+  print_debug(\" r_r12: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r12);\n+  print_debug(\" r_r13: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r13);\n+  print_debug(\" r_r14: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r14);\n+  print_debug(\" r_r15: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r15);\n+  print_debug(\" r_r16: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r16);\n+  print_debug(\" r_r17: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r17);\n+  print_debug(\" r_r18: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r18);\n+  print_debug(\" r_r19: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r19);\n+  print_debug(\" r_r20: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r20);\n+  print_debug(\" r_r21: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r21);\n+  print_debug(\" r_r22: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r22);\n+  print_debug(\" r_r23: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r23);\n+  print_debug(\" r_r24: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r24);\n+  print_debug(\" r_r25: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r25);\n+  print_debug(\" r_r26: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r26);\n+  print_debug(\" r_r27: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r27);\n+  print_debug(\" r_r28: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r28);\n+  print_debug(\" r_fp:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_fp);\n+  print_debug(\" r_lr:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_lr);\n+  print_debug(\" r_sp:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_sp);\n+  print_debug(\" r_pc:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_pc);\n+\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n@@ -272,0 +319,1 @@\n+#if defined(amd64)\n@@ -331,0 +379,84 @@\n+\n+#elif defined(aarch64)\n+        if (fc.flavor == ARM_THREAD_STATE64) {\n+          arm_thread_state64_t thrstate;\n+          if (read(fd, (void *)&thrstate, sizeof(arm_thread_state64_t)) != sizeof(arm_thread_state64_t)) {\n+            printf(\"Reading flavor, count failed.\\n\");\n+            goto err;\n+          }\n+          size += sizeof(arm_thread_state64_t);\n+          \/\/ create thread info list, update lwp_id later\n+          sa_thread_info* newthr = add_thread_info(ph, (pthread_t) -1, (lwpid_t) num_threads++);\n+          if (newthr == NULL) {\n+            printf(\"create thread_info failed\\n\");\n+            goto err;\n+          }\n+\n+          \/\/ note __DARWIN_UNIX03 depengs on other definitions\n+#if __DARWIN_UNIX03\n+#define get_register_v(regst, regname) \\\n+  regst.__##regname\n+#else\n+#define get_register_v(regst, regname) \\\n+  regst.##regname\n+#endif \/\/ __DARWIN_UNIX03\n+          newthr->regs.r_r0  = get_register_v(thrstate, x[0]);\n+          newthr->regs.r_r1  = get_register_v(thrstate, x[1]);\n+          newthr->regs.r_r2  = get_register_v(thrstate, x[2]);\n+          newthr->regs.r_r3  = get_register_v(thrstate, x[3]);\n+          newthr->regs.r_r4  = get_register_v(thrstate, x[4]);\n+          newthr->regs.r_r5  = get_register_v(thrstate, x[5]);\n+          newthr->regs.r_r6  = get_register_v(thrstate, x[6]);\n+          newthr->regs.r_r7  = get_register_v(thrstate, x[7]);\n+          newthr->regs.r_r8  = get_register_v(thrstate, x[8]);\n+          newthr->regs.r_r9  = get_register_v(thrstate, x[9]);\n+          newthr->regs.r_r10 = get_register_v(thrstate, x[10]);\n+          newthr->regs.r_r11 = get_register_v(thrstate, x[11]);\n+          newthr->regs.r_r12 = get_register_v(thrstate, x[12]);\n+          newthr->regs.r_r13 = get_register_v(thrstate, x[13]);\n+          newthr->regs.r_r14 = get_register_v(thrstate, x[14]);\n+          newthr->regs.r_r15 = get_register_v(thrstate, x[15]);\n+          newthr->regs.r_r16 = get_register_v(thrstate, x[16]);\n+          newthr->regs.r_r17 = get_register_v(thrstate, x[17]);\n+          newthr->regs.r_r18 = get_register_v(thrstate, x[18]);\n+          newthr->regs.r_r19 = get_register_v(thrstate, x[19]);\n+          newthr->regs.r_r20 = get_register_v(thrstate, x[20]);\n+          newthr->regs.r_r21 = get_register_v(thrstate, x[21]);\n+          newthr->regs.r_r22 = get_register_v(thrstate, x[22]);\n+          newthr->regs.r_r23 = get_register_v(thrstate, x[23]);\n+          newthr->regs.r_r24 = get_register_v(thrstate, x[24]);\n+          newthr->regs.r_r25 = get_register_v(thrstate, x[25]);\n+          newthr->regs.r_r26 = get_register_v(thrstate, x[26]);\n+          newthr->regs.r_r27 = get_register_v(thrstate, x[27]);\n+          newthr->regs.r_r28 = get_register_v(thrstate, x[28]);\n+          newthr->regs.r_fp  = get_register_v(thrstate, fp);\n+          newthr->regs.r_lr  = get_register_v(thrstate, lr);\n+          newthr->regs.r_sp  = get_register_v(thrstate, sp);\n+          newthr->regs.r_pc  = get_register_v(thrstate, pc);\n+          print_thread(newthr);\n+        } else if (fc.flavor == ARM_NEON_STATE64) {\n+          arm_neon_state64_t flstate;\n+          if (read(fd, (void *)&flstate, sizeof(arm_neon_state64_t)) != sizeof(arm_neon_state64_t)) {\n+            printf(\"Reading flavor, count failed.\\n\");\n+            goto err;\n+          }\n+          size += sizeof(arm_neon_state64_t);\n+        } else if (fc.flavor == ARM_EXCEPTION_STATE64) {\n+          arm_exception_state64_t excpstate;\n+          if (read(fd, (void *)&excpstate, sizeof(arm_exception_state64_t)) != sizeof(arm_exception_state64_t)) {\n+            printf(\"Reading flavor, count failed.\\n\");\n+            goto err;\n+          }\n+          size += sizeof(arm_exception_state64_t);\n+        } else if (fc.flavor == ARM_DEBUG_STATE64) {\n+          arm_debug_state64_t dbgstate;\n+          if (read(fd, (void *)&dbgstate, sizeof(arm_debug_state64_t)) != sizeof(arm_debug_state64_t)) {\n+            printf(\"Reading flavor, count failed.\\n\");\n+            goto err;\n+          }\n+          size += sizeof(arm_debug_state64_t);\n+        }\n+\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/ps_core.c","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -624,0 +624,2 @@\n+        } else if (cpu.equals(\"aarch64\")) {\n+            machDesc = new MachineDescriptionAArch64();\n@@ -625,1 +627,1 @@\n-            throw new DebuggerException(\"Darwin only supported on x86_64. Current arch: \" + cpu);\n+            throw new DebuggerException(\"Darwin only supported on x86_64\/aarch64. Current arch: \" + cpu);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotAgent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import sun.jvm.hotspot.debugger.aarch64.*;\n@@ -35,0 +36,1 @@\n+import sun.jvm.hotspot.debugger.bsd.aarch64.*;\n@@ -100,0 +102,7 @@\n+    } else if (cpu.equals(\"aarch64\")) {\n+       AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();\n+       Address fp = context.getRegisterAsAddress(AARCH64ThreadContext.FP);\n+       if (fp == null) return null;\n+       Address pc  = context.getRegisterAsAddress(AARCH64ThreadContext.PC);\n+       if (pc == null) return null;\n+       return new BsdAARCH64CFrame(dbg, fp, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdCDebugger.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.jvm.hotspot.debugger.bsd.aarch64.*;\n@@ -38,0 +39,2 @@\n+      } else if (cpu.equals(\"aarch64\")) {\n+         return new BsdAARCH64ThreadContext(dbg);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdThreadContextFactory.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.bsd.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.bsd.*;\n+import sun.jvm.hotspot.debugger.cdbg.*;\n+import sun.jvm.hotspot.debugger.cdbg.basic.*;\n+\n+final public class BsdAARCH64CFrame extends BasicCFrame {\n+   public BsdAARCH64CFrame(BsdDebugger dbg, Address fp, Address pc) {\n+      super(dbg.getCDebugger());\n+      this.fp = fp;\n+      this.pc = pc;\n+      this.dbg = dbg;\n+   }\n+\n+   \/\/ override base class impl to avoid ELF parsing\n+   public ClosestSymbol closestSymbolToPC() {\n+      \/\/ try native lookup in debugger.\n+      return dbg.lookup(dbg.getAddressValue(pc()));\n+   }\n+\n+   public Address pc() {\n+      return pc;\n+   }\n+\n+   public Address localVariableBase() {\n+      return fp;\n+   }\n+\n+   public CFrame sender(ThreadProxy thread) {\n+      AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();\n+      Address rsp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+\n+      if ((fp == null) || fp.lessThan(rsp)) {\n+        return null;\n+      }\n+\n+      \/\/ Check alignment of fp\n+      if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+        return null;\n+      }\n+\n+      Address nextFP = fp.getAddressAt(0 * ADDRESS_SIZE);\n+      if (nextFP == null || nextFP.lessThanOrEqual(fp)) {\n+        return null;\n+      }\n+      Address nextPC  = fp.getAddressAt(1 * ADDRESS_SIZE);\n+      if (nextPC == null) {\n+        return null;\n+      }\n+      return new BsdAARCH64CFrame(dbg, nextFP, nextPC);\n+   }\n+\n+   \/\/ package\/class internals only\n+   private static final int ADDRESS_SIZE = 8;\n+   private Address pc;\n+   private Address sp;\n+   private Address fp;\n+   private BsdDebugger dbg;\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/aarch64\/BsdAARCH64CFrame.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.bsd.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.bsd.*;\n+\n+public class BsdAARCH64ThreadContext extends AARCH64ThreadContext {\n+  private BsdDebugger debugger;\n+\n+  public BsdAARCH64ThreadContext(BsdDebugger debugger) {\n+    super();\n+    this.debugger = debugger;\n+  }\n+\n+  public void setRegisterAsAddress(int index, Address value) {\n+    setRegister(index, debugger.getAddressValue(value));\n+  }\n+\n+  public Address getRegisterAsAddress(int index) {\n+    return debugger.newAddress(getRegister(index));\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/aarch64\/BsdAARCH64ThreadContext.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.jvm.hotspot.runtime.bsd_aarch64.BsdAARCH64JavaThreadPDAccess;\n@@ -135,0 +136,2 @@\n+            } else if (cpu.equals(\"aarch64\")) {\n+                access = new BsdAARCH64JavaThreadPDAccess();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime.bsd_aarch64;\n+\n+import java.io.*;\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.bsd.BsdDebugger;\n+import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.aarch64.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.*;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+public class BsdAARCH64JavaThreadPDAccess implements JavaThreadPDAccess {\n+  private static AddressField  lastJavaFPField;\n+  private static AddressField  osThreadField;\n+\n+  \/\/ Fields from OSThread\n+  private static CIntegerField osThreadThreadIDField;\n+  private static CIntegerField osThreadUniqueThreadIDField;\n+\n+  \/\/ This is currently unneeded but is being kept in case we change\n+  \/\/ the currentFrameGuess algorithm\n+  private static final long GUESS_SCAN_RANGE = 128 * 1024;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"JavaThread\");\n+    osThreadField           = type.getAddressField(\"_osthread\");\n+\n+    Type anchorType = db.lookupType(\"JavaFrameAnchor\");\n+    lastJavaFPField         = anchorType.getAddressField(\"_last_Java_fp\");\n+\n+    Type osThreadType = db.lookupType(\"OSThread\");\n+    osThreadThreadIDField = osThreadType.getCIntegerField(\"_thread_id\");\n+    osThreadUniqueThreadIDField = osThreadType.getCIntegerField(\"_unique_thread_id\");\n+  }\n+\n+  public Address getLastJavaFP(Address addr) {\n+    return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));\n+  }\n+\n+  public Address getLastJavaPC(Address addr) {\n+    return null;\n+  }\n+\n+  public Address getBaseOfStackPointer(Address addr) {\n+    return null;\n+  }\n+\n+  public Frame getLastFramePD(JavaThread thread, Address addr) {\n+    Address fp = thread.getLastJavaFP();\n+    if (fp == null) {\n+      return null; \/\/ no information\n+    }\n+    return new AARCH64Frame(thread.getLastJavaSP(), fp);\n+  }\n+\n+  public RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {\n+    return new AARCH64RegisterMap(thread, updateMap);\n+  }\n+\n+  public Frame getCurrentFrameGuess(JavaThread thread, Address addr) {\n+    ThreadProxy t = getThreadProxy(addr);\n+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();\n+    AARCH64CurrentFrameGuess guesser = new AARCH64CurrentFrameGuess(context, thread);\n+    if (!guesser.run(GUESS_SCAN_RANGE)) {\n+      return null;\n+    }\n+    if (guesser.getPC() == null) {\n+      return new AARCH64Frame(guesser.getSP(), guesser.getFP());\n+    } else {\n+      return new AARCH64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n+    }\n+  }\n+\n+  public void printThreadIDOn(Address addr, PrintStream tty) {\n+    tty.print(getThreadProxy(addr));\n+  }\n+\n+  public void printInfoOn(Address threadAddr, PrintStream tty) {\n+    tty.print(\"Thread id: \");\n+    printThreadIDOn(threadAddr, tty);\n+\/\/    tty.println(\"\\nPostJavaState: \" + getPostJavaState(threadAddr));\n+  }\n+\n+  public Address getLastSP(Address addr) {\n+    ThreadProxy t = getThreadProxy(addr);\n+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();\n+    return context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+  }\n+\n+  public ThreadProxy getThreadProxy(Address addr) {\n+    \/\/ Addr is the address of the JavaThread.\n+    \/\/ Fetch the OSThread (for now and for simplicity, not making a\n+    \/\/ separate \"OSThread\" class in this package)\n+    Address osThreadAddr = osThreadField.getValue(addr);\n+    \/\/ Get the address of the _thread_id from the OSThread\n+    Address threadIdAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());\n+    Address uniqueThreadIdAddr = osThreadAddr.addOffsetTo(osThreadUniqueThreadIDField.getOffset());\n+\n+    BsdDebuggerLocal debugger = (BsdDebuggerLocal) VM.getVM().getDebugger();\n+    return debugger.getThreadForIdentifierAddress(threadIdAddr, uniqueThreadIdAddr);\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/bsd_aarch64\/BsdAARCH64JavaThreadPDAccess.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -110,1 +110,4 @@\n-ARCH=$(ARCH1:i686=i386)\n+ARCH2=$(ARCH1:arm64=aarch64)\n+ARCH=$(ARCH2:i686=i386)\n+CONFIGURE_ARGS\/aarch64= --enable-targets=aarch64-darwin\n+CONFIGURE_ARGS = $(CONFIGURE_ARGS\/$(ARCH))\n@@ -114,1 +117,1 @@\n-ARCH=$(ARCH1:amd64=i386)\n+ARCH=$(ARCH2:amd64=i386)\n@@ -117,0 +120,3 @@\n+ifeq ($(CPU), arm64)\n+CFLAGS\/aarch64  += -m64\n+endif # arm64\n","filename":"src\/utils\/hsdis\/Makefile","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+#include \"runtime\/thread.inline.hpp\"\n+\n@@ -94,1 +96,8 @@\n-  return JNI_CreateJavaVM(&jvm, (void**)&env, &args);\n+  int ret = JNI_CreateJavaVM(&jvm, (void**)&env, &args);\n+  if (ret == JNI_OK) {\n+    \/\/ CreateJavaVM leaves WXExec context, while gtests\n+    \/\/ calls internal functions assuming running in WXWwrite.\n+    \/\/ Switch to WXWrite once for all test cases.\n+    MACOS_AARCH64_ONLY(Thread::current()->enable_wx(WXWrite));\n+  }\n+  return ret;\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires os.arch == \"aarch64\" & os.family == \"mac\"\n+ * @run main\/othervm\/native TestCodegenAttach\n+ *\/\n+\n+public class TestCodegenAttach {\n+\n+    static native void testCodegenAttach();\n+\n+    static {\n+        System.loadLibrary(\"codegenAttach\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        testCodegenAttach();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/codegenAttachThread\/TestCodegenAttach.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h>\n+\n+#include \"jni.h\"\n+\n+#if defined(__APPLE__) && defined(__aarch64__)\n+\n+#include <pthread.h>\n+#include <sys\/mman.h>\n+\n+JavaVM* jvm;\n+\n+static void* codegen;\n+\n+static int thread_start2(int val) {\n+  JNIEnv *env;\n+  jclass class_id;\n+  jmethodID method_id;\n+  int res;\n+\n+  printf(\"Native thread is running and attaching ...\\n\");\n+\n+  res = (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't attach current thread: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  res = (*jvm)->DetachCurrentThread(jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't detach current thread: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  printf(\"Native thread is about to finish\\n\");\n+  return 1 + val;\n+}\n+\n+static int trampoline(int(*fn)(int), int arg) {\n+  int val = fn(arg);\n+  \/\/ ensure code in MAP_JIT area after target function returns\n+  return 1 + val;\n+}\n+\n+static void * thread_start(void* unused) {\n+  int val = ((int(*)(int(*)(int),int))codegen)(thread_start2, 10);\n+  printf(\"return val = %d\\n\", val);\n+  return NULL;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_TestCodegenAttach_testCodegenAttach\n+(JNIEnv *env, jclass cls) {\n+\n+  codegen = mmap(NULL, 0x1000,\n+      PROT_READ | PROT_WRITE | PROT_EXEC,\n+      MAP_PRIVATE | MAP_ANONYMOUS | MAP_JIT, -1, 0);\n+  if (codegen == MAP_FAILED) {\n+    perror(\"mmap\");\n+    exit(1);\n+  }\n+\n+  pthread_jit_write_protect_np(false);\n+\n+  memcpy(codegen, trampoline, 128);\n+\n+  pthread_jit_write_protect_np(true);\n+\n+  pthread_t thread;\n+  int res = (*env)->GetJavaVM(env, &jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't extract JavaVM: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  if ((res = pthread_create(&thread, NULL, thread_start, NULL)) != 0) {\n+    fprintf(stderr, \"TEST ERROR: pthread_create failed: %s (%d)\\n\", strerror(res), res);\n+    exit(1);\n+  }\n+\n+  if ((res = pthread_join(thread, NULL)) != 0) {\n+    fprintf(stderr, \"TEST ERROR: pthread_join failed: %s (%d)\\n\", strerror(res), res);\n+    exit(1);\n+  }\n+}\n+\n+#else\n+\n+JNIEXPORT void JNICALL\n+Java_TestCodegenAttach_testCodegenAttach\n+(JNIEnv *env, jclass cls) {\n+  printf(\"should not reach here\\n\");\n+  exit(1);\n+}\n+\n+#endif \/\/ __APPLE__ && __aarch64__\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/codegenAttachThread\/libcodegenAttach.c","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -534,0 +534,2 @@\n+        {\"macosx-aarch64\",  \"com.sun.jdi.SharedMemoryAttach\"},\n+        {\"mac-aarch64\",     \"com.sun.jdi.SharedMemoryAttach\"},\n@@ -557,0 +559,2 @@\n+        {\"macosx-aarch64\",  \"com.sun.jdi.SharedMemoryListen\"},\n+        {\"mac-aarch64\",     \"com.sun.jdi.SharedMemoryListen\"},\n@@ -614,2 +618,8 @@\n-        {\"mac-x64\",         \"com.sun.jdi.CommandLineLaunch\", \"dt_shmem\"},\n-        {\"mac-x64\",         \"com.sun.jdi.RawCommandLineLaunch\", \"dt_shmem\"},\n+        {\"mac-x64\",          \"com.sun.jdi.CommandLineLaunch\", \"dt_shmem\"},\n+        {\"mac-x64\",          \"com.sun.jdi.RawCommandLineLaunch\", \"dt_shmem\"},\n+\n+        {\"macosx-aarch64\",   \"com.sun.jdi.CommandLineLaunch\", \"dt_shmem\"},\n+        {\"macosx-aarch64\",   \"com.sun.jdi.RawCommandLineLaunch\", \"dt_shmem\"},\n+\n+        {\"mac-aarch64\",      \"com.sun.jdi.CommandLineLaunch\", \"dt_shmem\"},\n+        {\"mac-aarch64\",      \"com.sun.jdi.RawCommandLineLaunch\", \"dt_shmem\"},\n@@ -632,0 +642,2 @@\n+        {\"macosx-aarch64\",  \"dt_shmem\"},\n+        {\"mac-aarch64\",     \"dt_shmem\"},\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/ArgumentHandler.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"}]}