{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import javax.crypto.BadPaddingException;\n@@ -31,2 +30,0 @@\n-import javax.crypto.IllegalBlockSizeException;\n-import javax.crypto.NoSuchPaddingException;\n@@ -35,4 +32,0 @@\n-import java.security.InvalidAlgorithmParameterException;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.InvalidParameterSpecException;\n@@ -40,0 +33,7 @@\n+\/**\n+ * This performance tests runs AES\/GCM encryption and decryption using byte[]\n+ * as input and output buffers for single and multi-part testing.\n+ *\n+ * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n+ * benchmark operation\n+ *\/\n@@ -43,3 +43,0 @@\n-    @Param({\"AES\/GCM\/NoPadding\"})\n-    private String algorithm;\n-\n@@ -49,1 +46,1 @@\n-    @Param({\"\"+16*1024})\n+    @Param({\"1024\", \"1500\", \"4096\", \"16384\"})\n@@ -52,1 +49,0 @@\n-    byte[] data;\n@@ -54,0 +50,1 @@\n+    byte[] in, out;\n@@ -58,1 +55,0 @@\n-    byte[] aad;\n@@ -61,2 +57,2 @@\n-    public static final int IV_BUFFER_SIZE = 32;\n-    public static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n+    private static final int IV_BUFFER_SIZE = 32;\n+    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n@@ -64,0 +60,1 @@\n+    int updateLen = 0;\n@@ -72,1 +69,1 @@\n-    public void setup() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException, InvalidParameterSpecException {\n+    public void setup() throws Exception {\n@@ -74,1 +71,0 @@\n-        assert algorithm.split(\"\/\")[1].compareToIgnoreCase(\"GCM\") == 0;\n@@ -76,0 +72,1 @@\n+        \/\/ Setup key material\n@@ -80,2 +77,3 @@\n-        aad = fillSecureRandom(new byte[5]);\n-        encryptCipher = makeCipher(prov, algorithm);\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n@@ -83,4 +81,12 @@\n-        encryptCipher.updateAAD(aad);\n-        decryptCipher = makeCipher(prov, algorithm);\n-        data = fillRandom(new byte[dataSize]);\n-        encryptedData = encryptCipher.doFinal(data);\n+        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        \/\/ Setup input\/output buffers\n+        in = fillRandom(new byte[dataSize]);\n+        encryptedData = new byte[encryptCipher.getOutputSize(in.length)];\n+        out = new byte[encryptedData.length];\n+        encryptCipher.doFinal(in, 0, in.length, encryptedData, 0);\n+        updateLen = in.length \/ 2;\n+\n@@ -90,1 +96,1 @@\n-    public byte[] encrypt() throws BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException, InvalidKeyException {\n+    public void encrypt() throws Exception {\n@@ -93,2 +99,1 @@\n-        encryptCipher.updateAAD(aad);\n-        return encryptCipher.doFinal(data);\n+        encryptCipher.doFinal(in, 0, in.length, out, 0);\n@@ -98,4 +103,14 @@\n-    public byte[] decrypt() throws BadPaddingException, IllegalBlockSizeException, InvalidParameterSpecException, InvalidAlgorithmParameterException, InvalidKeyException {\n-        decryptCipher.init(Cipher.DECRYPT_MODE, ks, encryptCipher.getParameters().getParameterSpec(GCMParameterSpec.class));\n-        decryptCipher.updateAAD(aad);\n-        return decryptCipher.doFinal(encryptedData);\n+    public void encryptMultiPart() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        int outOfs = encryptCipher.update(in, 0, updateLen, out, 0);\n+        encryptCipher.doFinal(in, updateLen, in.length - updateLen,\n+            out, outOfs);\n+    }\n+\n+    @Benchmark\n+    public void decrypt() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+        decryptCipher.doFinal(encryptedData, 0, encryptedData.length, out, 0);\n@@ -104,0 +119,9 @@\n+    @Benchmark\n+    public void decryptMultiPart() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+        decryptCipher.update(encryptedData, 0, updateLen, out, 0);\n+        decryptCipher.doFinal(encryptedData, updateLen,\n+            encryptedData.length - updateLen, out, 0);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMBench.java","additions":54,"deletions":30,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+\n+\/**\n+ * This performance tests runs AES\/GCM encryption and decryption using heap and\n+ * direct ByteBuffers as input and output buffers for single and multi-part\n+ * operations.\n+ *\n+ * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n+ * benchmark operation\n+ *\/\n+\n+public class AESGCMByteBuffer extends CryptoBase {\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"\" + 1024, \"\" + 1500, \"\" + 4096, \"\" + 16384})\n+    private int dataSize;\n+\n+    @Param({\"direct\", \"heap\"})\n+    private String dataMethod;\n+\n+    byte[] data;\n+    ByteBuffer encryptedData;\n+    ByteBuffer in, out;\n+    private Cipher encryptCipher;\n+    private Cipher decryptCipher;\n+    SecretKeySpec ks;\n+    GCMParameterSpec gcm_spec;\n+    byte[] iv;\n+\n+    private static final int IV_BUFFER_SIZE = 32;\n+    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n+    int iv_index = 0;\n+    int updateLen = 0;\n+\n+    private int next_iv_index() {\n+        int r = iv_index;\n+        iv_index = (iv_index + 1) % IV_MODULO;\n+        return r;\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        setupProvider();\n+\n+        \/\/ Setup key material\n+        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n+        ks = new SecretKeySpec(keystring, \"AES\");\n+        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        \/\/ Setup input\/output buffers\n+        data = fillRandom(new byte[dataSize]);\n+        if (dataMethod.equalsIgnoreCase(\"direct\")) {\n+            in = ByteBuffer.allocateDirect(data.length);\n+            in.put(data);\n+            in.flip();\n+            encryptedData = ByteBuffer.allocateDirect(\n+                encryptCipher.getOutputSize(data.length));\n+            out = ByteBuffer.allocateDirect(encryptedData.capacity());\n+        } else if (dataMethod.equalsIgnoreCase(\"heap\")) {\n+            in = ByteBuffer.wrap(data);\n+            encryptedData = ByteBuffer.allocate(\n+                encryptCipher.getOutputSize(data.length));\n+            out = ByteBuffer.allocate(encryptedData.capacity());\n+        }\n+\n+        encryptCipher.doFinal(in, encryptedData);\n+        encryptedData.flip();\n+        in.flip();\n+        updateLen = in.remaining() \/ 2;\n+    }\n+\n+    @Benchmark\n+    public void encrypt() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        encryptCipher.doFinal(in, out);\n+        out.flip();\n+        in.flip();\n+    }\n+\n+    @Benchmark\n+    public void encryptMultiPart() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        in.limit(updateLen);\n+        encryptCipher.update(in, out);\n+        in.limit(in.capacity());\n+        encryptCipher.doFinal(in, out);\n+        out.flip();\n+        in.flip();\n+    }\n+\n+    @Benchmark\n+    public void decrypt() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+        decryptCipher.doFinal(encryptedData, out);\n+        encryptedData.flip();\n+        out.flip();\n+    }\n+\n+    @Benchmark\n+    public void decryptMultiPart() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        int len = encryptedData.remaining();\n+        encryptedData.limit(updateLen);\n+        decryptCipher.update(encryptedData, out);\n+        encryptedData.limit(len);\n+\n+        decryptCipher.doFinal(encryptedData, out);\n+        encryptedData.flip();\n+        out.flip();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMByteBuffer.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,5 +27,2 @@\n-public class AESGCMBench extends org.openjdk.bench.javax.crypto.full.AESGCMBench {\n-\n-\n-    @Param({\"AES\/GCM\/NoPadding\"})\n-    private String algorithm;\n+public class AESGCMBench extends\n+    org.openjdk.bench.javax.crypto.full.AESGCMBench {\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/small\/AESGCMBench.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.small;\n+\n+import org.openjdk.jmh.annotations.Param;\n+\n+public class AESGCMByteBuffer extends\n+    org.openjdk.bench.javax.crypto.full.AESGCMByteBuffer {\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"1024\"})\n+    private int dataSize;\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/small\/AESGCMByteBuffer.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"}]}