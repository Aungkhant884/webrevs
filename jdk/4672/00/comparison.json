{"files":[{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+\/**\n+ * This performance tests runs AES\/GCM encryption and decryption using byte[]\n+ * as input and output buffers for single and multi-part testing.\n+ *\n+ * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n+ * benchmark operation\n+ *\/\n+\n+public class AESGCMByteArray extends CryptoBase {\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"\" + 1024, \"\" +  1500, \"\" + 4096})\n+    private int dataSize;\n+\n+    byte[] encryptedData;\n+    byte[] in, out;\n+    private Cipher encryptCipher;\n+    private Cipher decryptCipher;\n+    SecretKeySpec ks;\n+    GCMParameterSpec gcm_spec;\n+    byte[] iv;\n+\n+    private static final int IV_BUFFER_SIZE = 32;\n+    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n+    int iv_index = 0;\n+    int updateLen = 0;\n+\n+    private int next_iv_index() {\n+        int r = iv_index;\n+        iv_index = (iv_index + 1) % IV_MODULO;\n+        return r;\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        setupProvider();\n+\n+        \/\/ Setup key material\n+        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n+        ks = new SecretKeySpec(keystring, \"AES\");\n+        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        \/\/ Setup input\/output buffers\n+        in = fillRandom(new byte[dataSize]);\n+        encryptedData = new byte[encryptCipher.getOutputSize(in.length)];\n+        out = new byte[encryptedData.length];\n+        encryptCipher.doFinal(in, 0, in.length, encryptedData, 0);\n+        updateLen = in.length \/ 2;\n+\n+    }\n+\n+    @Benchmark\n+    public void encrypt() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        encryptCipher.doFinal(in, 0, in.length, out, 0);\n+    }\n+\n+    @Benchmark\n+    public void encryptMultiPart() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        int outOfs = encryptCipher.update(in, 0, updateLen, out, 0);\n+        encryptCipher.doFinal(in, updateLen, in.length - updateLen,\n+            out, outOfs);\n+    }\n+\n+    @Benchmark\n+    public void decrypt() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+        decryptCipher.doFinal(encryptedData, 0, encryptedData.length, out, 0);\n+    }\n+\n+    @Benchmark\n+    public void decryptMultiPart() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+        decryptCipher.update(encryptedData, 0, updateLen, out, 0);\n+        decryptCipher.doFinal(encryptedData, updateLen,\n+            encryptedData.length - updateLen, out, 0);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMByteArray.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+\n+\/**\n+ * This performance tests runs AES\/GCM encryption and decryption using heap and\n+ * direct ByteBuffers as input and output buffers for single and multi-part\n+ * operations.\n+ *\n+ * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n+ * benchmark operation\n+ *\/\n+\n+public class AESGCMByteBuffer extends CryptoBase {\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"\" + 1024, \"\" + 1500, \"\" + 4096})\n+    private int dataSize;\n+\n+    @Param({\"direct\", \"heap\"})\n+    private String dataMethod;\n+\n+    byte[] data;\n+    ByteBuffer encryptedData;\n+    ByteBuffer in, out;\n+    private Cipher encryptCipher;\n+    private Cipher decryptCipher;\n+    SecretKeySpec ks;\n+    GCMParameterSpec gcm_spec;\n+    byte[] iv;\n+\n+    private static final int IV_BUFFER_SIZE = 32;\n+    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n+    int iv_index = 0;\n+    int updateLen = 0;\n+\n+    private int next_iv_index() {\n+        int r = iv_index;\n+        iv_index = (iv_index + 1) % IV_MODULO;\n+        return r;\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        setupProvider();\n+\n+        \/\/ Setup key material\n+        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n+        ks = new SecretKeySpec(keystring, \"AES\");\n+        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        \/\/ Setup input\/output buffers\n+        data = fillRandom(new byte[dataSize]);\n+        if (dataMethod.equalsIgnoreCase(\"direct\")) {\n+            in = ByteBuffer.allocateDirect(data.length);\n+            in.put(data);\n+            in.flip();\n+            encryptedData = ByteBuffer.allocateDirect(\n+                encryptCipher.getOutputSize(data.length));\n+            out = ByteBuffer.allocateDirect(encryptedData.capacity());\n+        } else if (dataMethod.equalsIgnoreCase(\"heap\")) {\n+            in = ByteBuffer.wrap(data);\n+            encryptedData = ByteBuffer.allocate(\n+                encryptCipher.getOutputSize(data.length));\n+            out = ByteBuffer.allocate(encryptedData.capacity());\n+        }\n+\n+        encryptCipher.doFinal(in, encryptedData);\n+        encryptedData.flip();\n+        in.flip();\n+        updateLen = in.remaining() \/ 2;\n+    }\n+\n+    @Benchmark\n+    public void encrypt() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        encryptCipher.doFinal(in, out);\n+        out.flip();\n+        in.flip();\n+    }\n+\n+    @Benchmark\n+    public void encryptMultiPart() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        in.limit(updateLen);\n+        encryptCipher.update(in, out);\n+        in.limit(in.capacity());\n+        encryptCipher.doFinal(in, out);\n+        out.flip();\n+        in.flip();\n+    }\n+\n+    @Benchmark\n+    public void decrypt() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+        decryptCipher.doFinal(encryptedData, out);\n+        encryptedData.flip();\n+        out.flip();\n+    }\n+\n+    @Benchmark\n+    public void decryptMultiPart() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        int len = encryptedData.remaining();\n+        encryptedData.limit(updateLen);\n+        decryptCipher.update(encryptedData, out);\n+        encryptedData.limit(len);\n+\n+        decryptCipher.doFinal(encryptedData, out);\n+        encryptedData.flip();\n+        out.flip();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMByteBuffer.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"}]}