{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -138,0 +139,1 @@\n+KlassSubGraphInfo* HeapShared::_default_subgraph_info;\n@@ -140,0 +142,2 @@\n+OopHandle HeapShared::_scratch_basic_type_mirrors[T_VOID+1];\n+KlassToOopHandleTable* HeapShared::_scratch_java_mirror_table = NULL;\n@@ -346,1 +350,78 @@\n-void HeapShared::archive_klass_objects() {\n+class KlassToOopHandleTable: public ResourceHashtable<Klass*, OopHandle,\n+    36137, \/\/ prime number\n+    AnyObj::C_HEAP,\n+    mtClassShared> {\n+public:\n+  oop get_oop(Klass* k) {\n+    MutexLocker ml(ScratchObjects_lock, Mutex::_no_safepoint_check_flag);\n+    OopHandle* handle = get(k);\n+    if (handle != NULL) {\n+      return handle->resolve();\n+    } else {\n+      return NULL;\n+    }\n+  }\n+  void set_oop(Klass* k, oop o) {\n+    MutexLocker ml(ScratchObjects_lock, Mutex::_no_safepoint_check_flag);\n+    OopHandle handle(Universe::vm_global(), o);\n+    bool is_new = put(k, handle);\n+    assert(is_new, \"cannot set twice\");\n+  }\n+  void remove_oop(Klass* k) {\n+    MutexLocker ml(ScratchObjects_lock, Mutex::_no_safepoint_check_flag);\n+    OopHandle* handle = get(k);\n+    if (handle != NULL) {\n+      handle->release(Universe::vm_global());\n+      remove(k);\n+    }\n+  }\n+};\n+\n+void HeapShared::init_scratch_objects(TRAPS) {\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (!is_reference_type(bt)) {\n+      oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n+      _scratch_basic_type_mirrors[i] = OopHandle(Universe::vm_global(), m);\n+    }\n+  }\n+  _scratch_java_mirror_table = new (mtClass)KlassToOopHandleTable();\n+}\n+\n+oop HeapShared::scratch_java_mirror(BasicType t) {\n+  assert((uint)t < T_VOID+1, \"range check\");\n+  assert(!is_reference_type(t), \"sanity\");\n+  return _scratch_basic_type_mirrors[t].resolve();\n+}\n+\n+oop HeapShared::scratch_java_mirror(Klass* k) {\n+  return _scratch_java_mirror_table->get_oop(k);\n+}\n+\n+void HeapShared::set_scratch_java_mirror(Klass* k, oop mirror) {\n+  _scratch_java_mirror_table->set_oop(k, mirror);\n+}\n+\n+void HeapShared::remove_scratch_objects(Klass* k) {\n+  _scratch_java_mirror_table->remove_oop(k);\n+}\n+\n+void HeapShared::archive_java_mirrors() {\n+  init_seen_objects_table();\n+\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (!is_reference_type(bt)) {\n+      oop m = _scratch_basic_type_mirrors[i].resolve();\n+      assert(m != NULL, \"sanity\");\n+      oop archived_m = archive_reachable_objects_from(1, _default_subgraph_info, m, \/*is_closed_archive=*\/ false);\n+      assert(archived_m != NULL, \"sanity\");\n+\n+      log_trace(cds, heap, mirror)(\n+        \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+        type2name(bt), p2i(m), p2i(archived_m));\n+\n+      Universe::set_archived_basic_type_mirror_index(bt, append_root(archived_m));\n+    }\n+  }\n+\n@@ -350,9 +431,17 @@\n-    Klass* k = ArchiveBuilder::get_buffered_klass(klasses->at(i));\n-\n-    \/\/ archive mirror object\n-    java_lang_Class::archive_mirror(k);\n-\n-    \/\/ archive the resolved_referenes array\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      ik->constants()->archive_resolved_references();\n+    Klass* orig_k = klasses->at(i);\n+    oop m = scratch_java_mirror(orig_k);\n+    if (m != NULL) {\n+      Klass* buffered_k = ArchiveBuilder::get_buffered_klass(orig_k);\n+      oop archived_m = archive_reachable_objects_from(1, _default_subgraph_info, m, \/*is_closed_archive=*\/ false);\n+      guarantee(archived_m != NULL, \"scratch mirrors should not point to any unachivable objects\");\n+      buffered_k->set_archived_java_mirror(append_root(archived_m));\n+      ResourceMark rm;\n+      log_trace(cds, heap, mirror)(\n+        \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+        buffered_k->external_name(), p2i(m), p2i(archived_m));\n+\n+      \/\/ archive the resolved_referenes array\n+      if (buffered_k->is_instance_klass()) {\n+        InstanceKlass* ik = InstanceKlass::cast(buffered_k);\n+        ik->constants()->archive_resolved_references();\n+      }\n@@ -361,0 +450,2 @@\n+\n+  delete_seen_objects_table();\n@@ -504,0 +595,2 @@\n+    _default_subgraph_info = init_subgraph_info(vmClasses::Object_klass(), false);\n+\n@@ -519,0 +612,1 @@\n+    check_default_subgraph_classes();\n@@ -545,3 +639,1 @@\n-  java_lang_Class::archive_basic_type_mirrors();\n-\n-  archive_klass_objects();\n+  archive_java_mirrors();\n@@ -1137,3 +1229,5 @@\n-        LogTarget(Trace, cds, heap) log;\n-        LogStream out(log);\n-        obj->print_on(&out);\n+        if (log_is_enabled(Trace, cds, heap)) {\n+          LogTarget(Trace, cds, heap) log;\n+          LogStream out(log);\n+          obj->print_on(&out);\n+        }\n@@ -1216,1 +1310,1 @@\n-  if (java_lang_Class::is_instance(orig_obj)) {\n+  if (java_lang_Class::is_instance(orig_obj) && subgraph_info != _default_subgraph_info) {\n@@ -1434,0 +1528,25 @@\n+\/\/ The \"default subgraph\" contains special objects (see heapShared.hpp) that\n+\/\/ can be accessed before we load any Java classes (including java\/lang\/Class).\n+\/\/ Make sure that these are only instances of the very few specific types\n+\/\/ that we can handle.\n+void HeapShared::check_default_subgraph_classes() {\n+  GrowableArray<Klass*>* klasses = _default_subgraph_info->subgraph_object_klasses();\n+  int num = klasses->length();\n+  for (int i = 0; i < num; i++) {\n+    Klass* subgraph_k = klasses->at(i);\n+    if (log_is_enabled(Info, cds, heap)) {\n+      ResourceMark rm;\n+      log_info(cds, heap)(\n+          \"Archived object klass (default subgraph %d) => %s\",\n+          i, subgraph_k->external_name());\n+    }\n+\n+    guarantee(subgraph_k->name()->equals(\"java\/lang\/Class\") ||\n+              subgraph_k->name()->equals(\"java\/lang\/String\") ||\n+              subgraph_k->name()->equals(\"[Ljava\/lang\/Object;\") ||\n+              subgraph_k->name()->equals(\"[C\") ||\n+              subgraph_k->name()->equals(\"[B\"),\n+              \"default subgraph can have only these objects\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":137,"deletions":18,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+class KlassToOopHandleTable;\n@@ -159,0 +160,5 @@\n+\n+  \/\/ Scratch objects for archiving Klass::java_mirror()\n+  static oop scratch_java_mirror(BasicType t) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static oop scratch_java_mirror(Klass* k)    NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+\n@@ -250,0 +256,1 @@\n+  static void check_default_subgraph_classes();\n@@ -272,0 +279,7 @@\n+  \/\/ The \"default subgraph\" is the root of all archived objects that do not belong to any\n+  \/\/ of the classes defined in the <xxx>_archive_subgraph_entry_fields[] arrays:\n+  \/\/    - interned strings\n+  \/\/    - Klass::java_mirror()\n+  \/\/    - ConstantPool::resolved_references()\n+  static KlassSubGraphInfo* _default_subgraph_info;\n+\n@@ -274,0 +288,2 @@\n+  static OopHandle _scratch_basic_type_mirrors[T_VOID+1];\n+  static KlassToOopHandleTable* _scratch_java_mirror_table;\n@@ -361,1 +377,1 @@\n-  static void archive_klass_objects();\n+  static void archive_java_mirrors();\n@@ -377,0 +393,4 @@\n+  \/\/ Scratch objects for archiving Klass::java_mirror()\n+  static void set_scratch_java_mirror(Klass* k, oop mirror);\n+  static void remove_scratch_objects(Klass* k);\n+\n@@ -406,0 +426,1 @@\n+  static void init_scratch_objects(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -809,12 +809,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-static void initialize_static_string_field_for_dump(fieldDescriptor* fd, Handle mirror) {\n-  DEBUG_ONLY(assert_valid_static_string_field(fd);)\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert(HeapShared::is_archived_object_during_dumptime(mirror()), \"must be\");\n-  \/\/ Archive the String field and update the pointer.\n-  oop s = mirror()->obj_field(fd->offset());\n-  oop archived_s = StringTable::create_archived_string(s);\n-  mirror()->obj_field_put(fd->offset(), archived_s);\n-}\n-#endif\n-\n@@ -867,13 +855,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-static void initialize_static_field_for_dump(fieldDescriptor* fd, Handle mirror) {\n-  assert(mirror.not_null() && fd->is_static(), \"just checking\");\n-  if (fd->has_initial_value()) {\n-    if (fd->field_type() != T_OBJECT) {\n-      initialize_static_primitive_field(fd, mirror);\n-    } else {\n-      initialize_static_string_field_for_dump(fd, mirror);\n-    }\n-  }\n-}\n-#endif\n-\n@@ -976,0 +951,55 @@\n+void java_lang_Class::allocate_mirror(Klass* k, bool is_scratch, Handle protection_domain, Handle classData,\n+                                      Handle& mirror, Handle& comp_mirror, TRAPS) {\n+  \/\/ Allocate mirror (java.lang.Class instance)\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK);\n+  mirror = Handle(THREAD, mirror_oop);\n+\n+  \/\/ Setup indirection from mirror->klass\n+  set_klass(mirror(), k);\n+\n+  InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror->klass());\n+  assert(oop_size(mirror()) == mk->instance_size(k), \"should have been set\");\n+\n+  set_static_oop_field_count(mirror(), mk->compute_static_oop_field_count(mirror()));\n+\n+  \/\/ It might also have a component mirror.  This mirror must already exist.\n+  if (k->is_array_klass()) {\n+    if (k->is_typeArray_klass()) {\n+      BasicType type = TypeArrayKlass::cast(k)->element_type();\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(type));\n+      } else {\n+        comp_mirror = Handle(THREAD, Universe::java_mirror(type));\n+      }\n+    } else {\n+      assert(k->is_objArray_klass(), \"Must be\");\n+      Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();\n+      assert(element_klass != NULL, \"Must have an element klass\");\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(element_klass));\n+      } else {\n+        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+      }\n+    }\n+    assert(comp_mirror() != NULL, \"must have a mirror\");\n+\n+    \/\/ Two-way link between the array klass and its component mirror:\n+    \/\/ (array_klass) k -> mirror -> component_mirror -> array_klass -> k\n+    set_component_mirror(mirror(), comp_mirror());\n+    \/\/ See below for ordering dependencies between field array_klass in component mirror\n+    \/\/ and java_mirror in this klass.\n+  } else {\n+    assert(k->is_instance_klass(), \"Must be\");\n+\n+    initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ If any of the fields throws an exception like OOM remove the klass field\n+      \/\/ from the mirror so GC doesn't follow it after the klass has been deallocated.\n+      \/\/ This mirror looks like a primitive type, which logically it is because it\n+      \/\/ it represents no class.\n+      set_klass(mirror(), NULL);\n+      return;\n+    }\n+  }\n+}\n+\n@@ -991,3 +1021,1 @@\n-    \/\/ Allocate mirror (java.lang.Class instance)\n-    oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK);\n-    Handle mirror(THREAD, mirror_oop);\n+    Handle mirror;\n@@ -996,39 +1024,1 @@\n-    \/\/ Setup indirection from mirror->klass\n-    set_klass(mirror(), k);\n-\n-    InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror->klass());\n-    assert(oop_size(mirror()) == mk->instance_size(k), \"should have been set\");\n-\n-    set_static_oop_field_count(mirror(), mk->compute_static_oop_field_count(mirror()));\n-\n-    \/\/ It might also have a component mirror.  This mirror must already exist.\n-    if (k->is_array_klass()) {\n-      if (k->is_typeArray_klass()) {\n-        BasicType type = TypeArrayKlass::cast(k)->element_type();\n-        comp_mirror = Handle(THREAD, Universe::java_mirror(type));\n-      } else {\n-        assert(k->is_objArray_klass(), \"Must be\");\n-        Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();\n-        assert(element_klass != NULL, \"Must have an element klass\");\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n-      }\n-      assert(comp_mirror() != NULL, \"must have a mirror\");\n-\n-      \/\/ Two-way link between the array klass and its component mirror:\n-      \/\/ (array_klass) k -> mirror -> component_mirror -> array_klass -> k\n-      set_component_mirror(mirror(), comp_mirror());\n-      \/\/ See below for ordering dependencies between field array_klass in component mirror\n-      \/\/ and java_mirror in this klass.\n-    } else {\n-      assert(k->is_instance_klass(), \"Must be\");\n-\n-      initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        \/\/ If any of the fields throws an exception like OOM remove the klass field\n-        \/\/ from the mirror so GC doesn't follow it after the klass has been deallocated.\n-        \/\/ This mirror looks like a primitive type, which logically it is because it\n-        \/\/ it represents no class.\n-        set_klass(mirror(), NULL);\n-        return;\n-      }\n-    }\n+    allocate_mirror(k, \/*is_scratch=*\/false, protection_domain, classData, mirror, comp_mirror, CHECK);\n@@ -1053,0 +1043,3 @@\n+    if (DumpSharedSpaces) {\n+      create_scratch_mirror(k, CHECK);\n+    }\n@@ -1060,86 +1053,4 @@\n-\/\/ Clears mirror fields. Static final fields with initial values are reloaded\n-\/\/ from constant pool. The object identity hash is in the object header and is\n-\/\/ not affected.\n-class ResetMirrorField: public FieldClosure {\n- private:\n-  Handle _m;\n-\n- public:\n-  ResetMirrorField(Handle mirror) : _m(mirror) {}\n-\n-  void do_field(fieldDescriptor* fd) {\n-    assert(DumpSharedSpaces, \"dump time only\");\n-    assert(_m.not_null(), \"Mirror cannot be NULL\");\n-\n-    if (fd->is_static() && fd->has_initial_value()) {\n-      initialize_static_field_for_dump(fd, _m);\n-      return;\n-    }\n-\n-    BasicType ft = fd->field_type();\n-    switch (ft) {\n-      case T_BYTE:\n-        _m()->byte_field_put(fd->offset(), 0);\n-        break;\n-      case T_CHAR:\n-        _m()->char_field_put(fd->offset(), 0);\n-        break;\n-      case T_DOUBLE:\n-        _m()->double_field_put(fd->offset(), 0);\n-        break;\n-      case T_FLOAT:\n-        _m()->float_field_put(fd->offset(), 0);\n-        break;\n-      case T_INT:\n-        _m()->int_field_put(fd->offset(), 0);\n-        break;\n-      case T_LONG:\n-        _m()->long_field_put(fd->offset(), 0);\n-        break;\n-      case T_SHORT:\n-        _m()->short_field_put(fd->offset(), 0);\n-        break;\n-      case T_BOOLEAN:\n-        _m()->bool_field_put(fd->offset(), false);\n-        break;\n-      case T_ARRAY:\n-      case T_OBJECT: {\n-        \/\/ It might be useful to cache the String field, but\n-        \/\/ for now just clear out any reference field\n-        oop o = _m()->obj_field(fd->offset());\n-        _m()->obj_field_put(fd->offset(), NULL);\n-        break;\n-      }\n-      default:\n-        ShouldNotReachHere();\n-        break;\n-     }\n-  }\n-};\n-\n-void java_lang_Class::archive_basic_type_mirrors() {\n-  assert(HeapShared::can_write(), \"must be\");\n-\n-  for (int t = T_BOOLEAN; t < T_VOID+1; t++) {\n-    BasicType bt = (BasicType)t;\n-    if (!is_reference_type(bt)) {\n-      oop m = Universe::java_mirror(bt);\n-      assert(m != NULL, \"sanity\");\n-      \/\/ Update the field at _array_klass_offset to point to the relocated array klass.\n-      oop archived_m = HeapShared::archive_object(m);\n-      assert(archived_m != NULL, \"sanity\");\n-\n-      \/\/ Clear the fields. Just to be safe\n-      Klass *k = m->klass();\n-      Handle archived_mirror_h(Thread::current(), archived_m);\n-      ResetMirrorField reset(archived_mirror_h);\n-      InstanceKlass::cast(k)->do_nonstatic_fields(&reset);\n-\n-      log_trace(cds, heap, mirror)(\n-        \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-        type2name(bt), p2i(m), p2i(archived_m));\n-\n-      Universe::set_archived_basic_type_mirror_index(bt, HeapShared::append_root(archived_m));\n-    }\n-  }\n-}\n+\/\/ The \"scratch mirror\" stores the states of the mirror object that can be\n+\/\/ decided at dump time (such as the initial values of the static fields, the\n+\/\/ component mirror, etc). At runtime, more information is added to it by\n+\/\/ java_lang_Class::restore_archived_mirror().\n@@ -1147,2 +1058,2 @@\n-\/\/ After the mirror object is successfully archived, the archived\n-\/\/ klass is set with _has_archived_raw_mirror flag.\n+\/\/ Essentially, \/*dumptime*\/create_scratch_mirror() + \/*runtime*\/restore_archived_mirror()\n+\/\/ produces the same result as \/*runtime*\/create_mirror().\n@@ -1150,40 +1061,9 @@\n-\/\/ The _has_archived_raw_mirror flag is cleared at runtime when the\n-\/\/ archived mirror is restored. If archived java heap data cannot\n-\/\/ be used at runtime, new mirror object is created for the shared\n-\/\/ class. The _has_archived_raw_mirror is cleared also during the process.\n-oop java_lang_Class::archive_mirror(Klass* k) {\n-  assert(HeapShared::can_write(), \"must be\");\n-\n-  \/\/ Mirror is already archived\n-  if (k->has_archived_mirror_index()) {\n-    assert(k->archived_java_mirror() != NULL, \"no archived mirror\");\n-    return k->archived_java_mirror();\n-  }\n-\n-  \/\/ No mirror\n-  oop mirror = k->java_mirror();\n-  if (mirror == NULL) {\n-    return NULL;\n-  }\n-\n-  if (k->is_instance_klass()) {\n-    InstanceKlass *ik = InstanceKlass::cast(k);\n-    assert(ik->signers() == NULL, \"class with signer should have been excluded\");\n-\n-    if (!(ik->is_shared_boot_class() || ik->is_shared_platform_class() ||\n-          ik->is_shared_app_class())) {\n-      \/\/ Archiving mirror for classes from non-builtin loaders is not\n-      \/\/ supported.\n-      return NULL;\n-    }\n-  }\n-\n-  \/\/ Now start archiving the mirror object\n-  oop archived_mirror = HeapShared::archive_object(mirror);\n-  if (archived_mirror == NULL) {\n-    return NULL;\n-  }\n-\n-  archived_mirror = process_archived_mirror(k, mirror, archived_mirror);\n-  if (archived_mirror == NULL) {\n-    return NULL;\n+\/\/ Note: we archive the \"scratch mirror\" instead of k->java_mirror(), because the\n+\/\/ latter may contain dumptime-specific information that cannot be archived\n+\/\/ (e.g., ClassLoaderData*, or static fields that are modified by Java code execution).\n+void java_lang_Class::create_scratch_mirror(Klass* k, TRAPS) {\n+  if (k->class_loader() != NULL &&\n+      k->class_loader() != SystemDictionary::java_platform_loader() &&\n+      k->class_loader() != SystemDictionary::java_system_loader()) {\n+    \/\/ We only archive the mirrors of classes loaded by the built-in loaders\n+    return;\n@@ -1192,42 +1072,4 @@\n-  k->set_archived_java_mirror(archived_mirror);\n-\n-  ResourceMark rm;\n-  log_trace(cds, heap, mirror)(\n-    \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-    k->external_name(), p2i(mirror), p2i(archived_mirror));\n-\n-  return archived_mirror;\n-}\n-\n-\/\/ The process is based on create_mirror().\n-oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,\n-                                             oop archived_mirror) {\n-  \/\/ Clear nonstatic fields in archived mirror. Some of the fields will be set\n-  \/\/ to archived metadata and objects below.\n-  Klass *c = archived_mirror->klass();\n-  Handle archived_mirror_h(Thread::current(), archived_mirror);\n-  ResetMirrorField reset(archived_mirror_h);\n-  InstanceKlass::cast(c)->do_nonstatic_fields(&reset);\n-\n-  if (k->is_array_klass()) {\n-    oop archived_comp_mirror;\n-    if (k->is_typeArray_klass()) {\n-      \/\/ The primitive type mirrors are already archived. Get the archived mirror.\n-      oop comp_mirror = component_mirror(mirror);\n-      archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);\n-      assert(archived_comp_mirror != NULL, \"Must be\");\n-    } else {\n-      assert(k->is_objArray_klass(), \"Must be\");\n-      Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();\n-      assert(element_klass != NULL, \"Must have an element klass\");\n-      archived_comp_mirror = archive_mirror(element_klass);\n-      if (archived_comp_mirror == NULL) {\n-        return NULL;\n-      }\n-    }\n-    set_component_mirror(archived_mirror, archived_comp_mirror);\n-  } else {\n-    assert(k->is_instance_klass(), \"Must be\");\n-\n-    \/\/ Reset local static fields in the mirror\n-    InstanceKlass::cast(k)->do_local_static_fields(&reset);\n+  Handle protection_domain, classData; \/\/ set to NULL. Will be reinitialized at runtime\n+  Handle mirror;\n+  Handle comp_mirror;\n+  allocate_mirror(k, \/*is_scratch=*\/true, protection_domain, classData, mirror, comp_mirror, CHECK);\n@@ -1235,3 +1077,2 @@\n-    set_protection_domain(archived_mirror, NULL);\n-    set_signers(archived_mirror, NULL);\n-    set_source_file(archived_mirror, NULL);\n+  if (comp_mirror() != NULL) {\n+    release_set_array_klass(comp_mirror(), k);\n@@ -1240,5 +1081,1 @@\n-  \/\/ clear class loader and mirror_module_field\n-  set_class_loader(archived_mirror, NULL);\n-  set_module(archived_mirror, NULL);\n-\n-  return archived_mirror;\n+  HeapShared::set_scratch_java_mirror(k, mirror());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":83,"deletions":246,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -252,0 +252,2 @@\n+  static void allocate_mirror(Klass* k, bool is_scratch, Handle protection_domain, Handle classData,\n+                              Handle& mirror, Handle& comp_mirror, TRAPS); \/\/ returns mirror and comp_mirror\n@@ -259,4 +261,1 @@\n-  static void archive_basic_type_mirrors() NOT_CDS_JAVA_HEAP_RETURN;\n-  static oop  archive_mirror(Klass* k) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror)\n-                                      NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static void create_scratch_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -481,0 +481,3 @@\n+    if (DumpSharedSpaces) {\n+      HeapShared::init_scratch_objects(CHECK);\n+    }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -695,0 +695,6 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (DumpSharedSpaces) {\n+    HeapShared::remove_scratch_objects(this);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -645,3 +645,3 @@\n-void Klass::set_archived_java_mirror(oop m) {\n-  assert(DumpSharedSpaces, \"called only during runtime\");\n-  _archived_mirror_index = HeapShared::append_root(m);\n+void Klass::set_archived_java_mirror(int mirror_index) {\n+  assert(DumpSharedSpaces, \"called only during dumptime\");\n+  _archived_mirror_index = mirror_index;\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,1 +269,1 @@\n-  void set_archived_java_mirror(oop m) NOT_CDS_JAVA_HEAP_RETURN;\n+  void set_archived_java_mirror(int mirror_index) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,1 @@\n+Mutex*   ScratchObjects_lock          = NULL;\n@@ -332,0 +333,1 @@\n+  def(ScratchObjects_lock          , PaddedMutex  , nosafepoint-1); \/\/ Holds DumpTimeTable_lock\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,0 +129,1 @@\n+extern Mutex*   ScratchObjects_lock;             \/\/ Protecting _scratch_xxx_table in heapShared.cpp\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}