{"files":[{"patch":"@@ -213,1 +213,1 @@\n-<p>Rationale: HotSpot often uses &quot;resource&quot; or &quot;arena&quot; allocation. Even where heap allocation is used, the standard global functions are avoided in favor of wrappers around malloc and free that support the VM's Native Memory Tracking (NMT) feature.<\/p>\n+<p>Rationale: HotSpot often uses &quot;resource&quot; or &quot;arena&quot; allocation. Even where heap allocation is used, the standard global functions are avoided in favor of wrappers around malloc and free that support the VM's Native Memory Tracking (NMT) feature. Typically, uses of the global operator new are inadvertent and therefore often associated with memory leaks.<\/p>\n@@ -273,2 +273,2 @@\n-<p>Do not use <code>thread_local<\/code> (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2659.htm\">n2659<\/a>); instead, use the HotSpot macro <code>THREAD_LOCAL<\/code>. The initializer must be a constant expression.<\/p>\n-<p>As was discussed in the review for <a href=\"https:\/\/mail.openjdk.java.net\/pipermail\/hotspot-dev\/2019-September\/039487.html\">JDK-8230877<\/a>, <code>thread_local<\/code> allows dynamic initialization and destruction semantics. However, that support requires a run-time penalty for references to non-function-local <code>thread_local<\/code> variables defined in a different translation unit, even if they don't need dynamic initialization. Dynamic initialization and destruction of namespace-scoped thread local variables also has the same ordering problems as for ordinary namespace-scoped variables.<\/p>\n+<p>Avoid use of <code>thread_local<\/code> (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2659.htm\">n2659<\/a>); and instead, use the HotSpot macro <code>THREAD_LOCAL<\/code>, for which the initializer must be a constant expression. When <code>thread_local<\/code> must be used, use the Hotspot macro <code>APPROVED_CPP_THREAD_LOCAL<\/code> to indicate that the use has been given appropriate consideration.<\/p>\n+<p>As was discussed in the review for <a href=\"https:\/\/mail.openjdk.java.net\/pipermail\/hotspot-dev\/2019-September\/039487.html\">JDK-8230877<\/a>, <code>thread_local<\/code> allows dynamic initialization and destruction semantics. However, that support requires a run-time penalty for references to non-function-local <code>thread_local<\/code> variables defined in a different translation unit, even if they don't need dynamic initialization. Dynamic initialization and destruction of non-local <code>thread_local<\/code> variables also has the same ordering problems as for ordinary non-local variables. So we avoid use of <code>thread_local<\/code> in general, limiting its use to only those cases where dynamic initialization or destruction are essential. See <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/JDK-8282469\">JDK-8282469<\/a> for further discussion.<\/p>\n","filename":"doc\/hotspot-style.html","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -472,1 +472,3 @@\n-VM's Native Memory Tracking (NMT) feature.\n+VM's Native Memory Tracking (NMT) feature.  Typically, uses of the global\n+operator new are inadvertent and therefore often associated with memory\n+leaks.\n@@ -632,1 +634,1 @@\n-([n2347](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2007\/n2347.pdf)) \n+([n2347](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2007\/n2347.pdf))\n@@ -652,1 +654,1 @@\n-Do not use `thread_local`\n+Avoid use of `thread_local`\n@@ -654,2 +656,4 @@\n-instead, use the HotSpot macro `THREAD_LOCAL`.  The initializer must\n-be a constant expression.\n+and instead, use the HotSpot macro `THREAD_LOCAL`, for which the initializer must\n+be a constant expression. When `thread_local` must be used, use the Hotspot macro\n+`APPROVED_CPP_THREAD_LOCAL` to indicate that the use has been given appropriate\n+consideration.\n@@ -664,2 +668,6 @@\n-namespace-scoped thread local variables also has the same ordering\n-problems as for ordinary namespace-scoped variables.\n+non-local `thread_local` variables also has the same ordering\n+problems as for ordinary non-local variables. So we avoid use of\n+`thread_local` in general, limiting its use to only those cases where dynamic\n+initialization or destruction are essential. See\n+[JDK-8282469](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8282469)\n+for further discussion.\n@@ -671,1 +679,1 @@\n-to `NULL`.  Don't use (constexpr or literal) 0 for pointers. \n+to `NULL`.  Don't use (constexpr or literal) 0 for pointers.\n@@ -940,1 +948,1 @@\n-[n2657]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2657.htm \n+[n2657]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2657.htm\n@@ -981,1 +989,1 @@\n-([n2235](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2007\/n2235.pdf)) \n+([n2235](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2007\/n2235.pdf))\n@@ -1088,1 +1096,1 @@\n-* Avoid `goto` statements. \n+* Avoid `goto` statements.\n@@ -1095,1 +1103,1 @@\n-* Trailing return type syntax for functions \n+* Trailing return type syntax for functions\n@@ -1109,1 +1117,1 @@\n-[ADL]: https:\/\/en.cppreference.com\/w\/cpp\/language\/adl \n+[ADL]: https:\/\/en.cppreference.com\/w\/cpp\/language\/adl\n","filename":"doc\/hotspot-style.md","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"}]}