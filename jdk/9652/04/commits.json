[{"commit":{"message":"Add more tests for swapped inputs where negation happens"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java"}],"sha":"678314e1ef6000da3cd5ce117b5b051410231546"},{"commit":{"message":"Merge branch 'master' into fg8289422"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/share\/opto\/superword.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"}],"sha":"823ca7bc72a084811a7fa04c04e5b0ba45505313"},{"commit":{"message":"Rebase the patch to the latest JDK and add some testcase for NE and EQ\n\nChange-Id: Ifb02b5efc2a09e6e0b4fc1c8346698597464f448"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/share\/opto\/superword.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java"}],"sha":"8bb57783377f5c5863f0d774711ad636eb64b4ed"},{"commit":{"message":"Merge branch 'master' into fg8289422\n\nChange-Id: I09677cb07f6b2717aa768a830663ca455806b900"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"}],"sha":"c3525f205df66105c03ea9b63f3ad23752d5f96e"},{"commit":{"message":"Merge branch 'master' into fg8289422\n\nChange-Id: I870c7bbc73d12bac16756226125edc1a229ba412"},"files":[{"filename":"src\/hotspot\/share\/opto\/matcher.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java"}],"sha":"7aa3adf178c59f5224209c5cf091fc794d31d37d"},{"commit":{"message":"Enable the test only on aarch64 platform because X86 supports vector cmove only on some 256-bits AVXs\n\nChange-Id: I64dd49380fe3d303ef6be21460df3be31c1458f8"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java"}],"sha":"3c83900001e141e867303614ab686bf18f24512d"},{"commit":{"message":"Merge branch 'master' into fg8289422\n\nChange-Id: I7936552df6ac12949ed8b550576f4e3520596423"},"files":[{"filename":"src\/hotspot\/share\/opto\/matcher.cpp"},{"filename":"src\/hotspot\/share\/opto\/superword.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"}],"sha":"c1e95d1fa7fdaeb62cd6826b87713f6c847bfb68"},{"commit":{"message":"8289422: Fix and re-enable vector conditional move\n\n```\n\/\/ float[] a, float[] b, float[] c;\nfor (int i = 0; i < a.length; i++) {\n    c[i] = (a[i] > b[i]) ? a[i] : b[i];\n}\n```\n\nAfter JDK-8139340 and JDK-8192846, we hope to vectorize the case\nabove by enabling -XX:+UseCMoveUnconditionally and -XX:+UseVectorCmov.\nBut the transformation here[1] is going to optimize the BoolNode\nwith constant input to a constant and break the design logic of\ncmove vector node[2]. We can't prevent all GVN transformation to\nthe BoolNode before matcher, so the patch keeps the condition input\nas a constant while creating a cmove vector node, and then\nrestructures it into a binary tree before matching.\n\nWhen the input order of original cmp node is different from the\ninput order of original cmove node, like:\n```\n\/\/ float[] a, float[] b, float[] c;\nfor (int i = 0; i < a.length; i++) {\n    c[i] = (a[i] < b[i]) ? a[i] : b[i];\n}\n```\nthe patch negates the mask of the BoolNode before creating the\ncmove vector node in SuperWord::output().\n\nWe can also use VectorNode::implemented() to consult if vector\nconditional move is supported in the backend. So, the patch cleans\nthe related code in SuperWord::implemented().\n\nWith the patch, the performance uplift is:\n(The micro-benchmark functions are included in the file\ntest\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java)\n\nAArch64:\nBenchmark (length)  Mode  Cnt   uplift(ns\/op)\ncmoveD     523      avgt  15    68.89%\ncmoveF     523      avgt  15    72.40%\n\nX86:\nBenchmark (length)  Mode  Cnt   uplift(ns\/op)\ncmoveD     523      avgt  15    73.12%\ncmoveF     523      avgt  15    85.45%\n\n[1]https:\/\/github.com\/openjdk\/jdk\/blob\/779b4e1d1959bc15a27492b7e2b951678e39cca8\/src\/hotspot\/share\/opto\/subnode.cpp#L1310\n[2]https:\/\/github.com\/openjdk\/jdk\/blob\/779b4e1d1959bc15a27492b7e2b951678e39cca8\/src\/hotspot\/share\/opto\/matcher.cpp#L2365\n\nChange-Id: If046dd745024deb0e602bf7efc2a07c22b89c690"},"files":[{"filename":"src\/hotspot\/share\/opto\/matcher.cpp"},{"filename":"src\/hotspot\/share\/opto\/superword.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java"}],"sha":"b2daf42b8602a5b19d165571af8c0e2f68494b39"}]