{"files":[{"patch":"@@ -5677,0 +5677,42 @@\n+\/\/ ------------------------- Vector conditional move --------------------------\n+\n+instruct vcmove_neon(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd) %{\n+  predicate(UseSVE == 0 ||\n+            (VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) &&\n+             n->in(1)->in(2)->get_int() != BoolTest::ne));\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcmove_neon.$copnd $dst, $src1, $src2\\t# vector conditional move fp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n+                    $src2$$FloatRegister, (int)($cond$$constant),\n+                    \/* isQ *\/ length_in_bytes == 16);\n+    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcmove_sve(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd, pRegGov pgtmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) ||\n+            (UseSVE > 0 && n->in(1)->in(2)->get_int() == BoolTest::ne));\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP pgtmp);\n+  format %{ \"vcmove_sve.$copnd $dst, $src1, $src2\\t# vector conditional move fp. KILL $pgtmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_compare($pgtmp$$PRegister, bt, ptrue, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pgtmp$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4039,0 +4039,42 @@\n+\/\/ ------------------------- Vector conditional move --------------------------\n+\n+instruct vcmove_neon(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd) %{\n+  predicate(UseSVE == 0 ||\n+            (VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) &&\n+             n->in(1)->in(2)->get_int() != BoolTest::ne));\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcmove_neon.$copnd $dst, $src1, $src2\\t# vector conditional move fp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n+                    $src2$$FloatRegister, (int)($cond$$constant),\n+                    \/* isQ *\/ length_in_bytes == 16);\n+    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcmove_sve(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd, pRegGov pgtmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) ||\n+            (UseSVE > 0 && n->in(1)->in(2)->get_int() == BoolTest::ne));\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP pgtmp);\n+  format %{ \"vcmove_sve.$copnd $dst, $src1, $src2\\t# vector conditional move fp. KILL $pgtmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_compare($pgtmp$$PRegister, bt, ptrue, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pgtmp$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2359,3 +2359,1 @@\n-    case Op_CMoveP:\n-    case Op_CMoveVF:\n-    case Op_CMoveVD:  {\n+    case Op_CMoveP: {\n@@ -2373,0 +2371,14 @@\n+    case Op_CMoveVF:\n+    case Op_CMoveVD: {\n+      \/\/ Restructure into a binary tree for Matching:\n+      \/\/ CMoveVF (Binary bool mask) (Binary src1 src2)\n+      Node* in_cc = n->in(1);\n+      assert(in_cc->is_Con(), \"The condition input of cmove vector node must be a constant.\");\n+      Node* bol = new BoolNode(in_cc, (BoolTest::mask)in_cc->get_int());\n+      Node* pair1 = new BinaryNode(bol, in_cc);\n+      n->set_req(1, pair1);\n+      Node* pair2 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair2);\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2067,6 +2067,1 @@\n-    }\n-    if (!retValue) {\n-      if (is_cmov_pack(p)) {\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr(\"SWPointer::implemented: found cmpd pack\"); print_pack(p);})\n-        return true;\n-      }\n+      NOT_PRODUCT(if(retValue && is_trace_cmov() && is_cmov_pack(p)) {tty->print_cr(\"SWPointer::implemented: found cmpd pack\"); print_pack(p);})\n@@ -2687,6 +2682,27 @@\n-        int cond = (int)bol->as_Bool()->_test._test;\n-        Node* in_cc  = _igvn.intcon(cond);\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created intcon in_cc node %d\", in_cc->_idx); in_cc->dump();})\n-        Node* cc = bol->clone();\n-        cc->set_req(1, in_cc);\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created bool cc node %d\", cc->_idx); cc->dump();})\n+        BoolTest boltest = bol->as_Bool()->_test;\n+        BoolTest::mask cond = boltest._test;\n+        Node* cmp = bol->in(1);\n+        \/\/ When the src order of cmp node and cmove node are the same:\n+        \/\/   cmp: CmpD src1 src2\n+        \/\/   bool: Bool cmp mask\n+        \/\/   cmove: CMoveD bool scr1 src2\n+        \/\/ =====> vectorized, equivalent to\n+        \/\/   cmovev: CMoveVD mask src_vector1 src_vector2\n+        \/\/\n+        \/\/ When the src order of cmp node and cmove node are different:\n+        \/\/   cmp: CmpD src2 src1\n+        \/\/   bool: Bool cmp mask\n+        \/\/   cmove: CMoveD bool scr1 src2\n+        \/\/ =====> equivalent to\n+        \/\/   cmp: CmpD src1 src2\n+        \/\/   bool: Bool cmp negate(mask)\n+        \/\/   cmove: CMoveD bool scr1 src2\n+        \/\/ (Note: when mask is ne or eq, we don't need to negate it even after swapping.)\n+        \/\/ =====> vectorized, equivalent to\n+        \/\/   cmovev: CMoveVD negate(mask) src_vector1 src_vector2\n+        if (cmp->in(2) == n->in(CMoveNode::IfFalse) && cond != BoolTest::ne && cond != BoolTest::eq) {\n+          assert(cmp->in(1) == n->in(CMoveNode::IfTrue), \"cmpnode and cmovenode don't share the same inputs.\");\n+          cond = boltest.negate();\n+        }\n+        Node* cc  = _igvn.intcon((int)cond);\n+        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created intcon in_cc node %d\", cc->_idx); cc->dump();})\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8289422\n+ * @key randomness\n+ * @summary Auto-vectorization enhancement to support vector conditional move on AArch64\n+ * @requires os.arch==\"aarch64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestVectorConditionalMove\n+ *\/\n+\n+public class TestVectorConditionalMove {\n+    final private static int SIZE = 3000;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    private static float[] floata = new float[SIZE];\n+    private static float[] floatb = new float[SIZE];\n+    private static float[] floatc = new float[SIZE];\n+    private static double[] doublea = new double[SIZE];\n+    private static double[] doubleb = new double[SIZE];\n+    private static double[] doublec = new double[SIZE];\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseCMoveUnconditionally\",\n+                                   \"-XX:+UseVectorCmov\", \"-XX:CompileCommand=exclude,*.cmove*\");\n+    }\n+\n+    private float cmoveFloatGT(float a, float b) {\n+        return (a > b) ? a : b;\n+    }\n+\n+    private float cmoveFloatLT(float a, float b) {\n+        return (a < b) ? a : b;\n+    }\n+\n+    private float cmoveFloatEQ(float a, float b) {\n+        return (a == b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleLE(double a, double b) {\n+        return (a <= b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleGE(double a, double b) {\n+        return (a >= b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleNE(double a, double b) {\n+        return (a != b) ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFGT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFLT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFEQ(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDLE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDGE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDNE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Run(test = {\"testCMoveVFGT\", \"testCMoveVFLT\",\"testCMoveVDLE\", \"testCMoveVDGE\", \"testCMoveVFEQ\", \"testCMoveVDNE\"})\n+    private void testCMove_runner() {\n+        for (int i = 0; i < SIZE; i++) {\n+            floata[i] = RANDOM.nextFloat();\n+            floatb[i] = RANDOM.nextFloat();\n+            doublea[i] = RANDOM.nextDouble();\n+            doubleb[i] = RANDOM.nextDouble();\n+        }\n+\n+        testCMoveVFGT(floata, floatb, floatc);\n+        testCMoveVDLE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatGT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleLE(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFLT(floata, floatb, floatc);\n+        testCMoveVDGE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatLT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleGE(doublea[i], doubleb[i]));\n+        }\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            if (i % 3 == 0) {\n+                floatb[i] = floata[i];\n+                doubleb[i] = doublea[i];\n+            }\n+        }\n+\n+        testCMoveVFEQ(floata, floatb, floatc);\n+        testCMoveVDNE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatEQ(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleNE(doublea[i], doubleb[i]));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -145,0 +145,2 @@\n+    public static final String CMOVEVF = START + \"CMoveVF\" + MID + END;\n+    public static final String CMOVEVD = START + \"CMoveVD\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -369,0 +369,16 @@\n+    @Benchmark\n+    @Fork(jvmArgsPrepend = {\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\"})\n+    public void cmoveD() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = resD[i] < doubles[i] ? resD[i] : doubles[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsPrepend = {\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\"})\n+    public void cmoveF() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = resF[i] < floats[i] ? resF[i] : floats[i];\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}