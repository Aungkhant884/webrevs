{"files":[{"patch":"@@ -2394,0 +2394,35 @@\n+\/\/ --------------------------------- VCMove ----------------------------\n+\n+instruct vcmove8B(vecD dst, vecD src1, vecD src2, immI cond, cmpOp copnd)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  format %{ \"vcmoveD.$copnd  $dst, $src1, $src2\\t# vector conditional move fp (8B)\"%}\n+  effect(TEMP_DEF dst);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), $cond$$constant, \/*isQ*\/ false);\n+    __ bsl(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(vlogical64);\n+%}\n+\n+instruct vcmove16B(vecX dst, vecX src1, vecX src2, immI cond, cmpOp copnd)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  format %{ \"vcmoveX.$copnd  $dst, $src1, $src2\\t# vector conditional move fp (16B)\"%}\n+  effect(TEMP_DEF dst);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), $cond$$constant, \/*isQ*\/ true);\n+    __ bsl(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(vlogical128);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1181,0 +1181,26 @@\n+\/\/ --------------------------------- VCMove ----------------------------\n+dnl\n+define(`VECTOR_CMOVE', `\n+instruct vcmove$1B(vec$2 dst, vec$2 src1, vec$2 src2, immI cond, cmpOp copnd)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() == $1);\n+  ifelse($2, D,\n+  `match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));',\n+  `match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));')\n+  format %{ \"vcmove$2.$copnd  $dst, $src1, $src2\\t# vector conditional move fp ($1B)\"%}\n+  effect(TEMP_DEF dst);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), $cond$$constant, \/*isQ*\/ $4);\n+    __ bsl(as_FloatRegister($dst$$reg), __ T$1B,\n+           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(vlogical$3);\n+%}')dnl\n+dnl          $1  $2 $3  $4\n+VECTOR_CMOVE(8,  D, 64, false)\n+VECTOR_CMOVE(16, X, 128, true)\n+dnl\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2309,0 +2309,19 @@\n+\/\/ vector conditional move\n+\n+instruct vcmove(vReg dst, vReg src1, vReg src2, pRegGov pg, immI cond, cmpOp copnd) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP pg);\n+  format %{ \"sve_cmove.$copnd $dst, $src1, $src2\\t# vector conditional move fp (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_compare(as_PRegister($pg$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n+                   as_FloatRegister($src2$$reg), $cond$$constant);\n+    __ sve_sel(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n+               as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1270,0 +1270,19 @@\n+\/\/ vector conditional move\n+\n+instruct vcmove(vReg dst, vReg src1, vReg src2, pRegGov pg, immI cond, cmpOp copnd) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP pg);\n+  format %{ \"sve_cmove.$copnd $dst, $src1, $src2\\t# vector conditional move fp (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_compare(as_PRegister($pg$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n+                   as_FloatRegister($src2$$reg), $cond$$constant);\n+    __ sve_sel(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n+               as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2362,3 +2362,1 @@\n-    case Op_CMoveP:\n-    case Op_CMoveVF:\n-    case Op_CMoveVD:  {\n+    case Op_CMoveP: {\n@@ -2376,0 +2374,14 @@\n+    case Op_CMoveVF:\n+    case Op_CMoveVD: {\n+      \/\/ Restructure into a binary tree for Matching:\n+      \/\/ CMoveVF (Binary bool mask) (Binary src1 src2)\n+      Node* in_cc = n->in(1);\n+      assert(in_cc->is_Con(), \"The condition input of cmove vector node must be a constant.\");\n+      Node* bol = new BoolNode(in_cc, (BoolTest::mask)in_cc->get_int());\n+      Node* pair1 = new BinaryNode(bol, in_cc);\n+      n->set_req(1, pair1);\n+      Node* pair2 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair2);\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2067,6 +2067,1 @@\n-    }\n-    if (!retValue) {\n-      if (is_cmov_pack(p)) {\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr(\"SWPointer::implemented: found cmpd pack\"); print_pack(p);})\n-        return true;\n-      }\n+      NOT_PRODUCT(if(retValue && is_trace_cmov() && is_cmov_pack(p)) {tty->print_cr(\"SWPointer::implemented: found cmpd pack\"); print_pack(p);})\n@@ -2686,6 +2681,22 @@\n-        int cond = (int)bol->as_Bool()->_test._test;\n-        Node* in_cc  = _igvn.intcon(cond);\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created intcon in_cc node %d\", in_cc->_idx); in_cc->dump();})\n-        Node* cc = bol->clone();\n-        cc->set_req(1, in_cc);\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created bool cc node %d\", cc->_idx); cc->dump();})\n+        BoolTest boltest = bol->as_Bool()->_test;\n+        BoolTest::mask cond = boltest._test;\n+        Node* cmp = bol->in(1);\n+        \/\/ When the src order of cmp node and cmove node are the same:\n+        \/\/ cmp: CmpD src1 src2\n+        \/\/ bool: Bool cmp mask\n+        \/\/ cmove: CMoveD bool scr1 src2\n+        \/\/ =====> merged, equivalent to\n+        \/\/ cmovev: CMoveVD mask src_vector1 src_vector2\n+        \/\/\n+        \/\/ When the src order of cmp node and cmove node are different:\n+        \/\/ cmp: CmpD src2 src1\n+        \/\/ bool: Bool cmp mask\n+        \/\/ cmove: CMoveD bool scr1 src2\n+        \/\/ =====> merged, equivalent to\n+        \/\/ cmovev: CMoveVD nagate(mask) src_vector1 src_vector2\n+        if (cmp->in(2) == n->in(CMoveNode::IfFalse)) {\n+          assert(cmp->in(1) == n->in(CMoveNode::IfTrue), \"cmpnode and cmovenode don't share the same inputs.\");\n+          cond = boltest.negate();\n+        }\n+        Node* cc  = _igvn.intcon((int)cond);\n+        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created intcon in_cc node %d\", cc->_idx); cc->dump();})\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8289422\n+ * @key randomness\n+ * @summary Auto-vectorization enhancement to support vector conditional move on AArch64\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") | os.arch==\"aarch64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestVectorConditionalMove\n+ *\/\n+\n+public class TestVectorConditionalMove {\n+    final private static int SIZE = 3000;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    private static float[] floata = new float[SIZE];\n+    private static float[] floatb = new float[SIZE];\n+    private static float[] floatc = new float[SIZE];\n+    private static double[] doublea = new double[SIZE];\n+    private static double[] doubleb = new double[SIZE];\n+    private static double[] doublec = new double[SIZE];\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\",\n+                                   \"-XX:CompileCommand=exclude,*.cmove*\");\n+    }\n+\n+    private float cmoveFloatGT(float a, float b) {\n+        return (a > b) ? a : b;\n+    }\n+\n+    private float cmoveFloatLT(float a, float b) {\n+        return (a < b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleLE(double a, double b) {\n+        return (a <= b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleGE(double a, double b) {\n+        return (a >= b) ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFGT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFLT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDLE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDGE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Run(test = {\"testCMoveVFGT\", \"testCMoveVFLT\",\"testCMoveVDLE\", \"testCMoveVDGE\"})\n+    private void testCMove_runner() {\n+        for (int i = 0; i < SIZE; i++) {\n+            floata[i] = RANDOM.nextFloat();\n+            floatb[i] = RANDOM.nextFloat();\n+            doublea[i] = RANDOM.nextDouble();\n+            doubleb[i] = RANDOM.nextDouble();\n+        }\n+\n+        testCMoveVFGT(floata, floatb, floatc);\n+        testCMoveVDLE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatGT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleLE(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFLT(floata, floatb, floatc);\n+        testCMoveVDGE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatLT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleGE(doublea[i], doubleb[i]));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -145,0 +145,2 @@\n+    public static final String CMOVEVF = START + \"CMoveVF\" + MID + END;\n+    public static final String CMOVEVD = START + \"CMoveVD\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -366,0 +366,16 @@\n+    @Benchmark\n+    @Fork(jvmArgsPrepend = {\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\"})\n+    public void cmoveD() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = resD[i] < doubles[i] ? resD[i] : doubles[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsPrepend = {\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\"})\n+    public void cmoveF() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = resF[i] < floats[i] ? resF[i] : floats[i];\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}