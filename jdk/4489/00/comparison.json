{"files":[{"patch":"@@ -31,1 +31,0 @@\n-\n@@ -198,1 +197,1 @@\n-     * tree within the provided compilation unit\n+     * tree within the provided compilation unit.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTrees.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+import com.sun.tools.javac.code.Symbol;\n@@ -88,1 +89,0 @@\n-import com.sun.tools.javac.code.Type.ErrorType;\n@@ -91,1 +91,0 @@\n-import com.sun.tools.javac.code.Types.TypeRelation;\n@@ -100,1 +99,0 @@\n-import com.sun.tools.javac.code.Symbol;\n@@ -154,1 +152,0 @@\n-import static com.sun.tools.javac.code.TypeTag.*;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -335,1 +335,3 @@\n-         * Logical size of map (number of valid entries.)\n+         * Logical size of map.\n+         * This is the number of occupied positions in {@code map},\n+         * and equals {@code NOFFSETS} multiplied by the number of entries.\n@@ -352,1 +354,1 @@\n-         * @param posOffet  input offset member of pair.\n+         * @param posOffset  input offset member of pair.\n@@ -356,2 +358,2 @@\n-        boolean shouldAdd(int sbOffset, int posOffet) {\n-            return sbOffset - lastSBOffset() != posOffet - lastPosOffset();\n+        boolean shouldAdd(int sbOffset, int posOffset) {\n+            return sbOffset - lastSBOffset() != posOffset - lastPosOffset();\n@@ -364,1 +366,1 @@\n-         * @param posOffet  input offset member of pair.\n+         * @param posOffset  input offset member of pair.\n@@ -366,2 +368,2 @@\n-        void add(int sbOffset, int posOffet) {\n-            if (size == 0 || shouldAdd(sbOffset, posOffet)) {\n+        void add(int sbOffset, int posOffset) {\n+            if (size == 0 || shouldAdd(sbOffset, posOffset)) {\n@@ -370,1 +372,1 @@\n-                map[size + POS_OFFSET] = posOffet;\n+                map[size + POS_OFFSET] = posOffset;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavadocTokenizer.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+    \/**\n+     * {@return the source position for this tree node}\n+     *\n+     * @param dc the enclosing doc comment\n+     *\/\n@@ -70,0 +75,11 @@\n+    \/**\n+     * {@return the source position for position relative to this tree node}\n+     * This is primarily useful for nodes that wrap a single string child.\n+     *\n+     * @param dc     the enclosing doc comment\n+     * @param offset the offset\n+     *\/\n+    public long getSourcePosition(DCDocComment dc, int offset) {\n+        return dc.comment.getSourcePos(pos + offset);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+import com.sun.source.doctree.CommentTree;\n+import com.sun.source.doctree.DocTypeTree;\n+import com.sun.source.doctree.ReferenceTree;\n+import com.sun.source.doctree.TextTree;\n@@ -83,0 +87,21 @@\n+    \/**\n+     * Prints a diagnostic message related to a position within a range of characters in a tree node.\n+     *\n+     * Only kinds of {@code DocTree} that wrap a simple string value are supported as leaf nodes\n+     * of the given path. This currently includes\n+     * {@link CommentTree}, {@link DocTypeTree}, {@link ReferenceTree}, and {@link TextTree}.\n+     *\n+     * The positions are all 0-based character offsets from the beginning of string.\n+     * The positions should satisfy the relation {@code start <= pos <= end}.\n+     *\n+     * @param kind    the kind of diagnostic\n+     * @param path    the path for the tree node\n+     * @param start   the beginning of the enclosing range\n+     * @param pos     the position\n+     * @param end     the end of the enclosing range\n+     * @param message the message to be printed\n+     *\n+     * @since 17\n+     *\/\n+    void print(Diagnostic.Kind kind, DocTreePath path, int start, int pos, int end, String message);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/doclet\/Reporter.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -48,0 +48,6 @@\n+import com.sun.source.doctree.CommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.DocTypeTree;\n+import com.sun.source.doctree.ReferenceTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.tools.javac.tree.DCTree;\n@@ -250,0 +256,42 @@\n+    @Override \/\/ Reporter\n+    public void print(Diagnostic.Kind kind, DocTreePath path, int start, int pos, int end, String message) {\n+        if (!(start <= pos && pos <= end)) {\n+            throw new IllegalArgumentException(\"start:\" + start + \",pos:\" + pos + \",end:\" + end);\n+        }\n+\n+        DocTree t = path.getLeaf();\n+        String s = switch (t.getKind()) {\n+            case COMMENT -> ((CommentTree) t).getBody();\n+            case DOC_TYPE -> ((DocTypeTree) t).getText();\n+            case REFERENCE -> ((ReferenceTree) t).getSignature();\n+            case TEXT -> ((TextTree) t).getBody();\n+            default -> throw new IllegalArgumentException(t.getKind().toString());\n+        };\n+\n+        if (start < 0 || end > s.length()) {\n+            throw new StringIndexOutOfBoundsException(\"start:\" + start + \",pos:\" + pos + \",end:\" + end\n+                    + \"; string length \" + s.length());\n+        }\n+\n+        DiagnosticType dt = getDiagnosticType(kind);\n+        Set<DiagnosticFlag> flags = getDiagnosticFlags(kind);\n+        DiagnosticSource ds = getDiagnosticSource(path);\n+\n+        DCTree.DCDocComment docComment = (DCTree.DCDocComment) path.getDocComment();\n+        DCTree tree = (DCTree) path.getLeaf();\n+        \/\/ note: it is important to evaluate the offsets in the context of the position\n+        \/\/ within the comment text, and not in the context of the overall source text\n+        int sStart = (int) tree.getSourcePosition(docComment, start);\n+        int sPos = (int) tree.getSourcePosition(docComment, pos);\n+        int sEnd = (int) tree.getSourcePosition(docComment, end);\n+        DiagnosticPosition dp = createDiagnosticPosition(null, sStart, sPos, sEnd);\n+\n+        report(dt, flags, ds, dp, message);\n+    }\n+\n+    private int getSourcePos(DocTreePath path, int offset) {\n+        DCTree.DCDocComment docComment = (DCTree.DCDocComment) path.getDocComment();\n+        DCTree tree = (DCTree) path.getLeaf();\n+        return (int) tree.getSourcePosition(docComment, offset);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/JavadocLog.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.util.Elements;\n+import javax.tools.Diagnostic;\n+import javax.tools.FileObject;\n+\n+import com.sun.source.doctree.CommentTree;\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.DocTypeTree;\n+import com.sun.source.doctree.ReferenceTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreePath;\n+import com.sun.source.util.DocTreePathScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.TreePath;\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.Reporter;\n+import jdk.javadoc.doclet.StandardDoclet;\n+import jdk.javadoc.doclet.Taglet;\n+\n+\/**\n+ * A taglet to be called in the context of the sdtandard doclet.\n+ * When invoked, it scans the entire enclosing doc comment, and\n+ * reports diagnostics at all instances of selected node kinds,\n+ * so that a test can verify the contents of the diagnostics.\n+ *\/\n+public class MyTaglet implements Taglet {\n+    private DocletEnvironment docEnv;\n+    private Reporter reporter;\n+\n+    @Override\n+    public void init(DocletEnvironment docEnv, Doclet doclet) {\n+        this.docEnv = docEnv;\n+        reporter = ((StandardDoclet) doclet).getReporter();\n+    }\n+\n+    @Override\n+    public Set<Location> getAllowedLocations() {\n+        return EnumSet.allOf(Location.class);\n+    }\n+\n+    @Override\n+    public boolean isInlineTag() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"scanMe\";\n+    }\n+\n+    @Override\n+    public String toString(List<? extends DocTree> tags, Element element) {\n+        DocTrees trees = docEnv.getDocTrees();\n+        Elements elements = docEnv.getElementUtils();\n+        DocTreePath dtp;\n+        \/\/ Use reflection to access the file object underlying a doc-files\/*.html file\n+        \/\/ in order to access a DocCommentTree for the file.\n+        \/\/ Note that using reflective access inside javadoc requires the -XDallowInternalAccess option.\n+        \/\/ Note also that technically the doc comment tree that is found may be a different instance\n+        \/\/ to the current instance, but since we only want to scan it and report diagnostics,\n+        \/\/ that should not matter.\n+        if (element.getClass().getSimpleName().equals(\"DocFileElement\")) {\n+            try {\n+                Method getFileObjectMethod = element.getClass().getMethod(\"getFileObject\");\n+                FileObject fo = (FileObject) getFileObjectMethod.invoke(element);\n+                DocCommentTree dct = trees.getDocCommentTree(fo);\n+                dtp = trees.getDocTreePath(fo, elements.getPackageElement(\"p\"));\n+            } catch (ReflectiveOperationException e) {\n+                return \"MyTaglet[\" + e + \"]\";\n+            }\n+        } else {\n+            DocCommentTree dct = trees.getDocCommentTree(element);\n+            TreePath tp = trees.getPath(element);\n+            dtp = new DocTreePath(tp, dct);\n+        }\n+\n+        scan(dtp);\n+\n+        return \"MyTaglet[\" + element + \"]\";\n+    }\n+\n+    \/**\n+     * Scans a DocCommentTree, generating diagnostics for selected nodes.\n+     * Information about the expected position is encodinged within the\n+     * text of the diagnostic, surrounded by {@code >>> <<<}.\n+     *\n+     * @param dtp the path to scan\n+     *\/\n+    void scan(DocTreePath dtp) {\n+        DocTreePathScanner<Void, Void> s = new DocTreePathScanner<Void, Void>() {\n+            @Override\n+            public Void visitDocComment(DocCommentTree t, Void p) {\n+                \/\/ By default, DocTreeScanner does not include the preamble and postamble\n+                scan(t.getPreamble(), p);\n+                super.visitDocComment(t, p);\n+                scan(t.getPostamble(), p);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitComment(CommentTree t, Void p) {\n+                report(t, t.getBody());\n+                return super.visitComment(t, p);\n+            }\n+\n+            @Override\n+            public Void visitDocType(DocTypeTree t, Void p) {\n+                report(t, t.getText());\n+                return super.visitDocType(t, p);\n+            }\n+\n+            @Override\n+            public Void visitReference(ReferenceTree t, Void p) {\n+                report(t, t.getSignature());\n+                return super.visitReference(t, p);\n+            }\n+\n+            @Override\n+            public Void visitText(TextTree t, Void p) {\n+                report(t, t.getBody());\n+                return super.visitText(t, p);\n+            }\n+\n+            void report(DocTree t, String s) {\n+                int pad = 3;\n+                assert (s.length() > 2 * pad + 3) : \">>>\" + s + \"<<<\";\n+                int mid = s.length() \/ 2;\n+                String detail = s.substring(mid - pad, mid) + \"[\" + s.charAt(mid) + \"]\" + s.substring(mid + 1, mid + pad + 1);\n+                \/\/ The diagnostic is reported at a position in a range of characters\n+                \/\/ in the middle of the string; the characters are encoded within the\n+                \/\/ message of the diagnostic, with {@code [ ]} surrounding the character\n+                \/\/ that should be indicated by the caret.\n+                reporter.print(Diagnostic.Kind.WARNING, getCurrentPath(),\n+                        mid - pad, mid, mid + pad + 1,\n+                        \"length: \" + s.length() + \" mid: \" + mid + \" >>>\" + detail + \"<<<\");\n+            }\n+        };\n+        s.scan(dtp, null);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocTreeDiags\/MyTaglet.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8268420\n+ * @summary  new Reporter method to report a diagnostic within a DocTree node\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    javadoc.tester.* MyTaglet\n+ * @run main TestDocTreeDiags\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.DocumentationTool;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests the ability to write diagnostics related to a (start,pos,end) range in those\n+ * DocTrees that wrap a String value.\n+ *\n+ * Ideally, this would be tested by using a custom doclet which scans all the doc comments,\n+ * generating diagnostics for eligible nodes. However, one of the cases that is tested is\n+ * a DocTypeTree, which only occurs in the context of an HTML file in a doc-files subdirectory,\n+ * which is very specific to the Standard Doclet. Therefore, we use the Standard Doclet\n+ * in conjunction with a non-standard use of a custom taglet, which is used to access and\n+ * scan the doc comments that enclose the tags that trigger the taglet.\n+ *\/\n+public class TestDocTreeDiags extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestDocTreeDiags tester = new TestDocTreeDiags();\n+        tester.runTests(m -> new Object[] { Path.of(m.getName())} );\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+    Path src;\n+    DocumentationTool tool;\n+\n+    boolean showOutput = false; \/\/ set true for to set output written by javadoc\n+\n+    TestDocTreeDiags() throws IOException {\n+        src = Path.of(\"src\");\n+        \/\/ Note: the following comments are somewhat stylized, and need to follow some\n+        \/\/ simple rules to avoid exceptions and false positives.\n+        \/\/ 1. Each fragment must be at least 7 (and preferably 9) characters long,\n+        \/\/    in order to contain the range that will be generated in the diagnostic.\n+        \/\/ 2. There must be no non-trivial duplication in the fragments, particularly\n+        \/\/    in the area where the range of characters will be generated for the\n+        \/\/    diagnostic. This is because we use String.indexOf to determine the\n+        \/\/    expected values of the range.\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/**\n+                     * First sentence. &quot;  Second sentence.\n+                     * {@link java.lang.String first phrase; &quot;  second phrase }\n+                     * And now ... <!-- this is a comment --> and so it was.\n+                     * @scanMe\n+                     *\/\n+                    public class C {\n+                        \/**\n+                         * Sentence for method m(). More details for the method.\n+                         * Embedded {@link java.lang.Object} link.\n+                         * And another <!-- unusual comment --> strange comment.\n+                         * @scanMe\n+                         *\/\n+                         public void m() { }\n+                    }\n+                    \"\"\");\n+        tb.writeFile(src.resolve(\"p\").resolve(\"doc-files\").resolve(\"extra.html\"),\n+                \"\"\"\n+                    <!doctype doctype-description>\n+                    <html>\n+                    <head><title>Document Title<\/title><\/head>\n+                    <body>\n+                    Extra content. More content.\n+                    @scanMe\n+                    <\/body>\n+                    <\/html>\n+                    \"\"\"\n+                );\n+\n+        tool = ToolProvider.getSystemDocumentationTool();\n+    }\n+\n+    \/**\n+     * Tests the diagnostics generated to the output stream when there is no\n+     * diagnostic listener in use.\n+     *\n+     * By default, in this context, the start and end of the range of characters are not\n+     * presented. The caret should point at the preferred position for the diagnostic.\n+     *\/\n+    @Test\n+    public void testStdout(Path base) throws Exception {\n+        StringWriter outWriter = new StringWriter();\n+        javadoc(outWriter, null, base.resolve(\"api\"));\n+\n+        \/\/ analyze and verify the generated diagnostics\n+        List<String> lines = outWriter.toString().lines().toList();\n+        Iterator<String> iter = lines.iterator();\n+        while (iter.hasNext()) {\n+            String l = iter.next();\n+            if (l.startsWith(\"src\")) {\n+                checkDiag(null, l, iter.next(), iter.next());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests the diagnostics received by a DiagnosticListener.\n+     *\n+     * In this context, various detailed coordinate information is available.\n+     *\/\n+    @Test\n+    public void testDiagListener(Path base) throws Exception {\n+        StringWriter outWriter = new StringWriter();\n+        DiagnosticListener dl = diagnostic -> {\n+            if (diagnostic.getPosition() != -1) {\n+                List<String> lines = List.of(diagnostic.toString().split(\"\\\\R\"));\n+                assert lines.size() == 3;\n+                String msgLine = lines.get(0);\n+                String srcLine = lines.get(1);\n+                String caretLine = lines.get(2);\n+                checkDiag(diagnostic, msgLine, srcLine, caretLine);\n+            }\n+        };\n+        javadoc(outWriter, dl, base.resolve(\"api\"));\n+    }\n+\n+    \/**\n+     * Runs javadoc on package {@code p} in the {@code src} directory,\n+     * using the specified writer and optional diagnostic listener.\n+     *\n+     * @param writer the writer\n+     * @param dl     the diagnostic listener, or {@code null}\n+     * @param outDir the output directory\n+     *\n+     * @throws IOException if an IO error occurs\n+     *\/\n+    void javadoc(StringWriter writer, DiagnosticListener dl, Path outDir) throws IOException {\n+        Files.createDirectories(outDir);\n+        try (StandardJavaFileManager fm = tool.getStandardFileManager(null, null, null)) {\n+            fm.setLocationFromPaths(StandardLocation.SOURCE_PATH, List.of(src));\n+            fm.setLocationFromPaths(DocumentationTool.Location.DOCUMENTATION_OUTPUT, List.of(outDir));\n+            fm.setLocationFromPaths(DocumentationTool.Location.TAGLET_PATH, List.of(Path.of(System.getProperty(\"test.classes\"))));\n+            Iterable<? extends JavaFileObject> files = Collections.emptyList();\n+            Iterable<String> options = List.of(\"-taglet\", MyTaglet.class.getName(), \"-XDaccessInternalAPI\", \"p\");\n+            DocumentationTool.DocumentationTask t = tool.getTask(writer, fm, dl, null, options, files);\n+\n+            checking(\"exit\");\n+            boolean ok = t.call();\n+\n+            if (showOutput) {\n+                out.println(\"OUT: >>>\" + writer.toString().replace(\"\\n\", NL) + \"<<<\");\n+            }\n+\n+            if (ok) {\n+                passed(\"javadoc exited OK, as expected\");\n+            } else {\n+                failed(\"javadoc failed\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Checks the diagnostic output against information encoded in the diagnostics.\n+     *\n+     * The message in the message line contains a string that indicates where the\n+     * caret should be pointing in the source line.\n+     *\n+     * @param diag          the diagnostic, or null\n+     * @param msgLine       file:line: message   >>>detail<<<\n+     * @param srcLine       the source line\n+     * @param caretLine     the line with the caret\n+     *\/\n+    void checkDiag(Diagnostic diag, String msgLine, String srcLine, String caretLine) {\n+        if (diag != null) {\n+            out.printf(\"DIAG:  %d:%d:%d  %d:%d vvv%n%s%n^^^%n\",\n+                    diag.getStartPosition(), diag.getPosition(), diag.getEndPosition(),\n+                    diag.getLineNumber(), diag.getColumnNumber(),\n+                    diag.toString().replace(\"\\\\R\", NL) );\n+        }\n+        out.println(msgLine);\n+        out.println(srcLine);\n+        out.println(caretLine);\n+\n+        String srcFileLine = msgLine.substring(0, msgLine.indexOf(\": \"));\n+        int caretIndex = caretLine.indexOf('^');\n+        Pattern p = Pattern.compile(\">>>([^<]*)<<<\");\n+        Matcher m = p.matcher(msgLine);\n+        if (!m.find()) {\n+            throw new IllegalArgumentException(\"detail pattern not found: \" + msgLine);\n+        }\n+        String rawDetail = m.group(1);\n+        String detail = rawDetail.replaceAll(\"[\\\\[\\\\]]\", \"\");\n+\n+        if (diag != null) {\n+            checking(\"coords-column: \" + srcFileLine);\n+            int col = (int) diag.getColumnNumber();\n+            \/\/ line and column are 1-based, so col should be 1 more than caretIndex\n+            if (col - 1 == caretIndex) {\n+                passed(\"col: \" + col + \" caret: \" + caretIndex);\n+            } else {\n+                failed(\"col: \" + col + \" caret: \" + caretIndex);\n+            }\n+\n+            checking(\"coords-start-end: \" + srcFileLine);\n+            String fileStr = readFile(\".\", msgLine.substring(0, msgLine.indexOf(\":\")));\n+            int start = (int) diag.getStartPosition();\n+            int end = (int) diag.getEndPosition();\n+            String fileRange = fileStr.substring(start, end);\n+            if (fileRange.equals(detail)) {\n+                passed(\"file: >>>\" + fileRange + \"<<<  message: >>>\" + detail + \"<<<\");\n+            } else {\n+                failed(\"file: >>>\" + fileRange + \"<<<  message: >>>\" + detail + \"<<<\");\n+            }\n+        }\n+\n+        checking(\"message-caret: \" + srcFileLine);\n+        int srcIndex = srcLine.indexOf(detail);\n+        int pad = (detail.length() - 1) \/ 2;\n+        int srcIndexPad = srcIndex + pad;\n+        if (srcIndexPad == caretIndex) {\n+            passed(\"src: \" + srcIndexPad + \" caret: \" + caretIndex);\n+        } else {\n+            failed(\"src: \" + srcIndexPad + \" caret: \" + caretIndex);\n+        }\n+    }\n+}\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocTreeDiags\/TestDocTreeDiags.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"}]}