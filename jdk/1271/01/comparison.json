{"files":[{"patch":"@@ -47,8 +47,0 @@\n-static BarrierSetNMethod* make_barrier_set_nmethod(ShenandoahHeap* heap) {\n-  \/\/ NMethod barriers are only used when concurrent nmethod unloading is enabled\n-  if (!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {\n-    return NULL;\n-  }\n-  return new ShenandoahBarrierSetNMethod(heap);\n-}\n-\n@@ -59,1 +51,1 @@\n-             make_barrier_set_nmethod(heap),\n+             new ShenandoahBarrierSetNMethod(heap),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -423,1 +423,2 @@\n-  if (heap->is_concurrent_weak_root_in_progress()) {\n+  if (heap->is_concurrent_weak_root_in_progress() &&\n+      ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1145,3 +1145,1 @@\n-                               ShenandoahPhaseTimings::init_evac,\n-                               !ShenandoahConcurrentRoots::should_do_concurrent_roots(),\n-                               !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());\n+                               ShenandoahPhaseTimings::init_evac);\n@@ -1747,3 +1745,2 @@\n-        if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n-          ShenandoahCodeRoots::arm_nmethods();\n-        }\n+        \/\/ Arm nmethods for concurrent codecache process.\n+        ShenandoahCodeRoots::arm_nmethods();\n@@ -1760,11 +1757,4 @@\n-          ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;\n-          if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {\n-            types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);\n-            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);\n-            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);\n-          }\n-\n-          if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n-            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);\n-          }\n-          verifier()->verify_roots_no_forwarded_except(types);\n+          \/\/ We only evacuate\/update thread and serial weak roots at this pause\n+          ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::ThreadRoots,\n+                                                                                    ShenandoahRootVerifier::SerialWeakRoots);\n+          verifier()->verify_roots_no_forwarded(types);\n@@ -1843,0 +1833,19 @@\n+class ShenandoahEvacUpdateCodeCacheClosure : public NMethodClosure {\n+private:\n+  BarrierSetNMethod* const               _bs;\n+  ShenandoahEvacuateUpdateRootsClosure<> _cl;\n+\n+public:\n+  ShenandoahEvacUpdateCodeCacheClosure() :\n+    _bs(BarrierSet::barrier_set()->barrier_set_nmethod()),\n+    _cl() {\n+  }\n+\n+  void do_nmethod(nmethod* n) {\n+    ShenandoahNMethod* data = ShenandoahNMethod::gc_data(n);\n+    ShenandoahReentrantLocker locker(data->lock());\n+    data->oops_do(&_cl, true\/*fix relocation*\/);\n+    _bs->disarm(n);\n+  }\n+};\n+\n@@ -1845,0 +1854,1 @@\n+  ShenandoahPhaseTimings::Phase                 _phase;\n@@ -1847,0 +1857,2 @@\n+  ShenandoahConcurrentNMethodIterator           _nmethod_itr;\n+  bool                                          _process_codecache;\n@@ -1851,0 +1863,1 @@\n+    _phase(phase),\n@@ -1852,1 +1865,15 @@\n-    _cld_roots(phase, ShenandoahHeap::heap()->workers()->active_workers()) {}\n+    _cld_roots(phase, ShenandoahHeap::heap()->workers()->active_workers()),\n+    _nmethod_itr(ShenandoahCodeRoots::table()),\n+    _process_codecache(!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n+    if (_process_codecache) {\n+      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+      _nmethod_itr.nmethods_do_begin();\n+    }\n+  }\n+\n+  ~ShenandoahConcurrentRootsEvacUpdateTask() {\n+    if (_process_codecache) {\n+      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+      _nmethod_itr.nmethods_do_end();\n+    }\n+  }\n@@ -1869,0 +1896,6 @@\n+\n+    if (_process_codecache) {\n+      ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);\n+      ShenandoahEvacUpdateCodeCacheClosure cl;\n+      _nmethod_itr.nmethods_do(&cl);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":51,"deletions":18,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -150,7 +150,0 @@\n-\n-  \/\/ No embedded oops\n-  if(!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() &&\n-    oops.is_empty() && nm->oops_begin() >= nm->oops_end()) {\n-    return NULL;\n-  }\n-\n@@ -198,1 +191,2 @@\n-  } else if (heap->is_concurrent_weak_root_in_progress()) {\n+  } else if (heap->is_concurrent_weak_root_in_progress() ||\n+             heap->is_concurrent_strong_root_in_progress()) {\n@@ -291,6 +285,0 @@\n-\n-void ShenandoahNMethod::assert_no_oops(nmethod* nm, bool allow_dead) {\n-  ShenandoahNMethodOopDetector detector;\n-  nm->oops_do(&detector, allow_dead);\n-  assert(detector.oops()->length() == 0, \"Should not have oops\");\n-}\n@@ -324,5 +312,1 @@\n-    if (data == NULL) {\n-      assert(!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading(),\n-             \"Only possible when concurrent class unloading is off\");\n-      return;\n-    }\n+    assert(data != NULL, \"Sanity\");\n@@ -342,7 +326,1 @@\n-  if (data == NULL) {\n-    assert(!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading(),\n-           \"Only possible when concurrent class unloading is off\");\n-    ShenandoahNMethod::assert_no_oops(nm, true \/*allow_dead*\/);\n-    return;\n-  }\n-\n+  assert(data != NULL, \"Sanity\");\n@@ -364,6 +342,1 @@\n-  assert(data != NULL || !ShenandoahConcurrentRoots::can_do_concurrent_class_unloading(),\n-         \"Only possible when concurrent class unloading is off\");\n-  if (data == NULL) {\n-    ShenandoahNMethod::assert_no_oops(nm, true \/*allow_dead*\/);\n-    return;\n-  }\n+  assert(data != NULL, \"Sanity\");\n@@ -601,2 +574,0 @@\n-  assert(ShenandoahConcurrentRoots::can_do_concurrent_class_unloading(),\n-         \"Only for concurrent class unloading\");\n@@ -613,2 +584,0 @@\n-  assert(ShenandoahConcurrentRoots::can_do_concurrent_class_unloading(),\n-         \"Only for concurrent class unloading\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":5,"deletions":36,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-  static void assert_no_oops(nmethod* nm, bool allow_dea = false) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-  if (!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,3 +185,1 @@\n-                                                 ShenandoahPhaseTimings::Phase phase,\n-                                                 bool stw_roots_processing,\n-                                                 bool stw_class_unloading) :\n+                                                 ShenandoahPhaseTimings::Phase phase) :\n@@ -189,2 +187,0 @@\n-  _vm_roots(phase),\n-  _cld_roots(phase, n_workers),\n@@ -192,6 +188,2 @@\n-  _serial_weak_roots(phase),\n-  _weak_roots(phase),\n-  _dedup_roots(phase),\n-  _code_roots(phase),\n-  _stw_roots_processing(stw_roots_processing),\n-  _stw_class_unloading(stw_class_unloading) {\n+  _serial_weak_roots(phase) {\n+  nmethod::oops_do_marking_prologue();\n@@ -200,7 +192,3 @@\n-void ShenandoahRootEvacuator::roots_do(uint worker_id, OopClosure* oops) {\n-  MarkingCodeBlobClosure blobsCl(oops, CodeBlobToOopClosure::FixRelocations);\n-  ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(oops);\n-  CodeBlobToOopClosure* codes_cl = ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() ?\n-                                   static_cast<CodeBlobToOopClosure*>(&blobs_and_disarm_Cl) :\n-                                   static_cast<CodeBlobToOopClosure*>(&blobsCl);\n-  AlwaysTrueClosure always_true;\n+ShenandoahRootEvacuator::~ShenandoahRootEvacuator() {\n+  nmethod::oops_do_marking_epilogue();\n+}\n@@ -208,0 +196,4 @@\n+void ShenandoahRootEvacuator::roots_do(uint worker_id, OopClosure* oops) {\n+  \/\/ Always disarm on-stack nmethods, because we are evacuating\/updating them\n+  \/\/ here\n+  ShenandoahCodeBlobAndDisarmClosure codeblob_cl(oops);\n@@ -212,17 +204,1 @@\n-  if (_stw_roots_processing) {\n-    _vm_roots.oops_do<OopClosure>(oops, worker_id);\n-    _weak_roots.oops_do<OopClosure>(oops, worker_id);\n-    _dedup_roots.oops_do(&always_true, oops, worker_id);\n-  }\n-  if (_stw_class_unloading) {\n-    CLDToOopClosure clds(oops, ClassLoaderData::_claim_strong);\n-    _cld_roots.cld_do(&clds, worker_id);\n-  }\n-\n-  \/\/ Process heavy-weight\/fully parallel roots the last\n-  if (_stw_class_unloading) {\n-    _code_roots.code_blobs_do(codes_cl, worker_id);\n-    _thread_roots.oops_do(oops, NULL, worker_id);\n-  } else {\n-    _thread_roots.oops_do(oops, codes_cl, worker_id);\n-  }\n+  _thread_roots.oops_do(oops, &codeblob_cl, worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":11,"deletions":35,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -235,3 +235,0 @@\n-  ShenandoahVMRoots<false \/*concurrent*\/>                   _vm_roots;\n-  ShenandoahClassLoaderDataRoots<false \/*concurrent*\/, false \/*single threaded*\/>\n-                                                            _cld_roots;\n@@ -240,5 +237,0 @@\n-  ShenandoahVMWeakRoots<false \/*concurrent*\/>               _weak_roots;\n-  ShenandoahStringDedupRoots                                _dedup_roots;\n-  ShenandoahCodeCacheRoots                                  _code_roots;\n-  bool                                                      _stw_roots_processing;\n-  bool                                                      _stw_class_unloading;\n@@ -246,2 +238,2 @@\n-  ShenandoahRootEvacuator(uint n_workers, ShenandoahPhaseTimings::Phase phase,\n-                          bool stw_roots_processing, bool stw_class_unloading);\n+  ShenandoahRootEvacuator(uint n_workers, ShenandoahPhaseTimings::Phase phase);\n+  ~ShenandoahRootEvacuator();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1013,0 +1013,6 @@\n+void ShenandoahVerifier::verify_roots_no_forwarded(ShenandoahRootVerifier::RootTypes types) {\n+  ShenandoahRootVerifier verifier(types);\n+  ShenandoahVerifyNoForwared cl;\n+  verifier.oops_do(&cl);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+  void verify_roots_no_forwarded(ShenandoahRootVerifier::RootTypes types);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}