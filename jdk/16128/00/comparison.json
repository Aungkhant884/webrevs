{"files":[{"patch":"@@ -111,0 +111,1 @@\n+        --add-exports java.base\/jdk.internal.foreign=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1079,1 +1079,1 @@\n-        return getString(offset, StandardCharsets.UTF_8);\n+        return getString(offset, sun.nio.cs.UTF_8.INSTANCE);\n@@ -1135,1 +1135,1 @@\n-        setString(offset, str, StandardCharsets.UTF_8);\n+        setString(offset, str, sun.nio.cs.UTF_8.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-        return allocateFrom(str, StandardCharsets.UTF_8);\n+        return allocateFrom(str, sun.nio.cs.UTF_8.INSTANCE);\n@@ -128,1 +128,1 @@\n-        MemorySegment segment = allocateNoInit(bytes.length + termCharSize);\n+        MemorySegment segment = allocateNoInit((long) bytes.length + termCharSize);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.foreign.Utils;\n+\n@@ -57,1 +59,1 @@\n-        return new IllegalArgumentException(\"Misaligned access at address: \" + address);\n+        return new IllegalArgumentException(\"Misaligned access at address: \" + Utils.toHexString(address));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -43,0 +44,1 @@\n+import java.util.Locale;\n@@ -46,0 +48,3 @@\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.joining;\n@@ -92,1 +97,0 @@\n-\n@@ -108,2 +112,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -115,2 +118,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -125,1 +127,1 @@\n-                                     addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n+                addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n@@ -129,2 +131,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -134,1 +135,1 @@\n-        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters,this);\n+        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters, this);\n@@ -138,2 +139,1 @@\n-        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n-        GroupLayout g = (GroupLayout)layout;\n+        GroupLayout g = requireGroupLayout();\n@@ -153,1 +153,2 @@\n-            throw badLayoutPath(\"cannot resolve '\" + name + \"' in layout \" + layout);\n+            throw badLayoutPath(\n+                    String.format(\"cannot resolve '%s' in layout %s\", name, breadcrumbs()));\n@@ -159,2 +160,1 @@\n-        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n-        GroupLayout g = (GroupLayout)layout;\n+        GroupLayout g = requireGroupLayout();\n@@ -166,1 +166,2 @@\n-                throw badLayoutPath(\"cannot resolve element \" + index + \" in layout \" + layout);\n+                throw badLayoutPath(\n+                        String.format(\"cannot resolve element %d in layout: %s\", index, breadcrumbs()));\n@@ -179,1 +180,2 @@\n-            throw badLayoutPath(\"Cannot dereference layout: \" + layout);\n+            throw badLayoutPath(\n+                    String.format(\"Cannot dereference layout: %s\", breadcrumbs()));\n@@ -204,1 +206,2 @@\n-            throw new IllegalArgumentException(\"Path does not select a value layout\");\n+            throw new IllegalArgumentException(\n+                    String.format(\"Path does not select a value layout: %s\", breadcrumbs()));\n@@ -291,1 +294,3 @@\n-            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints: \" + constraint.byteAlignment());\n+            throw new IllegalArgumentException(String.format(\n+                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n+                    , offset, constraint.byteAlignment(), constraint, segment));\n@@ -317,1 +322,9 @@\n-    private void check(Class<?> layoutClass, String msg) {\n+    private SequenceLayout requireSequenceLayout() {\n+        return requireLayoutType(SequenceLayout.class, \"sequence\");\n+    }\n+\n+    private GroupLayout requireGroupLayout() {\n+        return requireLayoutType(GroupLayout.class, \"group\");\n+    }\n+\n+    private <T extends MemoryLayout> T requireLayoutType(Class<T> layoutClass, String name) {\n@@ -319,1 +332,3 @@\n-            throw badLayoutPath(msg);\n+            throw badLayoutPath(\n+                    String.format(\"attempting to select a %s element from a non-%s layout: %s\",\n+                            name, name, breadcrumbs()));\n@@ -321,0 +336,1 @@\n+        return layoutClass.cast(layout);\n@@ -325,1 +341,2 @@\n-            throw badLayoutPath(String.format(\"Sequence index out of bound; found: %d, size: %d\", index, seq.elementCount()));\n+            throw badLayoutPath(String.format(\"sequence index out of bounds; index: %d, elementCount is %d for layout %s\",\n+                    index, seq.elementCount(), breadcrumbs()));\n@@ -345,0 +362,7 @@\n+    private String breadcrumbs() {\n+        return Stream.iterate(this, Objects::nonNull, lp -> lp.enclosing)\n+                .map(LayoutPath::layout)\n+                .map(Object::toString)\n+                .collect(joining(\", selected from: \"));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":45,"deletions":21,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.util.ArraysSupport;\n+\n@@ -32,3 +35,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -40,0 +41,3 @@\n+\n+    private StringSupport() {}\n+\n@@ -42,3 +46,3 @@\n-            case SINGLE_BYTE -> readFast_byte(segment, offset, charset);\n-            case DOUBLE_BYTE -> readFast_short(segment, offset, charset);\n-            case QUAD_BYTE -> readFast_int(segment, offset, charset);\n+            case SINGLE_BYTE -> readByte(segment, offset, charset);\n+            case DOUBLE_BYTE -> readShort(segment, offset, charset);\n+            case QUAD_BYTE -> readInt(segment, offset, charset);\n@@ -50,3 +54,3 @@\n-            case SINGLE_BYTE -> writeFast_byte(segment, offset, charset, string);\n-            case DOUBLE_BYTE -> writeFast_short(segment, offset, charset, string);\n-            case QUAD_BYTE -> writeFast_int(segment, offset, charset, string);\n+            case SINGLE_BYTE -> writeByte(segment, offset, charset, string);\n+            case DOUBLE_BYTE -> writeShort(segment, offset, charset, string);\n+            case QUAD_BYTE -> writeInt(segment, offset, charset, string);\n@@ -55,2 +59,3 @@\n-    private static String readFast_byte(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlen_byte(segment, offset);\n+\n+    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenByte(segment, offset);\n@@ -62,1 +67,1 @@\n-    private static void writeFast_byte(MemorySegment segment, long offset, Charset charset, String string) {\n+    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n@@ -68,2 +73,2 @@\n-    private static String readFast_short(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlen_short(segment, offset);\n+    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenShort(segment, offset);\n@@ -75,1 +80,1 @@\n-    private static void writeFast_short(MemorySegment segment, long offset, Charset charset, String string) {\n+    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n@@ -81,2 +86,2 @@\n-    private static String readFast_int(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlen_int(segment, offset);\n+    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlenInt(segment, offset);\n@@ -88,1 +93,1 @@\n-    private static void writeFast_int(MemorySegment segment, long offset, Charset charset, String string) {\n+    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n@@ -94,3 +99,97 @@\n-    private static int strlen_byte(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset++) {\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero byte in the provided {@code segment}}\n+     * <p>\n+     * The method divides the region of interest into three distinct regions:\n+     * <ul>\n+     *     <li>head (access made on a byte-by-byte basis) (if any)<\/li>\n+     *     <li>body (access made with eight bytes at a time at physically 64-bit-aligned memory) (if any)<\/li>\n+     *     <li>tail (access made on a byte-by-byte basis) (if any)<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The body is using a heuristic method to determine if a long word\n+     * contains a zero byte. The method might have false positives but\n+     * never false negatives.\n+     * <p>\n+     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero bytes\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroByte(curr)) {\n+                for (int j = 0; j < 8; j++) {\n+                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n+    }\n+\n+    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+       the \"holes\".  Note that there is a hole just to the left of\n+       each byte, with an extra at the end:\n+\n+       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+\n+       The 1-bits make sure that carries propagate to the next 0-bit.\n+       The 0-bits provide holes for carries to fall into.\n+    *\/\n+    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n+    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n+\n+    static boolean mightContainZeroByte(long l) {\n+        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n+    }\n+\n+    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n+    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n+\n+    static boolean mightContainZeroShort(long l) {\n+        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n+    }\n+\n+    static int requireWithinArraySize(long size) {\n+        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw newIaeStringTooLarge();\n+        }\n+        return (int) size;\n+    }\n+\n+    static int bodyCount(long remaining) {\n+        return (int) Math.min(\n+                \/\/ Make sure we do not wrap around\n+                Integer.MAX_VALUE - Long.BYTES,\n+                \/\/ Remaining bytes to consider\n+                remaining)\n+                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n+    }\n+\n+    private static int strlenByte(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n@@ -102,1 +201,1 @@\n-        throw new IllegalArgumentException(\"String too large\");\n+        throw newIaeStringTooLarge();\n@@ -105,3 +204,20 @@\n-    private static int strlen_short(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 2) {\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero short in the provided {@code segment}}\n+     * <p>\n+     * Note: The inspected region must be short aligned.\n+     *\n+     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero shorts\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset += Short.BYTES) {\n@@ -113,1 +229,19 @@\n-        throw new IllegalArgumentException(\"String too large\");\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroShort(curr)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n@@ -116,4 +250,16 @@\n-    private static int strlen_int(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 4) {\n-            int curr = segment.get(JAVA_INT, start + offset);\n+    private static int strlenShort(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n+            if (curr == (short)0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n+    \/\/ so, there is only one method for ints.\n+    public static int strlenInt(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n+            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n+            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n@@ -124,1 +270,1 @@\n-        throw new IllegalArgumentException(\"String too large\");\n+        throw newIaeStringTooLarge();\n@@ -143,6 +289,13 @@\n-            if (charset == StandardCharsets.UTF_8 || charset == StandardCharsets.ISO_8859_1 || charset == StandardCharsets.US_ASCII) {\n-                return CharsetKind.SINGLE_BYTE;\n-            } else if (charset == StandardCharsets.UTF_16LE || charset == StandardCharsets.UTF_16BE || charset == StandardCharsets.UTF_16) {\n-                return CharsetKind.DOUBLE_BYTE;\n-            } else if (charset == StandardCharsets.UTF_32LE || charset == StandardCharsets.UTF_32BE || charset == StandardCharsets.UTF_32) {\n-                return CharsetKind.QUAD_BYTE;\n+            \/\/ Comparing the charset to specific internal implementations avoids loading the class `StandardCharsets`\n+            if        (charset == sun.nio.cs.UTF_8.INSTANCE ||\n+                       charset == sun.nio.cs.ISO_8859_1.INSTANCE ||\n+                       charset == sun.nio.cs.US_ASCII.INSTANCE) {\n+                return SINGLE_BYTE;\n+            } else if (charset instanceof sun.nio.cs.UTF_16LE ||\n+                       charset instanceof sun.nio.cs.UTF_16BE ||\n+                       charset instanceof sun.nio.cs.UTF_16) {\n+                return DOUBLE_BYTE;\n+            } else if (charset instanceof sun.nio.cs.UTF_32LE ||\n+                       charset instanceof sun.nio.cs.UTF_32BE ||\n+                       charset instanceof sun.nio.cs.UTF_32) {\n+                return QUAD_BYTE;\n@@ -154,0 +307,5 @@\n+\n+    private static IllegalArgumentException newIaeStringTooLarge() {\n+        return new IllegalArgumentException(\"String too large\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":195,"deletions":37,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n@@ -157,1 +157,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -60,1 +59,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -132,0 +130,4 @@\n+    public static long remainsToAlignment(long addr, long alignment) {\n+        return alignUp(addr, alignment) - addr;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -39,1 +40,1 @@\n-            throw new IllegalStateException(\"Not a stub address: \" + stubAddress);\n+            throw new IllegalStateException(\"Not a stub address: \" + Utils.toHexString(stubAddress));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n+     *     <li>{@link AddressLayout}, for {@code MemorySegment.class}<\/li>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -139,1 +140,1 @@\n-    public void testBadAlignmentOfRoot() throws Throwable {\n+    public void testBadAlignmentOfRoot() {\n@@ -150,1 +151,1 @@\n-            String expectedMessage = \"Target offset incompatible with alignment constraints: \" + struct.byteAlignment();\n+            String expectedMessage = \"Target offset 0 is incompatible with alignment constraint \" + struct.byteAlignment() + \" (of [i4s2(x)]) for segment MemorySegment\";\n@@ -156,1 +157,1 @@\n-            assertEquals(iae.getMessage(), expectedMessage);\n+            assertTrue(iae.getMessage().startsWith(expectedMessage));\n@@ -162,1 +163,1 @@\n-            assertEquals(iae.getMessage(), expectedMessage);\n+            assertTrue(iae.getMessage().startsWith(expectedMessage));\n@@ -166,0 +167,36 @@\n+    @Test\n+    public void testWrongTypeRoot() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)\n+        );\n+\n+        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: [i4i4]\";\n+\n+        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n+                struct.select(PathElement.sequenceElement()));\n+        assertEquals(iae.getMessage(), expectedMessage);\n+    }\n+\n+    @Test\n+    public void testWrongTypeEnclosing() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(2, MemoryLayout.structLayout(\n+                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3a\"),\n+                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3b\")\n+                        ).withName(\"2\")\n+                ).withName(\"1\")\n+        ).withName(\"0\");\n+\n+        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: \" +\n+                \"[i4(3a)i4(3b)](2), selected from: \" +\n+                \"[2:[i4(3a)i4(3b)](2)](1), selected from: \" +\n+                \"[[2:[i4(3a)i4(3b)](2)](1)](0)\";\n+\n+        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n+                struct.select(PathElement.groupElement(\"1\"),\n+                        PathElement.sequenceElement(),\n+                        PathElement.sequenceElement()));\n+        assertEquals(iae.getMessage(), expectedMessage);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":41,"deletions":4,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n@@ -26,0 +28,3 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n@@ -27,0 +32,3 @@\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n@@ -28,0 +36,1 @@\n+import java.nio.channels.FileChannel;\n@@ -30,0 +39,8 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n@@ -31,0 +48,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -32,0 +50,2 @@\n+\n+import static java.lang.foreign.ValueLayout.*;\n@@ -36,0 +56,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -42,1 +63,1 @@\n-    public void testStrings(String testString) throws ReflectiveOperationException {\n+    public void testStrings(String testString) {\n@@ -45,2 +66,15 @@\n-                try (Arena arena = Arena.ofConfined()) {\n-                    MemorySegment text = arena.allocateFrom(testString, charset);\n+                for (Arena arena : arenas()) {\n+                    try (arena) {\n+                        MemorySegment text = arena.allocateFrom(testString, charset);\n+\n+                        int terminatorSize = \"\\0\".getBytes(charset).length;\n+                        if (charset == StandardCharsets.UTF_16) {\n+                            terminatorSize -= 2; \/\/ drop BOM\n+                        }\n+                        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n+\n+                        int expectedByteLength =\n+                                testString.getBytes(charset).length +\n+                                        terminatorSize;\n@@ -48,3 +82,6 @@\n-                    int terminatorSize = \"\\0\".getBytes(charset).length;\n-                    if (charset == StandardCharsets.UTF_16) {\n-                        terminatorSize -= 2; \/\/ drop BOM\n+                        assertEquals(text.byteSize(), expectedByteLength);\n+\n+                        String roundTrip = text.getString(0, charset);\n+                        if (charset.newEncoder().canEncode(testString)) {\n+                            assertEquals(roundTrip, testString);\n+                        }\n@@ -52,3 +89,15 @@\n-                    \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n-                    \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n-                    \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n+                }\n+            } else {\n+                assertThrows(IllegalArgumentException.class, () -> Arena.global().allocateFrom(testString, charset));\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsHeap(String testString) {\n+        for (Charset charset : singleByteCharsets()) {\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset);\n+                    text = toHeapSegment(text);\n@@ -57,2 +106,1 @@\n-                            testString.getBytes(charset).length +\n-                            terminatorSize;\n+                            testString.getBytes(charset).length + 1;\n@@ -67,2 +115,217 @@\n-            } else {\n-                assertThrows(IllegalArgumentException.class, () -> Arena.global().allocateFrom(testString, charset));\n+            }\n+        }\n+    }\n+\n+    MemorySegment toHeapSegment(MemorySegment segment) {\n+        var heapArray = segment.toArray(JAVA_BYTE);\n+        return MemorySegment.ofArray(heapArray);\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void unboundedSegment(String testString) {\n+        testModifyingSegment(testString,\n+                standardCharsets(),\n+                s -> s.reinterpret(Long.MAX_VALUE),\n+                UnaryOperator.identity());\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void unalignedSegmentSingleByte(String testString) {\n+        testModifyingSegment(testString,\n+                singleByteCharsets(),\n+                s -> s.byteSize() > 1 ? s.asSlice(1) : s,\n+                s -> s.length() > 0 ? s.substring(1) : s);\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void expandedSegment(String testString) {\n+        try (var arena = Arena.ofConfined()) {\n+            for (int i = 0; i < Long.BYTES; i++) {\n+                int extra = i;\n+                testModifyingSegment(testString,\n+                        \/\/ Single byte charsets\n+                        standardCharsets(),\n+                        s -> {\n+                            var s2 = arena.allocate(s.byteSize() + extra);\n+                            MemorySegment.copy(s, 0, s2, 0, s.byteSize());\n+                            return s2;\n+                        },\n+                        UnaryOperator.identity());\n+            }\n+        }\n+    }\n+\n+    public void testModifyingSegment(String testString,\n+                                     List<Charset> charsets,\n+                                     UnaryOperator<MemorySegment> segmentMapper,\n+                                     UnaryOperator<String> stringMapper) {\n+        for (var charset : charsets) {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment text = arena.allocateFrom(testString, charset);\n+                text = segmentMapper.apply(text);\n+                String roundTrip = text.getString(0, charset);\n+                String expected = stringMapper.apply(testString);\n+                if (charset.newEncoder().canEncode(testString)) {\n+                    assertEquals(roundTrip, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test()\n+    public void testPeculiarContentSingleByte() {\n+        Random random = new Random(42);\n+        for (int len = 7; len < 71; len++) {\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    var segment = arena.allocate(len, 1);\n+                    var arr = new byte[len];\n+                    random.nextBytes(arr);\n+                    segment.copyFrom(MemorySegment.ofArray(arr));\n+                    int terminatorIndex = random.nextInt(len);\n+                    segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n+                    for (Charset charset : singleByteCharsets()) {\n+                        var s = segment.getString(0, charset);\n+                        var ref = referenceImpl(segment, 0, charset);\n+                        assertEquals(s, ref);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testOffset(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment inSegment = arena.allocateFrom(testString, charset);\n+                    for (int i = 0; i < 3; i++) {\n+                        String actual = inSegment.getString(i, charset);\n+                        assertEquals(actual, testString.substring(i));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final MemoryLayout CHAR_POINTER = ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n+    private static final Linker LINKER = Linker.nativeLinker();\n+    private static final MethodHandle STRCAT = LINKER.downcallHandle(\n+            LINKER.defaultLookup().find(\"strcat\").orElseThrow(),\n+            FunctionDescriptor.of(CHAR_POINTER, CHAR_POINTER, CHAR_POINTER));\n+\n+    @Test(dataProvider = \"strings\")\n+    public void nativeSegFromNativeCall(String testString) {\n+        String addition = \"123\";\n+        try (var arena = Arena.ofConfined()) {\n+            try {\n+                var testStringSegment = arena.allocateFrom(testString);\n+                var additionSegment = arena.allocateFrom(addition);\n+                var destination = arena.allocate(testStringSegment.byteSize() + additionSegment.byteSize() - 1);\n+                destination.copyFrom(testStringSegment);\n+\n+                MemorySegment concatenation = (MemorySegment) STRCAT.invokeExact(destination, arena.allocateFrom(addition));\n+                var actual = concatenation.getString(0);\n+                assertEquals(actual, testString + addition);\n+            } catch (Throwable t) {\n+                throw new AssertionError(t);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void segmentationFault() {\n+        for (int i = 1; i < 18; i++) {\n+            var size = 1 << i;\n+            try (var arena = Arena.ofConfined()) {\n+                var seg = arena.allocate(size, size);\n+                seg.fill((byte) 1);\n+                try {\n+                    var s = seg.getString(0);\n+                    System.out.println(\"s.length() = \" + s.length());\n+                } catch (IndexOutOfBoundsException e) {\n+                    \/\/ we will end up here if strlen finds a zero outside the MS\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final int TEST_LENGTH_MAX = 277;\n+\n+    private Random deterministicRandom() {\n+        return new Random(42);\n+    }\n+\n+    @Test\n+    public void chunked_strlen_byte() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew++) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate(len + 1 + skew)\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        byte value;\n+                        while ((value = (byte) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_BYTE, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_BYTE, len, (byte) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n+                        assertEquals(actual, len - j);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void chunked_strlen_short() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Short.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Short.BYTES + skew, JAVA_SHORT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        short value;\n+                        while ((value = (short) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_SHORT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_SHORT, len, (short) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n+                        assertEquals(actual, (len - j) * Short.BYTES);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void strlen_int() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Integer.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Integer.BYTES + skew, JAVA_INT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        int value;\n+                        while ((value = random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_INT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_INT, len, 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n+                        assertEquals(actual, (len - j) * Integer.BYTES);\n+                    }\n+                }\n@@ -75,8 +338,18 @@\n-        return new Object[][] {\n-            { \"testing\" },\n-            { \"\" },\n-            { \"X\" },\n-            { \"12345\" },\n-            { \"yen \\u00A5\" },\n-            { \"snowman \\u26C4\" },\n-            { \"rainbow \\uD83C\\uDF08\" }\n+        return new Object[][]{\n+                {\"testing\"},\n+                {\"\"},\n+                {\"X\"},\n+                {\"12345\"},\n+                {\"yen \\u00A5\"},\n+                {\"snowman \\u26C4\"},\n+                {\"rainbow \\uD83C\\uDF08\"},\n+                {\"0\"},\n+                {\"01\"},\n+                {\"012\"},\n+                {\"0123\"},\n+                {\"01234\"},\n+                {\"012345\"},\n+                {\"0123456\"},\n+                {\"01234567\"},\n+                {\"012345678\"},\n+                {\"0123456789\"}\n@@ -86,1 +359,6 @@\n-    boolean isStandard(Charset charset) throws ReflectiveOperationException {\n+    public static boolean containsOnlyRegularCharacters(String s) {\n+        return s.chars()\n+                .allMatch(c -> Character.isLetterOrDigit((char) c));\n+    }\n+\n+    boolean isStandard(Charset charset) {\n@@ -88,2 +366,6 @@\n-            if (standardCharset.get(null) == charset) {\n-                return true;\n+            try {\n+                if (standardCharset.get(null) == charset) {\n+                    return true;\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                throw new AssertionError(e);\n@@ -94,0 +376,83 @@\n+\n+    List<Charset> standardCharsets() {\n+        return Charset.availableCharsets().values().stream()\n+                .filter(this::isStandard)\n+                .toList();\n+    }\n+\n+    List<Charset> singleByteCharsets() {\n+        return Arrays.asList(StandardCharsets.UTF_8, StandardCharsets.ISO_8859_1, StandardCharsets.US_ASCII);\n+    }\n+\n+    static String referenceImpl(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_byte(segment, offset);\n+        byte[] bytes = new byte[(int) len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int) len);\n+        return new String(bytes, charset);\n+    }\n+\n+    \/\/ Reference implementation\n+    private static int strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static List<Arena> arenas() {\n+        return Arrays.asList(\n+                Arena.ofConfined(),          \/\/ Native memory\n+                new HeapArena(byte.class),   \/\/ Heap memory backed by a byte array\n+                new HeapArena(short.class),  \/\/ Heap memory backed by a short array\n+                new HeapArena(int.class),    \/\/ Heap memory backed by an int array\n+                new HeapArena(long.class));  \/\/ Heap memory backed by a long array\n+    }\n+\n+    private static final class HeapArena implements Arena {\n+\n+        private static final int ELEMENT_SIZE = 1_000;\n+\n+        private final MemorySegment backingSegment;\n+        private final SegmentAllocator allocator;\n+\n+        public HeapArena(Class<?> type) {\n+            backingSegment = switch (type) {\n+                case Class<?> c when byte.class.equals(c) -> MemorySegment.ofArray(new byte[ELEMENT_SIZE]);\n+                case Class<?> c when short.class.equals(c) ->\n+                        MemorySegment.ofArray(new short[ELEMENT_SIZE]);\n+                case Class<?> c when int.class.equals(c) ->\n+                        MemorySegment.ofArray(new int[ELEMENT_SIZE]);\n+                case Class<?> c when long.class.equals(c) ->\n+                        MemorySegment.ofArray(new long[ELEMENT_SIZE]);\n+                default -> throw new IllegalArgumentException(type.toString());\n+            };\n+            allocator = SegmentAllocator.slicingAllocator(backingSegment);\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return allocator.allocate(byteSize, byteAlignment);\n+        }\n+\n+        @Override\n+        public MemorySegment.Scope scope() {\n+            return backingSegment.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ Do nothing\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"HeapArena{\" +\n+                    \"type=\" + backingSegment.heapBase().orElseThrow().getClass().getName() +\n+                    '}';\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":389,"deletions":24,"binary":false,"changes":413,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign\n+ * @requires sun.arch.data.model == \"64\"\n+ * @requires vm.flavor != \"zero\"\n+ *\n+ * @run testng\/othervm -Xmx6G TestStringEncodingJumbo\n+ *\/\n+\n+public class TestStringEncodingJumbo {\n+\n+    @Test()\n+    public void testJumboSegment() {\n+        testWithJumboSegment(\"testJumboSegment\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            String big = segment.getString(100);\n+            assertEquals(big.length(), Integer.MAX_VALUE - (100 - 10));\n+        });\n+    }\n+\n+    @Test()\n+    public void testStringLargerThanMaxInt() {\n+        testWithJumboSegment(\"testStringLargerThanMaxInt\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            assertThrows(IllegalArgumentException.class, () -> {\n+                segment.getString(0);\n+            });\n+        });\n+    }\n+\n+    private static void testWithJumboSegment(String testName, Consumer<MemorySegment> tester) {\n+        Path path = Paths.get(\"mapped_file\");\n+        try {\n+            \/\/ Relly try to make sure the file is deleted after use\n+            path.toFile().deleteOnExit();\n+            deleteIfExistsOrThrow(path);\n+            try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"rw\")) {\n+                FileChannel fc = raf.getChannel();\n+                try (Arena arena = Arena.ofConfined()) {\n+                    var segment = fc.map(FileChannel.MapMode.READ_WRITE, 0L, (long) Integer.MAX_VALUE + 100, arena);\n+                    tester.accept(segment);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        } catch (OutOfMemoryError oome) {\n+            \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n+            System.out.println(\"Skipping test because of insufficient memory: \" + testName);\n+        } finally {\n+            deleteIfExistsOrThrow(path);\n+        }\n+    }\n+\n+    private static void deleteIfExistsOrThrow(Path file) {\n+        try {\n+            Files.deleteIfExists(file);\n+        } catch (IOException ioe) {\n+            throw new AssertionError(\"Unable to delete mapped file: \" + file);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestStringEncodingJumbo.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public long alloc_calloc_arena() {\n+        CallocArena arena = new CallocArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    @Benchmark\n+    public long alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    public static class CallocArena implements Arena {\n+\n+        static final MethodHandle CALLOC = Linker.nativeLinker()\n+                .downcallHandle(\n+                        Linker.nativeLinker().defaultLookup().find(\"calloc\").get(),\n+                        FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n+\n+        static MemorySegment calloc(long size) {\n+            try {\n+                return (MemorySegment)CALLOC.invokeExact(size, 1L);\n+            } catch (Throwable ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return calloc(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            MemorySegment segment = MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize));\n+            Utils.unsafe.setMemory(segment.address(), byteSize, (byte)0);\n+            return segment.reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(segment.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static jdk.internal.foreign.StringSupport.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class InternalStrLen {\n+\n+    private MemorySegment singleByteSegment;\n+    private MemorySegment singleByteSegmentMisaligned;\n+    private MemorySegment doubleByteSegment;\n+    private MemorySegment quadByteSegment;\n+\n+    @Param({\"1\", \"4\", \"16\", \"251\", \"1024\"})\n+    int size;\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n+        singleByteSegmentMisaligned = arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n+        Stream.of(singleByteSegment, doubleByteSegment, quadByteSegment)\n+                .forEach(s -> IntStream.range(0, (int) s.byteSize() - 1)\n+                        .forEach(i -> s.set(\n+                                ValueLayout.JAVA_BYTE,\n+                                i,\n+                                (byte) ThreadLocalRandom.current().nextInt(1, 254)\n+                        )));\n+        singleByteSegment.set(ValueLayout.JAVA_BYTE, singleByteSegment.byteSize() - Byte.BYTES, (byte) 0);\n+        doubleByteSegment.set(ValueLayout.JAVA_SHORT, doubleByteSegment.byteSize() - Short.BYTES, (short) 0);\n+        quadByteSegment.set(ValueLayout.JAVA_INT, quadByteSegment.byteSize() - Integer.BYTES, 0);\n+        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n+                asSlice(1);\n+        MemorySegment.copy(singleByteSegment, 0, singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n+    }\n+\n+    @Benchmark\n+    public int elementSingle() {\n+        return legacy_strlen_byte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementByteMisaligned() {\n+        return legacy_strlen_byte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementDouble() {\n+        return legacy_strlen_short(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementQuad() {\n+        return legacy_strlen_int(quadByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedSingle() {\n+        return chunkedStrlenByte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedSingleMisaligned() {\n+        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedDouble() {\n+        return chunkedStrlenShort(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int changedElementQuad() {\n+        return strlenInt(quadByteSegment, 0);\n+    }\n+\n+    \/\/ These are the legacy methods\n+\n+    private static int legacy_strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_short(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 2) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_int(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 4) {\n+            int curr = segment.get(JAVA_INT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class ToCStringTest extends CLayouts {\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\"})\n+    public int size;\n+    public String str;\n+\n+    static {\n+        System.loadLibrary(\"ToCString\");\n+    }\n+\n+    static final MethodHandle STRLEN;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        STRLEN = abi.downcallHandle(abi.defaultLookup().find(\"strlen\").get(),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        str = makeString(size);\n+    }\n+\n+    @Benchmark\n+    public long jni_writeString() throws Throwable {\n+        return writeString(str);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_writeString() throws Throwable {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(str);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    static native long writeString(String str);\n+\n+    static String makeString(int size) {\n+        String lorem = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+        return lorem.substring(0, size);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToCStringTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class ToJavaStringTest {\n+\n+    private MemorySegment strSegment;\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\"})\n+    int size;\n+\n+    static {\n+        System.loadLibrary(\"ToJavaString\");\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        strSegment = arena.allocateFrom(LOREM.substring(0, size));\n+    }\n+\n+    @Benchmark\n+    public String panama_readString() {\n+        return strSegment.getString(0);\n+    }\n+\n+    @Benchmark\n+    public String jni_readString() {\n+        return readString(strSegment.address());\n+    }\n+\n+    static native String readString(long addr);\n+\n+    static String LOREM = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_java_lang_foreign_ToCStringTest_writeString(JNIEnv *const env, const jclass cls, const jstring text) {\n+    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n+    jlong addr = (jlong)(void*)str;\n+    (*env)->ReleaseStringUTFChars(env, text, str);\n+    return addr;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToCString.c","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jstring JNICALL Java_org_openjdk_bench_java_lang_foreign_ToJavaStringTest_readString(JNIEnv *const env, const jclass cls, jlong addr) {\n+    return (*env)->NewStringUTF(env, (char*)(void*)addr);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToJavaString.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"}]}