{"files":[{"patch":"@@ -378,4 +378,13 @@\n-        for (SignatureScheme ss: SignatureScheme.values()) {\n-            if (!ss.isAvailable ||\n-                    (!config.signatureSchemes.isEmpty() &&\n-                        !config.signatureSchemes.contains(ss))) {\n+\n+        \/\/ If config.signatureSchemes is non-empty then it means that\n+        \/\/ it was defined by a System property.  Per\n+        \/\/ SSLConfiguration.getCustomizedSignatureScheme() the list will\n+        \/\/ only contain schemes that are in the enum.\n+        \/\/ Otherwise, use the enum constants (converted to a List).\n+        List<SignatureScheme> schemesToCheck =\n+                config.signatureSchemes.isEmpty() ?\n+                    Arrays.asList(SignatureScheme.values()) :\n+                    config.signatureSchemes;\n+\n+        for (SignatureScheme ss: schemesToCheck) {\n+            if (!ss.isAvailable) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-    private final SSLEngine clientEngine;     \/\/ client Engine\n-    private final ByteBuffer clientOut;       \/\/ write side of clientEngine\n-    private final ByteBuffer clientIn;        \/\/ read side of clientEngine\n+    protected final SSLEngine clientEngine;     \/\/ client Engine\n+    protected final ByteBuffer clientOut;       \/\/ write side of clientEngine\n+    protected final ByteBuffer clientIn;        \/\/ read side of clientEngine\n@@ -59,3 +59,3 @@\n-    private final SSLEngine serverEngine;     \/\/ server Engine\n-    private final ByteBuffer serverOut;       \/\/ write side of serverEngine\n-    private final ByteBuffer serverIn;        \/\/ read side of serverEngine\n+    protected final SSLEngine serverEngine;     \/\/ server Engine\n+    protected final ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    protected final ByteBuffer serverIn;        \/\/ read side of serverEngine\n@@ -66,2 +66,2 @@\n-    private final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n-    private final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n+    protected final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    protected final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n@@ -69,1 +69,1 @@\n-    private SSLEngineTemplate() throws Exception {\n+    protected SSLEngineTemplate() throws Exception {\n@@ -226,1 +226,1 @@\n-    private static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+    protected static void runDelegatedTasks(SSLEngine engine) throws Exception {\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLEngineTemplate.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,333 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\/\/\n+\n+\/*\n+ * @test\n+ * @bug 8255867\n+ * @summary SignatureScheme JSSE property does not preserve ordering in handshake messages\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm SigSchemePropOrdering\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.util.*;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLException;\n+\n+public class SigSchemePropOrdering extends SSLEngineTemplate {\n+\n+    \/\/ Helper map to correlate integral SignatureScheme identifiers to\n+    \/\/ their IANA string name counterparts.\n+    static final Map<Integer, String> sigSchemeMap = Map.ofEntries(\n+            new SimpleImmutableEntry(0x0401, \"rsa_pkcs1_sha256\"),\n+            new SimpleImmutableEntry(0x0501, \"rsa_pkcs1_sha384\"),\n+            new SimpleImmutableEntry(0x0601, \"rsa_pkcs1_sha512\"),\n+            new SimpleImmutableEntry(0x0403, \"ecdsa_secp256r1_sha256\"),\n+            new SimpleImmutableEntry(0x0503, \"ecdsa_secp384r1_sha384\"),\n+            new SimpleImmutableEntry(0x0603, \"ecdsa_secp521r1_sha512\"),\n+            new SimpleImmutableEntry(0x0804, \"rsa_pss_rsae_sha256\"),\n+            new SimpleImmutableEntry(0x0805, \"rsa_pss_rsae_sha384\"),\n+            new SimpleImmutableEntry(0x0806, \"rsa_pss_rsae_sha512\"),\n+            new SimpleImmutableEntry(0x0807, \"ed25519\"),\n+            new SimpleImmutableEntry(0x0808, \"ed448\"),\n+            new SimpleImmutableEntry(0x0809, \"rsa_pss_pss_sha256\"),\n+            new SimpleImmutableEntry(0x080a, \"rsa_pss_pss_sha384\"),\n+            new SimpleImmutableEntry(0x080b, \"rsa_pss_pss_sha512\"),\n+            new SimpleImmutableEntry(0x0101, \"rsa_md5\"),\n+            new SimpleImmutableEntry(0x0201, \"rsa_pkcs1_sha1\"),\n+            new SimpleImmutableEntry(0x0202, \"dsa_sha1\"),\n+            new SimpleImmutableEntry(0x0203, \"ecdsa_sha1\"),\n+            new SimpleImmutableEntry(0x0301, \"rsa_sha224\"),\n+            new SimpleImmutableEntry(0x0302, \"dsa_sha224\"),\n+            new SimpleImmutableEntry(0x0303, \"ecdsa_sha224\"),\n+            new SimpleImmutableEntry(0x0402, \"rsa_pkcs1_sha256\"));\n+\n+    \/\/ Other useful TLS definitions for these tests\n+    private static final int TLS_HS_CLI_HELLO = 1;\n+    private static final int TLS_HS_CERT_REQ = 13;\n+    private static final int HELLO_EXT_SIG_ALGS = 13;\n+\n+    private static final String SIG_SCHEME_STR =\n+            \"rsa_pkcs1_sha256,rsa_pss_rsae_sha256,rsa_pss_pss_sha256,\" +\n+            \"ed448,ed25519,ecdsa_secp256r1_sha256\";\n+\n+    SigSchemePropOrdering() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"javax.net.debug\", \"ssl:handshake\");\n+        System.setProperty(\"jdk.tls.client.SignatureSchemes\", SIG_SCHEME_STR);\n+        System.setProperty(\"jdk.tls.server.SignatureSchemes\", SIG_SCHEME_STR);\n+        new SigSchemePropOrdering().run();\n+    }\n+\n+    @Override\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n+        return clientEngine;\n+    }\n+\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setWantClientAuth(true);\n+        return serverEngine;\n+    }\n+\n+    private void run() throws Exception {\n+        \/\/ Start the handshake.  Check the ClientHello's signature_algorithms\n+        \/\/ extension and make sure the ordering matches what we specified\n+        \/\/ in the property above.\n+        List<String> expectedSS = Arrays.asList(SIG_SCHEME_STR.split(\",\"));\n+\n+        clientEngine.wrap(clientOut, cTOs);\n+        cTOs.flip();\n+\n+        List<String> actualSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO));\n+\n+        \/\/ Make sure the ordering is correct\n+        if (!expectedSS.equals(actualSS)) {\n+            System.out.println(\"FAIL: Mismatch between property ordering \" +\n+                    \"and ClientHello message\");\n+            System.out.print(\"Expected SigSchemes: \");\n+            expectedSS.forEach(ss -> System.out.print(ss + \" \"));\n+            System.out.println();\n+            System.out.print(\"Actual SigSchemes: \");\n+            actualSS.forEach(ss -> System.out.print(ss + \" \"));\n+            System.out.println();\n+            throw new RuntimeException(\n+                    \"FAIL: Expected and Actual values differ.\");\n+        }\n+\n+        \/\/ Consume the ClientHello and get the server flight of handshake\n+        \/\/ messages.  We expect that it will be one TLS record containing\n+        \/\/ multiple handshake messages, one of which is a CertificateRequest.\n+        serverEngine.unwrap(cTOs, serverIn);\n+        runDelegatedTasks(serverEngine);\n+\n+        \/\/ Wrap the server flight\n+        serverEngine.wrap(serverOut, sTOc);\n+        sTOc.flip();\n+\n+        actualSS = getSigSchemesCertReq(\n+                extractHandshakeMsg(sTOc, TLS_HS_CERT_REQ));\n+\n+        \/\/ Make sure the ordering is correct\n+        if (!expectedSS.equals(actualSS)) {\n+            System.out.println(\"FAIL: Mismatch between property ordering \" +\n+                    \"and CertificateRequest message\");\n+            System.out.print(\"Expected SigSchemes: \");\n+            expectedSS.forEach(ss -> System.out.print(ss + \" \"));\n+            System.out.println();\n+            System.out.print(\"Actual SigSchemes: \");\n+            actualSS.forEach(ss -> System.out.print(ss + \" \"));\n+            System.out.println();\n+            throw new RuntimeException(\n+                    \"FAIL: Expected and Actual values differ.\");\n+        }\n+    }\n+\n+    \/**\n+     * Given a TLS record containing one or more handshake messages, return\n+     * the specific handshake message as a ByteBuffer (a slice of the record)\n+     *\n+     * @param tlsRecord a ByteBuffer containing a TLS record.  It is assumed\n+     *      that the position of the ByteBuffer is on the first byte of the TLS\n+     *      record header.\n+     * @param hsMsgId the message identifier for the handshake message being\n+     *      sought.\n+     *\n+     * @return a ByteBuffer containing the TLS handshake message.  The position\n+     *      of the returned ByteBuffer will be on the first byte of the TLS\n+     *      handshake message data, immediately following the handshake header.\n+     *      If the message is not found, null will be returned.\n+     *\n+     * @throws SSLException if the incoming ByteBuffer does not contain a\n+     *      well-formed TLS message.\n+     *\/\n+    private static ByteBuffer extractHandshakeMsg(ByteBuffer tlsRecord,\n+            int hsMsgId) throws SSLException {\n+        Objects.requireNonNull(tlsRecord);\n+        tlsRecord.mark();\n+\n+        \/\/ Process the TLS record header\n+        int type = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n+        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n+\n+        \/\/ Simple sanity checks\n+        if (type != 22) {\n+            throw new SSLException(\"Not a handshake: Type = \" + type);\n+        } else if (recLen > tlsRecord.remaining()) {\n+            throw new SSLException(\"Incomplete record in buffer: \" +\n+                    \"Record length = \" + recLen + \", Remaining = \" +\n+                    tlsRecord.remaining());\n+        }\n+\n+        while (tlsRecord.hasRemaining()) {\n+            \/\/ Grab the handshake message header.\n+            int msgHdr = tlsRecord.getInt();\n+            int msgType = (msgHdr >> 24) & 0x000000FF;\n+            int msgLen = msgHdr & 0x00FFFFFF;\n+\n+            if (msgType == hsMsgId) {\n+                \/\/ Slice the buffer such that it contains the entire\n+                \/\/ handshake message (less the handshake header).\n+                ByteBuffer buf = tlsRecord.slice(tlsRecord.position(), msgLen);\n+                tlsRecord.reset();\n+                return buf;\n+            } else {\n+                \/\/ Skip to the next handshake message, if there is one\n+                tlsRecord.position(tlsRecord.position() + msgLen);\n+            }\n+        }\n+\n+        tlsRecord.reset();\n+        return null;\n+    }\n+\n+\n+    \/**\n+     * Parses the ClientHello message and extracts from it a list of\n+     * SignatureScheme values in string form.  It is assumed that the provided\n+     * ByteBuffer has its position set at the first byte of the ClientHello\n+     * message body (AFTER the handshake header) and contains the entire\n+     * hello message.  Upon successful completion of this method the ByteBuffer\n+     * will have its position reset to the initial offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data the ByteBuffer containing the ClientHello bytes\n+     *\n+     * @returns A List of the signature schemes in string form.  If no\n+     * signature_algorithms extension is present in the client hello then\n+     * an empty list will be returned.\n+     *\/\n+    private static List<String> getSigSchemesCliHello(ByteBuffer data) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Skip over the protocol version and client random\n+        data.position(data.position() + 34);\n+\n+        \/\/ Jump past the session ID (if there is one)\n+        int sessLen = Byte.toUnsignedInt(data.get());\n+        if (sessLen != 0) {\n+            data.position(data.position() + sessLen);\n+        }\n+\n+        \/\/ Jump past the cipher suites\n+        int csLen = Short.toUnsignedInt(data.getShort());\n+        if (csLen != 0) {\n+            data.position(data.position() + csLen);\n+        }\n+\n+        \/\/ ...and the compression\n+        int compLen = Byte.toUnsignedInt(data.get());\n+        if (compLen != 0) {\n+            data.position(data.position() + compLen);\n+        }\n+\n+        \/\/ Now for the fun part.  Go through the extensions and look\n+        \/\/ for the two status request exts.\n+        List<String> extSigAlgs = new ArrayList();\n+        int extsLen = Short.toUnsignedInt(data.getShort());\n+        while (data.hasRemaining()) {\n+            int extType = Short.toUnsignedInt(data.getShort());\n+            int extLen = Short.toUnsignedInt(data.getShort());\n+            if (extType == HELLO_EXT_SIG_ALGS) {\n+                \/\/ Start processing signature algorithms\n+                int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+                for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+                    String schemeName = sigSchemeMap.get(\n+                            Short.toUnsignedInt(data.getShort()));\n+                    if (schemeName != null) {\n+                        extSigAlgs.add(schemeName);\n+                    }\n+                }\n+            } else {\n+                \/\/ Not the extension we're looking for.  Skip past the\n+                \/\/ extension data\n+                data.position(data.position() + extLen);\n+            }\n+        }\n+\n+        \/\/ We should be at the end of the ClientHello\n+        data.reset();\n+        return extSigAlgs;\n+    }\n+\n+    \/**\n+     * Parses the CertificateRequest message and extracts from it a list of\n+     * SignatureScheme values in string form.  It is assumed that the provided\n+     * ByteBuffer has its position set at the first byte of the\n+     * CertificateRequest message body (AFTER the handshake header) and\n+     * contains the entire CR message.  Upon successful completion of this\n+     * method the ByteBuffer will have its position reset to the initial\n+     * offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data the ByteBuffer containing the CertificateRequest bytes\n+     *\n+     * @returns A List of the signature schemes in string form.  If no\n+     * signature_algorithms extension is present in the CertificateRequest\n+     * then an empty list will be returned.\n+     *\/\n+    private static List<String> getSigSchemesCertReq(ByteBuffer data) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Jump past the certificate types\n+        int certTypeLen = Byte.toUnsignedInt(data.get());\n+        if (certTypeLen != 0) {\n+            data.position(data.position() + certTypeLen);\n+        }\n+\n+        \/\/ Collect the SignatureAndHashAlgorithms\n+        List<String> extSigAlgs = new ArrayList();\n+        int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+        for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+            String schemeName = sigSchemeMap.get(\n+                    Short.toUnsignedInt(data.getShort()));\n+            if (schemeName != null) {\n+                extSigAlgs.add(schemeName);\n+            }\n+        }\n+\n+        data.reset();\n+        return extSigAlgs;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigSchemePropOrdering.java","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"}]}