{"files":[{"patch":"@@ -4226,2 +4226,2 @@\n-  nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site->field_addr(_vmdependencies_offset);\n-  volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site->field_addr(_last_cleanup_offset);\n+  nmethodBucket* volatile* vmdeps_addr = call_site->field_addr<nmethodBucket* volatile>(_vmdependencies_offset);\n+  volatile uint64_t* last_cleanup_addr = call_site->field_addr<volatile uint64_t>(_last_cleanup_offset);\n@@ -4285,1 +4285,1 @@\n-  return HeapAccess<MO_ACQUIRE>::load_at(loader, _loader_data_offset);\n+  return Atomic::load_acquire(loader->field_addr<ClassLoaderData*>(_loader_data_offset));\n@@ -4291,1 +4291,1 @@\n-  return HeapAccess<>::load_at(loader, _loader_data_offset);\n+  return *loader->field_addr<ClassLoaderData*>(_loader_data_offset);\n@@ -4297,1 +4297,1 @@\n-  HeapAccess<MO_RELEASE>::store_at(loader, _loader_data_offset, new_data);\n+  Atomic::release_store(loader->field_addr<ClassLoaderData*>(_loader_data_offset), new_data);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  return java_string->obj_field_addr<uint8_t>(_flags_offset);\n+  return java_string->field_addr<uint8_t>(_flags_offset);\n@@ -149,1 +149,1 @@\n-  return ref->obj_field_addr<HeapWord>(_referent_offset);\n+  return ref->field_addr<HeapWord>(_referent_offset);\n@@ -165,1 +165,1 @@\n-  return ref->obj_field_addr<HeapWord>(_next_offset);\n+  return ref->field_addr<HeapWord>(_next_offset);\n@@ -181,1 +181,1 @@\n-  return ref->obj_field_addr<HeapWord>(_discovered_offset);\n+  return ref->field_addr<HeapWord>(_discovered_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-      return HeapAccess<>::load_at(base, className::_##name##_offset);                                                    \\\n+      return *base->field_addr<jtypename>(className::_##name##_offset);                                                   \\\n@@ -240,1 +240,1 @@\n-      HeapAccess<>::store_at(base, _##name##_offset, x);                                                                  \\\n+      *base->field_addr<jtypename>(className::_##name##_offset) = x;                                                      \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  T* p         = (T*)obj->obj_field_addr<T>(map->offset());\n+  T* p         = obj->field_addr<T>(map->offset());\n@@ -97,1 +97,1 @@\n-  T* const start = (T*)obj->obj_field_addr<T>(map->offset());\n+  T* const start = obj->field_addr<T>(map->offset());\n@@ -108,1 +108,1 @@\n-  T* p   = (T*)obj->obj_field_addr<T>(map->offset());\n+  T* p   = obj->field_addr<T>(map->offset());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -182,2 +182,2 @@\n-address oopDesc::address_field(int offset) const                      { return HeapAccess<>::load_at(as_oop(), offset); }\n-address oopDesc::address_field_acquire(int offset) const              { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+address oopDesc::address_field(int offset) const                      { return *field_addr<address>(offset); }\n+address oopDesc::address_field_acquire(int offset) const              { return Atomic::load_acquire(field_addr<address>(offset)); }\n@@ -185,2 +185,2 @@\n-void oopDesc::address_field_put(int offset, address value)            { HeapAccess<>::store_at(as_oop(), offset, value); }\n-void oopDesc::release_address_field_put(int offset, address value)    { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+void oopDesc::address_field_put(int offset, address value)            { *field_addr<address>(offset) = value; }\n+void oopDesc::release_address_field_put(int offset, address value)    { Atomic::release_store(field_addr<address>(offset), value); }\n@@ -188,2 +188,2 @@\n-Metadata* oopDesc::metadata_field(int offset) const                   { return HeapAccess<>::load_at(as_oop(), offset); }\n-void oopDesc::metadata_field_put(int offset, Metadata* value)         { HeapAccess<>::store_at(as_oop(), offset, value); }\n+Metadata* oopDesc::metadata_field(int offset) const                   { return *field_addr<Metadata*>(offset); }\n+void oopDesc::metadata_field_put(int offset, Metadata* value)         { *field_addr<Metadata*>(offset) = value; }\n@@ -191,2 +191,2 @@\n-Metadata* oopDesc::metadata_field_acquire(int offset) const           { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_metadata_field_put(int offset, Metadata* value) { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+Metadata* oopDesc::metadata_field_acquire(int offset) const           { return Atomic::load_acquire(field_addr<Metadata*>(offset)); }\n+void oopDesc::release_metadata_field_put(int offset, Metadata* value) { Atomic::release_store(field_addr<Metadata*>(offset), value); }\n@@ -194,2 +194,2 @@\n-jbyte oopDesc::byte_field_acquire(int offset) const                   { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_byte_field_put(int offset, jbyte value)         { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jbyte oopDesc::byte_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jbyte>(offset)); }\n+void oopDesc::release_byte_field_put(int offset, jbyte value)         { Atomic::release_store(field_addr<jbyte>(offset), value); }\n@@ -197,2 +197,2 @@\n-jchar oopDesc::char_field_acquire(int offset) const                   { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_char_field_put(int offset, jchar value)         { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jchar oopDesc::char_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jchar>(offset)); }\n+void oopDesc::release_char_field_put(int offset, jchar value)         { Atomic::release_store(field_addr<jchar>(offset), value); }\n@@ -200,2 +200,2 @@\n-jboolean oopDesc::bool_field_acquire(int offset) const                { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_bool_field_put(int offset, jboolean value)      { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, jboolean(value & 1)); }\n+jboolean oopDesc::bool_field_acquire(int offset) const                { return Atomic::load_acquire(field_addr<jboolean>(offset)); }\n+void oopDesc::release_bool_field_put(int offset, jboolean value)      { Atomic::release_store(field_addr<jboolean>(offset), jboolean(value & 1)); }\n@@ -203,2 +203,2 @@\n-jint oopDesc::int_field_acquire(int offset) const                     { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_int_field_put(int offset, jint value)           { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jint oopDesc::int_field_acquire(int offset) const                     { return Atomic::load_acquire(field_addr<jint>(offset)); }\n+void oopDesc::release_int_field_put(int offset, jint value)           { Atomic::release_store(field_addr<jint>(offset), value); }\n@@ -206,2 +206,2 @@\n-jshort oopDesc::short_field_acquire(int offset) const                 { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_short_field_put(int offset, jshort value)       { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jshort oopDesc::short_field_acquire(int offset) const                 { return Atomic::load_acquire(field_addr<jshort>(offset)); }\n+void oopDesc::release_short_field_put(int offset, jshort value)       { Atomic::release_store(field_addr<jshort>(offset), value); }\n@@ -209,2 +209,2 @@\n-jlong oopDesc::long_field_acquire(int offset) const                   { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_long_field_put(int offset, jlong value)         { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jlong oopDesc::long_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jlong>(offset)); }\n+void oopDesc::release_long_field_put(int offset, jlong value)         { Atomic::release_store(field_addr<jlong>(offset), value); }\n@@ -212,2 +212,2 @@\n-jfloat oopDesc::float_field_acquire(int offset) const                 { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_float_field_put(int offset, jfloat value)       { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jfloat oopDesc::float_field_acquire(int offset) const                 { return Atomic::load_acquire(field_addr<jfloat>(offset)); }\n+void oopDesc::release_float_field_put(int offset, jfloat value)       { Atomic::release_store(field_addr<jfloat>(offset), value); }\n@@ -215,2 +215,2 @@\n-jdouble oopDesc::double_field_acquire(int offset) const               { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_double_field_put(int offset, jdouble value)     { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jdouble oopDesc::double_field_acquire(int offset) const               { return Atomic::load_acquire(field_addr<jdouble>(offset)); }\n+void oopDesc::release_double_field_put(int offset, jdouble value)     { Atomic::release_store(field_addr<jdouble>(offset), value); }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -118,5 +118,2 @@\n-  \/\/ field addresses in oop\n-  inline void* field_addr(int offset) const;\n-\n-  \/\/ Need this as public for garbage collection.\n-  template <class T> inline T* obj_field_addr(int offset) const;\n+  template<typename T>\n+  inline T* field_addr(int offset) const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -211,4 +211,2 @@\n-void*    oopDesc::field_addr(int offset)     const { return reinterpret_cast<void*>(cast_from_oop<intptr_t>(as_oop()) + offset); }\n-\n-template <class T>\n-T*       oopDesc::obj_field_addr(int offset) const { return (T*) field_addr(offset); }\n+template<typename T>\n+T*       oopDesc::field_addr(int offset)     const { return reinterpret_cast<T*>(cast_from_oop<intptr_t>(as_oop()) + offset); }\n@@ -225,2 +223,2 @@\n-inline jbyte oopDesc::byte_field(int offset) const                  { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jbyte oopDesc::byte_field(int offset) const                  { return *field_addr<jbyte>(offset);  }\n+inline void  oopDesc::byte_field_put(int offset, jbyte value)       { *field_addr<jbyte>(offset) = value; }\n@@ -228,2 +226,2 @@\n-inline jchar oopDesc::char_field(int offset) const                  { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void  oopDesc::char_field_put(int offset, jchar value)       { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jchar oopDesc::char_field(int offset) const                  { return *field_addr<jchar>(offset);  }\n+inline void  oopDesc::char_field_put(int offset, jchar value)       { *field_addr<jchar>(offset) = value; }\n@@ -231,6 +229,6 @@\n-inline jboolean oopDesc::bool_field(int offset) const               { return HeapAccess<>::load_at(as_oop(), offset); }\n-inline void     oopDesc::bool_field_put(int offset, jboolean value) { HeapAccess<>::store_at(as_oop(), offset, jboolean(value & 1)); }\n-inline jboolean oopDesc::bool_field_volatile(int offset) const      { return HeapAccess<MO_SEQ_CST>::load_at(as_oop(), offset); }\n-inline void     oopDesc::bool_field_put_volatile(int offset, jboolean value) { HeapAccess<MO_SEQ_CST>::store_at(as_oop(), offset, jboolean(value & 1)); }\n-inline jshort oopDesc::short_field(int offset) const                { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void   oopDesc::short_field_put(int offset, jshort value)    { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jboolean oopDesc::bool_field(int offset) const               { return *field_addr<jboolean>(offset); }\n+inline void     oopDesc::bool_field_put(int offset, jboolean value) { *field_addr<jboolean>(offset) = jboolean(value & 1); }\n+inline jboolean oopDesc::bool_field_volatile(int offset) const      { return RawAccess<MO_SEQ_CST>::load(field_addr<jboolean>(offset)); }\n+inline void     oopDesc::bool_field_put_volatile(int offset, jboolean value) { RawAccess<MO_SEQ_CST>::store(field_addr<jboolean>(offset), jboolean(value & 1)); }\n+inline jshort oopDesc::short_field(int offset) const                { return *field_addr<jshort>(offset);   }\n+inline void   oopDesc::short_field_put(int offset, jshort value)    { *field_addr<jshort>(offset) = value;  }\n@@ -238,2 +236,2 @@\n-inline jint oopDesc::int_field(int offset) const                    { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void oopDesc::int_field_put(int offset, jint value)          { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jint oopDesc::int_field(int offset) const                    { return *field_addr<jint>(offset);     }\n+inline void oopDesc::int_field_put(int offset, jint value)          { *field_addr<jint>(offset) = value;    }\n@@ -241,2 +239,2 @@\n-inline jlong oopDesc::long_field(int offset) const                  { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void  oopDesc::long_field_put(int offset, jlong value)       { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jlong oopDesc::long_field(int offset) const                  { return *field_addr<jlong>(offset);    }\n+inline void  oopDesc::long_field_put(int offset, jlong value)       { *field_addr<jlong>(offset) = value;   }\n@@ -244,2 +242,2 @@\n-inline jfloat oopDesc::float_field(int offset) const                { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void   oopDesc::float_field_put(int offset, jfloat value)    { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jfloat oopDesc::float_field(int offset) const                { return *field_addr<jfloat>(offset);   }\n+inline void   oopDesc::float_field_put(int offset, jfloat value)    { *field_addr<jfloat>(offset) = value;  }\n@@ -247,2 +245,2 @@\n-inline jdouble oopDesc::double_field(int offset) const              { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void    oopDesc::double_field_put(int offset, jdouble value) { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jdouble oopDesc::double_field(int offset) const              { return *field_addr<jdouble>(offset);  }\n+inline void    oopDesc::double_field_put(int offset, jdouble value) { *field_addr<jdouble>(offset) = value; }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -93,3 +93,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jbyte>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *byte_at_addr(which);\n@@ -98,3 +96,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jbyte>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *byte_at_addr(which) = contents;\n@@ -104,3 +100,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jboolean>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *bool_at_addr(which);\n@@ -109,3 +103,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jboolean>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, jboolean(contents & 1));\n+  *bool_at_addr(which) = jboolean(contents & 1);\n@@ -115,3 +107,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jchar>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *char_at_addr(which);\n@@ -120,3 +110,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jchar>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *char_at_addr(which) = contents;\n@@ -126,3 +114,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jint>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *int_at_addr(which);\n@@ -131,3 +117,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jint>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *int_at_addr(which) = contents;\n@@ -137,3 +121,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jshort>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *short_at_addr(which);\n@@ -142,3 +124,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jshort>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *short_at_addr(which) = contents;\n@@ -148,3 +128,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jushort>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *ushort_at_addr(which);\n@@ -152,0 +130,1 @@\n+\n@@ -153,3 +132,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jushort>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *ushort_at_addr(which) = contents;\n@@ -159,3 +136,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jlong>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *long_at_addr(which);\n@@ -164,3 +139,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jlong>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *long_at_addr(which) = contents;\n@@ -170,3 +143,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jfloat>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *float_at_addr(which);\n@@ -174,0 +145,1 @@\n+\n@@ -175,3 +147,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jfloat>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *float_at_addr(which) = contents;\n@@ -181,3 +151,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jdouble>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *double_at_addr(which);\n@@ -185,0 +153,1 @@\n+\n@@ -186,3 +155,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jdouble>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *double_at_addr(which) = contents;\n@@ -192,3 +159,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jbyte>(which);\n-  return HeapAccess<MO_ACQUIRE | IS_ARRAY>::load_at(as_oop(), offset);\n+  return Atomic::load_acquire(byte_at_addr(which));\n@@ -197,3 +162,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jbyte>(which);\n-  HeapAccess<MO_RELEASE | IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  Atomic::release_store(byte_at_addr(which), contents);\n@@ -207,3 +170,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jlong>(which);\n-  return (Symbol*)(jlong) HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *reinterpret_cast<Symbol**>(long_at_addr(which));\n@@ -211,0 +172,1 @@\n+\n@@ -212,3 +174,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jlong>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, (jlong)contents);\n+  *reinterpret_cast<Symbol**>(long_at_addr(which)) = contents;\n@@ -218,3 +178,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jint>(which);\n-  return (Symbol*)(jint) HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *reinterpret_cast<Symbol**>(int_at_addr(which));\n@@ -223,3 +181,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jint>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, (jint)contents);\n+  *reinterpret_cast<Symbol**>(int_at_addr(which)) = contents;\n","filename":"src\/hotspot\/share\/oops\/typeArrayOop.inline.hpp","additions":28,"deletions":72,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-      assert(p->field_addr((jint)byte_offset) == ptr_plus_disp,\n+      assert(p->field_addr<void>((jint)byte_offset) == ptr_plus_disp,\n@@ -221,8 +221,2 @@\n-    if (_obj == NULL) {\n-      GuardUnsafeAccess guard(_thread);\n-      T ret = RawAccess<>::load(addr());\n-      return normalize_for_read(ret);\n-    } else {\n-      T ret = HeapAccess<>::load_at(_obj, _offset);\n-      return normalize_for_read(ret);\n-    }\n+    GuardUnsafeAccess guard(_thread);\n+    return normalize_for_read(*addr());\n@@ -232,6 +226,2 @@\n-    if (_obj == NULL) {\n-      GuardUnsafeAccess guard(_thread);\n-      RawAccess<>::store(addr(), normalize_for_write(x));\n-    } else {\n-      HeapAccess<>::store_at(_obj, _offset, normalize_for_write(x));\n-    }\n+    GuardUnsafeAccess guard(_thread);\n+    *addr() = normalize_for_write(x);\n@@ -242,8 +232,3 @@\n-    if (_obj == NULL) {\n-      GuardUnsafeAccess guard(_thread);\n-      volatile T ret = RawAccess<MO_SEQ_CST>::load(addr());\n-      return normalize_for_read(ret);\n-    } else {\n-      T ret = HeapAccess<MO_SEQ_CST>::load_at(_obj, _offset);\n-      return normalize_for_read(ret);\n-    }\n+    GuardUnsafeAccess guard(_thread);\n+    volatile T ret = RawAccess<MO_SEQ_CST>::load(addr());\n+    return normalize_for_read(ret);\n@@ -253,6 +238,2 @@\n-    if (_obj == NULL) {\n-      GuardUnsafeAccess guard(_thread);\n-      RawAccess<MO_SEQ_CST>::store(addr(), normalize_for_write(x));\n-    } else {\n-      HeapAccess<MO_SEQ_CST>::store_at(_obj, _offset, normalize_for_write(x));\n-    }\n+    GuardUnsafeAccess guard(_thread);\n+    RawAccess<MO_SEQ_CST>::store(addr(), normalize_for_write(x));\n@@ -748,7 +729,2 @@\n-  if (p == NULL) {\n-    volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n-    return RawAccess<>::atomic_cmpxchg(addr, e, x);\n-  } else {\n-    assert_field_offset_sane(p, offset);\n-    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);\n-  }\n+  volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n+  return Atomic::cmpxchg(addr, e, x);\n@@ -759,7 +735,2 @@\n-  if (p == NULL) {\n-    volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n-    return RawAccess<>::atomic_cmpxchg(addr, e, x);\n-  } else {\n-    assert_field_offset_sane(p, offset);\n-    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);\n-  }\n+  volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n+  return Atomic::cmpxchg(addr, e, x);\n@@ -779,7 +750,2 @@\n-  if (p == NULL) {\n-    volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n-    return RawAccess<>::atomic_cmpxchg(addr, e, x) == e;\n-  } else {\n-    assert_field_offset_sane(p, offset);\n-    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;\n-  }\n+  volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n+  return Atomic::cmpxchg(addr, e, x) == e;\n@@ -790,7 +756,2 @@\n-  if (p == NULL) {\n-    volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n-    return RawAccess<>::atomic_cmpxchg(addr, e, x) == e;\n-  } else {\n-    assert_field_offset_sane(p, offset);\n-    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;\n-  }\n+  volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n+  return Atomic::cmpxchg(addr, e, x) == e;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":18,"deletions":57,"binary":false,"changes":75,"status":"modified"}]}