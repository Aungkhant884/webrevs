{"files":[{"patch":"@@ -770,0 +770,15 @@\n+\/\/ Returns true if a path within the paths exists and has non-zero size.\n+bool FileMapInfo::check_paths_existence(const char* paths) {\n+  ClasspathStream cp_stream(paths);\n+  bool exist = false;\n+  struct stat st;\n+  while (cp_stream.has_next()) {\n+    const char* path = cp_stream.get_next();\n+    if (os::stat(path, &st) == 0 && st.st_size > 0) {\n+      exist = true;\n+      break;\n+    }\n+  }\n+  return exist;\n+}\n+\n@@ -853,1 +868,6 @@\n-      mismatch = true;\n+      ResourceMark rm;\n+      if (check_paths_existence(rp)) {\n+        \/\/ If a path exists in the runtime boot paths, it is considered a mismatch\n+        \/\/ since there's no boot path specified during dump time.\n+        mismatch = true;\n+      }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -557,0 +557,1 @@\n+  bool  check_paths_existence(const char* paths) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,7 @@\n+    static final String outDir = CDSTestUtils.getOutputDir();\n+    static final String newFile = \"non-exist.jar\";\n+    static final String nonExistPath = outDir + File.separator + newFile;\n+    static final String emptyJarPath = outDir + File.separator + \"empty.jar\";\n+    static final String errorMessage1 = \"Unable to use shared archive\";\n+    static final String errorMessage2 = \"shared class paths mismatch\";\n+\n@@ -50,5 +57,0 @@\n-        String outDir = CDSTestUtils.getOutputDir();\n-        String newFile = \"non-exist.jar\";\n-        String nonExistPath = outDir + File.separator + newFile;\n-        final String errorMessage1 = \"Unable to use shared archive\";\n-        final String errorMessage2 = \"shared class paths mismatch\";\n@@ -56,1 +58,0 @@\n-\n@@ -103,0 +104,75 @@\n+\n+        if (bootcp) {\n+            doMoreBCPTests(appJar, errorMessage3);\n+        }\n+    }\n+\n+    static void doMoreBCPTests(String appJar, String errorMessage3) throws Exception {\n+\n+        \/\/ Dump an archive with non-existent boot class path.\n+        (new File(nonExistPath)).delete();\n+        TestCommon.testDump(\"foobar\", TestCommon.list(\"Hello\"), make_args(true, nonExistPath, \"-cp\", appJar));\n+\n+        \/\/ Run with non-existent boot class path, test should pass.\n+        TestCommon.run(make_args(true,\n+                                 nonExistPath,\n+                                 \"-cp\", appJar,\n+                                 \"-Xlog:class+path=trace\",\n+                                 \"Hello\"))\n+            .assertNormalExit();\n+\n+        \/\/ Run with existent boot class path, test should fail.\n+        TestCommon.run(make_args(true,\n+                                 appJar,\n+                                 \"-cp\", appJar,\n+                                 \"-Xlog:class+path=trace\",\n+                                 \"Hello\"))\n+            .assertAbnormalExit(errorMessage1, errorMessage2, errorMessage3);\n+\n+        \/\/ Dump an archive with existent boot class path.\n+        TestCommon.testDump(\"foobar\", TestCommon.list(\"Hello\"), make_args(true, appJar));\n+\n+        \/\/ Run with non-existent boot class path, test should fail.\n+        TestCommon.run(make_args(true,\n+                                 nonExistPath,\n+                                 \"-Xlog:class+path=trace\",\n+                                 \"Hello\"))\n+            .assertAbnormalExit(errorMessage1, errorMessage2, errorMessage3);\n+\n+        \/\/ Run with existent boot class path, test should pass.\n+        TestCommon.run(make_args(true,\n+                                 appJar,\n+                                 \"-Xlog:class+path=trace\",\n+                                 \"Hello\"))\n+            .assertNormalExit();\n+\n+        \/\/ Test with empty jar file.\n+        (new File(emptyJarPath)).delete();\n+        (new File(emptyJarPath)).createNewFile();\n+\n+        \/\/ Dump an archive with an empty jar in the boot class path.\n+        TestCommon.testDump(\"foobar\", TestCommon.list(\"Hello\"), make_args(true, emptyJarPath, \"-cp\", appJar));\n+\n+        \/\/ Run with an empty jar in boot class path, test should pass.\n+        TestCommon.run(make_args(true,\n+                                 emptyJarPath,\n+                                 \"-cp\", appJar,\n+                                 \"-Xlog:class+path=trace\",\n+                                 \"Hello\"))\n+            .assertNormalExit();\n+\n+        \/\/ Run with non-existent boot class path, test should pass.\n+        TestCommon.run(make_args(true,\n+                                 nonExistPath,\n+                                 \"-cp\", appJar,\n+                                 \"-Xlog:class+path=trace\",\n+                                 \"Hello\"))\n+            .assertNormalExit();\n+\n+        \/\/ Run with existent boot class path, test should fail.\n+        TestCommon.run(make_args(true,\n+                                 appJar,\n+                                 \"-cp\", appJar,\n+                                 \"-Xlog:class+path=trace\",\n+                                 \"Hello\"))\n+            .assertAbnormalExit(errorMessage1, errorMessage2, errorMessage3);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/NonExistClasspath.java","additions":83,"deletions":7,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,3 +90,1 @@\n-    log(\"Execution with simple errors -- with 'simple' errors like missing or modified\\n\" +\n-        \"JAR files, the VM should try to continue to print the remaining information.\\n\" +\n-        \"Use an invalid Boot CP -- all the JAR paths should be checked\");\n+    log(\"Non-existent boot cp should be ignored, test should pass.\");\n@@ -97,1 +95,1 @@\n-      .ifNoMappingFailure(output -> check(output, 1, true, lastCheckMsg, \"[BOOT classpath mismatch, \"));\n+      .ifNoMappingFailure(output -> check(output, 0, true, lastCheckMsg));\n@@ -99,1 +97,3 @@\n-    log(\"Use an App CP shorter than the one at dump time -- all the JAR paths should be checked\");\n+    log(\"Execution with simple errors -- with 'simple' errors like missing or modified\\n\" +\n+        \"JAR files, the VM should try to continue to print the remaining information.\\n\" +\n+        \"Use an App CP shorter than the one at dump time -- all the JAR paths should be checked\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/PrintSharedArchiveAndExit.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,0 +222,10 @@\n+            .assertAbnormalExit(out -> {\n+                out.shouldNotContain(CLASS_FOUND_MESSAGE)\n+                   .shouldContain(OPTIMIZE_DISABLED)           \/\/ mapping info\n+                   .shouldContain(\"Error: Could not find or load main class .\");\n+            });\n+        tty(\"11. run with CDS on, --module-path, with -Xbootclasspath\/a:.\");\n+        TestCommon.run(\"-Xlog:cds\",\n+                       \"-Xbootclasspath\/a:.\",\n+                       \"--module-path\", libsDir.toString(),\n+                       MAIN_CLASS)\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"}]}