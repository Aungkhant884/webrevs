{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n- * @LastModified: Nov 2017\n+ * @LastModified: May 2022\n@@ -382,5 +382,1 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n-    this.addElement(n);\n+    addElement(n);\n@@ -400,4 +396,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -416,5 +408,1 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n-    this.removeElement(n);\n+    removeElement(n);\n@@ -434,4 +422,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -474,4 +458,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -491,4 +471,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -519,4 +495,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -547,4 +519,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -575,4 +543,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -635,4 +599,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -709,4 +669,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -770,3 +726,0 @@\n-  \/** True if this list can be mutated.  *\/\n-  transient protected boolean m_mutable = true;\n-\n@@ -807,1 +760,0 @@\n-    m_mutable = true;\n@@ -878,3 +830,0 @@\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -1105,3 +1054,0 @@\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -1198,3 +1144,0 @@\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n@@ -1261,3 +1204,0 @@\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); \/\/\"This NodeSet is not mutable!\");\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/NodeSet.java","additions":4,"deletions":64,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +59,1 @@\n+ * @LastModified: May 2022\n@@ -539,5 +539,1 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n-    this.addElement(n);\n+    addElement(n);\n@@ -557,4 +553,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -573,4 +565,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -650,4 +638,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -707,4 +691,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -796,4 +776,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -871,4 +847,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -897,4 +869,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -917,4 +885,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -933,4 +897,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -950,4 +910,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -972,4 +928,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -991,4 +943,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -1012,4 +960,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -1029,4 +973,0 @@\n-\n-    if (!m_mutable)\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); \/\/\"This NodeSetDTM is not mutable!\");\n-\n@@ -1160,3 +1100,0 @@\n-  \/** True if this list can be mutated.  *\/\n-  transient protected boolean m_mutable = true;\n-\n@@ -1200,1 +1137,0 @@\n-    m_mutable = true;\n@@ -1211,1 +1147,1 @@\n-    return m_mutable;\n+    return true;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/NodeSetDTM.java","additions":4,"deletions":68,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @LastModified: Jan 2022\n+ * @LastModified: May 2022\n@@ -211,1 +211,1 @@\n-      throw new RuntimeException(XSLMessages.createXPATHMessage(\n+      throw new TransformerException(XSLMessages.createXPATHMessage(\n@@ -214,1 +214,0 @@\n-            \/\/\"Can not deal with XPath type: \" + type);\n@@ -216,5 +215,1 @@\n-    \/\/ System.out.println(\"----------------\");\n-    Expression expr = compiler.compileExpression(0);\n-\n-    \/\/ System.out.println(\"expr: \"+expr);\n-    this.setExpression(expr);\n+    m_mainExp = compiler.compileExpression(0);\n@@ -224,1 +219,1 @@\n-        expr.exprSetParent((ExpressionNode)locator);\n+        m_mainExp.exprSetParent((ExpressionNode)locator);\n@@ -226,1 +221,0 @@\n-\n@@ -277,1 +271,1 @@\n-    this.setExpression(expr);\n+    m_mainExp = expr;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/XPath.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.org.apache.xml.internal.utils.WrappedRuntimeException;\n@@ -37,1 +38,1 @@\n- * @LastModified: May 2020\n+ * @LastModified: May 2022\n@@ -494,3 +495,2 @@\n-\n-      \/\/ TODO: Fix this.\n-      throw new RuntimeException(se.getMessage());\n+      \/\/ the Xalan\/XPath impl use WrappedRuntimeException to carry errors over\n+      throw new WrappedRuntimeException(se);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/axes\/PredicatedNodeTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @LastModified: Apr 2022\n+ * @LastModified: May 2022\n@@ -82,0 +82,10 @@\n+  \/\/ Union operands must be node-sets, e.g. \/\/a | \/\/b\n+  \/\/ A flag indicating whether the operand is a location path\n+  boolean isLocationPath = false;\n+\n+  \/\/ A flag indicating whether the next operand is required to be a location path\n+  boolean lPathRequired = false;\n+\n+  \/\/ Keep track of the status of reading the next token after lPathRequired is flagged\n+  boolean nextTokenRead = false;\n+\n@@ -437,1 +447,1 @@\n-  private final void nextToken()\n+  private final void nextToken() throws TransformerException\n@@ -439,1 +449,11 @@\n-\n+    \/\/ before reading another token, check the last one\n+    if (lPathRequired) {\n+        if (nextTokenRead) {\n+            \/\/ check whether the operand behind the union was a Location path\n+            checkNodeSet();\n+            lPathRequired = false;\n+            nextTokenRead = false;\n+        } else {\n+            nextTokenRead = true;\n+        }\n+    }\n@@ -500,6 +520,5 @@\n-   * Consume an expected token, throwing an exception if it\n-   * isn't there.\n-   *\n-   * @param expected The string to be expected.\n-   *\n-   * @throws TransformerException\n+   * Checks whether the function token represents a function that returns a\n+   * nodeset.\n+   * @param funcTok the function token\n+   * @return true if the function token represents a function that returns a\n+   * nodeset, false otherwise\n@@ -507,3 +526,4 @@\n-  private final void consumeExpected(String expected)\n-          throws TransformerException\n-  {\n+  private boolean isNodesetFunction(int funcTok) {\n+      return (funcTok == FunctionTable.FUNC_CURRENT || funcTok == FunctionTable.FUNC_HERE\n+              || funcTok == FunctionTable.FUNC_ID);\n+  }\n@@ -511,1 +531,7 @@\n-    if (tokenIs(expected))\n+  \/**\n+   * Checks whether the operand is a location path, reports error if not.\n+   *\n+   * @throws TransformerException if an error is found\n+   *\/\n+  private void checkNodeSet() throws TransformerException {\n+    if (!isLocationPath)\n@@ -513,1 +539,2 @@\n-      nextToken();\n+      error(XPATHErrorResources.ER_UNION_MUST_BE_NODESET,\n+            new Object[]{});\n@@ -515,10 +542,0 @@\n-    else\n-    {\n-      error(XPATHErrorResources.ER_EXPECTED_BUT_FOUND, new Object[]{ expected,\n-                                                                     m_token });  \/\/\"Expected \"+expected+\", but found: \"+m_token);\n-\n-          \/\/ Patch for Christina's gripe. She wants her errorHandler to return from\n-          \/\/ this error and continue trying to parse, rather than throwing an exception.\n-          \/\/ Without the patch, that put us into an endless loop.\n-                throw new XPathProcessorException(CONTINUE_AFTER_FATAL_ERROR);\n-        }\n@@ -1212,0 +1229,3 @@\n+        \/\/ check whether the operand before the union is a location path\n+        checkNodeSet();\n+\n@@ -1215,1 +1235,0 @@\n-\n@@ -1219,0 +1238,2 @@\n+        isLocationPath = false;\n+        lPathRequired = true;\n@@ -1467,1 +1488,1 @@\n-      consumeExpected(':');\n+      consumeExpected(Token.COLON);\n@@ -1497,0 +1518,4 @@\n+      \/\/ XML Signature here() function returns a node-set\n+      if (isNodesetFunction(funcTok)) {\n+          isLocationPath = true;\n+      }\n@@ -1547,1 +1572,1 @@\n-\n+    isLocationPath = true;\n@@ -1864,1 +1889,1 @@\n-        consumeExpected(':');\n+        consumeExpected(Token.COLON);\n@@ -1911,1 +1936,1 @@\n-      consumeExpected(']');\n+      consumeExpected(Token.RBRACK);\n@@ -1953,1 +1978,1 @@\n-      consumeExpected(':');\n+      consumeExpected(Token.COLON);\n@@ -1972,1 +1997,1 @@\n-  protected void NCName()\n+  protected void NCName() throws TransformerException\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/compiler\/XPathParser.java","additions":56,"deletions":31,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import javax.xml.transform.TransformerException;\n@@ -43,1 +44,1 @@\n- * @LastModified: Oct 2017\n+ * @LastModified: May 2022\n@@ -186,2 +187,1 @@\n-  public XObject execute(XPathContext xctxt)\n-          throws javax.xml.transform.TransformerException\n+  public XObject execute(XPathContext xctxt) throws TransformerException\n@@ -212,0 +212,6 @@\n+    if (extProvider == null) {\n+        String fmsg = XSLMessages.createXPATHMessage(\n+            XPATHErrorResources.ER_NO_XPATH_FUNCTION_PROVIDER,\n+            new Object[] {argVec} );\n+        throw new TransformerException ( fmsg );\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/functions\/FuncExtFunction.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +40,1 @@\n+ * @LastModified: May 2022\n@@ -64,0 +64,7 @@\n+\n+        if (resolver == null) {\n+            String fmsg = XSLMessages.createXPATHMessage(\n+                XPATHErrorResources.ER_NO_XPATH_VARIABLE_RESOLVER,\n+                new Object[] { name.toString()} );\n+            throw new TransformerException( fmsg );\n+        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/JAXPVariableStack.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import com.sun.org.apache.xml.internal.utils.WrappedRuntimeException;\n@@ -30,0 +31,1 @@\n+import javax.xml.xpath.XPathFunctionException;\n@@ -40,1 +42,1 @@\n- * @LastModified: Apr 2022\n+ * @LastModified: May 2022\n@@ -80,1 +82,1 @@\n-            throws javax.xml.transform.TransformerException {\n+            throws TransformerException {\n@@ -91,6 +93,1 @@\n-        } catch (java.lang.NullPointerException npe) {\n-            \/\/ If VariableResolver returns null Or if we get\n-            \/\/ NullPointerException at this stage for some other reason\n-            \/\/ then we have to reurn XPathException\n-            throw new XPathExpressionException (npe);\n-        } catch (javax.xml.transform.TransformerException te) {\n+        } catch (TransformerException te) {\n@@ -98,2 +95,2 @@\n-            if (nestedException instanceof javax.xml.xpath.XPathFunctionException) {\n-                throw (javax.xml.xpath.XPathFunctionException)nestedException;\n+            if (nestedException instanceof XPathFunctionException) {\n+                throw (XPathFunctionException)nestedException;\n@@ -105,0 +102,5 @@\n+        } catch (RuntimeException re) {\n+            if (re instanceof WrappedRuntimeException) {\n+                throw new XPathExpressionException(((WrappedRuntimeException)re).getException());\n+            }\n+            throw new XPathExpressionException(re);\n@@ -118,0 +120,1 @@\n+        requireNonNull(source, \"Source\");\n@@ -124,0 +127,5 @@\n+        } catch (RuntimeException re) {\n+            if (re instanceof WrappedRuntimeException) {\n+                throw new XPathExpressionException(((WrappedRuntimeException)re).getException());\n+            }\n+            throw new XPathExpressionException(re);\n@@ -146,1 +154,1 @@\n-        } catch (javax.xml.transform.TransformerException te) {\n+        } catch (TransformerException te) {\n@@ -148,0 +156,5 @@\n+        } catch (RuntimeException re) {\n+            if (re instanceof WrappedRuntimeException) {\n+                throw new XPathExpressionException(((WrappedRuntimeException)re).getException());\n+            }\n+            throw new XPathExpressionException(re);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/XPathExpressionImpl.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import com.sun.org.apache.xml.internal.utils.WrappedRuntimeException;\n@@ -50,1 +51,1 @@\n- * @LastModified: Jan 2022\n+ * @LastModified: May 2022\n@@ -137,5 +138,0 @@\n-        } catch (java.lang.NullPointerException npe) {\n-            \/\/ If VariableResolver returns null Or if we get\n-            \/\/ NullPointerException at this stage for some other reason\n-            \/\/ then we have to reurn XPathException\n-            throw new XPathExpressionException (npe);\n@@ -149,1 +145,1 @@\n-                throw new XPathExpressionException (te);\n+                throw new XPathExpressionException(te);\n@@ -151,0 +147,5 @@\n+        } catch (RuntimeException re) {\n+            if (re instanceof WrappedRuntimeException) {\n+                throw new XPathExpressionException(((WrappedRuntimeException)re).getException());\n+            }\n+            throw new XPathExpressionException(re);\n@@ -152,1 +153,0 @@\n-\n@@ -175,0 +175,5 @@\n+        } catch (RuntimeException re) {\n+            if (re instanceof WrappedRuntimeException) {\n+                throw new XPathExpressionException(((WrappedRuntimeException)re).getException());\n+            }\n+            throw new XPathExpressionException(re);\n@@ -181,14 +186,1 @@\n-        isSupported(returnType);\n-\n-        try {\n-            Document document = getDocument(source);\n-            XObject resultObject = eval(expression, document);\n-            return getResultAsType(resultObject, returnType);\n-        } catch (TransformerException te) {\n-            Throwable nestedException = te.getException();\n-            if (nestedException instanceof javax.xml.xpath.XPathFunctionException) {\n-                throw (javax.xml.xpath.XPathFunctionException)nestedException;\n-            } else {\n-                throw new XPathExpressionException (te);\n-            }\n-        }\n+        return evaluate(expression, getDocument(source), returnType);\n@@ -213,1 +205,2 @@\n-        isSupportedClassType(type);\n+         requireNonNull(expression, \"XPath expression\");\n+         isSupportedClassType(type);\n@@ -222,1 +215,6 @@\n-            throw new XPathExpressionException (te);\n+            throw new XPathExpressionException(te);\n+        } catch (RuntimeException re) {\n+            if (re instanceof WrappedRuntimeException) {\n+                throw new XPathExpressionException(((WrappedRuntimeException)re).getException());\n+            }\n+            throw new XPathExpressionException(re);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/XPathImpl.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @LastModified: Apr 2022\n+ * @LastModified: May 2022\n@@ -143,0 +143,1 @@\n+  public static final String ER_UNION_MUST_BE_NODESET = \"ER_UNION_MUST_BE_NODESET\";\n@@ -206,3 +207,0 @@\n-  public static final String ER_NODESET_NOT_MUTABLE = \"ER_NODESET_NOT_MUTABLE\";\n-  public static final String ER_NODESETDTM_NOT_MUTABLE =\n-         \"ER_NODESETDTM_NOT_MUTABLE\";\n@@ -312,0 +310,2 @@\n+  public static final String ER_NO_XPATH_VARIABLE_RESOLVER = \"ER_NO_XPATH_VARIABLE_RESOLVER\";\n+  public static final String ER_NO_XPATH_FUNCTION_PROVIDER = \"ER_NO_XPATH_FUNCTION_PROVIDER\";\n@@ -463,0 +463,3 @@\n+  { ER_UNION_MUST_BE_NODESET,\n+     \"Operands for a union must be node-sets.\"},\n+\n@@ -577,6 +580,0 @@\n-  { ER_NODESET_NOT_MUTABLE,\n-       \"This NodeSet is not mutable\"},\n-\n-  { ER_NODESETDTM_NOT_MUTABLE,\n-       \"This NodeSetDTM is not mutable\"},\n-\n@@ -783,0 +780,6 @@\n+  { ER_NO_XPATH_VARIABLE_RESOLVER,\n+       \"Attempting to resolve variable {0}, but a variable resolver is not set.\"},\n+\n+  { ER_NO_XPATH_FUNCTION_PROVIDER,\n+       \"Attempting to call an extension function {0}, but an extension provider is not set.\"},\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/res\/XPATHErrorResources.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import javax.xml.namespace.QName;\n@@ -29,0 +30,1 @@\n+import javax.xml.parsers.ParserConfigurationException;\n@@ -30,0 +32,5 @@\n+import static javax.xml.xpath.XPathConstants.BOOLEAN;\n+import static javax.xml.xpath.XPathConstants.NODE;\n+import static javax.xml.xpath.XPathConstants.NODESET;\n+import static javax.xml.xpath.XPathConstants.NUMBER;\n+import static javax.xml.xpath.XPathConstants.STRING;\n@@ -33,0 +40,1 @@\n+import javax.xml.xpath.XPathNodes;\n@@ -38,0 +46,1 @@\n+import org.xml.sax.InputSource;\n@@ -41,1 +50,1 @@\n- * @bug 8284548\n+ * @bug 8284400 8284548\n@@ -43,2 +52,6 @@\n- * @summary This is a general test for Exception handling. Additional cases may\n- * be added with a bug id in the test cases.\n+ * @summary This is a general test for Exception handling in XPath. This test\n+ * covers the followings:\n+ * NPE: refer to DataProvider NPE for more details.\n+ * IAE: covered by existing tests: Bug4991939, XPathAnyTypeTest, XPathExpAnyTypeTest\n+ *      and XPathTest\n+ * XPathExpressionException: all other cass other than NPE and IAE.\n@@ -47,0 +60,1 @@\n+    private final String XPATH_EXPRESSION = \"ext:helloWorld()\";\n@@ -49,2 +63,3 @@\n-     * DataProvider: invalid XPath expressions\n-     * Illegal expressions and structures that may escape the validation check.\n+     * DataProvider: used for NPE test, provides the following fields:\n+     *     expression, context, useSource, source, QName, class type, provided\n+     * Refer to testNPEWithEvaluate.\n@@ -52,2 +67,2 @@\n-    @DataProvider(name = \"invalid\")\n-    public Object[][] getInvalid() throws Exception {\n+    @DataProvider(name = \"NPE\")\n+    public Object[][] getNullParameter() throws Exception {\n@@ -55,0 +70,47 @@\n+            \/**\n+             * Existing NPE tests:\n+             *     for XPath::evaluate:\n+             *     Bug4992788: expression != null, source = null\n+             *     Bug4992793: expression = null, source != null\n+             *     Bug4992805: source != null, QName = null\n+             *\n+             *     for XPath::evaluateExpression\n+             *     XPathAnyTypeTest: expression = null or classType = null\n+            *\/\n+            \/\/ NPE if expression = null\n+            {null, (Node)null, false, null, STRING, String.class, true},\n+            {null, getDummyDoc(), false, null, STRING, String.class, true},\n+            {null, (Node)null, false, null, null, null, false},\n+            {null, getDummyDoc(), false, null, null, null, false},\n+            \/\/ NPE if returnType = null\n+            {\"exp\", (Node)null, false, null, null, null, true},\n+            {\"exp\", getDummyDoc(), false, null, null, null, true},\n+            \/\/ NPE if source = null\n+            {\"exp\", (Node)null, true, null, STRING, String.class, true},\n+            {\"exp\", getDummyDoc(), true, null, STRING, String.class, true},\n+            {\"exp\", (Node)null, true, null, null, null, false},\n+            {\"exp\", getDummyDoc(), true, null, null, null, false},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: used for compile-time error test, provides:\n+     *     invalid XPath expressions\n+     *\/\n+    @DataProvider(name = \"invalidExp\")\n+    public Object[][] getInvalidExp() throws Exception {\n+        return new Object[][]{\n+            {\"8|b\"},\n+            {\"8[x=2]|b\"},\n+            {\"8\/a|b\"},\n+            {\"a|7\"},\n+            {\"a|7|b\"},\n+            {\"a|7[x=2]\"},\n+            {\"b|'literal'\"},\n+            {\"b|\\\"literal\\\"\"},\n+            {\"a|$x:y\"},\n+            {\"a|(x or y)\"},\n+            {\"a|(x and y)\"},\n+            {\"a|(x=2)\"},\n+            {\"a|string-length(\\\"xy\\\")\"},\n+            {\"\/a\/b\/preceding-sibling::comment()|7\"},\n@@ -64,0 +126,61 @@\n+    \/*\n+     * DataProvider: expressions that cause exceptions in the given context.\n+     *\/\n+    @DataProvider(name = \"expInContext1\")\n+    public Object[][] getExpressionAndContext1() throws Exception {\n+        InputSource source = new InputSource(new StringReader(\"<A\/>\"));\n+        return new Object[][]{\n+\n+            \/\/ expressions invalid for the null context, return type not provided\n+            {\"x+1\", (Node)null, false, null, null, null, false},\n+            {\"5 mod a\", (Node)null, false, null, null, null, false},\n+            {\"8 div \", (Node)null, false, null, null, null, false},\n+            {\"\/bookstore\/book[price>xx]\", (Node)null, false, null, null, null, false},\n+            \/\/ expressions invalid for the null context, return type is irrelevant\n+            \/\/ for the eval, but needs to be a valid one when used\n+            \/\/ Note that invalid class type was tested in XPathAnyTypeTest,\n+            \/\/ and invalid QName tested in Bug4991939.\n+            {\"x+1\", (Node)null, false, null, STRING, String.class, true},\n+            {\"5 mod a\", (Node)null, false, null, STRING, String.class, true},\n+            {\"8 div \", (Node)null, false, null, STRING, String.class, true},\n+            {\"\/bookstore\/book[price>xx]\", (Node)null, false, null, STRING, String.class, true},\n+\n+            \/\/ undefined variable, context not relevant, return type not provided\n+            {\"\/  *     [n*$d2]\/s\", getDummyDoc(), false, null, null, null, false},\n+            {\"\/  *               [n|$d1]\/s\", getDummyDoc(), false, null, null, null, false},\n+            {\"\/  *     [n*$d2]\/s\", null, true, source, null, null, false},\n+            {\"\/  *               [n|$d1]\/s\", null, true, source, null, null, false},\n+            \/\/ undefined variable, context\/return type not relevant for the eval\n+            \/\/ but need to be valid when provided\n+            {\"\/  *     [n*$d2]\/s\", getDummyDoc(), false, null, STRING, String.class, true},\n+            {\"\/  *               [n|$d1]\/s\", getDummyDoc(), false, null, STRING, String.class, true},\n+            {\"\/  *     [n*$d2]\/s\", null, true, source, STRING, String.class, true},\n+            {\"\/  *               [n|$d1]\/s\", null, true, source, STRING, String.class, true},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides edge cases that are valid\n+     *\/\n+    @DataProvider(name = \"expInContext2\")\n+    public Object[][] getExpressionAndContext2() throws Exception {\n+        return new Object[][]{\n+            \/\/ The context can be empty\n+            {\"\/node[x=2]\", getEmptyDocument(), false, null, STRING, String.class, true},\n+            {\"\/a\/b\/c\", getEmptyDocument(), false, null, BOOLEAN, Boolean.class, true},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides expressions that contain function calls.\n+     *\/\n+    @DataProvider(name = \"functions\")\n+    public Object[][] getExpressionWithFunctions() throws Exception {\n+        InputSource source = new InputSource(new StringReader(\"<A\/>\"));\n+        return new Object[][]{\n+            \/\/ expression with a function call\n+            {XPATH_EXPRESSION, getEmptyDocument(), false, null, STRING, String.class, true},\n+            {XPATH_EXPRESSION, null, true, source, BOOLEAN, Boolean.class, true},\n+        };\n+    }\n+\n@@ -65,2 +188,43 @@\n-     * Verifies that the XPath processor throws XPathExpressionException upon\n-     * encountering illegal XPath expressions.\n+     * Verifies that NPE is thrown if the expression, source, or returnType is\n+     * null.\n+     * This test tests these methods:\n+     *     XPath::evaluate and XPathExpression::evaluate.\n+     *     XPath::evaluateExpression and XPathExpression::evaluateExpression.\n+     *\n+     * @param expression the expression\n+     * @param item the context item, can be null (for non-context dependent expressions)\n+     * @param useSource a flag indicating whether the source shall be used instead\n+     *                  of the context item\n+     * @param source the source\n+     * @param qn the return type in the form of a QName, can be null\n+     * @param cls the return type in the form of a class type, can be null\n+     * @param provided a flag indicating whether the return type is provided\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"NPE\")\n+    public void testNPEWithEvaluate(String expression, Object item, boolean useSource,\n+            InputSource source, QName qn, Class<?> cls, boolean provided)\n+            throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+\n+        \/\/ test with XPath::evaluate\n+        Assert.assertThrows(NullPointerException.class, () -> xpathEvaluate(\n+                xPath, expression, item, useSource, source, qn, provided));\n+\n+        \/\/ test with XPathExpression::evaluate\n+        Assert.assertThrows(NullPointerException.class, () -> xpathExpressionEvaluate(\n+                xPath, expression, item, useSource, source, qn, provided));\n+\n+        \/\/ test with XPath::evaluateExpression\n+        Assert.assertThrows(NullPointerException.class, () -> xpathEvaluateExpression(\n+                xPath, expression, item, useSource, source, cls, provided));\n+\n+        \/\/ test with XPathExpression::evaluateExpression\n+        Assert.assertThrows(NullPointerException.class, () -> xpathExpressionEvaluateExpression(\n+                xPath, expression, item, useSource, source, cls, provided));\n+    }\n+\n+    \/**\n+     * Verifies that XPathExpressionException is thrown upon encountering illegal\n+     * XPath expressions when XPath::compile is called.\n+     *\n@@ -70,5 +234,122 @@\n-    @Test(dataProvider = \"invalid\")\n-    public void testIllegalExp(String invalidExp) throws Exception {\n-        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n-        Document doc = builder.parse(new org.xml.sax.InputSource(new StringReader(\"<A\/>\")));\n-        Assert.assertThrows(XPathExpressionException.class, () -> evaluate(doc, invalidExp));\n+    @Test(dataProvider = \"invalidExp\")\n+    public void testXPathCompile(String invalidExp) throws Exception {\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathCompile(invalidExp));\n+    }\n+\n+    \/**\n+     * Verifies that XPathExpressionException is thrown upon encountering illegal\n+     * XPath expressions.\n+     * This test tests these methods:\n+     *     XPath::evaluate and XPathExpression::evaluate.\n+     *     XPath::evaluateExpression and XPathExpression::evaluateExpression.\n+\n+     *\n+     * @param expression an illegal XPath expression\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"invalidExp\")\n+    public void testCompileErrorWithEvaluate(String expression)\n+            throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+\n+        \/\/ test with XPath::evaluate\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathEvaluate(\n+                xPath, expression, (Node)null, false, null, null, false));\n+\n+        \/\/ test with XPathExpression::evaluate\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathExpressionEvaluate(\n+                xPath, expression, (Node)null, false, null, null, false));\n+\n+        \/\/ test with XPath::evaluateExpression\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathEvaluateExpression(\n+                xPath, expression, (Node)null, false, null, null, false));\n+\n+        \/\/ test with XPathExpression::evaluateExpression\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathExpressionEvaluateExpression(\n+                xPath, expression, (Node)null, false, null, null, false));\n+    }\n+\n+    \/**\n+     * Verifies that XPathExpressionException is thrown if the expression is\n+     * invalid with the given context.\n+     * This test tests these methods:\n+     *     XPath::evaluate and XPathExpression::evaluate.\n+     *     XPath::evaluateExpression and XPathExpression::evaluateExpression.\n+     *\n+     * @param expression the expression\n+     * @param item the context item, can be null (for non-context dependent expressions)\n+     * @param useSource a flag indicating whether the source shall be used instead\n+     *                  of the context item\n+     * @param source the source\n+     * @param qn the return type in the form of a QName, can be null\n+     * @param cls the return type in the form of a class type, can be null\n+     * @param provided a flag indicating whether the return type is provided\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"expInContext1\")\n+    public void testExpInContextEval1(String expression, Object item, boolean useSource,\n+            InputSource source, QName qn, Class<?> cls, boolean provided)\n+            throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+\n+        \/\/ test with XPath::evaluate\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathEvaluate(\n+                xPath, expression, item, useSource, source, qn, provided));\n+\n+        \/\/ test with XPathExpression::evaluate\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathExpressionEvaluate(\n+                xPath, expression, item, useSource, source, qn, provided));\n+\n+        \/\/ test with XPath::evaluateExpression\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathEvaluateExpression(\n+                xPath, expression, item, useSource, source, cls, provided));\n+\n+        \/\/ test with XPathExpression::evaluateExpression\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathExpressionEvaluateExpression(\n+                xPath, expression, item, useSource, source, cls, provided));\n+    }\n+\n+    \/**\n+     * Verifies that XPathExpressionException is thrown if the expression is\n+     * invalid with the given context.\n+     * This test tests these methods:\n+     *     XPath::evaluate and XPathExpression::evaluate.\n+     *     XPath::evaluateExpression and XPathExpression::evaluateExpression.\n+     *\n+     * @param expression the expression\n+     * @param item the context item, can be null (for non-context dependent expressions)\n+     * @param useSource a flag indicating whether the source shall be used instead\n+     *                  of the context item\n+     * @param source the source\n+     * @param qn the return type in the form of a QName, can be null\n+     * @param cls the return type in the form of a class type, can be null\n+     * @param provided a flag indicating whether the return type is provided\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"expInContext1\")\n+    public void testExpInContext(String expression, Object item, boolean useSource,\n+            InputSource source, QName qn, Class<?> cls, boolean provided)\n+            throws Exception {\n+        QName[] qns = {NUMBER, STRING, BOOLEAN, NODESET, NODE};\n+        Class[] classes = {Integer.class, Boolean.class, String.class, XPathNodes.class, Node.class};\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+\n+        for (QName qn1 : qns) {\n+            \/\/ test with XPath::evaluate\n+            Assert.assertThrows(XPathExpressionException.class, () -> xpathEvaluate(\n+                    xPath, expression, item, useSource, source, qn1, provided));\n+\n+            \/\/ test with XPathExpression::evaluate\n+            Assert.assertThrows(XPathExpressionException.class, () -> xpathExpressionEvaluate(\n+                    xPath, expression, item, useSource, source, qn1, provided));\n+        }\n+\n+        for (Class<?> cls1 : classes) {\n+            \/\/ test with XPath::evaluateExpression\n+            Assert.assertThrows(XPathExpressionException.class, () -> xpathEvaluateExpression(\n+                    xPath, expression, item, useSource, source, cls1, provided));\n+\n+            \/\/ test with XPathExpression::evaluateExpression\n+            Assert.assertThrows(XPathExpressionException.class, () -> xpathExpressionEvaluateExpression(\n+                    xPath, expression, item, useSource, source, cls1, provided));\n+        }\n@@ -77,1 +358,80 @@\n-    private void evaluate(Document doc, String s) throws XPathExpressionException {\n+    \/**\n+     * Verifies that the expression is valid with the given context.\n+     * This test tests these methods:\n+     *     XPath::evaluate and XPathExpression::evaluate.\n+     *     XPath::evaluateExpression and XPathExpression::evaluateExpression.\n+     *\n+     * @param expression the expression\n+     * @param item the context item, can be null (for non-context dependent expressions)\n+     * @param useSource a flag indicating whether the source shall be used instead\n+     *                  of the context item\n+     * @param source the source\n+     * @param qn the return type in the form of a QName, can be null\n+     * @param cls the return type in the form of a class type, can be null\n+     * @param provided a flag indicating whether the return type is provided\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"expInContext2\")\n+    public void testExpInContextEval2(String expression, Object item, boolean useSource,\n+            InputSource source, QName qn, Class<?> cls, boolean provided)\n+            throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+\n+        \/\/ test with XPath::evaluate\n+        xpathEvaluate(xPath, expression, item, useSource, source, qn, provided);\n+\n+        \/\/ test with XPathExpression::evaluate\n+        xpathExpressionEvaluate(xPath, expression, item, useSource, source, qn, provided);\n+\n+        \/\/ test with XPath::evaluateExpression\n+        xpathEvaluateExpression(xPath, expression, item, useSource, source, cls, provided);\n+\n+        \/\/ test with XPathExpression::evaluateExpression\n+        xpathExpressionEvaluateExpression(xPath, expression, item, useSource, source, cls, provided);\n+    }\n+\n+    \/**\n+     * Verifies that the XPath processor without XPathFunctionResolver throws\n+     * XPathExpressionException upon processing an XPath expression that attempts\n+     * to call a function.\n+     *\n+     * @param expression the expression\n+     * @param item the context item, can be null (for non-context dependent expressions)\n+     * @param useSource a flag indicating whether the source shall be used instead\n+     *                  of the context item\n+     * @param source the source\n+     * @param qn the return type in the form of a QName, can be null\n+     * @param cls the return type in the form of a class type, can be null\n+     * @param provided a flag indicating whether the return type is provided\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"functions\")\n+    public void testFunction(String expression, Object item, boolean useSource,\n+            InputSource source, QName qn, Class<?> cls, boolean provided)\n+            throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+\n+        \/\/ test with XPath::evaluate\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathEvaluate(\n+                xPath, expression, item, useSource, source, qn, provided));\n+\n+        \/\/ test with XPathExpression::evaluate\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathExpressionEvaluate(\n+                xPath, expression, item, useSource, source, qn, provided));\n+\n+        \/\/ test with XPath::evaluateExpression\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathEvaluateExpression(\n+                xPath, expression, item, useSource, source, cls, provided));\n+\n+        \/\/ test with XPathExpression::evaluateExpression\n+        Assert.assertThrows(XPathExpressionException.class, () -> xpathExpressionEvaluateExpression(\n+                xPath, expression, item, useSource, source, cls, provided));\n+    }\n+\n+\/\/ ---- utility methods ----\n+    \/**\n+     * Compiles the specified expression.\n+     * @param s the expression\n+     * @throws XPathExpressionException if the expression is invalid\n+     *\/\n+    private void xpathCompile(String s) throws XPathExpressionException {\n@@ -80,1 +440,157 @@\n-        xe.evaluateExpression(doc, Node.class);\n+    }\n+\n+    \/**\n+     * Runs evaluation using the XPath::evaluate methods.\n+     *\n+     * @param xPath the XPath object\n+     * @param expression the expression\n+     * @param item the context item, can be null (for non-context dependent expressions)\n+     * @param useSource a flag indicating whether the source shall be used instead\n+     *                  of the context item\n+     * @param source the source\n+     * @param qn the return type in the form of a QName, can be null\n+     * @param qnProvided a flag indicating whether the QName is provided\n+     * @throws XPathExpressionException\n+     *\/\n+    private void xpathEvaluate(XPath xPath, String expression, Object item,\n+            boolean useSource, InputSource source, QName qn, boolean qnProvided)\n+            throws XPathExpressionException {\n+        if (useSource) {\n+            if (!qnProvided) {\n+                xPath.evaluate(expression, source);\n+            } else {\n+                xPath.evaluate(expression, source, qn);\n+            }\n+        } else {\n+            if (!qnProvided) {\n+                xPath.evaluate(expression, item);\n+            } else {\n+                xPath.evaluate(expression, item, qn);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs evaluation using the XPathExpression::evaluate methods.\n+     *\n+     * @param xe the XPathExpression object\n+     * @param item the context item, can be null (for non-context dependent expressions)\n+     * @param useSource a flag indicating whether the source shall be used instead\n+     *                  of the context item\n+     * @param source the source\n+     * @param qn the return type in the form of a QName, can be null\n+     * @param qnProvided a flag indicating whether the QName is provided\n+     * @throws XPathExpressionException\n+     *\/\n+    private void xpathExpressionEvaluate(XPath xPath, String expression, Object item,\n+            boolean useSource, InputSource source, QName qn, boolean qnProvided)\n+            throws XPathExpressionException {\n+        XPathExpression xe = xPath.compile(expression);\n+        if (useSource) {\n+            if (!qnProvided) {\n+                xe.evaluate(source);\n+            } else {\n+                xe.evaluate(source, qn);\n+            }\n+        } else {\n+            if (!qnProvided) {\n+                xe.evaluate(item);\n+            } else {\n+                xe.evaluate(item, qn);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs evaluation using the XPath::evaluateExpression methods.\n+     *\n+     * @param xPath the XPath object\n+     * @param expression the expression\n+     * @param item the context item, can be null (for non-context dependent expressions)\n+     * @param useSource a flag indicating whether the source shall be used instead\n+     *                  of the context item\n+     * @param source the source\n+     * @param cls the class type, can be null\n+     * @param clsProvided a flag indicating whether the class type is provided\n+     * @throws XPathExpressionException\n+     *\/\n+    private void xpathEvaluateExpression(XPath xPath, String expression, Object item,\n+            boolean useSource, InputSource source, Class<?> cls, boolean clsProvided)\n+            throws XPathExpressionException {\n+        if (useSource) {\n+            if (!clsProvided) {\n+                xPath.evaluateExpression(expression, source);\n+            } else {\n+                xPath.evaluateExpression(expression, source, cls);\n+            }\n+        } else {\n+            if (!clsProvided) {\n+                xPath.evaluateExpression(expression, item);\n+            } else {\n+                xPath.evaluateExpression(expression, item, cls);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs evaluation using the XPathExpression::evaluateExpression methods.\n+     *\n+     * @param xe the XPathExpression object\n+     * @param item the context item, can be null (for non-context dependent expressions)\n+     * @param useSource a flag indicating whether the source shall be used instead\n+     *                  of the context item\n+     * @param source the source\n+     * @param qn the return type in the form of a QName, can be null\n+     * @param qnProvided a flag indicating whether the QName is provided\n+     * @throws XPathExpressionException\n+     *\/\n+    private void xpathExpressionEvaluateExpression(XPath xPath, String expression,\n+            Object item, boolean useSource, InputSource source, Class<?> cls, boolean qnProvided)\n+            throws XPathExpressionException {\n+        XPathExpression xe = xPath.compile(expression);\n+        if (useSource) {\n+            if (!qnProvided) {\n+                xe.evaluateExpression(source);\n+            } else {\n+                xe.evaluateExpression(source, cls);\n+            }\n+        } else {\n+            if (!qnProvided) {\n+                xe.evaluateExpression(item);\n+            } else {\n+                xe.evaluateExpression(item, cls);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns an empty {@link org.w3c.dom.Document}.\n+     * @return a DOM Document, null in case of Exception\n+     *\/\n+    private Document getEmptyDocument() {\n+        try {\n+            return DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+        } catch (ParserConfigurationException e) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a DOM Document with dummy content.\n+     * @return a DOM Document\n+     * @throws Exception\n+     *\/\n+    private Document getDummyDoc() throws Exception {\n+        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+        return builder.parse(new InputSource(new StringReader(\"<A\/>\")));\n+    }\n+\n+    \/**\n+     * Returns a DOM Document with the specified source.\n+     * @param s the source\n+     * @return a DOM Document\n+     * @throws Exception\n+     *\/\n+    private Document getDoc(InputSource s) throws Exception {\n+        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+        return builder.parse(s);\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathExceptionTest.java","additions":532,"deletions":16,"binary":false,"changes":548,"status":"modified"}]}