{"files":[{"patch":"@@ -339,0 +339,2 @@\n+  template(asFixedArity_name,                         \"asFixedArity\")                             \\\n+  template(asFixedArity_signature,                    \"()Ljava\/lang\/invoke\/MethodHandle;\")        \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-}\n+C2V_END\n@@ -628,0 +628,71 @@\n+C2V_VMENTRY_NULL(jobjectArray, resolveBootstrapMethod, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n+  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+  constantTag tag = cp->tag_at(index);\n+  bool is_indy = tag.is_invoke_dynamic();\n+  bool is_condy = tag.is_dynamic_constant();\n+  if (!(is_condy || is_indy)) {\n+    JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(\"Unexpected constant pool tag at index %d: %d\", index, tag.value()));\n+  }\n+  \/\/ Resolve the bootstrap specifier, its name, type, and static arguments\n+  BootstrapInfo bootstrap_specifier(cp, index);\n+  Handle bsm = bootstrap_specifier.resolve_bsm(CHECK_NULL);\n+\n+  \/\/ call java.lang.invoke.MethodHandle::asFixedArity() -> MethodHandle\n+  \/\/ to get a DirectMethodHandle from which we can then extract a Method*\n+  JavaValue result(T_OBJECT);\n+  JavaCalls::call_virtual(&result,\n+                         bsm,\n+                         vmClasses::MethodHandle_klass(),\n+                         vmSymbols::asFixedArity_name(),\n+                         vmSymbols::asFixedArity_signature(),\n+                         CHECK_NULL);\n+  bsm = Handle(THREAD, result.get_oop());\n+\n+  \/\/ Check assumption about getting a DirectMethodHandle\n+  if (!java_lang_invoke_DirectMethodHandle::is_instance(bsm())) {\n+    JVMCI_THROW_MSG_NULL(InternalError, err_msg(\"Unexpected MethodHandle subclass: %s\", bsm->klass()->external_name()));\n+  }\n+  \/\/ Create return array describing the bootstrap method invocation (BSMI)\n+  JVMCIObjectArray bsmi = JVMCIENV->new_Object_array(4, JVMCI_CHECK_NULL);\n+\n+  \/\/ Extract Method* and wrap it in a ResolvedJavaMethod\n+  Handle member = Handle(THREAD, java_lang_invoke_DirectMethodHandle::member(bsm()));\n+  JVMCIObject bsmi_method = JVMCIENV->get_jvmci_method(methodHandle(THREAD, java_lang_invoke_MemberName::vmtarget(member())), JVMCI_CHECK_NULL);\n+  JVMCIENV->put_object_at(bsmi, 0, bsmi_method);\n+\n+  JVMCIObject bsmi_name = JVMCIENV->create_string(bootstrap_specifier.name(), JVMCI_CHECK_NULL);\n+  JVMCIENV->put_object_at(bsmi, 1, bsmi_name);\n+\n+  Handle type_arg = bootstrap_specifier.type_arg();\n+  JVMCIObject bsmi_type = JVMCIENV->get_object_constant(type_arg());\n+  JVMCIENV->put_object_at(bsmi, 2, bsmi_type);\n+\n+  Handle arg_values = bootstrap_specifier.arg_values();\n+  if (arg_values.not_null()) {\n+    if (!arg_values->is_array()) {\n+      JVMCIENV->put_object_at(bsmi, 3, JVMCIENV->get_object_constant(arg_values()));\n+    } else if (arg_values->is_objArray()) {\n+      objArrayHandle args_array = objArrayHandle(THREAD, (objArrayOop) arg_values());\n+      int len = args_array->length();\n+      JVMCIObjectArray arguments = JVMCIENV->new_JavaConstant_array(len, JVMCI_CHECK_NULL);\n+      JVMCIENV->put_object_at(bsmi, 3, arguments);\n+      for (int i = 0; i < len; i++) {\n+        oop x = args_array->obj_at(i);\n+        if (x != nullptr) {\n+          JVMCIENV->put_object_at(arguments, i, JVMCIENV->get_object_constant(x));\n+        } else {\n+          JVMCIENV->put_object_at(arguments, i, JVMCIENV->get_JavaConstant_NULL_POINTER());\n+        }\n+      }\n+    } else if (arg_values->is_typeArray()) {\n+      typeArrayHandle bsci = typeArrayHandle(THREAD, (typeArrayOop) arg_values());\n+      JVMCIPrimitiveArray arguments = JVMCIENV->new_intArray(bsci->length(), JVMCI_CHECK_NULL);\n+      JVMCIENV->put_object_at(bsmi, 3, arguments);\n+      for (int i = 0; i < bsci->length(); i++) {\n+        JVMCIENV->put_int_at(arguments, i, bsci->int_at(i));\n+      }\n+    }\n+  }\n+  return JVMCIENV->get_jobjectArray(bsmi);\n+C2V_END\n+\n@@ -2720,0 +2791,1 @@\n+  {CC \"resolveBootstrapMethod\",                       CC \"(\" HS_CONSTANT_POOL \"I)[\" OBJECT,                                                 FN_PTR(resolveBootstrapMethod)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -286,2 +286,0 @@\n-    \/\/ TODO resolving JVM_CONSTANT_Dynamic\n-\n@@ -298,5 +296,27 @@\n-     * If {@code cpi} denotes an entry representing a\n-     * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-2.html#jvms-2.9\">signature\n-     * polymorphic<\/a> method, this method ensures that the type referenced by the entry is loaded\n-     * and initialized. It {@code cpi} does not denote a signature polymorphic method, this method\n-     * does nothing.\n+     * Resolves the details for invoking the bootstrap method associated with the\n+     * {@code CONSTANT_Dynamic_info} or @{code CONSTANT_InvokeDynamic_info} entry at {@code cpi} in\n+     * {@code constant pool}.\n+     *\n+     * The return value encodes the details in an object array that is described by the pseudo Java\n+     * object {@code info} below:\n+     *\n+     * <pre>\n+     *     bsm_invocation = [\n+     *         ResolvedJavaMethod[] method,\n+     *         String name,\n+     *         Object type,             \/\/ JavaConstant: reference to Class (condy) or MethodType (indy)\n+     *         Object staticArguments,  \/\/ null: no static arguments\n+     *                                  \/\/ JavaConstant: single static argument\n+     *                                  \/\/ JavaConstant[]: multiple static arguments\n+     *                                  \/\/ int[]: static arguments to be resolved via BootstrapCallInfo\n+     *     ]\n+     * <\/pre>\n+     *\n+     * @return bootstrap method invocation details as encoded above\n+     *\/\n+    native Object[] resolveBootstrapMethod(HotSpotConstantPool constantPool, int cpi);\n+\n+    \/**\n+     * If {@code cpi} denotes an entry representing a signature polymorphic method ({@jvms 2.9}),\n+     * this method ensures that the type referenced by the entry is loaded and initialized. It\n+     * {@code cpi} does not denote a signature polymorphic method, this method does nothing.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,5 @@\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n@@ -521,0 +526,87 @@\n+    static class BootstrapMethodInvocationImpl implements BootstrapMethodInvocation {\n+        private final boolean indy;\n+        private final ResolvedJavaMethod method;\n+        private final String name;\n+        private final JavaConstant type;\n+        private final List<JavaConstant> staticArguments;\n+\n+        BootstrapMethodInvocationImpl(boolean indy, ResolvedJavaMethod method, String name, JavaConstant type, List<JavaConstant> staticArguments) {\n+            this.indy = indy;\n+            this.method = method;\n+            this.name = name;\n+            this.type = type;\n+            this.staticArguments = staticArguments;\n+        }\n+\n+        @Override\n+        public ResolvedJavaMethod getMethod() {\n+            return method;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public boolean isInvokeDynamic() {\n+            return indy;\n+        }\n+\n+        @Override\n+        public JavaConstant getType() {\n+            return type;\n+        }\n+\n+        @Override\n+        public List<JavaConstant> getStaticArguments() {\n+            return staticArguments;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String static_args = staticArguments.stream().map(BootstrapMethodInvocationImpl::argumentAsString).collect(Collectors.joining(\", \", \"[\", \"]\"));\n+            return \"BootstrapMethod[\" + (indy ? \"indy\" : \"condy\") +\n+                            \", method:\" + method.format(\"%H.%n(%p)\") +\n+                            \", name: \" + name +\n+                            \", type: \" + type.toValueString() +\n+                            \", static arguments:\" + static_args;\n+        }\n+\n+        private static String argumentAsString(JavaConstant arg) {\n+            String type = arg.getJavaKind().getJavaName();\n+            String value = arg.toValueString();\n+            return type + \":\" + value;\n+        }\n+    }\n+\n+    @Override\n+    public BootstrapMethodInvocation lookupBootstrapMethodInvocation(int rawCpi, int opcode) {\n+        int cpi = opcode == -1 ? rawCpi : rawIndexToConstantPoolIndex(rawCpi, opcode);\n+        final JvmConstant tag = getTagAt(cpi);\n+        switch (tag.name) {\n+            case \"InvokeDynamic\":\n+            case \"Dynamic\":\n+                Object[] bsmi = compilerToVM().resolveBootstrapMethod(this, cpi);\n+                ResolvedJavaMethod method = (ResolvedJavaMethod) bsmi[0];\n+                String name = (String) bsmi[1];\n+                JavaConstant type = (JavaConstant) bsmi[2];\n+                Object staticArguments = bsmi[3];\n+                List<JavaConstant> staticArgumentsList;\n+                if (staticArguments == null) {\n+                    staticArgumentsList = List.of();\n+                } else if (staticArguments instanceof JavaConstant) {\n+                    staticArgumentsList = List.of((JavaConstant) staticArguments);\n+                } else if (staticArguments instanceof JavaConstant[]) {\n+                    staticArgumentsList = List.of((JavaConstant[]) staticArguments);\n+                } else {\n+                    int[] bsciArgs = (int[]) staticArguments;\n+                    String message = String.format(\"Resolving bootstrap static arguments for %s using BootstrapCallInfo %s not supported\", method.format(\"%H.%n(%p)\"), Arrays.toString(bsciArgs));\n+                    throw new IllegalArgumentException(message);\n+                }\n+                return new BootstrapMethodInvocationImpl(tag.name.equals(\"InvokeDynamic\"), method, name, type, staticArgumentsList);\n+            default:\n+                return null;\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n-     * The name of the class declaring the intrinsified method. The name is in\n-     * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.2.1\">class\n-     * file format<\/a> (e.g., {@code \"java\/lang\/Thread\"} instead of {@code \"java.lang.Thread\"}).\n+     * The name of the class declaring the intrinsified method. The name is in class file format\n+     * (see JVMS {@jvms 4.2.1}). For example, {@code \"java\/lang\/Thread\"} instead of\n+     * {@code \"java.lang.Thread\"}.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/VMIntrinsicMethod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+\n@@ -87,0 +90,59 @@\n+    \/**\n+     * The details for invoking a bootstrap method associated with a {@code CONSTANT_Dynamic_info}\n+     * or {@code CONSTANT_InvokeDynamic_info} pool entry .\n+     *\n+     * @jvms 4.4.10 The {@code CONSTANT_Dynamic_info} and {@code CONSTANT_InvokeDynamic_info}\n+     *       Structures\n+     * @jvms 4.7.23 The {@code BootstrapMethods} Attribute\n+     *\/\n+    interface BootstrapMethodInvocation {\n+        \/**\n+         * Gets the bootstrap method that will be invoked.\n+         *\/\n+        ResolvedJavaMethod getMethod();\n+\n+        \/**\n+         * Returns {@code true} if this bootstrap method invocation is for a\n+         * {@code CONSTANT_InvokeDynamic_info} pool entry, {@code false} if it is for a\n+         * {@code CONSTANT_Dynamic_info} entry.\n+         *\/\n+        boolean isInvokeDynamic();\n+\n+        \/**\n+         * Gets the name of the pool entry.\n+         *\/\n+        String getName();\n+\n+        \/**\n+         * Returns a reference to the {@link MethodType} ({@code this.isInvokeDynamic() == true}) or\n+         * {@link Class} ({@code this.isInvokeDynamic() == false}) resolved for the descriptor of\n+         * the pool entry.\n+         *\/\n+        JavaConstant getType();\n+\n+        \/**\n+         * Gets the static arguments with which the bootstrap method will be invoked.\n+         *\n+         * @jvms 5.4.3.6\n+         *\/\n+        List<JavaConstant> getStaticArguments();\n+    }\n+\n+    \/**\n+     * Gets the details for invoking a bootstrap method associated with the\n+     * {@code CONSTANT_Dynamic_info} or {@code CONSTANT_InvokeDynamic_info} pool entry {@code cpi}\n+     * in the constant pool.\n+     *\n+     * @param cpi a constant pool index\n+     * @param opcode the opcode of the instruction that has {@code cpi} as an operand or -1 if\n+     *            {@code cpi} was not decoded from an instruction stream\n+     * @return the bootstrap method invocation details or {@code null} if the entry at {@code cpi}\n+     *         is not a {@code CONSTANT_Dynamic_info} or @{code CONSTANT_InvokeDynamic_info}\n+     * @throws IllegalArgumentException if the bootstrap method invocation makes use of\n+     *             {@code java.lang.invoke.BootstrapCallInfo}\n+     * @jvms 4.7.23 The {@code BootstrapMethods} Attribute\n+     *\/\n+    default BootstrapMethodInvocation lookupBootstrapMethodInvocation(int cpi, int opcode) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ConstantPool.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -104,4 +104,3 @@\n-     * kinds, this is the <i>FieldType<\/i> term in\n-     * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3.2-200\">\n-     * table 4.3-A<\/a> of the JVM Specification. For {@link #Object}, the character {@code 'A'} is\n-     * returned and for {@link #Illegal}, {@code '-'} is returned.\n+     * kinds, this is the <i>FieldType<\/i> term in table 4.3-A of JVMS {@jvms 4.3.2}. For\n+     * {@link #Object}, the character {@code 'A'} is returned and for {@link #Illegal}, {@code '-'}\n+     * is returned.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/JavaKind.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @see \"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.12\"\n+ * @jvms 4.7.12\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/LineNumberTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @see \"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.13\"\n+ * @jvms 4.7.13\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/LocalVariableTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,3 +86,1 @@\n-     * Parses a\n-     * <a href=\"http:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.3.3\">method\n-     * descriptor<\/a> into a {@link Signature}.\n+     * Parses a method descriptor ({@jvms 4.3.3}) into a {@link Signature}.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/MetaAccessProvider.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,3 +88,1 @@\n-     * Checks that the method is a\n-     * <a href=\"http:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.6\">varargs<\/a>\n-     * method.\n+     * Checks if the method is a varargs method.\n@@ -93,0 +91,1 @@\n+     * @jvms 4.6\n@@ -97,3 +96,1 @@\n-     * Checks that the method is a\n-     * <a href=\"http:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.6\">bridge<\/a>\n-     * method.\n+     * Checks if the method is a bridge method.\n@@ -102,0 +99,1 @@\n+     * @jvms 4.6\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n- * @see <a href=\"http:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.3.3\">Method\n- *      Descriptors<\/a>\n+ * @jvms 4.3.3\n@@ -87,3 +86,1 @@\n-     * Gets the\n-     * <a href=\"http:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.3.3\">method\n-     * descriptor<\/a> corresponding to this signature. For example:\n+     * Gets the method descriptor ({@jvms 4.3.3}) corresponding to this signature. For example:\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/Signature.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -57,0 +58,1 @@\n+import jdk.vm.ci.hotspot.HotSpotConstantPool;\n@@ -58,0 +60,1 @@\n+import jdk.vm.ci.meta.ConstantPool.BootstrapMethodInvocation;\n@@ -64,1 +67,1 @@\n- * Tests support for Dynamic constants.\n+ * Tests support for Dynamic constants and {@link jdk.vm.ci.meta.ConstantPool#lookupBootstrapMethodInvocation}.\n@@ -148,0 +151,1 @@\n+            ConstantDynamic condy;\n@@ -154,1 +158,1 @@\n-                ConstantDynamic condy = new ConstantDynamic(\"const\", desc, handle);\n+                condy = new ConstantDynamic(\"const\", desc, handle);\n@@ -164,1 +168,1 @@\n-                ConstantDynamic condy = new ConstantDynamic(\"const\", desc, invokeHandle, handle);\n+                condy = new ConstantDynamic(\"const\", desc, invokeHandle, handle);\n@@ -180,0 +184,1 @@\n+                condy = condy2;\n@@ -187,0 +192,12 @@\n+\n+            MethodVisitor concat = cw.visitMethod(PUBLIC_STATIC, \"concat\", \"()Ljava\/lang\/String;\", null, null);\n+            String sig = \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";\n+            Handle handle = new Handle(H_INVOKESTATIC, Type.getInternalName(StringConcatFactory.class), \"makeConcatWithConstants\", sig, false);\n+            String recipe = \"var arg=\\u0001, const arg=\\u0002\";\n+            Object[] bsmArgs = {recipe};\n+            concat.visitLdcInsn(condy);\n+            concat.visitInvokeDynamicInsn(\"do_concat\", \"(\" + desc + \")Ljava\/lang\/String;\", handle, bsmArgs);\n+            concat.visitInsn(ARETURN);\n+            concat.visitMaxs(0, 0);\n+            concat.visitEnd();\n+\n@@ -237,0 +254,4 @@\n+\n+        Method getTagAt = HotSpotConstantPool.class.getDeclaredMethod(\"getTagAt\", int.class);\n+        getTagAt.setAccessible(true);\n+\n@@ -244,2 +265,0 @@\n-                Method getTagAt = cp.getClass().getDeclaredMethod(\"getTagAt\", int.class);\n-                getTagAt.setAccessible(true);\n@@ -265,0 +284,33 @@\n+\n+                testLookupBootstrapMethodInvocation(condyType, metaAccess, testClass, getTagAt);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests {@link jdk.vm.ci.meta.ConstantPool#lookupBootstrapMethodInvocation}.\n+     *\/\n+    private void testLookupBootstrapMethodInvocation(CondyType condyType, MetaAccessProvider metaAccess, Class<?> testClass, Method getTagAt) throws Throwable {\n+        Method m = testClass.getDeclaredMethod(\"concat\");\n+        ResolvedJavaMethod concat = metaAccess.lookupJavaMethod(m);\n+        ConstantPool cp = concat.getConstantPool();\n+        Object lastConstant = null;\n+        for (int cpi = 1; cpi < cp.length(); cpi++) {\n+            String tag = String.valueOf(getTagAt.invoke(cp, cpi));\n+            BootstrapMethodInvocation bsmi = cp.lookupBootstrapMethodInvocation(cpi, -1);\n+            if (tag.equals(\"InvokeDynamic\") || tag.equals(\"Dynamic\")) {\n+                Assert.assertNotNull(bsmi);\n+                String bsm = bsmi.getMethod().format(\"%H.%n\");\n+                if (tag.equals(\"InvokeDynamic\")) {\n+                    Assert.assertTrue(bsmi.isInvokeDynamic());\n+                    Assert.assertEquals(bsm, \"java.lang.invoke.StringConcatFactory.makeConcatWithConstants\");\n+                } else {\n+                    Assert.assertFalse(bsmi.isInvokeDynamic());\n+                    if (condyType == CondyType.CALL_DIRECT_BSM) {\n+                        Assert.assertTrue(bsm.startsWith(\"jdk.vm.ci.hotspot.test.TestDynamicConstant.get\") && bsm.endsWith(\"BSM\"), bsm);\n+                    } else {\n+                        Assert.assertEquals(bsm, \"java.lang.invoke.ConstantBootstraps.invoke\");\n+                    }\n+                }\n+            } else {\n+                Assert.assertNull(bsmi, String.valueOf(bsmi));\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestDynamicConstant.java","additions":57,"deletions":5,"binary":false,"changes":62,"status":"modified"}]}