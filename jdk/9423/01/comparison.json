{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"os_linux.impl.hpp\"\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"os_linux.impl.hpp\"\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zNUMA_linux.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"os_linux.impl.hpp\"\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"os_linux.impl.hpp\"\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"os_linux.impl.hpp\"\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-\/\/ Linux_OS defines the interface to Linux operating systems\n-\n@@ -33,399 +31,3 @@\n-class Linux {\n-  friend class CgroupSubsystem;\n-  friend class os;\n-  friend class OSContainer;\n-  friend class TestReserveMemorySpecial;\n-\n-  static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);\n-  static int (*_pthread_setname_np)(pthread_t, const char*);\n-\n-  static address   _initial_thread_stack_bottom;\n-  static uintptr_t _initial_thread_stack_size;\n-\n-  static const char *_libc_version;\n-  static const char *_libpthread_version;\n-\n-  static bool _supports_fast_thread_cpu_time;\n-\n-  static GrowableArray<int>* _cpu_to_node;\n-  static GrowableArray<int>* _nindex_to_node;\n-\n-  static size_t _default_large_page_size;\n-\n- protected:\n-\n-  static julong _physical_memory;\n-  static pthread_t _main_thread;\n-  static int _page_size;\n-\n-  static julong available_memory();\n-  static julong physical_memory() { return _physical_memory; }\n-  static void set_physical_memory(julong phys_mem) { _physical_memory = phys_mem; }\n-  static int active_processor_count();\n-\n-  static void initialize_system_info();\n-\n-  static int commit_memory_impl(char* addr, size_t bytes, bool exec);\n-  static int commit_memory_impl(char* addr, size_t bytes,\n-                                size_t alignment_hint, bool exec);\n-\n-  static void set_libc_version(const char *s)       { _libc_version = s; }\n-  static void set_libpthread_version(const char *s) { _libpthread_version = s; }\n-\n-  static void rebuild_cpu_to_node_map();\n-  static void rebuild_nindex_to_node_map();\n-  static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }\n-  static GrowableArray<int>* nindex_to_node()  { return _nindex_to_node; }\n-\n-  static size_t default_large_page_size();\n-  static size_t scan_default_large_page_size();\n-  static os::PageSizes scan_multiple_page_support();\n-\n-  static bool setup_large_page_type(size_t page_size);\n-  static bool transparent_huge_pages_sanity_check(bool warn, size_t pages_size);\n-  static bool hugetlbfs_sanity_check(bool warn, size_t page_size);\n-  static bool shm_hugetlbfs_sanity_check(bool warn, size_t page_size);\n-\n-  static int hugetlbfs_page_size_flag(size_t page_size);\n-\n-  static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec);\n-  static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, size_t page_size, char* req_addr, bool exec);\n-  static bool commit_memory_special(size_t bytes, size_t page_size, char* req_addr, bool exec);\n-\n-  static bool release_memory_special_impl(char* base, size_t bytes);\n-  static bool release_memory_special_shm(char* base, size_t bytes);\n-  static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);\n-\n-  static void print_process_memory_info(outputStream* st);\n-  static void print_system_memory_info(outputStream* st);\n-  static bool print_container_info(outputStream* st);\n-  static void print_steal_info(outputStream* st);\n-  static void print_distro_info(outputStream* st);\n-  static void print_libversion_info(outputStream* st);\n-  static void print_proc_sys_info(outputStream* st);\n-  static bool print_ld_preload_file(outputStream* st);\n-  static void print_uptime_info(outputStream* st);\n-\n- public:\n-  struct CPUPerfTicks {\n-    uint64_t used;\n-    uint64_t usedKernel;\n-    uint64_t total;\n-    uint64_t steal;\n-    bool     has_steal_ticks;\n-  };\n-\n-  \/\/ which_logical_cpu=-1 returns accumulated ticks for all cpus.\n-  static bool get_tick_information(CPUPerfTicks* pticks, int which_logical_cpu);\n-  static bool _stack_is_executable;\n-  static void *dlopen_helper(const char *name, char *ebuf, int ebuflen);\n-  static void *dll_load_in_vmthread(const char *name, char *ebuf, int ebuflen);\n-  static const char *dll_path(void* lib);\n-\n-  static void init_thread_fpu_state();\n-  static int  get_fpu_control_word();\n-  static void set_fpu_control_word(int fpu_control);\n-  static pthread_t main_thread(void)                                { return _main_thread; }\n-  \/\/ returns kernel thread id (similar to LWP id on Solaris), which can be\n-  \/\/ used to access \/proc\n-  static pid_t gettid();\n-\n-  static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }\n-  static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }\n-\n-  static int page_size(void)                                        { return _page_size; }\n-  static void set_page_size(int val)                                { _page_size = val; }\n-\n-  static intptr_t* ucontext_get_sp(const ucontext_t* uc);\n-  static intptr_t* ucontext_get_fp(const ucontext_t* uc);\n-\n-  \/\/ GNU libc and libpthread version strings\n-  static const char *libc_version()           { return _libc_version; }\n-  static const char *libpthread_version()     { return _libpthread_version; }\n-\n-  static void libpthread_init();\n-  static void sched_getcpu_init();\n-  static bool libnuma_init();\n-  static void* libnuma_dlsym(void* handle, const char* name);\n-  \/\/ libnuma v2 (libnuma_1.2) symbols\n-  static void* libnuma_v2_dlsym(void* handle, const char* name);\n-\n-  \/\/ Return default guard size for the specified thread type\n-  static size_t default_guard_size(os::ThreadType thr_type);\n-\n-  static void capture_initial_stack(size_t max_size);\n-\n-  \/\/ Stack overflow handling\n-  static bool manually_expand_stack(JavaThread * t, address addr);\n-\n-  \/\/ fast POSIX clocks support\n-  static void fast_thread_clock_init(void);\n-\n-  static int pthread_getcpuclockid(pthread_t tid, clockid_t *clock_id) {\n-    return _pthread_getcpuclockid ? _pthread_getcpuclockid(tid, clock_id) : -1;\n-  }\n-\n-  static bool supports_fast_thread_cpu_time() {\n-    return _supports_fast_thread_cpu_time;\n-  }\n-\n-  static jlong fast_thread_cpu_time(clockid_t clockid);\n-\n-  \/\/ Determine if the vmid is the parent pid for a child in a PID namespace.\n-  \/\/ Return the namespace pid if so, otherwise -1.\n-  static int get_namespace_pid(int vmid);\n-\n-  \/\/ Output structure for query_process_memory_info()\n-  struct meminfo_t {\n-    ssize_t vmsize;     \/\/ current virtual size\n-    ssize_t vmpeak;     \/\/ peak virtual size\n-    ssize_t vmrss;      \/\/ current resident set size\n-    ssize_t vmhwm;      \/\/ peak resident set size\n-    ssize_t vmswap;     \/\/ swapped out\n-    ssize_t rssanon;    \/\/ resident set size (anonymous mappings, needs 4.5)\n-    ssize_t rssfile;    \/\/ resident set size (file mappings, needs 4.5)\n-    ssize_t rssshmem;   \/\/ resident set size (shared mappings, needs 4.5)\n-  };\n-\n-  \/\/ Attempts to query memory information about the current process and return it in the output structure.\n-  \/\/ May fail (returns false) or succeed (returns true) but not all output fields are available; unavailable\n-  \/\/ fields will contain -1.\n-  static bool query_process_memory_info(meminfo_t* info);\n-\n-  \/\/ Stack repair handling\n-\n-  \/\/ none present\n-\n- private:\n-  static void numa_init();\n-  static void expand_stack_to(address bottom);\n-\n-  typedef int (*sched_getcpu_func_t)(void);\n-  typedef int (*numa_node_to_cpus_func_t)(int node, unsigned long *buffer, int bufferlen);\n-  typedef int (*numa_node_to_cpus_v2_func_t)(int node, void *mask);\n-  typedef int (*numa_max_node_func_t)(void);\n-  typedef int (*numa_num_configured_nodes_func_t)(void);\n-  typedef int (*numa_available_func_t)(void);\n-  typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);\n-  typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);\n-  typedef void (*numa_interleave_memory_v2_func_t)(void *start, size_t size, struct bitmask* mask);\n-  typedef struct bitmask* (*numa_get_membind_func_t)(void);\n-  typedef struct bitmask* (*numa_get_interleave_mask_func_t)(void);\n-  typedef long (*numa_move_pages_func_t)(int pid, unsigned long count, void **pages, const int *nodes, int *status, int flags);\n-  typedef void (*numa_set_preferred_func_t)(int node);\n-  typedef void (*numa_set_bind_policy_func_t)(int policy);\n-  typedef int (*numa_bitmask_isbitset_func_t)(struct bitmask *bmp, unsigned int n);\n-  typedef int (*numa_distance_func_t)(int node1, int node2);\n-\n-  static sched_getcpu_func_t _sched_getcpu;\n-  static numa_node_to_cpus_func_t _numa_node_to_cpus;\n-  static numa_node_to_cpus_v2_func_t _numa_node_to_cpus_v2;\n-  static numa_max_node_func_t _numa_max_node;\n-  static numa_num_configured_nodes_func_t _numa_num_configured_nodes;\n-  static numa_available_func_t _numa_available;\n-  static numa_tonode_memory_func_t _numa_tonode_memory;\n-  static numa_interleave_memory_func_t _numa_interleave_memory;\n-  static numa_interleave_memory_v2_func_t _numa_interleave_memory_v2;\n-  static numa_set_bind_policy_func_t _numa_set_bind_policy;\n-  static numa_bitmask_isbitset_func_t _numa_bitmask_isbitset;\n-  static numa_distance_func_t _numa_distance;\n-  static numa_get_membind_func_t _numa_get_membind;\n-  static numa_get_interleave_mask_func_t _numa_get_interleave_mask;\n-  static numa_move_pages_func_t _numa_move_pages;\n-  static numa_set_preferred_func_t _numa_set_preferred;\n-  static unsigned long* _numa_all_nodes;\n-  static struct bitmask* _numa_all_nodes_ptr;\n-  static struct bitmask* _numa_nodes_ptr;\n-  static struct bitmask* _numa_interleave_bitmask;\n-  static struct bitmask* _numa_membind_bitmask;\n-\n-  static void set_sched_getcpu(sched_getcpu_func_t func) { _sched_getcpu = func; }\n-  static void set_numa_node_to_cpus(numa_node_to_cpus_func_t func) { _numa_node_to_cpus = func; }\n-  static void set_numa_node_to_cpus_v2(numa_node_to_cpus_v2_func_t func) { _numa_node_to_cpus_v2 = func; }\n-  static void set_numa_max_node(numa_max_node_func_t func) { _numa_max_node = func; }\n-  static void set_numa_num_configured_nodes(numa_num_configured_nodes_func_t func) { _numa_num_configured_nodes = func; }\n-  static void set_numa_available(numa_available_func_t func) { _numa_available = func; }\n-  static void set_numa_tonode_memory(numa_tonode_memory_func_t func) { _numa_tonode_memory = func; }\n-  static void set_numa_interleave_memory(numa_interleave_memory_func_t func) { _numa_interleave_memory = func; }\n-  static void set_numa_interleave_memory_v2(numa_interleave_memory_v2_func_t func) { _numa_interleave_memory_v2 = func; }\n-  static void set_numa_set_bind_policy(numa_set_bind_policy_func_t func) { _numa_set_bind_policy = func; }\n-  static void set_numa_bitmask_isbitset(numa_bitmask_isbitset_func_t func) { _numa_bitmask_isbitset = func; }\n-  static void set_numa_distance(numa_distance_func_t func) { _numa_distance = func; }\n-  static void set_numa_get_membind(numa_get_membind_func_t func) { _numa_get_membind = func; }\n-  static void set_numa_get_interleave_mask(numa_get_interleave_mask_func_t func) { _numa_get_interleave_mask = func; }\n-  static void set_numa_move_pages(numa_move_pages_func_t func) { _numa_move_pages = func; }\n-  static void set_numa_set_preferred(numa_set_preferred_func_t func) { _numa_set_preferred = func; }\n-  static void set_numa_all_nodes(unsigned long* ptr) { _numa_all_nodes = ptr; }\n-  static void set_numa_all_nodes_ptr(struct bitmask **ptr) { _numa_all_nodes_ptr = (ptr == NULL ? NULL : *ptr); }\n-  static void set_numa_nodes_ptr(struct bitmask **ptr) { _numa_nodes_ptr = (ptr == NULL ? NULL : *ptr); }\n-  static void set_numa_interleave_bitmask(struct bitmask* ptr)     { _numa_interleave_bitmask = ptr ;   }\n-  static void set_numa_membind_bitmask(struct bitmask* ptr)        { _numa_membind_bitmask = ptr ;      }\n-  static int sched_getcpu_syscall(void);\n-\n-  enum NumaAllocationPolicy{\n-    NotInitialized,\n-    Membind,\n-    Interleave\n-  };\n-  static NumaAllocationPolicy _current_numa_policy;\n-\n-#ifdef __GLIBC__\n-  struct glibc_mallinfo {\n-    int arena;\n-    int ordblks;\n-    int smblks;\n-    int hblks;\n-    int hblkhd;\n-    int usmblks;\n-    int fsmblks;\n-    int uordblks;\n-    int fordblks;\n-    int keepcost;\n-  };\n-\n-  struct glibc_mallinfo2 {\n-    size_t arena;\n-    size_t ordblks;\n-    size_t smblks;\n-    size_t hblks;\n-    size_t hblkhd;\n-    size_t usmblks;\n-    size_t fsmblks;\n-    size_t uordblks;\n-    size_t fordblks;\n-    size_t keepcost;\n-  };\n-\n-  typedef struct glibc_mallinfo (*mallinfo_func_t)(void);\n-  typedef struct glibc_mallinfo2 (*mallinfo2_func_t)(void);\n-\n-  static mallinfo_func_t _mallinfo;\n-  static mallinfo2_func_t _mallinfo2;\n-#endif\n-\n- public:\n-  static int sched_getcpu()  { return _sched_getcpu != NULL ? _sched_getcpu() : -1; }\n-  static int numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen);\n-  static int numa_max_node() { return _numa_max_node != NULL ? _numa_max_node() : -1; }\n-  static int numa_num_configured_nodes() {\n-    return _numa_num_configured_nodes != NULL ? _numa_num_configured_nodes() : -1;\n-  }\n-  static int numa_available() { return _numa_available != NULL ? _numa_available() : -1; }\n-  static int numa_tonode_memory(void *start, size_t size, int node) {\n-    return _numa_tonode_memory != NULL ? _numa_tonode_memory(start, size, node) : -1;\n-  }\n-\n-  static bool is_running_in_interleave_mode() {\n-    return _current_numa_policy == Interleave;\n-  }\n-\n-  static void set_configured_numa_policy(NumaAllocationPolicy numa_policy) {\n-    _current_numa_policy = numa_policy;\n-  }\n-\n-  static NumaAllocationPolicy identify_numa_policy() {\n-    for (int node = 0; node <= Linux::numa_max_node(); node++) {\n-      if (Linux::_numa_bitmask_isbitset(Linux::_numa_interleave_bitmask, node)) {\n-        return Interleave;\n-      }\n-    }\n-    return Membind;\n-  }\n-\n-  static void numa_interleave_memory(void *start, size_t size) {\n-    \/\/ Prefer v2 API\n-    if (_numa_interleave_memory_v2 != NULL) {\n-      if (is_running_in_interleave_mode()) {\n-        _numa_interleave_memory_v2(start, size, _numa_interleave_bitmask);\n-      } else if (_numa_membind_bitmask != NULL) {\n-        _numa_interleave_memory_v2(start, size, _numa_membind_bitmask);\n-      }\n-    } else if (_numa_interleave_memory != NULL) {\n-      _numa_interleave_memory(start, size, _numa_all_nodes);\n-    }\n-  }\n-  static void numa_set_preferred(int node) {\n-    if (_numa_set_preferred != NULL) {\n-      _numa_set_preferred(node);\n-    }\n-  }\n-  static void numa_set_bind_policy(int policy) {\n-    if (_numa_set_bind_policy != NULL) {\n-      _numa_set_bind_policy(policy);\n-    }\n-  }\n-  static int numa_distance(int node1, int node2) {\n-    return _numa_distance != NULL ? _numa_distance(node1, node2) : -1;\n-  }\n-  static long numa_move_pages(int pid, unsigned long count, void **pages, const int *nodes, int *status, int flags) {\n-    return _numa_move_pages != NULL ? _numa_move_pages(pid, count, pages, nodes, status, flags) : -1;\n-  }\n-  static int get_node_by_cpu(int cpu_id);\n-  static int get_existing_num_nodes();\n-  \/\/ Check if numa node is configured (non-zero memory node).\n-  static bool is_node_in_configured_nodes(unsigned int n) {\n-    if (_numa_bitmask_isbitset != NULL && _numa_all_nodes_ptr != NULL) {\n-      return _numa_bitmask_isbitset(_numa_all_nodes_ptr, n);\n-    } else\n-      return false;\n-  }\n-  \/\/ Check if numa node exists in the system (including zero memory nodes).\n-  static bool is_node_in_existing_nodes(unsigned int n) {\n-    if (_numa_bitmask_isbitset != NULL && _numa_nodes_ptr != NULL) {\n-      return _numa_bitmask_isbitset(_numa_nodes_ptr, n);\n-    } else if (_numa_bitmask_isbitset != NULL && _numa_all_nodes_ptr != NULL) {\n-      \/\/ Not all libnuma API v2 implement numa_nodes_ptr, so it's not possible\n-      \/\/ to trust the API version for checking its absence. On the other hand,\n-      \/\/ numa_nodes_ptr found in libnuma 2.0.9 and above is the only way to get\n-      \/\/ a complete view of all numa nodes in the system, hence numa_nodes_ptr\n-      \/\/ is used to handle CPU and nodes on architectures (like PowerPC) where\n-      \/\/ there can exist nodes with CPUs but no memory or vice-versa and the\n-      \/\/ nodes may be non-contiguous. For most of the architectures, like\n-      \/\/ x86_64, numa_node_ptr presents the same node set as found in\n-      \/\/ numa_all_nodes_ptr so it's possible to use numa_all_nodes_ptr as a\n-      \/\/ substitute.\n-      return _numa_bitmask_isbitset(_numa_all_nodes_ptr, n);\n-    } else\n-      return false;\n-  }\n-  \/\/ Check if node is in bound node set.\n-  static bool is_node_in_bound_nodes(int node) {\n-    if (_numa_bitmask_isbitset != NULL) {\n-      if (is_running_in_interleave_mode()) {\n-        return _numa_bitmask_isbitset(_numa_interleave_bitmask, node);\n-      } else {\n-        return _numa_membind_bitmask != NULL ? _numa_bitmask_isbitset(_numa_membind_bitmask, node) : false;\n-      }\n-    }\n-    return false;\n-  }\n-  \/\/ Check if bound to only one numa node.\n-  \/\/ Returns true if bound to a single numa node, otherwise returns false.\n-  static bool is_bound_to_single_node() {\n-    int nodes = 0;\n-    unsigned int node = 0;\n-    unsigned int highest_node_number = 0;\n-\n-    if (_numa_membind_bitmask != NULL && _numa_max_node != NULL && _numa_bitmask_isbitset != NULL) {\n-      highest_node_number = _numa_max_node();\n-    } else {\n-      return false;\n-    }\n-\n-    for (node = 0; node <= highest_node_number; node++) {\n-      if (_numa_bitmask_isbitset(_numa_membind_bitmask, node)) {\n-        nodes++;\n-      }\n-    }\n-\n-    if (nodes == 1) {\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  static const GrowableArray<int>* numa_nindex_to_node() {\n-    return _nindex_to_node;\n-  }\n-};\n+\/\/ If you want to use any member of the os::Linux class, you need to\n+\/\/ explicitly include os_linux.impl.hpp.\n+class Linux;\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":3,"deletions":401,"binary":false,"changes":404,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef OS_LINUX_OS_LINUX_HPP\n-#define OS_LINUX_OS_LINUX_HPP\n+#ifndef OS_LINUX_OS_LINUX_IMPL_HPP\n+#define OS_LINUX_OS_LINUX_IMPL_HPP\n@@ -28,1 +28,1 @@\n-\/\/ Linux_OS defines the interface to Linux operating systems\n+#include \"runtime\/os.hpp\"\n@@ -30,2 +30,1 @@\n-\/\/ Information about the protection of the page at address '0' on this os.\n-static bool zero_page_read_protected() { return true; }\n+\/\/ os::Linux defines the interface to Linux operating systems\n@@ -33,1 +32,1 @@\n-class Linux {\n+class os::Linux {\n@@ -433,1 +432,1 @@\n-#endif \/\/ OS_LINUX_OS_LINUX_HPP\n+#endif \/\/ OS_LINUX_OS_LINUX_IMPL_HPP\n","filename":"src\/hotspot\/os\/linux\/os_linux.impl.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"previous_filename":"src\/hotspot\/os\/linux\/os_linux.hpp","status":"copied"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"os_linux.impl.hpp\"\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"os_linux.impl.hpp\"\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#ifdef LINUX\n@@ -29,1 +28,0 @@\n-#endif\n@@ -54,0 +52,4 @@\n+#ifdef LINUX\n+#include \"os_linux.impl.hpp\"\n+#endif\n+\n@@ -1122,2 +1124,2 @@\n-#if !defined(AIX) && !defined(__APPLE__)\n-    \/\/ bsd and aix don't have this\n+#ifdef LINUX\n+    \/\/ This only works with os::Linux::manually_expand_stack()\n@@ -1141,1 +1143,1 @@\n-#endif \/\/ AIX or BSD\n+#endif \/\/ LINUX\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,4 @@\n+#if defined(LINUX)\n+#include \"os_linux.impl.hpp\"\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"os_linux.impl.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"os_linux.impl.hpp\"\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}