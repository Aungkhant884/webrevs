{"files":[{"patch":"@@ -3667,3 +3667,4 @@\n-     * class is {@code java.lang.Record}. A record class has (possibly zero)\n-     * record components, that is, {@link #getRecordComponents()} returns a\n-     * non-null value.\n+     * class is {@code java.lang.Record}. A record class is\n+     * {@link Modifier#FINAL final}. A record class has (possibly zero) record\n+     * components, that is, {@link #getRecordComponents()} returns a non-null\n+     * value.\n@@ -3679,1 +3680,3 @@\n-        return getSuperclass() == java.lang.Record.class && isRecord0();\n+        return getSuperclass() == java.lang.Record.class &&\n+                (this.getModifiers() & Modifier.FINAL) != 0 &&\n+                isRecord0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255560\n+ * @summary Class::isRecord should check that the current class is final and not abstract\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/test\/lib\n+ * @run testng\/othervm IsRecordTest\n+ * @run testng\/othervm\/java.security.policy=allPermissions.policy IsRecordTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.List;\n+import java.util.Map;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.test.lib.ByteCodeLoader;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+import static jdk.internal.org.objectweb.asm.ClassWriter.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class IsRecordTest {\n+\n+    @DataProvider(name = \"scenarios\")\n+    public Object[][] scenarios() {\n+        return new Object[][] {\n+             \/\/ isFinal, isAbstract, extendJLR, withRecAttr, expectIsRecord\n+             {     false,    false,     false,    true,      false    },\n+             {     false,    false,     true,     true,      false    },\n+             {     false,    true,      false,    true,      false    },\n+             {     false,    true,      true,     true,      false    },\n+             {     true,     false,     false,    true,      false    },\n+             {     true,     false,     true,     true,      true     },\n+\n+             {     false,    false,     false,    false,     false    },\n+             {     false,    false,     true,     false,     false    },\n+             {     false,    true,      false,    false,     false    },\n+             {     false,    true,      true,     false,     false    },\n+             {     true,     false,     false,    false,     false    },\n+             {     true,     false,     true,     false,     false    },\n+        };\n+    }\n+\n+    \/**\n+     * Tests the valid combinations of i) final\/non-final, ii) abstract\/non-abstract,\n+     * iii) direct subclass of j.l.Record (or not), along with the presence or\n+     * absence of a record attribute.\n+     *\/\n+    @Test(dataProvider = \"scenarios\")\n+    public void testDirectSubClass(boolean isFinal,\n+                                   boolean isAbstract,\n+                                   boolean extendsJLR,\n+                                   boolean withRecordAttr,\n+                                   boolean expectIsRecord) throws Exception {\n+        out.println(\"\\n--- testDirectSubClass isFinal=%s, isAbstract=%s, extendsJLR=%s, withRecordAttr=%s, expectIsRecord=%s ---\"\n+                .formatted(isFinal, isAbstract, extendsJLR, withRecordAttr, expectIsRecord));\n+\n+        List<RecordComponentEntry> rc = null;\n+        if (withRecordAttr)\n+            rc = List.of(new RecordComponentEntry(\"x\", \"I\"));\n+        String superName = extendsJLR ? \"java\/lang\/Record\" : \"java\/lang\/Object\";\n+        var classBytes = generateClassBytes(\"C\", isFinal, isAbstract, superName, rc);\n+        Class<?> cls = ByteCodeLoader.load(\"C\", classBytes);\n+        out.println(\"cls=%s, Record::isAssignable=%s, isRecord=%s\"\n+                .formatted(cls, Record.class.isAssignableFrom(cls), cls.isRecord()));\n+        assertEquals(cls.isRecord(), expectIsRecord);\n+        var getRecordComponents = cls.getRecordComponents();\n+        assertTrue(expectIsRecord ? getRecordComponents != null : getRecordComponents == null);\n+    }\n+\n+    \/**\n+     * Tests the valid combinations of i) final\/non-final, ii) abstract\/non-abstract,\n+     * along with the presence or absence of a record attribute, where the class has\n+     * a superclass whose superclass is j.l.Record.\n+     *\/\n+    @Test(dataProvider = \"scenarios\")\n+    public void testIndirectSubClass(boolean isFinal,\n+                                     boolean isAbstract,\n+                                     boolean unused1,\n+                                     boolean withRecordAttr,\n+                                     boolean unused2) throws Exception {\n+        out.println(\"\\n--- testIndirectSubClass isFinal=%s, isAbstract=%s withRecordAttr=%s ---\"\n+                .formatted(isFinal, isAbstract, withRecordAttr));\n+\n+        List<RecordComponentEntry> rc = null;\n+        if (withRecordAttr)\n+            rc = List.of(new RecordComponentEntry(\"x\", \"I\"));\n+        var supFooClassBytes = generateClassBytes(\"SupFoo\", false, isAbstract, \"java\/lang\/Record\", rc);\n+        var subFooClassBytes = generateClassBytes(\"SubFoo\", isFinal, isAbstract, \"SupFoo\", rc);\n+        var allClassBytes = Map.of(\"SupFoo\", supFooClassBytes,\n+                                   \"SubFoo\", subFooClassBytes);\n+\n+        ClassLoader loader = new ByteCodeLoader(allClassBytes, null);\n+        Class<?> supFooCls = loader.loadClass(\"SupFoo\");\n+        Class<?> subFooCls = loader.loadClass(\"SubFoo\");\n+        for (var cls : List.of(supFooCls, subFooCls))\n+            out.println(\"cls=%s, Record::isAssignable=%s, isRecord=%s\"\n+                    .formatted(cls, Record.class.isAssignableFrom(cls), cls.isRecord()));\n+        assertFalse(supFooCls.isRecord());\n+        assertFalse(subFooCls.isRecord());\n+        assertEquals(supFooCls.getRecordComponents(), null);\n+        assertEquals(subFooCls.getRecordComponents(), null);\n+    }\n+\n+    \/** Tests record-ness properties of traditionally compiled classes. *\/\n+    @Test\n+    public void testBasicRecords() {\n+        out.println(\"\\n--- testBasicRecords ---\");\n+        record EmptyRecord () { }\n+        assertTrue(EmptyRecord.class.isRecord());\n+        assertEquals(EmptyRecord.class.getRecordComponents().length, 0);\n+\n+        record FooRecord (int x) { }\n+        assertTrue(FooRecord.class.isRecord());\n+        assertTrue(FooRecord.class.getRecordComponents() != null);\n+\n+        final record FinalFooRecord (int x) { }\n+        assertTrue(FinalFooRecord.class.isRecord());\n+        assertTrue(FinalFooRecord.class.getRecordComponents() != null);\n+\n+        class A { }\n+        assertFalse(A.class.isRecord());\n+        assertFalse(A.class.getRecordComponents() != null);\n+\n+        final class B { }\n+        assertFalse(B.class.isRecord());\n+        assertFalse(B.class.getRecordComponents() != null);\n+    }\n+\n+    \/\/ --  infra\n+\n+    \/\/ Generates a class with the given properties.\n+    byte[] generateClassBytes(String className,\n+                              boolean isFinal,\n+                              boolean isAbstract,\n+                              String superName,\n+                              List<RecordComponentEntry> components) {\n+        ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+\n+        int access = 0;\n+        if (isFinal)\n+            access = access | Opcodes.ACC_FINAL;\n+        if (isAbstract)\n+            access = access | Opcodes.ACC_ABSTRACT;\n+\n+        cw.visit(Opcodes.V16,\n+                 access,\n+                 className,\n+                 null,\n+                 superName,\n+                 null);\n+\n+        if (components != null)\n+            components.forEach(rc -> cw.visitRecordComponent(rc.name(), rc.descriptor(), null));\n+\n+        cw.visitEnd();\n+        return cw.toByteArray();\n+    }\n+\n+    record RecordComponentEntry (String name, String descriptor) { }\n+\n+    static byte[] classBytes(Class<?> cls) {\n+        try {\n+            return cls.getClassLoader().getResourceAsStream(cls.getName() + \".class\").readAllBytes();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/IsRecordTest.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @compile --enable-preview -source ${jdk.version} RecordPermissionsTest.java\n- * @run testng\/othervm\/java.security.policy=allPermissions.policy --enable-preview RecordPermissionsTest\n+ * @run testng\/othervm\/java.security.policy=allPermissions.policy RecordPermissionsTest\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordPermissionsTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} RecordReflectionTest.java\n- * @run testng\/othervm --enable-preview RecordReflectionTest\n- * @run testng\/othervm\/java.security.policy=allPermissions.policy --enable-preview RecordReflectionTest\n+ * @run testng\/othervm RecordReflectionTest\n+ * @run testng\/othervm\/java.security.policy=allPermissions.policy RecordReflectionTest\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordReflectionTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -38,3 +40,8 @@\n-    private final String className;\n-    private final byte[] byteCode;\n-    private volatile Class<?> holder;\n+    private final Map<String,byte[]> classBytesMap;\n+    private final Map<String,Class<?>> cache;\n+\n+    public ByteCodeLoader(Map<String,byte[]> classBytesMap, ClassLoader parent) {\n+        super(parent);\n+        this.classBytesMap = classBytesMap;\n+        cache = new ConcurrentHashMap<>();\n+    }\n@@ -51,2 +58,3 @@\n-        this.className = className;\n-        this.byteCode = byteCode;\n+        super();\n+        classBytesMap = Map.of(className, byteCode);\n+        cache = new ConcurrentHashMap<>();\n@@ -62,0 +70,1 @@\n+     * @param parent The parent class loader for delegation\n@@ -64,3 +73,1 @@\n-        super(parent);\n-        this.className = className;\n-        this.byteCode = byteCode;\n+        this(Map.of(className, byteCode), parent);\n@@ -71,1 +78,1 @@\n-        if (!name.equals(className)) {\n+        if (classBytesMap.get(name) == null) {\n@@ -74,8 +81,1 @@\n-        if (holder == null) {\n-            synchronized(this) {\n-                if (holder == null) {\n-                    holder = findClass(name);\n-                }\n-            }\n-        }\n-        return holder;\n+        return cache.computeIfAbsent(name, k -> findClass(k) );\n@@ -85,3 +85,4 @@\n-    protected Class<?> findClass(String name) throws ClassNotFoundException {\n-        if (!name.equals(className)) {\n-            throw new ClassNotFoundException(name);\n+    protected Class<?> findClass(String name)  {\n+        byte[] byteCode = classBytesMap.get(name);\n+        if (byteCode == null) {\n+            throw new AssertionError(name);\n@@ -89,1 +90,0 @@\n-\n","filename":"test\/lib\/jdk\/test\/lib\/ByteCodeLoader.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"}]}