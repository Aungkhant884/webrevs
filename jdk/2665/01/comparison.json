{"files":[{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;\n+import jdk.javadoc.internal.doclets.toolkit.Messages;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFile;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+\n+\/**\n+ * A class to write {@link HtmlDocument} objects using tasks of an {@link ExecutorService}.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class BackgroundWriter {\n+\n+    \/**\n+     * The number of background threads to create, to write out files.\n+     * Just one thread is created, primarily because one is enough.\n+     * Experiments show that the utilization of this thread is currently\n+     * about 8%, meaning we cannot generate pages fast enough to\n+     * warrant more threads. This may change if we ever start to\n+     * generate pages on multiple threads.\n+     *\/\n+    private static final int DEFAULT_BACKGROUND_THREADS = 1;\n+\n+    \/**\n+     * The number of tasks awaiting execution.\n+     * Since we currently consume (execute) tasks faster than we can\n+     * produce them, there is no point in queuing any additional tasks.\n+     * That just uses up memory, and so has a regressive impact on\n+     * performance, by causing more GC cycles.\n+     *\/\n+    private static final int DEFAULT_QUEUED_TASKS = DEFAULT_BACKGROUND_THREADS;\n+\n+    \/**\n+     * Options to configure the background writer.\n+     * This is an internal class, for testing only.\n+     * The default options should be sufficient for normal use.\n+     *\/\n+    static class Options {\n+        public boolean enabled = true;\n+        public boolean verbose = false;\n+        public int backgroundThreads = DEFAULT_BACKGROUND_THREADS;\n+        public int queuedTasks = DEFAULT_QUEUED_TASKS;\n+\n+        public boolean process(Messages messages, String opts) {\n+            boolean ok = true;\n+            for (String opt : opts.split(\",\")) {\n+                String value;\n+                int sep = opt.indexOf(\"=\");\n+                if (sep == -1) {\n+                    value = null;\n+                } else {\n+                    value = opt.substring(sep + 1);\n+                    opt = opt.substring(0, sep);\n+                }\n+                switch (opt) {\n+                    case \"off\" -> enabled = false;\n+                    case \"verbose\" -> verbose = true;\n+                    case \"queue\" -> {\n+                        if (value == null) {\n+                            messages.error(\"doclet.bgWriter.no_value\", opt);\n+                            ok = false;\n+                        } else if (value.matches(\"[0-9]+\")) { \/\/ 0 or more\n+                            queuedTasks = Integer.parseInt(value);\n+                        } else {\n+                            messages.error(\"doclet.bgWriter.bad_value\", opt, value);\n+                            ok = false;\n+                        }\n+                    }\n+                    case \"threads\" -> {\n+                        if (value == null) {\n+                            messages.error(\"doclet.bgWriter.no_value\", opt);\n+                            ok = false;\n+                        } else if (value.matches(\"[1-9]+\")) { \/\/ 1 or more\n+                            backgroundThreads = Integer.parseInt(value);\n+                        } else {\n+                            messages.error(\"doclet.bgWriter.bad_value\", opt, value);\n+                            ok = false;\n+                        }\n+                    }\n+                    default -> {\n+                        messages.warning(\"doclet.bgWriter.unknown_option\", opt);\n+                        ok = false;\n+                    }\n+                }\n+            }\n+            return ok;\n+        }\n+    }\n+\n+    \/**\n+     * A messages object, used to write messages should any errors occur.\n+     * Note that because the errors are handled here, and not passed up\n+     * to the AbstractDoclet, we cannot dump the stack in the case of\n+     * an error, although we could set a flag to do so, if necessary.\n+     *\/\n+    private final Messages messages;\n+\n+    \/**\n+     * The executor for the background tasks.\n+     *\/\n+    private final ExecutorService executor;\n+\n+    \/**\n+     * A semaphore to help restrict the number of queued and active tasks.\n+     * See \"Java Concurrency In Practice\", by Brian Goetz et al,\n+     * 8.3.3: Saturation Policies (last paragraph) and\n+     * Listing 8.4: Using a Semaphore to throttle task submission.\n+     *\/\n+    private final Semaphore semaphore;\n+\n+    \/\/ The following members are just used to help monitor execution.\n+\n+    \/**\n+     * The options used to configure the writer.\n+     *\/\n+    private final Options options;\n+\n+    \/**\n+     * Indicates whether tasks have been submitted to the executor.\n+     * Set when the first task is scheduled, at which point {@link #start}\n+     * will be initialized.\n+     *\/\n+    private boolean started;\n+\n+    \/**\n+     * The time, in nanos, at which the writer accepts the first task.\n+     * Used to help compute the utilization of the threads.\n+     *\/\n+    private long start;\n+\n+    \/**\n+     * The cumulative time, in nanos, spent writing documents.\n+     *\/\n+    private final AtomicLong taskBusy = new AtomicLong(0);\n+\n+    \/**\n+     * Whether to report additional information, such as the overall utilization of the\n+     * executor.\n+     *\/\n+    private final boolean verbose;\n+\n+    \/**\n+     * Creates a {@code BackgroundWriter}.\n+     *\n+     * @implNote\n+     * The writer uses a {@link Executors#newFixedThreadPool fixed thread pool} of\n+     * {@link Options#backgroundThreads} background threads and a queue that is\n+     * restricted to {@link Options#queuedTasks} queued tasks.\n+     *\n+     * @param messages used to write out any error messages and other output\n+     * @param options  the options to configure the writer\n+     *\/\n+    public BackgroundWriter(Messages messages, Options options) {\n+        this.messages = messages;\n+        this.verbose = options.verbose;\n+        executor = Executors.newFixedThreadPool(options.backgroundThreads);\n+        semaphore = new Semaphore(options.queuedTasks + options.backgroundThreads);\n+        this.options = options;\n+    }\n+\n+    \/**\n+     * Writes the given document at some point in the future, using the internal executor.\n+     * A semaphore is used to throttle the number of requests, although in practice this\n+     * rarely takes effect, because it is quicker to write documents than to generate them.\n+     *\n+     * @param doc  the document to be written\n+     * @param file the file to which to write the document\n+     *\/\n+    public void writeLater(HtmlDocument doc, DocFile file) {\n+        if (!started) {\n+            start = System.nanoTime();\n+            started = true;\n+        }\n+\n+        try {\n+            semaphore.acquire();\n+            try {\n+                executor.execute(() -> {\n+                    try {\n+                        long taskStart  = System.nanoTime();\n+                        doc.write(file);\n+                        long taskEnd  = System.nanoTime();\n+                        taskBusy.addAndGet(taskEnd - taskStart);\n+                    } catch (DocFileIOException e) {\n+                        error(e);\n+                    } finally {\n+                        semaphore.release();\n+                    }\n+                });\n+            } catch (RejectedExecutionException e) {\n+                semaphore.release();\n+            }\n+        } catch (InterruptedException e) {\n+            messages.error(\"doclet.exception.interrupted\");\n+        }\n+\n+    }\n+\n+    \/**\n+     * Shuts down the internal executor service, releasing all resources.\n+     *\/\n+    public void finish() {\n+        try {\n+            executor.shutdown();\n+            boolean ok = executor.awaitTermination(5, TimeUnit.MINUTES);\n+            if (ok && started && verbose) {\n+                double elapsed = System.nanoTime() - start;\n+                double utilization = ((double) taskBusy.get()) \/ options.backgroundThreads \/ elapsed * 100;\n+                messages.noticeAlways(\"doclet.bgWriter.utilization\",\n+                        options.backgroundThreads, options.queuedTasks, ((int) utilization) + \"%\");\n+            }\n+\n+        } catch (InterruptedException e) {\n+            messages.error(\"doclet.exception.interrupted\");\n+        }\n+    }\n+\n+    \/**\n+     * Reports an exception that occurred on the background thread.\n+     *\n+     * @param e the exception\n+     *\/\n+    private void error(DocFileIOException e) {\n+        switch (e.mode) {\n+            case READ ->\n+                    messages.error(\"doclet.exception.read.file\",\n+                        e.fileName.getPath(), e.getCause());\n+\n+            case WRITE ->\n+                    messages.error(\"doclet.exception.write.file\",\n+                        e.fileName.getPath(), e.getCause());\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/BackgroundWriter.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -209,0 +209,1 @@\n+\n@@ -229,0 +230,2 @@\n+    protected BackgroundWriter backgroundWriter;\n+\n@@ -270,0 +273,6 @@\n+\n+        BackgroundWriter.Options bgWriterOptions = options.getBackgroundWriterOptions();\n+        if (bgWriterOptions.enabled) {\n+            backgroundWriter = new BackgroundWriter(messages, bgWriterOptions);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -380,0 +380,7 @@\n+\n+    @Override\n+    protected void finish() {\n+        if (configuration.backgroundWriter != null) {\n+            configuration.backgroundWriter.finish();\n+        }\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -479,1 +479,6 @@\n-        htmlDocument.write(DocFile.createFileForOutput(configuration, path));\n+        DocFile file = DocFile.createFileForOutput(configuration, path);\n+        if (configuration.backgroundWriter == null) {\n+            htmlDocument.write(file);\n+        } else {\n+            configuration.backgroundWriter.writeLater(htmlDocument, file);\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -182,0 +182,6 @@\n+\n+    \/**\n+     * Values for the hidden {@code --background-writer} option.\n+     *\/\n+    private BackgroundWriter.Options backgroundWriterOptions = new BackgroundWriter.Options();\n+\n@@ -450,0 +456,8 @@\n+                },\n+\n+                new Hidden(resources, \"--background-writer\", 1) {\n+                    @Override\n+                    public boolean process(String option, List<String> args) {\n+                        \/\/ delegate to BackgroundWriter\n+                        return getBackgroundWriterOptions().process(messages, args.get(0));\n+                    }\n@@ -681,0 +695,7 @@\n+\n+    \/**\n+     * Default or parsed values for the command-line option {@code --background-writer}.\n+     *\/\n+    public BackgroundWriter.Options getBackgroundWriterOptions() {\n+        return backgroundWriterOptions;\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlOptions.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -535,0 +535,12 @@\n+\n+doclet.bgWriter.unknown_option=\\\n+    Unknown option for ''--background-writer'': {0}\n+\n+doclet.bgWriter.no_value=\\\n+    No value for ''--background-writer'' option ''{0}''\n+\n+doclet.bgWriter.bad_value=\\\n+    Bad value for ''--background-writer'' option ''{0}'': {1}\n+\n+doclet.bgWriter.utilization=\\\n+    Background writer: threads: {0}, queue: {1}, utilization: {2}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -149,0 +149,3 @@\n+\n+        } finally {\n+            finish();\n@@ -283,0 +286,2 @@\n+\n+    protected void finish() { }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AbstractDoclet.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+     * The message is suppressed if the {@code -quiet} option is set.\n@@ -151,0 +152,10 @@\n+    \/**\n+     * Reports an informational notice to the doclet's reporter.\n+     * The message is not suppressed if the {@code -quiet} option is set.\n+     *\n+     * @param key the name of a resource containing the message to be printed\n+     * @param args optional arguments to be replaced in the message.\n+     *\/\n+    public void noticeAlways(String key, Object... args) {\n+        report(NOTE, resources.getText(key, args));\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/Messages.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+doclet.exception.interrupted=Interrupted!\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-    private void printError(String prefix, String msg) {\n+    private synchronized void printError(String prefix, String msg) {\n@@ -298,1 +298,1 @@\n-    private void printWarning(String prefix, String msg) {\n+    private synchronized void printWarning(String prefix, String msg) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Messager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}