{"files":[{"patch":"@@ -2435,0 +2435,13 @@\n+const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+  if (UseSVE == 0) {\n+    \/\/ ConvD2I and ConvL2F are not profitable to be vectorized on NEON, because no direct\n+    \/\/ NEON instructions support them. But the match rule support for them is profitable for\n+    \/\/ Vector API intrinsics.\n+    if ((opcode == Op_VectorCastD2X && bt == T_INT) ||\n+        (opcode == Op_VectorCastL2X && bt == T_FLOAT)) {\n+      return false;\n+    }\n+  }\n+  return match_rule_supported_vector(opcode, vlen, bt);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -984,0 +984,4 @@\n+const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+  return match_rule_supported_vector(opcode, vlen, bt);\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2168,0 +2168,4 @@\n+const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+  return match_rule_supported_vector(opcode, vlen, bt);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1818,0 +1818,4 @@\n+const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+  return match_rule_supported_vector(opcode, vlen, bt);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1508,0 +1508,4 @@\n+const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+  return match_rule_supported_vector(opcode, vlen, bt);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1696,0 +1696,4 @@\n+const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+  return match_rule_supported_vector(opcode, vlen, bt);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -328,0 +328,4 @@\n+  \/\/ Identify extra cases that we might want to vectorize automatically\n+  \/\/ And exclude cases which are not profitable to auto-vectorize.\n+  static const bool match_rule_supported_superword(int opcode, int vlen, BasicType bt);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -377,2 +377,4 @@\n-      \/\/ Map the maximal common vector\n-      if (VectorNode::implemented(n->Opcode(), cur_max_vector, bt)) {\n+      \/\/ Map the maximal common vector except conversion nodes, because we can't get\n+      \/\/ the precise basic type for conversion nodes in the stage of early analysis.\n+      if (!VectorNode::is_convert_opcode(n->Opcode()) &&\n+          VectorNode::implemented(n->Opcode(), cur_max_vector, bt)) {\n@@ -1008,0 +1010,6 @@\n+  \/\/ Check for special case where there is a type conversion between different data size.\n+  int vectsize = max_vector_size_in_def_use_chain(s);\n+  if (vectsize < max_vector_size(btype)) {\n+    vw = MIN2(vectsize * type2aelembytes(btype), vw);\n+  }\n+\n@@ -1196,1 +1204,3 @@\n-  if (Matcher::max_vector_size(bt1) < 2) {\n+  BasicType longer_bt = longer_type_for_conversion(s1);\n+  if (max_vector_size(bt1) < 2 ||\n+      (longer_bt != T_ILLEGAL && max_vector_size(longer_bt) < 2)) {\n@@ -1439,0 +1449,10 @@\n+\/\/------------------------------adjust_alignment_for_type_conversion---------------------------------\n+\/\/ Adjust the target alignment if conversion between different data size exists in def-use nodes.\n+int SuperWord::adjust_alignment_for_type_conversion(Node* s, Node* t, int align) {\n+  if (longer_type_for_conversion(s) != T_ILLEGAL ||\n+      longer_type_for_conversion(t) != T_ILLEGAL) {\n+    align = align \/ data_size(s) * data_size(t);\n+  }\n+  return align;\n+}\n+\n@@ -1450,2 +1470,1 @@\n-  int align = alignment(s1);\n-  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, align);)\n+  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, alignment(s1));)\n@@ -1456,0 +1475,1 @@\n+    int align = alignment(s1);\n@@ -1460,0 +1480,1 @@\n+    align = adjust_alignment_for_type_conversion(s1, t1, align);\n@@ -1503,1 +1524,3 @@\n-      if (stmts_can_pack(t1, t2, align)) {\n+      int adjusted_align = alignment(s1);\n+      adjusted_align = adjust_alignment_for_type_conversion(s1, t1, adjusted_align);\n+      if (stmts_can_pack(t1, t2, adjusted_align)) {\n@@ -1509,0 +1532,1 @@\n+          align = adjusted_align;\n@@ -1701,2 +1725,1 @@\n-      BasicType bt = velt_basic_type(p1->at(0));\n-      uint max_vlen = max_vector_size(bt); \/\/ Max elements in vector\n+      uint max_vlen = max_vector_size_in_def_use_chain(p1->at(0)); \/\/ Max elements in vector\n@@ -2025,0 +2048,2 @@\n+    } else if (VectorNode::is_convert_opcode(opc)) {\n+      retValue = VectorCastNode::implemented(opc, size, velt_basic_type(p0->in(1)), velt_basic_type(p0));\n@@ -2619,2 +2644,1 @@\n-      } else if (opc == Op_ConvI2F || opc == Op_ConvL2D ||\n-                 opc == Op_ConvF2I || opc == Op_ConvD2L) {\n+      } else if (VectorNode::is_convert_opcode(opc)) {\n@@ -2623,1 +2647,0 @@\n-        int vopc = VectorNode::opcode(opc, bt);\n@@ -2625,0 +2648,1 @@\n+        int vopc = VectorCastNode::opcode(in->bottom_type()->is_vect()->element_basic_type());\n@@ -3137,1 +3161,0 @@\n-\n@@ -3140,0 +3163,18 @@\n+\n+  if (longer_type_for_conversion(use) != T_ILLEGAL) {\n+    \/\/ type conversion takes a type of a kind of size and produces a type of\n+    \/\/ another size - hence the special checks on alignment and size.\n+    for (uint i = 0; i < u_pk->size(); i++) {\n+      Node* ui = u_pk->at(i);\n+      Node* di = d_pk->at(i);\n+      if (ui->in(u_idx) != di) {\n+        return false;\n+      }\n+      if (alignment(ui) \/ type2aelembytes(velt_basic_type(ui)) !=\n+          alignment(di) \/ type2aelembytes(velt_basic_type(di))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n@@ -3372,0 +3413,57 @@\n+BasicType SuperWord::longer_type_for_conversion(Node* n) {\n+  int opcode = n->Opcode();\n+  switch (opcode) {\n+    case Op_ConvD2I:\n+    case Op_ConvI2D:\n+    case Op_ConvF2D:\n+    case Op_ConvD2F: return T_DOUBLE;\n+    case Op_ConvF2L:\n+    case Op_ConvL2F:\n+    case Op_ConvL2I:\n+    case Op_ConvI2L: return T_LONG;\n+    case Op_ConvI2F: {\n+      BasicType src_t = velt_basic_type(n->in(1));\n+      if (src_t == T_BYTE || src_t == T_SHORT) {\n+        return T_FLOAT;\n+      }\n+      return T_ILLEGAL;\n+    }\n+    case Op_ConvF2I: {\n+      BasicType dst_t = velt_basic_type(n);\n+      if (dst_t == T_BYTE || dst_t == T_SHORT) {\n+        return T_FLOAT;\n+      }\n+      return T_ILLEGAL;\n+    }\n+  }\n+  return T_ILLEGAL;\n+}\n+\n+int SuperWord::max_vector_size_in_def_use_chain(Node* n) {\n+  BasicType bt = velt_basic_type(n);\n+  BasicType vt = bt;\n+\n+  \/\/ find the longest type among def nodes.\n+  uint start, end;\n+  VectorNode::vector_operands(n, &start, &end);\n+  for (uint i = start; i < end; ++i) {\n+    Node* input = n->in(i);\n+    if (!in_bb(input)) continue;\n+    BasicType newt = longer_type_for_conversion(input);\n+    vt = (newt == T_ILLEGAL) ? vt : newt;\n+  }\n+\n+  \/\/ find the longest type among use nodes.\n+  for (uint i = 0; i < n->outcnt(); ++i) {\n+    Node* output = n->raw_out(i);\n+    if (!in_bb(output)) continue;\n+    BasicType newt = longer_type_for_conversion(output);\n+    vt = (newt == T_ILLEGAL) ? vt : newt;\n+  }\n+\n+  int max = max_vector_size(vt);\n+  \/\/ If now there is no vectors for the longest type, the nodes with the longest\n+  \/\/ type in the def-use chain are not packed in SuperWord::stmts_can_pack.\n+  return max < 2 ? max_vector_size(bt) : max;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":110,"deletions":12,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -521,0 +521,1 @@\n+  int adjust_alignment_for_type_conversion(Node* s, Node* t, int align);\n@@ -574,0 +575,4 @@\n+  \/\/ Return the longer type for type-conversion node and return illegal type for other nodes.\n+  BasicType longer_type_for_conversion(Node* n);\n+  \/\/ Find the longest type in def-use chain for packed nodes, and then compute the max vector size.\n+  int max_vector_size_in_def_use_chain(Node* n);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -251,8 +251,0 @@\n-  case Op_ConvI2F:\n-    return Op_VectorCastI2X;\n-  case Op_ConvL2D:\n-    return Op_VectorCastL2X;\n-  case Op_ConvF2I:\n-    return Op_VectorCastF2X;\n-  case Op_ConvD2L:\n-    return Op_VectorCastD2X;\n@@ -271,0 +263,3 @@\n+    assert(!VectorNode::is_convert_opcode(sopc),\n+           \"Convert node %s should be processed by VectorCastNode::opcode()\",\n+           NodeClassNames[sopc]);\n@@ -318,1 +313,1 @@\n-    return vopc > 0 && Matcher::match_rule_supported_vector(vopc, vlen, bt);\n+    return vopc > 0 && Matcher::match_rule_supported_superword(vopc, vlen, bt);\n@@ -463,0 +458,20 @@\n+bool VectorNode::is_convert_opcode(int opc) {\n+  switch (opc) {\n+    case Op_ConvI2F:\n+    case Op_ConvL2D:\n+    case Op_ConvF2I:\n+    case Op_ConvD2L:\n+    case Op_ConvI2D:\n+    case Op_ConvL2F:\n+    case Op_ConvL2I:\n+    case Op_ConvI2L:\n+    case Op_ConvF2L:\n+    case Op_ConvD2F:\n+    case Op_ConvF2D:\n+    case Op_ConvD2I:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -1235,1 +1250,1 @@\n-      assert(false, \"unknown type: %s\", type2name(bt));\n+      assert(bt == T_CHAR || bt == T_BOOLEAN, \"unknown type: %s\", type2name(bt));\n@@ -1240,0 +1255,10 @@\n+bool VectorCastNode::implemented(int opc, uint vlen, BasicType src_type, BasicType dst_type) {\n+  if (is_java_primitive(dst_type) &&\n+      (vlen > 1) && is_power_of_2(vlen) &&\n+      VectorNode::vector_size_supported(dst_type, vlen)) {\n+    int vopc = VectorCastNode::opcode(src_type);\n+    return vopc > 0 && Matcher::match_rule_supported_superword(vopc, vlen, dst_type);\n+  }\n+  return false;\n+}\n+\n@@ -1329,1 +1354,1 @@\n-    return vopc != opc && Matcher::match_rule_supported_vector(vopc, vlen, bt);\n+    return vopc != opc && Matcher::match_rule_supported_superword(vopc, vlen, bt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+  static bool is_convert_opcode(int opc);\n@@ -1523,1 +1524,1 @@\n-  static bool implemented(BasicType bt, uint vlen);\n+  static bool implemented(int opc, uint vlen, BasicType src_type, BasicType dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8283091\n+ * @summary Auto-vectorization enhancement for type conversion between different data sizes.\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") | os.arch==\"aarch64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestVectorizeTypeConversion\n+ *\/\n+\n+public class TestVectorizeTypeConversion {\n+\n+    final private static int SIZE = 3000;\n+\n+    private static double[] doublea = new double[SIZE];\n+    private static double[] doubleb = new double[SIZE];\n+    private static long[] longa = new long[SIZE];\n+    private static long[] longb = new long[SIZE];\n+    private static int[] inta = new int[SIZE];\n+    private static int[] intb = new int[SIZE];\n+    private static float[] floata = new float[SIZE];\n+    private static float[] floatb = new float[SIZE];\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\",\n+                  IRNode.VECTOR_CAST_I2X, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"})\n+    private static void testConvI2D(double[] d, int[] a) {\n+        for(int i = 0; i < d.length; i++) {\n+            d[i] = (double) (a[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\",\n+                  IRNode.VECTOR_CAST_I2X, \">0\",\n+                  IRNode.VECTOR_CAST_L2X, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"})\n+    private static void testConvI2L(int[] d1, int d2[], long[] a1, long[] a2) {\n+        for(int i = 0; i < d1.length; i++) {\n+            d1[i] = (int) (a1[i]);\n+            a2[i] = (long) (d2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\",\n+                  IRNode.VECTOR_CAST_D2X, \">0\",\n+                  IRNode.VECTOR_CAST_F2X, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"})\n+    private static void testConvF2D(double[] d1, double[] d2, float[] a1, float[] a2) {\n+        for(int i = 0; i < d1.length; i++) {\n+            d1[i] = (double) (a1[i]);\n+            a2[i] = (float) (d2[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testConvI2D\", \"testConvI2L\", \"testConvF2D\"})\n+    private void test_runner() {\n+        testConvI2D(doublea, inta);\n+        testConvI2L(inta, intb, longa, longb);\n+        testConvF2D(doublea, doubleb, floata, floatb);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizeTypeConversion.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,26 @@\n+  private static final byte[] bspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, (byte)0x80, (byte)0x81, (byte)0x8F,\n+    (byte)0xF3, (byte)0xF8, (byte)0xFF, (byte)0x38FF, (byte)0x3FFF,\n+    (byte)0xFFFF, (byte)Integer.MAX_VALUE, (byte)Integer.MIN_VALUE\n+  };\n+\n+  private static final double[] dspecial = {\n+    0.0,\n+    -0.0,\n+    Double.MAX_VALUE,\n+    Double.MIN_VALUE,\n+    -Double.MAX_VALUE,\n+    -Double.MIN_VALUE,\n+    Double.NaN,\n+    Double.POSITIVE_INFINITY,\n+    Double.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n@@ -78,0 +108,2 @@\n+      test_conv_b2d(a1, b1);\n+      test_conv_d2b(a1, b1);\n@@ -341,0 +373,35 @@\n+      for (int j = 0; j < bspecial.length; j++) {\n+        byte bytevalue = bspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = bytevalue;\n+        }\n+        test_conv_b2d(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_b2d: b1\", i, b1[i], (double)bytevalue);\n+        }\n+      }\n+      for (int j = 0; j < dspecial.length; j++) {\n+        double doubleValue = dspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = doubleValue;\n+        }\n+        test_conv_d2b(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_d2b: a1\", i, a1[i], (byte)(doubleValue));\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte)r.nextInt();\n+      }\n+      test_conv_b2d(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_b2d: b1\", i, b1[i], (double)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextDouble();\n+      }\n+      test_conv_d2b(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2b: a1\", i, a1[i], (byte)b1[i]);\n+      }\n@@ -451,0 +518,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_b2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_b2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_d2b(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2b: \" + (end - start));\n@@ -560,0 +639,12 @@\n+  static void test_conv_b2d(byte[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (double) a[i];\n+    }\n+  }\n+\n+  static void test_conv_d2b(byte[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (byte) b[i];\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestByteDoubleVect.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,26 @@\n+  private static final byte[] bspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, (byte)0x80, (byte)0x81, (byte)0x8F,\n+    (byte)0xF3, (byte)0xF8, (byte)0xFF, (byte)0x38FF, (byte)0x3FFF,\n+    (byte)0xFFFF, (byte)Integer.MAX_VALUE, (byte)Integer.MIN_VALUE\n+  };\n+\n+  private static final float[] fspecial = {\n+    0.0f,\n+    -0.0f,\n+    Float.MAX_VALUE,\n+    Float.MIN_VALUE,\n+    -Float.MAX_VALUE,\n+    -Float.MIN_VALUE,\n+    Float.NaN,\n+    Float.POSITIVE_INFINITY,\n+    Float.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n@@ -78,0 +108,2 @@\n+      test_conv_b2f(a1, b1);\n+      test_conv_f2b(a1, b1);\n@@ -341,0 +373,35 @@\n+      for (int j = 0; j < bspecial.length; j++) {\n+        byte byteValue = bspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = byteValue;\n+        }\n+        test_conv_b2f(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_b2f: b1\", i, b1[i], (float)(byteValue));\n+        }\n+      }\n+      for (int j = 0; j < fspecial.length; j++) {\n+        float floatValue = fspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = floatValue;\n+        }\n+        test_conv_f2b(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_f2b: a1\", i, a1[i], (byte)floatValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte)r.nextInt();\n+      }\n+      test_conv_b2f(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_b2f: b1\", i, b1[i], (float)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextFloat();\n+      }\n+      test_conv_f2b(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2b: a1\", i, a1[i], (byte)b1[i]);\n+      }\n@@ -451,0 +518,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_b2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_b2f: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_f2b(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2b: \" + (end - start));\n@@ -560,0 +639,12 @@\n+  static void test_conv_b2f(byte[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (float) a[i];\n+    }\n+  }\n+\n+  static void test_conv_f2b(byte[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (byte) b[i];\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestByteFloatVect.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,18 @@\n+  private static final byte[] bspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, (byte)0x80, (byte)0x81, (byte)0x8F,\n+    (byte)0xF3, (byte)0xF8, (byte)0xFF, (byte)0x38FF, (byte)0x3FFF,\n+    (byte)0xFFFF, (byte)Integer.MAX_VALUE, (byte)Integer.MIN_VALUE\n+  };\n+\n+  private static final long[] lspecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +100,2 @@\n+      test_conv_b2l(a1, b1);\n+      test_conv_l2b(a1, b1);\n@@ -341,0 +365,35 @@\n+      for (int j = 0; j < bspecial.length; j++) {\n+        byte bytevalue = bspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = bytevalue;\n+        }\n+        test_conv_b2l(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_b2l: b1\", i, b1[i], (long)bytevalue);\n+        }\n+      }\n+      for (int j = 0; j < lspecial.length; j++) {\n+        long longValue = lspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = longValue;\n+        }\n+        test_conv_l2b(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_l2b: a1\", i, a1[i], (byte)longValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte)r.nextInt();\n+      }\n+      test_conv_b2l(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_b2l: b1\", i, b1[i], (long)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextLong();\n+      }\n+      test_conv_l2b(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2b: a1\", i, a1[i], (byte)b1[i]);\n+      }\n@@ -451,0 +510,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_b2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_b2l: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_l2b(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_l2b: \" + (end - start));\n@@ -560,0 +631,12 @@\n+  static void test_conv_b2l(byte[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (long) a[i];\n+    }\n+  }\n+\n+  static void test_conv_l2b(byte[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (byte) b[i];\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestByteLongVect.java","additions":85,"deletions":2,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,40 @@\n+  private static float[] fspecial = {\n+    0.0f,\n+    -0.0f,\n+    Float.MAX_VALUE,\n+    Float.MIN_VALUE,\n+    -Float.MAX_VALUE,\n+    -Float.MIN_VALUE,\n+    Float.NaN,\n+    Float.POSITIVE_INFINITY,\n+    Float.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n+  private static double[] dspecial = {\n+    0.0,\n+    -0.0,\n+    Double.MAX_VALUE,\n+    Double.MIN_VALUE,\n+    -Double.MAX_VALUE,\n+    -Double.MIN_VALUE,\n+    Double.NaN,\n+    Double.POSITIVE_INFINITY,\n+    Double.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n@@ -78,0 +122,2 @@\n+      test_conv_f2d(a1, b1);\n+      test_conv_d2f(a1, b1);\n@@ -341,0 +387,35 @@\n+      for (int j = 0; j < fspecial.length; j++) {\n+        float floatValue = fspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = floatValue;\n+        }\n+        test_conv_f2d(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_f2d: b1\", i, b1[i], (double)floatValue);\n+        }\n+      }\n+      for (int j = 0; j < dspecial.length; j++) {\n+        double doubleValue = dspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = doubleValue;\n+        }\n+        test_conv_d2f(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_d2f: a1\", i, a1[i], (float)(doubleValue));\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = r.nextFloat();\n+      }\n+      test_conv_f2d(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2d: b1\", i, b1[i], (double)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextDouble();\n+      }\n+      test_conv_d2f(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2f: a1\", i, a1[i], (float)b1[i]);\n+      }\n@@ -451,0 +532,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_f2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_d2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2f: \" + (end - start));\n@@ -560,0 +653,12 @@\n+  static void test_conv_f2d(float[] a, double[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (double) a[i];\n+    }\n+  }\n+\n+  static void test_conv_d2f(float[] a, double[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      a[i] = (float) b[i];\n+    }\n+  }\n+\n@@ -561,1 +666,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Float.isNaN(elem) && Float.isNaN(val))) {\n@@ -568,1 +673,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Double.isNaN(elem) && Double.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestFloatDoubleVect.java","additions":109,"deletions":4,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,30 @@\n+  private static double[] dspecial = {\n+    1.0,\n+    -1.0,\n+    0.0,\n+    -0.0,\n+    Double.MAX_VALUE,\n+    Double.MIN_VALUE,\n+    -Double.MAX_VALUE,\n+    -Double.MIN_VALUE,\n+    Double.NaN,\n+    Double.POSITIVE_INFINITY,\n+    Double.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n+  private static int[] ispecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE\n+  };\n+\n@@ -78,0 +112,2 @@\n+      test_conv_i2d(a1, b1);\n+      test_conv_d2i(a1, b1);\n@@ -341,1 +377,35 @@\n-\n+      for (int j = 0; j < ispecial.length; j++) {\n+        int intValue = ispecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = intValue;\n+        }\n+        test_conv_i2d(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_i2d: b1\", i, b1[i], (double)intValue);\n+        }\n+      }\n+      for (int j = 0; j < dspecial.length; j++) {\n+        double doubleValue = dspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = doubleValue;\n+        }\n+        test_conv_d2i(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_d2i: a1\", i, a1[i], (int)doubleValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = r.nextInt();\n+      }\n+      test_conv_i2d(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2d: b1\", i, b1[i], (double)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextDouble();\n+      }\n+      test_conv_d2i(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2i: a1\", i, a1[i], (int)b1[i]);\n+      }\n@@ -451,0 +521,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_i2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_i2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_d2i(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2i: \" + (end - start));\n@@ -559,0 +641,10 @@\n+  static void test_conv_i2d(int[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (double) a[i];\n+    }\n+  }\n+  static void test_conv_d2i(int[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (int)b[i];\n+    }\n+  }\n@@ -568,1 +660,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Double.isNaN(elem) && Double.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntDoubleVect.java","additions":96,"deletions":4,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,20 @@\n+  private static int[] ispecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE\n+  };\n+\n+  private static long[] lspecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +102,2 @@\n+      test_conv_i2l(a1, b1);\n+      test_conv_l2i(a1, b1);\n@@ -341,0 +367,35 @@\n+      for (int j = 0; j < ispecial.length; j++) {\n+        int intValue = ispecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = intValue;\n+        }\n+        test_conv_i2l(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_i2l: b1\", i, b1[i], (long)intValue);\n+        }\n+      }\n+      for (int j = 0; j < lspecial.length; j++) {\n+        long longValue = lspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = longValue;\n+        }\n+        test_conv_l2i(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_l2i: a1\", i, a1[i], (int)longValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = r.nextInt();\n+      }\n+      test_conv_i2l(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2l: b1\", i, b1[i], (long)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextLong();\n+      }\n+      test_conv_l2i(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2i: a1\", i, a1[i], (int)b1[i]);\n+      }\n@@ -451,0 +512,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_i2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_cp_unalnsrc: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_l2i(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_cp_unalnsrc: \" + (end - start));\n@@ -560,0 +633,11 @@\n+  static void test_conv_i2l(int[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (long)a[i];\n+    }\n+  }\n+  static void test_conv_l2i(int[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (int)b[i];\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntLongVect.java","additions":86,"deletions":2,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,34 @@\n+  private static float[] fspecial = {\n+    1.0f,\n+    -1.0f,\n+    0.0f,\n+    -0.0f,\n+    Float.MAX_VALUE,\n+    Float.MIN_VALUE,\n+    -Float.MAX_VALUE,\n+    -Float.MIN_VALUE,\n+    Float.NaN,\n+    Float.POSITIVE_INFINITY,\n+    Float.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n+  private static long[] lspecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +116,2 @@\n+      test_conv_l2f(a1, b1);\n+      test_conv_f2l(a1, b1);\n@@ -341,0 +381,35 @@\n+      for (int j = 0; j < lspecial.length; j++) {\n+        long longValue = lspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = longValue;\n+        }\n+        test_conv_l2f(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_l2f: b1\", i, b1[i], (float)longValue);\n+        }\n+      }\n+      for (int j = 0; j < fspecial.length; j++) {\n+        float floatValue = fspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = floatValue;\n+        }\n+        test_conv_f2l(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_f2l: a1\", i, a1[i], (long)floatValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = r.nextLong();\n+      }\n+      test_conv_l2f(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2f: b1\", i, b1[i], (float)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextFloat();\n+      }\n+      test_conv_f2l(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2l: a1\", i, a1[i], (long)b1[i]);\n+      }\n@@ -451,0 +526,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_f2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2l: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_l2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_l2f: \" + (end - start));\n@@ -559,0 +646,10 @@\n+  static void test_conv_l2f(long[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (float)a[i];\n+    }\n+  }\n+  static void test_conv_f2l(long[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (long)b[i];\n+    }\n+  }\n@@ -568,1 +665,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Float.isNaN(elem) && Float.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestLongFloatVect.java","additions":100,"deletions":3,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,28 @@\n+  private static final short[] sspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, 0x8F, 0xF3, 0xF8, 0xFF, 0x38FF, (short)0x8F8F,\n+    (short)0x8FFF, 0x7FF3, 0x7FFF, (short)0xFF33, (short)0xFFF8, (short)0xFFFF,\n+    (short)0xFFFFFF, (short)Integer.MAX_VALUE, (short)Integer.MIN_VALUE\n+  };\n+\n+  private static final double[] dspecial = {\n+    1.0,\n+    -1.0,\n+    0.0,\n+    -0.0,\n+    Double.MAX_VALUE,\n+    Double.MIN_VALUE,\n+    -Double.MAX_VALUE,\n+    -Double.MIN_VALUE,\n+    Double.NaN,\n+    Double.POSITIVE_INFINITY,\n+    Double.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n@@ -78,0 +110,2 @@\n+      test_conv_s2d(a1, b1);\n+      test_conv_d2s(a1, b1);\n@@ -341,1 +375,35 @@\n-\n+      for (int j = 0; j < sspecial.length; j++) {\n+        short shortValue = sspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = shortValue;\n+        }\n+        test_conv_s2d(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_s2d: b1\", i, b1[i], (double)shortValue);\n+        }\n+      }\n+      for (int j = 0; j < dspecial.length; j++) {\n+        double doubleValue = dspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = doubleValue;\n+        }\n+        test_conv_d2s(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_d2s: a1\", i, a1[i], (short)doubleValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (short)r.nextInt();\n+      }\n+      test_conv_s2d(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_s2d: b1\", i, b1[i], (double)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextDouble();\n+      }\n+      test_conv_d2s(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2s: a1\", i, a1[i], (short)b1[i]);\n+      }\n@@ -451,0 +519,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_s2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_s2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_d2s(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2s: \" + (end - start));\n@@ -559,0 +639,10 @@\n+  static void test_conv_s2d(short[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (double) a[i];\n+    }\n+  }\n+  static void test_conv_d2s(short[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (short) b[i];\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestShortDoubleVect.java","additions":93,"deletions":3,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,28 @@\n+  private static final short[] sspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, 0x8F, 0xF3, 0xF8, 0xFF, 0x38FF, (short)0x8F8F,\n+    (short)0x8FFF, 0x7FF3, 0x7FFF, (short)0xFF33, (short)0xFFF8, (short)0xFFFF,\n+    (short)0xFFFFFF, (short)Integer.MAX_VALUE, (short)Integer.MIN_VALUE\n+  };\n+\n+  private static final float[] fspecial = {\n+    1.0f,\n+    -1.0f,\n+    0.0f,\n+    -0.0f,\n+    Float.MAX_VALUE,\n+    Float.MIN_VALUE,\n+    -Float.MAX_VALUE,\n+    -Float.MIN_VALUE,\n+    Float.NaN,\n+    Float.POSITIVE_INFINITY,\n+    Float.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +110,2 @@\n+      test_conv_s2f(a1, b1);\n+      test_conv_f2s(a1, b1);\n@@ -341,0 +375,35 @@\n+      for (int j = 0; j < sspecial.length; j++) {\n+        short shortValue = sspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = shortValue;\n+        }\n+        test_conv_s2f(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_s2f: b1\", i, b1[i], (float)(shortValue));\n+        }\n+      }\n+      for (int j = 0; j < fspecial.length; j++) {\n+        float floatValue = fspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = floatValue;\n+        }\n+        test_conv_f2s(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_f2s: a1\", i, a1[i], (short)floatValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (short)r.nextInt();\n+      }\n+      test_conv_s2f(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_s2f: b1\", i, b1[i], (float)(a1[i]));\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextFloat();\n+      }\n+      test_conv_f2s(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2s: a1\", i, a1[i], (short)(b1[i]));\n+      }\n@@ -451,0 +520,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_s2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_s2f: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_f2s(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2s: \" + (end - start));\n@@ -559,0 +640,10 @@\n+  static void test_conv_s2f(short[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (float) a[i];\n+    }\n+  }\n+  static void test_conv_f2s(short[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (short) b[i];\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestShortFloatVect.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,18 @@\n+  private static final short[] sspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, 0x8F, 0xF3, 0xF8, 0xFF, 0x38FF, (short)0x8F8F,\n+    (short)0x8FFF, 0x7FF3, 0x7FFF, (short)0xFF33, (short)0xFFF8, (short)0xFFFF,\n+    (short)0xFFFFFF, (short)Integer.MAX_VALUE, (short)Integer.MIN_VALUE\n+  };\n+\n+  private static long[] lspecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +100,2 @@\n+      test_conv_s2l(a1, b1);\n+      test_conv_l2s(a1, b1);\n@@ -341,1 +365,35 @@\n-\n+      for (int j = 0; j < sspecial.length; j++) {\n+        short shortValue = sspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = shortValue;\n+        }\n+        test_conv_s2l(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_s2l: b1\", i, b1[i], (long)(shortValue));\n+        }\n+      }\n+      for (int j = 0; j < lspecial.length; j++) {\n+        long longValue = lspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = longValue;\n+        }\n+        test_conv_l2s(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_l2s: a1\", i, a1[i], (short)longValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (short)r.nextInt();\n+      }\n+      test_conv_s2l(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_s2l: b1\", i, b1[i], (long)(a1[i]));\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextLong();\n+      }\n+      test_conv_l2s(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2s: a1\", i, a1[i], (short)b1[i]);\n+      }\n@@ -451,0 +509,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_s2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_s2l: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_l2s(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_l2s: \" + (end - start));\n@@ -559,0 +629,10 @@\n+  static void test_conv_s2l(short[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (long) a[i];\n+    }\n+  }\n+  static void test_conv_l2s(short[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (short) b[i];\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestShortLongVect.java","additions":83,"deletions":3,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,1 +199,1 @@\n-    public void convert_i2f() {\n+    public void convertB2D() {\n@@ -201,1 +201,36 @@\n-            resF[i] = (float) ints[i];\n+            resD[i] = (double) bytesA[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertB2F() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = (float) bytesA[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertB2L() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = (long) bytesA[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertD2B() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resB[i] = (byte) doubles[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertD2F() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = (float) doubles[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertD2I() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) doubles[i];\n@@ -206,1 +241,15 @@\n-    public void convert_f2i() {\n+    public void convertD2S() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resS[i] = (short) doubles[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertD2L() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = (long) doubles[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertF2I() {\n@@ -213,1 +262,50 @@\n-    public void convert_l2d() {\n+    public void convertF2B() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resB[i] = (byte) floats[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertF2D() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = (double) floats[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertF2L() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = (long) floats[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertF2S() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resS[i] = (short) floats[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertI2F() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = (float) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertI2D() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = (double) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertI2L() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = (long) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertL2D() {\n@@ -220,1 +318,1 @@\n-    public void convert_d2l() {\n+    public void convertL2B() {\n@@ -222,1 +320,43 @@\n-            resL[i] = (long) doubles[i];\n+            resB[i] = (byte) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertL2F() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = (float) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertL2I() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertL2S() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resS[i] = (short) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertS2D() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = (double) shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertS2F() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = (float) shorts[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertS2L() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = (long) shorts[i];\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":147,"deletions":7,"binary":false,"changes":154,"status":"modified"}]}