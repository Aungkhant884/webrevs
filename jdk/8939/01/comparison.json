{"files":[{"patch":"@@ -158,0 +158,1 @@\n+JVM_IsContinuationsSupported\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+define_pd_global(bool, VMContinuations, true);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+define_pd_global(bool, VMContinuations, false);\n+\n","filename":"src\/hotspot\/cpu\/arm\/globals_arm.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+define_pd_global(bool,  VMContinuations, false);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+define_pd_global(bool, VMContinuations, false);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+define_pd_global(bool,  VMContinuations, false);\n+\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,6 @@\n+#ifdef _LP64\n+define_pd_global(bool, VMContinuations, true);\n+#else\n+define_pd_global(bool, VMContinuations, false);\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+define_pd_global(bool,  VMContinuations, false);\n+\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+  do_klass(BasicVirtualThread_klass,                    java_lang_BaseVirtualThread                           ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  template(java_lang_BaseVirtualThread,               \"java\/lang\/BaseVirtualThread\")              \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,1 +172,4 @@\n-JVM_IsPreviewEnabled(JNIEnv* env);\n+JVM_IsPreviewEnabled(void);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_IsContinuationsSupported(void);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -154,1 +154,5 @@\n-      case vmIntrinsics::_Continuation_doYield: return java_lang_continuation_doYield;\n+      case vmIntrinsics::_Continuation_doYield:\n+        if (VMContinuations) {\n+          return java_lang_continuation_doYield;\n+        }\n+        break;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -3146,1 +3147,5 @@\n-  return java_lang_VirtualThread::is_instance(thread_obj) ? JNI_TRUE : JNI_FALSE;\n+  if (thread_obj != NULL && thread_obj->is_a(vmClasses::BasicVirtualThread_klass())) {\n+    return JNI_TRUE;\n+  } else {\n+    return JNI_FALSE;\n+  }\n@@ -3990,0 +3995,7 @@\n+  \/\/ No JVM TI with --enable-preview and no continuations support.\n+  if (!VMContinuations && Arguments::enable_preview() && JvmtiExport::is_jvmti_version(version)) {\n+    *penv = NULL;\n+    ret = JNI_EVERSION;\n+    return ret;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3490,1 +3490,1 @@\n-JVM_LEAF(jboolean, JVM_IsPreviewEnabled(JNIEnv *env))\n+JVM_LEAF(jboolean, JVM_IsPreviewEnabled(void))\n@@ -3494,0 +3494,3 @@\n+JVM_LEAF(jboolean, JVM_IsContinuationsSupported(void))\n+  return VMContinuations ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -415,5 +415,1 @@\n-#if defined(AMD64) || defined(AARCH64)\n-  return Arguments::enable_preview();\n-#else\n-  return false;\n-#endif\n+  return VMContinuations && Arguments::enable_preview();\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2003,0 +2003,3 @@\n+  product_pd(bool, VMContinuations, EXPERIMENTAL,                           \\\n+          \"Enable VM continuations support\")                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -371,0 +371,13 @@\n+bool ThreadService::is_virtual_or_carrier_thread(JavaThread* jt) {\n+  oop threadObj = jt->threadObj();\n+  if (threadObj != NULL && threadObj->is_a(vmClasses::BasicVirtualThread_klass())) {\n+    \/\/ a virtual thread backed by JavaThread\n+    return true;\n+  }\n+  if (jt->is_vthread_mounted()) {\n+    \/\/ carrier thread\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -391,2 +404,3 @@\n-    if (jt->is_vthread_mounted()) continue;\n-    jt->set_depth_first_number(-1);\n+    if (!is_virtual_or_carrier_thread(jt)) {\n+      jt->set_depth_first_number(-1);\n+    }\n@@ -399,1 +413,4 @@\n-    if (jt->is_vthread_mounted()) continue;\n+    if (is_virtual_or_carrier_thread(jt)) {\n+      \/\/ skip virtual and carrier threads\n+      continue;\n+    }\n@@ -474,1 +491,1 @@\n-      if (currentThread == NULL || currentThread->is_vthread_mounted()) {\n+      if (currentThread == NULL || is_virtual_or_carrier_thread(currentThread)) {\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+  \/\/ test if the JavaThread is a virtual thread or has a mounted virtual thread\n+  static bool is_virtual_or_carrier_thread(JavaThread* jt);\n+\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang;\n+\n+\/**\n+ * Base class for virtual thread implementations.\n+ *\/\n+sealed abstract class BaseVirtualThread extends Thread\n+        permits VirtualThread, ThreadBuilders.BoundVirtualThread {\n+\n+    \/**\n+     * Initializes a virtual Thread.\n+     *\n+     * @param name thread name, can be null\n+     * @param characteristics thread characteristics\n+     * @param bound true when bound to an OS thread\n+     *\/\n+    BaseVirtualThread(String name, int characteristics, boolean bound) {\n+        super(name, characteristics, bound);\n+    }\n+\n+    \/**\n+     * Parks the current virtual thread until the parking permit is available or\n+     * the thread is interrupted.\n+     *\n+     * The behavior of this method when the current thread is not this thread\n+     * is not defined.\n+     *\/\n+    abstract void park();\n+\n+    \/**\n+     * Parks current virtual thread up to the given waiting time until the parking\n+     * permit is available or the thread is interrupted.\n+     *\n+     * The behavior of this method when the current thread is not this thread\n+     * is not defined.\n+     *\/\n+    abstract void parkNanos(long nanos);\n+\n+    \/**\n+     * Makes available the parking permit to the given this virtual thread.\n+     *\/\n+    abstract void unpark();\n+}\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/BaseVirtualThread.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2594,1 +2594,6 @@\n-                VirtualThread.park();\n+                Thread thread = Thread.currentThread();\n+                if (thread instanceof BaseVirtualThread vthread) {\n+                    vthread.park();\n+                } else {\n+                    throw new WrongThreadException();\n+                }\n@@ -2598,1 +2603,6 @@\n-                VirtualThread.parkNanos(nanos);\n+                Thread thread = Thread.currentThread();\n+                if (thread instanceof BaseVirtualThread vthread) {\n+                    vthread.parkNanos(nanos);\n+                } else {\n+                    throw new WrongThreadException();\n+                }\n@@ -2602,1 +2612,1 @@\n-                if (thread instanceof VirtualThread vthread) {\n+                if (thread instanceof BaseVirtualThread vthread) {\n@@ -2605,1 +2615,1 @@\n-                    throw new IllegalArgumentException(\"Not a virtual thread\");\n+                    throw new WrongThreadException();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -38,0 +39,2 @@\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n@@ -739,0 +742,1 @@\n+     * @param bound true when bound to an OS thread\n@@ -740,1 +744,1 @@\n-    Thread(String name, int characteristics) {\n+    Thread(String name, int characteristics, boolean bound) {\n@@ -770,2 +774,8 @@\n-        \/\/ no additional fields\n-        this.holder = null;\n+        \/\/ create a FieldHolder object, needed when bound to an OS thread\n+        if (bound) {\n+            ThreadGroup g = Constants.VTHREAD_GROUP;\n+            int pri = NORM_PRIORITY;\n+            this.holder = new FieldHolder(g, null, -1, pri, true);\n+        } else {\n+            this.holder = null;\n+        }\n@@ -1498,0 +1508,1 @@\n+        Objects.requireNonNull(task);\n@@ -1499,1 +1510,1 @@\n-        var thread = new VirtualThread(null, null, 0, task);\n+        var thread = ThreadBuilders.newVirtualThread(null, null, 0, task);\n@@ -1514,1 +1525,1 @@\n-        return (this instanceof VirtualThread);\n+        return (this instanceof BaseVirtualThread);\n@@ -2620,0 +2631,1 @@\n+            Thread thread = threads[i];\n@@ -2621,1 +2633,2 @@\n-            if (stackTrace != null) {\n+            \/\/ BoundVirtualThread objects may be in list returned by the VM\n+            if (!thread.isVirtual() && stackTrace != null) {\n@@ -2691,1 +2704,5 @@\n-        return getThreads();\n+        Thread[] threads = getThreads();\n+        return Stream.of(threads)\n+                \/\/ BoundVirtualThread objects may be in list returned by the VM\n+                .filter(Predicate.not(Thread::isVirtual))\n+                .toArray(Thread[]::new);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Locale;\n@@ -36,0 +37,2 @@\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.ContinuationSupport;\n@@ -136,0 +139,3 @@\n+        PlatformThreadBuilder() {\n+        }\n+\n@@ -206,1 +212,11 @@\n-        private Executor scheduler;  \/\/ set by tests\n+        private Executor scheduler;\n+\n+        VirtualThreadBuilder() {\n+        }\n+\n+        \/\/ invoked by tests\n+        VirtualThreadBuilder(Executor scheduler) {\n+            if (!ContinuationSupport.isSupported())\n+                throw new UnsupportedOperationException();\n+            this.scheduler = Objects.requireNonNull(scheduler);\n+        }\n@@ -211,1 +227,1 @@\n-            var thread = new VirtualThread(scheduler, nextThreadName(), characteristics(), task);\n+            var thread = newVirtualThread(scheduler, nextThreadName(), characteristics(), task);\n@@ -352,1 +368,1 @@\n-            Thread thread = new VirtualThread(scheduler, name, characteristics(), task);\n+            Thread thread = newVirtualThread(scheduler, name, characteristics(), task);\n@@ -359,0 +375,71 @@\n+\n+    \/**\n+     * Creates a new virtual thread to run the given task.\n+     *\/\n+    static Thread newVirtualThread(Executor scheduler,\n+                                   String name,\n+                                   int characteristics,\n+                                   Runnable task) {\n+        if (ContinuationSupport.isSupported()) {\n+            return new VirtualThread(scheduler, name, characteristics, task);\n+        } else {\n+            if (scheduler != null)\n+                throw new UnsupportedOperationException();\n+            return new BoundVirtualThread(name, characteristics, task);\n+        }\n+    }\n+\n+    \/**\n+     * A \"virtual thread\" that is backed by a platform thread. This implementation\n+     * is intended for platforms that don't have the underlying VM support for\n+     * continuations. It can also be used for testing.\n+     *\/\n+    static final class BoundVirtualThread extends BaseVirtualThread {\n+        private static final Unsafe U = Unsafe.getUnsafe();\n+        private final Runnable task;\n+        private boolean runInvoked;\n+\n+        BoundVirtualThread(String name, int characteristics, Runnable task) {\n+            super(name, characteristics, true);\n+            this.task = task;\n+        }\n+\n+        @Override\n+        public void run() {\n+            \/\/ run is specified to do nothing when Thread is a virtual thread\n+            if (Thread.currentThread() == this && !runInvoked) {\n+                runInvoked = true;\n+                task.run();\n+            }\n+        }\n+\n+        @Override\n+        void park() {\n+            U.park(false, 0L);\n+        }\n+\n+        @Override\n+        void parkNanos(long nanos) {\n+            U.park(false, nanos);\n+        }\n+\n+        @Override\n+        void unpark() {\n+            U.unpark(this);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder(\"VirtualThread[#\");\n+            sb.append(threadId());\n+            String name = getName();\n+            if (!name.isEmpty()) {\n+                sb.append(\",\");\n+                sb.append(name);\n+            }\n+            sb.append(\"]\/\");\n+            String stateAsString = threadState().toString();\n+            sb.append(stateAsString.toLowerCase(Locale.ROOT));\n+            return sb.toString();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadBuilders.java","additions":90,"deletions":3,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-final class VirtualThread extends Thread {\n+final class VirtualThread extends BaseVirtualThread {\n@@ -151,1 +151,1 @@\n-        super(name, characteristics);\n+        super(name, characteristics, \/*bound*\/ false);\n@@ -483,11 +483,0 @@\n-    \/**\n-     * Parks the current virtual thread until unparked or interrupted.\n-     *\/\n-    static void park() {\n-        if (currentThread() instanceof VirtualThread vthread) {\n-            vthread.doPark();\n-        } else {\n-            throw new WrongThreadException();\n-        }\n-    }\n-\n@@ -499,1 +488,4 @@\n-    private void doPark() {\n+    @Override\n+    void park() {\n+        assert Thread.currentThread() == this;\n+\n@@ -516,14 +508,0 @@\n-    \/**\n-     * Parks the current virtual thread up to the given waiting time or until\n-     * unparked or interrupted.\n-     *\n-     * @param nanos the maximum number of nanoseconds to wait\n-     *\/\n-    static void parkNanos(long nanos) {\n-        if (currentThread() instanceof VirtualThread vthread) {\n-            vthread.doParkNanos(nanos);\n-        } else {\n-            throw new WrongThreadException();\n-        }\n-    }\n-\n@@ -538,1 +516,2 @@\n-    private void doParkNanos(long nanos) {\n+    @Override\n+    void parkNanos(long nanos) {\n@@ -641,0 +620,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+        ContinuationSupport.ensureSupported();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+\/**\n+ * Defines a static method to test if the VM has continuations support.\n+ *\/\n+public class ContinuationSupport {\n+    private static final boolean SUPPORTED = isSupported0();\n+\n+    private ContinuationSupport() {\n+    }\n+\n+    \/**\n+     * Return true if the VM has continuations support.\n+     *\/\n+    public static boolean isSupported() {\n+        return SUPPORTED;\n+    }\n+\n+    \/**\n+     * Ensures that VM has continuations support.\n+     * @throws UnsupportedOperationException if not supported\n+     *\/\n+    public static void ensureSupported() {\n+        if (!isSupported()) {\n+            throw new UnsupportedOperationException(\"VM does not support continuations\");\n+        }\n+    }\n+\n+    private static native boolean isSupported0();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ContinuationSupport.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_misc_PreviewFeatures.h\"\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_vm_ContinuationSupport_isSupported0(JNIEnv *env, jclass cls) {\n+    return JVM_IsContinuationsSupported();\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/ContinuationSupport.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -26,2 +26,2 @@\n- #include \"jni.h\"\n- #include \"jvm.h\"\n+#include \"jni.h\"\n+#include \"jvm.h\"\n@@ -29,1 +29,1 @@\n- #include \"jdk_internal_misc_PreviewFeatures.h\"\n+#include \"jdk_internal_misc_PreviewFeatures.h\"\n@@ -31,4 +31,4 @@\n- JNIEXPORT jboolean JNICALL\n- Java_jdk_internal_misc_PreviewFeatures_isPreviewEnabled(JNIEnv *env, jclass cls) {\n-     return JVM_IsPreviewEnabled(env);\n- }\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_misc_PreviewFeatures_isPreviewEnabled(JNIEnv *env, jclass cls) {\n+    return JVM_IsPreviewEnabled();\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/PreviewFeatures.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import sun.management.Util;\n@@ -96,0 +97,1 @@\n+    private boolean      virtual;   \/\/ accessed by ThreadImpl\n@@ -227,0 +229,1 @@\n+        this.virtual = Util.isVirtual(t);\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ThreadInfo.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n@@ -34,3 +32,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -39,0 +34,1 @@\n+import sun.management.Util;\n@@ -137,1 +133,0 @@\n-\n@@ -139,7 +134,1 @@\n-        int length = threads.length;\n-        long[] ids = new long[length];\n-        for (int i = 0; i < length; i++) {\n-            Thread t = threads[i];\n-            ids[i] = t.threadId();\n-        }\n-        return ids;\n+        return platformThreadIds(threads);\n@@ -150,4 +139,1 @@\n-        long[] ids = new long[1];\n-        ids[0] = id;\n-        final ThreadInfo[] infos = getThreadInfo(ids, 0);\n-        return infos[0];\n+        return getThreadInfo(id, 0);\n@@ -158,4 +144,7 @@\n-        long[] ids = new long[1];\n-        ids[0] = id;\n-        final ThreadInfo[] infos = getThreadInfo(ids, maxDepth);\n-        return infos[0];\n+        long[] ids = new long[] { id };\n+        ThreadInfo ti = getThreadInfo(ids, maxDepth)[0];\n+        if (ti == null || Util.isVirtual(ti)) {\n+            return null;\n+        } else {\n+            return ti;\n+        }\n@@ -205,0 +194,1 @@\n+        nullVirtualThreads(infos);\n@@ -235,1 +225,1 @@\n-        if (isVirtual(Thread.currentThread())) {\n+        if (Util.isVirtual(Thread.currentThread())) {\n@@ -297,1 +287,1 @@\n-                    if (isVirtual(thread)) {\n+                    if (Util.isVirtual(thread)) {\n@@ -340,1 +330,1 @@\n-                    if (isVirtual(thread)) {\n+                    if (Util.isVirtual(thread)) {\n@@ -374,1 +364,1 @@\n-        if (isThreadAllocatedMemoryEnabled() && !isVirtual(Thread.currentThread())) {\n+        if (isThreadAllocatedMemoryEnabled() && !Util.isVirtual(Thread.currentThread())) {\n@@ -390,1 +380,1 @@\n-                if (isVirtual(thread)) {\n+                if (Util.isVirtual(thread)) {\n@@ -446,3 +436,1 @@\n-            long[] tids = Stream.of(threads)\n-                    .mapToLong(Thread::threadId)\n-                    .toArray();\n+            long[] tids = platformThreadIds(threads);\n@@ -512,2 +500,4 @@\n-        return dumpThreads0(ids, lockedMonitors, lockedSynchronizers,\n-                            Integer.MAX_VALUE);\n+        ThreadInfo[] infos = dumpThreads0(ids, lockedMonitors, lockedSynchronizers,\n+                                          Integer.MAX_VALUE);\n+        nullVirtualThreads(infos);\n+        return infos;\n@@ -530,1 +520,3 @@\n-        return dumpThreads0(ids, lockedMonitors, lockedSynchronizers, maxDepth);\n+        ThreadInfo[] infos = dumpThreads0(ids, lockedMonitors, lockedSynchronizers, maxDepth);\n+        nullVirtualThreads(infos);\n+        return infos;\n@@ -536,2 +528,3 @@\n-        return dumpAllThreads(lockedMonitors, lockedSynchronizers,\n-                              Integer.MAX_VALUE);\n+        ThreadInfo[] infos = dumpAllThreads(lockedMonitors, lockedSynchronizers,\n+                                            Integer.MAX_VALUE);\n+        return platformThreads(infos);\n@@ -548,1 +541,2 @@\n-        return dumpThreads0(null, lockedMonitors, lockedSynchronizers, maxDepth);\n+        ThreadInfo[] infos = dumpThreads0(null, lockedMonitors, lockedSynchronizers, maxDepth);\n+        return platformThreads(infos);\n@@ -582,4 +576,1 @@\n-     * Returns true if the given Thread is a virutal thread.\n-     *\n-     * @implNote This method uses reflection because Thread::isVirtual is a preview API\n-     * and the java.management cannot be compiled with --enable-preview.\n+     * Returns the thread identifiers of the platform threads in the given array.\n@@ -587,6 +578,5 @@\n-    private static boolean isVirtual(Thread thread) {\n-        try {\n-            return (boolean) IS_VIRTUAL.invoke(thread);\n-        } catch (IllegalAccessException | InvocationTargetException e) {\n-            throw new InternalError(e);\n-        }\n+    private static long[] platformThreadIds(Thread[] threads) {\n+        return Stream.of(threads)\n+                .filter(t -> !Util.isVirtual(t))\n+                .mapToLong(Thread::threadId)\n+                .toArray();\n@@ -595,10 +585,9 @@\n-    static final Method IS_VIRTUAL;\n-    static {\n-        try {\n-            PrivilegedExceptionAction<Method> pa = () -> Thread.class.getMethod(\"isVirtual\");\n-            @SuppressWarnings(\"removal\")\n-            Method m = AccessController.doPrivileged(pa);\n-            IS_VIRTUAL = m;\n-        } catch (PrivilegedActionException e) {\n-            throw new InternalError(e);\n-        }\n+    \/**\n+     * Returns the ThreadInfo objects from the given array that coresspond to platform\n+     * threads.\n+     *\/\n+    private ThreadInfo[] platformThreads(ThreadInfo[] infos) {\n+        return Stream.of(infos)\n+                .filter(ti -> !Util.isVirtual(ti))\n+                .toArray(ThreadInfo[]::new);\n+    }\n@@ -606,0 +595,10 @@\n+    \/**\n+     * Set the elements of the given array to null if they correspond to a virtual thread.\n+     *\/\n+    private static void nullVirtualThreads(ThreadInfo[] infos) {\n+        for (int i = 0; i < infos.length; i++) {\n+            ThreadInfo ti = infos[i];\n+            if (ti != null && Util.isVirtual(ti)) {\n+                infos[i] = null;\n+            }\n+        }\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ThreadImpl.java","additions":54,"deletions":55,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Field;\n@@ -29,0 +31,4 @@\n+import java.lang.management.ThreadInfo;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n@@ -84,0 +90,52 @@\n+\n+    \/**\n+     * Returns true if the given Thread is a virutal thread.\n+     *\n+     * @implNote This method uses reflection because Thread::isVirtual is a preview API\n+     * and the java.management cannot be compiled with --enable-preview.\n+     *\/\n+    public static boolean isVirtual(Thread thread) {\n+        try {\n+            return (boolean) THREAD_IS_VIRTUAL.invoke(thread);\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the given ThreadInfo is for a virutal thread.\n+     *\/\n+    public static boolean isVirtual(ThreadInfo threadInfo) {\n+        try {\n+            return (boolean) THREADINFO_VIRTUAL.get(threadInfo);\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Method threadIsVirtual() {\n+        PrivilegedExceptionAction<Method> pa = () -> Thread.class.getMethod(\"isVirtual\");\n+        try {\n+            return AccessController.doPrivileged(pa);\n+        } catch (PrivilegedActionException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Field threadInfoVirtual() {\n+        PrivilegedExceptionAction<Field> pa = () -> {\n+            Field f = ThreadInfo.class.getDeclaredField(\"virtual\");\n+            f.setAccessible(true);\n+            return f;\n+        };\n+        try {\n+            return AccessController.doPrivileged(pa);\n+        } catch (PrivilegedActionException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static final Method THREAD_IS_VIRTUAL = threadIsVirtual();\n+    private static final Field THREADINFO_VIRTUAL = threadInfoVirtual();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/Util.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    vm.continuations \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.continuations\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/redefineClass\/RedefineRunningMethods_Shared.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @summary Tests that JNI monitors works correctly for native threads\n+ * @summary Tests that JNI monitors work correctly with virtual threads\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/JNIMonitor\/JNIMonitor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        checkFrames(vThread1, false, 15);\n+        checkFrames(vThread1, false, 14);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    vm.continuations \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbOptions.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CustomScheduler.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTraceWhenRunnable.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/HoldsLock.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n- * @summary Basic test for JFR jdk.VirtualThreadXXX events.\n+ * @summary Basic test for JFR jdk.VirtualThreadXXX events\n+ * @requires vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ParkWithFixedThreadPool.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import org.testng.SkipException;\n@@ -144,0 +145,2 @@\n+        if (!ThreadBuilders.supportsCustomScheduler())\n+            throw new SkipException(\"No support for custom schedulers\");\n@@ -146,2 +149,2 @@\n-            ThreadFactory factory = ThreadBuilders.virtualThreadBuilder(scheduler).factory();\n-\n+            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n+            ThreadFactory factory = builder.factory();\n@@ -318,0 +321,2 @@\n+        if (!ThreadBuilders.supportsCustomScheduler())\n+            throw new SkipException(\"No support for custom schedulers\");\n@@ -320,2 +325,2 @@\n-            ThreadFactory factory = ThreadBuilders.virtualThreadBuilder(scheduler).factory();\n-\n+            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n+            ThreadFactory factory = builder.factory();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Reflection.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/StackTraces.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,9 @@\n+\/**\n+ * @test\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run testng\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations ThreadAPI\n+ *\/\n+\n@@ -56,0 +65,1 @@\n+import org.testng.SkipException;\n@@ -1088,0 +1098,2 @@\n+        if (!ThreadBuilders.supportsCustomScheduler())\n+            throw new SkipException(\"No support for custom schedulers\");\n@@ -1115,0 +1127,2 @@\n+        if (!ThreadBuilders.supportsCustomScheduler())\n+            throw new SkipException(\"No support for custom schedulers\");\n@@ -1690,0 +1704,2 @@\n+        if (!ThreadBuilders.supportsCustomScheduler())\n+            throw new SkipException(\"No support for custom schedulers\");\n@@ -1856,0 +1872,2 @@\n+        if (!ThreadBuilders.supportsCustomScheduler())\n+            throw new SkipException(\"Requires continuations support\");\n@@ -1917,0 +1935,2 @@\n+        if (!ThreadBuilders.supportsCustomScheduler())\n+            throw new SkipException(\"No support for custom schedulers\");\n@@ -2013,0 +2033,2 @@\n+        if (!ThreadBuilders.supportsCustomScheduler())\n+            throw new SkipException(\"No support for custom schedulers\");\n@@ -2274,1 +2296,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n-import java.lang.reflect.Field;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n@@ -26,0 +27,1 @@\n+import java.util.concurrent.Executors;\n@@ -29,0 +31,2 @@\n+ *\n+ * Tests using this class need to open java.base\/java.lang.\n@@ -33,0 +37,12 @@\n+    private static final Constructor<?> VTBUILDER_CTOR;\n+    static {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+            ctor.setAccessible(true);\n+            VTBUILDER_CTOR = ctor;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n@@ -35,2 +51,1 @@\n-     *\n-     * Tests using this method need to open java.base\/java.lang.\n+     * @throws UnsupportedOperationException if custom schedulers are not supported\n@@ -41,6 +56,7 @@\n-            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n-            Field field = clazz.getDeclaredField(\"scheduler\");\n-            field.setAccessible(true);\n-            field.set(builder, scheduler);\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n+            return (Thread.Builder.OfVirtual) VTBUILDER_CTOR.newInstance(scheduler);\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                throw re;\n+            }\n+            throw new RuntimeException(e);\n@@ -50,1 +66,14 @@\n-        return builder;\n+    }\n+\n+    \/**\n+     * Return true if custom schedulers are supported.\n+     *\/\n+    static boolean supportsCustomScheduler() {\n+        try (var pool = Executors.newCachedThreadPool()) {\n+            try {\n+                virtualThreadBuilder(pool);\n+                return true;\n+            } catch (UnsupportedOperationException e) {\n+                return false;\n+            }\n+        }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadBuilders.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/TracePinnedThreads.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.debug != true\n+ * @requires vm.debug != true & vm.continuations\n@@ -36,1 +36,1 @@\n- * @requires vm.debug == true\n+ * @requires vm.debug == true & vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALot.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.continuations\n@@ -33,1 +34,1 @@\n- * @requires vm.debug == true\n+ * @requires vm.debug == true & vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.debug != true\n+ * @requires vm.debug != true & vm.continuations\n@@ -34,1 +34,1 @@\n- * @requires vm.debug == true\n+ * @requires vm.debug == true & vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/SleepALot.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.debug != true\n+ * @requires vm.debug != true & vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/TimedGet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/java\/lang\/instrument\/ParallelTransformerLoaderTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,4 +29,15 @@\n- * @compile --enable-preview -source ${jdk.version} VirtualThreadDeadlocks.java\n- * @run main\/othervm --enable-preview VirtualThreadDeadlocks PP\n- * @run main\/othervm --enable-preview VirtualThreadDeadlocks PV\n- * @run main\/othervm --enable-preview VirtualThreadDeadlocks VV\n+ * @enablePreview\n+ * @modules java.management\n+ * @run main\/othervm VirtualThreadDeadlocks PP\n+ * @run main\/othervm VirtualThreadDeadlocks PV\n+ * @run main\/othervm VirtualThreadDeadlocks VV\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @modules java.management\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations VirtualThreadDeadlocks PP\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations VirtualThreadDeadlocks PV\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations VirtualThreadDeadlocks VV\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreadDeadlocks.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8284161\n@@ -27,3 +28,11 @@\n- * @modules java.base\/java.lang:+open\n- * @compile --enable-preview -source ${jdk.version} VirtualThreads.java\n- * @run testng\/othervm --enable-preview VirtualThreads\n+ * @enablePreview\n+ * @modules java.base\/java.lang:+open java.management\n+ * @run testng\/othervm VirtualThreads\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @modules java.base\/java.lang:+open java.management\n+ * @run testng\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations VirtualThreads\n@@ -35,1 +44,2 @@\n-import java.lang.reflect.Field;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n@@ -44,0 +54,1 @@\n+import org.testng.SkipException;\n@@ -81,0 +92,2 @@\n+        if (!supportsCustomScheduler())\n+            throw new SkipException(\"No support for custom schedulers\");\n@@ -206,0 +219,4 @@\n+    \/**\n+     * Returns a builder to create virtual threads that use the given scheduler.\n+     * @throws UnsupportedOperationException if there is no support for custom schedulers\n+     *\/\n@@ -210,5 +227,9 @@\n-            Field field = clazz.getDeclaredField(\"scheduler\");\n-            field.setAccessible(true);\n-            field.set(builder, scheduler);\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+            ctor.setAccessible(true);\n+            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                throw re;\n+            }\n+            throw new RuntimeException(e);\n@@ -218,1 +239,14 @@\n-        return builder;\n+    }\n+\n+    \/**\n+     * Return true if custom schedulers are supported.\n+     *\/\n+    private static boolean supportsCustomScheduler() {\n+        try (var pool = Executors.newCachedThreadPool()) {\n+            try {\n+                virtualThreadBuilder(pool);\n+                return true;\n+            } catch (UnsupportedOperationException e) {\n+                return false;\n+            }\n+        }\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreads.java","additions":44,"deletions":10,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8284161\n@@ -27,0 +28,1 @@\n+ * @enablePreview\n@@ -28,3 +30,10 @@\n- * @compile --enable-preview -source ${jdk.version} BlockingSocketOps.java\n- * @run testng\/othervm\/timeout=300 --enable-preview BlockingSocketOps\n- * @run testng\/othervm\/timeout=300 --enable-preview -Djdk.useDirectRegister BlockingSocketOps\n+ * @run testng\/othervm\/timeout=300 BlockingSocketOps\n+ * @run testng\/othervm\/timeout=300 -Djdk.useDirectRegister BlockingSocketOps\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @run testng\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingSocketOps\n","filename":"test\/jdk\/java\/net\/vthread\/BlockingSocketOps.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8284161\n@@ -27,0 +28,1 @@\n+ * @enablePreview\n@@ -28,3 +30,10 @@\n- * @compile --enable-preview -source ${jdk.version} BlockingChannelOps.java\n- * @run testng\/othervm\/timeout=300 --enable-preview BlockingChannelOps\n- * @run testng\/othervm\/timeout=300 --enable-preview -Djdk.useDirectRegister BlockingChannelOps\n+ * @run testng\/othervm\/timeout=300 BlockingChannelOps\n+ * @run testng\/othervm\/timeout=300 -Djdk.useDirectRegister BlockingChannelOps\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @run testng\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingChannelOps\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+* @requires vm.continuations\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Basic.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+* @requires vm.continuations\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/ClassUnloading.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+* @requires vm.continuations\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/HumongousStack.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/LiveFramesDriver.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.continuations\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Scoped.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadEndEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadSleepEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadStartEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestVirtualThreadEndEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestVirtualThreadStartEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestThreadExclusion.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestVirtualThreadExclusion.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestDeepVirtualStackTrace.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestManyVirtualThreads.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.continuations\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestNestedVirtualThreads.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,1 @@\n+        map.put(\"vm.continuations\", this::vmContinuations);\n@@ -424,0 +425,11 @@\n+    \/**\n+     * @return \"true\" if this VM supports continuations.\n+     *\/\n+    protected String vmContinuations() {\n+        if (WB.getBooleanVMFlag(\"VMContinuations\")) {\n+            return \"true\";\n+        } else {\n+            return \"false\";\n+        }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}