{"files":[{"patch":"@@ -4485,2 +4485,12 @@\n-  HANDLE handle1 = create_read_only_file_handle(file1);\n-  HANDLE handle2 = create_read_only_file_handle(file2);\n+  char* native_file1 = os::strdup(file1);\n+  native_file1 = os::native_path(native_file1);\n+  char* native_file2 = os::strdup(file2);\n+  native_file2 = os::native_path(native_file2);\n+  if (strcmp(native_file1, native_file2) == 0) {\n+    os::free(native_file1);\n+    os::free(native_file2);\n+    return true;\n+  }\n+\n+  HANDLE handle1 = create_read_only_file_handle(native_file1);\n+  HANDLE handle2 = create_read_only_file_handle(native_file2);\n@@ -4513,0 +4523,3 @@\n+  os::free(native_file1);\n+  os::free(native_file2);\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -720,0 +720,8 @@\n+jzfile* ClassLoader::open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread) {\n+  \/\/ enable call to C land\n+  ThreadToNativeFromVM ttn(thread);\n+  HandleMark hm(thread);\n+  load_zip_library_if_needed();\n+  return (*ZipOpen)(canonical_path, error_msg);\n+}\n+\n@@ -731,2 +739,2 @@\n-    char* canonical_path = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, JVM_MAXPATHLEN);\n-    if (!get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {\n+    const char* canonical_path = get_canonical_path(path, thread);\n+    if (canonical_path == NULL) {\n@@ -746,8 +754,1 @@\n-      jzfile* zip;\n-      {\n-        \/\/ enable call to C land\n-        ThreadToNativeFromVM ttn(thread);\n-        HandleMark hm(thread);\n-        load_zip_library_if_needed();\n-        zip = (*ZipOpen)(canonical_path, &error_msg);\n-      }\n+      jzfile* zip = open_zip_file(canonical_path, &error_msg, thread);\n@@ -792,2 +793,4 @@\n-      char canonical_path[JVM_MAXPATHLEN];\n-      if (get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {\n+      JavaThread* thread = JavaThread::current();\n+      ResourceMark rm(thread);\n+      const char* canonical_path = get_canonical_path(path, thread);\n+      if (canonical_path != NULL) {\n@@ -795,9 +798,1 @@\n-        jzfile* zip;\n-        {\n-          \/\/ enable call to C land\n-          JavaThread* thread = JavaThread::current();\n-          ThreadToNativeFromVM ttn(thread);\n-          HandleMark hm(thread);\n-          load_zip_library_if_needed();\n-          zip = (*ZipOpen)(canonical_path, &error_msg);\n-        }\n+        jzfile* zip = open_zip_file(canonical_path, &error_msg, thread);\n@@ -1342,4 +1337,3 @@\n-    char* canonical_path_table_entry = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, JVM_MAXPATHLEN);\n-\n-    \/\/ save the path from the file: protocol or the module name from the jrt: protocol\n-    \/\/ if no protocol prefix is found, path is the same as stream->source()\n+    \/\/ Save the path from the file: protocol or the module name from the jrt: protocol\n+    \/\/ if no protocol prefix is found, path is the same as stream->source(). This path\n+    \/\/ must be valid since the class has been successfully parsed.\n@@ -1347,5 +1341,1 @@\n-    char* canonical_class_src_path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, JVM_MAXPATHLEN);\n-    bool success = get_canonical_path(path, canonical_class_src_path, JVM_MAXPATHLEN);\n-    \/\/ The path is from the ClassFileStream. Since a ClassFileStream has been created successfully in functions\n-    \/\/ such as ClassLoader::load_class(), its source path must be valid.\n-    assert(success, \"must be valid path\");\n+    assert(path != NULL, \"sanity\");\n@@ -1354,1 +1344,0 @@\n-      success = get_canonical_path(ent->name(), canonical_path_table_entry, JVM_MAXPATHLEN);\n@@ -1357,1 +1346,1 @@\n-      assert(success, \"must be valid path\");\n+      assert(ent->name() != NULL, \"sanity\");\n@@ -1360,1 +1349,4 @@\n-      if (strcmp(canonical_path_table_entry, canonical_class_src_path) == 0) {\n+      \/\/ src may come from the App\/Platform class loaders, which would canonicalize\n+      \/\/ the file name. We cannot use strcmp to check for equality against ent->name().\n+      \/\/ We must use os::same_files (which is faster than canonicalizing ent->name()).\n+      if (os::same_files(ent->name(), path)) {\n@@ -1602,5 +1594,5 @@\n-bool ClassLoader::get_canonical_path(const char* orig, char* out, int len) {\n-  assert(orig != NULL && out != NULL && len > 0, \"bad arguments\");\n-  JavaThread* THREAD = JavaThread::current();\n-  ResourceMark rm(THREAD);\n-\n+char* ClassLoader::get_canonical_path(const char* orig, Thread* thread) {\n+  assert(orig != NULL, \"bad arguments\");\n+  \/\/ caller needs to allocate ResourceMark for the following output buffer\n+  char* canonical_path = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, JVM_MAXPATHLEN);\n+  ResourceMark rm(thread);\n@@ -1608,1 +1600,1 @@\n-  char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(orig)+1);\n+  char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(orig)+1);\n@@ -1610,2 +1602,2 @@\n-  if ((CanonicalizeEntry)(os::native_path(orig_copy), out, len) < 0) {\n-    return false;\n+  if ((CanonicalizeEntry)(os::native_path(orig_copy), canonical_path, JVM_MAXPATHLEN) < 0) {\n+    return NULL;\n@@ -1613,1 +1605,1 @@\n-  return true;\n+  return canonical_path;\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":34,"deletions":42,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -257,0 +257,1 @@\n+  static jzfile* open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread);\n@@ -266,1 +267,1 @@\n-  static bool get_canonical_path(const char* orig, char* out, int len);\n+  static char* get_canonical_path(const char* orig, Thread* thread);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}