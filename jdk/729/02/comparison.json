{"files":[{"patch":"@@ -1647,4 +1647,0 @@\n-  JavaThread* current_thread  = JavaThread::current();\n-  HandleMark hm(current_thread);\n-  uint32_t debug_bits = 0;\n-\n@@ -1657,70 +1653,9 @@\n-  \/\/ Check if java_thread is fully suspended\n-  if (!java_thread->is_thread_fully_suspended(true \/* wait for suspend completion *\/, &debug_bits)) {\n-    return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-  }\n-  \/\/ Check to see if a PopFrame was already in progress\n-  if (java_thread->popframe_condition() != JavaThread::popframe_inactive) {\n-    \/\/ Probably possible for JVMTI clients to trigger this, but the\n-    \/\/ JPDA backend shouldn't allow this to happen\n-    return JVMTI_ERROR_INTERNAL;\n-  }\n-\n-  {\n-    \/\/ Was workaround bug\n-    \/\/    4812902: popFrame hangs if the method is waiting at a synchronize\n-    \/\/ Catch this condition and return an error to avoid hanging.\n-    \/\/ Now JVMTI spec allows an implementation to bail out with an opaque frame error.\n-    OSThread* osThread = java_thread->osthread();\n-    if (osThread->get_state() == MONITOR_WAIT) {\n-      return JVMTI_ERROR_OPAQUE_FRAME;\n-    }\n-  }\n-\n-  if (java_thread->frames_to_pop_failed_realloc() > 0) {\n-    \/\/ VM is in the process of popping the top frame because it has scalar replaced objects which\n-    \/\/ could not be reallocated on the heap.\n-    \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n-    return JVMTI_ERROR_OUT_OF_MEMORY;\n-  }\n-\n-  {\n-    ResourceMark rm(current_thread);\n-    \/\/ Check if there are more than one Java frame in this thread, that the top two frames\n-    \/\/ are Java (not native) frames, and that there is no intervening VM frame\n-    int frame_count = 0;\n-    bool is_interpreted[2];\n-    intptr_t *frame_sp[2];\n-    \/\/ The 2-nd arg of constructor is needed to stop iterating at java entry frame.\n-    for (vframeStream vfs(java_thread, true, false \/* process_frames *\/); !vfs.at_end(); vfs.next()) {\n-      methodHandle mh(current_thread, vfs.method());\n-      if (mh->is_native()) return(JVMTI_ERROR_OPAQUE_FRAME);\n-      is_interpreted[frame_count] = vfs.is_interpreted_frame();\n-      frame_sp[frame_count] = vfs.frame_id();\n-      if (++frame_count > 1) break;\n-    }\n-    if (frame_count < 2)  {\n-      \/\/ We haven't found two adjacent non-native Java frames on the top.\n-      \/\/ There can be two situations here:\n-      \/\/  1. There are no more java frames\n-      \/\/  2. Two top java frames are separated by non-java native frames\n-      if(vframeForNoProcess(java_thread, 1) == NULL) {\n-        return JVMTI_ERROR_NO_MORE_FRAMES;\n-      } else {\n-        \/\/ Intervening non-java native or VM frames separate java frames.\n-        \/\/ Current implementation does not support this. See bug #5031735.\n-        \/\/ In theory it is possible to pop frames in such cases.\n-        return JVMTI_ERROR_OPAQUE_FRAME;\n-      }\n-    }\n-\n-    \/\/ If any of the top 2 frames is a compiled one, need to deoptimize it\n-    EscapeBarrier eb(!is_interpreted[0] || !is_interpreted[1], current_thread, java_thread);\n-    for (int i = 0; i < 2; i++) {\n-      if (!is_interpreted[i]) {\n-        Deoptimization::deoptimize_frame(java_thread, frame_sp[i]);\n-        \/\/ Eagerly reallocate scalar replaced objects.\n-        if (!eb.deoptimize_objects(frame_sp[i])) {\n-          \/\/ Reallocation of scalar replaced objects failed -> return with error\n-          return JVMTI_ERROR_OUT_OF_MEMORY;\n-        }\n-      }\n+  \/\/ Eagerly reallocate scalar replaced objects.\n+  JavaThread* current_thread = JavaThread::current();\n+  EscapeBarrier eb(true, current_thread, java_thread);\n+  if (eb.barrier_active()) {\n+    if (java_thread->frames_to_pop_failed_realloc() > 0) {\n+      \/\/ VM is in the process of popping the top frame because it has scalar replaced objects which\n+      \/\/ could not be reallocated on the heap.\n+      \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n+      return JVMTI_ERROR_OUT_OF_MEMORY;\n@@ -1728,24 +1663,3 @@\n-\n-    \/\/ Update the thread state to reflect that the top frame is popped\n-    \/\/ so that cur_stack_depth is maintained properly and all frameIDs\n-    \/\/ are invalidated.\n-    \/\/ The current frame will be popped later when the suspended thread\n-    \/\/ is resumed and right before returning from VM to Java.\n-    \/\/ (see call_VM_base() in assembler_<cpu>.cpp).\n-\n-    \/\/ It's fine to update the thread state here because no JVMTI events\n-    \/\/ shall be posted for this PopFrame.\n-\n-    \/\/ It is only safe to perform the direct operation on the current\n-    \/\/ thread. All other usage needs to use a handshake for safety.\n-    {\n-      MutexLocker mu(JvmtiThreadState_lock);\n-      if (java_thread == JavaThread::current()) {\n-        state->update_for_pop_top_frame();\n-      } else {\n-        UpdateForPopTopFrameClosure op(state);\n-        Handshake::execute(&op, java_thread);\n-        if (op.result() != JVMTI_ERROR_NONE) {\n-          return op.result();\n-        }\n-      }\n+    if (!eb.deoptimize_objects(1)) {\n+      \/\/ Reallocation of scalar replaced objects failed -> return with error\n+      return JVMTI_ERROR_OUT_OF_MEMORY;\n@@ -1753,5 +1667,0 @@\n-\n-    java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n-    \/\/ Set pending step flag for this popframe and it is cleared when next\n-    \/\/ step event is posted.\n-    state->set_pending_step_for_popframe();\n@@ -1760,1 +1669,8 @@\n-  return JVMTI_ERROR_NONE;\n+  MutexLocker mu(JvmtiThreadState_lock);\n+  UpdateForPopTopFrameClosure op(state);\n+  if (java_thread == current_thread) {\n+    op.doit(java_thread, true);\n+  } else {\n+    Handshake::execute(&op, java_thread);\n+  }\n+  return op.result();\n@@ -1794,4 +1710,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  ResourceMark rm;\n-  uint32_t debug_bits = 0;\n-\n@@ -1803,21 +1715,1 @@\n-  if (!java_thread->is_thread_fully_suspended(true, &debug_bits)) {\n-    return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-  }\n-\n-  if (TraceJVMTICalls) {\n-    JvmtiSuspendControl::print();\n-  }\n-\n-  vframe *vf = vframeForNoProcess(java_thread, depth);\n-  if (vf == NULL) {\n-    return JVMTI_ERROR_NO_MORE_FRAMES;\n-  }\n-\n-  if (!vf->is_java_frame() || ((javaVFrame*) vf)->method()->is_native()) {\n-    return JVMTI_ERROR_OPAQUE_FRAME;\n-  }\n-\n-  assert(vf->frame_pointer() != NULL, \"frame pointer mustn't be NULL\");\n-\n-  \/\/ It is only safe to perform the direct operation on the current\n-  \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n+  SetFramePopClosure op(this, state, depth);\n@@ -1826,2 +1718,1 @@\n-    int frame_number = state->count_frames() - depth;\n-    state->env_thread_state(this)->set_frame_pop(frame_number);\n+    op.doit(java_thread, true);\n@@ -1829,1 +1720,0 @@\n-    SetFramePopClosure op(this, state, depth);\n@@ -1831,1 +1721,0 @@\n-    err = op.result();\n@@ -1833,1 +1722,1 @@\n-  return err;\n+  return op.result();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":23,"deletions":134,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/vframe.inline.hpp\"\n@@ -60,0 +61,1 @@\n+\n@@ -1309,1 +1311,1 @@\n-JvmtiEnvBase::check_top_frame(JavaThread* current_thread, JavaThread* java_thread,\n+JvmtiEnvBase::check_top_frame(Thread* current_thread, JavaThread* java_thread,\n@@ -1313,7 +1315,0 @@\n-  if (java_thread->frames_to_pop_failed_realloc() > 0) {\n-    \/\/ VM is in the process of popping the top frame because it has scalar replaced objects\n-    \/\/ which could not be reallocated on the heap.\n-    \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n-    return JVMTI_ERROR_OUT_OF_MEMORY;\n-  }\n-\n@@ -1334,6 +1329,0 @@\n-    \/\/ Eagerly reallocate scalar replaced objects.\n-    EscapeBarrier eb(true, current_thread, java_thread);\n-    if (!eb.deoptimize_objects(jvf->fr().id())) {\n-      \/\/ Reallocation of scalar replaced objects failed -> return with error\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n@@ -1385,4 +1374,0 @@\n-  JavaThread* current_thread = JavaThread::current();\n-  HandleMark   hm(current_thread);\n-  uint32_t debug_bits = 0;\n-\n@@ -1395,3 +1380,36 @@\n-  \/\/ Check if java_thread is fully suspended\n-  if (!java_thread->is_thread_fully_suspended(true \/* wait for suspend completion *\/, &debug_bits)) {\n-    return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+  \/\/ Eagerly reallocate scalar replaced objects.\n+  JavaThread* current_thread = JavaThread::current();\n+  EscapeBarrier eb(true, current_thread, java_thread);\n+  if (eb.barrier_active()) {\n+    if (java_thread->frames_to_pop_failed_realloc() > 0) {\n+      \/\/ VM is in the process of popping the top frame because it has scalar replaced objects\n+      \/\/ which could not be reallocated on the heap.\n+      \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n+      return JVMTI_ERROR_OUT_OF_MEMORY;\n+    }\n+    if (!eb.deoptimize_objects(0)) {\n+      \/\/ Reallocation of scalar replaced objects failed -> return with error\n+      return JVMTI_ERROR_OUT_OF_MEMORY;\n+    }\n+  }\n+\n+  SetForceEarlyReturn op(state, value, tos);\n+  if (java_thread == current_thread) {\n+    op.doit(java_thread, true);\n+  } else {\n+    Handshake::execute(&op, java_thread);\n+  }\n+  return op.result();\n+}\n+\n+void\n+SetForceEarlyReturn::doit(Thread *target, bool self) {\n+  JavaThread* java_thread = target->as_Java_thread();\n+  Thread* current_thread = Thread::current();\n+  HandleMark   hm(current_thread);\n+\n+  if (!self) {\n+    if (!java_thread->is_external_suspend()) {\n+      _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+      return;\n+    }\n@@ -1401,1 +1419,1 @@\n-  if (state->is_earlyret_pending()) {\n+  if (_state->is_earlyret_pending()) {\n@@ -1404,1 +1422,2 @@\n-    return JVMTI_ERROR_INTERNAL;\n+    _result = JVMTI_ERROR_INTERNAL;\n+    return;\n@@ -1414,1 +1433,2 @@\n-      return JVMTI_ERROR_OPAQUE_FRAME;\n+      _result = JVMTI_ERROR_OPAQUE_FRAME;\n+      return;\n@@ -1417,0 +1437,1 @@\n+\n@@ -1418,3 +1439,3 @@\n-  jvmtiError err = check_top_frame(current_thread, java_thread, value, tos, &ret_ob_h);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n+  _result = JvmtiEnvBase::check_top_frame(current_thread, java_thread, _value, _tos, &ret_ob_h);\n+  if (_result != JVMTI_ERROR_NONE) {\n+    return;\n@@ -1422,1 +1443,1 @@\n-  assert(tos != atos || value.l == NULL || ret_ob_h() != NULL,\n+  assert(_tos != atos || _value.l == NULL || ret_ob_h() != NULL,\n@@ -1431,3 +1452,3 @@\n-  state->set_earlyret_pending();\n-  state->set_earlyret_oop(ret_ob_h());\n-  state->set_earlyret_value(value, tos);\n+  _state->set_earlyret_pending();\n+  _state->set_earlyret_oop(ret_ob_h());\n+  _state->set_earlyret_value(_value, _tos);\n@@ -1437,4 +1458,2 @@\n-  state->set_pending_step_for_earlyret();\n-\n-  return JVMTI_ERROR_NONE;\n-} \/* end force_early_return *\/\n+  _state->set_pending_step_for_earlyret();\n+}\n@@ -1520,1 +1539,83 @@\n-UpdateForPopTopFrameClosure::do_thread(Thread *target) {\n+UpdateForPopTopFrameClosure::doit(Thread *target, bool self) {\n+  Thread* current_thread  = Thread::current();\n+  HandleMark hm(current_thread);\n+  JavaThread* java_thread = target->as_Java_thread();\n+\n+  if (!self) {\n+    if (!java_thread->is_external_suspend()) {\n+      _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+      return;\n+    }\n+  }\n+\n+  \/\/ Check to see if a PopFrame was already in progress\n+  if (java_thread->popframe_condition() != JavaThread::popframe_inactive) {\n+    \/\/ Probably possible for JVMTI clients to trigger this, but the\n+    \/\/ JPDA backend shouldn't allow this to happen\n+    _result = JVMTI_ERROR_INTERNAL;\n+    return;\n+  }\n+\n+  \/\/ Was workaround bug\n+  \/\/    4812902: popFrame hangs if the method is waiting at a synchronize\n+  \/\/ Catch this condition and return an error to avoid hanging.\n+  \/\/ Now JVMTI spec allows an implementation to bail out with an opaque frame error.\n+  OSThread* osThread = java_thread->osthread();\n+  if (osThread->get_state() == MONITOR_WAIT) {\n+    _result = JVMTI_ERROR_OPAQUE_FRAME;\n+    return;\n+  }\n+\n+  ResourceMark rm(current_thread);\n+  \/\/ Check if there are more than one Java frame in this thread, that the top two frames\n+  \/\/ are Java (not native) frames, and that there is no intervening VM frame\n+  int frame_count = 0;\n+  bool is_interpreted[2];\n+  intptr_t *frame_sp[2];\n+  \/\/ The 2-nd arg of constructor is needed to stop iterating at java entry frame.\n+  for (vframeStream vfs(java_thread, true, false \/* process_frames *\/); !vfs.at_end(); vfs.next()) {\n+    methodHandle mh(current_thread, vfs.method());\n+    if (mh->is_native()) {\n+      _result = JVMTI_ERROR_OPAQUE_FRAME;\n+      return;\n+    }\n+    is_interpreted[frame_count] = vfs.is_interpreted_frame();\n+    frame_sp[frame_count] = vfs.frame_id();\n+    if (++frame_count > 1) break;\n+  }\n+  if (frame_count < 2)  {\n+    \/\/ We haven't found two adjacent non-native Java frames on the top.\n+    \/\/ There can be two situations here:\n+    \/\/  1. There are no more java frames\n+    \/\/  2. Two top java frames are separated by non-java native frames\n+    if(JvmtiEnvBase::vframeForNoProcess(java_thread, 1) == NULL) {\n+      _result = JVMTI_ERROR_NO_MORE_FRAMES;\n+      return;\n+    } else {\n+      \/\/ Intervening non-java native or VM frames separate java frames.\n+      \/\/ Current implementation does not support this. See bug #5031735.\n+      \/\/ In theory it is possible to pop frames in such cases.\n+      _result = JVMTI_ERROR_OPAQUE_FRAME;\n+      return;\n+    }\n+  }\n+\n+  \/\/ If any of the top 2 frames is a compiled one, need to deoptimize it\n+  for (int i = 0; i < 2; i++) {\n+    if (!is_interpreted[i]) {\n+      Deoptimization::deoptimize_frame(java_thread, frame_sp[i]);\n+    }\n+  }\n+\n+  \/\/ Update the thread state to reflect that the top frame is popped\n+  \/\/ so that cur_stack_depth is maintained properly and all frameIDs\n+  \/\/ are invalidated.\n+  \/\/ The current frame will be popped later when the suspended thread\n+  \/\/ is resumed and right before returning from VM to Java.\n+  \/\/ (see call_VM_base() in assembler_<cpu>.cpp).\n+\n+  \/\/ It's fine to update the thread state here because no JVMTI events\n+  \/\/ shall be posted for this PopFrame.\n+\n+  \/\/ It is only safe to perform the direct operation on the current\n+  \/\/ thread. All other usage needs to use a handshake for safety.\n@@ -1525,0 +1626,4 @@\n+    java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n+    \/\/ Set pending step flag for this popframe and it is cleared when next\n+    \/\/ step event is posted.\n+    _state->set_pending_step_for_popframe();\n@@ -1530,7 +1635,27 @@\n-SetFramePopClosure::do_thread(Thread *target) {\n-  JavaThread* jt = _state->get_thread();\n-  assert(jt == target, \"just checking\");\n-  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n-    int frame_number = _state->count_frames() - _depth;\n-    _state->env_thread_state((JvmtiEnvBase*)_env)->set_frame_pop(frame_number);\n-    _result = JVMTI_ERROR_NONE;\n+SetFramePopClosure::doit(Thread *target, bool self) {\n+  ResourceMark rm;\n+  JavaThread* java_thread = target->as_Java_thread();\n+\n+  assert(_state->get_thread() == java_thread, \"Must be\");\n+\n+  if (!self) {\n+    if (!java_thread->is_external_suspend()) {\n+      _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+      return;\n+    }\n+  }\n+\n+  vframe *vf = JvmtiEnvBase::vframeForNoProcess(java_thread, _depth);\n+  if (vf == NULL) {\n+    _result = JVMTI_ERROR_NO_MORE_FRAMES;\n+    return;\n+  }\n+\n+  if (!vf->is_java_frame() || ((javaVFrame*) vf)->method()->is_native()) {\n+    _result = JVMTI_ERROR_OPAQUE_FRAME;\n+    return;\n+  }\n+\n+  assert(vf->frame_pointer() != NULL, \"frame pointer mustn't be NULL\");\n+  if (java_thread->is_exiting() || java_thread->threadObj() == NULL) {\n+    return;\n@@ -1538,0 +1663,3 @@\n+  int frame_number = _state->count_frames() - _depth;\n+  _state->env_thread_state((JvmtiEnvBase*)_env)->set_frame_pop(frame_number);\n+  _result = JVMTI_ERROR_NONE;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":171,"deletions":43,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -289,2 +289,0 @@\n-  vframe* vframeForNoProcess(JavaThread* java_thread, jint depth);\n-\n@@ -292,0 +290,2 @@\n+  static vframe* vframeForNoProcess(JavaThread* java_thread, jint depth);\n+\n@@ -309,1 +309,1 @@\n-  jvmtiError check_top_frame(JavaThread* current_thread, JavaThread* java_thread,\n+  static jvmtiError check_top_frame(Thread* current_thread, JavaThread* java_thread,\n@@ -349,0 +349,17 @@\n+class SetForceEarlyReturn : public JvmtiHandshakeClosure {\n+private:\n+  JvmtiThreadState* _state;\n+  jvalue _value;\n+  TosState _tos;\n+public:\n+  SetForceEarlyReturn(JvmtiThreadState* state, jvalue value, TosState tos)\n+    : JvmtiHandshakeClosure(\"SetForceEarlyReturn\"),\n+     _state(state),\n+     _value(value),\n+     _tos(tos) {}\n+  void do_thread(Thread *target) {\n+    doit(target, false);\n+  }\n+  void doit(Thread *target, bool self);\n+};\n+\n@@ -357,2 +374,5 @@\n-      _state(state) {}\n-  void do_thread(Thread *target);\n+     _state(state) {}\n+  void do_thread(Thread *target) {\n+    doit(target, false);\n+  }\n+  void doit(Thread *target, bool self);\n@@ -374,1 +394,4 @@\n-  void do_thread(Thread *target);\n+  void do_thread(Thread *target) {\n+    doit(target, false);\n+  }\n+  void doit(Thread *target, bool self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1752,1 +1752,3 @@\n-  assert(thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n+  assert(thread == Thread::current() ||\n+         thread->is_handshake_safe_for(Thread::current()) ||\n+         SafepointSynchronize::is_at_safepoint(),\n@@ -1765,1 +1767,2 @@\n-  if (thread == Thread::current()) {\n+  Thread* current = Thread::current();\n+  if (thread == current || thread->is_handshake_safe_for(current)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -537,82 +537,1 @@\n-\/\/\n-\/\/ The bits parameter returns information about the code path through\n-\/\/ the routine. Useful for debugging:\n-\/\/\n-\/\/ set in is_ext_suspend_completed():\n-\/\/ 0x00000001 - routine was entered\n-\/\/ 0x00000010 - routine return false at end\n-\/\/ 0x00000100 - thread exited (return false)\n-\/\/ 0x00000200 - suspend request cancelled (return false)\n-\/\/ 0x00000400 - thread suspended (return true)\n-\/\/ 0x00001000 - thread is in a suspend equivalent state (return true)\n-\/\/ 0x00002000 - thread is native and walkable (return true)\n-\/\/ 0x00004000 - thread is native_trans and walkable (needed retry)\n-\/\/\n-\/\/ set in wait_for_ext_suspend_completion():\n-\/\/ 0x00010000 - routine was entered\n-\/\/ 0x00020000 - suspend request cancelled before loop (return false)\n-\/\/ 0x00040000 - thread suspended before loop (return true)\n-\/\/ 0x00080000 - suspend request cancelled in loop (return false)\n-\/\/ 0x00100000 - thread suspended in loop (return true)\n-\/\/ 0x00200000 - suspend not completed during retry loop (return false)\n-\n-\/\/ Helper class for tracing suspend wait debug bits.\n-\/\/\n-\/\/ 0x00000100 indicates that the target thread exited before it could\n-\/\/ self-suspend which is not a wait failure. 0x00000200, 0x00020000 and\n-\/\/ 0x00080000 each indicate a cancelled suspend request so they don't\n-\/\/ count as wait failures either.\n-#define DEBUG_FALSE_BITS (0x00000010 | 0x00200000)\n-\n-class TraceSuspendDebugBits : public StackObj {\n- private:\n-  JavaThread * jt;\n-  bool         is_wait;\n-  bool         called_by_wait;  \/\/ meaningful when !is_wait\n-  uint32_t *   bits;\n-\n- public:\n-  TraceSuspendDebugBits(JavaThread *_jt, bool _is_wait, bool _called_by_wait,\n-                        uint32_t *_bits) {\n-    jt             = _jt;\n-    is_wait        = _is_wait;\n-    called_by_wait = _called_by_wait;\n-    bits           = _bits;\n-  }\n-\n-  ~TraceSuspendDebugBits() {\n-    if (!is_wait) {\n-#if 1\n-      \/\/ By default, don't trace bits for is_ext_suspend_completed() calls.\n-      \/\/ That trace is very chatty.\n-      return;\n-#else\n-      if (!called_by_wait) {\n-        \/\/ If tracing for is_ext_suspend_completed() is enabled, then only\n-        \/\/ trace calls to it from wait_for_ext_suspend_completion()\n-        return;\n-      }\n-#endif\n-    }\n-\n-    if (AssertOnSuspendWaitFailure || TraceSuspendWaitFailures) {\n-      if (bits != NULL && (*bits & DEBUG_FALSE_BITS) != 0) {\n-        MutexLocker ml(Threads_lock);  \/\/ needed for get_thread_name()\n-        ResourceMark rm;\n-\n-        tty->print_cr(\n-                      \"Failed wait_for_ext_suspend_completion(thread=%s, debug_bits=%x)\",\n-                      jt->get_thread_name(), *bits);\n-\n-        guarantee(!AssertOnSuspendWaitFailure, \"external suspend wait failed\");\n-      }\n-    }\n-  }\n-};\n-#undef DEBUG_FALSE_BITS\n-\n-\n-bool JavaThread::is_ext_suspend_completed(bool called_by_wait, int delay,\n-                                          uint32_t *bits) {\n-  TraceSuspendDebugBits tsdb(this, false \/* !is_wait *\/, called_by_wait, bits);\n-\n+bool JavaThread::is_ext_suspend_completed() {\n@@ -622,2 +541,0 @@\n-  *bits |= 0x00000001;\n-\n@@ -630,1 +547,0 @@\n-      *bits |= 0x00000100;\n@@ -638,1 +554,0 @@\n-      *bits |= 0x00000200;\n@@ -644,1 +559,0 @@\n-      *bits |= 0x00000400;\n@@ -672,1 +586,0 @@\n-      *bits |= 0x00001000;\n@@ -679,1 +592,0 @@\n-      *bits |= 0x00002000;\n@@ -681,1 +593,1 @@\n-    } else if (!called_by_wait && !did_trans_retry &&\n+    } else if (!did_trans_retry &&\n@@ -698,2 +610,0 @@\n-      *bits |= 0x00004000;\n-\n@@ -719,1 +629,1 @@\n-          SR_lock()->wait(i * delay);\n+          SR_lock()->wait(i * SuspendRetryDelay);\n@@ -721,1 +631,1 @@\n-          SR_lock()->wait_without_safepoint_check(i * delay);\n+          SR_lock()->wait_without_safepoint_check(i * SuspendRetryDelay);\n@@ -732,2 +642,0 @@\n-\n-\n@@ -737,89 +645,0 @@\n-  *bits |= 0x00000010;\n-  return false;\n-}\n-\n-\/\/ Wait for an external suspend request to complete (or be cancelled).\n-\/\/ Returns true if the thread is externally suspended and false otherwise.\n-\/\/\n-bool JavaThread::wait_for_ext_suspend_completion(int retries, int delay,\n-                                                 uint32_t *bits) {\n-  TraceSuspendDebugBits tsdb(this, true \/* is_wait *\/,\n-                             false \/* !called_by_wait *\/, bits);\n-\n-  \/\/ local flag copies to minimize SR_lock hold time\n-  bool is_suspended;\n-  bool pending;\n-  uint32_t reset_bits;\n-\n-  \/\/ set a marker so is_ext_suspend_completed() knows we are the caller\n-  *bits |= 0x00010000;\n-\n-  \/\/ We use reset_bits to reinitialize the bits value at the top of\n-  \/\/ each retry loop. This allows the caller to make use of any\n-  \/\/ unused bits for their own marking purposes.\n-  reset_bits = *bits;\n-\n-  {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    is_suspended = is_ext_suspend_completed(true \/* called_by_wait *\/,\n-                                            delay, bits);\n-    pending = is_external_suspend();\n-  }\n-  \/\/ must release SR_lock to allow suspension to complete\n-\n-  if (!pending) {\n-    \/\/ A cancelled suspend request is the only false return from\n-    \/\/ is_ext_suspend_completed() that keeps us from entering the\n-    \/\/ retry loop.\n-    *bits |= 0x00020000;\n-    return false;\n-  }\n-\n-  if (is_suspended) {\n-    *bits |= 0x00040000;\n-    return true;\n-  }\n-\n-  for (int i = 1; i <= retries; i++) {\n-    *bits = reset_bits;  \/\/ reinit to only track last retry\n-\n-    \/\/ We used to do an \"os::yield_all(i)\" call here with the intention\n-    \/\/ that yielding would increase on each retry. However, the parameter\n-    \/\/ is ignored on Linux which means the yield didn't scale up. Waiting\n-    \/\/ on the SR_lock below provides a much more predictable scale up for\n-    \/\/ the delay. It also provides a simple\/direct point to check for any\n-    \/\/ safepoint requests from the VMThread\n-\n-    {\n-      Thread* t = Thread::current();\n-      MonitorLocker ml(SR_lock(),\n-                       t->is_Java_thread() ? Mutex::_safepoint_check_flag : Mutex::_no_safepoint_check_flag);\n-      \/\/ wait with safepoint check (if we're a JavaThread - the WatcherThread\n-      \/\/ can also call this)  and increase delay with each retry\n-      ml.wait(i * delay);\n-\n-      is_suspended = is_ext_suspend_completed(true \/* called_by_wait *\/,\n-                                              delay, bits);\n-\n-      \/\/ It is possible for the external suspend request to be cancelled\n-      \/\/ (by a resume) before the actual suspend operation is completed.\n-      \/\/ Refresh our local copy to see if we still need to wait.\n-      pending = is_external_suspend();\n-    }\n-\n-    if (!pending) {\n-      \/\/ A cancelled suspend request is the only false return from\n-      \/\/ is_ext_suspend_completed() that keeps us from staying in the\n-      \/\/ retry loop.\n-      *bits |= 0x00080000;\n-      return false;\n-    }\n-\n-    if (is_suspended) {\n-      *bits |= 0x00100000;\n-      return true;\n-    }\n-  } \/\/ end retry loop\n-\n-  \/\/ thread did not suspend after all our retries\n-  *bits |= 0x00200000;\n@@ -829,31 +648,0 @@\n-\/\/ Called from API entry points which perform stack walking. If the\n-\/\/ associated JavaThread is the current thread, then wait_for_suspend\n-\/\/ is not used. Otherwise, it determines if we should wait for the\n-\/\/ \"other\" thread to complete external suspension. (NOTE: in future\n-\/\/ releases the suspension mechanism should be reimplemented so this\n-\/\/ is not necessary.)\n-\/\/\n-bool\n-JavaThread::is_thread_fully_suspended(bool wait_for_suspend, uint32_t *bits) {\n-  if (this != Thread::current()) {\n-    \/\/ \"other\" threads require special handling.\n-    if (wait_for_suspend) {\n-      \/\/ We are allowed to wait for the external suspend to complete\n-      \/\/ so give the other thread a chance to get suspended.\n-      if (!wait_for_ext_suspend_completion(SuspendRetryCount,\n-                                           SuspendRetryDelay, bits)) {\n-        \/\/ Didn't make it so let the caller know.\n-        return false;\n-      }\n-    }\n-    \/\/ We aren't allowed to wait for the external suspend to complete\n-    \/\/ so if the other thread isn't externally suspended we need to\n-    \/\/ let the caller know.\n-    else if (!is_ext_suspend_completed_with_lock(bits)) {\n-      return false;\n-    }\n-  }\n-\n-  return true;\n-}\n-\n@@ -2492,1 +2280,1 @@\n-    uint32_t debug_bits = 0;\n+\n@@ -2496,2 +2284,1 @@\n-    if (is_ext_suspend_completed(false \/* !called_by_wait *\/,\n-                                 SuspendRetryDelay, &debug_bits)) {\n+    if (is_ext_suspend_completed()) {\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":219,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -1397,20 +1397,1 @@\n-  bool is_ext_suspend_completed(bool called_by_wait, int delay, uint32_t *bits);\n-  bool is_ext_suspend_completed_with_lock(uint32_t *bits) {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    \/\/ Warning: is_ext_suspend_completed() may temporarily drop the\n-    \/\/ SR_lock to allow the thread to reach a stable thread state if\n-    \/\/ it is currently in a transient thread state.\n-    return is_ext_suspend_completed(false \/* !called_by_wait *\/,\n-                                    SuspendRetryDelay, bits);\n-  }\n-\n-  \/\/ We cannot allow wait_for_ext_suspend_completion() to run forever or\n-  \/\/ we could hang. SuspendRetryCount and SuspendRetryDelay are normally\n-  \/\/ passed as the count and delay parameters. Experiments with specific\n-  \/\/ calls to wait_for_ext_suspend_completion() can be done by passing\n-  \/\/ other values in the code. Experiments with all calls can be done\n-  \/\/ via the appropriate -XX options.\n-  bool wait_for_ext_suspend_completion(int count, int delay, uint32_t *bits);\n-\n-  \/\/ test for suspend - most (all?) of these should go away\n-  bool is_thread_fully_suspended(bool wait_for_suspend, uint32_t *bits);\n+  bool is_ext_suspend_completed();\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"}]}