{"files":[{"patch":"@@ -1637,4 +1637,0 @@\n-  JavaThread* current_thread  = JavaThread::current();\n-  HandleMark hm(current_thread);\n-  uint32_t debug_bits = 0;\n-\n@@ -1647,88 +1643,6 @@\n-  \/\/ Check if java_thread is fully suspended\n-  if (!java_thread->is_thread_fully_suspended(true \/* wait for suspend completion *\/, &debug_bits)) {\n-    return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-  }\n-  \/\/ Check to see if a PopFrame was already in progress\n-  if (java_thread->popframe_condition() != JavaThread::popframe_inactive) {\n-    \/\/ Probably possible for JVMTI clients to trigger this, but the\n-    \/\/ JPDA backend shouldn't allow this to happen\n-    return JVMTI_ERROR_INTERNAL;\n-  }\n-\n-  {\n-    \/\/ Was workaround bug\n-    \/\/    4812902: popFrame hangs if the method is waiting at a synchronize\n-    \/\/ Catch this condition and return an error to avoid hanging.\n-    \/\/ Now JVMTI spec allows an implementation to bail out with an opaque frame error.\n-    OSThread* osThread = java_thread->osthread();\n-    if (osThread->get_state() == MONITOR_WAIT) {\n-      return JVMTI_ERROR_OPAQUE_FRAME;\n-    }\n-  }\n-\n-  {\n-    ResourceMark rm(current_thread);\n-    \/\/ Check if there are more than one Java frame in this thread, that the top two frames\n-    \/\/ are Java (not native) frames, and that there is no intervening VM frame\n-    int frame_count = 0;\n-    bool is_interpreted[2];\n-    intptr_t *frame_sp[2];\n-    \/\/ The 2-nd arg of constructor is needed to stop iterating at java entry frame.\n-    for (vframeStream vfs(java_thread, true, false \/* process_frames *\/); !vfs.at_end(); vfs.next()) {\n-      methodHandle mh(current_thread, vfs.method());\n-      if (mh->is_native()) return(JVMTI_ERROR_OPAQUE_FRAME);\n-      is_interpreted[frame_count] = vfs.is_interpreted_frame();\n-      frame_sp[frame_count] = vfs.frame_id();\n-      if (++frame_count > 1) break;\n-    }\n-    if (frame_count < 2)  {\n-      \/\/ We haven't found two adjacent non-native Java frames on the top.\n-      \/\/ There can be two situations here:\n-      \/\/  1. There are no more java frames\n-      \/\/  2. Two top java frames are separated by non-java native frames\n-      if(vframeForNoProcess(java_thread, 1) == NULL) {\n-        return JVMTI_ERROR_NO_MORE_FRAMES;\n-      } else {\n-        \/\/ Intervening non-java native or VM frames separate java frames.\n-        \/\/ Current implementation does not support this. See bug #5031735.\n-        \/\/ In theory it is possible to pop frames in such cases.\n-        return JVMTI_ERROR_OPAQUE_FRAME;\n-      }\n-    }\n-\n-    \/\/ If any of the top 2 frames is a compiled one, need to deoptimize it\n-    for (int i = 0; i < 2; i++) {\n-      if (!is_interpreted[i]) {\n-        Deoptimization::deoptimize_frame(java_thread, frame_sp[i]);\n-      }\n-    }\n-\n-    \/\/ Update the thread state to reflect that the top frame is popped\n-    \/\/ so that cur_stack_depth is maintained properly and all frameIDs\n-    \/\/ are invalidated.\n-    \/\/ The current frame will be popped later when the suspended thread\n-    \/\/ is resumed and right before returning from VM to Java.\n-    \/\/ (see call_VM_base() in assembler_<cpu>.cpp).\n-\n-    \/\/ It's fine to update the thread state here because no JVMTI events\n-    \/\/ shall be posted for this PopFrame.\n-\n-    \/\/ It is only safe to perform the direct operation on the current\n-    \/\/ thread. All other usage needs to use a handshake for safety.\n-    {\n-      MutexLocker mu(JvmtiThreadState_lock);\n-      if (java_thread == JavaThread::current()) {\n-        state->update_for_pop_top_frame();\n-      } else {\n-        UpdateForPopTopFrameClosure op(state);\n-        Handshake::execute(&op, java_thread);\n-        if (op.result() != JVMTI_ERROR_NONE) {\n-          return op.result();\n-        }\n-      }\n-    }\n-\n-    java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n-    \/\/ Set pending step flag for this popframe and it is cleared when next\n-    \/\/ step event is posted.\n-    state->set_pending_step_for_popframe();\n+  MutexLocker mu(JvmtiThreadState_lock);\n+  UpdateForPopTopFrameClosure op(state);\n+  if (java_thread == JavaThread::current()) {\n+    op.doit(java_thread, true);\n+  } else {\n+    Handshake::execute(&op, java_thread);\n@@ -1736,2 +1650,1 @@\n-\n-  return JVMTI_ERROR_NONE;\n+  return op.result();\n@@ -1771,4 +1684,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  ResourceMark rm;\n-  uint32_t debug_bits = 0;\n-\n@@ -1780,21 +1689,1 @@\n-  if (!java_thread->is_thread_fully_suspended(true, &debug_bits)) {\n-    return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-  }\n-\n-  if (TraceJVMTICalls) {\n-    JvmtiSuspendControl::print();\n-  }\n-\n-  vframe *vf = vframeForNoProcess(java_thread, depth);\n-  if (vf == NULL) {\n-    return JVMTI_ERROR_NO_MORE_FRAMES;\n-  }\n-\n-  if (!vf->is_java_frame() || ((javaVFrame*) vf)->method()->is_native()) {\n-    return JVMTI_ERROR_OPAQUE_FRAME;\n-  }\n-\n-  assert(vf->frame_pointer() != NULL, \"frame pointer mustn't be NULL\");\n-\n-  \/\/ It is only safe to perform the direct operation on the current\n-  \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n+  SetFramePopClosure op(this, state, depth);\n@@ -1803,2 +1692,1 @@\n-    int frame_number = state->count_frames() - depth;\n-    state->env_thread_state(this)->set_frame_pop(frame_number);\n+    op.doit(java_thread, true);\n@@ -1806,1 +1694,0 @@\n-    SetFramePopClosure op(this, state, depth);\n@@ -1808,1 +1695,0 @@\n-    err = op.result();\n@@ -1810,1 +1696,1 @@\n-  return err;\n+  return op.result();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":10,"deletions":124,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/vframe.inline.hpp\"\n@@ -60,0 +61,1 @@\n+\n@@ -1372,4 +1374,0 @@\n-  Thread* current_thread = Thread::current();\n-  HandleMark   hm(current_thread);\n-  uint32_t debug_bits = 0;\n-\n@@ -1381,0 +1379,8 @@\n+  SetForceEarlyReturn op(state, value, tos);\n+  if (java_thread == JavaThread::current()) {\n+    op.doit(java_thread, true);\n+  } else {\n+    Handshake::execute(&op, java_thread);\n+  }\n+  return op.result();\n+}\n@@ -1382,3 +1388,11 @@\n-  \/\/ Check if java_thread is fully suspended\n-  if (!java_thread->is_thread_fully_suspended(true \/* wait for suspend completion *\/, &debug_bits)) {\n-    return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+void\n+SetForceEarlyReturn::doit(Thread *target, bool self) {\n+  JavaThread *java_thread = target->as_Java_thread();\n+  Thread* current_thread = Thread::current();\n+  HandleMark   hm(current_thread);\n+\n+  if (!self) {\n+    if (!java_thread->is_external_suspend()) {\n+      _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+      return;\n+    }\n@@ -1388,1 +1402,1 @@\n-  if (state->is_earlyret_pending()) {\n+  if (_state->is_earlyret_pending()) {\n@@ -1391,1 +1405,2 @@\n-    return JVMTI_ERROR_INTERNAL;\n+    _result = JVMTI_ERROR_INTERNAL;\n+    return;\n@@ -1401,1 +1416,2 @@\n-      return JVMTI_ERROR_OPAQUE_FRAME;\n+      _result = JVMTI_ERROR_OPAQUE_FRAME;\n+      return;\n@@ -1404,0 +1420,1 @@\n+\n@@ -1405,3 +1422,3 @@\n-  jvmtiError err = check_top_frame(current_thread, java_thread, value, tos, &ret_ob_h);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n+  _result = JvmtiEnvBase::check_top_frame(current_thread, java_thread, _value, _tos, &ret_ob_h);\n+  if (_result != JVMTI_ERROR_NONE) {\n+    return;\n@@ -1409,1 +1426,1 @@\n-  assert(tos != atos || value.l == NULL || ret_ob_h() != NULL,\n+  assert(_tos != atos || _value.l == NULL || ret_ob_h() != NULL,\n@@ -1418,3 +1435,3 @@\n-  state->set_earlyret_pending();\n-  state->set_earlyret_oop(ret_ob_h());\n-  state->set_earlyret_value(value, tos);\n+  _state->set_earlyret_pending();\n+  _state->set_earlyret_oop(ret_ob_h());\n+  _state->set_earlyret_value(_value, _tos);\n@@ -1424,4 +1441,2 @@\n-  state->set_pending_step_for_earlyret();\n-\n-  return JVMTI_ERROR_NONE;\n-} \/* end force_early_return *\/\n+  _state->set_pending_step_for_earlyret();\n+}\n@@ -1507,1 +1522,83 @@\n-UpdateForPopTopFrameClosure::do_thread(Thread *target) {\n+UpdateForPopTopFrameClosure::doit(Thread *target, bool self) {\n+  Thread* current_thread  = Thread::current();\n+  HandleMark hm(current_thread);\n+  JavaThread* java_thread = target->as_Java_thread();\n+\n+  if (!self) {\n+    if (!java_thread->is_external_suspend()) {\n+      _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+      return;\n+    }\n+  }\n+\n+  \/\/ Check to see if a PopFrame was already in progress\n+  if (java_thread->popframe_condition() != JavaThread::popframe_inactive) {\n+    \/\/ Probably possible for JVMTI clients to trigger this, but the\n+    \/\/ JPDA backend shouldn't allow this to happen\n+    _result = JVMTI_ERROR_INTERNAL;\n+    return;\n+  }\n+\n+  \/\/ Was workaround bug\n+  \/\/    4812902: popFrame hangs if the method is waiting at a synchronize\n+  \/\/ Catch this condition and return an error to avoid hanging.\n+  \/\/ Now JVMTI spec allows an implementation to bail out with an opaque frame error.\n+  OSThread* osThread = java_thread->osthread();\n+  if (osThread->get_state() == MONITOR_WAIT) {\n+    _result = JVMTI_ERROR_OPAQUE_FRAME;\n+    return;\n+  }\n+\n+  ResourceMark rm(current_thread);\n+  \/\/ Check if there are more than one Java frame in this thread, that the top two frames\n+  \/\/ are Java (not native) frames, and that there is no intervening VM frame\n+  int frame_count = 0;\n+  bool is_interpreted[2];\n+  intptr_t *frame_sp[2];\n+  \/\/ The 2-nd arg of constructor is needed to stop iterating at java entry frame.\n+  for (vframeStream vfs(java_thread, true); !vfs.at_end(); vfs.next()) {\n+    methodHandle mh(current_thread, vfs.method());\n+    if (mh->is_native()) {\n+      _result = JVMTI_ERROR_OPAQUE_FRAME;\n+      return;\n+    }\n+    is_interpreted[frame_count] = vfs.is_interpreted_frame();\n+    frame_sp[frame_count] = vfs.frame_id();\n+    if (++frame_count > 1) break;\n+  }\n+  if (frame_count < 2)  {\n+    \/\/ We haven't found two adjacent non-native Java frames on the top.\n+    \/\/ There can be two situations here:\n+    \/\/  1. There are no more java frames\n+    \/\/  2. Two top java frames are separated by non-java native frames\n+    if(JvmtiEnvBase::vframeForNoProcess(java_thread, 1) == NULL) {\n+      _result = JVMTI_ERROR_NO_MORE_FRAMES;\n+      return;\n+    } else {\n+      \/\/ Intervening non-java native or VM frames separate java frames.\n+      \/\/ Current implementation does not support this. See bug #5031735.\n+      \/\/ In theory it is possible to pop frames in such cases.\n+      _result = JVMTI_ERROR_OPAQUE_FRAME;\n+      return;\n+    }\n+  }\n+\n+  \/\/ If any of the top 2 frames is a compiled one, need to deoptimize it\n+  for (int i = 0; i < 2; i++) {\n+    if (!is_interpreted[i]) {\n+      Deoptimization::deoptimize_frame(java_thread, frame_sp[i]);\n+    }\n+  }\n+\n+  \/\/ Update the thread state to reflect that the top frame is popped\n+  \/\/ so that cur_stack_depth is maintained properly and all frameIDs\n+  \/\/ are invalidated.\n+  \/\/ The current frame will be popped later when the suspended thread\n+  \/\/ is resumed and right before returning from VM to Java.\n+  \/\/ (see call_VM_base() in assembler_<cpu>.cpp).\n+\n+  \/\/ It's fine to update the thread state here because no JVMTI events\n+  \/\/ shall be posted for this PopFrame.\n+\n+  \/\/ It is only safe to perform the direct operation on the current\n+  \/\/ thread. All other usage needs to use a handshake for safety.\n@@ -1512,0 +1609,4 @@\n+    java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n+    \/\/ Set pending step flag for this popframe and it is cleared when next\n+    \/\/ step event is posted.\n+    _state->set_pending_step_for_popframe();\n@@ -1517,7 +1618,27 @@\n-SetFramePopClosure::do_thread(Thread *target) {\n-  JavaThread* jt = _state->get_thread();\n-  assert(jt == target, \"just checking\");\n-  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n-    int frame_number = _state->count_frames() - _depth;\n-    _state->env_thread_state((JvmtiEnvBase*)_env)->set_frame_pop(frame_number);\n-    _result = JVMTI_ERROR_NONE;\n+SetFramePopClosure::doit(Thread *target, bool self) {\n+  ResourceMark rm;\n+  JavaThread* java_thread = target->as_Java_thread();\n+\n+  assert(_state->get_thread() == java_thread, \"Must be\");\n+\n+  if (!self) {\n+    if (!java_thread->is_external_suspend()) {\n+      _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+      return;\n+    }\n+  }\n+\n+  vframe *vf = JvmtiEnvBase::vframeForNoProcess(java_thread, _depth);\n+  if (vf == NULL) {\n+    _result = JVMTI_ERROR_NO_MORE_FRAMES;\n+    return;\n+  }\n+\n+  if (!vf->is_java_frame() || ((javaVFrame*) vf)->method()->is_native()) {\n+    _result = JVMTI_ERROR_OPAQUE_FRAME;\n+    return;\n+  }\n+\n+  assert(vf->frame_pointer() != NULL, \"frame pointer mustn't be NULL\");\n+  if (java_thread->is_exiting() || java_thread->threadObj() == NULL) {\n+    return;\n@@ -1525,0 +1646,3 @@\n+  int frame_number = _state->count_frames() - _depth;\n+  _state->env_thread_state((JvmtiEnvBase*)_env)->set_frame_pop(frame_number);\n+  _result = JVMTI_ERROR_NONE;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":153,"deletions":29,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -289,2 +289,0 @@\n-  vframe* vframeForNoProcess(JavaThread* java_thread, jint depth);\n-\n@@ -292,0 +290,2 @@\n+  static vframe* vframeForNoProcess(JavaThread* java_thread, jint depth);\n+\n@@ -309,1 +309,1 @@\n-  jvmtiError check_top_frame(Thread* current_thread, JavaThread* java_thread,\n+  static jvmtiError check_top_frame(Thread* current_thread, JavaThread* java_thread,\n@@ -349,0 +349,17 @@\n+class SetForceEarlyReturn : public JvmtiHandshakeClosure {\n+private:\n+  JvmtiThreadState* _state;\n+  jvalue _value;\n+  TosState _tos;\n+public:\n+  SetForceEarlyReturn(JvmtiThreadState* state, jvalue value, TosState tos)\n+    : JvmtiHandshakeClosure(\"SetForceEarlyReturn\"),\n+     _state(state),\n+     _value(value),\n+     _tos(tos) {}\n+  void do_thread(Thread *target) {\n+    doit(target, false);\n+  }\n+  void doit(Thread *target, bool self);\n+};\n+\n@@ -357,2 +374,5 @@\n-      _state(state) {}\n-  void do_thread(Thread *target);\n+     _state(state) {}\n+  void do_thread(Thread *target) {\n+    doit(target, false);\n+  }\n+  void doit(Thread *target, bool self);\n@@ -374,1 +394,4 @@\n-  void do_thread(Thread *target);\n+  void do_thread(Thread *target) {\n+    doit(target, false);\n+  }\n+  void doit(Thread *target, bool self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1645,1 +1645,3 @@\n-  assert(thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n+  assert(thread == Thread::current() ||\n+         thread->is_handshake_safe_for(Thread::current()) ||\n+         SafepointSynchronize::is_at_safepoint(),\n@@ -1658,1 +1660,2 @@\n-  if (thread == Thread::current()) {\n+  Thread* current = Thread::current();\n+  if (thread == current || thread->is_handshake_safe_for(current)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -567,4 +567,2 @@\n-  JavaThread * jt;\n-  bool         is_wait;\n-  bool         called_by_wait;  \/\/ meaningful when !is_wait\n-  uint32_t *   bits;\n+  JavaThread* _jt;\n+  uint32_t*   _bits;\n@@ -573,6 +571,1 @@\n-  TraceSuspendDebugBits(JavaThread *_jt, bool _is_wait, bool _called_by_wait,\n-                        uint32_t *_bits) {\n-    jt             = _jt;\n-    is_wait        = _is_wait;\n-    called_by_wait = _called_by_wait;\n-    bits           = _bits;\n+  TraceSuspendDebugBits(JavaThread *jt, uint32_t *bits) : _jt(jt), _bits(bits) {\n@@ -582,1 +575,0 @@\n-    if (!is_wait) {\n@@ -584,3 +576,3 @@\n-      \/\/ By default, don't trace bits for is_ext_suspend_completed() calls.\n-      \/\/ That trace is very chatty.\n-      return;\n+    \/\/ By default, don't trace bits for is_ext_suspend_completed() calls.\n+    \/\/ That trace is very chatty.\n+    return;\n@@ -588,5 +580,3 @@\n-      if (!called_by_wait) {\n-        \/\/ If tracing for is_ext_suspend_completed() is enabled, then only\n-        \/\/ trace calls to it from wait_for_ext_suspend_completion()\n-        return;\n-      }\n+    \/\/ If tracing for is_ext_suspend_completed() is enabled, then only\n+    \/\/ trace calls to it from wait_for_ext_suspend_completion()\n+    return;\n@@ -594,1 +584,0 @@\n-    }\n@@ -597,1 +586,1 @@\n-      if (bits != NULL && (*bits & DEBUG_FALSE_BITS) != 0) {\n+      if (_bits != NULL && (*_bits & DEBUG_FALSE_BITS) != 0) {\n@@ -603,1 +592,1 @@\n-                      jt->get_thread_name(), *bits);\n+                      _jt->get_thread_name(), *_bits);\n@@ -613,3 +602,2 @@\n-bool JavaThread::is_ext_suspend_completed(bool called_by_wait, int delay,\n-                                          uint32_t *bits) {\n-  TraceSuspendDebugBits tsdb(this, false \/* !is_wait *\/, called_by_wait, bits);\n+bool JavaThread::is_ext_suspend_completed(int delay, uint32_t *bits) {\n+  TraceSuspendDebugBits tsdb(this, bits);\n@@ -679,1 +667,1 @@\n-    } else if (!called_by_wait && !did_trans_retry &&\n+    } else if (!did_trans_retry &&\n@@ -739,119 +727,0 @@\n-\/\/ Wait for an external suspend request to complete (or be cancelled).\n-\/\/ Returns true if the thread is externally suspended and false otherwise.\n-\/\/\n-bool JavaThread::wait_for_ext_suspend_completion(int retries, int delay,\n-                                                 uint32_t *bits) {\n-  TraceSuspendDebugBits tsdb(this, true \/* is_wait *\/,\n-                             false \/* !called_by_wait *\/, bits);\n-\n-  \/\/ local flag copies to minimize SR_lock hold time\n-  bool is_suspended;\n-  bool pending;\n-  uint32_t reset_bits;\n-\n-  \/\/ set a marker so is_ext_suspend_completed() knows we are the caller\n-  *bits |= 0x00010000;\n-\n-  \/\/ We use reset_bits to reinitialize the bits value at the top of\n-  \/\/ each retry loop. This allows the caller to make use of any\n-  \/\/ unused bits for their own marking purposes.\n-  reset_bits = *bits;\n-\n-  {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    is_suspended = is_ext_suspend_completed(true \/* called_by_wait *\/,\n-                                            delay, bits);\n-    pending = is_external_suspend();\n-  }\n-  \/\/ must release SR_lock to allow suspension to complete\n-\n-  if (!pending) {\n-    \/\/ A cancelled suspend request is the only false return from\n-    \/\/ is_ext_suspend_completed() that keeps us from entering the\n-    \/\/ retry loop.\n-    *bits |= 0x00020000;\n-    return false;\n-  }\n-\n-  if (is_suspended) {\n-    *bits |= 0x00040000;\n-    return true;\n-  }\n-\n-  for (int i = 1; i <= retries; i++) {\n-    *bits = reset_bits;  \/\/ reinit to only track last retry\n-\n-    \/\/ We used to do an \"os::yield_all(i)\" call here with the intention\n-    \/\/ that yielding would increase on each retry. However, the parameter\n-    \/\/ is ignored on Linux which means the yield didn't scale up. Waiting\n-    \/\/ on the SR_lock below provides a much more predictable scale up for\n-    \/\/ the delay. It also provides a simple\/direct point to check for any\n-    \/\/ safepoint requests from the VMThread\n-\n-    {\n-      Thread* t = Thread::current();\n-      MonitorLocker ml(SR_lock(),\n-                       t->is_Java_thread() ? Mutex::_safepoint_check_flag : Mutex::_no_safepoint_check_flag);\n-      \/\/ wait with safepoint check (if we're a JavaThread - the WatcherThread\n-      \/\/ can also call this)  and increase delay with each retry\n-      ml.wait(i * delay);\n-\n-      is_suspended = is_ext_suspend_completed(true \/* called_by_wait *\/,\n-                                              delay, bits);\n-\n-      \/\/ It is possible for the external suspend request to be cancelled\n-      \/\/ (by a resume) before the actual suspend operation is completed.\n-      \/\/ Refresh our local copy to see if we still need to wait.\n-      pending = is_external_suspend();\n-    }\n-\n-    if (!pending) {\n-      \/\/ A cancelled suspend request is the only false return from\n-      \/\/ is_ext_suspend_completed() that keeps us from staying in the\n-      \/\/ retry loop.\n-      *bits |= 0x00080000;\n-      return false;\n-    }\n-\n-    if (is_suspended) {\n-      *bits |= 0x00100000;\n-      return true;\n-    }\n-  } \/\/ end retry loop\n-\n-  \/\/ thread did not suspend after all our retries\n-  *bits |= 0x00200000;\n-  return false;\n-}\n-\n-\/\/ Called from API entry points which perform stack walking. If the\n-\/\/ associated JavaThread is the current thread, then wait_for_suspend\n-\/\/ is not used. Otherwise, it determines if we should wait for the\n-\/\/ \"other\" thread to complete external suspension. (NOTE: in future\n-\/\/ releases the suspension mechanism should be reimplemented so this\n-\/\/ is not necessary.)\n-\/\/\n-bool\n-JavaThread::is_thread_fully_suspended(bool wait_for_suspend, uint32_t *bits) {\n-  if (this != Thread::current()) {\n-    \/\/ \"other\" threads require special handling.\n-    if (wait_for_suspend) {\n-      \/\/ We are allowed to wait for the external suspend to complete\n-      \/\/ so give the other thread a chance to get suspended.\n-      if (!wait_for_ext_suspend_completion(SuspendRetryCount,\n-                                           SuspendRetryDelay, bits)) {\n-        \/\/ Didn't make it so let the caller know.\n-        return false;\n-      }\n-    }\n-    \/\/ We aren't allowed to wait for the external suspend to complete\n-    \/\/ so if the other thread isn't externally suspended we need to\n-    \/\/ let the caller know.\n-    else if (!is_ext_suspend_completed_with_lock(bits)) {\n-      return false;\n-    }\n-  }\n-\n-  return true;\n-}\n-\n@@ -2493,2 +2362,1 @@\n-    if (is_ext_suspend_completed(false \/* !called_by_wait *\/,\n-                                 SuspendRetryDelay, &debug_bits)) {\n+    if (is_ext_suspend_completed(SuspendRetryDelay, &debug_bits)) {\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":15,"deletions":147,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -1387,1 +1387,1 @@\n-  bool is_ext_suspend_completed(bool called_by_wait, int delay, uint32_t *bits);\n+  bool is_ext_suspend_completed(int delay, uint32_t *bits);\n@@ -1393,2 +1393,1 @@\n-    return is_ext_suspend_completed(false \/* !called_by_wait *\/,\n-                                    SuspendRetryDelay, bits);\n+    return is_ext_suspend_completed(SuspendRetryDelay, bits);\n@@ -1397,11 +1396,0 @@\n-  \/\/ We cannot allow wait_for_ext_suspend_completion() to run forever or\n-  \/\/ we could hang. SuspendRetryCount and SuspendRetryDelay are normally\n-  \/\/ passed as the count and delay parameters. Experiments with specific\n-  \/\/ calls to wait_for_ext_suspend_completion() can be done by passing\n-  \/\/ other values in the code. Experiments with all calls can be done\n-  \/\/ via the appropriate -XX options.\n-  bool wait_for_ext_suspend_completion(int count, int delay, uint32_t *bits);\n-\n-  \/\/ test for suspend - most (all?) of these should go away\n-  bool is_thread_fully_suspended(bool wait_for_suspend, uint32_t *bits);\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"}]}