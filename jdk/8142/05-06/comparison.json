{"files":[{"patch":"@@ -693,0 +693,2 @@\n+#define ALC_ZOPC    (unsigned long)(227L << 40 | 152L)\n+#define ALCG_ZOPC   (unsigned long)(227L << 40 | 136L)\n@@ -1452,1 +1454,2 @@\n-    bcondLogCarry            =  bcondLogZero_Carry | bcondLogNotZero_Carry,\n+    bcondLogCarry            =  bcondLogZero_Carry    | bcondLogNotZero_Carry,\n+    bcondLogNoCarry          =  bcondLogZero_NoCarry  | bcondLogNotZero_NoCarry,\n@@ -2129,0 +2132,2 @@\n+  inline void z_alc( Register r1, int64_t d2, Register x2, Register b2);\/\/ add r1 = r1 + *(d2_imm20+x2+b2) + c ; int32\n+  inline void z_alcg(Register r1, int64_t d2, Register x2, Register b2);\/\/ add r1 = r1 + *(d2_imm20+x2+b2) + c ; int64\n@@ -2137,0 +2142,2 @@\n+  inline void z_alc( Register r1, const Address& a);                  \/\/ add r1 = r1 + *(a) + c          ; int32\n+  inline void z_alcg(Register r1, const Address& a);                  \/\/ add r1 = r1 + *(a) + c          ; int64\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -534,0 +534,5 @@\n+inline void Assembler::z_alc( Register r1, int64_t d2, Register x2, Register b2) { emit_48( ALC_ZOPC  | regt(r1, 8, 48) | rxymask_48(d2, x2, b2)); }\n+inline void Assembler::z_alcg(Register r1, int64_t d2, Register x2, Register b2) { emit_48( ALCG_ZOPC | regt(r1, 8, 48) | rxymask_48(d2, x2, b2)); }\n+inline void Assembler::z_alc( Register r1, const Address& a) { z_alc( r1, a.disp(), a.indexOrR0(), a.baseOrR0()); }\n+inline void Assembler::z_alcg(Register r1, const Address& a) { z_alcg(r1, a.disp(), a.indexOrR0(), a.baseOrR0()); }\n+\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1952,3 +1952,3 @@\n-    __ add2reg(counter, AES_parmBlk_align, parmBlk);             \/\/ counter array is located behind crypto key. Available range is disp12 only.\n-    __ z_mvc(0, AES_ctrVal_len-1, counter, 0, ctr);              \/\/ move first copy of iv\n-    for (int j = 1; j < AES_ctrVec_len; j+=j) {                  \/\/ j (and amount of moved data) doubles with every iteration\n+    __ add2reg(counter, AES_parmBlk_align, parmBlk);       \/\/ counter array is located behind crypto key. Available range is disp12 only.\n+    __ z_mvc(0, AES_ctrVal_len-1, counter, 0, ctr);        \/\/ move first copy of iv\n+    for (int j = 1; j < AES_ctrVec_len; j+=j) {            \/\/ j (and amount of moved data) doubles with every iteration\n@@ -1957,1 +1957,1 @@\n-        __ z_mvc(offset, offset-1, counter, 0, counter);         \/\/ move iv\n+        __ z_mvc(offset, offset-1, counter, 0, counter);   \/\/ move iv\n@@ -1964,1 +1964,14 @@\n-    for (int j = 1; j < AES_ctrVec_len; j++) {                   \/\/ start with j = 1; no need to add 0 to the first counter value.\n+\n+    Label noCarry, done;\n+    __ z_lg(scratch, Address(ctr, 8));                     \/\/ get low-order DW of initial counter.\n+    __ z_algfi(scratch, AES_ctrVec_len);                   \/\/ check if we will overflow during init.\n+    __ z_brc(Assembler::bcondLogNoCarry, noCarry);         \/\/ No, 64-bit increment is sufficient.\n+\n+    for (int j = 1; j < AES_ctrVec_len; j++) {             \/\/ start with j = 1; no need to add 0 to the first counter value.\n+      int offset = j * AES_ctrVal_len;\n+      generate_increment128(counter, offset, j, scratch);  \/\/ increment iv by index value\n+    }\n+    __ z_bru(done);\n+\n+    __ bind(noCarry);\n+    for (int j = 1; j < AES_ctrVec_len; j++) {             \/\/ start with j = 1; no need to add 0 to the first counter value.\n@@ -1966,2 +1979,1 @@\n-      __ z_algsi(offset + 8, counter, j);                        \/\/ increment iv by index value\n-                                                                 \/\/ TODO: for correctness, use 128-bit add\n+      generate_increment64(counter, offset, j);            \/\/ increment iv by index value\n@@ -1970,0 +1982,2 @@\n+    __ bind(done);\n+\n@@ -1974,1 +1988,1 @@\n-  void generate_counterMode_increment_ctrVector(Register parmBlk, Register counter, bool v0_only) {\n+  void generate_counterMode_increment_ctrVector(Register parmBlk, Register counter, Register scratch, bool v0_only) {\n@@ -1978,1 +1992,1 @@\n-    __ add2reg(counter, AES_parmBlk_align, parmBlk);             \/\/ ptr to counter array needs to be restored\n+    __ add2reg(counter, AES_parmBlk_align, parmBlk);       \/\/ ptr to counter array needs to be restored\n@@ -1981,2 +1995,1 @@\n-      __ z_algsi(offset + 8, counter, AES_ctrVec_len);           \/\/ calculate new ctr vector elements (simple increment)\n-                                                                 \/\/ TODO: for correctness, use 128-bit add\n+      generate_increment128(counter, offset, AES_ctrVec_len, scratch); \/\/ increment iv by # vector elements\n@@ -1989,0 +2002,10 @@\n+  void generate_increment64(Register counter, int offset, int increment) {\n+    __ z_algsi(offset + 8, counter, increment);            \/\/ increment, no overflow check\n+  }\n+\n+  void generate_increment128(Register counter, int offset, int increment, Register scratch) {\n+    __ clear_reg(scratch);                                 \/\/ prepare to add carry to high-order DW\n+    __ z_algsi(offset + 8, counter, increment);            \/\/ increment low order DW\n+    __ z_alcg(scratch, Address(counter, offset));          \/\/ add carry to high-order DW\n+    __ z_stg(scratch, Address(counter, offset));           \/\/ store back\n+  }\n@@ -2267,1 +2290,1 @@\n-      generate_counterMode_increment_ctrVector(parmBlk, counter, false);\n+      generate_counterMode_increment_ctrVector(parmBlk, counter, srclen, false); \/\/ srclen unused here (serves as scratch)\n@@ -2338,1 +2361,1 @@\n-      generate_counterMode_increment_ctrVector(parmBlk, counter, true);\n+      generate_counterMode_increment_ctrVector(parmBlk, counter, srclen, true); \/\/ srclen unused here (serves as scratch)\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"}]}