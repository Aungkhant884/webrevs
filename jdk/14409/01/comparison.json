{"files":[{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -32,1 +31,0 @@\n-import java.util.List;\n@@ -47,2 +45,0 @@\n-    @Stable\n-    private final MethodHandle[] handleMap = new MethodHandle[AccessMode.COUNT];\n@@ -69,10 +65,0 @@\n-    @Override\n-    public Class<?> varType() {\n-        return value;\n-    }\n-\n-    @Override\n-    public List<Class<?>> coordinateTypes() {\n-        return List.of(coordinates);\n-    }\n-\n@@ -89,4 +75,0 @@\n-    VarHandle target() {\n-        return target;\n-    }\n-\n@@ -100,0 +82,7 @@\n+    @Override\n+    public VarHandle withInvokeBehavior() {\n+        return !hasInvokeExactBehavior()\n+                ? this\n+                : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, false);\n+    }\n+\n@@ -108,4 +97,2 @@\n-    public VarHandle withInvokeBehavior() {\n-        return !hasInvokeExactBehavior()\n-            ? this\n-            : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, false);\n+    public boolean isAccessModeSupported(AccessMode accessMode) {\n+        return directTarget.isAccessModeSupported(accessMode);\n@@ -115,8 +102,3 @@\n-    @ForceInline\n-    MethodHandle getMethodHandle(int mode) {\n-        MethodHandle handle = handleMap[mode];\n-        if (handle == null) {\n-            MethodHandle targetHandle = target.getMethodHandle(mode); \/\/ might throw UOE of access mode is not supported, which is ok\n-            handle = handleMap[mode] = handleFactory.apply(AccessMode.values()[mode], targetHandle);\n-        }\n-        return handle;\n+    MethodHandle getMethodHandleUncached(int mode) {\n+        MethodHandle targetHandle = target.getMethodHandle(mode); \/\/ might throw UOE of access mode is not supported, which is ok\n+        return handleFactory.apply(AccessMode.values()[mode], targetHandle);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/IndirectVarHandle.java","additions":13,"deletions":31,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -529,2 +529,0 @@\n-    VarHandle target() { return null; }\n-\n@@ -2123,1 +2121,1 @@\n-    public final boolean isAccessModeSupported(AccessMode accessMode) {\n+    public boolean isAccessModeSupported(AccessMode accessMode) {\n@@ -2179,1 +2177,1 @@\n-    MethodHandle getMethodHandle(int mode) {\n+    final MethodHandle getMethodHandle(int mode) {\n@@ -2191,1 +2189,1 @@\n-    private final MethodHandle getMethodHandleUncached(int mode) {\n+    MethodHandle getMethodHandleUncached(int mode) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8307508\n+ * @enablePreview\n+ * @run junit IndirectVarHandleTest\n+ * @summary Test VarHandle::isAccessModeSupported on indirect VarHandle produced by MethodHandles.filterCoordinates\n+ *\/\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.function.IntUnaryOperator;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class IndirectVarHandleTest {\n+    @Test\n+    public void testIsAccessModeTypeSupported() throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        var intArrayVh = MethodHandles.arrayElementVarHandle(int[].class);\n+        var addOne = lookup.bind((IntUnaryOperator) a -> a + 1, \"applyAsInt\", MethodType.methodType(int.class, int.class));\n+        var offsetIntArrayVh = MethodHandles.filterCoordinates(intArrayVh, 1, addOne);\n+\n+        for (var mode : VarHandle.AccessMode.values()) {\n+            assertEquals(intArrayVh.isAccessModeSupported(mode), offsetIntArrayVh.isAccessModeSupported(mode), mode.toString());\n+        }\n+\n+        var stringArrayVh = MethodHandles.arrayElementVarHandle(String[].class);\n+        var offsetStringArrayVh = MethodHandles.filterCoordinates(stringArrayVh, 1, addOne);\n+\n+        for (var mode : VarHandle.AccessMode.values()) {\n+            assertEquals(stringArrayVh.isAccessModeSupported(mode), offsetStringArrayVh.isAccessModeSupported(mode), mode.toString());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/IndirectVarHandleTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"}]}