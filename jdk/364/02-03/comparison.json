{"files":[{"patch":"@@ -71,0 +71,1 @@\n+  _indy_items = new (ResourceObj::C_HEAP, mtClass) GrowableArray<const char*>(9, mtClass);\n@@ -101,1 +102,1 @@\n-  _cp_index = _unspecified;\n+  _indy_items->clear();\n@@ -123,0 +124,1 @@\n+    _class_name = _line;\n@@ -125,15 +127,2 @@\n-  int min_len = (int)strlen(LAMBDA_PROXY_TAG);\n-  if (_line[0] == '@' && _line_len < min_len) {\n-    error(\"line #%d \\\"%s\\\" with length %d too short\", _line_no, _line, _line_len);\n-    return false;\n-  }\n-\n-  bool lambda_proxy_line = false;\n-  int class_name_offset = 0;\n-  if (strncmp(_line, LAMBDA_PROXY_TAG, min_len) == 0) {\n-    lambda_proxy_line = true;\n-    if (_line[min_len] != ' ') {\n-      error(\"line #%d \\\"%s\\\" expecting a blank space after \\\":\\\"\", _line_no, _line);\n-      return false;\n-    }\n-    class_name_offset = min_len + 1;\n+  if (_line[0] == '@') {\n+    return parse_at_tags();\n@@ -142,10 +131,3 @@\n-  _class_name = _line + class_name_offset;\n-  _token = strchr(_line + class_name_offset, ' ');\n-  if (_token == NULL) {\n-    if (!lambda_proxy_line) {\n-      \/\/ No optional arguments are specified.\n-      return true;\n-    } else {\n-      error(\"Expecting an index number following the class name\");\n-      return false;\n-    }\n+  if ((_token = strchr(_line, ' ')) == NULL) {\n+    \/\/ No optional arguments are specified.\n+    return true;\n@@ -181,2 +163,0 @@\n-    } else if (lambda_proxy_line) {\n-      parse_int(&_cp_index);\n@@ -188,3 +168,1 @@\n-  \/\/ if it is a lambda_proxy_line\n-  \/\/     only indy_index should be specified\n-  \/\/ else if src is specified\n+  \/\/ if src is specified\n@@ -200,0 +178,35 @@\n+void ClassListParser::split_tokens_by_whitespace() {\n+  int start = 0;\n+  int end;\n+  bool done = false;\n+  while (!done) {\n+    while (_line[start] == ' ' || _line[start] == '\\t') start++;\n+    end = start;\n+    while (_line[end] && _line[end] != ' ' && _line[end] != '\\t') end++;\n+    if (_line[end] == '\\0') {\n+      done = true;\n+    } else {\n+      _line[end] = '\\0';\n+    }\n+    _indy_items->append(_line + start);\n+    start = ++end;\n+  }\n+}\n+\n+bool ClassListParser::parse_at_tags() {\n+  assert(_line[0] == '@', \"must be\");\n+  split_tokens_by_whitespace();\n+  if (strcmp(_indy_items->at(0), LAMBDA_PROXY_TAG) == 0) {\n+    if (_indy_items->length() < 3) {\n+      error(\"Line with @ tag has too few items \\\"%s\\\" line #%d\", _line, _line_no);\n+      return false;\n+    }\n+    \/\/ set the class name\n+    _class_name = _indy_items->at(1);\n+    return true;\n+  } else {\n+    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%d\", _line, _line_no);\n+    return false;\n+  }\n+}\n+\n@@ -377,0 +390,47 @@\n+void ClassListParser::populate_cds_indy_info(const constantPoolHandle &pool, int cp_index, CDSIndyInfo* cii, TRAPS) {\n+  \/\/ Caller needs to allocate ResourceMark.\n+  int type_index = pool->bootstrap_name_and_type_ref_index_at(cp_index);\n+  int name_index = pool->name_ref_index_at(type_index);\n+  cii->add_item(pool->symbol_at(name_index)->as_C_string());\n+  int sig_index = pool->signature_ref_index_at(type_index);\n+  cii->add_item(pool->symbol_at(sig_index)->as_C_string());\n+  int argc = pool->bootstrap_argument_count_at(cp_index);\n+  if (argc > 0) {\n+    for (int arg_i = 0; arg_i < argc; arg_i++) {\n+      int arg = pool->bootstrap_argument_index_at(cp_index, arg_i);\n+      jbyte tag = pool->tag_at(arg).value();\n+      if (tag == JVM_CONSTANT_MethodType) {\n+        cii->add_item(pool->method_type_signature_at(arg)->as_C_string());\n+      } else if (tag == JVM_CONSTANT_MethodHandle) {\n+        cii->add_ref_kind(pool->method_handle_ref_kind_at(arg));\n+        int callee_index = pool->method_handle_klass_index_at(arg);\n+        Klass* callee = pool->klass_at(callee_index, THREAD);\n+        if (callee != NULL) {\n+          cii->add_item(callee->name()->as_C_string());\n+        }\n+        cii->add_item(pool->method_handle_name_ref_at(arg)->as_C_string());\n+        cii->add_item(pool->method_handle_signature_ref_at(arg)->as_C_string());\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    }\n+  }\n+}\n+\n+bool ClassListParser::is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  CDSIndyInfo cii;\n+  populate_cds_indy_info(pool, cp_index, &cii, THREAD);\n+  GrowableArray<const char*>* items = cii.items();\n+  int indy_info_offset = 2;\n+  if (_indy_items->length() - indy_info_offset != items->length()) {\n+    return false;\n+  }\n+  for (int i = 0; i < items->length(); i++) {\n+    if (strcmp(_indy_items->at(i + indy_info_offset), items->at(i)) != 0) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -389,0 +449,1 @@\n+    bool found = false;\n@@ -393,7 +454,2 @@\n-      if (pool_index == _cp_index) {\n-        constantPoolHandle pool(THREAD, cp);\n-        if (!pool->tag_at(pool_index).has_bootstrap()) {\n-          ResourceMark rm(THREAD);\n-          tty->print_cr(\"Invalid cp_index %d for class %s\", pool_index, ik->name()->as_C_string());\n-          exit(1);\n-        }\n+      constantPoolHandle pool(THREAD, cp);\n+      if (pool->tag_at(pool_index).is_invoke_dynamic()) {\n@@ -404,1 +460,1 @@\n-           exit(1);\n+           continue;\n@@ -406,10 +462,25 @@\n-        CallInfo info;\n-        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(info, THREAD);\n-        if (!is_done) {\n-          \/\/ resolve it\n-          Handle recv;\n-          LinkResolver::resolve_invoke(info, recv, pool, indy_index, Bytecodes::_invokedynamic, THREAD);\n-        }\n-        cpce->set_dynamic_call(pool, info);\n-        if (HAS_PENDING_EXCEPTION) {\n-          exit(1);\n+        if (is_matching_cp_entry(pool, pool_index, THREAD)) {\n+          found = true;\n+          CallInfo info;\n+          bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(info, THREAD);\n+          if (!is_done) {\n+            \/\/ resolve it\n+            Handle recv;\n+            LinkResolver::resolve_invoke(info, recv, pool, indy_index, Bytecodes::_invokedynamic, THREAD);\n+            break;\n+          }\n+          cpce->set_dynamic_call(pool, info);\n+          if (HAS_PENDING_EXCEPTION) {\n+            ResourceMark rm(THREAD);\n+            tty->print(\"resolve_indy for class %s has\", class_name_symbol->as_C_string());\n+            oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n+            if (message != NULL) {\n+              char* ex_msg = java_lang_String::as_utf8_string(message);\n+              tty->print_cr(\" exception pending '%s %s'\",\n+                         PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n+            } else {\n+              tty->print_cr(\" exception pending %s \",\n+                         PENDING_EXCEPTION->klass()->external_name());\n+            }\n+            exit(1);\n+          }\n@@ -419,0 +490,5 @@\n+    if (!found) {\n+      ResourceMark rm(THREAD);\n+      log_warning(cds)(\"No invoke dynamic constant pool entry can be found for class %s. The classlist is probably out-of-date.\",\n+                     class_name_symbol->as_C_string());\n+    }\n@@ -425,1 +501,1 @@\n-  if (_cp_index != _unspecified) {\n+  if (_indy_items->length() > 0) {\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":126,"deletions":50,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -40,0 +40,21 @@\n+class CDSIndyInfo {\n+  char _ref_kind[10];\n+  GrowableArray<const char*>* _items;\n+public:\n+  CDSIndyInfo() : _items(NULL) {_ref_kind[0] = '\\0';}\n+  void add_item(const char* item) {\n+    if (_items == NULL) {\n+      _items = new GrowableArray<const char*>(9);\n+    }\n+    assert(_items != NULL, \"sanity\");\n+    _items->append(item);\n+  }\n+  void add_ref_kind(int ref_kind) {\n+    sprintf(_ref_kind, \"%d\", ref_kind);\n+    _items->append(_ref_kind);\n+  }\n+  GrowableArray<const char*>* items() {\n+    return _items;\n+  }\n+};\n+\n@@ -66,1 +87,1 @@\n-  int                 _cp_index;\n+  GrowableArray<const char*>* _indy_items;    \/\/ items related to invoke dynamic for archiving lambda proxy classes\n@@ -82,0 +103,2 @@\n+  bool is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS);\n+\n@@ -91,0 +114,2 @@\n+  void split_tokens_by_whitespace();\n+  bool parse_at_tags();\n@@ -135,0 +160,2 @@\n+\n+  static void populate_cds_indy_info(const constantPoolHandle &pool, int cp_index, CDSIndyInfo* cii, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/classListParser.hpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1913,0 +1913,6 @@\n+    tty->print_cr(\"bsi check failed\");\n+    tty->print_cr(\"    bsi.arg_values().not_null() %d\", bsi.arg_values().not_null());\n+    if (bsi.arg_values().not_null()) {\n+      tty->print_cr(\"    bsi.arg_values()->is_objArray() %d\", bsi.arg_values()->is_objArray());\n+      bsi.print();\n+    }\n@@ -1918,0 +1924,4 @@\n+    tty->print_cr(\"bsm check failed\");\n+    tty->print_cr(\"    bsm.is_null() %d\", bsm.is_null());\n+    tty->print_cr(\"    java_lang_invoke_DirectMethodHandle::is_instance(bsm()) %d\",\n+      java_lang_invoke_DirectMethodHandle::is_instance(bsm()));\n@@ -1927,0 +1937,6 @@\n+  } else {\n+    ResourceMark rm;\n+    tty->print_cr(\"method check failed\");\n+    tty->print_cr(\"    klass_name() %s\", method->klass_name()->as_C_string());\n+    tty->print_cr(\"    name() %s\", method->name()->as_C_string());\n+    tty->print_cr(\"    signature() %s\", method->signature()->as_C_string());\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"memory\/archiveUtils.hpp\"\n@@ -1772,6 +1773,2 @@\n-  if (DumpLoadedClassList != NULL && classlist_file->is_open()) {\n-    if (SystemDictionaryShared::is_supported_invokedynamic(bootstrap_specifier)) {\n-      ResourceMark rm(THREAD);\n-      classlist_file->print_cr(\"%s %s %d\", LAMBDA_PROXY_TAG, pool->pool_holder()->name()->as_C_string(), pool_index);\n-    }\n-  }\n+  \/\/ Log dynamic info to CDS classlist.\n+  ArchiveUtils::log_to_classlist(bootstrap_specifier, THREAD);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+#include \"classfile\/classListParser.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"interpreter\/bootstrapInfo.hpp\"\n@@ -32,0 +35,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -300,0 +304,18 @@\n+\n+void ArchiveUtils::log_to_classlist(BootstrapInfo bootstrap_specifier, TRAPS) {\n+  if (DumpLoadedClassList != NULL && classlist_file->is_open()) {\n+    if (SystemDictionaryShared::is_supported_invokedynamic(bootstrap_specifier)) {\n+      ResourceMark rm(THREAD);\n+      const constantPoolHandle& pool = bootstrap_specifier.pool();\n+      int pool_index = bootstrap_specifier.bss_index();\n+      classlist_file->print(\"%s %s\", LAMBDA_PROXY_TAG, pool->pool_holder()->name()->as_C_string());\n+      CDSIndyInfo cii;\n+      ClassListParser::populate_cds_indy_info(pool, pool_index, &cii, THREAD);\n+      GrowableArray<const char*>* indy_items = cii.items();\n+      for (int i = 0; i < indy_items->length(); i++) {\n+        classlist_file->print(\" %s\", indy_items->at(i));\n+      }\n+      classlist_file->print_cr(\"\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+class BootstrapInfo;\n@@ -242,0 +243,5 @@\n+class ArchiveUtils {\n+public:\n+  static void log_to_classlist(BootstrapInfo bootstrap_specifier, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3834,1 +3834,1 @@\n-    JVMWrapper(\"JVM_IsCDSDumpingEnable\");\n+    JVMWrapper(\"JVM_IsCDSDumpingEnabled\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-        dumpArchive = CDS.isCDSDumpingEnabled();\n+        dumpArchive = CDS.isDumpingEnabled();\n@@ -131,1 +131,1 @@\n-        if (!loadedByBuiltinLoader(caller) ||\n+        if (!loadedByBuiltinLoader(caller) || !initialize ||\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaProxyClassArchive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    public static native boolean isCDSDumpingEnabled();\n+    public static native boolean isDumpingEnabled();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-Java_jdk_internal_misc_CDS_isCDSDumpingEnabled(JNIEnv *env, jclass jcls) {\n+Java_jdk_internal_misc_CDS_isDumpingEnabled(JNIEnv *env, jclass jcls) {\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -334,1 +334,0 @@\n- -runtime\/cds\/appcds\/BadCPIndex.java \\\n@@ -337,0 +336,1 @@\n+ -runtime\/cds\/appcds\/LambdaProxyClasslist.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    out.shouldHaveExitValue(1);\n+    out.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/BadBSM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary CDS dump should abort upon detection of a bad CP index in the classlist.\n- * @requires vm.cds\n- * @library \/test\/lib\n- * @compile dynamicArchive\/test-classes\/StrConcatApp.java\n- * @run driver BadCPIndex\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class BadCPIndex {\n-\n-  public static void main(String[] args) throws Exception {\n-    JarBuilder.build(\"strconcatapp\", \"StrConcatApp\");\n-\n-    String appJar = TestCommon.getTestJar(\"strconcatapp.jar\");\n-\n-    \/\/ test with an invalid indy index, it should be a negative integer\n-    OutputAnalyzer out = TestCommon.dump(appJar,\n-        TestCommon.list(\"StrConcatApp\",\n-                        \"@lambda-proxy: StrConcatApp 7\"));\n-    out.shouldHaveExitValue(1);\n-    out.shouldContain(\"Invalid cp_index 7 for class StrConcatApp\");\n-\n-  }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/BadCPIndex.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test some error handling on the \"@lambda-proxy\" entries in a classlist.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile dynamicArchive\/test-classes\/LambHello.java\n+ * @run driver LambdaProxyClasslist\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class LambdaProxyClasslist {\n+\n+  public static void main(String[] args) throws Exception {\n+    JarBuilder.build(\"lambhello\", \"LambHello\");\n+\n+    String appJar = TestCommon.getTestJar(\"lambhello.jar\");\n+\n+    \/\/ 1. No error with a correct @lambda-proxy entry.\n+    OutputAnalyzer out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy: LambHello run ()Ljava\/lang\/Runnable; ()V 6 LambHello lambda$main$0 ()V ()V\"));\n+    out.shouldHaveExitValue(0);\n+\n+    \/\/ 2. Error if the @lambda-proxy entry is too short.\n+    out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy: LambHello\"));\n+    out.shouldContain(\"An error has occurred while processing class list file\")\n+       .shouldContain(\"Line with @ tag has too few items \\\"@lambda-proxy:\\\" line #2\")\n+       .shouldContain(\"class list format error\")\n+       .shouldHaveExitValue(1);\n+\n+    \/\/ 3. Warning message if there's an incorrect signature in the @lambda-proxy entry.\n+    out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy: LambHello run ()Ljava\/lang\/Runnable; ()V 6 LambHello lambda$main$0 ()V ()Z\"));\n+    out.shouldContain(\"[warning][cds] No invoke dynamic constant pool entry can be found for class LambHello. The classlist is probably out-of-date.\")\n+       .shouldHaveExitValue(0);\n+\n+    \/\/ 4. More blank spaces in between items should be fine.\n+    out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy:  LambHello run  ()Ljava\/lang\/Runnable; ()V 6 LambHello lambda$main$0 ()V ()V\"));\n+    out.shouldHaveExitValue(0);\n+\n+    \/\/ 5. Trailing spaces at the end of the @lambda-proxy line should be fine.\n+    out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy: LambHello run ()Ljava\/lang\/Runnable; ()V 6 LambHello lambda$main$0 ()V ()V \"));\n+    out.shouldHaveExitValue(0);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaProxyClasslist.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}