{"files":[{"patch":"@@ -146,2 +146,1 @@\n-JVM_IsDynamicDumpingEnabled\n-JVM_IsSharingEnabled\n+JVM_IsCDSDumpingEnabled\n@@ -155,0 +154,1 @@\n+JVM_IsSharingEnabled\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+#include \"interpreter\/bytecode.hpp\"\n+#include \"interpreter\/bytecodeStream.hpp\"\n+#include \"interpreter\/linkResolver.hpp\"\n@@ -39,0 +42,1 @@\n+#include \"oops\/constantPool.hpp\"\n@@ -68,0 +72,1 @@\n+  _indy_items = new (ResourceObj::C_HEAP, mtClass) GrowableArray<const char*>(9, mtClass);\n@@ -104,0 +109,1 @@\n+  _indy_items->clear();\n@@ -128,0 +134,4 @@\n+  if (_line[0] == '@') {\n+    return parse_at_tags();\n+  }\n+\n@@ -139,1 +149,1 @@\n-    if (parse_int_option(\"id:\", &_id)) {\n+    if (parse_uint_option(\"id:\", &_id)) {\n@@ -141,1 +151,1 @@\n-    } else if (parse_int_option(\"super:\", &_super)) {\n+    } else if (parse_uint_option(\"super:\", &_super)) {\n@@ -146,1 +156,1 @@\n-      while (try_parse_int(&i)) {\n+      while (try_parse_uint(&i)) {\n@@ -175,0 +185,35 @@\n+void ClassListParser::split_tokens_by_whitespace() {\n+  int start = 0;\n+  int end;\n+  bool done = false;\n+  while (!done) {\n+    while (_line[start] == ' ' || _line[start] == '\\t') start++;\n+    end = start;\n+    while (_line[end] && _line[end] != ' ' && _line[end] != '\\t') end++;\n+    if (_line[end] == '\\0') {\n+      done = true;\n+    } else {\n+      _line[end] = '\\0';\n+    }\n+    _indy_items->append(_line + start);\n+    start = ++end;\n+  }\n+}\n+\n+bool ClassListParser::parse_at_tags() {\n+  assert(_line[0] == '@', \"must be\");\n+  split_tokens_by_whitespace();\n+  if (strcmp(_indy_items->at(0), LAMBDA_PROXY_TAG) == 0) {\n+    if (_indy_items->length() < 3) {\n+      error(\"Line with @ tag has too few items \\\"%s\\\" line #%d\", _line, _line_no);\n+      return false;\n+    }\n+    \/\/ set the class name\n+    _class_name = _indy_items->at(1);\n+    return true;\n+  } else {\n+    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%d\", _line, _line_no);\n+    return false;\n+  }\n+}\n+\n@@ -191,3 +236,0 @@\n-    if (*value < 0) {\n-      error(\"Error: negative integers not allowed (%d)\", *value);\n-    }\n@@ -199,1 +241,8 @@\n-bool ClassListParser::try_parse_int(int* value) {\n+void ClassListParser::parse_uint(int* value) {\n+  parse_int(value);\n+  if (*value < 0) {\n+    error(\"Error: negative integers not allowed (%d)\", *value);\n+  }\n+}\n+\n+bool ClassListParser::try_parse_uint(int* value) {\n@@ -230,0 +279,12 @@\n+bool ClassListParser::parse_uint_option(const char* option_name, int* value) {\n+  if (skip_token(option_name)) {\n+    if (*value != _unspecified) {\n+      error(\"%s specified twice\", option_name);\n+    } else {\n+      parse_uint(value);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -336,0 +397,108 @@\n+void ClassListParser::populate_cds_indy_info(const constantPoolHandle &pool, int cp_index, CDSIndyInfo* cii, TRAPS) {\n+  \/\/ Caller needs to allocate ResourceMark.\n+  int type_index = pool->bootstrap_name_and_type_ref_index_at(cp_index);\n+  int name_index = pool->name_ref_index_at(type_index);\n+  cii->add_item(pool->symbol_at(name_index)->as_C_string());\n+  int sig_index = pool->signature_ref_index_at(type_index);\n+  cii->add_item(pool->symbol_at(sig_index)->as_C_string());\n+  int argc = pool->bootstrap_argument_count_at(cp_index);\n+  if (argc > 0) {\n+    for (int arg_i = 0; arg_i < argc; arg_i++) {\n+      int arg = pool->bootstrap_argument_index_at(cp_index, arg_i);\n+      jbyte tag = pool->tag_at(arg).value();\n+      if (tag == JVM_CONSTANT_MethodType) {\n+        cii->add_item(pool->method_type_signature_at(arg)->as_C_string());\n+      } else if (tag == JVM_CONSTANT_MethodHandle) {\n+        cii->add_ref_kind(pool->method_handle_ref_kind_at(arg));\n+        int callee_index = pool->method_handle_klass_index_at(arg);\n+        Klass* callee = pool->klass_at(callee_index, THREAD);\n+        if (callee != NULL) {\n+          cii->add_item(callee->name()->as_C_string());\n+        }\n+        cii->add_item(pool->method_handle_name_ref_at(arg)->as_C_string());\n+        cii->add_item(pool->method_handle_signature_ref_at(arg)->as_C_string());\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    }\n+  }\n+}\n+\n+bool ClassListParser::is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  CDSIndyInfo cii;\n+  populate_cds_indy_info(pool, cp_index, &cii, THREAD);\n+  GrowableArray<const char*>* items = cii.items();\n+  int indy_info_offset = 2;\n+  if (_indy_items->length() - indy_info_offset != items->length()) {\n+    return false;\n+  }\n+  for (int i = 0; i < items->length(); i++) {\n+    if (strcmp(_indy_items->at(i + indy_info_offset), items->at(i)) != 0) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+void ClassListParser::resolve_indy(Symbol* class_name_symbol, TRAPS) {\n+\n+  Handle class_loader(THREAD, SystemDictionary::java_system_loader());\n+  Handle protection_domain;\n+  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, protection_domain, true, THREAD); \/\/ FIXME should really be just a lookup\n+  if (klass != NULL && klass->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    MetaspaceShared::try_link_class(ik, THREAD);\n+    assert(!HAS_PENDING_EXCEPTION, \"unexpected exception\");\n+\n+    ConstantPool* cp = ik->constants();\n+    ConstantPoolCache* cpcache = cp->cache();\n+    bool found = false;\n+    for (int cpcindex = 0; cpcindex < cpcache->length(); cpcindex ++) {\n+      int indy_index = ConstantPool::encode_invokedynamic_index(cpcindex);\n+      ConstantPoolCacheEntry* cpce = cpcache->entry_at(cpcindex);\n+      int pool_index = cpce->constant_pool_index();\n+      constantPoolHandle pool(THREAD, cp);\n+      if (pool->tag_at(pool_index).is_invoke_dynamic()) {\n+        BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);\n+        Handle bsm = bootstrap_specifier.resolve_bsm(THREAD);\n+        if (!SystemDictionaryShared::is_supported_invokedynamic(&bootstrap_specifier)) {\n+           tty->print_cr(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n+           continue;\n+        }\n+        if (is_matching_cp_entry(pool, pool_index, THREAD)) {\n+          found = true;\n+          CallInfo info;\n+          bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(info, THREAD);\n+          if (!is_done) {\n+            \/\/ resolve it\n+            Handle recv;\n+            LinkResolver::resolve_invoke(info, recv, pool, indy_index, Bytecodes::_invokedynamic, THREAD);\n+            break;\n+          }\n+          cpce->set_dynamic_call(pool, info);\n+          if (HAS_PENDING_EXCEPTION) {\n+            ResourceMark rm(THREAD);\n+            tty->print(\"resolve_indy for class %s has\", class_name_symbol->as_C_string());\n+            oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n+            if (message != NULL) {\n+              char* ex_msg = java_lang_String::as_utf8_string(message);\n+              tty->print_cr(\" exception pending '%s %s'\",\n+                         PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n+            } else {\n+              tty->print_cr(\" exception pending %s \",\n+                         PENDING_EXCEPTION->klass()->external_name());\n+            }\n+            exit(1);\n+          }\n+        }\n+      }\n+    }\n+    if (!found) {\n+      ResourceMark rm(THREAD);\n+      log_warning(cds)(\"No invoke dynamic constant pool entry can be found for class %s. The classlist is probably out-of-date.\",\n+                     class_name_symbol->as_C_string());\n+    }\n+  }\n+}\n+\n@@ -339,0 +508,5 @@\n+  if (_indy_items->length() > 0) {\n+    resolve_indy(class_name_symbol, CHECK_NULL);\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":181,"deletions":7,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#define LAMBDA_PROXY_TAG \"@lambda-proxy:\"\n+\n@@ -38,0 +40,21 @@\n+class CDSIndyInfo {\n+  char _ref_kind[10];\n+  GrowableArray<const char*>* _items;\n+public:\n+  CDSIndyInfo() : _items(NULL) {_ref_kind[0] = '\\0';}\n+  void add_item(const char* item) {\n+    if (_items == NULL) {\n+      _items = new GrowableArray<const char*>(9);\n+    }\n+    assert(_items != NULL, \"sanity\");\n+    _items->append(item);\n+  }\n+  void add_ref_kind(int ref_kind) {\n+    sprintf(_ref_kind, \"%d\", ref_kind);\n+    _items->append(_ref_kind);\n+  }\n+  GrowableArray<const char*>* items() {\n+    return _items;\n+  }\n+};\n+\n@@ -64,0 +87,1 @@\n+  GrowableArray<const char*>* _indy_items;    \/\/ items related to invoke dynamic for archiving lambda proxy classes\n@@ -71,0 +95,1 @@\n+  bool parse_uint_option(const char* option_name, int* value);\n@@ -78,0 +103,3 @@\n+  bool is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS);\n+\n+  void resolve_indy(Symbol* class_name_symbol, TRAPS);\n@@ -86,0 +114,2 @@\n+  void split_tokens_by_whitespace();\n+  bool parse_at_tags();\n@@ -89,1 +119,2 @@\n-  bool try_parse_int(int* value);\n+  void parse_uint(int* value);\n+  bool try_parse_uint(int* value);\n@@ -129,0 +160,2 @@\n+\n+  static void populate_cds_indy_info(const constantPoolHandle &pool, int cp_index, CDSIndyInfo* cii, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/classListParser.hpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_CLASSLISTWRITER_HPP\n+#define SHARE_CLASSFILE_CLASSLISTWRITER_HPP\n+\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class ClassListWriter {\n+  friend const char* make_log_name(const char* log_name, const char* force_directory);\n+\n+  static fileStream* _classlist_file;\n+  MutexLocker _locker;\n+public:\n+#if INCLUDE_CDS\n+  ClassListWriter() : _locker(Thread::current(), ClassListFile_lock, Mutex::_no_safepoint_check_flag) {}\n+#else\n+  ClassListWriter() : _locker(Thread::current(), NULL, Mutex::_no_safepoint_check_flag) {}\n+#endif\n+\n+  outputStream* stream() {\n+    return _classlist_file;\n+  }\n+\n+  static bool is_enabled() {\n+#if INCLUDE_CDS\n+    return _classlist_file != NULL && _classlist_file->is_open();\n+#else\n+    return false;\n+#endif\n+  }\n+\n+  static void init() {\n+#if INCLUDE_CDS\n+  \/\/ For -XX:DumpLoadedClassList=<file> option\n+  if (DumpLoadedClassList != NULL) {\n+    const char* list_name = make_log_name(DumpLoadedClassList, NULL);\n+    _classlist_file = new(ResourceObj::C_HEAP, mtInternal)\n+                         fileStream(list_name);\n+    FREE_C_HEAP_ARRAY(char, list_name);\n+  }\n+#endif\n+  }\n+\n+  static void delete_classlist() {\n+#if INCLUDE_CDS\n+    if (_classlist_file != NULL) {\n+        delete _classlist_file;\n+    }\n+#endif\n+  }\n+};\n+\n+#endif \/\/ SHARE_CLASSFILE_CLASSLISTWRITER_HPP\n","filename":"src\/hotspot\/share\/classfile\/classListWriter.hpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -1356,2 +1356,4 @@\n-  assert(shared_nest_host->is_same_class_package(ik),\n-         \"lambda proxy class and its nest host must be in the same package\");\n+  if (loaded_ik != NULL) {\n+    assert(shared_nest_host->is_same_class_package(ik),\n+           \"lambda proxy class and its nest host must be in the same package\");\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"interpreter\/bootstrapInfo.hpp\"\n@@ -100,0 +102,1 @@\n+  InstanceKlass*               _nest_host;\n@@ -111,0 +114,1 @@\n+    _nest_host = NULL;\n@@ -148,0 +152,1 @@\n+    it->push(&_nest_host);\n@@ -179,0 +184,8 @@\n+\n+  void set_nest_host(InstanceKlass* nest_host) {\n+    _nest_host = nest_host;\n+  }\n+\n+  InstanceKlass* nest_host() {\n+    return _nest_host;\n+  }\n@@ -259,1 +272,3 @@\n-      field = DynamicArchive::original_to_target(field);\n+      if (DynamicDumpSharedSpaces) {\n+        field = DynamicArchive::original_to_target(field);\n+      }\n@@ -285,0 +300,9 @@\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_caller_ik);\n+    it->push(&_invoked_name);\n+    it->push(&_invoked_type);\n+    it->push(&_method_type);\n+    it->push(&_member_method);\n+    it->push(&_instantiated_method_type);\n+  }\n+\n@@ -311,0 +335,8 @@\n+  static unsigned int dumptime_hash(Symbol* sym)  {\n+    if (sym == NULL) {\n+      \/\/ _invoked_name maybe NULL\n+      return 0;\n+    }\n+    return java_lang_String::hash_code((const jbyte*)sym->bytes(), sym->utf8_length());\n+  }\n+\n@@ -312,5 +344,5 @@\n-    return primitive_hash<InstanceKlass*>(_caller_ik) +\n-           primitive_hash<Symbol*>(_invoked_name) +\n-           primitive_hash<Symbol*>(_invoked_type) +\n-           primitive_hash<Symbol*>(_method_type) +\n-           primitive_hash<Symbol*>(_instantiated_method_type);\n+    return dumptime_hash(_caller_ik->name()) +\n+           dumptime_hash(_invoked_name) +\n+           dumptime_hash(_invoked_type) +\n+           dumptime_hash(_method_type) +\n+           dumptime_hash(_instantiated_method_type);\n@@ -341,0 +373,6 @@\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    for (int i=0; i<_proxy_klasses->length(); i++) {\n+      it->push(_proxy_klasses->adr_at(i));\n+    }\n+  }\n@@ -347,2 +385,2 @@\n-  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass) :\n-    _key(key), _proxy_klass_head(proxy_klass) {}\n+  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n+    _key(key), _proxy_klass_head(proxy_klass_head) {}\n@@ -360,1 +398,3 @@\n-    _proxy_klass_head = DynamicArchive::original_to_target(info._proxy_klasses->at(0));\n+    _proxy_klass_head = DynamicDumpSharedSpaces ?\n+                          DynamicArchive::original_to_target(info._proxy_klasses->at(0)) :\n+                          info._proxy_klasses->at(0);\n@@ -367,0 +407,3 @@\n+  LambdaProxyClassKey key() const {\n+    return _key;\n+  }\n@@ -376,0 +419,2 @@\n+LambdaProxyClassDictionary _dynamic_lambda_proxy_class_dictionary;\n+\n@@ -587,4 +632,4 @@\n-    if (DynamicDumpSharedSpaces) {\n-      if (_klass->is_hidden()) {\n-        Thread* THREAD = Thread::current();\n-        InstanceKlass* n_h = _klass->nest_host(THREAD);\n+\n+    if (_klass->is_hidden()) {\n+      InstanceKlass* n_h = info.nest_host();\n+      if (DynamicDumpSharedSpaces) {\n@@ -592,1 +637,0 @@\n-        set_nest_host(n_h);\n@@ -594,1 +638,1 @@\n-      _klass = DynamicArchive::original_to_target(info._klass);\n+      set_nest_host(n_h);\n@@ -596,0 +640,1 @@\n+    _klass = DynamicDumpSharedSpaces ? DynamicArchive::original_to_target(info._klass) : info._klass;\n@@ -1391,1 +1436,1 @@\n-    if (SystemDictionaryShared::should_be_excluded(k)) {\n+    if (SystemDictionaryShared::should_be_excluded(k) || info.is_excluded()) {\n@@ -1451,0 +1496,12 @@\n+class IterateDumpTimeLambdaProxyClassDictionary : StackObj {\n+  MetaspaceClosure *_it;\n+public:\n+  IterateDumpTimeLambdaProxyClassDictionary(MetaspaceClosure* it) : _it(it) {}\n+\n+  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    info.metaspace_pointers_do(_it);\n+    key.metaspace_pointers_do(_it);\n+    return true;\n+  }\n+};\n+\n@@ -1455,0 +1512,4 @@\n+  if (_dumptime_lambda_proxy_class_dictionary != NULL) {\n+    IterateDumpTimeLambdaProxyClassDictionary iter_lambda(it);\n+    _dumptime_lambda_proxy_class_dictionary->iterate(&iter_lambda);\n+  }\n@@ -1525,1 +1586,2 @@\n-                                                    Symbol* instantiated_method_type) {\n+                                                    Symbol* instantiated_method_type,\n+                                                    TRAPS) {\n@@ -1535,0 +1597,1 @@\n+  InstanceKlass* nest_host = caller_ik->nest_host(THREAD);\n@@ -1541,0 +1604,1 @@\n+    info->set_nest_host(nest_host);\n@@ -1562,0 +1626,4 @@\n+  if (info == NULL) {\n+    \/\/ Try lookup from the dynamic lambda proxy class dictionary.\n+    info = _dynamic_lambda_proxy_class_dictionary.lookup(&key, key.hash(), 0);\n+  }\n@@ -1579,1 +1647,1 @@\n-        log_debug(cds)(\"Loaded lambda proxy: %s\", proxy_klass->external_name());\n+        log_debug(cds)(\"Loaded lambda proxy: %s \", proxy_klass->external_name());\n@@ -1614,0 +1682,4 @@\n+  if (loaded_lambda == NULL) {\n+    return NULL;\n+  }\n+\n@@ -1848,0 +1920,37 @@\n+bool SystemDictionaryShared::is_supported_invokedynamic(BootstrapInfo* bsi) {\n+  if (bsi->arg_values() == NULL || !bsi->arg_values()->is_objArray()) {\n+    tty->print_cr(\"bsi check failed\");\n+    tty->print_cr(\"    bsi->arg_values().not_null() %d\", bsi->arg_values().not_null());\n+    if (bsi->arg_values().not_null()) {\n+      tty->print_cr(\"    bsi->arg_values()->is_objArray() %d\", bsi->arg_values()->is_objArray());\n+      bsi->print();\n+    }\n+    return false;\n+  }\n+\n+  Handle bsm = bsi->bsm();\n+  if (bsm.is_null() || !java_lang_invoke_DirectMethodHandle::is_instance(bsm())) {\n+    tty->print_cr(\"bsm check failed\");\n+    tty->print_cr(\"    bsm.is_null() %d\", bsm.is_null());\n+    tty->print_cr(\"    java_lang_invoke_DirectMethodHandle::is_instance(bsm()) %d\",\n+      java_lang_invoke_DirectMethodHandle::is_instance(bsm()));\n+    return false;\n+  }\n+\n+  oop mn = java_lang_invoke_DirectMethodHandle::member(bsm());\n+  Method* method = java_lang_invoke_MemberName::vmtarget(mn);\n+  if (method->klass_name()->equals(\"java\/lang\/invoke\/LambdaMetafactory\") &&\n+      method->name()->equals(\"metafactory\") &&\n+      method->signature()->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\")) {\n+      return true;\n+  } else {\n+    ResourceMark rm;\n+    tty->print_cr(\"method check failed\");\n+    tty->print_cr(\"    klass_name() %s\", method->klass_name()->as_C_string());\n+    tty->print_cr(\"    name() %s\", method->name()->as_C_string());\n+    tty->print_cr(\"    signature() %s\", method->signature()->as_C_string());\n+  }\n+\n+  return false;\n+}\n+\n@@ -1895,3 +2004,9 @@\n-    if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses->at(0))) {\n-      return true;\n-    }\n+    \/\/ In static dump, info._proxy_klasses->at(0) is already relocated to point to the archived class\n+    \/\/ (not the original class).\n+    \/\/\n+    \/\/ The following check has been moved to SystemDictionaryShared::check_excluded_classes(), which\n+    \/\/ happens before the classes are copied.\n+    \/\/\n+    \/\/ if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses->at(0))) {\n+    \/\/  return true;\n+    \/\/}\n@@ -1905,1 +2020,3 @@\n-    u4 delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(runtime_info));\n+    u4 delta = DynamicDumpSharedSpaces ?\n+                 MetaspaceShared::object_delta_u4((void*)DynamicArchive::buffer_to_target(runtime_info)) :\n+                 MetaspaceShared::object_delta_u4((void*)runtime_info);\n@@ -1915,3 +2032,0 @@\n-    if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses->at(0))) {\n-      return true;\n-    }\n@@ -1923,2 +2037,2 @@\n-        InstanceKlass* bk0 = DynamicArchive::original_to_buffer(ok0);\n-        InstanceKlass* bk1 = DynamicArchive::original_to_buffer(ok1);\n+        InstanceKlass* bk0 = DynamicDumpSharedSpaces ? DynamicArchive::original_to_buffer(ok0) : ok0;\n+        InstanceKlass* bk1 = DynamicDumpSharedSpaces ? DynamicArchive::original_to_buffer(ok1) : ok1;\n@@ -1932,1 +2046,5 @@\n-    DynamicArchive::original_to_buffer(info._proxy_klasses->at(0))->set_lambda_proxy_is_available();\n+    if (DynamicDumpSharedSpaces) {\n+      DynamicArchive::original_to_buffer(info._proxy_klasses->at(0))->set_lambda_proxy_is_available();\n+    } else {\n+      info._proxy_klasses->at(0)->set_lambda_proxy_is_available();\n+    }\n@@ -2023,0 +2141,1 @@\n+  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -2026,0 +2145,3 @@\n+    if (dynamic_mapinfo == NULL || DynamicDumpSharedSpaces || (dynamic_mapinfo != NULL && UseSharedSpaces)) {\n+      _lambda_proxy_class_dictionary.serialize_header(soc);\n+    }\n@@ -2029,1 +2151,5 @@\n-    _lambda_proxy_class_dictionary.serialize_header(soc);\n+    if (DynamicDumpSharedSpaces) {\n+      _lambda_proxy_class_dictionary.serialize_header(soc);\n+    } else {\n+      _dynamic_lambda_proxy_class_dictionary.serialize_header(soc);\n+    }\n@@ -2107,0 +2233,16 @@\n+void SystemDictionaryShared::print_on(const char* prefix,\n+                                      RunTimeSharedDictionary* builtin_dictionary,\n+                                      RunTimeSharedDictionary* unregistered_dictionary,\n+                                      LambdaProxyClassDictionary* lambda_dictionary,\n+                                      outputStream* st) {\n+  st->print_cr(\"%sShared Dictionary\", prefix);\n+  SharedDictionaryPrinter p(st);\n+  builtin_dictionary->iterate(&p);\n+  unregistered_dictionary->iterate(&p);\n+  if (!lambda_dictionary->empty()) {\n+    st->print_cr(\"%sShared Lambda Dictionary\", prefix);\n+    SharedLambdaDictionaryPrinter ldp(st);\n+    lambda_dictionary->iterate(&ldp);\n+  }\n+}\n+\n@@ -2109,4 +2251,1 @@\n-    st->print_cr(\"Shared Dictionary\");\n-    SharedDictionaryPrinter p(st);\n-    _builtin_dictionary.iterate(&p);\n-    _unregistered_dictionary.iterate(&p);\n+    print_on(\"\", &_builtin_dictionary, &_unregistered_dictionary, &_lambda_proxy_class_dictionary, st);\n@@ -2114,7 +2253,2 @@\n-      _dynamic_builtin_dictionary.iterate(&p);\n-      _unregistered_dictionary.iterate(&p);\n-      if (!_lambda_proxy_class_dictionary.empty()) {\n-        st->print_cr(\"Shared Lambda Dictionary\");\n-        SharedLambdaDictionaryPrinter ldp(st);\n-        _lambda_proxy_class_dictionary.iterate(&ldp);\n-      }\n+      print_on(\"\", &_dynamic_builtin_dictionary, &_dynamic_unregistered_dictionary,\n+               &_dynamic_lambda_proxy_class_dictionary, st);\n@@ -2129,0 +2263,1 @@\n+    _lambda_proxy_class_dictionary.print_table_statistics(st, \"Lambda Shared Dictionary\");\n@@ -2132,1 +2267,1 @@\n-      _lambda_proxy_class_dictionary.print_table_statistics(st, \"Lambda Shared Dictionary\");\n+      _dynamic_lambda_proxy_class_dictionary.print_table_statistics(st, \"Dynamic Lambda Shared Dictionary\");\n@@ -2151,0 +2286,1 @@\n+protected:\n@@ -2175,0 +2311,12 @@\n+class ArchivedLambdaMirrorPatcher : public ArchivedMirrorPatcher {\n+public:\n+  void do_value(const RunTimeLambdaProxyClassInfo* info) {\n+    InstanceKlass* ik = info->proxy_klass_head();\n+    while (ik != NULL) {\n+      update(ik);\n+      Klass* k = ik->next_link();\n+      ik = (k != NULL) ? InstanceKlass::cast(k) : NULL;\n+    }\n+  }\n+};\n+\n@@ -2180,0 +2328,5 @@\n+void SystemDictionaryShared::update_archived_mirror_native_pointers_for(LambdaProxyClassDictionary* dict) {\n+  ArchivedLambdaMirrorPatcher patcher;\n+  dict->iterate(&patcher);\n+}\n+\n@@ -2189,0 +2342,1 @@\n+  update_archived_mirror_native_pointers_for(&_lambda_proxy_class_dictionary);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":195,"deletions":41,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+class BootstrapInfo;\n@@ -223,0 +224,5 @@\n+  static void print_on(const char* prefix,\n+                       RunTimeSharedDictionary* builtin_dictionary,\n+                       RunTimeSharedDictionary* unregistered_dictionary,\n+                       LambdaProxyClassDictionary* lambda_dictionary,\n+                       outputStream* st) NOT_CDS_RETURN;\n@@ -291,1 +297,1 @@\n-                                     Symbol* instantiated_method_type) NOT_CDS_RETURN;\n+                                     Symbol* instantiated_method_type, TRAPS) NOT_CDS_RETURN;\n@@ -325,0 +331,1 @@\n+  static bool is_supported_invokedynamic(BootstrapInfo* bsi) NOT_CDS_RETURN_(false);\n@@ -351,0 +358,1 @@\n+  static void update_archived_mirror_native_pointers_for(LambdaProxyClassDictionary* dict);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-JVM_IsDynamicDumpingEnabled(JNIEnv* env);\n+JVM_IsCDSDumpingEnabled(JNIEnv* env);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"memory\/archiveUtils.hpp\"\n@@ -1768,0 +1769,3 @@\n+\n+  \/\/ Log dynamic info to CDS classlist.\n+  ArchiveUtils::log_to_classlist(&bootstrap_specifier, THREAD);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+#include \"classfile\/classListParser.hpp\"\n+#include \"classfile\/classListWriter.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"interpreter\/bootstrapInfo.hpp\"\n@@ -32,0 +36,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -300,0 +305,21 @@\n+\n+fileStream* ClassListWriter::_classlist_file = NULL;\n+\n+void ArchiveUtils::log_to_classlist(BootstrapInfo* bootstrap_specifier, TRAPS) {\n+  if (ClassListWriter::is_enabled()) {\n+    if (SystemDictionaryShared::is_supported_invokedynamic(bootstrap_specifier)) {\n+      ResourceMark rm(THREAD);\n+      const constantPoolHandle& pool = bootstrap_specifier->pool();\n+      int pool_index = bootstrap_specifier->bss_index();\n+      ClassListWriter w;\n+      w.stream()->print(\"%s %s\", LAMBDA_PROXY_TAG, pool->pool_holder()->name()->as_C_string());\n+      CDSIndyInfo cii;\n+      ClassListParser::populate_cds_indy_info(pool, pool_index, &cii, THREAD);\n+      GrowableArray<const char*>* indy_items = cii.items();\n+      for (int i = 0; i < indy_items->length(); i++) {\n+        w.stream()->print(\" %s\", indy_items->at(i));\n+      }\n+      w.stream()->cr();\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+class BootstrapInfo;\n@@ -242,0 +243,5 @@\n+class ArchiveUtils {\n+public:\n+  static void log_to_classlist(BootstrapInfo* bootstrap_specifier, TRAPS) NOT_CDS_RETURN;\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -781,0 +781,2 @@\n+  SystemDictionaryShared::adjust_lambda_proxy_class_dictionary();\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/classListWriter.hpp\"\n@@ -4198,1 +4199,1 @@\n-  if (DumpLoadedClassList && classlist_file->is_open()) {\n+  if (ClassListWriter::is_enabled()) {\n@@ -4211,0 +4212,5 @@\n+      if (is_hidden()) {\n+        \/\/ Don't include archived lambda proxy class in the classlist.\n+        assert(!is_non_strong_hidden(), \"unexpected non-strong hidden class\");\n+        return;\n+      }\n@@ -4238,2 +4244,3 @@\n-      classlist_file->print_cr(\"%s\", name()->as_C_string());\n-      classlist_file->flush();\n+      ClassListWriter w;\n+      w.stream()->print_cr(\"%s\", name()->as_C_string());\n+      w.stream()->flush();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -621,0 +621,1 @@\n+    ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/classListWriter.hpp\"\n@@ -3745,1 +3746,1 @@\n-  if (!DynamicDumpSharedSpaces) {\n+  if (!Arguments::is_dumping_archive()) {\n@@ -3780,1 +3781,1 @@\n-                                                 method_type, m, instantiated_method_type);\n+                                                 method_type, m, instantiated_method_type, THREAD);\n@@ -3794,3 +3795,0 @@\n-  if (!DynamicArchive::is_mapped()) {\n-    return NULL;\n-  }\n@@ -3837,3 +3835,3 @@\n-JVM_ENTRY(jboolean, JVM_IsDynamicDumpingEnabled(JNIEnv* env))\n-    JVMWrapper(\"JVM_IsDynamicDumpingEnable\");\n-    return DynamicDumpSharedSpaces;\n+JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))\n+    JVMWrapper(\"JVM_IsCDSDumpingEnabled\");\n+    return Arguments::is_dumping_archive();\n@@ -3873,1 +3871,1 @@\n-  return DumpLoadedClassList != NULL && classlist_file != NULL && classlist_file->is_open();\n+  return ClassListWriter::is_enabled();\n@@ -3882,1 +3880,1 @@\n-  assert(DumpLoadedClassList != NULL && classlist_file->is_open(), \"Should be set and open\");\n+  assert(ClassListWriter::is_enabled(), \"Should be set and open\");\n@@ -3887,1 +3885,2 @@\n-    classlist_file->print_cr(\"%s %s\", LambdaFormInvokers::lambda_form_invoker_tag(), c_line);\n+    ClassListWriter w;\n+    w.stream()->print_cr(\"%s %s\", LambdaFormInvokers::lambda_form_invoker_tag(), c_line);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+Mutex*   ClassListFile_lock           = NULL;\n@@ -346,0 +347,1 @@\n+  def(ClassListFile_lock           , PaddedMutex  , leaf,        true,  _safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+extern Mutex*   ClassListFile_lock;              \/\/ ClassListWriter()\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classListWriter.hpp\"\n@@ -393,1 +394,0 @@\n-CDS_ONLY(fileStream* classlist_file;) \/\/ Only dump the classes that can be stored into the CDS archive\n@@ -512,1 +512,1 @@\n-static const char* make_log_name(const char* log_name, const char* force_directory) {\n+const char* make_log_name(const char* log_name, const char* force_directory) {\n@@ -914,9 +914,1 @@\n-#if INCLUDE_CDS\n-  \/\/ For -XX:DumpLoadedClassList=<file> option\n-  if (DumpLoadedClassList != NULL) {\n-    const char* list_name = make_log_name(DumpLoadedClassList, NULL);\n-    classlist_file = new(ResourceObj::C_HEAP, mtInternal)\n-                         fileStream(list_name);\n-    FREE_C_HEAP_ARRAY(char, list_name);\n-  }\n-#endif\n+  ClassListWriter::init();\n@@ -936,5 +928,1 @@\n-#if INCLUDE_CDS\n-  if (classlist_file != NULL) {\n-    delete classlist_file;\n-  }\n-#endif\n+  ClassListWriter::delete_classlist();\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -242,2 +242,0 @@\n-CDS_ONLY(extern fileStream*   classlist_file;)\n-\n@@ -264,0 +262,1 @@\n+const char* make_log_name(const char* log_name, const char* force_directory);\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.CDS;\n@@ -266,1 +267,1 @@\n-        if (LambdaProxyClassArchive.isDumpArchive()) {\n+        if (CDS.isDumpingArchive()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,22 +32,0 @@\n-    private static final boolean dumpArchive;\n-    private static final boolean sharingEnabled;\n-\n-    static {\n-        dumpArchive = CDS.isDynamicDumpingEnabled();\n-        sharingEnabled = CDS.isSharingEnabled();\n-    }\n-\n-    \/**\n-     * Check if CDS dynamic dump is enabled.\n-     *\/\n-    static boolean isDumpArchive() {\n-        return dumpArchive;\n-    }\n-\n-    \/**\n-     * Check if CDS sharing is enabled.\n-     *\/\n-    static boolean isSharingEnabled() {\n-        return sharingEnabled;\n-    }\n-\n@@ -97,1 +75,1 @@\n-        if (!isDumpArchive())\n+        if (!CDS.isDumpingArchive())\n@@ -128,1 +106,1 @@\n-        if (isDumpArchive())\n+        if (CDS.isDumpingArchive())\n@@ -131,2 +109,2 @@\n-        if (!loadedByBuiltinLoader(caller) ||\n-            !isSharingEnabled() || isSerializable || markerInterfaces.length > 0 || additionalBridges.length > 0)\n+        if (!loadedByBuiltinLoader(caller) || !initialize ||\n+            !CDS.isSharingEnabled() || isSerializable || markerInterfaces.length > 0 || additionalBridges.length > 0)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaProxyClassArchive.java","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    private static final boolean isDumpingArchive;\n+    private static final boolean isSharingEnabled;\n@@ -40,0 +42,2 @@\n+        isDumpingArchive = isDumpingArchive0();\n+        isSharingEnabled = isSharingEnabled0();\n@@ -48,0 +52,14 @@\n+\n+    \/**\n+      * Is the VM writing to a (static or dynamic) CDS archive.\n+      *\/\n+    public static boolean isDumpingArchive() {\n+        return isDumpingArchive;\n+    }\n+\n+    \/**\n+      * Is sharing enabled via the UseSharedSpaces flag.\n+      *\/\n+    public static boolean isSharingEnabled() {\n+        return isSharingEnabled;\n+    }\n@@ -49,0 +67,2 @@\n+    private static native boolean isDumpingArchive0();\n+    private static native boolean isSharingEnabled0();\n@@ -75,10 +95,0 @@\n-    \/**\n-     * Check if dynamic dumping is enabled via the DynamicDumpSharedSpaces flag.\n-     *\/\n-    public static native boolean isDynamicDumpingEnabled(); \/\/ will return false for static dumping.\n-\n-    \/**\n-     * Check if sharing is enabled via the UseSharedSpaces flag.\n-     *\/\n-    public static native boolean isSharingEnabled();\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-Java_jdk_internal_misc_CDS_isDynamicDumpingEnabled(JNIEnv *env, jclass jcls) {\n-    return JVM_IsDynamicDumpingEnabled(env);\n+Java_jdk_internal_misc_CDS_isDumpingArchive0(JNIEnv *env, jclass jcls) {\n+    return JVM_IsCDSDumpingEnabled(env);\n@@ -53,1 +53,1 @@\n-Java_jdk_internal_misc_CDS_isSharingEnabled(JNIEnv *env, jclass jcls) {\n+Java_jdk_internal_misc_CDS_isSharingEnabled0(JNIEnv *env, jclass jcls) {\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+ -runtime\/cds\/appcds\/methodHandles \\\n@@ -332,0 +333,1 @@\n+ -runtime\/cds\/appcds\/BadBSM.java \\\n@@ -335,0 +337,1 @@\n+ -runtime\/cds\/appcds\/LambdaProxyClasslist.java \\\n@@ -340,0 +343,1 @@\n+ -runtime\/cds\/appcds\/StaticArchiveWithLambda.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary CDS dump should abort if a class file contains a bad BSM.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/WrongBSM.jcod\n+ * @run driver BadBSM\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BadBSM {\n+\n+  public static void main(String[] args) throws Exception {\n+    JarBuilder.build(\"wrongbsm\", \"WrongBSM\");\n+\n+    String appJar = TestCommon.getTestJar(\"wrongbsm.jar\");\n+\n+    OutputAnalyzer out = TestCommon.dump(appJar,\n+        TestCommon.list(\"WrongBSM\",\n+                        \"@lambda-proxy: WrongBSM 7\"));\n+    out.shouldHaveExitValue(0);\n+    out.shouldContain( \"is_supported_invokedynamic check failed for cp_index 7\");\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/BadBSM.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test some error handling on the \"@lambda-proxy\" entries in a classlist.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile dynamicArchive\/test-classes\/LambHello.java\n+ * @run driver LambdaProxyClasslist\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class LambdaProxyClasslist {\n+\n+  public static void main(String[] args) throws Exception {\n+    JarBuilder.build(\"lambhello\", \"LambHello\");\n+\n+    String appJar = TestCommon.getTestJar(\"lambhello.jar\");\n+\n+    \/\/ 1. No error with a correct @lambda-proxy entry.\n+    OutputAnalyzer out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy: LambHello run ()Ljava\/lang\/Runnable; ()V 6 LambHello lambda$main$0 ()V ()V\"));\n+    out.shouldHaveExitValue(0);\n+\n+    \/\/ 2. Error if the @lambda-proxy entry is too short.\n+    out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy: LambHello\"));\n+    out.shouldContain(\"An error has occurred while processing class list file\")\n+       .shouldContain(\"Line with @ tag has too few items \\\"@lambda-proxy:\\\" line #2\")\n+       .shouldContain(\"class list format error\")\n+       .shouldHaveExitValue(1);\n+\n+    \/\/ 3. Warning message if there's an incorrect signature in the @lambda-proxy entry.\n+    out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy: LambHello run ()Ljava\/lang\/Runnable; ()V 6 LambHello lambda$main$0 ()V ()Z\"));\n+    out.shouldContain(\"[warning][cds] No invoke dynamic constant pool entry can be found for class LambHello. The classlist is probably out-of-date.\")\n+       .shouldHaveExitValue(0);\n+\n+    \/\/ 4. More blank spaces in between items should be fine.\n+    out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy:  LambHello run  ()Ljava\/lang\/Runnable; ()V 6 LambHello lambda$main$0 ()V ()V\"));\n+    out.shouldHaveExitValue(0);\n+\n+    \/\/ 5. Trailing spaces at the end of the @lambda-proxy line should be fine.\n+    out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy: LambHello run ()Ljava\/lang\/Runnable; ()V 6 LambHello lambda$main$0 ()V ()V \"));\n+    out.shouldHaveExitValue(0);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaProxyClasslist.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Sanity test lambda proxy classes in static CDS archive.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile dynamicArchive\/test-classes\/LambHello.java\n+ * @run driver StaticArchiveWithLambda\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class StaticArchiveWithLambda {\n+    public static void main(String[] args) throws Exception {\n+        String appClass = \"LambHello\";\n+        JarBuilder.build(\"lambhello\", appClass);\n+        String appJar = TestCommon.getTestJar(\"lambhello.jar\");\n+        String classList = \"lambhello.list\";\n+        String archiveName = \"StaticArchiveWithLambda.jsa\";\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", appJar,\n+            appClass);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", appJar,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", appJar, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(appClass);\n+       output = CDSTestUtils.runWithArchive(runOpts);\n+       output.shouldContain(\"LambHello source: shared objects file\")\n+             .shouldMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.shared.objects.file\")\n+             .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/StaticArchiveWithLambda.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Archive lambda proxy class is in the base archive. The lambda proxy\n+ *          class should be loaded from the base archive during runtime.\n+ *\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build LambHello\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller -jar lambhello.jar LambHello\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. LambdaInBaseArchive\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LambdaInBaseArchive extends DynamicArchiveTestBase {\n+    public static void main(String[] args) throws Exception {\n+        createBaseArchive();\n+        runTest(LambdaInBaseArchive::testCustomBase);\n+    }\n+\n+    static String helloBaseArchive = getNewArchiveName(\"base-with-hello\");\n+    static String appJar = ClassFileInstaller.getJarPath(\"lambhello.jar\");\n+    static String mainClass = \"LambHello\";\n+    static String classList = \"lambhello.list\";\n+\n+    static void createBaseArchive() throws Exception {\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", appJar,\n+            mainClass);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+        output.shouldHaveExitValue(0);\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", appJar,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(helloBaseArchive);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+    }\n+\n+    \/\/ Test with custom base archive + top archive\n+    static void testCustomBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top2\");\n+        doTest(helloBaseArchive, topArchiveName);\n+    }\n+\n+    private static void doTest(String baseArchiveName, String topArchiveName) throws Exception {\n+        dump2(baseArchiveName, topArchiveName,\n+             \"-Xlog:class+load,cds,cds+dynamic=debug\",\n+             \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Buffer-space to target-space delta\")\n+                           .shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run2(baseArchiveName, topArchiveName,\n+            \"-Xlog:class+load,cds+dynamic=debug,cds=debug\",\n+            \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"LambHello source: shared objects file\")\n+                      .shouldMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.shared.objects.file\")\n+                      .shouldNotMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.shared.objects.file.*(top)\");\n+                });\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaInBaseArchive.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -51,2 +51,3 @@\n-        Method method = c.getDeclaredMethod(\"doTest\");\n-        method.invoke(o);\n+        Method method = c.getMethod(\"main\", String[].class);\n+        String[] params = null;\n+        method.invoke(null, (Object)params);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/CustomLoaderApp.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+        doTest();\n@@ -28,1 +29,1 @@\n-    public void doTest() {\n+    static void doTest() {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/LambHello.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+#!\/bin\/bash\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"\/\/ --- start auto-generated\"\n+\n+testnames=( MethodHandlesGeneralTest  MethodHandlesAsCollectorTest MethodHandlesCastFailureTest MethodHandlesInvokersTest MethodHandlesPermuteArgumentsTest MethodHandlesSpreadArgumentsTest )\n+name_suffix='.java'\n+\n+for i in \"${testnames[@]}\"\n+do\n+    fname=\"$i$name_suffix\"\n+    cat << EOF > $fname\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by $0. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the $fname test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/$fname\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. $i\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class $i {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"$i\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.$i[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n+EOF\n+done\n+echo \"\/\/ --- end auto-generated\"\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/CDSMHTest_generate.sh","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesAsCollectorTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesAsCollectorTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesAsCollectorTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesAsCollectorTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesAsCollectorTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesAsCollectorTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesAsCollectorTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesCastFailureTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesCastFailureTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesCastFailureTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesCastFailureTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesCastFailureTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesCastFailureTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesCastFailureTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesGeneralTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesGeneralTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesGeneralTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesGeneralTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesGeneralTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesGeneralTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesGeneralTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesInvokersTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesInvokersTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesInvokersTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesInvokersTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesInvokersTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesInvokersTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesInvokersTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesPermuteArgumentsTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesPermuteArgumentsTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesPermuteArgumentsTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesPermuteArgumentsTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesPermuteArgumentsTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesPermuteArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesPermuteArgumentsTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesSpreadArgumentsTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesSpreadArgumentsTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesSpreadArgumentsTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesSpreadArgumentsTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesSpreadArgumentsTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesSpreadArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesSpreadArgumentsTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This class file has an incorrect constant pool entry #49 which results\n+ * in an incorrect BSM.\n+ * The correct entry should have a return type as follows instead of V:\n+ *     Ljava\/lang\/invoke\/CallSite;\"; \/\/ #49\n+ *\/\n+\n+class WrongBSM {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  59; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    InvokeDynamic 0s #8; \/\/ #7\n+    NameAndType #9 #10; \/\/ #8\n+    Utf8 \"run\"; \/\/ #9\n+    Utf8 \"()Ljava\/lang\/Runnable;\"; \/\/ #10\n+    Method #12 #13; \/\/ #11\n+    class #14; \/\/ #12\n+    NameAndType #15 #16; \/\/ #13\n+    Utf8 \"WrongBSM\"; \/\/ #14\n+    Utf8 \"doit\"; \/\/ #15\n+    Utf8 \"(Ljava\/lang\/Runnable;)V\"; \/\/ #16\n+    InterfaceMethod #18 #19; \/\/ #17\n+    class #20; \/\/ #18\n+    NameAndType #9 #6; \/\/ #19\n+    Utf8 \"java\/lang\/Runnable\"; \/\/ #20\n+    Field #22 #23; \/\/ #21\n+    class #24; \/\/ #22\n+    NameAndType #25 #26; \/\/ #23\n+    Utf8 \"java\/lang\/System\"; \/\/ #24\n+    Utf8 \"out\"; \/\/ #25\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #26\n+    String #28; \/\/ #27\n+    Utf8 \"Hello from Lambda\"; \/\/ #28\n+    Method #30 #31; \/\/ #29\n+    class #32; \/\/ #30\n+    NameAndType #33 #34; \/\/ #31\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #32\n+    Utf8 \"println\"; \/\/ #33\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #34\n+    Utf8 \"Code\"; \/\/ #35\n+    Utf8 \"LineNumberTable\"; \/\/ #36\n+    Utf8 \"main\"; \/\/ #37\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #38\n+    Utf8 \"lambda$main$0\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"WrongBSM.java\"; \/\/ #41\n+    Utf8 \"BootstrapMethods\"; \/\/ #42\n+    MethodHandle 6b #44; \/\/ #43\n+    Method #45 #46; \/\/ #44\n+    class #47; \/\/ #45\n+    NameAndType #48 #49; \/\/ #46\n+    Utf8 \"java\/lang\/invoke\/LambdaMetafactory\"; \/\/ #47\n+    Utf8 \"metafactory\"; \/\/ #48\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)V\"; \/\/ #49\n+    MethodType #6; \/\/ #50\n+    MethodHandle 6b #52; \/\/ #51\n+    Method #12 #53; \/\/ #52\n+    NameAndType #39 #6; \/\/ #53\n+    Utf8 \"InnerClasses\"; \/\/ #54\n+    class #56; \/\/ #55\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #56\n+    class #58; \/\/ #57\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #58\n+    Utf8 \"Lookup\"; \/\/ #59\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#35) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#36) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #37; \/\/ name_index\n+      #38; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#35) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xBA00070000B8000B;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#36) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                8  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #16; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#35) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB900110100B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#36) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  8;\n+                6  9;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x100A; \/\/ access\n+      #39; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#35) { \/\/ Code\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xB20015121BB6001D;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#36) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+                8  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#42) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #43; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+            #50;\n+            #51;\n+            #50;\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#54) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #55 #57 #59 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongBSM\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/WrongBSM.jcod","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"}]}