{"files":[{"patch":"@@ -146,2 +146,1 @@\n-JVM_IsDynamicDumpingEnabled\n-JVM_IsSharingEnabled\n+JVM_IsCDSDumpingEnabled\n@@ -154,0 +153,1 @@\n+JVM_IsSharingEnabled\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6059,1 +6059,12 @@\n-  jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  if (DumpSharedSpaces) {\n+    \/\/ We want stable names for the archived hidden classes (only for static\n+    \/\/ archive for now). Spaces under default_SharedBaseAddress() will be\n+    \/\/ occupied by the archive at run time, so we know that no dynamically\n+    \/\/ loaded InstanceKlass will be placed under there.\n+    static volatile size_t counter = 0;\n+    Atomic::cmpxchg(&counter, (size_t)0, Arguments::default_SharedBaseAddress()); \/\/ initialize it\n+    size_t new_id = Atomic::add(&counter, (size_t)1);\n+    jio_snprintf(addr_buf, 20, INTPTR_FORMAT, new_id);\n+  } else {\n+    jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+#include \"interpreter\/bytecode.hpp\"\n+#include \"interpreter\/bytecodeStream.hpp\"\n+#include \"interpreter\/linkResolver.hpp\"\n@@ -38,0 +41,1 @@\n+#include \"oops\/constantPool.hpp\"\n@@ -97,0 +101,1 @@\n+  _cp_index = _unspecified;\n@@ -118,1 +123,0 @@\n-    _class_name = _line;\n@@ -121,3 +125,27 @@\n-  if ((_token = strchr(_line, ' ')) == NULL) {\n-    \/\/ No optional arguments are specified.\n-    return true;\n+  int min_len = (int)strlen(LAMBDA_PROXY_TAG);\n+  if (_line[0] == '@' && _line_len < min_len) {\n+    error(\"line #%d \\\"%s\\\" with length %d too short\", _line_no, _line, _line_len);\n+    return false;\n+  }\n+\n+  bool lambda_proxy_line = false;\n+  int class_name_offset = 0;\n+  if (strncmp(_line, LAMBDA_PROXY_TAG, min_len) == 0) {\n+    lambda_proxy_line = true;\n+    if (_line[min_len] != ' ') {\n+      error(\"line #%d \\\"%s\\\" expecting a blank space after \\\":\\\"\", _line_no, _line);\n+      return false;\n+    }\n+    class_name_offset = min_len + 1;\n+  }\n+\n+  _class_name = _line + class_name_offset;\n+  _token = strchr(_line + class_name_offset, ' ');\n+  if (_token == NULL) {\n+    if (!lambda_proxy_line) {\n+      \/\/ No optional arguments are specified.\n+      return true;\n+    } else {\n+      error(\"Expecting an index number following the class name\");\n+      return false;\n+    }\n@@ -132,1 +160,1 @@\n-    if (parse_int_option(\"id:\", &_id)) {\n+    if (parse_uint_option(\"id:\", &_id)) {\n@@ -134,1 +162,1 @@\n-    } else if (parse_int_option(\"super:\", &_super)) {\n+    } else if (parse_uint_option(\"super:\", &_super)) {\n@@ -139,1 +167,1 @@\n-      while (try_parse_int(&i)) {\n+      while (try_parse_uint(&i)) {\n@@ -153,0 +181,2 @@\n+    } else if (lambda_proxy_line) {\n+      parse_int(&_cp_index);\n@@ -158,1 +188,3 @@\n-  \/\/ if src is specified\n+  \/\/ if it is a lambda_proxy_line\n+  \/\/     only indy_index should be specified\n+  \/\/ else if src is specified\n@@ -184,3 +216,0 @@\n-    if (*value < 0) {\n-      error(\"Error: negative integers not allowed (%d)\", *value);\n-    }\n@@ -192,1 +221,8 @@\n-bool ClassListParser::try_parse_int(int* value) {\n+void ClassListParser::parse_uint(int* value) {\n+  parse_int(value);\n+  if (*value < 0) {\n+    error(\"Error: negative integers not allowed (%d)\", *value);\n+  }\n+}\n+\n+bool ClassListParser::try_parse_uint(int* value) {\n@@ -223,0 +259,12 @@\n+bool ClassListParser::parse_uint_option(const char* option_name, int* value) {\n+  if (skip_token(option_name)) {\n+    if (*value != _unspecified) {\n+      error(\"%s specified twice\", option_name);\n+    } else {\n+      parse_uint(value);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -329,0 +377,45 @@\n+void ClassListParser::resolve_indy(Symbol* class_name_symbol, TRAPS) {\n+\n+  Handle class_loader(THREAD, SystemDictionary::java_system_loader());\n+  Handle protection_domain;\n+  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, protection_domain, true, THREAD); \/\/ FIXME should really be just a lookup\n+  if (klass != NULL && klass->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    MetaspaceShared::try_link_class(ik, THREAD);\n+    assert(!HAS_PENDING_EXCEPTION, \"unexpected exception\");\n+\n+    ConstantPool* cp = ik->constants();\n+    ConstantPoolCache* cpcache = cp->cache();\n+    for (int cpcindex = 0; cpcindex < cpcache->length(); cpcindex ++) {\n+      int indy_index = ConstantPool::encode_invokedynamic_index(cpcindex);\n+      ConstantPoolCacheEntry* cpce = cpcache->entry_at(cpcindex);\n+      int pool_index = cpce->constant_pool_index();\n+      if (pool_index == _cp_index) {\n+        constantPoolHandle pool(THREAD, cp);\n+        if (!pool->tag_at(pool_index).has_bootstrap()) {\n+          ResourceMark rm(THREAD);\n+          tty->print_cr(\"Invalid cp_index %d for class %s\", pool_index, ik->name()->as_C_string());\n+          exit(1);\n+        }\n+        BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);\n+        Handle bsm = bootstrap_specifier.resolve_bsm(THREAD);\n+        if (!SystemDictionaryShared::is_supported_invokedynamic(bootstrap_specifier)) {\n+           tty->print_cr(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n+           exit(1);\n+        }\n+        CallInfo info;\n+        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(info, THREAD);\n+        if (!is_done) {\n+          \/\/ resolve it\n+          Handle recv;\n+          LinkResolver::resolve_invoke(info, recv, pool, indy_index, Bytecodes::_invokedynamic, THREAD);\n+        }\n+        cpce->set_dynamic_call(pool, info);\n+        if (HAS_PENDING_EXCEPTION) {\n+          exit(1);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -332,0 +425,5 @@\n+  if (_cp_index != _unspecified) {\n+    resolve_indy(class_name_symbol, CHECK_NULL);\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":110,"deletions":12,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#define LAMBDA_PROXY_TAG \"@lambda-proxy:\"\n+\n@@ -64,0 +66,1 @@\n+  int                 _cp_index;\n@@ -71,0 +74,1 @@\n+  bool parse_uint_option(const char* option_name, int* value);\n@@ -78,0 +82,1 @@\n+  void resolve_indy(Symbol* class_name_symbol, TRAPS);\n@@ -89,1 +94,2 @@\n-  bool try_parse_int(int* value);\n+  void parse_uint(int* value);\n+  bool try_parse_uint(int* value);\n","filename":"src\/hotspot\/share\/classfile\/classListParser.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1356,2 +1356,4 @@\n-  assert(shared_nest_host->is_same_class_package(ik),\n-         \"lambda proxy class and its nest host must be in the same package\");\n+  if (loaded_ik != NULL) {\n+    assert(shared_nest_host->is_same_class_package(ik),\n+           \"lambda proxy class and its nest host must be in the same package\");\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"interpreter\/bootstrapInfo.hpp\"\n@@ -100,0 +102,1 @@\n+  InstanceKlass*               _nest_host;\n@@ -111,0 +114,1 @@\n+    _nest_host = NULL;\n@@ -148,0 +152,1 @@\n+    it->push(&_nest_host);\n@@ -179,0 +184,8 @@\n+\n+  void set_nest_host(InstanceKlass* nest_host) {\n+    _nest_host = nest_host;\n+  }\n+\n+  InstanceKlass* nest_host() {\n+    return _nest_host;\n+  }\n@@ -259,1 +272,3 @@\n-      field = DynamicArchive::original_to_target(field);\n+      if (DynamicDumpSharedSpaces) {\n+        field = DynamicArchive::original_to_target(field);\n+      }\n@@ -285,0 +300,9 @@\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_caller_ik);\n+    it->push(&_invoked_name);\n+    it->push(&_invoked_type);\n+    it->push(&_method_type);\n+    it->push(&_member_method);\n+    it->push(&_instantiated_method_type);\n+  }\n+\n@@ -311,0 +335,8 @@\n+  static unsigned int dumptime_hash(Symbol* sym)  {\n+    if (sym == NULL) {\n+      \/\/ _invoked_name maybe NULL\n+      return 0;\n+    }\n+    return java_lang_String::hash_code((const jbyte*)sym->bytes(), sym->utf8_length());\n+  }\n+\n@@ -312,5 +344,5 @@\n-    return primitive_hash<InstanceKlass*>(_caller_ik) +\n-           primitive_hash<Symbol*>(_invoked_name) +\n-           primitive_hash<Symbol*>(_invoked_type) +\n-           primitive_hash<Symbol*>(_method_type) +\n-           primitive_hash<Symbol*>(_instantiated_method_type);\n+    return dumptime_hash(_caller_ik->name()) +\n+           dumptime_hash(_invoked_name) +\n+           dumptime_hash(_invoked_type) +\n+           dumptime_hash(_method_type) +\n+           dumptime_hash(_instantiated_method_type);\n@@ -341,0 +373,6 @@\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    for (int i=0; i<_proxy_klasses->length(); i++) {\n+      it->push(_proxy_klasses->adr_at(i));\n+    }\n+  }\n@@ -347,2 +385,2 @@\n-  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass) :\n-    _key(key), _proxy_klass_head(proxy_klass) {}\n+  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n+    _key(key), _proxy_klass_head(proxy_klass_head) {}\n@@ -360,1 +398,3 @@\n-    _proxy_klass_head = DynamicArchive::original_to_target(info._proxy_klasses->at(0));\n+    _proxy_klass_head = DynamicDumpSharedSpaces ?\n+                          DynamicArchive::original_to_target(info._proxy_klasses->at(0)) :\n+                          info._proxy_klasses->at(0);\n@@ -367,0 +407,3 @@\n+  LambdaProxyClassKey key() const {\n+    return _key;\n+  }\n@@ -376,0 +419,2 @@\n+LambdaProxyClassDictionary _dynamic_lambda_proxy_class_dictionary;\n+\n@@ -587,4 +632,4 @@\n-    if (DynamicDumpSharedSpaces) {\n-      if (_klass->is_hidden()) {\n-        Thread* THREAD = Thread::current();\n-        InstanceKlass* n_h = _klass->nest_host(THREAD);\n+\n+    if (_klass->is_hidden()) {\n+      InstanceKlass* n_h = info.nest_host();\n+      if (DynamicDumpSharedSpaces) {\n@@ -592,1 +637,0 @@\n-        set_nest_host(n_h);\n@@ -594,1 +638,1 @@\n-      _klass = DynamicArchive::original_to_target(info._klass);\n+      set_nest_host(n_h);\n@@ -596,0 +640,1 @@\n+    _klass = DynamicDumpSharedSpaces ? DynamicArchive::original_to_target(info._klass) : info._klass;\n@@ -1390,1 +1435,1 @@\n-    if (SystemDictionaryShared::should_be_excluded(k)) {\n+    if (SystemDictionaryShared::should_be_excluded(k) || info.is_excluded()) {\n@@ -1442,0 +1487,12 @@\n+class IterateDumpTimeLambdaProxyClassDictionary : StackObj {\n+  MetaspaceClosure *_it;\n+public:\n+  IterateDumpTimeLambdaProxyClassDictionary(MetaspaceClosure* it) : _it(it) {}\n+\n+  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    info.metaspace_pointers_do(_it);\n+    key.metaspace_pointers_do(_it);\n+    return true;\n+  }\n+};\n+\n@@ -1446,0 +1503,4 @@\n+  if (_dumptime_lambda_proxy_class_dictionary != NULL) {\n+    IterateDumpTimeLambdaProxyClassDictionary iter_lambda(it);\n+    _dumptime_lambda_proxy_class_dictionary->iterate(&iter_lambda);\n+  }\n@@ -1516,1 +1577,2 @@\n-                                                    Symbol* instantiated_method_type) {\n+                                                    Symbol* instantiated_method_type,\n+                                                    TRAPS) {\n@@ -1526,0 +1588,1 @@\n+  InstanceKlass* nest_host = caller_ik->nest_host(THREAD);\n@@ -1532,0 +1595,1 @@\n+    info->set_nest_host(nest_host);\n@@ -1553,0 +1617,4 @@\n+  if (info == NULL) {\n+    \/\/ Try lookup from the dynamic lambda proxy class dictionary.\n+    info = _dynamic_lambda_proxy_class_dictionary.lookup(&key, key.hash(), 0);\n+  }\n@@ -1570,1 +1638,1 @@\n-        log_debug(cds)(\"Loaded lambda proxy: %s\", proxy_klass->external_name());\n+        log_debug(cds)(\"Loaded lambda proxy: %s \", proxy_klass->external_name());\n@@ -1605,0 +1673,4 @@\n+  if (loaded_lambda == NULL) {\n+    return NULL;\n+  }\n+\n@@ -1839,0 +1911,21 @@\n+bool SystemDictionaryShared::is_supported_invokedynamic(BootstrapInfo bsi) {\n+  if (bsi.arg_values() == NULL || !bsi.arg_values()->is_objArray()) {\n+    return false;\n+  }\n+\n+  Handle bsm = bsi.bsm();\n+  if (bsm.is_null() || !java_lang_invoke_DirectMethodHandle::is_instance(bsm())) {\n+    return false;\n+  }\n+\n+  oop mn = java_lang_invoke_DirectMethodHandle::member(bsm());\n+  Method* method = java_lang_invoke_MemberName::vmtarget(mn);\n+  if (method->klass_name()->equals(\"java\/lang\/invoke\/LambdaMetafactory\") &&\n+      method->name()->equals(\"metafactory\") &&\n+      method->signature()->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\")) {\n+      return true;\n+  }\n+\n+  return false;\n+}\n+\n@@ -1886,3 +1979,9 @@\n-    if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses->at(0))) {\n-      return true;\n-    }\n+    \/\/ In static dump, info._proxy_klasses->at(0) is already relocated to point to the archived class\n+    \/\/ (not the original class).\n+    \/\/\n+    \/\/ The following check has been moved to SystemDictionaryShared::check_excluded_classes(), which\n+    \/\/ happens before the classes are copied.\n+    \/\/\n+    \/\/ if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses->at(0))) {\n+    \/\/  return true;\n+    \/\/}\n@@ -1896,1 +1995,3 @@\n-    u4 delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(runtime_info));\n+    u4 delta = DynamicDumpSharedSpaces ?\n+                 MetaspaceShared::object_delta_u4((void*)DynamicArchive::buffer_to_target(runtime_info)) :\n+                 MetaspaceShared::object_delta_u4((void*)runtime_info);\n@@ -1906,3 +2007,0 @@\n-    if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses->at(0))) {\n-      return true;\n-    }\n@@ -1914,2 +2012,2 @@\n-        InstanceKlass* bk0 = DynamicArchive::original_to_buffer(ok0);\n-        InstanceKlass* bk1 = DynamicArchive::original_to_buffer(ok1);\n+        InstanceKlass* bk0 = DynamicDumpSharedSpaces ? DynamicArchive::original_to_buffer(ok0) : ok0;\n+        InstanceKlass* bk1 = DynamicDumpSharedSpaces ? DynamicArchive::original_to_buffer(ok1) : ok1;\n@@ -1923,1 +2021,5 @@\n-    DynamicArchive::original_to_buffer(info._proxy_klasses->at(0))->set_lambda_proxy_is_available();\n+    if (DynamicDumpSharedSpaces) {\n+      DynamicArchive::original_to_buffer(info._proxy_klasses->at(0))->set_lambda_proxy_is_available();\n+    } else {\n+      info._proxy_klasses->at(0)->set_lambda_proxy_is_available();\n+    }\n@@ -2014,0 +2116,1 @@\n+  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -2017,0 +2120,3 @@\n+    if (dynamic_mapinfo == NULL || DynamicDumpSharedSpaces || (dynamic_mapinfo != NULL && UseSharedSpaces)) {\n+      _lambda_proxy_class_dictionary.serialize_header(soc);\n+    }\n@@ -2020,1 +2126,5 @@\n-    _lambda_proxy_class_dictionary.serialize_header(soc);\n+    if (DynamicDumpSharedSpaces) {\n+      _lambda_proxy_class_dictionary.serialize_header(soc);\n+    } else {\n+      _dynamic_lambda_proxy_class_dictionary.serialize_header(soc);\n+    }\n@@ -2097,0 +2207,16 @@\n+void SystemDictionaryShared::print_on(const char* prefix,\n+                                      RunTimeSharedDictionary builtin_dictionary,\n+                                      RunTimeSharedDictionary unregistered_dictionary,\n+                                      LambdaProxyClassDictionary lambda_dictionary,\n+                                      outputStream* st) {\n+  st->print_cr(\"%sShared Dictionary\", prefix);\n+  SharedDictionaryPrinter p(st);\n+  builtin_dictionary.iterate(&p);\n+  unregistered_dictionary.iterate(&p);\n+  if (!lambda_dictionary.empty()) {\n+    st->print_cr(\"%sShared Lambda Dictionary\", prefix);\n+    SharedLambdaDictionaryPrinter ldp(st);\n+    lambda_dictionary.iterate(&ldp);\n+  }\n+}\n+\n@@ -2099,4 +2225,1 @@\n-    st->print_cr(\"Shared Dictionary\");\n-    SharedDictionaryPrinter p(st);\n-    _builtin_dictionary.iterate(&p);\n-    _unregistered_dictionary.iterate(&p);\n+    print_on(\"\", _builtin_dictionary, _unregistered_dictionary, _lambda_proxy_class_dictionary, st);\n@@ -2104,7 +2227,2 @@\n-      _dynamic_builtin_dictionary.iterate(&p);\n-      _unregistered_dictionary.iterate(&p);\n-      if (!_lambda_proxy_class_dictionary.empty()) {\n-        st->print_cr(\"Shared Lambda Dictionary\");\n-        SharedLambdaDictionaryPrinter ldp(st);\n-        _lambda_proxy_class_dictionary.iterate(&ldp);\n-      }\n+      print_on(\"\", _dynamic_builtin_dictionary, _dynamic_unregistered_dictionary,\n+               _dynamic_lambda_proxy_class_dictionary, st);\n@@ -2119,0 +2237,1 @@\n+    _lambda_proxy_class_dictionary.print_table_statistics(st, \"Lambda Shared Dictionary\");\n@@ -2122,1 +2241,1 @@\n-      _lambda_proxy_class_dictionary.print_table_statistics(st, \"Lambda Shared Dictionary\");\n+      _dynamic_lambda_proxy_class_dictionary.print_table_statistics(st, \"Dynamic Lambda Shared Dictionary\");\n@@ -2141,0 +2260,1 @@\n+protected:\n@@ -2165,0 +2285,12 @@\n+class ArchivedLambdaMirrorPatcher : public ArchivedMirrorPatcher {\n+public:\n+  void do_value(const RunTimeLambdaProxyClassInfo* info) {\n+    InstanceKlass* ik = info->proxy_klass_head();\n+    while (ik != NULL) {\n+      update(ik);\n+      Klass* k = ik->next_link();\n+      ik = (k != NULL) ? InstanceKlass::cast(k) : NULL;\n+    }\n+  }\n+};\n+\n@@ -2170,0 +2302,5 @@\n+void SystemDictionaryShared::update_archived_mirror_native_pointers_for(LambdaProxyClassDictionary* dict) {\n+  ArchivedLambdaMirrorPatcher patcher;\n+  dict->iterate(&patcher);\n+}\n+\n@@ -2179,0 +2316,1 @@\n+  update_archived_mirror_native_pointers_for(&_lambda_proxy_class_dictionary);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":179,"deletions":41,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -223,0 +223,5 @@\n+  static void print_on(const char* prefix,\n+                       RunTimeSharedDictionary builtin_dictionary,\n+                       RunTimeSharedDictionary unregistered_dictionary,\n+                       LambdaProxyClassDictionary lambda_dictionary,\n+                       outputStream* st) NOT_CDS_RETURN;\n@@ -291,1 +296,1 @@\n-                                     Symbol* instantiated_method_type) NOT_CDS_RETURN;\n+                                     Symbol* instantiated_method_type, TRAPS) NOT_CDS_RETURN;\n@@ -324,0 +329,1 @@\n+  static bool is_supported_invokedynamic(BootstrapInfo bsi) NOT_CDS_RETURN_(false);\n@@ -350,0 +356,1 @@\n+  static void update_archived_mirror_native_pointers_for(LambdaProxyClassDictionary* dict);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-JVM_IsDynamicDumpingEnabled(JNIEnv* env);\n+JVM_IsCDSDumpingEnabled(JNIEnv* env);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classListParser.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -1768,0 +1771,7 @@\n+\n+  if (DumpLoadedClassList != NULL && classlist_file->is_open()) {\n+    if (SystemDictionaryShared::is_supported_invokedynamic(bootstrap_specifier)) {\n+      ResourceMark rm(THREAD);\n+      classlist_file->print_cr(\"%s %s %d\", LAMBDA_PROXY_TAG, pool->pool_holder()->name()->as_C_string(), pool_index);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -780,0 +780,2 @@\n+  SystemDictionaryShared::adjust_lambda_proxy_class_dictionary();\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -621,0 +621,1 @@\n+    ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3744,1 +3744,1 @@\n-  if (!DynamicDumpSharedSpaces) {\n+  if (!Arguments::is_dumping_archive()) {\n@@ -3779,1 +3779,1 @@\n-                                                 method_type, m, instantiated_method_type);\n+                                                 method_type, m, instantiated_method_type, THREAD);\n@@ -3793,3 +3793,0 @@\n-  if (!DynamicArchive::is_mapped()) {\n-    return NULL;\n-  }\n@@ -3836,3 +3833,3 @@\n-JVM_ENTRY(jboolean, JVM_IsDynamicDumpingEnabled(JNIEnv* env))\n-    JVMWrapper(\"JVM_IsDynamicDumpingEnable\");\n-    return DynamicDumpSharedSpaces;\n+JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))\n+    JVMWrapper(\"JVM_IsCDSDumpingEnable\");\n+    return Arguments::is_dumping_archive();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-        dumpArchive = CDS.isDynamicDumpingEnabled();\n+        dumpArchive = CDS.isCDSDumpingEnabled();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaProxyClassArchive.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-     * Check if dynamic dumping is enabled via the DynamicDumpSharedSpaces flag.\n+     * Check if CDS dumping is enabled via the DynamicDumpSharedSpaces or the DumpSharedSpaces flag.\n@@ -56,1 +56,1 @@\n-    public static native boolean isDynamicDumpingEnabled(); \/\/ will return false for static dumping.\n+    public static native boolean isCDSDumpingEnabled();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-Java_jdk_internal_misc_CDS_isDynamicDumpingEnabled(JNIEnv *env, jclass jcls) {\n-    return JVM_IsDynamicDumpingEnabled(env);\n+Java_jdk_internal_misc_CDS_isCDSDumpingEnabled(JNIEnv *env, jclass jcls) {\n+    return JVM_IsCDSDumpingEnabled(env);\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+ -runtime\/cds\/appcds\/methodHandles \\\n@@ -332,0 +333,2 @@\n+ -runtime\/cds\/appcds\/BadBSM.java \\\n+ -runtime\/cds\/appcds\/BadCPIndex.java \\\n@@ -339,0 +342,1 @@\n+ -runtime\/cds\/appcds\/StaticArchiveWithLambda.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary CDS dump should abort if a class file contains a bad BSM.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/WrongBSM.jcod\n+ * @run driver BadBSM\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BadBSM {\n+\n+  public static void main(String[] args) throws Exception {\n+    JarBuilder.build(\"wrongbsm\", \"WrongBSM\");\n+\n+    String appJar = TestCommon.getTestJar(\"wrongbsm.jar\");\n+\n+    OutputAnalyzer out = TestCommon.dump(appJar,\n+        TestCommon.list(\"WrongBSM\",\n+                        \"@lambda-proxy: WrongBSM 7\"));\n+    out.shouldHaveExitValue(1);\n+    out.shouldContain( \"is_supported_invokedynamic check failed for cp_index 7\");\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/BadBSM.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary CDS dump should abort upon detection of a bad CP index in the classlist.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile dynamicArchive\/test-classes\/StrConcatApp.java\n+ * @run driver BadCPIndex\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BadCPIndex {\n+\n+  public static void main(String[] args) throws Exception {\n+    JarBuilder.build(\"strconcatapp\", \"StrConcatApp\");\n+\n+    String appJar = TestCommon.getTestJar(\"strconcatapp.jar\");\n+\n+    \/\/ test with an invalid indy index, it should be a negative integer\n+    OutputAnalyzer out = TestCommon.dump(appJar,\n+        TestCommon.list(\"StrConcatApp\",\n+                        \"@lambda-proxy: StrConcatApp 7\"));\n+    out.shouldHaveExitValue(1);\n+    out.shouldContain(\"Invalid cp_index 7 for class StrConcatApp\");\n+\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/BadCPIndex.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Sanity test lambda proxy classes in static CDS archive.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile dynamicArchive\/test-classes\/LambHello.java\n+ * @run driver StaticArchiveWithLambda\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class StaticArchiveWithLambda {\n+    public static void main(String[] args) throws Exception {\n+        String appClass = \"LambHello\";\n+        JarBuilder.build(\"lambhello\", appClass);\n+        String appJar = TestCommon.getTestJar(\"lambhello.jar\");\n+        String classList = \"lambhello.list\";\n+        String archiveName = \"StaticArchiveWithLambda.jsa\";\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", appJar,\n+            appClass);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", appJar,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", appJar, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(appClass);\n+       output = CDSTestUtils.runWithArchive(runOpts);\n+       output.shouldContain(\"LambHello source: shared objects file\")\n+             .shouldMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.shared.objects.file\")\n+             .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/StaticArchiveWithLambda.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Archive lambda proxy class is in the base archive. The lambda proxy\n+ *          class should be loaded from the base archive during runtime.\n+ *\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build LambHello\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller -jar lambhello.jar LambHello\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. LambdaInBaseArchive\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LambdaInBaseArchive extends DynamicArchiveTestBase {\n+    public static void main(String[] args) throws Exception {\n+        createBaseArchive();\n+        runTest(LambdaInBaseArchive::testCustomBase);\n+    }\n+\n+    static String helloBaseArchive = getNewArchiveName(\"base-with-hello\");\n+    static String appJar = ClassFileInstaller.getJarPath(\"lambhello.jar\");\n+    static String mainClass = \"LambHello\";\n+    static String classList = \"lambhello.list\";\n+\n+    static void createBaseArchive() throws Exception {\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", appJar,\n+            mainClass);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+        output.shouldHaveExitValue(0);\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", appJar,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(helloBaseArchive);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+    }\n+\n+    \/\/ Test with custom base archive + top archive\n+    static void testCustomBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top2\");\n+        doTest(helloBaseArchive, topArchiveName);\n+    }\n+\n+    private static void doTest(String baseArchiveName, String topArchiveName) throws Exception {\n+        dump2(baseArchiveName, topArchiveName,\n+             \"-Xlog:class+load,cds,cds+dynamic=debug\",\n+             \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Buffer-space to target-space delta\")\n+                           .shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run2(baseArchiveName, topArchiveName,\n+            \"-Xlog:class+load,cds+dynamic=debug,cds=debug\",\n+            \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"LambHello source: shared objects file\")\n+                      .shouldMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.shared.objects.file\")\n+                      .shouldNotMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.shared.objects.file.*(top)\");\n+                });\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaInBaseArchive.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -51,2 +51,3 @@\n-        Method method = c.getDeclaredMethod(\"doTest\");\n-        method.invoke(o);\n+        Method method = c.getMethod(\"main\", String[].class);\n+        String[] params = null;\n+        method.invoke(null, (Object)params);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/CustomLoaderApp.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+        doTest();\n@@ -28,1 +29,1 @@\n-    public void doTest() {\n+    static void doTest() {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/LambHello.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+#!\/bin\/bash\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"\/\/ --- start auto-generated\"\n+\n+testnames=( MethodHandlesGeneralTest  MethodHandlesAsCollectorTest MethodHandlesCastFailureTest MethodHandlesInvokersTest MethodHandlesPermuteArgumentsTest MethodHandlesSpreadArgumentsTest )\n+name_suffix='.java'\n+\n+for i in \"${testnames[@]}\"\n+do\n+    fname=\"$i$name_suffix\"\n+    cat << EOF > $fname\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by $0. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the $fname test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/$fname\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. $i\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class $i {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"$i\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.$i[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n+EOF\n+done\n+echo \"\/\/ --- end auto-generated\"\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/CDSMHTest_generate.sh","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesAsCollectorTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesAsCollectorTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesAsCollectorTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesAsCollectorTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesAsCollectorTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesAsCollectorTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesAsCollectorTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesCastFailureTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesCastFailureTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesCastFailureTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesCastFailureTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesCastFailureTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesCastFailureTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesCastFailureTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesGeneralTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesGeneralTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesGeneralTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesGeneralTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesGeneralTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesGeneralTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesGeneralTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesInvokersTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesInvokersTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesInvokersTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesInvokersTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesInvokersTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesInvokersTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesInvokersTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesPermuteArgumentsTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesPermuteArgumentsTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesPermuteArgumentsTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesPermuteArgumentsTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesPermuteArgumentsTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesPermuteArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesPermuteArgumentsTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/\/ this file is auto-generated by .\/CDSMHTest_generate.sh. Do not edit manually.\n+\n+\/*\n+ * @test\n+ * @summary Run the MethodHandlesSpreadArgumentsTest.java test in static CDS archive mode.\n+ * @requires vm.cds & vm.compMode != \"Xcomp\"\n+ * @comment Some of the tests run excessively slowly with -Xcomp. The original\n+ *          tests aren't executed with -Xcomp in the CI pipeline, so let's exclude\n+ *          the generated tests from -Xcomp execution as well.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesTest.java\n+ *        ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Utils.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/MethodHandlesSpreadArgumentsTest.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/remote\/RemoteExample.java\n+ *        ..\/..\/..\/..\/..\/..\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/CodeCacheOverflowProcessor.java\n+ *        ..\/dynamicArchive\/test-classes\/TestMHApp.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. MethodHandlesSpreadArgumentsTest\n+ *\/\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class MethodHandlesSpreadArgumentsTest {\n+    @Test\n+    public void test() throws Exception {\n+        testImpl();\n+    }\n+\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final String mainClass = \"TestMHApp\";\n+    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n+    private static final String ps = System.getProperty(\"path.separator\");\n+    private static final String testPackageName = \"test.java.lang.invoke\";\n+    private static final String testClassName = \"MethodHandlesSpreadArgumentsTest\";\n+\n+    static void testImpl() throws Exception {\n+        String appJar = JarBuilder.build(\"MH\", new File(classDir), null);\n+        String classList = testClassName + \".list\";\n+        String archiveName = testClassName + \".jsa\";\n+\n+        String[] classPaths = javaClassPath.split(File.pathSeparator);\n+        String junitJar = null;\n+        for (String path : classPaths) {\n+            if (path.endsWith(\"junit.jar\")) {\n+                junitJar = path;\n+                break;\n+            }\n+        }\n+\n+        String jars = appJar + ps + junitJar;\n+\n+        \/\/ dump class list\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n+            \"-XX:DumpLoadedClassList=\" + classList,\n+            \"-cp\", jars,\n+            mainClass, testPackageName + \".\" + testClassName);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dumpClassList\");\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", jars,\n+                       \"-Xlog:class+load,cds\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", jars, \"-Xlog:class+load,cds=debug\")\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass, testPackageName + \".\" + testClassName);\n+        output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesSpreadArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+              .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesSpreadArgumentsTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This class file has an incorrect constant pool entry #49 which results\n+ * in an incorrect BSM.\n+ * The correct entry should have a return type as follows instead of V:\n+ *     Ljava\/lang\/invoke\/CallSite;\"; \/\/ #49\n+ *\/\n+\n+class WrongBSM {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  59; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    InvokeDynamic 0s #8; \/\/ #7\n+    NameAndType #9 #10; \/\/ #8\n+    Utf8 \"run\"; \/\/ #9\n+    Utf8 \"()Ljava\/lang\/Runnable;\"; \/\/ #10\n+    Method #12 #13; \/\/ #11\n+    class #14; \/\/ #12\n+    NameAndType #15 #16; \/\/ #13\n+    Utf8 \"WrongBSM\"; \/\/ #14\n+    Utf8 \"doit\"; \/\/ #15\n+    Utf8 \"(Ljava\/lang\/Runnable;)V\"; \/\/ #16\n+    InterfaceMethod #18 #19; \/\/ #17\n+    class #20; \/\/ #18\n+    NameAndType #9 #6; \/\/ #19\n+    Utf8 \"java\/lang\/Runnable\"; \/\/ #20\n+    Field #22 #23; \/\/ #21\n+    class #24; \/\/ #22\n+    NameAndType #25 #26; \/\/ #23\n+    Utf8 \"java\/lang\/System\"; \/\/ #24\n+    Utf8 \"out\"; \/\/ #25\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #26\n+    String #28; \/\/ #27\n+    Utf8 \"Hello from Lambda\"; \/\/ #28\n+    Method #30 #31; \/\/ #29\n+    class #32; \/\/ #30\n+    NameAndType #33 #34; \/\/ #31\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #32\n+    Utf8 \"println\"; \/\/ #33\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #34\n+    Utf8 \"Code\"; \/\/ #35\n+    Utf8 \"LineNumberTable\"; \/\/ #36\n+    Utf8 \"main\"; \/\/ #37\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #38\n+    Utf8 \"lambda$main$0\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"WrongBSM.java\"; \/\/ #41\n+    Utf8 \"BootstrapMethods\"; \/\/ #42\n+    MethodHandle 6b #44; \/\/ #43\n+    Method #45 #46; \/\/ #44\n+    class #47; \/\/ #45\n+    NameAndType #48 #49; \/\/ #46\n+    Utf8 \"java\/lang\/invoke\/LambdaMetafactory\"; \/\/ #47\n+    Utf8 \"metafactory\"; \/\/ #48\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)V\"; \/\/ #49\n+    MethodType #6; \/\/ #50\n+    MethodHandle 6b #52; \/\/ #51\n+    Method #12 #53; \/\/ #52\n+    NameAndType #39 #6; \/\/ #53\n+    Utf8 \"InnerClasses\"; \/\/ #54\n+    class #56; \/\/ #55\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #56\n+    class #58; \/\/ #57\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #58\n+    Utf8 \"Lookup\"; \/\/ #59\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#35) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#36) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #37; \/\/ name_index\n+      #38; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#35) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xBA00070000B8000B;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#36) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                8  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #16; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#35) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB900110100B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#36) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  8;\n+                6  9;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x100A; \/\/ access\n+      #39; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#35) { \/\/ Code\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xB20015121BB6001D;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#36) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+                8  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#42) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #43; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+            #50;\n+            #51;\n+            #50;\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#54) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #55 #57 #59 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class WrongBSM\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/WrongBSM.jcod","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"}]}