{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,2 @@\n-public final class ARCFOURCipher extends CipherSpi {\n+public sealed class ARCFOURCipher extends CipherSpi\n+        permits PKCS12PBECipherCore.PBEWithSHA1AndRC4 {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ARCFOURCipher.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,2 @@\n-public final class DESedeCipher extends CipherSpi {\n+public sealed class DESedeCipher extends CipherSpi\n+        permits PKCS12PBECipherCore.PBEWithSHA1AndDESede {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeCipher.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,0 +169,18 @@\n+    private static byte[] check(byte[] salt)\n+        throws InvalidAlgorithmParameterException {\n+        if (salt != null && salt.length < 8) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Salt must be at least 8 bytes long\");\n+        }\n+        return salt;\n+    }\n+\n+    private static int check(int iCount)\n+        throws InvalidAlgorithmParameterException {\n+        if (iCount < 0) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Iteration count must be a positive number\");\n+        }\n+        return iCount == 0 ? DEFAULT_COUNT : iCount;\n+    }\n+\n@@ -180,0 +198,4 @@\n+        salt = null;\n+        iCount = 0;\n+        ivSpec = null;\n+\n@@ -187,1 +209,2 @@\n-            \/\/ TBD: consolidate the salt, ic and IV parameter checks below\n+            boolean doEncrypt = ((opmode == Cipher.ENCRYPT_MODE) ||\n+                        (opmode == Cipher.WRAP_MODE));\n@@ -189,4 +212,14 @@\n-            \/\/ Extract salt and iteration count from the key, if present\n-            if (key instanceof javax.crypto.interfaces.PBEKey) {\n-                salt = ((javax.crypto.interfaces.PBEKey)key).getSalt();\n-                if (salt != null && salt.length < 8) {\n+            \/\/ Extract from the supplied PBE params, if present\n+            if (params instanceof PBEParameterSpec pbeParams) {\n+                \/\/ salt should be non-null per PBEParameterSpec\n+                salt = check(pbeParams.getSalt());\n+                iCount = check(pbeParams.getIterationCount());\n+                AlgorithmParameterSpec ivParams = pbeParams.getParameterSpec();\n+                if (ivParams instanceof IvParameterSpec iv) {\n+                    ivSpec = iv;\n+                } else if (ivParams == null && doEncrypt) {\n+                    \/\/ generate random IV\n+                    byte[] ivBytes = new byte[blkSize];\n+                    random.nextBytes(ivBytes);\n+                    ivSpec = new IvParameterSpec(ivBytes);\n+                } else {\n@@ -194,1 +227,1 @@\n-                            \"Salt must be at least 8 bytes long\");\n+                            \"Wrong parameter type: IV expected\");\n@@ -196,6 +229,6 @@\n-                iCount = ((javax.crypto.interfaces.PBEKey)key).getIterationCount();\n-                if (iCount == 0) {\n-                    iCount = DEFAULT_COUNT;\n-                } else if (iCount < 0) {\n-                    throw new InvalidAlgorithmParameterException(\n-                            \"Iteration count must be a positive number\");\n+            } else if (params == null && doEncrypt) {\n+                \/\/ Try extracting from the key if present. If unspecified,\n+                \/\/ PBEKey returns null and 0 respectively.\n+                if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n+                    salt = check(pbeKey.getSalt());\n+                    iCount = check(pbeKey.getIterationCount());\n@@ -203,4 +236,0 @@\n-            }\n-\n-            \/\/ Extract salt, iteration count and IV from the params, if present\n-            if (params == null) {\n@@ -208,1 +237,1 @@\n-                    \/\/ generate random salt and use default iteration count\n+                    \/\/ generate random salt\n@@ -211,1 +240,0 @@\n-                    iCount = DEFAULT_COUNT;\n@@ -213,6 +241,3 @@\n-                if ((opmode == Cipher.ENCRYPT_MODE) ||\n-                        (opmode == Cipher.WRAP_MODE)) {\n-                    \/\/ generate random IV\n-                    byte[] ivBytes = new byte[blkSize];\n-                    random.nextBytes(ivBytes);\n-                    ivSpec = new IvParameterSpec(ivBytes);\n+                if (iCount == 0) {\n+                    \/\/ use default iteration count\n+                    iCount = DEFAULT_COUNT;\n@@ -220,0 +245,4 @@\n+                \/\/ generate random IV\n+                byte[] ivBytes = new byte[blkSize];\n+                random.nextBytes(ivBytes);\n+                ivSpec = new IvParameterSpec(ivBytes);\n@@ -221,39 +250,2 @@\n-                if (!(params instanceof PBEParameterSpec)) {\n-                    throw new InvalidAlgorithmParameterException\n-                            (\"Wrong parameter type: PBE expected\");\n-                }\n-                \/\/ salt and iteration count from the params take precedence\n-                byte[] specSalt = ((PBEParameterSpec) params).getSalt();\n-                if (specSalt != null && specSalt.length < 8) {\n-                    throw new InvalidAlgorithmParameterException(\n-                            \"Salt must be at least 8 bytes long\");\n-                }\n-                salt = specSalt;\n-                int specICount = ((PBEParameterSpec) params).getIterationCount();\n-                if (specICount == 0) {\n-                    specICount = DEFAULT_COUNT;\n-                } else if (specICount < 0) {\n-                    throw new InvalidAlgorithmParameterException(\n-                            \"Iteration count must be a positive number\");\n-                }\n-                iCount = specICount;\n-\n-                AlgorithmParameterSpec specParams =\n-                        ((PBEParameterSpec) params).getParameterSpec();\n-                if (specParams != null) {\n-                    if (specParams instanceof IvParameterSpec) {\n-                        ivSpec = (IvParameterSpec)specParams;\n-                    } else {\n-                        throw new InvalidAlgorithmParameterException(\n-                                \"Wrong parameter type: IV expected\");\n-                    }\n-                } else if ((opmode == Cipher.ENCRYPT_MODE) ||\n-                        (opmode == Cipher.WRAP_MODE)) {\n-                    \/\/ generate random IV\n-                    byte[] ivBytes = new byte[blkSize];\n-                    random.nextBytes(ivBytes);\n-                    ivSpec = new IvParameterSpec(ivBytes);\n-                } else {\n-                    throw new InvalidAlgorithmParameterException(\n-                            \"Missing parameter type: IV expected\");\n-                }\n+                throw new InvalidAlgorithmParameterException\n+                        (\"Wrong parameter type: PBE expected\");\n@@ -261,1 +253,0 @@\n-\n@@ -267,0 +258,1 @@\n+        } finally {\n@@ -269,1 +261,0 @@\n-        } finally {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Core.java","additions":57,"deletions":66,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.io.Closeable;\n+import java.io.IOException;\n@@ -47,9 +49,3 @@\n-\n-    \/\/ TBD: replace CipherCore with a CipherSpi object to simplify maintenance\n-\n-    private CipherCore cipher;\n-    private int blockSize;\n-    private int keySize;\n-    private int keyLength; \/\/ in bits\n-    private String algo = null;\n-    private String pbeAlgo = null;\n+    private final int keySize; \/\/ in bytes\n+    private final String algo;\n+    private final String pbeAlgo;\n@@ -174,23 +170,5 @@\n-    PKCS12PBECipherCore(String symmCipherAlg, int defKeySize)\n-        throws NoSuchAlgorithmException {\n-\n-        algo = symmCipherAlg;\n-        keyLength = defKeySize * 8;\n-        if (algo.equals(\"RC4\")) {\n-            pbeAlgo = \"PBEWithSHA1AndRC4_\" + keyLength;\n-        } else {\n-            SymmetricCipher symmCipher = null;\n-            if (algo.equals(\"DESede\")) {\n-                symmCipher = new DESedeCrypt();\n-                pbeAlgo = \"PBEWithSHA1AndDESede\";\n-                keyLength = 112; \/\/ effective key length\n-            } else if (algo.equals(\"RC2\")) {\n-                symmCipher = new RC2Crypt();\n-                pbeAlgo = \"PBEWithSHA1AndRC2_\" + keyLength;\n-            } else {\n-                throw new NoSuchAlgorithmException(\"No Cipher implementation \" +\n-                       \"for PBEWithSHA1And\" + algo);\n-            }\n-            blockSize = symmCipher.getBlockSize();\n-            cipher = new CipherCore(symmCipher, blockSize);\n-            cipher.setMode(\"CBC\");\n+    \/\/ holder for the derived key and iv\n+    private record KeyAndIv(SecretKey key, IvParameterSpec iv)\n+            implements Closeable {\n+        @Override\n+        public void close() {\n@@ -198,3 +176,3 @@\n-                cipher.setPadding(\"PKCS5Padding\");\n-            } catch (NoSuchPaddingException nspe) {\n-                \/\/ should not happen\n+                key.destroy();\n+            } catch (DestroyFailedException e) {\n+                \/\/ Ignore the failure\n@@ -203,8 +181,0 @@\n-        keySize = defKeySize;\n-    }\n-\n-    void implSetMode(String mode) throws NoSuchAlgorithmException {\n-        if ((mode != null) && (!mode.equalsIgnoreCase(\"CBC\"))) {\n-            throw new NoSuchAlgorithmException(\"Invalid cipher mode: \"\n-                                               + mode);\n-        }\n@@ -213,15 +183,2 @@\n-    void implSetPadding(String padding) throws NoSuchPaddingException {\n-        if ((padding != null) &&\n-            (!padding.equalsIgnoreCase(\"PKCS5Padding\"))) {\n-            throw new NoSuchPaddingException(\"Invalid padding scheme: \" +\n-                                             padding);\n-        }\n-    }\n-\n-    int implGetBlockSize() {\n-        return blockSize;\n-    }\n-\n-    int implGetOutputSize(int inLen) {\n-        return cipher.getOutputSize(inLen);\n-    }\n+    PKCS12PBECipherCore(String symmCipherAlg, int keySizeInBits)\n+            throws NoSuchAlgorithmException {\n@@ -229,2 +186,9 @@\n-    byte[] implGetIV() {\n-        return cipher.getIV();\n+        algo = symmCipherAlg;\n+        pbeAlgo = switch (algo) {\n+            case \"RC4\" -> \"PBEWithSHA1AndRC4_\" + keySizeInBits;\n+            case \"DESede\" -> \"PBEWithSHA1AndDESede\";\n+            case \"RC2\" -> \"PBEWithSHA1AndRC2_\" + keySizeInBits;\n+            default -> throw new NoSuchAlgorithmException(\n+                   \"No Cipher implementation for PBEWithSHA1And\" + algo);\n+        };\n+        keySize = keySizeInBits >> 3;\n@@ -259,10 +223,4 @@\n-    void implInit(int opmode, Key key, AlgorithmParameterSpec params,\n-                  SecureRandom random) throws InvalidKeyException,\n-        InvalidAlgorithmParameterException {\n-        implInit(opmode, key, params, random, null);\n-    }\n-\n-    void implInit(int opmode, Key key, AlgorithmParameterSpec params,\n-                  SecureRandom random, CipherSpi cipherImpl)\n-                      throws InvalidKeyException,\n-        InvalidAlgorithmParameterException {\n+    \/\/ returns derived Key and Iv\n+    KeyAndIv implInit(int opmode, Key key, AlgorithmParameterSpec params,\n+                  SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n@@ -348,0 +306,1 @@\n+\n@@ -353,19 +312,9 @@\n-            try {\n-                if (cipherImpl != null && cipherImpl instanceof ARCFOURCipher) {\n-                    ((ARCFOURCipher) cipherImpl).engineInit(opmode, cipherKey, random);\n-\n-                } else {\n-                    byte[] derivedIv = derive(passwdChars, salt, iCount, 8,\n-                            CIPHER_IV);\n-                    IvParameterSpec ivSpec = new IvParameterSpec(derivedIv, 0, 8);\n-\n-                    \/\/ initialize the underlying cipher\n-                    cipher.init(opmode, cipherKey, ivSpec, random);\n-                }\n-            } finally {\n-                try {\n-                    cipherKey.destroy();\n-                } catch (DestroyFailedException e) {\n-                    \/\/ Ignore the failure\n-                }\n-            }\n+            return switch (algo) {\n+                case \"RC4\" -> new KeyAndIv(cipherKey, null);\n+                case \"RC2\", \"DESede\" -> new KeyAndIv(cipherKey,\n+                    new IvParameterSpec(derive(passwdChars, salt, iCount, 8,\n+                            CIPHER_IV)));\n+                default ->\n+                    throw new ProviderException(\"Unsupported cipher impl: \"\n+                            + algo);\n+            };\n@@ -377,17 +326,4 @@\n-    void implInit(int opmode, Key key, AlgorithmParameters params,\n-                  SecureRandom random)\n-        throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        implInit(opmode, key, params, random, null);\n-    }\n-\n-    void implInit(int opmode, Key key, AlgorithmParameters params,\n-                  SecureRandom random, CipherSpi cipherImpl)\n-        throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        AlgorithmParameterSpec paramSpec = null;\n-        if (params != null) {\n-            try {\n-                paramSpec = params.getParameterSpec(PBEParameterSpec.class);\n-            } catch (InvalidParameterSpecException ipse) {\n-                throw new InvalidAlgorithmParameterException(\n-                    \"requires PBE parameters\");\n-            }\n+    private static final PBEParameterSpec toParamSpec(AlgorithmParameters ap)\n+            throws InvalidAlgorithmParameterException {\n+        if (ap == null) {\n+            return null;\n@@ -395,10 +331,0 @@\n-        implInit(opmode, key, paramSpec, random, cipherImpl);\n-    }\n-\n-    void implInit(int opmode, Key key, SecureRandom random)\n-        throws InvalidKeyException {\n-        implInit(opmode, key, random, null);\n-    }\n-\n-    void implInit(int opmode, Key key, SecureRandom random,\n-        CipherSpi cipherImpl) throws InvalidKeyException {\n@@ -406,4 +332,4 @@\n-            implInit(opmode, key, (AlgorithmParameterSpec) null, random,\n-                cipherImpl);\n-        } catch (InvalidAlgorithmParameterException iape) {\n-            throw new InvalidKeyException(\"requires PBE parameters\");\n+            return ap.getParameterSpec(PBEParameterSpec.class);\n+        } catch (InvalidParameterSpecException ipse) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"requires PBE parameters\");\n@@ -413,20 +339,0 @@\n-    byte[] implUpdate(byte[] in, int inOff, int inLen) {\n-        return cipher.update(in, inOff, inLen);\n-    }\n-\n-    int implUpdate(byte[] in, int inOff, int inLen, byte[] out, int outOff)\n-        throws ShortBufferException {\n-        return cipher.update(in, inOff, inLen, out, outOff);\n-    }\n-\n-    byte[] implDoFinal(byte[] in, int inOff, int inLen)\n-        throws IllegalBlockSizeException, BadPaddingException {\n-        return cipher.doFinal(in, inOff, inLen);\n-    }\n-\n-    int implDoFinal(byte[] in, int inOff, int inLen, byte[] out, int outOff)\n-        throws ShortBufferException, IllegalBlockSizeException,\n-               BadPaddingException {\n-        return cipher.doFinal(in, inOff, inLen, out, outOff);\n-    }\n-\n@@ -434,13 +340,1 @@\n-        return keyLength;\n-    }\n-\n-    byte[] implWrap(Key key) throws IllegalBlockSizeException,\n-        InvalidKeyException {\n-        return cipher.wrap(key);\n-    }\n-\n-    Key implUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm,\n-                   int wrappedKeyType)\n-        throws InvalidKeyException, NoSuchAlgorithmException {\n-        return cipher.unwrap(wrappedKey, wrappedKeyAlgorithm,\n-                             wrappedKeyType);\n+        return keySize << 3; \/\/ in bits\n@@ -449,1 +343,1 @@\n-    public static final class PBEWithSHA1AndDESede extends CipherSpi {\n+    public static final class PBEWithSHA1AndDESede extends DESedeCipher {\n@@ -451,0 +345,1 @@\n+\n@@ -452,17 +347,7 @@\n-            core = new PKCS12PBECipherCore(\"DESede\", 24);\n-        }\n-        protected byte[] engineDoFinal(byte[] in, int inOff, int inLen)\n-            throws IllegalBlockSizeException, BadPaddingException {\n-            return core.implDoFinal(in, inOff, inLen);\n-        }\n-        protected int engineDoFinal(byte[] in, int inOff, int inLen,\n-                                    byte[] out, int outOff)\n-            throws ShortBufferException, IllegalBlockSizeException,\n-                   BadPaddingException {\n-            return core.implDoFinal(in, inOff, inLen, out, outOff);\n-        }\n-        protected int engineGetBlockSize() {\n-            return core.implGetBlockSize();\n-        }\n-        protected byte[] engineGetIV() {\n-            return core.implGetIV();\n+            try {\n+                super.engineSetMode(\"CBC\");\n+                super.engineSetPadding(\"PKCS5Padding\");\n+            } catch (NoSuchPaddingException nspe) {\n+                \/\/ should never happen\n+            }\n+            core = new PKCS12PBECipherCore(\"DESede\", 192);\n@@ -470,0 +355,1 @@\n+        @Override\n@@ -471,4 +357,1 @@\n-            return core.implGetKeySize(key);\n-        }\n-        protected int engineGetOutputSize(int inLen) {\n-            return core.implGetOutputSize(inLen);\n+            return 112; \/\/ effective key size\n@@ -476,0 +359,1 @@\n+        @Override\n@@ -479,0 +363,1 @@\n+        @Override\n@@ -482,2 +367,4 @@\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random);\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            try (var derived = core.implInit(opmode, key, params, random)) {\n+                super.engineInit(opmode, derived.key(), derived.iv(), random);\n+            }\n@@ -485,0 +372,1 @@\n+        @Override\n@@ -488,2 +376,2 @@\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random);\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            engineInit(opmode, key, toParamSpec(params), random);\n@@ -491,0 +379,1 @@\n+        @Override\n@@ -492,2 +381,7 @@\n-            throws InvalidKeyException {\n-            core.implInit(opmode, key, random);\n+                throws InvalidKeyException {\n+            try {\n+                engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                \/\/ should never happen\n+            }\n+\n@@ -495,0 +389,1 @@\n+        @Override\n@@ -496,2 +391,4 @@\n-            throws NoSuchAlgorithmException {\n-            core.implSetMode(mode);\n+                throws NoSuchAlgorithmException {\n+            if (!\"CBC\".equalsIgnoreCase(mode)) {\n+                throw new NoSuchAlgorithmException(\"Unsupported mode: \" + mode);\n+            }\n@@ -499,0 +396,1 @@\n+        @Override\n@@ -500,21 +398,5 @@\n-            throws NoSuchPaddingException {\n-            core.implSetPadding(paddingScheme);\n-        }\n-        protected Key engineUnwrap(byte[] wrappedKey,\n-                                   String wrappedKeyAlgorithm,\n-                                   int wrappedKeyType)\n-            throws InvalidKeyException, NoSuchAlgorithmException {\n-            return core.implUnwrap(wrappedKey, wrappedKeyAlgorithm,\n-                                   wrappedKeyType);\n-        }\n-        protected byte[] engineUpdate(byte[] in, int inOff, int inLen) {\n-            return core.implUpdate(in, inOff, inLen);\n-        }\n-        protected int engineUpdate(byte[] in, int inOff, int inLen,\n-                                   byte[] out, int outOff)\n-            throws ShortBufferException {\n-            return core.implUpdate(in, inOff, inLen, out, outOff);\n-        }\n-        protected byte[] engineWrap(Key key)\n-            throws IllegalBlockSizeException, InvalidKeyException {\n-            return core.implWrap(key);\n+                throws NoSuchPaddingException {\n+            if (!\"PKCS5Padding\".equalsIgnoreCase(paddingScheme)) {\n+                throw new NoSuchPaddingException(\"Unsupported padding: \" +\n+                        paddingScheme);\n+            }\n@@ -524,1 +406,1 @@\n-    public static final class PBEWithSHA1AndRC2_40 extends CipherSpi {\n+    static sealed class PBEWithSHA1AndRC2 extends RC2Cipher {\n@@ -526,24 +408,9 @@\n-        public PBEWithSHA1AndRC2_40() throws NoSuchAlgorithmException {\n-            core = new PKCS12PBECipherCore(\"RC2\", 5);\n-        }\n-        protected byte[] engineDoFinal(byte[] in, int inOff, int inLen)\n-            throws IllegalBlockSizeException, BadPaddingException {\n-            return core.implDoFinal(in, inOff, inLen);\n-        }\n-        protected int engineDoFinal(byte[] in, int inOff, int inLen,\n-                                    byte[] out, int outOff)\n-            throws ShortBufferException, IllegalBlockSizeException,\n-                   BadPaddingException {\n-            return core.implDoFinal(in, inOff, inLen, out, outOff);\n-        }\n-        protected int engineGetBlockSize() {\n-            return core.implGetBlockSize();\n-        }\n-        protected byte[] engineGetIV() {\n-            return core.implGetIV();\n-        }\n-        protected int engineGetKeySize(Key key) throws InvalidKeyException {\n-            return core.implGetKeySize(key);\n-        }\n-        protected int engineGetOutputSize(int inLen) {\n-            return core.implGetOutputSize(inLen);\n+\n+        public PBEWithSHA1AndRC2(int keysize) throws NoSuchAlgorithmException {\n+            core = new PKCS12PBECipherCore(\"RC2\", keysize);\n+            try {\n+                super.engineSetMode(\"CBC\");\n+                super.engineSetPadding(\"PKCS5Padding\");\n+            } catch (NoSuchPaddingException nspe) {\n+                \/\/ should never happen\n+            }\n@@ -551,0 +418,1 @@\n+        @Override\n@@ -554,0 +422,1 @@\n+        @Override\n@@ -557,2 +426,4 @@\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random);\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            try (var derived = core.implInit(opmode, key, params, random)) {\n+                super.engineInit(opmode, derived.key(), derived.iv(), random);\n+            }\n@@ -560,0 +431,1 @@\n+        @Override\n@@ -563,2 +435,2 @@\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random);\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            engineInit(opmode, key, toParamSpec(params), random);\n@@ -566,0 +438,1 @@\n+        @Override\n@@ -567,2 +440,6 @@\n-            throws InvalidKeyException {\n-            core.implInit(opmode, key, random);\n+                throws InvalidKeyException {\n+            try {\n+                engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                \/\/ should never happen\n+            }\n@@ -570,0 +447,1 @@\n+        @Override\n@@ -571,2 +449,4 @@\n-            throws NoSuchAlgorithmException {\n-            core.implSetMode(mode);\n+                throws NoSuchAlgorithmException {\n+            if (!\"CBC\".equalsIgnoreCase(mode)) {\n+                throw new NoSuchAlgorithmException(\"Unsupported mode: \" + mode);\n+            }\n@@ -574,0 +454,1 @@\n+        @Override\n@@ -575,17 +456,5 @@\n-            throws NoSuchPaddingException {\n-            core.implSetPadding(paddingScheme);\n-        }\n-        protected Key engineUnwrap(byte[] wrappedKey,\n-                                   String wrappedKeyAlgorithm,\n-                                   int wrappedKeyType)\n-            throws InvalidKeyException, NoSuchAlgorithmException {\n-            return core.implUnwrap(wrappedKey, wrappedKeyAlgorithm,\n-                                   wrappedKeyType);\n-        }\n-        protected byte[] engineUpdate(byte[] in, int inOff, int inLen) {\n-            return core.implUpdate(in, inOff, inLen);\n-        }\n-        protected int engineUpdate(byte[] in, int inOff, int inLen,\n-                                   byte[] out, int outOff)\n-            throws ShortBufferException {\n-            return core.implUpdate(in, inOff, inLen, out, outOff);\n+                throws NoSuchPaddingException {\n+            if (!\"PKCS5Padding\".equalsIgnoreCase(paddingScheme)) {\n+                throw new NoSuchPaddingException(\"Unsupported padding: \" +\n+                        paddingScheme);\n+            }\n@@ -593,3 +462,5 @@\n-        protected byte[] engineWrap(Key key)\n-            throws IllegalBlockSizeException, InvalidKeyException {\n-            return core.implWrap(key);\n+    }\n+\n+    public static final class PBEWithSHA1AndRC2_40 extends PBEWithSHA1AndRC2 {\n+        public PBEWithSHA1AndRC2_40() throws NoSuchAlgorithmException {\n+            super(40);\n@@ -599,2 +470,1 @@\n-    public static final class PBEWithSHA1AndRC2_128 extends CipherSpi {\n-        private final PKCS12PBECipherCore core;\n+    public static final class PBEWithSHA1AndRC2_128 extends PBEWithSHA1AndRC2 {\n@@ -602,69 +472,1 @@\n-            core = new PKCS12PBECipherCore(\"RC2\", 16);\n-        }\n-        protected byte[] engineDoFinal(byte[] in, int inOff, int inLen)\n-            throws IllegalBlockSizeException, BadPaddingException {\n-            return core.implDoFinal(in, inOff, inLen);\n-        }\n-        protected int engineDoFinal(byte[] in, int inOff, int inLen,\n-                                    byte[] out, int outOff)\n-            throws ShortBufferException, IllegalBlockSizeException,\n-                   BadPaddingException {\n-            return core.implDoFinal(in, inOff, inLen, out, outOff);\n-        }\n-        protected int engineGetBlockSize() {\n-            return core.implGetBlockSize();\n-        }\n-        protected byte[] engineGetIV() {\n-            return core.implGetIV();\n-        }\n-        protected int engineGetKeySize(Key key) throws InvalidKeyException {\n-            return core.implGetKeySize(key);\n-        }\n-        protected int engineGetOutputSize(int inLen) {\n-            return core.implGetOutputSize(inLen);\n-        }\n-        protected AlgorithmParameters engineGetParameters() {\n-            return core.implGetParameters();\n-        }\n-        protected void engineInit(int opmode, Key key,\n-                                  AlgorithmParameterSpec params,\n-                                  SecureRandom random)\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random);\n-        }\n-        protected void engineInit(int opmode, Key key,\n-                                  AlgorithmParameters params,\n-                                  SecureRandom random)\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random);\n-        }\n-        protected void engineInit(int opmode, Key key, SecureRandom random)\n-            throws InvalidKeyException {\n-            core.implInit(opmode, key, random);\n-        }\n-        protected void engineSetMode(String mode)\n-            throws NoSuchAlgorithmException {\n-            core.implSetMode(mode);\n-        }\n-        protected void engineSetPadding(String paddingScheme)\n-            throws NoSuchPaddingException {\n-            core.implSetPadding(paddingScheme);\n-        }\n-        protected Key engineUnwrap(byte[] wrappedKey,\n-                                   String wrappedKeyAlgorithm,\n-                                   int wrappedKeyType)\n-            throws InvalidKeyException, NoSuchAlgorithmException {\n-            return core.implUnwrap(wrappedKey, wrappedKeyAlgorithm,\n-                                   wrappedKeyType);\n-        }\n-        protected byte[] engineUpdate(byte[] in, int inOff, int inLen) {\n-            return core.implUpdate(in, inOff, inLen);\n-        }\n-        protected int engineUpdate(byte[] in, int inOff, int inLen,\n-                                   byte[] out, int outOff)\n-            throws ShortBufferException {\n-            return core.implUpdate(in, inOff, inLen, out, outOff);\n-        }\n-        protected byte[] engineWrap(Key key)\n-            throws IllegalBlockSizeException, InvalidKeyException {\n-            return core.implWrap(key);\n+            super(128);\n@@ -674,2 +476,1 @@\n-    public static final class PBEWithSHA1AndRC4_40 extends CipherSpi {\n-        private static final int RC4_KEYSIZE = 5;\n+    static sealed class PBEWithSHA1AndRC4 extends ARCFOURCipher {\n@@ -677,1 +478,0 @@\n-        private final ARCFOURCipher cipher;\n@@ -679,19 +479,2 @@\n-        public PBEWithSHA1AndRC4_40() throws NoSuchAlgorithmException {\n-            core = new PKCS12PBECipherCore(\"RC4\", RC4_KEYSIZE);\n-            cipher = new ARCFOURCipher();\n-        }\n-        protected byte[] engineDoFinal(byte[] in, int inOff, int inLen)\n-            throws IllegalBlockSizeException, BadPaddingException {\n-            return cipher.engineDoFinal(in, inOff, inLen);\n-        }\n-        protected int engineDoFinal(byte[] in, int inOff, int inLen,\n-                                    byte[] out, int outOff)\n-            throws ShortBufferException, IllegalBlockSizeException,\n-                   BadPaddingException {\n-            return cipher.engineDoFinal(in, inOff, inLen, out, outOff);\n-        }\n-        protected int engineGetBlockSize() {\n-            return cipher.engineGetBlockSize();\n-        }\n-        protected byte[] engineGetIV() {\n-            return cipher.engineGetIV();\n+        public PBEWithSHA1AndRC4(int keysize) throws NoSuchAlgorithmException {\n+            core = new PKCS12PBECipherCore(\"RC4\", keysize);\n@@ -699,0 +482,1 @@\n+        @Override\n@@ -700,4 +484,1 @@\n-            return RC4_KEYSIZE;\n-        }\n-        protected int engineGetOutputSize(int inLen) {\n-            return cipher.engineGetOutputSize(inLen);\n+            return core.implGetKeySize(key);\n@@ -705,0 +486,1 @@\n+        @Override\n@@ -708,0 +490,1 @@\n+        @Override\n@@ -711,2 +494,4 @@\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random, cipher);\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            try (var derived = core.implInit(opmode, key, params, random)) {\n+                super.engineInit(opmode, derived.key(), derived.iv(), random);\n+            }\n@@ -714,0 +499,1 @@\n+        @Override\n@@ -717,2 +503,2 @@\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random, cipher);\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            engineInit(opmode, key, toParamSpec(params), random);\n@@ -720,0 +506,1 @@\n+        @Override\n@@ -721,2 +508,6 @@\n-            throws InvalidKeyException {\n-            core.implInit(opmode, key, random, cipher);\n+                throws InvalidKeyException {\n+            try {\n+                engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                \/\/ should never happen\n+            }\n@@ -724,0 +515,1 @@\n+        @Override\n@@ -725,3 +517,3 @@\n-            throws NoSuchAlgorithmException {\n-            if (mode.equalsIgnoreCase(\"ECB\") == false) {\n-                throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n+                throws NoSuchAlgorithmException {\n+            if (!\"ECB\".equalsIgnoreCase(mode)) {\n+                throw new NoSuchAlgorithmException(\"Unsupported mode: \" + mode);\n@@ -730,0 +522,1 @@\n+        @Override\n@@ -731,3 +524,4 @@\n-            throws NoSuchPaddingException {\n-            if (paddingScheme.equalsIgnoreCase(\"NoPadding\") == false) {\n-                throw new NoSuchPaddingException(\"Padding must be NoPadding\");\n+                throws NoSuchPaddingException {\n+            if (!\"NoPadding\".equalsIgnoreCase(paddingScheme)) {\n+                throw new NoSuchPaddingException(\"Unsupported padding: \" +\n+                        paddingScheme);\n@@ -736,19 +530,0 @@\n-        protected Key engineUnwrap(byte[] wrappedKey,\n-                                   String wrappedKeyAlgorithm,\n-                                   int wrappedKeyType)\n-            throws InvalidKeyException, NoSuchAlgorithmException {\n-            return cipher.engineUnwrap(wrappedKey, wrappedKeyAlgorithm,\n-                                   wrappedKeyType);\n-        }\n-        protected byte[] engineUpdate(byte[] in, int inOff, int inLen) {\n-            return cipher.engineUpdate(in, inOff, inLen);\n-        }\n-        protected int engineUpdate(byte[] in, int inOff, int inLen,\n-                                   byte[] out, int outOff)\n-            throws ShortBufferException {\n-            return cipher.engineUpdate(in, inOff, inLen, out, outOff);\n-        }\n-        protected byte[] engineWrap(Key key)\n-            throws IllegalBlockSizeException, InvalidKeyException {\n-            return cipher.engineWrap(key);\n-        }\n@@ -757,76 +532,3 @@\n-    public static final class PBEWithSHA1AndRC4_128 extends CipherSpi {\n-        private static final int RC4_KEYSIZE = 16;\n-        private final PKCS12PBECipherCore core;\n-        private final ARCFOURCipher cipher;\n-\n-        public PBEWithSHA1AndRC4_128() throws NoSuchAlgorithmException {\n-            core = new PKCS12PBECipherCore(\"RC4\", RC4_KEYSIZE);\n-            cipher = new ARCFOURCipher();\n-        }\n-        protected byte[] engineDoFinal(byte[] in, int inOff, int inLen)\n-            throws IllegalBlockSizeException, BadPaddingException {\n-            return cipher.engineDoFinal(in, inOff, inLen);\n-        }\n-        protected int engineDoFinal(byte[] in, int inOff, int inLen,\n-                                    byte[] out, int outOff)\n-            throws ShortBufferException, IllegalBlockSizeException,\n-                   BadPaddingException {\n-            return cipher.engineDoFinal(in, inOff, inLen, out, outOff);\n-        }\n-        protected int engineGetBlockSize() {\n-            return cipher.engineGetBlockSize();\n-        }\n-        protected byte[] engineGetIV() {\n-            return cipher.engineGetIV();\n-        }\n-        protected int engineGetKeySize(Key key) throws InvalidKeyException {\n-            return RC4_KEYSIZE;\n-        }\n-        protected int engineGetOutputSize(int inLen) {\n-            return cipher.engineGetOutputSize(inLen);\n-        }\n-        protected AlgorithmParameters engineGetParameters() {\n-            return core.implGetParameters();\n-        }\n-        protected void engineInit(int opmode, Key key,\n-                                  AlgorithmParameterSpec params,\n-                                  SecureRandom random)\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random, cipher);\n-        }\n-        protected void engineInit(int opmode, Key key,\n-                                  AlgorithmParameters params,\n-                                  SecureRandom random)\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            core.implInit(opmode, key, params, random, cipher);\n-        }\n-        protected void engineInit(int opmode, Key key, SecureRandom random)\n-            throws InvalidKeyException {\n-            core.implInit(opmode, key, random, cipher);\n-        }\n-        protected void engineSetMode(String mode)\n-            throws NoSuchAlgorithmException {\n-            if (mode.equalsIgnoreCase(\"ECB\") == false) {\n-                throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-            }\n-        }\n-        protected void engineSetPadding(String paddingScheme)\n-            throws NoSuchPaddingException {\n-            if (paddingScheme.equalsIgnoreCase(\"NoPadding\") == false) {\n-                throw new NoSuchPaddingException(\"Padding must be NoPadding\");\n-            }\n-        }\n-        protected Key engineUnwrap(byte[] wrappedKey,\n-                                   String wrappedKeyAlgorithm,\n-                                   int wrappedKeyType)\n-            throws InvalidKeyException, NoSuchAlgorithmException {\n-            return cipher.engineUnwrap(wrappedKey, wrappedKeyAlgorithm,\n-                                   wrappedKeyType);\n-        }\n-        protected byte[] engineUpdate(byte[] in, int inOff, int inLen) {\n-            return cipher.engineUpdate(in, inOff, inLen);\n-        }\n-        protected int engineUpdate(byte[] in, int inOff, int inLen,\n-                                   byte[] out, int outOff)\n-            throws ShortBufferException {\n-            return cipher.engineUpdate(in, inOff, inLen, out, outOff);\n+    public static final class PBEWithSHA1AndRC4_40 extends PBEWithSHA1AndRC4 {\n+        public PBEWithSHA1AndRC4_40() throws NoSuchAlgorithmException {\n+            super(40);\n@@ -834,3 +536,4 @@\n-        protected byte[] engineWrap(Key key)\n-            throws IllegalBlockSizeException, InvalidKeyException {\n-            return cipher.engineWrap(key);\n+    }\n+    public static final class PBEWithSHA1AndRC4_128 extends PBEWithSHA1AndRC4 {\n+        public PBEWithSHA1AndRC4_128() throws NoSuchAlgorithmException {\n+            super(128);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PKCS12PBECipherCore.java","additions":168,"deletions":465,"binary":false,"changes":633,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,2 @@\n-public final class RC2Cipher extends CipherSpi {\n+public sealed class RC2Cipher extends CipherSpi\n+        permits PKCS12PBECipherCore.PBEWithSHA1AndRC2 {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RC2Cipher.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4953553\n+ * @bug 4953553 8002277\n@@ -35,0 +35,1 @@\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -41,4 +42,22 @@\n-    public static void main(String argv[]) throws Exception {\n-        String algo = \"PBEWithMD5AndDES\";\n-        Cipher cipher = Cipher.getInstance(algo, \"SunJCE\");\n-        SecretKey key = new SecretKeySpec(new byte[5], algo);\n+    private static String[] PBES1ALGOS = {\n+        \"PBEWithMD5AndDES\",\n+        \"PBEWithSHA1AndDESede\",\n+        \"PBEWithSHA1AndRC2_40\",\n+        \"PBEWithSHA1AndRC2_128\",\n+        \"PBEWithSHA1AndRC4_40\",\n+        \"PBEWithSHA1AndRC4_128\",\n+    };\n+\n+    private static String[] PBES2ALGOS = {\n+        \"PBEWithHmacSHA1AndAES_128\",\n+        \"PBEWithHmacSHA224AndAES_128\",\n+        \"PBEWithHmacSHA256AndAES_128\",\n+        \"PBEWithHmacSHA384AndAES_128\",\n+        \"PBEWithHmacSHA512AndAES_128\",\n+    };\n+\n+    \/\/ return true if Cipher.init() fails with\n+    \/\/ InvalidAlgorithmParameterException\n+    private static boolean test(Cipher c, SecretKey key,\n+        AlgorithmParameterSpec spec) throws InvalidKeyException {\n+        System.out.println(\"Testing \" + c.getAlgorithm());\n@@ -46,5 +65,71 @@\n-            cipher.init(Cipher.DECRYPT_MODE, key);\n-            throw new Exception(\"Should throw InvalidKeyException when \" +\n-                                \"decrypting without parameters\");\n-        } catch (InvalidKeyException ike) {\n-            System.out.println(\"Test Passed: InvalidKeyException thrown\");\n+            c.init(Cipher.DECRYPT_MODE, key, spec);\n+            System.out.println(\"=> failed\");\n+            return false;\n+        } catch (InvalidAlgorithmParameterException e) {\n+            System.out.println(\"=> ok, got expected IAPE \" + e);\n+            return true;\n+        }\n+    }\n+\n+    static final class MyPBEKey implements PBEKey {\n+        private String algo;\n+        private PBEKeySpec spec;\n+\n+        MyPBEKey(String algo, PBEKeySpec spec) {\n+            this.algo = algo;\n+            this.spec = spec;\n+        }\n+        public int getIterationCount() {\n+            return spec.getIterationCount();\n+        }\n+        public char[] getPassword() {\n+            return spec.getPassword();\n+        }\n+        public byte[] getSalt() {\n+            return spec.getSalt();\n+        }\n+        public void destroy() {\n+            spec.clearPassword();\n+            spec = null;\n+        }\n+        public boolean isDestroyed() {\n+            return spec == null;\n+        }\n+        public String getAlgorithm() {\n+            return algo;\n+        }\n+        public byte[] getEncoded() {\n+            return new byte[5];\n+        }\n+        public String getFormat() {\n+            \/\/ not used\n+            return \"Proprietary\";\n+        }\n+    }\n+\n+    public static void main(String argv[]) throws Exception {\n+        boolean status = true;\n+\n+        for (String algo : PBES1ALGOS) {\n+            Cipher cipher = Cipher.getInstance(algo, \"SunJCE\");\n+            SecretKey key = new SecretKeySpec(new byte[5], algo);\n+            status = status && test(cipher, key, null);\n+        }\n+\n+        byte[] salt = \"atleast8bytes\".getBytes();\n+        int iterCount = 123456;\n+        PBEParameterSpec spec = new PBEParameterSpec(salt, iterCount);\n+        for (String algo : PBES2ALGOS) {\n+            Cipher cipher = Cipher.getInstance(algo, \"SunJCE\");\n+            SecretKey key = new SecretKeySpec(new byte[5], algo);\n+            PBEKey key2 = new MyPBEKey(algo,\n+                new PBEKeySpec(\"phrase\".toCharArray(), salt, iterCount));\n+            \/\/ null param\n+            status = status && test(cipher, key, null);\n+            status = status && test(cipher, key2, null);\n+            \/\/ param has salt and iterCount but missing iv\n+            status = status && test(cipher, key, spec);\n+            status = status && test(cipher, key2, spec);\n+        }\n+        if (!status) {\n+            throw new Exception(\"One or more test failed\");\n@@ -52,0 +137,1 @@\n+        System.out.println(\"All tests passed\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/PBE\/DecryptWithoutParameters.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"}]}