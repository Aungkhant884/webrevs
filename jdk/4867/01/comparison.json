{"files":[{"patch":"@@ -1785,0 +1785,4 @@\n+bool G1CollectedHeap::concurrent_mark_is_terminating() const {\n+  return _cm_thread->should_terminate();\n+}\n+\n@@ -3004,18 +3008,0 @@\n-bool G1CollectedHeap::determine_start_concurrent_mark_gc(){\n-  \/\/ We should not be doing concurrent start unless the concurrent mark thread is running\n-  if (!_cm_thread->should_terminate()) {\n-    \/\/ This call will decide whether this pause is a concurrent start\n-    \/\/ pause. If it is, in_concurrent_start_gc() will return true\n-    \/\/ for the duration of this pause.\n-    policy()->decide_on_conc_mark_initiation();\n-  }\n-\n-  \/\/ We do not allow concurrent start to be piggy-backed on a mixed GC.\n-  assert(!collector_state()->in_concurrent_start_gc() ||\n-         collector_state()->in_young_only_phase(), \"sanity\");\n-  \/\/ We also do not allow mixed GCs during marking.\n-  assert(!collector_state()->mark_or_rebuild_in_progress() || collector_state()->in_young_only_phase(), \"sanity\");\n-\n-  return collector_state()->in_concurrent_start_gc();\n-}\n-\n@@ -3058,0 +3044,1 @@\n+  policy()->decide_on_concurrent_start_pause();\n@@ -3061,1 +3048,1 @@\n-  bool should_start_concurrent_mark_operation = determine_start_concurrent_mark_gc();\n+  bool should_start_concurrent_mark_operation = collector_state()->in_concurrent_start_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -804,2 +804,0 @@\n-  bool determine_start_concurrent_mark_gc();\n-\n@@ -1007,0 +1005,3 @@\n+  \/\/ Returns whether concurrent mark threads (and the VM) are about to terminate.\n+  bool concurrent_mark_is_terminating() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1049,1 +1049,1 @@\n-void G1Policy::decide_on_conc_mark_initiation() {\n+void G1Policy::decide_on_concurrent_start_pause() {\n@@ -1059,0 +1059,6 @@\n+  \/\/ We should not be starting a concurrent start pause if the concurrent mark\n+  \/\/ thread is terminating.\n+  if (_g1h->concurrent_mark_is_terminating()) {\n+    return;\n+  }\n+\n@@ -1107,0 +1113,6 @@\n+  \/\/ Result consistency checks.\n+  \/\/ We do not allow concurrent start to be piggy-backed on a mixed GC.\n+  assert(!collector_state()->in_concurrent_start_gc() ||\n+         collector_state()->in_young_only_phase(), \"sanity\");\n+  \/\/ We also do not allow mixed GCs during marking.\n+  assert(!collector_state()->mark_or_rebuild_in_progress() || collector_state()->in_young_only_phase(), \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -376,7 +376,7 @@\n-  \/\/ This is called at the very beginning of an evacuation pause (it\n-  \/\/ has to be the first thing that the pause does). If\n-  \/\/ initiate_conc_mark_if_possible() is true, and the concurrent\n-  \/\/ marking thread has completed its work during the previous cycle,\n-  \/\/ it will set in_concurrent_start_gc() to so that the pause does\n-  \/\/ the concurrent start work and start a marking cycle.\n-  void decide_on_conc_mark_initiation();\n+  \/\/ Decide whether this garbage collection pause should be a concurrent start\n+  \/\/ pause and update the collector state accordingly.\n+  \/\/ We decide on a concurrent start pause if initiate_conc_mark_if_possible() is\n+  \/\/ true, the concurrent marking thread has completed its work for the previous\n+  \/\/ cycle, and we are not shutting down the VM.\n+  \/\/ This must be called at the very beginning of an evacuation pause.\n+  void decide_on_concurrent_start_pause();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  _terminating = g1h->_cm_thread->should_terminate();\n+  _terminating = g1h->concurrent_mark_is_terminating();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}