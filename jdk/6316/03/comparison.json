{"files":[{"patch":"@@ -114,1 +114,1 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n@@ -124,1 +124,1 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-  ShenandoahReentrantLocker data_locker(data != NULL ? data->lock() : NULL);\n@@ -279,0 +278,3 @@\n+    \/\/ Prevent updating a nmethod while concurrent iteration is in progress.\n+    wait_until_concurrent_iteration_done();\n+    ShenandoahReentrantLocker data_locker(data->lock());\n@@ -281,0 +283,2 @@\n+    \/\/ For a new nmethod, we can safely append it to the list, because\n+    \/\/ concurrent iteration will not touch it.\n@@ -385,0 +389,1 @@\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n@@ -390,0 +395,1 @@\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}