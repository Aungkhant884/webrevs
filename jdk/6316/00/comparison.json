{"files":[{"patch":"@@ -114,1 +114,1 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n@@ -119,1 +119,1 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n@@ -124,1 +124,1 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-  ShenandoahReentrantLocker data_locker(data != NULL ? data->lock() : NULL);\n@@ -279,0 +278,3 @@\n+    \/\/ Prevent updating a nmethod while concurrent iteration is in progress.\n+    wait_until_concurrent_iteration_done();\n+    ShenandoahReentrantLocker data_locker(data->lock());\n@@ -281,0 +283,2 @@\n+    \/\/ For a new nmethod, we can safely append it to the list, cause\n+    \/\/ concurrent iteration will not touch it.\n@@ -293,1 +297,1 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n@@ -385,0 +389,1 @@\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n@@ -390,0 +395,1 @@\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}