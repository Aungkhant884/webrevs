{"files":[{"patch":"@@ -2843,0 +2843,6 @@\n+  if (!VerifyBeforeGC) {\n+    return;\n+  }\n+  Ticks start = Ticks::now();\n+  _verifier->verify_region_sets_optional();\n+  _verifier->verify_dirty_young_regions();\n@@ -2851,0 +2857,1 @@\n+  phase_times()->record_verify_before_time_ms((Ticks::now() - start).seconds() * MILLIUNITS);\n@@ -2854,0 +2861,5 @@\n+  if (!VerifyAfterGC) {\n+    return;\n+  }\n+  Ticks start = Ticks::now();\n+  \/\/ Inject evacuation failure tag into type if needed.\n@@ -2865,0 +2877,2 @@\n+  _verifier->verify_region_sets_optional();\n+  phase_times()->record_verify_after_time_ms((Ticks::now() - start).seconds() * MILLIUNITS);\n@@ -2880,11 +2894,0 @@\n-void G1CollectedHeap::set_young_gc_name(char* young_gc_name) {\n-  G1GCPauseType pause_type =\n-    \/\/ The strings for all Concurrent Start pauses are the same, so the parameter\n-    \/\/ does not matter here.\n-    collector_state()->young_gc_pause_type(false \/* concurrent_operation_is_full_mark *\/);\n-  snprintf(young_gc_name,\n-           MaxYoungGCNameLength,\n-           \"Pause Young (%s)\",\n-           G1GCPauseTypeHelper::to_string(pause_type));\n-}\n-\n@@ -2918,0 +2921,34 @@\n+\/\/ GCTraceTime wrapper that constructs the message according to GC pause type and\n+\/\/ GC cause.\n+class G1YoungGCTraceTime {\n+  G1GCPauseType _pause_type;\n+\n+  static const uint MaxYoungGCNameLength = 128;\n+  char _young_gc_name_data[MaxYoungGCNameLength];\n+\n+  GCTraceTime(Info, gc) _tt;\n+\n+  char* update_young_gc_name() {\n+    snprintf(_young_gc_name_data,\n+             MaxYoungGCNameLength,\n+             \"Pause Young (%s)%s\",\n+             G1GCPauseTypeHelper::to_string(_pause_type),\n+             G1CollectedHeap::heap()->evacuation_failed() ? \" (Evacuation Failure)\" : \"\");\n+    return _young_gc_name_data;\n+  }\n+\n+public:\n+\n+  G1YoungGCTraceTime(GCCause::Cause cause) :\n+    \/\/ Take snapshot of current pause type at start as it may be modified during gc.\n+    \/\/ The strings for all Concurrent Start pauses are the same, so the parameter\n+    \/\/ does not matter here.\n+    _pause_type(G1CollectedHeap::heap()->collector_state()->young_gc_pause_type(false \/* concurrent_operation_is_full_mark *\/)),\n+    _tt(update_young_gc_name(), NULL, cause, true) {\n+  }\n+\n+  ~G1YoungGCTraceTime() {\n+    update_young_gc_name();\n+  }\n+};\n+\n@@ -2934,3 +2971,0 @@\n-  _verifier->verify_region_sets_optional();\n-  _verifier->verify_dirty_young_regions();\n-\n@@ -2963,4 +2997,1 @@\n-    char young_gc_name[MaxYoungGCNameLength];\n-    set_young_gc_name(young_gc_name);\n-\n-    GCTraceTime(Info, gc) tm(young_gc_name, NULL, gc_cause(), true);\n+    G1YoungGCTraceTime tm(gc_cause());\n@@ -3055,5 +3086,0 @@\n-    \/\/ Print the remainder of the GC log output.\n-    if (evacuation_failed()) {\n-      log_info(gc)(\"To-space exhausted\");\n-    }\n-\n@@ -3063,3 +3089,0 @@\n-    _hrm.verify_optional();\n-    _verifier->verify_region_sets_optional();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":49,"deletions":26,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -399,5 +399,0 @@\n-  static const uint MaxYoungGCNameLength = 128;\n-  \/\/ Sets given young_gc_name to the canonical young gc pause string. Young_gc_name\n-  \/\/ must be at least of length MaxYoungGCNameLength.\n-  void set_young_gc_name(char* young_gc_name);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -607,3 +607,1 @@\n-double G1HeapVerifier::verify(G1VerifyType type, VerifyOption vo, const char* msg) {\n-  double verify_time_ms = 0.0;\n-\n+void G1HeapVerifier::verify(G1VerifyType type, VerifyOption vo, const char* msg) {\n@@ -611,1 +609,0 @@\n-    double verify_start = os::elapsedTime();\n@@ -614,1 +611,0 @@\n-    verify_time_ms = (os::elapsedTime() - verify_start) * 1000;\n@@ -616,2 +612,0 @@\n-\n-  return verify_time_ms;\n@@ -621,4 +615,1 @@\n-  if (VerifyBeforeGC) {\n-    double verify_time_ms = verify(type, VerifyOption_G1UsePrevMarking, \"Before GC\");\n-    _g1h->phase_times()->record_verify_before_time_ms(verify_time_ms);\n-  }\n+  verify(type, VerifyOption_G1UsePrevMarking, \"Before GC\");\n@@ -628,4 +619,1 @@\n-  if (VerifyAfterGC) {\n-    double verify_time_ms = verify(type, VerifyOption_G1UsePrevMarking, \"After GC\");\n-    _g1h->phase_times()->record_verify_after_time_ms(verify_time_ms);\n-  }\n+  verify(type, VerifyOption_G1UsePrevMarking, \"After GC\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -82,1 +83,1 @@\n-  double verify(G1VerifyType type, VerifyOption vo, const char* msg);\n+  void verify(G1VerifyType type, VerifyOption vo, const char* msg);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test TestEvacuationFailure\n+ * @summary Ensure the output for a minor GC with G1 that has evacuation failure contains the correct strings.\n+ * @requires vm.gc.G1\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   gc.g1.TestEvacuationFailure\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestEvacuationFailure {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseG1GC\",\n+                                                                  \"-Xmx32M\",\n+                                                                  \"-Xmn16M\",\n+                                                                  \"-XX:+G1EvacuationFailureALot\",\n+                                                                  \"-XX:G1EvacuationFailureALotCount=100\",\n+                                                                  \"-XX:G1EvacuationFailureALotInterval=1\",\n+                                                                  \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                  \"-XX:-G1AllowPreventiveGC\",\n+                                                                  \"-Xlog:gc\",\n+                                                                  GCTestWithEvacuationFailure.class.getName());\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+        output.shouldContain(\"(Evacuation Failure)\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static class GCTestWithEvacuationFailure {\n+        private static byte[] garbage;\n+        private static byte[] largeObject;\n+        private static Object[] holder = new Object[200]; \/\/ Must be larger than G1EvacuationFailureALotCount\n+\n+        public static void main(String [] args) {\n+            largeObject = new byte[16*1024*1024];\n+            System.out.println(\"Creating garbage\");\n+            \/\/ Create 16 MB of garbage. This should result in at least one GC,\n+            \/\/ (Heap size is 32M, we use 17MB for the large object above)\n+            \/\/ which is larger than G1EvacuationFailureALotInterval.\n+            for (int i = 0; i < 16 * 1024; i++) {\n+                holder[i % holder.length] = new byte[1024];\n+            }\n+            System.out.println(\"Done\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEvacuationFailure.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -199,1 +199,1 @@\n-                .filter(line -> line.contains(\"space exhausted\"))\n+                .filter(line -> line.contains(\"(Evacuation Failure)\"))\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABEvacuationFailure.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}