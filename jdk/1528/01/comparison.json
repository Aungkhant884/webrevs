{"files":[{"patch":"@@ -107,1 +107,0 @@\n-  OptionType    _type;\n@@ -120,2 +119,1 @@\n-    _option(CompileCommand::Unknown),\n-    _type(OptionType::Unknown) {\n+    _option(CompileCommand::Unknown) {\n@@ -127,1 +125,1 @@\n-  TypedMethodOptionMatcher* match(const methodHandle &method, enum CompileCommand option, OptionType type);\n+  TypedMethodOptionMatcher* match(const methodHandle &method, enum CompileCommand option);\n@@ -129,1 +127,1 @@\n-  void init(enum CompileCommand option, OptionType type, TypedMethodOptionMatcher* next) {\n+  void init(enum CompileCommand option, TypedMethodOptionMatcher* next) {\n@@ -131,1 +129,0 @@\n-    _type = type;\n@@ -143,1 +140,0 @@\n-  OptionType type() { return _type; }\n@@ -197,2 +193,3 @@\n-  switch (_type) {\n-  case OptionType::Intx:\n+  enum OptionType type = option2type(_option);\n+  switch (type) {\n+    case OptionType::Intx:\n@@ -211,0 +208,1 @@\n+    case OptionType::Ccstrlist:\n@@ -247,1 +245,2 @@\n-  if (type() == OptionType::Ccstr) {\n+  enum OptionType type = option2type(_option);\n+  if (type == OptionType::Ccstr || type == OptionType::Ccstrlist) {\n@@ -266,1 +265,1 @@\n-TypedMethodOptionMatcher* TypedMethodOptionMatcher::match(const methodHandle& method, enum CompileCommand option, OptionType type) {\n+TypedMethodOptionMatcher* TypedMethodOptionMatcher::match(const methodHandle& method, enum CompileCommand option) {\n@@ -288,6 +287,3 @@\n-  enum OptionType type = option2type(option);\n-  if (type == OptionType::Ccstrlist) {\n-    type = OptionType::Ccstr; \/\/ ccstrlists are stores as ccstr\n-  }\n-  assert(type == get_type_for<T>(), \"sanity\");\n-  matcher->init(option, type, option_list);\n+  assert(CompilerOracle::option_matches_type(option, value), \"Value must match option type\");\n+\n+  matcher->init(option, option_list);\n@@ -311,1 +307,1 @@\n-bool CompilerOracle::has_option_value(const methodHandle& method, enum CompileCommand option, T& value, bool verify_type) {\n+bool CompilerOracle::has_option_value(const methodHandle& method, enum CompileCommand option, T& value) {\n@@ -316,13 +312,2 @@\n-  if (type == OptionType::Ccstrlist) {\n-    type = OptionType::Ccstr; \/\/ CCstrList type options are stored as Ccstr\n-  }\n-  if (verify_type) {\n-    if (type != get_type_for<T>()) {\n-      \/\/ Whitebox API expects false if option and type doesn't match\n-      return false;\n-    }\n-  } else {\n-    assert(type == get_type_for<T>(), \"Value type (%s) must match option %s (%s)\",\n-            optiontype2name(get_type_for<T>()),\n-           option2name(option), optiontype2name(option2type(option)));\n-  }\n+  assert(option_matches_type(option, value), \"Value must match option type\");\n+\n@@ -330,1 +315,1 @@\n-    TypedMethodOptionMatcher* m = option_list->match(method, option, type);\n+    TypedMethodOptionMatcher* m = option_list->match(method, option);\n@@ -364,5 +349,20 @@\n-template bool CompilerOracle::has_option_value<intx>(const methodHandle& method, enum CompileCommand option, intx& value, bool verify_type);\n-template bool CompilerOracle::has_option_value<uintx>(const methodHandle& method, enum CompileCommand option, uintx& value, bool verify_type);\n-template bool CompilerOracle::has_option_value<bool>(const methodHandle& method, enum CompileCommand option, bool& value, bool verify_type);\n-template bool CompilerOracle::has_option_value<ccstr>(const methodHandle& method, enum CompileCommand option, ccstr& value, bool verify_type);\n-template bool CompilerOracle::has_option_value<double>(const methodHandle& method, enum CompileCommand option, double& value, bool verify_type);\n+template bool CompilerOracle::has_option_value<intx>(const methodHandle& method, enum CompileCommand option, intx& value);\n+template bool CompilerOracle::has_option_value<uintx>(const methodHandle& method, enum CompileCommand option, uintx& value);\n+template bool CompilerOracle::has_option_value<bool>(const methodHandle& method, enum CompileCommand option, bool& value);\n+template bool CompilerOracle::has_option_value<ccstr>(const methodHandle& method, enum CompileCommand option, ccstr& value);\n+template bool CompilerOracle::has_option_value<double>(const methodHandle& method, enum CompileCommand option, double& value);\n+\n+template<typename T>\n+bool CompilerOracle::option_matches_type(enum CompileCommand option, T& value) {\n+  enum OptionType option_type = option2type(option);\n+  if (option_type == OptionType::Ccstrlist) {\n+    option_type = OptionType::Ccstr; \/\/ CCstrList type options are stored as Ccstr\n+  }\n+  return (get_type_for<T>() == option_type);\n+}\n+\n+template bool CompilerOracle::option_matches_type<intx>(enum CompileCommand option, intx& value);\n+template bool CompilerOracle::option_matches_type<uintx>(enum CompileCommand option, uintx& value);\n+template bool CompilerOracle::option_matches_type<bool>(enum CompileCommand option, bool& value);\n+template bool CompilerOracle::option_matches_type<ccstr>(enum CompileCommand option, ccstr& value);\n+template bool CompilerOracle::option_matches_type<double>(enum CompileCommand option, double& value);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -152,1 +152,5 @@\n-  static bool has_option_value(const methodHandle& method, enum CompileCommand option, T& value, bool verfiy_type = false);\n+  static bool has_option_value(const methodHandle& method, enum CompileCommand option, T& value);\n+\n+  \/\/ This check is currently only needed by whitebox API\n+  template<typename T>\n+  static bool option_matches_type(enum CompileCommand option, T& value);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1817,1 +1817,4 @@\n-  return CompilerOracle::has_option_value(mh, option, *value, true \/* verify type*\/);\n+  if (!CompilerOracle::option_matches_type(option, *value)) {\n+    return false;\n+  }\n+  return CompilerOracle::has_option_value(mh, option, *value);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}