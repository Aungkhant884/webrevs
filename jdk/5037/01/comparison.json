{"files":[{"patch":"@@ -3822,1 +3822,1 @@\n-  post_evacuate_cleanup_1(per_thread_states, rdcqs);\n+  post_evacuate_cleanup_1(per_thread_states);\n@@ -3909,2 +3909,1 @@\n-void G1CollectedHeap::post_evacuate_cleanup_1(G1ParScanThreadStateSet* per_thread_states,\n-                                              G1RedirtyCardsQueueSet* rdcqs) {\n+void G1CollectedHeap::post_evacuate_cleanup_1(G1ParScanThreadStateSet* per_thread_states) {\n@@ -3913,1 +3912,1 @@\n-    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states, rdcqs);\n+    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states);\n@@ -4191,0 +4190,1 @@\n+      register_new_survivor_region_with_region_attr(new_alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -633,0 +633,1 @@\n+  inline void register_new_survivor_region_with_region_attr(HeapRegion* r);\n@@ -860,2 +861,1 @@\n-  void post_evacuate_cleanup_1(G1ParScanThreadStateSet* per_thread_states,\n-                               G1RedirtyCardsQueueSet* rdcqs);\n+  void post_evacuate_cleanup_1(G1ParScanThreadStateSet* per_thread_states);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,0 +181,4 @@\n+void G1CollectedHeap::register_new_survivor_region_with_region_attr(HeapRegion* r) {\n+  _region_attr.set_new_survivor_region(r->hrm_index());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1RedirtyCardsQueue.hpp\"\n@@ -40,39 +39,0 @@\n-class UpdateLogBuffersDeferred : public BasicOopIterateClosure {\n-private:\n-  G1CollectedHeap* _g1h;\n-  G1RedirtyCardsLocalQueueSet* _rdc_local_qset;\n-  G1CardTable*    _ct;\n-\n-  \/\/ Remember the last enqueued card to avoid enqueuing the same card over and over;\n-  \/\/ since we only ever handle a card once, this is sufficient.\n-  size_t _last_enqueued_card;\n-\n-public:\n-  UpdateLogBuffersDeferred(G1RedirtyCardsLocalQueueSet* rdc_local_qset) :\n-    _g1h(G1CollectedHeap::heap()),\n-    _rdc_local_qset(rdc_local_qset),\n-    _ct(_g1h->card_table()),\n-    _last_enqueued_card(SIZE_MAX) {}\n-\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(      oop* p) { do_oop_work(p); }\n-  template <class T> void do_oop_work(T* p) {\n-    assert(_g1h->heap_region_containing(p)->is_in_reserved(p), \"paranoia\");\n-    assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Unexpected evac failure in survivor region\");\n-\n-    T const o = RawAccess<>::oop_load(p);\n-    if (CompressedOops::is_null(o)) {\n-      return;\n-    }\n-\n-    if (HeapRegion::is_in_same_region(p, CompressedOops::decode(o))) {\n-      return;\n-    }\n-    size_t card_index = _ct->index_for(p);\n-    if (card_index != _last_enqueued_card) {\n-      _rdc_local_qset->enqueue(_ct->byte_for_index(card_index));\n-      _last_enqueued_card = card_index;\n-    }\n-  }\n-};\n-\n@@ -85,1 +45,0 @@\n-  UpdateLogBuffersDeferred* _log_buffer_cl;\n@@ -92,1 +51,0 @@\n-                                 UpdateLogBuffersDeferred* log_buffer_cl,\n@@ -100,1 +58,0 @@\n-    _log_buffer_cl(log_buffer_cl),\n@@ -145,9 +102,0 @@\n-      \/\/ During evacuation failure we do not record inter-region\n-      \/\/ references referencing regions that need a remembered set\n-      \/\/ update originating from young regions (including eden) that\n-      \/\/ failed evacuation. Make up for that omission now by rescanning\n-      \/\/ these failed objects.\n-      if (_is_young) {\n-        obj->oop_iterate(_log_buffer_cl);\n-      }\n-\n@@ -202,3 +150,0 @@\n-  G1RedirtyCardsLocalQueueSet _rdc_local_qset;\n-  UpdateLogBuffersDeferred _log_buffer_cl;\n-\n@@ -208,1 +153,1 @@\n-  RemoveSelfForwardPtrHRClosure(G1RedirtyCardsQueueSet* rdcqs, uint worker_id, uint volatile* num_failed_regions) :\n+  RemoveSelfForwardPtrHRClosure(uint worker_id, uint volatile* num_failed_regions) :\n@@ -211,2 +156,0 @@\n-    _rdc_local_qset(rdcqs),\n-    _log_buffer_cl(&_rdc_local_qset),\n@@ -216,4 +159,0 @@\n-  ~RemoveSelfForwardPtrHRClosure() {\n-    _rdc_local_qset.flush();\n-  }\n-\n@@ -223,1 +162,0 @@\n-                                        &_log_buffer_cl,\n@@ -262,1 +200,1 @@\n-G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs) :\n+G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask() :\n@@ -265,1 +203,0 @@\n-  _rdcqs(rdcqs),\n@@ -270,1 +207,1 @@\n-  RemoveSelfForwardPtrHRClosure rsfp_cl(_rdcqs, worker_id, &_num_failed_regions);\n+  RemoveSelfForwardPtrHRClosure rsfp_cl(worker_id, &_num_failed_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":3,"deletions":66,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-class G1RedirtyCardsQueueSet;\n@@ -41,1 +40,0 @@\n-  G1RedirtyCardsQueueSet* _rdcqs;\n@@ -47,1 +45,1 @@\n-  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs);\n+  G1ParRemoveSelfForwardPtrsTask();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,2 +58,3 @@\n-  static const region_type_t Optional     =  -3;    \/\/ The region is optional not in the current collection set.\n-  static const region_type_t Humongous    =  -2;    \/\/ The region is a humongous candidate not in the current collection set.\n+  static const region_type_t Optional     =  -4;    \/\/ The region is optional not in the current collection set.\n+  static const region_type_t Humongous    =  -3;    \/\/ The region is a humongous candidate not in the current collection set.\n+  static const region_type_t NewSurvivor  =  -2;    \/\/ The region is a new (ly allocated) survivor region.\n@@ -77,0 +78,1 @@\n+      case NewSurvivor: return \"NewSurvivor\";\n@@ -86,0 +88,1 @@\n+  void set_new_survivor()              { _type = NewSurvivor; }\n@@ -97,0 +100,1 @@\n+  bool is_new_survivor() const         { return type() == NewSurvivor; }\n@@ -129,0 +133,6 @@\n+  void set_new_survivor_region(uintptr_t index) {\n+    assert(get_by_index(index).is_default(),\n+           \"Region attributes at index \" INTPTR_FORMAT \" should be default but is %s\", index, get_by_index(index).get_type_str());\n+    get_ref_by_index(index)->set_new_survivor();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  friend class G1ScanInYoungSetter;\n+  friend class G1SkipCardEnqueueSetter;\n@@ -90,1 +90,1 @@\n-  enum ScanningInYoungValues {\n+  enum SkipCardEnqueueTristate {\n@@ -96,1 +96,1 @@\n-  ScanningInYoungValues _scanning_in_young;\n+  SkipCardEnqueueTristate _skip_card_enqueue;\n@@ -100,1 +100,1 @@\n-    G1ScanClosureBase(g1h, par_scan_state), _scanning_in_young(Uninitialized) { }\n+    G1ScanClosureBase(g1h, par_scan_state), _skip_card_enqueue(Uninitialized) { }\n@@ -114,2 +114,1 @@\n-\/\/ RAII object to properly set the _scanning_in_young field in G1ScanEvacuatedObjClosure.\n-class G1ScanInYoungSetter : public StackObj {\n+class G1SkipCardEnqueueSetter : public StackObj {\n@@ -119,3 +118,3 @@\n-  G1ScanInYoungSetter(G1ScanEvacuatedObjClosure* closure, bool new_value) : _closure(closure) {\n-    assert(_closure->_scanning_in_young == G1ScanEvacuatedObjClosure::Uninitialized, \"Must not be set\");\n-    _closure->_scanning_in_young = new_value ? G1ScanEvacuatedObjClosure::True : G1ScanEvacuatedObjClosure::False;\n+  G1SkipCardEnqueueSetter(G1ScanEvacuatedObjClosure* closure, bool skip_card_enqueue) : _closure(closure) {\n+    assert(_closure->_skip_card_enqueue == G1ScanEvacuatedObjClosure::Uninitialized, \"Must not be set\");\n+    _closure->_skip_card_enqueue = skip_card_enqueue ? G1ScanEvacuatedObjClosure::True : G1ScanEvacuatedObjClosure::False;\n@@ -124,2 +123,2 @@\n-  ~G1ScanInYoungSetter() {\n-    DEBUG_ONLY(_closure->_scanning_in_young = G1ScanEvacuatedObjClosure::Uninitialized;)\n+  ~G1SkipCardEnqueueSetter() {\n+    DEBUG_ONLY(_closure->_skip_card_enqueue = G1ScanEvacuatedObjClosure::Uninitialized;)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-\n+  assert(!_g1h->heap_region_containing(obj)->is_humongous(), \"trying to push humongous object \" PTR_FORMAT, p2i(obj));\n@@ -91,2 +91,2 @@\n-    assert(_scanning_in_young != Uninitialized, \"Scan location has not been initialized.\");\n-    if (_scanning_in_young == True) {\n+    assert(_skip_card_enqueue != Uninitialized, \"Scan location has not been initialized.\");\n+    if (_skip_card_enqueue == True) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -210,3 +210,12 @@\n-  HeapRegion* from = _g1h->heap_region_containing(p);\n-  if (!from->is_young()) {\n-    enqueue_card_if_tracked(_g1h->region_attr(obj), p, obj);\n+  G1HeapRegionAttr from_attr = _g1h->region_attr(p);\n+  \/\/ If this is a reference from (current) survivor regions, we do not need\n+  \/\/ to track references from it.\n+  if (from_attr.is_new_survivor()) {\n+    return;\n+  }\n+  G1HeapRegionAttr dest_attr = _g1h->region_attr(obj);\n+  \/\/ References to the current collection set are references to objects that failed\n+  \/\/ evacuation. Currently these regions are always relabelled as old without\n+  \/\/ remembered sets, so skip them.\n+  if (!dest_attr.is_in_cset()) {\n+    enqueue_card_if_tracked(dest_attr, p, obj);\n@@ -237,2 +246,2 @@\n-  HeapRegion* hr = _g1h->heap_region_containing(to_array);\n-  G1ScanInYoungSetter x(&_scanner, hr->is_young());\n+  G1HeapRegionAttr dest_attr = _g1h->region_attr(to_array);\n+  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_new_survivor());\n@@ -270,1 +279,6 @@\n-  G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n+  \/\/ Same reason to use dest_attr.is_young() here as for the successfully evacuated\n+  \/\/ regular object case. Is_survivor() may not have been set, but to_array must\n+  \/\/ be in a Survivor region (if dest_attr.is_young()) or Old here.\n+  \/\/ Assert this here as it is not immediately obvious.\n+  assert(!dest_attr.is_young() || _g1h->heap_region_containing(to_array)->is_survivor(), \"must be\");\n+  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n@@ -524,1 +538,9 @@\n-    G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n+    \/\/ If dest_attr still refers to Young at this point, this object must be\n+    \/\/ in a survivor region (evacuation succeeded), so we can use this for the\n+    \/\/ G1SkipCardEnqueueSetter instead of re-evaluating the G1HeapRegionAttr of\n+    \/\/ obj (dest_attr here is used to select the allocation generation, and this\n+    \/\/ is either \"Young\" or \"Old\").\n+    \/\/ The region of \"obj\" is the source region for this iteration.\n+    \/\/ Assert this here although almost obvious.\n+    assert(!dest_attr.is_young() || _g1h->heap_region_containing(obj)->is_survivor(), \"must be\");\n+    G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n@@ -614,1 +636,8 @@\n-    G1ScanInYoungSetter x(&_scanner, r->is_young());\n+    \/\/ For iterating objects that failed evacuation currently we can reuse the\n+    \/\/ existing closure to scan evacuated objects because:\n+    \/\/ - for objects into the collection set we do not need to gather cards at this\n+    \/\/ time. The regions they are in will be unconditionally turned to old regions\n+    \/\/ without remembered sets.\n+    \/\/ - since we are iterating from a collection set region (i.e. never a Survivor\n+    \/\/ region), we always need to gather cards for this case.\n+    G1SkipCardEnqueueSetter x(&_scanner, false \/* skip_enqueue_cards *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -133,1 +133,4 @@\n-    assert(!_g1h->heap_region_containing(p)->is_young(), \"Should have filtered out from-young references already.\");\n+    assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Should have filtered out from-survivor references already.\");\n+    \/\/ We relabel all regions that failed evacuation as old gen without remembered,\n+    \/\/ and so pre-filter them out in the caller.\n+    assert(!_g1h->heap_region_containing(o)->in_collection_set(), \"Should not try to enqueue reference into collection set region\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n-                                                                                 G1RedirtyCardsQueueSet* rdcqs) :\n+G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states) :\n@@ -50,1 +49,1 @@\n-    add_parallel_task(new RemoveSelfForwardPtrsTask(rdcqs));\n+    add_parallel_task(new RemoveSelfForwardPtrsTask());\n@@ -102,2 +101,2 @@\n-G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs) :\n-  G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr), _task(rdcqs) { }\n+G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask() :\n+  G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr), _task() { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class G1RedirtyCardsQueueSet;\n@@ -51,2 +50,1 @@\n-  G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n-                                          G1RedirtyCardsQueueSet* rdcqs);\n+  G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states);\n@@ -87,1 +85,1 @@\n-  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs);\n+  RemoveSelfForwardPtrsTask();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}