{"files":[{"patch":"@@ -653,3 +653,0 @@\n-#ifdef ASSERT\n-                  , _type_verif_cache(comp_arena(), 2, 0, VerifyMeetResult())\n-#endif\n@@ -928,5 +925,1 @@\n-    _allowed_reasons(0)\n-#ifdef ASSERT\n-  , _type_verif_cache(comp_arena(), 2, 0, VerifyMeetResult())\n-#endif\n-    {\n+    _allowed_reasons(0) {\n@@ -1084,1 +1077,1 @@\n-  _type_depth = 0;\n+  _type_verify = NULL;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+class VerifyMeetResult;\n@@ -1218,41 +1219,1 @@\n-  class VerifyMeetResult {\n-  private:\n-    const Type* _in1;\n-    const Type* _in2;\n-    const Type* _res;\n-  public:\n-    VerifyMeetResult(const Type* in1, const Type* in2, const Type* res):\n-    _in1(in1), _in2(in2), _res(res) {\n-    }\n-    VerifyMeetResult():\n-    _in1(NULL), _in2(NULL), _res(NULL) {\n-    }\n-\n-    bool operator==(const VerifyMeetResult& rhs) const {\n-      return _in1 == rhs._in1 &&\n-             _in2 == rhs._in2 &&\n-             _res == rhs._res;\n-    }\n-\n-    bool operator!=(const VerifyMeetResult& rhs) const {\n-      return !(rhs == *this);\n-    }\n-\n-    static int compare(const VerifyMeetResult& v1, const VerifyMeetResult& v2) {\n-      if ((intptr_t) v1._in1 < (intptr_t) v2._in1) {\n-        return -1;\n-      } else if (v1._in1 == v2._in1) {\n-        if ((intptr_t) v1._in2 < (intptr_t) v2._in2) {\n-          return -1;\n-        } else if (v1._in2 == v2._in2) {\n-          assert(v1._res == v2._res || v1._res == NULL || v2._res == NULL, \"same inputs should lead to same result\");\n-          return 0;\n-        }\n-        return 1;\n-      }\n-      return 1;\n-    }\n-    const Type* res() const { return _res; }\n-  };\n-  uint _type_depth;\n-  GrowableArray<VerifyMeetResult> _type_verif_cache;\n+  VerifyMeetResult* _type_verify;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":41,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -790,38 +790,16 @@\n-\/\/ With verification code, the meet of A and B causes the computation of:\n-\/\/ 1- meet(A, B)\n-\/\/ 2- meet(B, A)\n-\/\/ 3- meet(dual(meet(A, B)), dual(A))\n-\/\/ 4- meet(dual(meet(A, B)), dual(B))\n-\/\/ 5- meet(dual(A), dual(B))\n-\/\/ 6- meet(dual(B), dual(A))\n-\/\/ 7- meet(dual(meet(dual(A), dual(B))), A)\n-\/\/ 8- meet(dual(meet(dual(A), dual(B))), B)\n-\/\/\n-\/\/ In addition the meet of A[] and B[] requires the computation of the meet of A and B.\n-\/\/\n-\/\/ The meet of A[] and B[] triggers the computation of:\n-\/\/ 1- meet(A[], B[][)\n-\/\/   1.1- meet(A, B)\n-\/\/   1.2- meet(B, A)\n-\/\/   1.3- meet(dual(meet(A, B)), dual(A))\n-\/\/   1.4- meet(dual(meet(A, B)), dual(B))\n-\/\/   1.5- meet(dual(A), dual(B))\n-\/\/   1.6- meet(dual(B), dual(A))\n-\/\/   1.7- meet(dual(meet(dual(A), dual(B))), A)\n-\/\/   1.8- meet(dual(meet(dual(A), dual(B))), B)\n-\/\/ 2- meet(B[], A[])\n-\/\/   2.1- meet(B, A) = 1.2\n-\/\/   2.2- meet(A, B) = 1.1\n-\/\/   2.3- meet(dual(meet(B, A)), dual(B)) = 1.4\n-\/\/   2.4- meet(dual(meet(B, A)), dual(A)) = 1.3\n-\/\/   2.5- meet(dual(B), dual(A)) = 1.6\n-\/\/   2.6- meet(dual(A), dual(B)) = 1.5\n-\/\/   2.7- meet(dual(meet(dual(B), dual(A))), B) = 1.8\n-\/\/   2.8- meet(dual(meet(dual(B), dual(A))), B) = 1.7\n-\/\/ etc.\n-\/\/ The number of meet operations performed grows exponentially with the number of dimensions of the arrays but the number\n-\/\/ of different meet operations is linear in the number of dimensions. The function below caches meet results for the\n-\/\/ duration of the meet at the root of the recursive calls.\n-\/\/\n-static const Type* debug_meet(const Type* t1, const Type* t2) {\n-  Compile* C = Compile::current();\n+class VerifyMeetMark;\n+class VerifyMeetResult : public ArenaObj {\n+  friend class VerifyMeetMark;\n+private:\n+  class VerifyMeetResultEntry {\n+  private:\n+    const Type* _in1;\n+    const Type* _in2;\n+    const Type* _res;\n+  public:\n+    VerifyMeetResultEntry(const Type* in1, const Type* in2, const Type* res):\n+            _in1(in1), _in2(in2), _res(res) {\n+    }\n+    VerifyMeetResultEntry():\n+            _in1(NULL), _in2(NULL), _res(NULL) {\n+    }\n@@ -829,12 +807,92 @@\n-  bool found = false;\n-  const Compile::VerifyMeetResult meet(t1, t2, NULL);\n-  int pos = C->_type_verif_cache.find_sorted<Compile::VerifyMeetResult, Compile::VerifyMeetResult::compare>(meet, found);\n-  const Type* res = NULL;\n-  if (found) {\n-    res = C->_type_verif_cache.at(pos).res();\n-  } else {\n-    res = t1->xmeet(t2);\n-    C->_type_verif_cache.insert_sorted<Compile::VerifyMeetResult::compare>(Compile::VerifyMeetResult(t1, t2, res));\n-    found = false;\n-    C->_type_verif_cache.find_sorted<Compile::VerifyMeetResult, Compile::VerifyMeetResult::compare>(meet, found);\n-    assert(found, \"should be in table after it's added\");\n+    bool operator==(const VerifyMeetResultEntry& rhs) const {\n+      return _in1 == rhs._in1 &&\n+             _in2 == rhs._in2 &&\n+             _res == rhs._res;\n+    }\n+\n+    bool operator!=(const VerifyMeetResultEntry& rhs) const {\n+      return !(rhs == *this);\n+    }\n+\n+    static int compare(const VerifyMeetResultEntry& v1, const VerifyMeetResultEntry& v2) {\n+      if ((intptr_t) v1._in1 < (intptr_t) v2._in1) {\n+        return -1;\n+      } else if (v1._in1 == v2._in1) {\n+        if ((intptr_t) v1._in2 < (intptr_t) v2._in2) {\n+          return -1;\n+        } else if (v1._in2 == v2._in2) {\n+          assert(v1._res == v2._res || v1._res == NULL || v2._res == NULL, \"same inputs should lead to same result\");\n+          return 0;\n+        }\n+        return 1;\n+      }\n+      return 1;\n+    }\n+    const Type* res() const { return _res; }\n+  };\n+  uint _depth;\n+  GrowableArray<VerifyMeetResultEntry> _cache;\n+public:\n+  VerifyMeetResult(Compile* C) :\n+          _depth(0), _cache(C->comp_arena(), 2, 0, VerifyMeetResultEntry()) {\n+  }\n+\n+  \/\/ With verification code, the meet of A and B causes the computation of:\n+  \/\/ 1- meet(A, B)\n+  \/\/ 2- meet(B, A)\n+  \/\/ 3- meet(dual(meet(A, B)), dual(A))\n+  \/\/ 4- meet(dual(meet(A, B)), dual(B))\n+  \/\/ 5- meet(dual(A), dual(B))\n+  \/\/ 6- meet(dual(B), dual(A))\n+  \/\/ 7- meet(dual(meet(dual(A), dual(B))), A)\n+  \/\/ 8- meet(dual(meet(dual(A), dual(B))), B)\n+  \/\/\n+  \/\/ In addition the meet of A[] and B[] requires the computation of the meet of A and B.\n+  \/\/\n+  \/\/ The meet of A[] and B[] triggers the computation of:\n+  \/\/ 1- meet(A[], B[][)\n+  \/\/   1.1- meet(A, B)\n+  \/\/   1.2- meet(B, A)\n+  \/\/   1.3- meet(dual(meet(A, B)), dual(A))\n+  \/\/   1.4- meet(dual(meet(A, B)), dual(B))\n+  \/\/   1.5- meet(dual(A), dual(B))\n+  \/\/   1.6- meet(dual(B), dual(A))\n+  \/\/   1.7- meet(dual(meet(dual(A), dual(B))), A)\n+  \/\/   1.8- meet(dual(meet(dual(A), dual(B))), B)\n+  \/\/ 2- meet(B[], A[])\n+  \/\/   2.1- meet(B, A) = 1.2\n+  \/\/   2.2- meet(A, B) = 1.1\n+  \/\/   2.3- meet(dual(meet(B, A)), dual(B)) = 1.4\n+  \/\/   2.4- meet(dual(meet(B, A)), dual(A)) = 1.3\n+  \/\/   2.5- meet(dual(B), dual(A)) = 1.6\n+  \/\/   2.6- meet(dual(A), dual(B)) = 1.5\n+  \/\/   2.7- meet(dual(meet(dual(B), dual(A))), B) = 1.8\n+  \/\/   2.8- meet(dual(meet(dual(B), dual(A))), B) = 1.7\n+  \/\/ etc.\n+  \/\/ The number of meet operations performed grows exponentially with the number of dimensions of the arrays but the number\n+  \/\/ of different meet operations is linear in the number of dimensions. The function below caches meet results for the\n+  \/\/ duration of the meet at the root of the recursive calls.\n+  \/\/\n+  const Type* meet(const Type* t1, const Type* t2) {\n+    bool found = false;\n+    const VerifyMeetResultEntry meet(t1, t2, NULL);\n+    int pos = _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+    const Type* res = NULL;\n+    if (found) {\n+      res = _cache.at(pos).res();\n+    } else {\n+      res = t1->xmeet(t2);\n+      _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+      found = false;\n+      _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+      assert(found, \"should be in table after it's added\");\n+    }\n+    return res;\n+  }\n+\n+  void add(const Type* t1, const Type* t2, const Type* res) {\n+    _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+  }\n+\n+  bool empty_cache() const {\n+    return _cache.length() == 0;\n@@ -842,1 +900,4 @@\n-  return res;\n+};\n+\n+void Type::assert_type_verify_empty() const {\n+  assert(Compile::current()->_type_verify == NULL || Compile::current()->_type_verify->empty_cache(), \"cache should have been discarded\");\n@@ -845,1 +906,1 @@\n-class TypeVerif {\n+class VerifyMeetMark {\n@@ -849,2 +910,5 @@\n-  TypeVerif(Compile* C) : _C(C) {\n-    _C->_type_depth++;\n+  VerifyMeetMark(Compile* C) : _C(C) {\n+    if (C->_type_verify == NULL) {\n+      C->_type_verify = new (C->comp_arena())VerifyMeetResult(C);\n+    }\n+    _C->_type_verify->_depth++;\n@@ -853,5 +917,5 @@\n-  ~TypeVerif() {\n-    assert(_C->_type_depth != 0, \"\");\n-    _C->_type_depth--;\n-    if (_C->_type_depth == 0) {\n-      _C->_type_verif_cache.trunc_to(0);\n+  ~VerifyMeetMark() {\n+    assert(_C->_type_verify->_depth != 0, \"\");\n+    _C->_type_verify->_depth--;\n+    if (_C->_type_verify->_depth == 0) {\n+      _C->_type_verify->_cache.trunc_to(0);\n@@ -861,1 +925,0 @@\n-\n@@ -866,1 +929,3 @@\n-  const Type* mt2 = debug_meet(t, this);\n+  Compile* C = Compile::current();\n+  VerifyMeetResult* type_verify = C->_type_verify;\n+  const Type* mt2 = type_verify->meet(t, this);\n@@ -876,2 +941,2 @@\n-  const Type* t2t    = debug_meet(dual_join,t->_dual);\n-  const Type* t2this = debug_meet(dual_join,this->_dual);\n+  const Type* t2t    = type_verify->meet(dual_join,t->_dual);\n+  const Type* t2this = type_verify->meet(dual_join,this->_dual);\n@@ -916,1 +981,1 @@\n-  TypeVerif verif(C);\n+  VerifyMeetMark verif(C);\n@@ -924,1 +989,2 @@\n-  C->_type_verif_cache.insert_sorted<Compile::VerifyMeetResult::compare>(Compile::VerifyMeetResult(this_t, t, mt));\n+  VerifyMeetResult* type_verify = C->_type_verify;\n+  type_verify->add(this_t, t, mt);\n@@ -932,1 +998,1 @@\n-  const Type *mt_dual = debug_meet(this_t->_dual,t->_dual);\n+  const Type *mt_dual = type_verify->meet(this_t->_dual, t->_dual);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":132,"deletions":66,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-    assert(Compile::current()->_type_verif_cache.length() == 0, \"cache should have been discarded\");\n+    assert_type_verify_empty();\n@@ -188,0 +188,2 @@\n+  void assert_type_verify_empty() const PRODUCT_RETURN;\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}