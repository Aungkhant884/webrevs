{"files":[{"patch":"@@ -653,0 +653,3 @@\n+#ifdef ASSERT\n+                  , _type_verif_cache(comp_arena(), 2, 0, VerifyMeetResult())\n+#endif\n@@ -925,1 +928,5 @@\n-    _allowed_reasons(0) {\n+    _allowed_reasons(0)\n+#ifdef ASSERT\n+  , _type_verif_cache(comp_arena(), 2, 0, VerifyMeetResult())\n+#endif\n+    {\n@@ -1075,1 +1082,0 @@\n-  _type_verify_symmetry = true;\n@@ -1078,0 +1084,1 @@\n+  _type_depth = 0;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1218,1 +1218,41 @@\n-  bool _type_verify_symmetry;\n+  class VerifyMeetResult {\n+  private:\n+    const Type* _in1;\n+    const Type* _in2;\n+    const Type* _res;\n+  public:\n+    VerifyMeetResult(const Type* in1, const Type* in2, const Type* res):\n+    _in1(in1), _in2(in2), _res(res) {\n+    }\n+    VerifyMeetResult():\n+    _in1(NULL), _in2(NULL), _res(NULL) {\n+    }\n+\n+    bool operator==(const VerifyMeetResult& rhs) const {\n+      return _in1 == rhs._in1 &&\n+             _in2 == rhs._in2 &&\n+             _res == rhs._res;\n+    }\n+\n+    bool operator!=(const VerifyMeetResult& rhs) const {\n+      return !(rhs == *this);\n+    }\n+\n+    static int compare(const VerifyMeetResult& v1, const VerifyMeetResult& v2) {\n+      if ((intptr_t) v1._in1 < (intptr_t) v2._in1) {\n+        return -1;\n+      } else if (v1._in1 == v2._in1) {\n+        if ((intptr_t) v1._in2 < (intptr_t) v2._in2) {\n+          return -1;\n+        } else if (v1._in2 == v2._in2) {\n+          assert(v1._res == v2._res || v1._res == NULL || v2._res == NULL, \"same inputs should lead to same result\");\n+          return 0;\n+        }\n+        return 1;\n+      }\n+      return 1;\n+    }\n+    const Type* res() const { return _res; }\n+  };\n+  uint _type_depth;\n+  GrowableArray<VerifyMeetResult> _type_verif_cache;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -789,0 +789,75 @@\n+#ifdef ASSERT\n+\/\/ With verification code, the meet of A and B causes the computation of:\n+\/\/ 1- meet(A, B)\n+\/\/ 2- meet(B, A)\n+\/\/ 3- meet(dual(meet(A, B)), dual(A))\n+\/\/ 4- meet(dual(meet(A, B)), dual(B))\n+\/\/ 5- meet(dual(A), dual(B))\n+\/\/ 6- meet(dual(B), dual(A))\n+\/\/ 7- meet(dual(meet(dual(A), dual(B))), A)\n+\/\/ 8- meet(dual(meet(dual(A), dual(B))), B)\n+\/\/\n+\/\/ In addition the meet of A[] and B[] requires the computation of the meet of A and B.\n+\/\/\n+\/\/ The meet of A[] and B[] triggers the computation of:\n+\/\/ 1- meet(A[], B[][)\n+\/\/   1.1- meet(A, B)\n+\/\/   1.2- meet(B, A)\n+\/\/   1.3- meet(dual(meet(A, B)), dual(A))\n+\/\/   1.4- meet(dual(meet(A, B)), dual(B))\n+\/\/   1.5- meet(dual(A), dual(B))\n+\/\/   1.6- meet(dual(B), dual(A))\n+\/\/   1.7- meet(dual(meet(dual(A), dual(B))), A)\n+\/\/   1.8- meet(dual(meet(dual(A), dual(B))), B)\n+\/\/ 2- meet(B[], A[])\n+\/\/   2.1- meet(B, A) = 1.2\n+\/\/   2.2- meet(A, B) = 1.1\n+\/\/   2.3- meet(dual(meet(B, A)), dual(B)) = 1.4\n+\/\/   2.4- meet(dual(meet(B, A)), dual(A)) = 1.3\n+\/\/   2.5- meet(dual(B), dual(A)) = 1.6\n+\/\/   2.6- meet(dual(A), dual(B)) = 1.5\n+\/\/   2.7- meet(dual(meet(dual(B), dual(A))), B) = 1.8\n+\/\/   2.8- meet(dual(meet(dual(B), dual(A))), B) = 1.7\n+\/\/ etc.\n+\/\/ The number of meet operations performed grows exponentially with the number of dimensions of the arrays but the number\n+\/\/ of different meet operations is linear in the number of dimensions. The function below caches meet results for the\n+\/\/ duration of the meet at the root of the recursive calls.\n+\/\/\n+static const Type* debug_meet(const Type* t1, const Type* t2) {\n+  Compile* C = Compile::current();\n+\n+  bool found = false;\n+  const Compile::VerifyMeetResult meet(t1, t2, NULL);\n+  int pos = C->_type_verif_cache.find_sorted<Compile::VerifyMeetResult, Compile::VerifyMeetResult::compare>(meet, found);\n+  const Type* res = NULL;\n+  if (found) {\n+    res = C->_type_verif_cache.at(pos).res();\n+  } else {\n+    res = t1->xmeet(t2);\n+    C->_type_verif_cache.insert_sorted<Compile::VerifyMeetResult::compare>(Compile::VerifyMeetResult(t1, t2, res));\n+    found = false;\n+    C->_type_verif_cache.find_sorted<Compile::VerifyMeetResult, Compile::VerifyMeetResult::compare>(meet, found);\n+    assert(found, \"should be in table after it's added\");\n+  }\n+  return res;\n+}\n+\n+class TypeVerif {\n+private:\n+  Compile* _C;\n+public:\n+  TypeVerif(Compile* C) : _C(C) {\n+    _C->_type_depth++;\n+  }\n+\n+  ~TypeVerif() {\n+    assert(_C->_type_depth != 0, \"\");\n+    _C->_type_depth--;\n+    if (_C->_type_depth == 0) {\n+      _C->_type_verif_cache.trunc_to(0);\n+    }\n+  }\n+};\n+\n+#endif\n+\n@@ -791,1 +866,1 @@\n-  const Type* mt2 = t->xmeet(this);\n+  const Type* mt2 = debug_meet(t, this);\n@@ -801,2 +876,2 @@\n-  const Type* t2t    = dual_join->xmeet(t->_dual);\n-  const Type* t2this = dual_join->xmeet(this->_dual);\n+  const Type* t2t    = debug_meet(dual_join,t->_dual);\n+  const Type* t2this = debug_meet(dual_join,this->_dual);\n@@ -839,0 +914,3 @@\n+  Compile* C = Compile::current();\n+  TypeVerif verif(C);\n+\n@@ -844,4 +922,5 @@\n-  if (isa_narrowoop() || t->isa_narrowoop()) return mt;\n-  if (isa_narrowklass() || t->isa_narrowklass()) return mt;\n-  Compile* C = Compile::current();\n-  if (!C->_type_verify_symmetry) {\n+  C->_type_verif_cache.insert_sorted<Compile::VerifyMeetResult::compare>(Compile::VerifyMeetResult(this_t, t, mt));\n+  if (isa_narrowoop() || t->isa_narrowoop()) {\n+    return mt;\n+  }\n+  if (isa_narrowklass() || t->isa_narrowklass()) {\n@@ -851,11 +930,1 @@\n-  \/\/ In the case of an array, computing the meet above, caused the\n-  \/\/ computation of the meet of the elements which at verification\n-  \/\/ time caused the computation of the meet of the dual of the\n-  \/\/ elements. Computing the meet of the dual of the arrays here\n-  \/\/ causes the meet of the dual of the elements to be computed which\n-  \/\/ would cause the meet of the dual of the dual of the elements,\n-  \/\/ that is the meet of the elements already computed above to be\n-  \/\/ computed. Avoid redundant computations by requesting no\n-  \/\/ verification.\n-  C->_type_verify_symmetry = false;\n-  const Type *mt_dual = this_t->_dual->xmeet(t->_dual);\n+  const Type *mt_dual = debug_meet(this_t->_dual,t->_dual);\n@@ -863,2 +932,0 @@\n-  assert(!C->_type_verify_symmetry, \"shouldn't have changed\");\n-  C->_type_verify_symmetry = true;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":87,"deletions":20,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+    assert(Compile::current()->_type_verif_cache.length() == 0, \"cache should have been discarded\");\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8297582\n+ * @summary C2: very slow compilation due to type system verification code\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation TestArrayManyDimensions\n+ *\n+ *\/\n+\n+import java.util.function.IntFunction;\n+\n+public class TestArrayManyDimensions {\n+\n+    static class A {\n+\n+    }\n+\n+    static class B extends A {\n+    }\n+\n+    public static void main(String[] args) {\n+        final IntFunction<String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]> lambda = String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]::new;\n+        for (int i = 0; i < 20_000; i++) {\n+            test1();\n+            lambda.apply(2);\n+            test2();\n+        }\n+    }\n+\n+    private static String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] test1() {\n+        return new String[2][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][];\n+    }\n+\n+    private static A[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] test2() {\n+        return new B[2][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestArrayManyDimensions.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}