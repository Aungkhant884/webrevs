{"files":[{"patch":"@@ -921,0 +921,1 @@\n+  BasicType bt = is_int ? T_INT: T_LONG;\n@@ -929,1 +930,1 @@\n-  if (!is_unsigned) {\n+  if (is_int && !is_unsigned) {\n@@ -931,8 +932,2 @@\n-      if (is_int) {\n-        res =  gvn.transform(new MaxINode(a, b));\n-        assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n-      } else {\n-        Node* cmp = gvn.transform(new CmpLNode(a, b));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n-      }\n+      res =  gvn.transform(new MaxINode(a, b));\n+      assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n@@ -940,8 +935,2 @@\n-      if (is_int) {\n-        Node* res =  gvn.transform(new MinINode(a, b));\n-        assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n-      } else {\n-        Node* cmp = gvn.transform(new CmpLNode(b, a));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n-      }\n+      Node* res =  gvn.transform(new MinINode(a, b));\n+      assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n@@ -950,0 +939,1 @@\n+    Node* cmp = NULL;\n@@ -951,9 +941,1 @@\n-      if (is_int) {\n-        Node* cmp = gvn.transform(new CmpUNode(a, b));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n-      } else {\n-        Node* cmp = gvn.transform(new CmpULNode(a, b));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n-      }\n+      cmp = gvn.transform(CmpNode::make(a, b, bt, is_unsigned));\n@@ -961,9 +943,1 @@\n-      if (is_int) {\n-        Node* cmp = gvn.transform(new CmpUNode(b, a));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n-      } else {\n-        Node* cmp = gvn.transform(new CmpULNode(b, a));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n-      }\n+      cmp = gvn.transform(CmpNode::make(b, a, bt, is_unsigned));\n@@ -971,0 +945,2 @@\n+    Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n+    res = gvn.transform(CMoveNode::make(NULL, bol, a, b, t));\n@@ -982,6 +958,2 @@\n-  Node* zero = NULL;\n-  if (is_int) {\n-    zero = gvn.intcon(0);\n-  } else {\n-    zero = gvn.longcon(0);\n-  }\n+  BasicType bt = is_int ? T_INT: T_LONG;\n+  Node* zero = gvn.integercon(0, bt);\n@@ -995,1 +967,1 @@\n-  Node* res = NULL;\n+  Node* cmp = NULL;\n@@ -997,11 +969,1 @@\n-    if (is_int) {\n-      Node* cmp = gvn.transform(new CmpINode(a, b));\n-      Node* sub = gvn.transform(new SubINode(a, b));\n-      Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n-    } else {\n-      Node* cmp = gvn.transform(new CmpLNode(a, b));\n-      Node* sub = gvn.transform(new SubLNode(a, b));\n-      Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n-    }\n+    cmp = gvn.transform(CmpNode::make(a, b, bt, false));\n@@ -1009,11 +971,1 @@\n-    if (is_int) {\n-      Node* cmp = gvn.transform(new CmpINode(b, a));\n-      Node* sub = gvn.transform(new SubINode(a, b));\n-      Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n-    } else {\n-      Node* cmp = gvn.transform(new CmpLNode(b, a));\n-      Node* sub = gvn.transform(new SubLNode(a, b));\n-      Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n-    }\n+    cmp = gvn.transform(CmpNode::make(b, a, bt, false));\n@@ -1021,0 +973,3 @@\n+  Node* sub = gvn.transform(SubNode::make(a, b, bt));\n+  Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n+  Node* res = gvn.transform(CMoveNode::make(NULL, bol, sub, zero, t));\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":19,"deletions":64,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -609,1 +609,3 @@\n-bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar) const {\n+bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, BasicType bt, Node *iv, Node *&range,\n+                                      Node *&offset,\n+                                      jlong &scale) const {\n@@ -624,1 +626,1 @@\n-  if (cmp->Opcode() != Op_CmpU) {\n+  if (!(cmp->is_Cmp() && cmp->operates_on(bt, false))) {\n@@ -627,4 +629,4 @@\n-  Node* range = cmp->in(2);\n-  if (range->Opcode() != Op_LoadRange && !iff->is_RangeCheck()) {\n-    const TypeInt* tint = phase->_igvn.type(range)->isa_int();\n-    if (tint == NULL || tint->empty() || tint->_lo < 0) {\n+  range = cmp->in(2);\n+  if (range->Opcode() != Op_LoadRange) {\n+    const TypeInteger* tinteger = phase->_igvn.type(range)->isa_integer(bt);\n+    if (tinteger == NULL || tinteger->empty() || tinteger->lo_as_long() < 0) {\n@@ -637,0 +639,2 @@\n+  } else {\n+    assert(bt == T_INT, \"no LoadRange for longs\");\n@@ -638,1 +642,3 @@\n-  if (!invar.is_invariant(range)) {\n+  scale  = 0;\n+  offset = NULL;\n+  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, &scale, &offset, bt)) {\n@@ -641,2 +647,5 @@\n-  Node *iv     = _head->as_CountedLoop()->phi();\n-  int   scale  = 0;\n+  return true;\n+}\n+\n+bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar) const {\n+  Node* range = NULL;\n@@ -644,1 +653,4 @@\n-  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, &scale, &offset)) {\n+  jlong scale = 0;\n+  Node *iv = _head->as_BaseCountedLoop()->phi();\n+  if (is_range_check_if(iff, phase, T_INT, iv, range, offset, scale)) {\n+    if (!invar.is_invariant(range)) {\n@@ -652,0 +664,2 @@\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1050,0 +1050,58 @@\n+\/\/ Slightly different from IdealLoopTree::policy_range_check(): doesn't test for a loop invariant range as hoisting\n+\/\/ may not have happened yet.\n+bool IdealLoopTree::may_have_range_check(PhaseIdealLoop *phase) const {\n+  if (_head->is_CountedLoop()) {\n+    CountedLoopNode *cl = _head->as_CountedLoop();\n+    \/\/ If we unrolled  with no intention of doing RCE and we  later changed our\n+    \/\/ minds, we got no pre-loop.  Either we need to make a new pre-loop, or we\n+    \/\/ have to disallow RCE.\n+    if (cl->is_main_no_pre_loop()) return false; \/\/ Disallowed for now.\n+\n+    \/\/ check for vectorized loops, some opts are no longer needed\n+    \/\/ RCE needs pre\/main\/post loops. Don't apply it on a single iteration loop.\n+    if (cl->is_unroll_only() || (cl->is_normal_loop() && cl->trip_count() == 1)) return false;\n+  }\n+  BaseCountedLoopNode* cl = _head->as_BaseCountedLoop();\n+  Node *trip_counter = cl->phi();\n+  BasicType bt = cl->bt();\n+\n+  \/\/ Check loop body for tests of trip-counter plus loop-invariant\n+  for (uint i = 0; i < _body.size(); i++) {\n+    Node *iff = _body[i];\n+    if (iff->Opcode() == Op_If ||\n+        iff->Opcode() == Op_RangeCheck) { \/\/ Test?\n+\n+      \/\/ Comparing trip+off vs limit\n+      Node *bol = iff->in(1);\n+      if (bol->req() != 2) {\n+        continue; \/\/ dead constant test\n+      }\n+      if (!bol->is_Bool()) {\n+        assert(bol->Opcode() == Op_Conv2B, \"predicate check only\");\n+        continue;\n+      }\n+      if (bol->as_Bool()->_test._test == BoolTest::ne) {\n+        continue; \/\/ not RC\n+      }\n+      Node *cmp = bol->in(1);\n+\n+      \/\/ Try to pattern match with either cmp inputs, do not check whether one of the inputs is loop independent as it\n+      \/\/ may not have had a change to be hoisted yet.\n+      if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, NULL, NULL, bt) &&\n+          !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, NULL, NULL, bt)) {\n+        continue;\n+      }\n+      \/\/ Found a test like 'trip+off vs limit'. Test is an IfNode, has two (2)\n+      \/\/ projections. If BOTH are in the loop we need loop unswitching instead\n+      \/\/ of iteration splitting.\n+      if (is_loop_exit(iff)) {\n+        \/\/ Found valid reason to split iterations\n+        return true;\n+      }\n+    } \/\/ End of is IF\n+  }\n+\n+  return false;\n+}\n+\n+\n@@ -2431,1 +2489,1 @@\n-bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, int* p_scale) {\n+bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt) {\n@@ -2433,0 +2491,1 @@\n+  assert(bt == T_INT || bt == T_LONG, \"unexpected int type\");\n@@ -2440,1 +2499,2 @@\n-  if (opc == Op_MulI) {\n+  \/\/ Can't use is_Mul() here as it's true for AndI and AndL\n+  if ((opc == Op_MulI || opc == Op_MulL) && exp->operates_on(bt, true)) {\n@@ -2443,1 +2503,1 @@\n-        *p_scale = exp->in(2)->get_int();\n+        *p_scale = exp->in(2)->get_integer_as_long(bt);\n@@ -2449,1 +2509,1 @@\n-        *p_scale = exp->in(1)->get_int();\n+        *p_scale = exp->in(1)->get_integer_as_long(bt);\n@@ -2453,1 +2513,1 @@\n-  } else if (opc == Op_LShiftI) {\n+  } else if (exp->is_LShift() && exp->operates_on(bt, true)) {\n@@ -2456,1 +2516,1 @@\n-        *p_scale = 1 << exp->in(2)->get_int();\n+        *p_scale = ((jlong)1) << exp->in(2)->get_int();\n@@ -2466,2 +2526,3 @@\n-bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth) {\n-  if (is_scaled_iv(exp, iv, p_scale)) {\n+bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, int depth) {\n+  assert(bt == T_INT || bt == T_LONG, \"unexpected int type\");\n+  if (is_scaled_iv(exp, iv, p_scale, bt)) {\n@@ -2469,1 +2530,1 @@\n-      Node *zero = _igvn.intcon(0);\n+      Node *zero = _igvn.integercon(0, bt);\n@@ -2476,3 +2537,2 @@\n-  int opc = exp->Opcode();\n-  if (opc == Op_AddI) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale)) {\n+  if (exp->is_Add() && exp->operates_on(bt, true)) {\n+    if (is_scaled_iv(exp->in(1), iv, p_scale, bt)) {\n@@ -2484,1 +2544,1 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale)) {\n+    if (is_scaled_iv(exp->in(2), iv, p_scale, bt)) {\n@@ -2494,1 +2554,1 @@\n-                                   p_offset != NULL ? &offset2 : NULL, depth+1)) {\n+                                   p_offset != NULL ? &offset2 : NULL, bt, depth+1)) {\n@@ -2497,1 +2557,1 @@\n-          Node* offset = new AddINode(offset2, exp->in(2));\n+          Node* offset = AddNode::make(offset2, exp->in(2), bt);\n@@ -2504,2 +2564,2 @@\n-  } else if (opc == Op_SubI) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale)) {\n+  } else if (exp->is_Sub() && exp->operates_on(bt, true)) {\n+    if (is_scaled_iv(exp->in(1), iv, p_scale, bt)) {\n@@ -2507,1 +2567,1 @@\n-        Node *zero = _igvn.intcon(0);\n+        Node *zero = _igvn.integercon(0, bt);\n@@ -2510,1 +2570,1 @@\n-        Node* offset = new SubINode(zero, exp->in(2));\n+        Node* offset = SubNode::make(zero, exp->in(2), bt);\n@@ -2516,1 +2576,1 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale)) {\n+    if (is_scaled_iv(exp->in(2), iv, p_scale, bt)) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":80,"deletions":20,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -527,1 +527,1 @@\n-void PhaseIdealLoop::long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head) {\n+Node* PhaseIdealLoop::long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head) {\n@@ -548,0 +548,1 @@\n+  return iv_replacement;\n@@ -829,0 +830,5 @@\n+  Node_List range_checks;\n+  iters_limit = extract_long_range_checks(loop, stride_con, iters_limit, phi, range_checks);\n+\n+  Node* long_stride = head->stride();\n+\n@@ -878,2 +884,2 @@\n-  Node* zero = _igvn.intcon(0);\n-  set_ctrl(zero, C->root());\n+  Node* int_zero = _igvn.intcon(0);\n+  set_ctrl(int_zero, C->root());\n@@ -881,1 +887,1 @@\n-    inner_iters_actual_int = new SubINode(zero, inner_iters_actual_int);\n+    inner_iters_actual_int = new SubINode(int_zero, inner_iters_actual_int);\n@@ -886,1 +892,1 @@\n-  Node* int_stride = _igvn.intcon((int)stride_con);\n+  Node* int_stride = _igvn.intcon(checked_cast<int>(stride_con));\n@@ -893,1 +899,1 @@\n-  inner_phi->set_req(LoopNode::EntryControl, zero);\n+  inner_phi->set_req(LoopNode::EntryControl, int_zero);\n@@ -916,1 +922,1 @@\n-  long_loop_replace_long_iv(phi, inner_phi, outer_phi, head);\n+  Node* iv_add = long_loop_replace_long_iv(phi, inner_phi, outer_phi, head);\n@@ -980,0 +986,2 @@\n+  transform_long_range_checks(stride_con, range_checks, outer_phi, inner_iters_actual_int,\n+                              inner_phi, iv_add, inner_head);\n@@ -1012,0 +1020,212 @@\n+void PhaseIdealLoop::transform_long_range_checks(jlong stride_con, const Node_List &range_checks, Node* outer_phi,\n+                                                 Node* inner_iters_actual_int, Node* inner_phi,\n+                                                 Node* iv_add, LoopNode* inner_head) {\n+  Node* int_zero = _igvn.intcon(0);\n+  set_ctrl(int_zero, C->root());\n+  Node* int_stride = _igvn.intcon(checked_cast<int>(stride_con));\n+  set_ctrl(int_stride, C->root());\n+\n+  \/\/ A range check is: 0 <=? scale * outer_iv + offset <? range\n+  \/\/ One execution of the inner loop covers a sub range of the entire iteration range of the loop: [lower, upper)\n+  \/\/\n+  \/\/ Note regarding overflow:\n+  \/\/ scale * inner_iv can't overflow the int range because the number of iterations of the inner loop is adjusted so\n+  \/\/ it's guaranteed not to happen\n+  \/\/ scale * outer_iv + offset can overflow the long range but logic below should guarantee overflow doesn't cause incorrect execution.\n+  \/\/\n+  \/\/\n+  \/\/ if scale * upper + offset < 0, the range check always fails (unless maybe in the case of an overflow) and can be transformed to:\n+  \/\/ 0 <=? scale * i <? 0 (1)\n+  \/\/\n+  \/\/ Otherwise, if scale > 0 and stride > 0 then, an equivalent range check is:\n+  \/\/ 0 <=? scale * lower + offset + scale * inner_iv <? min(range, scale * upper + offset)\n+  \/\/\n+  \/\/ if scale * lower + offset >= 0 then scale * lower + offset + scale * inner_iv >= 0 and an equivalent range check is:\n+  \/\/ if min(range, scale * upper + offset) >= (scale * lower + offset):\n+  \/\/ 0 <=? scale * inner_iv <? min(range, scale * upper + offset) - (scale * lower + offset) (2)\n+  \/\/ if min(range, scale * upper + offset) < (scale * lower + offset):\n+  \/\/ 0 <=? scale * inner_iv <? 0 (3)\n+  \/\/\n+  \/\/ if scale * lower + offset < 0:\n+  \/\/ 0 <=? scale * lower + offset + scale * inner_iv <? min(range, scale * upper + offset) (4)\n+  \/\/ Given, scale * upper + offset >= 0 and scale * inner_iv fits in an int so scale * lower + offset + scale * inner_iv fits in an int\n+  \/\/\n+  \/\/\n+  \/\/ if scale > 0 and stride < 0, an equivalent range check is:\n+  \/\/\n+  \/\/ 0 <=? scale * (upper - 1) + offset + scale * inner_iv <? min(range, scale * upper + offset)\n+  \/\/\n+  \/\/ if scale * lower + offset >= 0 then scale * (upper - 1) + offset + scale * inner_iv >= 0 and an equivalent range check is:\n+  \/\/ 0 <=? scale * lower + offset + (scale * (upper - 1) - scale * lower) + scale * inner_iv <? min(range, scale * upper + offset)\n+  \/\/ if min(range, scale * upper + offset) >= (scale * lower + offset):\n+  \/\/ 0 <=? (scale * (upper - 1) - scale * lower) + scale * inner_iv <? min(range, scale * upper + offset) - (scale * lower + offset) (5)\n+  \/\/ if min(range, scale * upper + offset) < (scale * lower + offset):\n+  \/\/ 0 <=? (scale * (upper - 1) - scale * lower) + scale * inner_iv <? 0 (6)\n+  \/\/\n+  \/\/ if scale * lower + offset < 0:\n+  \/\/ 0 <=? scale * (upper - 1) + offset + scale * inner_iv <? min(range, scale * upper + offset) (7)\n+  \/\/ Given, scale * upper + offset >= 0 and scale * inner_iv fits in an int so scale * (upper - 1) + offset + scale * inner_iv fits in an int\n+  \/\/\n+  \/\/ All of these cases taken together allow conversion of a range check on the long iv of the outer loop into a range\n+  \/\/ check on the int iv of the inner loop:\n+  \/\/\n+  \/\/ if scale > 0 and stride > 0:\n+  \/\/ new_range = min(range, scale * upper + offset) - max(0, (scale * lower + offset))\n+  \/\/ new_range = scale * upper + offset < 0 ? 0 : new_range (1)\n+  \/\/ new_range = new_range < 0 ? 0 : new_range (3)\n+  \/\/ inner_iv * scale + (scale * lower + offset < 0 ? scale * lower + offset < 0 : 0) <u new_range (2), (4)\n+  \/\/\n+  \/\/ if scale > 0 and stride < 0:\n+  \/\/ new_range = min(range, scale * upper + offset) - max(0, (scale * lower + offset))\n+  \/\/ new_range = scale * upper + offset < 0 ? 0 : new_range (1)\n+  \/\/ new_range = new_range < 0 ? 0 : new_range (6)\n+  \/\/ extra_offset = (scale * (upper - 1 - lower)) + offset\n+  \/\/ inner_iv * scale + extra_offset + (scale * lower + offset < 0 ? scale * lower + offset < 0 : 0) <u new_range (5), (7)\n+  \/\/\n+  \/\/ scale < 0 and stride < 0 is similar to scale > 0 and stride > 0 but with lower and upper swapped\n+  \/\/ scale < 0 and stride > 0 is similar to scale > 0 and stride < 0 but with lower and upper swapped\n+  for (uint i = 0; i < range_checks.size(); i++) {\n+    ProjNode* proj = range_checks.at(i)->as_Proj();\n+    ProjNode* unc_proj = proj->other_if_proj();\n+    RangeCheckNode* rc = proj->in(0)->as_RangeCheck();\n+    jlong scale = 0;\n+    Node* offset = NULL;\n+    Node* rc_bol = rc->in(1);\n+    Node* rc_cmp = rc_bol->in(1);\n+    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, &scale, &offset, T_LONG);\n+    assert(ok, \"inconsistent: was tested before\");\n+    Node* range = rc_cmp->in(2);\n+    Node* c = rc->in(0);\n+    CallStaticJavaNode* call = proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+    Node* entry_control = inner_head->in(LoopNode::EntryControl);\n+\n+    \/\/ Compute lower and upper\n+    Node* last = new LoopLimitNode(C, int_zero, inner_iters_actual_int, int_stride);\n+    register_new_node(last, entry_control);\n+    last = new SubINode(last, int_stride);\n+    register_new_node(last, entry_control);\n+\n+    Node* lower = outer_phi;\n+    Node* upper = new ConvI2LNode(last);\n+    register_new_node(upper, entry_control);\n+    upper = new AddLNode(lower, upper);\n+    register_new_node(upper, entry_control);\n+\n+    Node* scale_node = _igvn.longcon(scale);\n+    set_ctrl(scale_node, C->root());\n+\n+    upper = new MulLNode(upper, scale_node);\n+    register_new_node(upper, entry_control);\n+    upper = new AddLNode(upper, offset);\n+    register_new_node(upper, entry_control);\n+\n+    lower = new MulLNode(lower, scale_node);\n+    register_new_node(lower, entry_control);\n+    lower = new AddLNode(lower, offset);\n+    register_new_node(lower, entry_control);\n+\n+    if (scale > 0 != stride_con > 0) {\n+      swap(lower, upper);\n+    }\n+\n+    Node* long_one = _igvn.longcon(1);\n+    set_ctrl(long_one, C->root());\n+    upper = new AddLNode(upper, long_one);\n+    register_new_node(upper, entry_control);\n+\n+    \/\/ min(range, scale * upper + offset)\n+    Node* new_upper = MaxNode::signed_min(range, upper, TypeLong::POS, _igvn);\n+    set_subtree_ctrl(new_upper, true);\n+\n+    \/\/ Use the sign bit, shift and mask to test for lower >= 0\n+    Node* shift_con = _igvn.intcon(63);\n+    set_ctrl(shift_con, C->root());\n+    Node* sign = new RShiftLNode(lower, shift_con);\n+    register_new_node(sign, entry_control);\n+    Node* long_minus_one = _igvn.longcon(-1);\n+    set_ctrl(long_minus_one, C->root());\n+    Node* not_sign = new XorLNode(sign, long_minus_one);\n+    register_new_node(not_sign, entry_control);\n+    \/\/ lower_pos = lower >= 0 ? lower : 0\n+    Node* lower_pos = new AndLNode(lower, not_sign);\n+    register_new_node(lower_pos, entry_control);\n+    \/\/ new_offset = lower >= 0 ? 0 : lower\n+    Node* new_offset = new AndLNode(lower, sign);\n+    register_new_node(new_offset, entry_control);\n+    new_offset = new ConvL2INode(new_offset);\n+    register_new_node(new_offset, entry_control);\n+\n+    Node* new_range = new SubLNode(new_upper, lower_pos);\n+    register_new_node(new_range, entry_control);\n+\n+    \/\/ new_range = new_range < 0 ? 0 : new_range\n+    \/\/ new_range = upper < 0 ? 0 : new_range\n+    \/\/ Use the sign bit again\n+    Node* must_be_non_neg = new OrLNode(new_range, upper);\n+    register_new_node(must_be_non_neg, entry_control);\n+    sign = new RShiftLNode(must_be_non_neg, shift_con);\n+    register_new_node(sign, entry_control);\n+    not_sign = new XorLNode(sign, long_minus_one);\n+    register_new_node(not_sign, entry_control);\n+    new_range = new AndLNode(new_range, not_sign);\n+    register_new_node(new_range, entry_control);\n+\n+    Node* int_range = new ConvL2INode(new_range, TypeInt::POS);\n+    register_new_node(int_range, entry_control);\n+    Node* int_scale_node = _igvn.intcon((int)scale);\n+    set_ctrl(int_scale_node, C->root());\n+    Node* scaled_iv = new MulINode(inner_phi, int_scale_node);\n+    register_new_node(scaled_iv, c);\n+    Node* scaled_iv_plus_offset = scaled_iv;\n+\n+    if (scale > 0 != stride_con > 0) {\n+      Node* extra_offset = new MulINode(last, int_scale_node);\n+      register_new_node(extra_offset, entry_control);\n+      extra_offset = new AddINode(extra_offset, new_offset);\n+      register_new_node(extra_offset, entry_control);\n+      scaled_iv_plus_offset = new SubINode(scaled_iv, extra_offset);\n+      register_new_node(scaled_iv_plus_offset, c);\n+    } else {\n+      scaled_iv_plus_offset = new AddINode(scaled_iv, new_offset);\n+      register_new_node(scaled_iv_plus_offset, c);\n+    }\n+\n+    Node* new_rc_cmp = new CmpUNode(scaled_iv_plus_offset, int_range);\n+    register_new_node(new_rc_cmp, c);\n+\n+    _igvn.replace_input_of(rc_bol, 1, new_rc_cmp);\n+  }\n+}\n+\n+int PhaseIdealLoop::extract_long_range_checks(const IdealLoopTree* loop, jlong stride_con, int iters_limit, PhiNode* phi,\n+                                              Node_List& range_checks) {\n+  const jlong min_iters = 2;\n+  jlong iters_limit_as_long = iters_limit;\n+  jlong max_scale = 1;\n+  for (uint i = 0; i < loop->_body.size(); i++) {\n+    Node* c = loop->_body.at(i);\n+    if (c->is_IfProj() && c->in(0)->is_RangeCheck()) {\n+      CallStaticJavaNode* call = c->as_IfProj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      if (call != NULL) {\n+        Node* range = NULL;\n+        Node* offset = NULL;\n+        jlong scale = 0;\n+        RangeCheckNode* rc = c->in(0)->as_RangeCheck();\n+        if (loop->is_range_check_if(rc, this, T_LONG, phi, range, offset, scale) &&\n+            loop->is_invariant(range) && loop->is_invariant(offset)) {\n+          if (iters_limit_as_long \/ ABS(scale * stride_con) > min_iters\/* && UseNewCode*\/) {\n+            max_scale = MAX2(max_scale, scale);\n+            range_checks.push(c);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  iters_limit_as_long = iters_limit_as_long \/ max_scale;\n+  assert(iters_limit_as_long >= min_iters, \"too few iterations\");\n+  iters_limit = checked_cast<int>(iters_limit_as_long);\n+\n+  return iters_limit;\n+}\n+\n@@ -1417,1 +1637,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_jint - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_signed_integer(iv_bt) - stride_m, iv_bt), iv_bt);\n@@ -1420,1 +1640,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_jint - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_signed_integer(iv_bt) - stride_m, iv_bt), iv_bt);\n@@ -1888,1 +2108,1 @@\n-    return NULL;  \/\/ Identity\n+    return bottom_type();  \/\/ Identity\n@@ -3953,2 +4173,5 @@\n-      bool is_counted = lpt->is_counted();\n-      if (!is_counted || !lpt->is_innermost()) continue;\n+      if (!lpt->is_loop()) {\n+        continue;\n+      }\n+      Node* head = lpt->_head;\n+      if (!head->is_BaseCountedLoop() || !lpt->is_innermost()) continue;\n@@ -3957,5 +4180,7 @@\n-      if (is_counted && lpt->_head->as_CountedLoop()->is_unroll_only()) {\n-        continue;\n-      } else {\n-        AutoNodeBudget node_budget(this);\n-        lpt->reassociate_invariants(this);\n+      if (head->is_CountedLoop()) {\n+        if (head->as_CountedLoop()->is_unroll_only()) {\n+          continue;\n+        } else {\n+          AutoNodeBudget node_budget(this);\n+          lpt->reassociate_invariants(this);\n+        }\n@@ -3967,2 +4192,1 @@\n-        AutoNodeBudget node_budget(this, AutoNodeBudget::NO_BUDGET_CHECK);\n-        if (lpt->policy_range_check(this)) {\n+        if (lpt->may_have_range_check(this)) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":243,"deletions":19,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -732,1 +732,2 @@\n-  bool policy_range_check( PhaseIdealLoop *phase ) const;\n+  bool policy_range_check(PhaseIdealLoop *phase) const;\n+  bool may_have_range_check(PhaseIdealLoop *phase) const;\n@@ -736,0 +737,2 @@\n+  bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, BasicType bt, Node *iv, Node *&range, Node *&offset,\n+                         jlong &scale) const;\n@@ -1168,1 +1171,1 @@\n-  void long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head);\n+  Node* long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head);\n@@ -1270,1 +1273,1 @@\n-  bool is_scaled_iv(Node* exp, Node* iv, int* p_scale);\n+  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt);\n@@ -1273,1 +1276,12 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset) {\n+    jlong long_scale;\n+    if (is_scaled_iv_plus_offset(exp, iv, &long_scale, p_offset, T_INT)) {\n+      int int_scale = checked_cast<int>(long_scale);\n+      if (p_scale != NULL) {\n+        *p_scale = int_scale;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n@@ -1609,0 +1623,7 @@\n+\n+  int extract_long_range_checks(const IdealLoopTree* loop, jlong stride_con, int iters_limit, PhiNode* phi,\n+                                      Node_List &range_checks);\n+\n+  void transform_long_range_checks(jlong stride_con, const Node_List &range_checks, Node* outer_phi,\n+                                   Node* inner_iters_actual_int, Node* inner_phi,\n+                                   Node* iv_add, LoopNode* inner_head);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1067,1 +1067,1 @@\n-  if (n_blk->is_CountedLoop()) {\n+  if (n_blk->is_BaseCountedLoop()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  MulNode( Node *in1, Node *in2 ): Node(0,in1,in2) {\n+  MulNode(Node *in1, Node *in2): Node(NULL,in1,in2) {\n@@ -78,0 +78,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n@@ -94,0 +98,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -110,0 +118,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n@@ -188,0 +200,11 @@\n+class LShiftNode : public Node {\n+public:\n+  LShiftNode(Node *in1, Node *in2) : Node(NULL,in1,in2) {\n+    init_class_id(Class_LShift);\n+  }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+};\n+\n@@ -190,1 +213,1 @@\n-class LShiftINode : public Node {\n+class LShiftINode : public LShiftNode {\n@@ -192,1 +215,1 @@\n-  LShiftINode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  LShiftINode(Node *in1, Node *in2) : LShiftNode(in1,in2) {}\n@@ -199,0 +222,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -203,1 +230,1 @@\n-class LShiftLNode : public Node {\n+class LShiftLNode : public LShiftNode {\n@@ -205,1 +232,1 @@\n-  LShiftLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  LShiftLNode(Node *in1, Node *in2) : LShiftNode(in1,in2) {}\n@@ -212,0 +239,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+class LShiftNode;\n@@ -745,0 +746,1 @@\n+    DEFINE_CLASS_ID(LShift,   Node, 18)\n@@ -874,0 +876,1 @@\n+  DEFINE_CLASS_QUERY(LShift)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n@@ -80,0 +84,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -93,0 +101,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8259609\n+ * @summary C2: optimize long range checks in long counted loops\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.util\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -ea -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation TestLongRangeCheck\n+ *\n+ *\/\n+\n+import jdk.internal.util.Preconditions;\n+import sun.hotspot.WhiteBox;\n+import java.lang.reflect.Method;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class TestLongRangeCheck {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+     private static void assertIsCompiled(Method m) {\n+         if (!WHITE_BOX.isMethodCompiled(m) || WHITE_BOX.getMethodCompilationLevel(m) != CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n+             throw new RuntimeException(\"should still be compiled\");\n+         }\n+    }\n+\n+     private static void assertIsNotCompiled(Method m) {\n+         if (WHITE_BOX.isMethodCompiled(m) && WHITE_BOX.getMethodCompilationLevel(m) == CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n+             throw new RuntimeException(\"should have been deoptimized\");\n+         }\n+    }\n+\n+    private static void compile(Method m) {\n+        WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertIsCompiled(m);\n+    }\n+\n+    public static ClassLoader newClassLoader() {\n+        try {\n+            return new URLClassLoader(new URL[] {\n+                    Paths.get(System.getProperty(\"test.classes\",\".\")).toUri().toURL(),\n+            }, null);\n+        } catch (MalformedURLException e){\n+            throw new RuntimeException(\"Unexpected URL conversion failure\", e);\n+        }\n+    }\n+\n+    private static void test(String method, long start, long stop, long length, long offset) throws Exception {\n+        Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset); \/\/ run once so all classes are loaded\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start-1, stop, length, offset);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset); \/\/ run once so all classes are loaded\n+        compile(m);\n+        assertIsCompiled(m);\n+\n+        m.invoke(null, start, stop, length, offset);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, stop, stop + 100, length, offset);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset); \/\/ run once so all classes are loaded\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start, stop+1, length, offset);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        test(\"testStridePosScalePos\", 0, 100, 100, 0);\n+\n+        test(\"testStrideNegScaleNeg\", 0, 100, 100, 100);\n+\n+        test(\"testStrideNegScalePos\", 0, 100, 100, 0);\n+\n+        test(\"testStridePosScaleNeg\", 0, 100, 100, 99);\n+\n+        test(\"testStridePosScalePosNotOne\", 0, 100, 1090, 0);\n+\n+        test(\"testStrideNegScaleNegNotOne\", 0, 100, 1090, 1100);\n+\n+        test(\"testStrideNegScalePosNotOne\", 0, 100, 1090, 0);\n+\n+        test(\"testStridePosScaleNegNotOne\", 0, 100, 1090, 1089);\n+\n+        long v = ((long)Integer.MAX_VALUE \/ 10000) * 250000;\n+\n+        test(\"testStridePosNotOneScalePos\", -v, v, v * 2, v);\n+\n+        test(\"testStrideNegNotOneScaleNeg\", -v, v, v * 2, v);\n+\n+        test(\"testStrideNegNotOneScalePos\", -v, v, v * 2, v);\n+\n+        test(\"testStridePosNotOneScaleNeg\", -v, v, v * 2, v-1);\n+\n+        \/\/ offset causes overflow\n+\n+        Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePos\", long.class, long.class, long.class, long.class);\n+        m.invoke(null, 0, 100, 100, 0);\n+        compile(m);\n+\n+        m.invoke(null, 0, 100, 100, 0);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+    }\n+\n+    public static void testStridePosScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosNotOne(long start, long stop, long length, long offset) {\n+        final long scale = 11;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegNotOne(long start, long stop, long length, long offset) {\n+        final long scale = -11;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosNotOne(long start, long stop, long length, long offset) {\n+        final long scale = 11;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegNotOne(long start, long stop, long length, long offset) {\n+        final long scale = -11;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = stop; i > start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestLongRangeCheck.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"}]}