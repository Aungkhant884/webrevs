{"files":[{"patch":"@@ -1110,0 +1110,1 @@\n+  BasicType bt = is_int ? T_INT: T_LONG;\n@@ -1118,1 +1119,1 @@\n-  if (!is_unsigned) {\n+  if (is_int && !is_unsigned) {\n@@ -1120,8 +1121,2 @@\n-      if (is_int) {\n-        res =  gvn.transform(new MaxINode(a, b));\n-        assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n-      } else {\n-        Node* cmp = gvn.transform(new CmpLNode(a, b));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n-      }\n+      res =  gvn.transform(new MaxINode(a, b));\n+      assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n@@ -1129,8 +1124,2 @@\n-      if (is_int) {\n-        Node* res =  gvn.transform(new MinINode(a, b));\n-        assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n-      } else {\n-        Node* cmp = gvn.transform(new CmpLNode(b, a));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n-      }\n+      Node* res =  gvn.transform(new MinINode(a, b));\n+      assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n@@ -1139,0 +1128,1 @@\n+    Node* cmp = NULL;\n@@ -1140,9 +1130,1 @@\n-      if (is_int) {\n-        Node* cmp = gvn.transform(new CmpUNode(a, b));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n-      } else {\n-        Node* cmp = gvn.transform(new CmpULNode(a, b));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n-      }\n+      cmp = gvn.transform(CmpNode::make(a, b, bt, is_unsigned));\n@@ -1150,9 +1132,1 @@\n-      if (is_int) {\n-        Node* cmp = gvn.transform(new CmpUNode(b, a));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n-      } else {\n-        Node* cmp = gvn.transform(new CmpULNode(b, a));\n-        Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n-      }\n+      cmp = gvn.transform(CmpNode::make(b, a, bt, is_unsigned));\n@@ -1160,0 +1134,2 @@\n+    Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n+    res = gvn.transform(CMoveNode::make(NULL, bol, a, b, t));\n@@ -1171,6 +1147,2 @@\n-  Node* zero = NULL;\n-  if (is_int) {\n-    zero = gvn.intcon(0);\n-  } else {\n-    zero = gvn.longcon(0);\n-  }\n+  BasicType bt = is_int ? T_INT: T_LONG;\n+  Node* zero = gvn.integercon(0, bt);\n@@ -1184,1 +1156,1 @@\n-  Node* res = NULL;\n+  Node* cmp = NULL;\n@@ -1186,11 +1158,1 @@\n-    if (is_int) {\n-      Node* cmp = gvn.transform(new CmpINode(a, b));\n-      Node* sub = gvn.transform(new SubINode(a, b));\n-      Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n-    } else {\n-      Node* cmp = gvn.transform(new CmpLNode(a, b));\n-      Node* sub = gvn.transform(new SubLNode(a, b));\n-      Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n-    }\n+    cmp = gvn.transform(CmpNode::make(a, b, bt, false));\n@@ -1198,11 +1160,1 @@\n-    if (is_int) {\n-      Node* cmp = gvn.transform(new CmpINode(b, a));\n-      Node* sub = gvn.transform(new SubINode(a, b));\n-      Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n-    } else {\n-      Node* cmp = gvn.transform(new CmpLNode(b, a));\n-      Node* sub = gvn.transform(new SubLNode(a, b));\n-      Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n-      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n-    }\n+    cmp = gvn.transform(CmpNode::make(b, a, bt, false));\n@@ -1210,0 +1162,3 @@\n+  Node* sub = gvn.transform(SubNode::make(a, b, bt));\n+  Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));\n+  Node* res = gvn.transform(CMoveNode::make(NULL, bol, sub, zero, t));\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":19,"deletions":64,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -715,1 +715,2 @@\n-bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n+bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, BasicType bt, Node *iv, Node *&range,\n+                                      Node *&offset, jlong &scale) const {\n@@ -730,1 +731,1 @@\n-  if (cmp->Opcode() != Op_CmpU) {\n+  if (!(cmp->is_Cmp() && cmp->operates_on(bt, false))) {\n@@ -733,4 +734,4 @@\n-  Node* range = cmp->in(2);\n-  if (range->Opcode() != Op_LoadRange && !iff->is_RangeCheck()) {\n-    const TypeInt* tint = phase->_igvn.type(range)->isa_int();\n-    if (tint == NULL || tint->empty() || tint->_lo < 0) {\n+  range = cmp->in(2);\n+  if (range->Opcode() != Op_LoadRange) {\n+    const TypeInteger* tinteger = phase->_igvn.type(range)->isa_integer(bt);\n+    if (tinteger == NULL || tinteger->empty() || tinteger->lo_as_long() < 0) {\n@@ -743,0 +744,2 @@\n+  } else {\n+    assert(bt == T_INT, \"no LoadRange for longs\");\n@@ -744,10 +747,3 @@\n-  if (!invar.is_invariant(range)) {\n-    return false;\n-  }\n-  Node *iv     = _head->as_CountedLoop()->phi();\n-  int   scale  = 0;\n-  Node *offset = NULL;\n-  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, &scale, &offset)) {\n-    return false;\n-  }\n-  if (offset && !invar.is_invariant(offset)) { \/\/ offset must be invariant\n+  scale  = 0;\n+  offset = NULL;\n+  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, &scale, &offset, bt)) {\n@@ -756,0 +752,15 @@\n+  return true;\n+}\n+\n+bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n+  Node* range = NULL;\n+  Node* offset = NULL;\n+  jlong scale = 0;\n+  Node* iv = _head->as_BaseCountedLoop()->phi();\n+  if (is_range_check_if(iff, phase, T_INT, iv, range, offset, scale)) {\n+    if (!invar.is_invariant(range)) {\n+      return false;\n+    }\n+    if (offset && !invar.is_invariant(offset)) { \/\/ offset must be invariant\n+      return false;\n+    }\n@@ -757,11 +768,12 @@\n-  if (offset && phase->has_ctrl(offset)) {\n-    Node* offset_ctrl = phase->get_ctrl(offset);\n-    if (phase->get_loop(predicate_proj) == phase->get_loop(offset_ctrl) &&\n-        phase->is_dominator(predicate_proj, offset_ctrl)) {\n-      \/\/ If the control of offset is loop predication promoted by previous pass,\n-      \/\/ then it will lead to cyclic dependency.\n-      \/\/ Previously promoted loop predication is in the same loop of predication\n-      \/\/ point.\n-      \/\/ This situation can occur when pinning nodes too conservatively - can we do better?\n-      assert(false, \"cyclic dependency prevents range check elimination, idx: offset %d, offset_ctrl %d, predicate_proj %d\",\n-             offset->_idx, offset_ctrl->_idx, predicate_proj->_idx);\n+    if (offset && phase->has_ctrl(offset)) {\n+      Node* offset_ctrl = phase->get_ctrl(offset);\n+      if (phase->get_loop(predicate_proj) == phase->get_loop(offset_ctrl) &&\n+          phase->is_dominator(predicate_proj, offset_ctrl)) {\n+        \/\/ If the control of offset is loop predication promoted by previous pass,\n+        \/\/ then it will lead to cyclic dependency.\n+        \/\/ Previously promoted loop predication is in the same loop of predication\n+        \/\/ point.\n+        \/\/ This situation can occur when pinning nodes too conservatively - can we do better?\n+        assert(false, \"cyclic dependency prevents range check elimination, idx: offset %d, offset_ctrl %d, predicate_proj %d\",\n+               offset->_idx, offset_ctrl->_idx, predicate_proj->_idx);\n+      }\n@@ -769,1 +781,0 @@\n-  }\n@@ -771,1 +782,3 @@\n-  return true;\n+    return true;\n+  }\n+  return false;\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":42,"deletions":29,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1062,0 +1062,1 @@\n+\n@@ -1067,2 +1068,2 @@\n-bool IdealLoopTree::policy_range_check(PhaseIdealLoop *phase) const {\n-  if (!RangeCheckElimination) return false;\n+bool IdealLoopTree::policy_range_check(PhaseIdealLoop* phase, bool provisional) const {\n+  if (!provisional && !RangeCheckElimination) return false;\n@@ -1071,1 +1072,1 @@\n-  assert(!phase->exceeding_node_budget(), \"sanity\");\n+  assert(provisional || !phase->exceeding_node_budget(), \"sanity\");\n@@ -1073,6 +1074,13 @@\n-  CountedLoopNode *cl = _head->as_CountedLoop();\n-  \/\/ If we unrolled  with no intention of doing RCE and we  later changed our\n-  \/\/ minds, we got no pre-loop.  Either we need to make a new pre-loop, or we\n-  \/\/ have to disallow RCE.\n-  if (cl->is_main_no_pre_loop()) return false; \/\/ Disallowed for now.\n-  Node *trip_counter = cl->phi();\n+  if (_head->is_CountedLoop()) {\n+    CountedLoopNode *cl = _head->as_CountedLoop();\n+    \/\/ If we unrolled  with no intention of doing RCE and we  later changed our\n+    \/\/ minds, we got no pre-loop.  Either we need to make a new pre-loop, or we\n+    \/\/ have to disallow RCE.\n+    if (cl->is_main_no_pre_loop()) return false; \/\/ Disallowed for now.\n+\n+    \/\/ check for vectorized loops, some opts are no longer needed\n+    \/\/ RCE needs pre\/main\/post loops. Don't apply it on a single iteration loop.\n+    if (cl->is_unroll_only() || (cl->is_normal_loop() && cl->trip_count() == 1)) return false;\n+  } else {\n+    assert(provisional, \"no long counted loop expected\");\n+  }\n@@ -1080,3 +1088,3 @@\n-  \/\/ check for vectorized loops, some opts are no longer needed\n-  \/\/ RCE needs pre\/main\/post loops. Don't apply it on a single iteration loop.\n-  if (cl->is_unroll_only() || (cl->is_normal_loop() && cl->trip_count() == 1)) return false;\n+  BaseCountedLoopNode* cl = _head->as_BaseCountedLoop();\n+  Node *trip_counter = cl->phi();\n+  BasicType bt = cl->bt();\n@@ -1107,9 +1115,13 @@\n-      Node *limit_c = phase->get_ctrl(limit);\n-      if (limit_c == phase->C->top()) {\n-        return false;           \/\/ Found dead test on live IF?  No RCE!\n-      }\n-      if (is_member(phase->get_loop(limit_c))) {\n-        \/\/ Compare might have operands swapped; commute them\n-        rc_exp = cmp->in(2);\n-        limit  = cmp->in(1);\n-        limit_c = phase->get_ctrl(limit);\n+      if (provisional) {\n+        \/\/ Try to pattern match with either cmp inputs, do not check\n+        \/\/ whether one of the inputs is loop independent as it may not\n+        \/\/ have had a chance to be hoisted yet.\n+        if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, NULL, NULL, bt) &&\n+            !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, NULL, NULL, bt)) {\n+          continue;\n+        }\n+      } else {\n+        Node *limit_c = phase->get_ctrl(limit);\n+        if (limit_c == phase->C->top()) {\n+          return false;           \/\/ Found dead test on live IF?  No RCE!\n+        }\n@@ -1117,1 +1129,7 @@\n-          continue;             \/\/ Both inputs are loop varying; cannot RCE\n+          \/\/ Compare might have operands swapped; commute them\n+          rc_exp = cmp->in(2);\n+          limit  = cmp->in(1);\n+          limit_c = phase->get_ctrl(limit);\n+          if (is_member(phase->get_loop(limit_c))) {\n+            continue;             \/\/ Both inputs are loop varying; cannot RCE\n+          }\n@@ -1119,1 +1137,0 @@\n-      }\n@@ -1121,2 +1138,3 @@\n-      if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {\n-        continue;\n+        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {\n+          continue;\n+        }\n@@ -1130,1 +1148,1 @@\n-        return phase->may_require_nodes(est_loop_clone_sz(2));\n+        return provisional || phase->may_require_nodes(est_loop_clone_sz(2));\n@@ -2461,1 +2479,1 @@\n-bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, int* p_scale) {\n+bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt) {\n@@ -2463,0 +2481,1 @@\n+  assert(bt == T_INT || bt == T_LONG, \"unexpected int type\");\n@@ -2470,1 +2489,2 @@\n-  if (opc == Op_MulI) {\n+  \/\/ Can't use is_Mul() here as it's true for AndI and AndL\n+  if ((opc == Op_MulI || opc == Op_MulL) && exp->operates_on(bt, true)) {\n@@ -2473,1 +2493,1 @@\n-        *p_scale = exp->in(2)->get_int();\n+        *p_scale = exp->in(2)->get_integer_as_long(bt);\n@@ -2479,1 +2499,1 @@\n-        *p_scale = exp->in(1)->get_int();\n+        *p_scale = exp->in(1)->get_integer_as_long(bt);\n@@ -2483,1 +2503,1 @@\n-  } else if (opc == Op_LShiftI) {\n+  } else if (exp->is_LShift() && exp->operates_on(bt, true)) {\n@@ -2486,1 +2506,6 @@\n-        *p_scale = 1 << exp->in(2)->get_int();\n+        jint shift_amount = exp->in(2)->get_int();\n+        if (bt == T_INT) {\n+          *p_scale = java_shift_left(1, (juint)shift_amount);\n+        } else if (bt == T_LONG) {\n+          *p_scale = java_shift_left((jlong)1, (julong)shift_amount);\n+        }\n@@ -2496,2 +2521,3 @@\n-bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth) {\n-  if (is_scaled_iv(exp, iv, p_scale)) {\n+bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, int depth) {\n+  assert(bt == T_INT || bt == T_LONG, \"unexpected int type\");\n+  if (is_scaled_iv(exp, iv, p_scale, bt)) {\n@@ -2499,1 +2525,1 @@\n-      Node *zero = _igvn.intcon(0);\n+      Node *zero = _igvn.integercon(0, bt);\n@@ -2506,3 +2532,2 @@\n-  int opc = exp->Opcode();\n-  if (opc == Op_AddI) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale)) {\n+  if (exp->is_Add() && exp->operates_on(bt, true)) {\n+    if (is_scaled_iv(exp->in(1), iv, p_scale, bt)) {\n@@ -2514,1 +2539,1 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale)) {\n+    if (is_scaled_iv(exp->in(2), iv, p_scale, bt)) {\n@@ -2524,1 +2549,1 @@\n-                                   p_offset != NULL ? &offset2 : NULL, depth+1)) {\n+                                   p_offset != NULL ? &offset2 : NULL, bt, depth+1)) {\n@@ -2527,1 +2552,1 @@\n-          Node* offset = new AddINode(offset2, exp->in(2));\n+          Node* offset = AddNode::make(offset2, exp->in(2), bt);\n@@ -2534,2 +2559,2 @@\n-  } else if (opc == Op_SubI) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale)) {\n+  } else if (exp->is_Sub() && exp->operates_on(bt, true)) {\n+    if (is_scaled_iv(exp->in(1), iv, p_scale, bt)) {\n@@ -2537,1 +2562,1 @@\n-        Node *zero = _igvn.intcon(0);\n+        Node *zero = _igvn.integercon(0, bt);\n@@ -2540,1 +2565,1 @@\n-        Node* offset = new SubINode(zero, exp->in(2));\n+        Node* offset = SubNode::make(zero, exp->in(2), bt);\n@@ -2546,1 +2571,1 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale)) {\n+    if (is_scaled_iv(exp->in(2), iv, p_scale, bt)) {\n@@ -2548,0 +2573,3 @@\n+        if (*p_scale == min_signed_integer(bt)) {\n+          return false;\n+        }\n@@ -3414,1 +3442,1 @@\n-  bool should_rce    = policy_range_check(phase);\n+  bool should_rce    = policy_range_check(phase, false);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":75,"deletions":47,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -528,1 +528,1 @@\n-void PhaseIdealLoop::long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head) {\n+Node* PhaseIdealLoop::long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head) {\n@@ -549,0 +549,1 @@\n+  return iv_replacement;\n@@ -831,0 +832,3 @@\n+  Node_List range_checks;\n+  iters_limit = extract_long_range_checks(loop, stride_con, iters_limit, phi, range_checks);\n+\n@@ -880,2 +884,2 @@\n-  Node* zero = _igvn.intcon(0);\n-  set_ctrl(zero, C->root());\n+  Node* int_zero = _igvn.intcon(0);\n+  set_ctrl(int_zero, C->root());\n@@ -883,1 +887,1 @@\n-    inner_iters_actual_int = new SubINode(zero, inner_iters_actual_int);\n+    inner_iters_actual_int = new SubINode(int_zero, inner_iters_actual_int);\n@@ -888,1 +892,1 @@\n-  Node* int_stride = _igvn.intcon((int)stride_con);\n+  Node* int_stride = _igvn.intcon(checked_cast<int>(stride_con));\n@@ -895,1 +899,1 @@\n-  inner_phi->set_req(LoopNode::EntryControl, zero);\n+  inner_phi->set_req(LoopNode::EntryControl, int_zero);\n@@ -918,1 +922,1 @@\n-  long_loop_replace_long_iv(phi, inner_phi, outer_phi, head);\n+  Node* iv_add = long_loop_replace_long_iv(phi, inner_phi, outer_phi, head);\n@@ -982,0 +986,2 @@\n+  transform_long_range_checks(checked_cast<int>(stride_con), range_checks, outer_phi, inner_iters_actual_int,\n+                              inner_phi, iv_add, inner_head);\n@@ -1015,0 +1021,233 @@\n+int PhaseIdealLoop::extract_long_range_checks(const IdealLoopTree* loop, jlong stride_con, int iters_limit, PhiNode* phi,\n+                                              Node_List& range_checks) {\n+  if (stride_con < 0) { \/\/ only for stride_con > 0 && scale > 0 for now\n+    return iters_limit;\n+  }\n+  const jlong min_iters = 2;\n+  jlong reduced_iters_limit = iters_limit;\n+  jlong original_iters_limit = iters_limit;\n+  for (uint i = 0; i < loop->_body.size(); i++) {\n+    Node* c = loop->_body.at(i);\n+    if (c->is_IfProj() && c->in(0)->is_RangeCheck()) {\n+      CallStaticJavaNode* call = c->as_IfProj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      if (call != NULL) {\n+        Node* range = NULL;\n+        Node* offset = NULL;\n+        jlong scale = 0;\n+        RangeCheckNode* rc = c->in(0)->as_RangeCheck();\n+        if (loop->is_range_check_if(rc, this, T_LONG, phi, range, offset, scale) &&\n+            loop->is_invariant(range) && loop->is_invariant(offset) &&\n+            scale > 0 && \/\/ only for stride_con > 0 && scale > 0 for now\n+            original_iters_limit \/ ABS(scale * stride_con) >= min_iters) {\n+          reduced_iters_limit = MIN2(reduced_iters_limit, original_iters_limit\/ABS(scale));\n+          range_checks.push(c);\n+        }\n+      }\n+    }\n+  }\n+\n+  return checked_cast<int>(reduced_iters_limit);\n+}\n+\n+\/\/ One execution of the inner loop covers a sub-range of the entire iteration range of the loop: [A,Z), aka [A=init,\n+\/\/ Z=limit). If the loop has at least one trip (which is the case here), the iteration variable i always takes A as its\n+\/\/ first value, followed by A+S (S is the stride), next A+2S, etc. The limit is exclusive, so that the final value B of\n+\/\/ i is never Z.  It will be B=Z-1 if S=1, or B=Z+1 if S=-1.  If |S|>1 the formula for the last value requires a floor\n+\/\/ operation, specifically B=floor((Z-sgn(S)-A)\/S)*S+A.  Thus i ranges as i:[A,B] or i:[A,Z) or i:[A,Z-U) for some U<S.\n+\n+\/\/ N.B. We handle only the case of positive S currently, so comments about S<0 are not operative at present.  Also,\n+\/\/ we only support positive index scale value (K > 0) to simplify the logic for clamping 32-bit bounds (L_2, R_2).\n+\/\/ For restrictions on S and K, see the guards in extract_long_range_checks.\n+\n+\/\/ Within the loop there may be many range checks.  Each such range check (R.C.) is of the form 0 <= i*K+L < R, where K\n+\/\/ is a scale factor applied to the loop iteration variable i, and L is some offset; K, L, and R are loop-invariant.\n+\/\/ Because R is never negative, this check can always be simplified to an unsigned check i*K+L <u R.\n+\n+\/\/ When a long loop over a 64-bit variable i (outer_iv) is decomposed into a series of shorter sub-loops over a 32-bit\n+\/\/ variable j (inner_iv), j ranges over a shorter interval j:[0,Z_2), where the limit is chosen to prevent various cases\n+\/\/ of 32-bit overflow (including multiplications j*K below).  In the sub-loop the logical value i is offset from j by a\n+\/\/ 64-bit constant C, so i ranges in i:C+[0,Z_2).\n+\n+\/\/ The union of all the C+[0,Z_2) ranges from the sub-loops must be identical to the whole range [A,B].  Assuming S>0,\n+\/\/ the first C must be A itself, and the next C value is the previous C+Z_2.  In each sub-loop, j counts up from zero\n+\/\/ and exits just before i=C+Z_2.\n+\n+\/\/ (N.B. If S<0 the formulas are different, because all the loops count downward.)\n+\n+\/\/ Returning to range checks, we see that each i*K+L <u R expands to (C+j)*K+L <u R, or j*K+Q <u R, where Q=(C*K+L).\n+\/\/ (Recall that K and L and R are loop-invariant scale, offset and range values for a particular R.C.)  This is still a\n+\/\/ 64-bit comparison, so the range check elimination logic will not apply to it.  (The R.C.E. transforms operate only on\n+\/\/ 32-bit indexes and comparisons, because they use 64-bit temporary values to avoid overflow; see\n+\/\/ PhaseIdealLoop::add_constraint.)\n+\n+\/\/ We must transform this comparison so that it gets the same answer, but by means of a 32-bit R.C. (using j not i) of\n+\/\/ the form j*K+L_2 <u32 R_2.  Note that L_2 and R_2 must be loop-invariant, but only with respect to the sub-loop.  Thus, the\n+\/\/ problem reduces to computing values for L_2 and R_2 (for each R.C. in the loop) in the loop header for the sub-loop.\n+\/\/ Then the standard R.C.E. transforms can take those as inputs and further compute the necessary minimum and maximum\n+\/\/ values for the 32-bit counter j within which the range checks can be eliminated.\n+\n+\/\/ So, given j*K+Q <u R, we need to find some j*K+L_2 <u32 R_2, where L_2 and R_2 fit in 32 bits, and the 32-bit operations do\n+\/\/ not overflow. We also need to cover the cases where i*K+L (= j*K+Q) overflows to a 64-bit negative, since that is\n+\/\/ allowed as an input to the R.C., as long as the R.C. as a whole fails.\n+\n+\/\/ If 32-bit multiplication j*K might overflow, we adjust the sub-loop limit Z_2 closer to zero to reduce j's range.\n+\n+\/\/ For each R.C. j*K+Q <u32 R, the range of mathematical values of j*K+Q in the sub-loop is [Q_min, Q_max), where\n+\/\/ Q_min=Q and Q_max=Z_2*K+Q.  Making the upper limit Q_max be exclusive helps it integrate correctly with the strict\n+\/\/ comparisons against R and R_2.  Sometimes a very high R will be replaced by an R_2 derived from the more moderate\n+\/\/ Q_max, and replacing one exclusive limit by another exclusive limit avoids off-by-one complexities.\n+\n+\/\/ N.B. If (S*K)<0 then the formulas for Q_min and Q_max may differ; the values may need to be swapped and adjusted to\n+\/\/ the correct type of bound (inclusive or exclusive).\n+\n+\/\/ Case A: Some Negatives (but no overflow).\n+\/\/ Number line:\n+\/\/ |s64_min   .    .    .    0    .    .    .   s64_max|\n+\/\/ |    .  Q_min..Q_max .    0    .    .    .     .    |  s64 negative\n+\/\/ |    .     .    .  Q_min..0..Q_max  .    .     .    |  small mixed\n+\/\/\n+\/\/ if Q_min <s64 0, then use this test:\n+\/\/ j*K + s32_trunc(Q_min) <u32 clamp(R, 0, Q_max)\n+\n+\/\/ If the 32-bit truncation loses information, no harm is done, since certainly the clamp also returns R_2=zero.\n+\n+\/\/ Case B: No Negatives.\n+\/\/ Number line:\n+\/\/ |s64_min   .    .    .    0    .    .    .   s64_max|\n+\/\/ |    .     .    .    .    0 Q_min..Q_max .     .    |  small positive\n+\/\/ |    .     .    .    .    0    . Q_min..Q_max  .    |  s64 positive\n+\/\/\n+\/\/ if both Q_min, Q_max >=s64 0, then use this test:\n+\/\/ j*K + 0 <u32 clamp(R, Q_min, Q_max) - Q_min\n+\/\/ or equivalently:\n+\/\/ j*K + 0 <u32 clamp(R - Q_min, 0, Q_max - Q_min)\n+\n+\/\/ Case C: Overflow in the 64-bit domain\n+\/\/ Number line:\n+\/\/ |..Q_max-2^64   .    .    0    .    .    .   Q_min..|  s64 overflow\n+\/\/\n+\/\/ if Q_min >=s64 0 but Q_max <s64 0, then use this test:\n+\/\/ j*K + 0 <u32 clamp(R, Q_min, R) - Q_min\n+\/\/ or equivalently:\n+\/\/ j*K + 0 <u32 clamp(R - Q_min, 0, R - Q_min)\n+\/\/ or also equivalently:\n+\/\/ j*K + 0 <u32 max(0, R - Q_min)\n+\/\/\n+\/\/ Here the clamp function is a simple 64-bit min\/max:\n+\/\/ clamp(X, L, H) := max(L, min(X, H))\n+\/\/ When degenerately L > H, it returns L not H.\n+\/\/\n+\/\/ Tests above can be merged into a single one:\n+\/\/ L_clamp = Q_min < 0 ? 0 : Q_min\n+\/\/ H_clamp = Q_max < Q_min ? R : Q_max\n+\/\/ j*K + Q_min - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp\n+\/\/ or equivalently:\n+\/\/ j*K + Q_min - L_clamp <u32 clamp(R - L_clamp, 0, H_clamp - L_clamp)\n+\/\/\n+\/\/ Readers may find the equivalent forms easier to reason about, but the forms given first generate better code.\n+\n+void PhaseIdealLoop::transform_long_range_checks(int stride_con, const Node_List &range_checks, Node* outer_phi,\n+                                                 Node* inner_iters_actual_int, Node* inner_phi,\n+                                                 Node* iv_add, LoopNode* inner_head) {\n+  Node* long_zero = _igvn.longcon(0);\n+  set_ctrl(long_zero, C->root());\n+\n+  for (uint i = 0; i < range_checks.size(); i++) {\n+    ProjNode* proj = range_checks.at(i)->as_Proj();\n+    ProjNode* unc_proj = proj->other_if_proj();\n+    RangeCheckNode* rc = proj->in(0)->as_RangeCheck();\n+    jlong scale = 0;\n+    Node* offset = NULL;\n+    Node* rc_bol = rc->in(1);\n+    Node* rc_cmp = rc_bol->in(1);\n+    if (rc_cmp->Opcode() == Op_CmpU) {\n+      \/\/ could be shared and have already been taken care of\n+      continue;\n+    }\n+    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, &scale, &offset, T_LONG);\n+    assert(ok, \"inconsistent: was tested before\");\n+    Node* range = rc_cmp->in(2);\n+    Node* c = rc->in(0);\n+    Node* entry_control = inner_head->in(LoopNode::EntryControl);\n+\n+    Node* R = range;\n+    Node* K = _igvn.longcon(scale);\n+    set_ctrl(K, this->C->root());\n+    Node* L = offset;\n+    Node* C = outer_phi;\n+    Node* Z_2 = new ConvI2LNode(inner_iters_actual_int, TypeLong::LONG);\n+    register_new_node(Z_2, entry_control);\n+\n+    \/\/ Start with 64-bit values:\n+    \/\/   i*K + L <u64 R\n+    \/\/   (C+j)*K + L <u64 R\n+    \/\/   j*K + L_2 <u64 R    where L_2 = C*K+L\n+    Node* L_2 = new MulLNode(C, K);\n+    register_new_node(L_2, entry_control);\n+    L_2 = new AddLNode(L_2, L);\n+    register_new_node(L_2, entry_control);\n+\n+    \/\/ Compute endpoints of the range of values j*K.\n+    \/\/  Q_min = (j=0)*K + L_2;  Q_max = (j=Z_2)*K + L_2\n+    Node* Q_min = L_2;\n+    Node* Q_max = new MulLNode(Z_2, K);\n+    register_new_node(Q_max, entry_control);\n+    Q_max = new AddLNode(Q_max, L_2);\n+    register_new_node(Q_max, entry_control);\n+\n+    \/\/ L_clamp = Q_min < 0 ? 0 : Q_min\n+    Node* Q_min_cmp = new CmpLNode(Q_min, long_zero);\n+    register_new_node(Q_min_cmp, entry_control);\n+    Node* Q_min_bool = new BoolNode(Q_min_cmp, BoolTest::lt);\n+    register_new_node(Q_min_bool, entry_control);\n+    Node* L_clamp = new CMoveLNode(Q_min_bool, Q_min, long_zero, TypeLong::LONG);\n+    register_new_node(L_clamp, entry_control);\n+\n+    \/\/ H_clamp = Q_max < Q_min ? R : Q_max\n+    Node* Q_max_cmp = new CmpLNode(Q_max, Q_min);\n+    register_new_node(Q_max_cmp, entry_control);\n+    Node* Q_max_bool = new BoolNode(Q_max_cmp, BoolTest::lt);\n+    register_new_node(Q_max_bool, entry_control);\n+    Node* H_clamp = new CMoveLNode(Q_max_bool, Q_max, R, TypeLong::LONG);\n+    register_new_node(H_clamp, entry_control);\n+\n+    \/\/ R_2 = clamp(R, L_clamp, H_clamp) - L_clamp\n+    \/\/ that is: R_2 = clamp(R, L_clamp, H_clamp) if Q_min < 0\n+    \/\/ or:      R_2 = clamp(R, L_clamp, H_clamp) - Q_min if Q_min > 0\n+    Node* R_2 = clamp(R, L_clamp, H_clamp);\n+    R_2 = new SubLNode(R_2, L_clamp);\n+    register_new_node(R_2, entry_control);\n+    R_2 = new ConvL2INode(R_2, TypeInt::POS);\n+    register_new_node(R_2, entry_control);\n+\n+    \/\/ Q = Q_min - L_clamp\n+    \/\/ that is: Q = Q_min - 0 if Q_min < 0\n+    \/\/ or:      Q = Q_min - Q_min = 0 if Q_min > 0\n+    Node* Q = new SubLNode(Q_min, L_clamp);\n+    register_new_node(Q, entry_control);\n+    Q = new ConvL2INode(Q, TypeInt::INT);\n+    register_new_node(Q, entry_control);\n+\n+    \/\/ Transform the range check\n+    K = _igvn.intcon(checked_cast<int>(scale));\n+    set_ctrl(K, this->C->root());\n+    Node* scaled_iv = new MulINode(inner_phi, K);\n+    register_new_node(scaled_iv, c);\n+    Node* scaled_iv_plus_offset = scaled_iv_plus_offset = new AddINode(scaled_iv, Q);\n+    register_new_node(scaled_iv_plus_offset, c);\n+\n+    Node* new_rc_cmp = new CmpUNode(scaled_iv_plus_offset, R_2);\n+    register_new_node(new_rc_cmp, c);\n+\n+    _igvn.replace_input_of(rc_bol, 1, new_rc_cmp);\n+  }\n+}\n+\n+Node* PhaseIdealLoop::clamp(Node* R, Node* L, Node* H) {\n+  Node* min = MaxNode::signed_min(R, H, TypeLong::LONG, _igvn);\n+  set_subtree_ctrl(min, true);\n+  Node* max = MaxNode::signed_max(L, min, TypeLong::LONG, _igvn);\n+  set_subtree_ctrl(max, true);\n+  return max;\n+}\n+\n@@ -1420,1 +1659,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_jint - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_signed_integer(iv_bt) - stride_m, iv_bt), iv_bt);\n@@ -1423,1 +1662,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_jint - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_signed_integer(iv_bt) - stride_m, iv_bt), iv_bt);\n@@ -1876,1 +2115,1 @@\n-    return NULL;  \/\/ Identity\n+    return bottom_type();  \/\/ Identity\n@@ -3958,2 +4197,5 @@\n-      bool is_counted = lpt->is_counted();\n-      if (!is_counted || !lpt->is_innermost()) continue;\n+      if (!lpt->is_loop()) {\n+        continue;\n+      }\n+      Node* head = lpt->_head;\n+      if (!head->is_BaseCountedLoop() || !lpt->is_innermost()) continue;\n@@ -3962,5 +4204,7 @@\n-      if (is_counted && lpt->_head->as_CountedLoop()->is_unroll_only()) {\n-        continue;\n-      } else {\n-        AutoNodeBudget node_budget(this);\n-        lpt->reassociate_invariants(this);\n+      if (head->is_CountedLoop()) {\n+        if (head->as_CountedLoop()->is_unroll_only()) {\n+          continue;\n+        } else {\n+          AutoNodeBudget node_budget(this);\n+          lpt->reassociate_invariants(this);\n+        }\n@@ -3971,5 +4215,2 @@\n-      if (SplitIfBlocks && do_split_ifs) {\n-        AutoNodeBudget node_budget(this, AutoNodeBudget::NO_BUDGET_CHECK);\n-        if (lpt->policy_range_check(this)) {\n-          lpt->_rce_candidate = 1; \/\/ = true\n-        }\n+      if (SplitIfBlocks && do_split_ifs && lpt->policy_range_check(this, true)) {\n+        lpt->_rce_candidate = 1; \/\/ = true\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":263,"deletions":22,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -737,1 +737,1 @@\n-  bool policy_range_check( PhaseIdealLoop *phase ) const;\n+  bool policy_range_check(PhaseIdealLoop* phase, bool provisional) const;\n@@ -741,0 +741,2 @@\n+  bool is_range_check_if(IfNode* iff, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n+                         jlong& scale) const;\n@@ -1171,1 +1173,1 @@\n-  void long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head);\n+  Node* long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head);\n@@ -1273,1 +1275,1 @@\n-  bool is_scaled_iv(Node* exp, Node* iv, int* p_scale);\n+  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt);\n@@ -1276,1 +1278,12 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset) {\n+    jlong long_scale;\n+    if (is_scaled_iv_plus_offset(exp, iv, &long_scale, p_offset, T_INT)) {\n+      int int_scale = checked_cast<int>(long_scale);\n+      if (p_scale != NULL) {\n+        *p_scale = int_scale;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n@@ -1626,0 +1639,8 @@\n+\n+  int extract_long_range_checks(const IdealLoopTree* loop, jlong stride_con, int iters_limit, PhiNode* phi,\n+                                      Node_List &range_checks);\n+\n+  void transform_long_range_checks(int stride_con, const Node_List &range_checks, Node* outer_phi,\n+                                   Node* inner_iters_actual_int, Node* inner_phi,\n+                                   Node* iv_add, LoopNode* inner_head);\n+\n@@ -1636,0 +1657,2 @@\n+  Node* clamp(Node* pNode, Node* pNode1, Node* pNode2);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1077,1 +1077,1 @@\n-  if (n_blk->is_CountedLoop()) {\n+  if (n_blk->is_BaseCountedLoop()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  MulNode( Node *in1, Node *in2 ): Node(0,in1,in2) {\n+  MulNode(Node *in1, Node *in2): Node(NULL,in1,in2) {\n@@ -78,0 +78,5 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+\n@@ -101,0 +106,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -119,0 +128,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n@@ -205,0 +218,11 @@\n+class LShiftNode : public Node {\n+public:\n+  LShiftNode(Node *in1, Node *in2) : Node(NULL,in1,in2) {\n+    init_class_id(Class_LShift);\n+  }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+};\n+\n@@ -207,1 +231,1 @@\n-class LShiftINode : public Node {\n+class LShiftINode : public LShiftNode {\n@@ -209,1 +233,1 @@\n-  LShiftINode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  LShiftINode(Node *in1, Node *in2) : LShiftNode(in1,in2) {}\n@@ -216,0 +240,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -220,1 +248,1 @@\n-class LShiftLNode : public Node {\n+class LShiftLNode : public LShiftNode {\n@@ -222,1 +250,1 @@\n-  LShiftLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  LShiftLNode(Node *in1, Node *in2) : LShiftNode(in1,in2) {}\n@@ -229,0 +257,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+class LShiftNode;\n@@ -757,0 +758,1 @@\n+    DEFINE_CLASS_ID(LShift,   Node, 18)\n@@ -886,0 +888,1 @@\n+  DEFINE_CLASS_QUERY(LShift)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -795,3 +795,1 @@\n-    jint int_con = (jint)l;\n-    assert(((long)int_con) == l, \"not an int\");\n-    return intcon(int_con);\n+    return intcon(checked_cast<jint>(l));\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n@@ -80,0 +84,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -93,0 +101,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @bug 8259609\n+ * @summary C2: optimize long range checks in long counted loops\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestLongRangeChecks\n+ *\/\n+\n+public class TestLongRangeChecks {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+\n+        \/\/ Loop is first transformed into a loop nest, long range\n+        \/\/ check into an int range check, the range check is hoisted\n+        \/\/ and the inner counted loop becomes empty so is optimized\n+        \/\/ out.\n+        for (long i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScalePos\")\n+    private void testStridePosScalePos_runner() {\n+        testStridePosScalePos(0, 100, 100, 0);\n+    }    \n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8259609\n+ * @summary C2: optimize long range checks in long counted loops\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.util\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -ea -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation TestLongRangeCheck\n+ *\n+ *\/\n+\n+import jdk.internal.util.Preconditions;\n+import sun.hotspot.WhiteBox;\n+import java.lang.reflect.Method;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class TestLongRangeCheck {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+     private static void assertIsCompiled(Method m) {\n+         if (!WHITE_BOX.isMethodCompiled(m) || WHITE_BOX.getMethodCompilationLevel(m) != CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n+             throw new RuntimeException(\"should still be compiled\");\n+         }\n+    }\n+\n+     private static void assertIsNotCompiled(Method m) {\n+         if (WHITE_BOX.isMethodCompiled(m) && WHITE_BOX.getMethodCompilationLevel(m) == CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n+             throw new RuntimeException(\"should have been deoptimized\");\n+         }\n+    }\n+\n+    private static void compile(Method m) {\n+        WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertIsCompiled(m);\n+    }\n+\n+    public static ClassLoader newClassLoader() {\n+        try {\n+            return new URLClassLoader(new URL[] {\n+                    Paths.get(System.getProperty(\"test.classes\",\".\")).toUri().toURL(),\n+            }, null);\n+        } catch (MalformedURLException e){\n+            throw new RuntimeException(\"Unexpected URL conversion failure\", e);\n+        }\n+    }\n+\n+    private static void test(String method, long start, long stop, long length, long offset) throws Exception {\n+        Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset); \/\/ run once so all classes are loaded\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start-1, stop, length, offset);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset); \/\/ run once so all classes are loaded\n+        compile(m);\n+        assertIsCompiled(m);\n+\n+        m.invoke(null, start, stop, length, offset);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, stop, stop + 100, length, offset);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset); \/\/ run once so all classes are loaded\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start, stop+1, length, offset);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        test(\"testStridePosScalePos\", 0, 100, 100, 0);\n+\n+        test(\"testStrideNegScaleNeg\", 0, 100, 100, 100);\n+\n+        test(\"testStrideNegScalePos\", 0, 100, 100, 0);\n+\n+        test(\"testStridePosScaleNeg\", 0, 100, 100, 99);\n+\n+        test(\"testStridePosScalePosNotOne\", 0, 100, 1090, 0);\n+\n+        test(\"testStrideNegScaleNegNotOne\", 0, 100, 1090, 1100);\n+\n+        test(\"testStrideNegScalePosNotOne\", 0, 100, 1090, 0);\n+\n+        test(\"testStridePosScaleNegNotOne\", 0, 100, 1090, 1089);\n+\n+        long v = ((long)Integer.MAX_VALUE \/ 10000) * 250000;\n+\n+        test(\"testStridePosNotOneScalePos\", -v, v, v * 2, v);\n+\n+        test(\"testStrideNegNotOneScaleNeg\", -v, v, v * 2, v);\n+\n+        test(\"testStrideNegNotOneScalePos\", -v, v, v * 2, v);\n+\n+        test(\"testStridePosNotOneScaleNeg\", -v, v, v * 2, v-1);\n+\n+        \/\/ offset causes overflow\n+\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePos\", long.class, long.class, long.class, long.class);\n+            m.invoke(null, 0, 100, 100, 0);\n+            compile(m);\n+\n+            m.invoke(null, 0, 100, 100, 0);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        \/\/ no spurious deopt if the range check doesn't fail because not executed\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, 0, 100, 100, 0, 0, 100);\n+            compile(m);\n+\n+            m.invoke(null, 0, 100, 100, -50, 50, 100);\n+            assertIsCompiled(m);\n+        }\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, 0, 100, 100, 0, 0, 100);\n+            compile(m);\n+\n+            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n+            assertIsCompiled(m);\n+        }\n+    }\n+\n+    public static void testStridePosScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosNotOne(long start, long stop, long length, long offset) {\n+        final long scale = 11;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegNotOne(long start, long stop, long length, long offset) {\n+        final long scale = -11;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosNotOne(long start, long stop, long length, long offset) {\n+        final long scale = 11;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegNotOne(long start, long stop, long length, long offset) {\n+        final long scale = -11;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = stop; i > start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        Preconditions.checkIndex(0, length, null);\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestLongRangeCheck.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8259609\n+ * @summary range checks with min int scale value\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation TestRCMinInt\n+ *\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class TestRCMinInt {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(0, 10, 10);\n+            test2(0, 10, 10);\n+        }\n+    }\n+\n+    private static float test1(int start, int stop, int offset) {\n+        float v = 1;\n+        for (int i = start; i < stop; i+=2) {\n+            final int index = offset + Integer.MIN_VALUE * i;\n+            Objects.checkIndex(index, 100);\n+        }\n+        return v;\n+    }\n+\n+    private static float test2(int start, int stop, int offset) {\n+        float v = 1;\n+        for (int i = start; i < stop; i+=2) {\n+            final int index = offset - Integer.MIN_VALUE * i;\n+            Objects.checkIndex(index, 100);\n+        }\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRCMinInt.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}