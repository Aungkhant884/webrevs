{"files":[{"patch":"@@ -909,1 +909,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which))\n@@ -911,1 +911,1 @@\n-  oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);\n+  oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, which);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -563,2 +563,5 @@\n-     * Gets the appendix object (if any) associated with the entry at index {@code cpi} in\n-     * {@code constantPool}.\n+     * Gets the appendix object (if any) associated with the entry identified by {@code which}.\n+     *\n+     * @param which if negative, is treated as an encoded indy index for INVOKEDYNAMIC;\n+     *              Otherwise, it's treated as a constant pool cache index (returned by HotSpotConstantPool::rawIndexToConstantPoolCacheIndex)\n+     *              for INVOKE{VIRTUAL,SPECIAL,STATIC,INTERFACE}.\n@@ -566,2 +569,2 @@\n-    HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return lookupAppendixInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, int which) {\n+        return lookupAppendixInPool(constantPool, constantPool.getConstantPoolPointer(), which);\n@@ -570,1 +573,1 @@\n-    private native HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,0 +50,13 @@\n+ *\n+ * The following convention is used in the jdk.vm.ci.hotspot package when accessing the ConstantPool with an index:\n+ * <ul>\n+ * <li>rawIndex - Index in the bytecode stream after the opcode (could be rewritten for some opcodes)<\/li>\n+ * <li>cpi -      The constant pool index (as specified in JVM Spec)<\/li>\n+ * <li>cpci -     The constant pool cache index, used only by the four bytecodes INVOKE{VIRTUAL,SPECIAL,STATIC,INTERFACE}.\n+ *                It's the same as {@code rawIndex + HotSpotVMConfig::constantPoolCpCacheIndexTag}. <\/li>\n+ * <li>which -    May be either a {@code rawIndex} or a {@code cpci}.<\/li>\n+ * <\/ul>\n+ *\n+ * Note that {@code cpci} and {@code which} are used only in the HotSpot-specific implementation. They\n+ * are not used by the public interface in jdk.vm.ci.meta.*.\n+ * After JDK-8301993, all uses of {@code cpci} and {@code which} will be replaced with {@code rawIndex}.\n@@ -255,7 +268,5 @@\n-        int index;\n-        if (opcode == Bytecodes.INVOKEDYNAMIC) {\n-            index = rawIndex;\n-            \/\/ See: ConstantPool::is_invokedynamic_index\n-            if (index >= 0) {\n-                throw new IllegalArgumentException(\"not an invokedynamic constant pool index \" + index);\n-            }\n+        if (opcode == Bytecodes.INVOKEINTERFACE ||\n+            opcode == Bytecodes.INVOKEVIRTUAL ||\n+            opcode == Bytecodes.INVOKESPECIAL ||\n+            opcode == Bytecodes.INVOKESTATIC) {\n+            return rawIndex + config().constantPoolCpCacheIndexTag;\n@@ -263,9 +274,2 @@\n-            if (opcode == Bytecodes.INVOKEINTERFACE ||\n-                opcode == Bytecodes.INVOKEVIRTUAL ||\n-                opcode == Bytecodes.INVOKESPECIAL ||\n-                opcode == Bytecodes.INVOKESTATIC) {\n-                index = rawIndex + config().constantPoolCpCacheIndexTag;\n-            } else {\n-                throw new IllegalArgumentException(\"unexpected opcode \" + opcode);\n-\n-            }\n+            \/\/ Only the above 4 bytecodes use ConstantPoolCacheIndex\n+            throw new IllegalArgumentException(\"unexpected opcode \" + opcode);\n@@ -273,1 +277,0 @@\n-        return index;\n@@ -584,2 +587,2 @@\n-    public BootstrapMethodInvocation lookupBootstrapMethodInvocation(int rawCpi, int opcode) {\n-        int cpi = opcode == -1 ? rawCpi : rawIndexToConstantPoolIndex(rawCpi, opcode);\n+    public BootstrapMethodInvocation lookupBootstrapMethodInvocation(int index, int opcode) {\n+        int cpi = opcode == -1 ? index : indyIndexConstantPoolIndex(index, opcode);\n@@ -688,1 +691,1 @@\n-    public JavaConstant lookupAppendix(int cpi, int opcode) {\n+    public JavaConstant lookupAppendix(int rawIndex, int opcode) {\n@@ -690,1 +693,1 @@\n-            throw new IllegalArgumentException(\"expected an invoke bytecode at \" + cpi + \", got \" + opcode);\n+            throw new IllegalArgumentException(\"expected an invoke bytecode for \" + rawIndex + \", got \" + opcode);\n@@ -693,2 +696,8 @@\n-        final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);\n-        return compilerToVM().lookupAppendixInPool(this, index);\n+        if (opcode == Bytecodes.INVOKEDYNAMIC) {\n+          if (!isInvokedynamicIndex(rawIndex)) {\n+              throw new IllegalArgumentException(\"expected a raw index for INVOKEDYNAMIC but got \" + rawIndex);\n+          }\n+          return compilerToVM().lookupAppendixInPool(this, rawIndex);\n+        } else {\n+          return compilerToVM().lookupAppendixInPool(this, rawIndexToConstantPoolCacheIndex(rawIndex, opcode));\n+        }\n@@ -712,3 +721,3 @@\n-    public JavaMethod lookupMethod(int cpi, int opcode, ResolvedJavaMethod caller) {\n-        final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);\n-        final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, index, (byte) opcode, (HotSpotResolvedJavaMethodImpl) caller);\n+    public JavaMethod lookupMethod(int rawIndex, int opcode, ResolvedJavaMethod caller) {\n+        final int cpci = rawIndexToConstantPoolCacheIndex(rawIndex, opcode);\n+        final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, cpci, (byte) opcode, (HotSpotResolvedJavaMethodImpl) caller);\n@@ -719,2 +728,2 @@\n-            String name = getNameOf(index, opcode);\n-            HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(index, opcode));\n+            String name = getNameOf(cpci, opcode);\n+            HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(cpci, opcode));\n@@ -724,1 +733,1 @@\n-                final int klassIndex = getKlassRefIndexAt(index, opcode);\n+                final int klassIndex = getKlassRefIndexAt(cpci, opcode);\n@@ -783,1 +792,0 @@\n-        final int cpi = compilerToVM().decodeFieldIndexToCPIndex(this, rawIndex);\n@@ -816,1 +824,1 @@\n-     * Converts a raw index from the bytecodes to a constant pool index (not a cache index).\n+     * Converts a raw index for the INVOKEDYNAMIC bytecode to a constant pool index.\n@@ -820,1 +828,1 @@\n-     * @param opcode bytecode to convert the index for\n+     * @param opcode bytecode to convert the index for. Must be INVOKEDYNAMIC.\n@@ -824,1 +832,1 @@\n-    public int rawIndexToConstantPoolIndex(int rawIndex, int opcode) {\n+    private int indyIndexConstantPoolIndex(int rawIndex, int opcode) {\n@@ -830,0 +838,2 @@\n+        } else {\n+          throw new IllegalArgumentException(\"expected a raw index for INVOKEDYNAMIC but got \" + rawIndex);\n@@ -831,11 +841,0 @@\n-        if (opcode == Bytecodes.INVOKEDYNAMIC) {\n-            throw new IllegalArgumentException(\"unexpected INVOKEDYNAMIC at \" + rawIndex);\n-        }\n-        if (opcode == Bytecodes.GETSTATIC ||\n-            opcode == Bytecodes.PUTSTATIC ||\n-            opcode == Bytecodes.GETFIELD ||\n-            opcode == Bytecodes.PUTFIELD) {\n-            return compilerToVM().decodeFieldIndexToCPIndex(this, rawIndex);\n-        }\n-        int index = rawIndexToConstantPoolCacheIndex(rawIndex, opcode);\n-        return compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-     * {@code CONSTANT_Dynamic_info} or {@code CONSTANT_InvokeDynamic_info} pool entry {@code cpi}\n+     * {@code CONSTANT_Dynamic_info} or {@code CONSTANT_InvokeDynamic_info} pool entry\n@@ -178,4 +178,6 @@\n-     * @param cpi a constant pool index\n-     * @param opcode the opcode of the instruction that has {@code cpi} as an operand or -1 if\n-     *            {@code cpi} was not decoded from an instruction stream\n-     * @return the bootstrap method invocation details or {@code null} if the entry at {@code cpi}\n+     * @param index if {@code opcode} is -1,  {@code index} is a constant pool index. Otherwise {@code opcode}\n+     *              must be {@code Bytecodes.INVOKEDYNAMIC}, and {@code index} must be the operand of that\n+     *              opcode in the bytecode stream (i.e., a {@code rawIndex}).\n+     * @param opcode must be {@code Bytecodes.INVOKEDYNAMIC}, or -1 if\n+     *            {@code index} was not decoded from a bytecode stream\n+     * @return the bootstrap method invocation details or {@code null} if the entry specified by {@code index}\n@@ -187,1 +189,1 @@\n-    default BootstrapMethodInvocation lookupBootstrapMethodInvocation(int cpi, int opcode) {\n+    default BootstrapMethodInvocation lookupBootstrapMethodInvocation(int index, int opcode) {\n@@ -245,3 +247,2 @@\n-     * @param cpi the constant pool index\n-     * @param opcode the opcode of the instruction for which the lookup is being performed or\n-     *            {@code -1}\n+     * @param rawIndex index in the bytecode stream after the {@code opcode} (could be rewritten for some opcodes)\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -250,1 +251,1 @@\n-    JavaConstant lookupAppendix(int cpi, int opcode);\n+    JavaConstant lookupAppendix(int rawIndex, int opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ConstantPool.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -274,2 +274,2 @@\n-        int cpi = getFirstInvokedynamicOperand(shouldNotBeCalled);\n-        BootstrapMethodInvocation bmi = cp.lookupBootstrapMethodInvocation(cpi, INVOKEDYNAMIC);\n+        int rawIndex = getFirstInvokedynamicOperand(shouldNotBeCalled);\n+        BootstrapMethodInvocation bmi = cp.lookupBootstrapMethodInvocation(rawIndex, INVOKEDYNAMIC);\n@@ -411,2 +411,2 @@\n-        int cpi = getFirstInvokedynamicOperand(method);\n-        cp.loadReferencedType(cpi, INVOKEDYNAMIC, false);\n+        int rawIndex = getFirstInvokedynamicOperand(method);\n+        cp.loadReferencedType(rawIndex, INVOKEDYNAMIC, false);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestDynamicConstant.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+\n@@ -43,0 +48,1 @@\n+import jdk.vm.ci.meta.JavaConstant;\n@@ -85,3 +91,6 @@\n-    public static final int ALOAD_0 = 42; \/\/ 0x2A\n-    public static final int GETSTATIC = 178; \/\/ 0xB2\n-    public static final int INVOKEVIRTUAL = 182; \/\/ 0xB6\n+    public static final int ICONST_0 = 3;\n+    public static final int ALOAD_0 = 42;\n+    public static final int ALOAD_1 = 43;\n+    public static final int GETSTATIC = 178;\n+    public static final int INVOKEVIRTUAL = 182;\n+    public static final int INVOKEDYNAMIC = 186;\n@@ -97,0 +106,4 @@\n+    public static int beS4(byte[] data, int bci) {\n+        return (data[bci] << 24) | ((data[bci + 1] & 0xff) << 16) | ((data[bci + 2] & 0xff) << 8) | (data[bci + 3] & 0xff);\n+    }\n+\n@@ -141,0 +154,82 @@\n+\n+    static String concatString1(String a, String b) {\n+        return a + b;\n+    }\n+\n+    static String concatString2(String a, String b) {\n+        return a + b;\n+    }\n+\n+    static void invokeHandle(MethodHandle mh) throws Throwable  {\n+        mh.invokeExact(0);\n+    }\n+\n+    static void intFunc(int t) {}\n+\n+    @Test\n+    public void lookupAppendixTest() throws Throwable {\n+        \/\/ We want at least two indy bytecodes -- with a single indy, the rawIndex is -1,\n+        \/\/ or 0xffffffff. Even if we load it with the wrong endianness, it will still come\n+        \/\/ \"correctly\" out as -1.\n+        concatString1(\"aaa\", \"bbb\"); \/\/ force the indy to be resolved\n+        concatString2(\"aaa\", \"bbb\"); \/\/ force the indy to be resolved\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodType mt = MethodType.methodType(void.class, int.class);\n+        MethodHandle mh = lookup.findStatic(ConstantPoolTest.class, \"intFunc\", mt);\n+        invokeHandle(mh);\n+\n+        lookupAppendixTest_dynamic(\"concatString1\");\n+        lookupAppendixTest_dynamic(\"concatString2\");\n+        lookupAppendixTest_virtual();\n+    }\n+\n+    public void lookupAppendixTest_dynamic(String methodName) throws Exception {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        ResolvedJavaType type = metaAccess.lookupJavaType(ConstantPoolTest.class);\n+        Signature methodSig = metaAccess.parseMethodDescriptor(\"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\");\n+        ResolvedJavaMethod m = type.findMethod(methodName, methodSig);\n+        Assert.assertNotNull(m);\n+\n+        \/\/ Expected:\n+        \/\/ aload_0;\n+        \/\/ aload_1;\n+        \/\/ invokedynamic ...StringConcatFactory.makeConcatWithConstants...\n+        byte[] bytecode = m.getCode();\n+        Assert.assertNotNull(bytecode);\n+        Assert.assertEquals(8, bytecode.length);\n+        Assert.assertEquals(ALOAD_0, beU1(bytecode, 0));\n+        Assert.assertEquals(ALOAD_1, beU1(bytecode, 1));\n+        Assert.assertEquals(INVOKEDYNAMIC, beU1(bytecode, 2));\n+\n+        \/\/ Note: internally HotSpot stores the indy index as a native int32, but m.getCode() byte-swaps all such\n+        \/\/ indices so they appear to be big-endian.\n+        int rawIndex = beS4(bytecode, 3);\n+        JavaConstant constant = m.getConstantPool().lookupAppendix(rawIndex, INVOKEDYNAMIC);\n+        Assert.assertTrue(constant.toString().startsWith(\"Object[\"), \"wrong appendix: \" + constant);\n+    }\n+\n+    public void lookupAppendixTest_virtual() throws Exception {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        ResolvedJavaType type = metaAccess.lookupJavaType(ConstantPoolTest.class);\n+        Signature methodSig = metaAccess.parseMethodDescriptor(\"(Ljava\/lang\/invoke\/MethodHandle;)V\");\n+        ResolvedJavaMethod m = type.findMethod(\"invokeHandle\", methodSig);\n+        Assert.assertNotNull(m);\n+\n+        \/\/ Expected\n+        \/\/ aload_0\n+        \/\/ iconst_0\n+        \/\/ invokevirtual #rawIndex \/\/ Method java\/lang\/invoke\/MethodHandle.invokeExact:(I)V\n+        byte[] bytecode = m.getCode();\n+        Assert.assertNotNull(bytecode);\n+        Assert.assertEquals(6, bytecode.length);\n+        Assert.assertEquals(ALOAD_0, beU1(bytecode, 0));\n+        Assert.assertEquals(ICONST_0, beU1(bytecode, 1));\n+        Assert.assertEquals(INVOKEVIRTUAL, beU1(bytecode, 2));\n+\n+        int rawIndex = beU2(bytecode, 3);\n+        \/\/System.out.println(\"rawIndex = \" + rawIndex);\n+        JavaConstant constant = m.getConstantPool().lookupAppendix(rawIndex, INVOKEVIRTUAL);\n+        \/\/System.out.println(\"constant = \" + constant);\n+        Assert.assertTrue(constant.toString().startsWith(\"Object[\"), \"wrong appendix: \" + constant);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/ConstantPoolTest.java","additions":98,"deletions":3,"binary":false,"changes":101,"status":"modified"}]}