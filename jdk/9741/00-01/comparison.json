{"files":[{"patch":"@@ -168,4 +168,2 @@\n-  \/\/ when last_Java_sp is non-null but the pc fetched is junk. If we are truly\n-  \/\/ unlucky the junk value could be to a zombied method and we'll die on the\n-  \/\/ find_blob call. This is also why we can have no asserts on the validity\n-  \/\/ of the pc we find here. AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n+  \/\/ when last_Java_sp is non-null but the pc fetched is junk.\n+  \/\/ AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-bool NativeInstruction::is_sigill_zombie_not_entrant() {\n+bool NativeInstruction::is_sigill_not_entrant() {\n@@ -480,1 +480,1 @@\n-         || nativeInstruction_at(verified_entry)->is_sigill_zombie_not_entrant(),\n+         || nativeInstruction_at(verified_entry)->is_sigill_not_entrant(),\n@@ -491,2 +491,1 @@\n-    \/\/ We use an illegal instruction for marking a method as\n-    \/\/ not_entrant or zombie.\n+    \/\/ We use an illegal instruction for marking a method as not_entrant.\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  bool is_sigill_zombie_not_entrant();\n+  bool is_sigill_not_entrant();\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-  a[0] = zombie_illegal_instruction; \/\/ always illegal\n+  a[0] = not_entrant_illegal_instruction; \/\/ always illegal\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  static const int zombie_illegal_instruction = 0xe7f000f0;\n+  static const int not_entrant_illegal_instruction = 0xe7f000f0;\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-\/\/ We use an illtrap for marking a method as not_entrant or zombie\n+\/\/ We use an illtrap for marking a method as not_entrant\n@@ -45,1 +45,1 @@\n-bool NativeInstruction::is_sigill_zombie_not_entrant_at(address addr) {\n+bool NativeInstruction::is_sigill_not_entrant_at(address addr) {\n@@ -346,1 +346,1 @@\n-    \/\/ We use an illtrap for marking a method as not_entrant or zombie.\n+    \/\/ We use an illtrap for marking a method as not_entrant.\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-  \/\/ We use an illtrap for marking a method as not_entrant or zombie.\n-  bool is_sigill_zombie_not_entrant() {\n+  \/\/ We use an illtrap for marking a method as not_entrant.\n+  bool is_sigill_not_entrant() {\n@@ -73,1 +73,1 @@\n-    return NativeInstruction::is_sigill_zombie_not_entrant_at(addr_at(0));\n+    return NativeInstruction::is_sigill_not_entrant_at(addr_at(0));\n@@ -75,1 +75,1 @@\n-  static bool is_sigill_zombie_not_entrant_at(address addr);\n+  static bool is_sigill_not_entrant_at(address addr);\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,4 +118,2 @@\n-  \/\/ when last_Java_sp is non-null but the pc fetched is junk. If we are truly\n-  \/\/ unlucky the junk value could be to a zombied method and we'll die on the\n-  \/\/ find_blob call. This is also why we can have no asserts on the validity\n-  \/\/ of the pc we find here. AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n+  \/\/ when last_Java_sp is non-null but the pc fetched is junk.\n+  \/\/ AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-bool NativeInstruction::is_sigill_zombie_not_entrant() {\n+bool NativeInstruction::is_sigill_not_entrant() {\n@@ -348,1 +348,1 @@\n-\/\/ nmethod::make_not_entrant_or_zombie)\n+\/\/ nmethod::make_not_entrant)\n@@ -355,1 +355,1 @@\n-         nativeInstruction_at(verified_entry)->is_sigill_zombie_not_entrant(),\n+         nativeInstruction_at(verified_entry)->is_sigill_not_entrant(),\n@@ -374,1 +374,1 @@\n-    \/\/ not_entrant or zombie.\n+    \/\/ not_entrant.\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-  bool is_sigill_zombie_not_entrant();\n+  bool is_sigill_not_entrant();\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,2 +171,2 @@\n-\/\/ We use an illtrap for marking a method as not_entrant or zombie.\n-bool NativeInstruction::is_sigill_zombie_not_entrant() {\n+\/\/ We use an illtrap for marking a method as not_entrant.\n+bool NativeInstruction::is_sigill_not_entrant() {\n@@ -184,1 +184,1 @@\n-  \/\/ This method is not_entrant or zombie if the illtrap instruction\n+  \/\/ This method is not_entrant if the illtrap instruction\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-  \/\/ We use an illtrap for marking a method as not_entrant or zombie.\n-  bool is_sigill_zombie_not_entrant();\n+  \/\/ We use an illtrap for marking a method as not_entrant.\n+  bool is_sigill_not_entrant();\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,4 +156,2 @@\n-  \/\/ when last_Java_sp is non-null but the pc fetched is junk. If we are truly\n-  \/\/ unlucky the junk value could be to a zombied method and we'll die on the\n-  \/\/ find_blob call. This is also why we can have no asserts on the validity\n-  \/\/ of the pc we find here. AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n+  \/\/ when last_Java_sp is non-null but the pc fetched is junk.\n+  \/\/ AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -498,1 +498,1 @@\n-\/\/ MT safe inserting of a jump over an unknown instruction sequence (used by nmethod::makeZombie)\n+\/\/ MT safe inserting of a jump over an unknown instruction sequence (used by nmethod::make_not_entrant)\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/ This method is called by nmethod::make_not_entrant_or_zombie to\n+\/\/ This method is called by nmethod::make_not_entrant to\n","filename":"src\/hotspot\/cpu\/zero\/nativeInst_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2700,1 +2700,1 @@\n-      if (nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+      if (nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n@@ -2702,1 +2702,1 @@\n-          tty->print_cr(\"trap: zombie_not_entrant\");\n+          tty->print_cr(\"trap: not_entrant\");\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-      \/\/   Safepoints, Unreachable Code, Entry points of Zombie methods,\n+      \/\/   Safepoints, Unreachable Code, Entry points of not entrant nmethods,\n@@ -205,1 +205,1 @@\n-      \/\/     - zombie methods\n+      \/\/     - not entrant nmethods\n@@ -228,1 +228,1 @@\n-      if (sig == SIGILL && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+      if (sig == SIGILL && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n@@ -230,1 +230,1 @@\n-          tty->print_cr(\"trap: zombie_not_entrant\");\n+          tty->print_cr(\"trap: not_entrant\");\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+          && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n@@ -251,1 +251,1 @@\n-          tty->print_cr(\"trap: zombie_not_entrant\");\n+          tty->print_cr(\"trap: not_entrant\");\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+          && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n@@ -212,1 +212,1 @@\n-          tty->print_cr(\"trap: zombie_not_entrant (%s)\", (sig == SIGTRAP) ? \"SIGTRAP\" : \"SIGILL\");\n+          tty->print_cr(\"trap: not_entrant (%s)\", (sig == SIGTRAP) ? \"SIGTRAP\" : \"SIGILL\");\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -338,2 +338,2 @@\n-      } else if (sig == SIGILL && *(int *)pc == NativeInstruction::zombie_illegal_instruction) {\n-        \/\/ Zombie\n+      } else if (sig == SIGILL && *(int *)pc == NativeInstruction::not_entrant_illegal_instruction) {\n+        \/\/ Not entrant\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-      if (sig == SIGILL && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+      if (sig == SIGILL && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n@@ -253,1 +253,1 @@\n-          tty->print_cr(\"trap: zombie_not_entrant\");\n+          tty->print_cr(\"trap: not_entrant\");\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+          && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n@@ -213,1 +213,1 @@\n-          tty->print_cr(\"trap: zombie_not_entrant (%s)\", (sig == SIGTRAP) ? \"SIGTRAP\" : \"SIGILL\");\n+          tty->print_cr(\"trap: not_entrant (%s)\", (sig == SIGTRAP) ? \"SIGTRAP\" : \"SIGILL\");\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-      if (sig == SIGILL && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+      if (sig == SIGILL && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n@@ -247,1 +247,1 @@\n-          tty->print_cr(\"trap: zombie_not_entrant (SIGILL)\");\n+          tty->print_cr(\"trap: not_entrant (SIGILL)\");\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1290,1 +1290,1 @@\n-\/\/ Remove this method when zombied or unloaded.\n+\/\/ Remove this method when flushed.\n@@ -1643,1 +1643,1 @@\n-  tty->print_cr(\"\\nnmethod size distribution (non-zombie java)\");\n+  tty->print_cr(\"\\nnmethod size distribution\");\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -219,12 +219,10 @@\n-                             ,                         \"nMethod (zombie)\"\n-                             ,                              \"nMethod (unloaded)\"\n-                             ,                                   \"runtime stub\"\n-                             ,                                        \"ricochet stub\"\n-                             ,                                             \"deopt stub\"\n-                             ,                                                  \"uncommon trap stub\"\n-                             ,                                                       \"exception stub\"\n-                             ,                                                            \"safepoint stub\"\n-                             ,                                                                 \"adapter blob\"\n-                             ,                                                                      \"MH adapter blob\"\n-                             ,                                                                           \"buffer blob\"\n-                             ,                                                                                \"lastType\"\n+                             ,                         \"runtime stub\"\n+                             ,                              \"ricochet stub\"\n+                             ,                                   \"deopt stub\"\n+                             ,                                        \"uncommon trap stub\"\n+                             ,                                             \"exception stub\"\n+                             ,                                                  \"safepoint stub\"\n+                             ,                                                       \"adapter blob\"\n+                             ,                                                            \"MH adapter blob\"\n+                             ,                                                                 \"buffer blob\"\n+                             ,                                                                      \"lastType\"\n@@ -252,2 +250,0 @@\n-static unsigned int nBlocks_dead          = 0;  \/\/ counting \"zombie\" and \"unloaded\" methods only.\n-static unsigned int nBlocks_unloaded      = 0;  \/\/ counting \"unloaded\" nmethods only. This is a transient state.\n@@ -317,2 +313,0 @@\n-    nBlocks_dead          = CodeHeapStatArray[ix].nBlocks_dead;\n-    nBlocks_unloaded      = CodeHeapStatArray[ix].nBlocks_unloaded;\n@@ -336,2 +330,0 @@\n-    nBlocks_dead          = 0;\n-    nBlocks_unloaded      = 0;\n@@ -359,2 +351,0 @@\n-    CodeHeapStatArray[ix].nBlocks_dead          = nBlocks_dead;\n-    CodeHeapStatArray[ix].nBlocks_unloaded      = nBlocks_unloaded;\n@@ -648,2 +638,0 @@\n-    nBlocks_dead     = 0;\n-    nBlocks_unloaded = 0;\n@@ -681,2 +669,0 @@\n-    size_t       deadSpace     = 0;\n-    size_t       unloadedSpace = 0;\n@@ -967,1 +953,0 @@\n-              \/\/ must be a stub, if it's not a dead or alive nMethod\n@@ -1036,1 +1021,0 @@\n-                \/\/ must be a stub, if it's not a dead or alive nMethod\n@@ -1059,2 +1043,0 @@\n-      ast->print_cr(\"  unloadedSpace  = \" SIZE_FORMAT_W(8) \"k, nBlocks_unloaded = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity\", unloadedSpace\/(size_t)K, nBlocks_unloaded, (100.0*unloadedSpace)\/size, (100.0*unloadedSpace)\/res_size);\n-      ast->print_cr(\"  deadSpace      = \" SIZE_FORMAT_W(8) \"k, nBlocks_dead     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity\", deadSpace\/(size_t)K,     nBlocks_dead,     (100.0*deadSpace)\/size,     (100.0*deadSpace)\/res_size);\n@@ -1090,3 +1072,0 @@\n-        if (StatArray[ix].dead_count > granule_segs) {\n-          out->print_cr(\"dead_count[%d] = %d\", ix, StatArray[ix].dead_count);\n-        }\n@@ -1105,3 +1084,0 @@\n-        if (StatArray[ix].dead_space > granule_segs) {\n-          out->print_cr(\"dead_space[%d] = %d\", ix, StatArray[ix].dead_space);\n-        }\n@@ -1109,1 +1085,1 @@\n-        if ((size_t)(StatArray[ix].t1_count+StatArray[ix].t2_count+StatArray[ix].tx_count+StatArray[ix].stub_count+StatArray[ix].dead_count) > granule_segs) {\n+        if ((size_t)(StatArray[ix].t1_count+StatArray[ix].t2_count+StatArray[ix].tx_count+StatArray[ix].stub_count) > granule_segs) {\n@@ -1112,1 +1088,1 @@\n-        if ((size_t)(StatArray[ix].t1_space+StatArray[ix].t2_space+StatArray[ix].tx_space+StatArray[ix].stub_space+StatArray[ix].dead_space) > granule_segs) {\n+        if ((size_t)(StatArray[ix].t1_space+StatArray[ix].t2_space+StatArray[ix].tx_space+StatArray[ix].stub_space) > granule_segs) {\n@@ -1282,1 +1258,1 @@\n-    ast->print_cr(\"%18s %13s %17s %4s %9s  %5s %s\",      \"Addr(module)      \", \"offset\", \"size\", \"type\", \" type lvl\", \" temp\", \"Name\");\n+    ast->print_cr(\"%18s %13s %17s %9s  %5s %s\",      \"Addr(module)      \", \"offset\", \"size\", \"type\", \" type lvl\", \"Name\");\n@@ -1671,1 +1647,1 @@\n-                           + StatArray[ix].stub_count + StatArray[ix].dead_count;\n+                           + StatArray[ix].stub_count;\n@@ -1758,20 +1734,0 @@\n-  {\n-    if (nBlocks_dead > 0) {\n-      printBox(ast, '-', \"Dead nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n-\n-      granules_per_line = 128;\n-      for (unsigned int ix = 0; ix < alloc_granules; ix++) {\n-        print_line_delim(out, ast, low_bound, ix, granules_per_line);\n-        if (segment_granules && StatArray[ix].dead_count > 0) {\n-          print_blobType_single(ast, StatArray[ix].type);\n-        } else {\n-          print_count_single(ast, StatArray[ix].dead_count);\n-        }\n-      }\n-      ast->print(\"|\");\n-    } else {\n-      ast->print(\"No dead nMethods found in CodeHeap.\");\n-    }\n-    BUFFEREDSTREAM_FLUSH_LOCKED(\"\\n\\n\\n\")\n-  }\n-\n@@ -1780,1 +1736,1 @@\n-      printBox(ast, '-', \"Count by tier (combined, no dead blocks): <#t1>:<#t2>:<#s>, 0x0..0xf. '*' indicates >= 16 blocks\", NULL);\n+      printBox(ast, '-', \"Count by tier (combined): <#t1>:<#t2>:<#s>, 0x0..0xf. '*' indicates >= 16 blocks\", NULL);\n@@ -1852,1 +1808,1 @@\n-                              + StatArray[ix].stub_space + StatArray[ix].dead_space;\n+                              + StatArray[ix].stub_space;\n@@ -1939,16 +1895,0 @@\n-  {\n-    if (nBlocks_dead > 0) {\n-      printBox(ast, '-', \"Dead space consumption. ' ' indicates empty, '*' indicates full\", NULL);\n-\n-      granules_per_line = 128;\n-      for (unsigned int ix = 0; ix < alloc_granules; ix++) {\n-        print_line_delim(out, ast, low_bound, ix, granules_per_line);\n-        print_space_single(ast, StatArray[ix].dead_space);\n-      }\n-      ast->print(\"|\");\n-    } else {\n-      ast->print(\"No dead nMethods found in CodeHeap.\");\n-    }\n-    BUFFEREDSTREAM_FLUSH_LOCKED(\"\\n\\n\\n\")\n-  }\n-\n@@ -2149,1 +2089,1 @@\n-                           StatArray[ix].stub_count + StatArray[ix].dead_count;\n+                           StatArray[ix].stub_count;\n@@ -2192,1 +2132,1 @@\n-          ast->print_cr(\"%18s %13s %17s %9s  %5s %18s  %s\", \"Addr(module)      \", \"offset\", \"size\", \" type lvl\", \" temp\", \"blobType          \", \"Name\");\n+          ast->print_cr(\"%18s %13s %17s %9s  %18s  %s\", \"Addr(module)      \", \"offset\", \"size\", \" type lvl\", \"blobType          \", \"Name\");\n@@ -2217,1 +2157,1 @@\n-          ast->fill_to(62+6);\n+          ast->fill_to(62);\n@@ -2219,1 +2159,1 @@\n-          ast->fill_to(82+6);\n+          ast->fill_to(82);\n@@ -2239,1 +2179,1 @@\n-          ast->fill_to(62+6);\n+          ast->fill_to(62);\n@@ -2241,1 +2181,1 @@\n-          ast->fill_to(82+6);\n+          ast->fill_to(82);\n@@ -2244,1 +2184,1 @@\n-          ast->fill_to(62+6);\n+          ast->fill_to(62);\n","filename":"src\/hotspot\/share\/code\/codeHeapState.cpp","additions":23,"deletions":83,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -370,2 +370,0 @@\n-  \/\/ A zombie transition will always be safe, since the metadata has already been set to NULL, so\n-  \/\/ we only need to patch the destination\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-  \/\/ If the method is not entrant or zombie then a JMP is plastered over the\n+  \/\/ If the method is not entrant then a JMP is plastered over the\n@@ -511,1 +511,0 @@\n-  \/\/ Ok, to lookup references to zombies here\n@@ -515,1 +514,1 @@\n-    \/\/ Clean inline caches pointing to both zombie and not_entrant methods\n+    \/\/ Clean inline caches pointing to bad nmethods\n@@ -595,2 +594,1 @@\n-  \/\/ Find all calls in an nmethod and clear the ones that point to non-entrant,\n-  \/\/ zombie and unloaded nmethods.\n+  \/\/ Find all calls in an nmethod and clear the ones that point to bad nmethods.\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,2 +71,0 @@\n-    \/\/ since dependencies aren't removed until an nmethod becomes a zombie,\n-    \/\/ the dependency list may contain nmethods which aren't alive.\n@@ -140,34 +138,0 @@\n-\/\/\n-\/\/ Remove an nmethod dependency from the context.\n-\/\/ Decrement count of the nmethod in the dependency list and, optionally, remove\n-\/\/ the bucket completely when the count goes to 0.  This method must find\n-\/\/ a corresponding bucket otherwise there's a bug in the recording of dependencies.\n-\/\/ Can be called concurrently by parallel GC threads.\n-\/\/\n-void DependencyContext::remove_dependent_nmethod(nmethod* nm) {\n-  assert_locked_or_safepoint(CodeCache_lock);\n-  nmethodBucket* first = dependencies_not_unloading();\n-  nmethodBucket* last = NULL;\n-  for (nmethodBucket* b = first; b != NULL; b = b->next_not_unloading()) {\n-    if (nm == b->get_nmethod()) {\n-      int val = b->decrement();\n-      guarantee(val >= 0, \"Underflow: %d\", val);\n-      if (val == 0) {\n-        if (last == NULL) {\n-          \/\/ If there was not a head that was not unloading, we can set a new\n-          \/\/ head without a CAS, because we know there is no contending cleanup.\n-          set_dependencies(b->next_not_unloading());\n-        } else {\n-          \/\/ Only supports a single inserting thread (protected by CodeCache_lock)\n-          \/\/ for now. Therefore, the next pointer only competes with another cleanup\n-          \/\/ operation. That interaction does not need a CAS.\n-          last->set_next(b->next_not_unloading());\n-        }\n-        release(b);\n-      }\n-      return;\n-    }\n-    last = b;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-  void remove_dependent_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1166,1 +1166,0 @@\n-        \/\/ Ok, to lookup references to zombies here\n@@ -1171,1 +1170,1 @@\n-          \/\/ Verify that inline caches pointing to both zombie and not_entrant methods are clean\n+          \/\/ Verify that inline caches pointing to bad nmethods are clean\n@@ -1184,1 +1183,1 @@\n-          \/\/ Verify that inline caches pointing to both zombie and not_entrant methods are clean\n+          \/\/ Verify that inline caches pointing to bad nmethods are clean\n@@ -1308,0 +1307,8 @@\n+    BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+    if (bs_nm == nullptr || !bs_nm->supports_entry_barrier(this)) {\n+      \/\/ If nmethod entry barriers are not supported, we won't mark\n+      \/\/ nmethods as on-stack when they become on-stack. So we\n+      \/\/ degrade to a less accurate flushing strategy, for now.\n+      mark_as_maybe_on_stack();\n+    }\n+\n@@ -1348,1 +1355,1 @@\n-  flush_dependencies(false \/* delete_immediately *\/);\n+  flush_dependencies();\n@@ -1421,18 +1428,3 @@\n-\/\/ longer dependent. This should only be called in two situations.\n-\/\/ First, when a nmethod transitions to a zombie all dependents need\n-\/\/ to be clear.  Since zombification happens at a safepoint there's no\n-\/\/ synchronization issues.  The second place is a little more tricky.\n-\/\/ During phase 1 of mark sweep class unloading may happen and as a\n-\/\/ result some nmethods may get unloaded.  In this case the flushing\n-\/\/ of dependencies must happen during phase 1 since after GC any\n-\/\/ dependencies in the unloaded nmethod won't be updated, so\n-\/\/ traversing the dependency information in unsafe.  In that case this\n-\/\/ function is called with a boolean argument and this function only\n-\/\/ notifies instanceKlasses that are reachable\n-\n-void nmethod::flush_dependencies(bool delete_immediately) {\n-  DEBUG_ONLY(bool called_by_gc = Universe::heap()->is_gc_active() ||\n-                                 Thread::current()->is_ConcurrentGC_thread() ||\n-                                 Thread::current()->is_Worker_thread();)\n-  assert(called_by_gc != delete_immediately,\n-  \"delete_immediately is false if and only if we are called during GC\");\n+\/\/ longer dependent.\n+\n+void nmethod::flush_dependencies() {\n@@ -1445,6 +1437,1 @@\n-        if (delete_immediately) {\n-          assert_locked_or_safepoint(CodeCache_lock);\n-          MethodHandles::remove_dependent_nmethod(call_site, this);\n-        } else {\n-          MethodHandles::clean_dependency_context(call_site);\n-        }\n+        MethodHandles::clean_dependency_context(call_site);\n@@ -1456,9 +1443,3 @@\n-        \/\/ During GC delete_immediately is false, and liveness\n-        \/\/ of dependee determines class that needs to be updated.\n-        if (delete_immediately) {\n-          assert_locked_or_safepoint(CodeCache_lock);\n-          InstanceKlass::cast(klass)->remove_dependent_nmethod(this);\n-        } else if (klass->is_loader_alive()) {\n-          \/\/ The GC may clean dependency contexts concurrently and in parallel.\n-          InstanceKlass::cast(klass)->clean_dependency_context();\n-        }\n+        \/\/ During GC liveness of dependee determines class that needs to be updated.\n+        \/\/ The GC may clean dependency contexts concurrently and in parallel.\n+        InstanceKlass::cast(klass)->clean_dependency_context();\n@@ -1603,0 +1584,8 @@\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm == nullptr || !bs_nm->supports_entry_barrier(this)) {\n+    \/\/ On platforms that don't support nmethod entry barriers, we can't\n+    \/\/ trust the temporal aspect of the gc epochs. So we can't detect\n+    \/\/ cold nmethods on such platforms.\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":26,"deletions":37,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-  volatile signed char _state;         \/\/ {not_installed, in_use, not_entrant, zombie, unloaded}\n+  volatile signed char _state;         \/\/ {not_installed, in_use, not_entrant}\n@@ -469,1 +469,1 @@\n-  void flush_dependencies(bool delete_immediately);\n+  void flush_dependencies();\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,3 +243,0 @@\n-  \/\/ For unloaded methods the transition to zombie occurs after the\n-  \/\/ method is cleared so it's impossible to report accurate\n-  \/\/ information for that case.\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    return new BarrierSetNMethod();\n+    return NOT_ARM32(new BarrierSetNMethod()) ARM32_ONLY(nullptr);\n@@ -79,1 +79,3 @@\n-  thread->set_nmethod_disarm_value(bs_nm->disarmed_value());\n+  if (bs_nm != nullptr) {\n+    thread->set_nmethod_disarm_value(bs_nm->disarmed_value());\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2345,4 +2345,0 @@\n-void InstanceKlass::remove_dependent_nmethod(nmethod* nm) {\n-  dependencies().remove_dependent_nmethod(nm);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -942,1 +942,0 @@\n-  void remove_dependent_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1168,3 +1168,0 @@\n-  \/\/ If the vep() points to the zombie nmethod, the memory for the nmethod\n-  \/\/ could be flushed and the compiler and vtable stubs could still call\n-  \/\/ through it.\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1079,1 +1079,1 @@\n-  \/\/ Post events while nmethods are still in the queue and can't be unloaded or made zombie\n+  \/\/ Post events while nmethods are still in the queue and can't be unloaded.\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1058,8 +1058,0 @@\n-void MethodHandles::remove_dependent_nmethod(oop call_site, nmethod* nm) {\n-  assert_locked_or_safepoint(CodeCache_lock);\n-\n-  oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);\n-  DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);\n-  deps.remove_dependent_nmethod(nm);\n-}\n-\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-  static void remove_dependent_nmethod(oop call_site, nmethod* nm);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-          \"Create zombies (non-entrant) at exit from the runtime system\")   \\\n+          \"Create non-entrant nmethods at exit from the runtime system\")    \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-  \/\/ wrong method handling (inline cache misses, zombie methods)\n+  \/\/ wrong method handling (inline cache misses)\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"code\/dependencyContext.hpp\"\n-#include \"code\/nmethod.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"unittest.hpp\"\n-\n-class TestDependencyContext {\n- public:\n-  nmethod _nmethods[3];\n-\n-  nmethodBucket* volatile _dependency_context;\n-  volatile uint64_t _last_cleanup;\n-\n-  DependencyContext dependencies() {\n-    DependencyContext depContext(&_dependency_context, &_last_cleanup);\n-    return depContext;\n-  }\n-\n-  TestDependencyContext()\n-    : _dependency_context(NULL),\n-      _last_cleanup(0) {\n-    CodeCache_lock->lock_without_safepoint_check();\n-\n-    _nmethods[0].clear_unloading_state();\n-    _nmethods[1].clear_unloading_state();\n-    _nmethods[2].clear_unloading_state();\n-\n-    dependencies().add_dependent_nmethod(&_nmethods[2]);\n-    dependencies().add_dependent_nmethod(&_nmethods[1]);\n-    dependencies().add_dependent_nmethod(&_nmethods[0]);\n-  }\n-\n-  ~TestDependencyContext() {\n-    wipe();\n-    CodeCache_lock->unlock();\n-  }\n-\n-  void wipe() {\n-    DependencyContext ctx(&_dependency_context, &_last_cleanup);\n-    nmethodBucket* b = ctx.dependencies();\n-    ctx.set_dependencies(NULL);\n-    while (b != NULL) {\n-      nmethodBucket* next = b->next();\n-      delete b;\n-      b = next;\n-    }\n-  }\n-};\n-\n-static void test_remove_dependent_nmethod(int id) {\n-  TestDependencyContext c;\n-  DependencyContext depContext = c.dependencies();\n-\n-  nmethod* nm = &c._nmethods[id];\n-  depContext.remove_dependent_nmethod(nm);\n-\n-  ASSERT_FALSE(depContext.is_dependent_nmethod(nm));\n-}\n-\n-TEST_VM(code, dependency_context) {\n-  test_remove_dependent_nmethod(0);\n-  test_remove_dependent_nmethod(1);\n-  test_remove_dependent_nmethod(2);\n-}\n","filename":"test\/hotspot\/gtest\/code\/test_dependencyContext.cpp","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"}]}