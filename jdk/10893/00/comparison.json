{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import sun.security.util.CurveDB;\n+import sun.security.util.KnownOIDs;\n@@ -48,1 +50,1 @@\n-public class ECOperations {\n+public sealed class ECOperations {\n@@ -75,1 +77,1 @@\n-        if (!(curve.getField() instanceof ECFieldFp)) {\n+        if (!(curve.getField() instanceof ECFieldFp primeField)) {\n@@ -78,1 +80,0 @@\n-        ECFieldFp primeField = (ECFieldFp) curve.getField();\n@@ -196,29 +197,0 @@\n-    \/*\n-     * 4-bit branchless array lookup for projective points.\n-     *\/\n-    private void lookup4(ProjectivePoint.Immutable[] arr, int index,\n-        ProjectivePoint.Mutable result, IntegerModuloP zero) {\n-\n-        for (int i = 0; i < 16; i++) {\n-            int xor = index ^ i;\n-            int bit3 = (xor & 0x8) >>> 3;\n-            int bit2 = (xor & 0x4) >>> 2;\n-            int bit1 = (xor & 0x2) >>> 1;\n-            int bit0 = (xor & 0x1);\n-            int inverse = bit0 | bit1 | bit2 | bit3;\n-            int set = 1 - inverse;\n-\n-            ProjectivePoint.Immutable pi = arr[i];\n-            result.conditionalSet(pi, set);\n-        }\n-    }\n-\n-    private void double4(ProjectivePoint.Mutable p, MutableIntegerModuloP t0,\n-        MutableIntegerModuloP t1, MutableIntegerModuloP t2,\n-        MutableIntegerModuloP t3, MutableIntegerModuloP t4) {\n-\n-        for (int i = 0; i < 4; i++) {\n-            setDouble(p, t0, t1, t2, t3, t4);\n-        }\n-    }\n-\n@@ -234,0 +206,2 @@\n+        return PointMultiplier.of(this, affineP).pointMultiply(s);\n+    }\n@@ -235,51 +209,2 @@\n-        \/\/ 4-bit windowed multiply with branchless lookup.\n-        \/\/ The mixed addition is faster, so it is used to construct the array\n-        \/\/ at the beginning of the operation.\n-\n-        IntegerFieldModuloP field = affineP.getX().getField();\n-        ImmutableIntegerModuloP zero = field.get0();\n-        \/\/ temporaries\n-        MutableIntegerModuloP t0 = zero.mutable();\n-        MutableIntegerModuloP t1 = zero.mutable();\n-        MutableIntegerModuloP t2 = zero.mutable();\n-        MutableIntegerModuloP t3 = zero.mutable();\n-        MutableIntegerModuloP t4 = zero.mutable();\n-\n-        ProjectivePoint.Mutable result = new ProjectivePoint.Mutable(field);\n-        result.getY().setValue(field.get1().mutable());\n-\n-        ProjectivePoint.Immutable[] pointMultiples =\n-            new ProjectivePoint.Immutable[16];\n-        \/\/ 0P is neutral---same as initial result value\n-        pointMultiples[0] = result.fixed();\n-\n-        ProjectivePoint.Mutable ps = new ProjectivePoint.Mutable(field);\n-        ps.setValue(affineP);\n-        \/\/ 1P = P\n-        pointMultiples[1] = ps.fixed();\n-\n-        \/\/ the rest are calculated using mixed point addition\n-        for (int i = 2; i < 16; i++) {\n-            setSum(ps, affineP, t0, t1, t2, t3, t4);\n-            pointMultiples[i] = ps.fixed();\n-        }\n-\n-        ProjectivePoint.Mutable lookupResult = ps.mutable();\n-\n-        for (int i = s.length - 1; i >= 0; i--) {\n-\n-            double4(result, t0, t1, t2, t3, t4);\n-\n-            int high = (0xFF & s[i]) >>> 4;\n-            lookup4(pointMultiples, high, lookupResult, zero);\n-            setSum(result, lookupResult, t0, t1, t2, t3, t4);\n-\n-            double4(result, t0, t1, t2, t3, t4);\n-\n-            int low = 0xF & s[i];\n-            lookup4(pointMultiples, low, lookupResult, zero);\n-            setSum(result, lookupResult, t0, t1, t2, t3, t4);\n-        }\n-\n-        return result;\n-\n+    public MutablePoint multiply(ECPoint ecPoint, byte[] s) {\n+        return PointMultiplier.of(this, ecPoint).pointMultiply(s);\n@@ -407,1 +332,0 @@\n-\n@@ -473,1 +397,0 @@\n-\n@@ -489,1 +412,0 @@\n-}\n@@ -491,0 +413,250 @@\n+    static final class Secp256R1Ops extends ECOperations {\n+        private static final ECOperations instance = new Secp256R1Ops();\n+        Secp256R1Ops() {\n+            super(IntegerPolynomialP256.ONE.getElement(\n+                CurveDB.lookup(KnownOIDs.secp256r1.value()).getCurve().getB()),\n+                P256OrderField.ONE);\n+        }\n+    }\n+\n+    sealed interface PointMultiplier {\n+        Map<ECPoint, PointMultiplier> multipliers =\n+                    Map.of(Secp256R1.point, Secp256R1.multiplier);\n+\n+        ProjectivePoint.Mutable pointMultiply(byte[] s);\n+\n+        static PointMultiplier of(ECOperations ecOps, AffinePoint affPoint) {\n+            PointMultiplier multiplier = multipliers.get(affPoint.toECPoint());\n+            if (multiplier == null) {\n+                multiplier = new Default(ecOps, affPoint);\n+            }\n+\n+            return multiplier;\n+        }\n+\n+        static PointMultiplier of(ECOperations ecOps, ECPoint ecPoint) {\n+            PointMultiplier multiplier = multipliers.get(ecPoint);\n+            if (multiplier == null) {\n+                AffinePoint affPoint =\n+                        AffinePoint.fromECPoint(ecPoint, ecOps.getField());\n+                multiplier = new Default(ecOps, affPoint);\n+            }\n+\n+            return multiplier;\n+        }\n+\n+        private static void lookup(\n+                ProjectivePoint.Immutable[] ips, int index,\n+                ProjectivePoint.Mutable result) {\n+            for (int i = 0; i < 16; i++) {\n+                int xor = index ^ i;\n+                int bit3 = (xor & 0x8) >>> 3;\n+                int bit2 = (xor & 0x4) >>> 2;\n+                int bit1 = (xor & 0x2) >>> 1;\n+                int bit0 = (xor & 0x1);\n+                int inverse = bit0 | bit1 | bit2 | bit3;\n+                int set = 1 - inverse;\n+\n+                ProjectivePoint.Immutable pi = ips[i];\n+                result.conditionalSet(pi, set);\n+            }\n+        }\n+\n+        final class Default implements PointMultiplier {\n+            private final AffinePoint affineP;\n+            private final ECOperations ecOps;\n+\n+            private Default(ECOperations ecOps, AffinePoint affineP) {\n+                this.ecOps = ecOps;\n+                this.affineP = affineP;\n+            }\n+\n+            @Override\n+            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+                \/\/ 4-bit windowed multiply with branchless lookup.\n+                \/\/ The mixed addition is faster, so it is used to construct\n+                \/\/ the array at the beginning of the operation.\n+\n+                IntegerFieldModuloP field = affineP.getX().getField();\n+                ImmutableIntegerModuloP zero = field.get0();\n+                \/\/ temporaries\n+                MutableIntegerModuloP t0 = zero.mutable();\n+                MutableIntegerModuloP t1 = zero.mutable();\n+                MutableIntegerModuloP t2 = zero.mutable();\n+                MutableIntegerModuloP t3 = zero.mutable();\n+                MutableIntegerModuloP t4 = zero.mutable();\n+\n+                ProjectivePoint.Mutable result =\n+                        new ProjectivePoint.Mutable(field);\n+                result.getY().setValue(field.get1().mutable());\n+\n+                ProjectivePoint.Immutable[] pointMultiples =\n+                        new ProjectivePoint.Immutable[16];\n+                \/\/ 0P is neutral---same as initial result value\n+                pointMultiples[0] = result.fixed();\n+\n+                ProjectivePoint.Mutable ps = new ProjectivePoint.Mutable(field);\n+                ps.setValue(affineP);\n+                \/\/ 1P = P\n+                pointMultiples[1] = ps.fixed();\n+\n+                \/\/ the rest are calculated using mixed point addition\n+                for (int i = 2; i < 16; i++) {\n+                    ecOps.setSum(ps, affineP, t0, t1, t2, t3, t4);\n+                    pointMultiples[i] = ps.fixed();\n+                }\n+\n+                ProjectivePoint.Mutable lookupResult = ps.mutable();\n+\n+                for (int i = s.length - 1; i >= 0; i--) {\n+                    double4(result, t0, t1, t2, t3, t4);\n+\n+                    int high = (0xFF & s[i]) >>> 4;\n+                    lookup(pointMultiples, high, lookupResult);\n+                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+\n+                    double4(result, t0, t1, t2, t3, t4);\n+\n+                    int low = 0xF & s[i];\n+                    lookup(pointMultiples, low, lookupResult);\n+                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+                }\n+\n+                return result;\n+            }\n+\n+            private void double4(ProjectivePoint.Mutable p,\n+                    MutableIntegerModuloP t0, MutableIntegerModuloP t1,\n+                    MutableIntegerModuloP t2, MutableIntegerModuloP t3,\n+                    MutableIntegerModuloP t4) {\n+                for (int i = 0; i < 4; i++) {\n+                    ecOps.setDouble(p, t0, t1, t2, t3, t4);\n+                }\n+            }\n+        }\n+\n+        final class Secp256R1 implements PointMultiplier {\n+            private static final ECPoint point =\n+                    CurveDB.lookup(\"secp256r1\").getGenerator();\n+            private static final PointMultiplier multiplier = new Secp256R1();\n+\n+            private static final ImmutableIntegerModuloP zero =\n+                    IntegerPolynomialP256.ONE.get0();\n+\n+            @Override\n+            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+                MutableIntegerModuloP t0 = zero.mutable();\n+                MutableIntegerModuloP t1 = zero.mutable();\n+                MutableIntegerModuloP t2 = zero.mutable();\n+                MutableIntegerModuloP t3 = zero.mutable();\n+                MutableIntegerModuloP t4 = zero.mutable();\n+\n+                ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n+                        zero.mutable(),\n+                        zero.getField().get1().mutable(),\n+                        zero.mutable());\n+                ProjectivePoint.Mutable r = d.mutable();\n+                for (int i = 15; i >= 0; i--) {\n+                    Secp256R1Ops.instance.setDouble(d, t0, t1, t2, t3, t4);\n+                    for (int j = 3; j >= 0; j--) {\n+                        int pos = i + j * 16;\n+                        int index = (posit(s, pos + 192) << 3) |\n+                                    (posit(s, pos + 128) << 2) |\n+                                    (posit(s, pos +  64) << 1) |\n+                                     posit(s, pos);\n+\n+                        lookup(P256.points[j], index, r);\n+                        Secp256R1Ops.instance.setSum(d, r, t0, t1, t2, t3, t4);\n+                    }\n+                }\n+\n+                return d;\n+            }\n+\n+            private static int posit(byte[] k, int i) {\n+                return (k[i >> 3] >> (i & 0x07)) & 0x01;\n+            }\n+        }\n+\n+        final class P256 {\n+            private static final ProjectivePoint.Immutable[][] points;\n+\n+            \/\/ Generate the pre-computed tables.  This block may be replaced\n+            \/\/ with hard-coded tables in order to speed up the class loading.\n+            static {\n+                points = new ProjectivePoint.Immutable[4][16];\n+                BigInteger[] factors = new BigInteger[] {\n+                        BigInteger.ONE,\n+                        BigInteger.TWO.pow(64),\n+                        BigInteger.TWO.pow(128),\n+                        BigInteger.TWO.pow(192)\n+                };\n+\n+                BigInteger[] base = new BigInteger[16];\n+                base[0] = BigInteger.ZERO;\n+                base[1] = BigInteger.ONE;\n+                base[2] = factors[1];\n+                for (int i = 3; i < 16; i++) {\n+                    base[i] = BigInteger.ZERO;\n+                    for (int k = 0; k < 4; k++) {\n+                        if (((i >>> k) & 0x01) != 0) {\n+                            base[i] = base[i].add(factors[k]);\n+                        }\n+                    }\n+                }\n+\n+                for (int d = 0; d < 4; d++) {\n+                    for (int w = 0; w < 16; w++) {\n+                        BigInteger bi = base[w];\n+                        if (d != 0) {\n+                            bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                        }\n+                        if (w == 0) {\n+                            points[d][0] = new ProjectivePoint.Immutable(\n+                                    Secp256R1.zero.fixed(),\n+                                    Secp256R1.zero.getField().get1().fixed(),\n+                                    Secp256R1.zero.fixed());\n+                        } else {\n+                            PointMultiplier multiplier = new Default(\n+                                    Secp256R1Ops.instance,\n+                                    AffinePoint.fromECPoint(Secp256R1.point,\n+                                            Secp256R1.zero.getField()));\n+                            byte[] s = bi.toByteArray();\n+                            ArrayUtil.reverse(s);\n+                            ProjectivePoint.Mutable m =\n+                                    multiplier.pointMultiply(s);\n+                            points[d][w] = m.setValue(m.asAffine()).fixed();\n+                        }\n+                    }\n+                }\n+\n+                \/\/ Check that the tables are correctly generated.\n+                for (int d = 0; d < 4; d++) {\n+                    for (int w = 0; w < 16; w++) {\n+                        BigInteger bi = base[w];\n+                        if (d != 0) {\n+                            bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                        }\n+                        if (w != 0) {\n+                            byte[] s = new byte[32];\n+                            byte[] b = bi.toByteArray();\n+                            ArrayUtil.reverse(b);\n+                            System.arraycopy(b, 0, s, 0, b.length);\n+\n+                            ProjectivePoint.Mutable m =\n+                                    Secp256R1.multiplier.pointMultiply(s);\n+                            ProjectivePoint.Immutable v =\n+                                    m.setValue(m.asAffine()).fixed();\n+                            if (!v.getX().asBigInteger().equals(\n+                                    points[d][w].getX().asBigInteger()) ||\n+                                !v.getY().asBigInteger().equals(\n+                                    points[d][w].getY().asBigInteger())) {\n+                                throw new RuntimeException();\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":258,"deletions":86,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.security.util.math.IntegerFieldModuloP;\n@@ -29,0 +30,1 @@\n+import java.security.spec.ECPoint;\n@@ -47,0 +49,11 @@\n+    public static AffinePoint fromECPoint(\n+            ECPoint ecPoint, IntegerFieldModuloP field) {\n+        return new AffinePoint(\n+                field.getElement(ecPoint.getAffineX()),\n+                field.getElement(ecPoint.getAffineY()));\n+    }\n+\n+    public ECPoint toECPoint() {\n+        return new ECPoint(x.asBigInteger(), y.asBigInteger());\n+    }\n+\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/point\/AffinePoint.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 3)\n+public class KeyPairGenerators {\n+    @Param({\"secp256r1\", \"secp384r1\", \"secp521r1\", \"Ed25519\", \"Ed448\"})\n+    private String curveName;\n+\n+    private KeyPairGenerator kpg;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        if (curveName.startsWith(\"secp\")) {\n+            AlgorithmParameters params =\n+                    AlgorithmParameters.getInstance(\"EC\", \"SunEC\");\n+            params.init(new ECGenParameterSpec(curveName));\n+            ECGenParameterSpec ecParams =\n+                    params.getParameterSpec(ECGenParameterSpec.class);\n+\n+            kpg = KeyPairGenerator.getInstance(\"EC\", \"SunEC\");\n+            kpg.initialize(ecParams);\n+        } else {\n+            kpg = KeyPairGenerator.getInstance(curveName, \"SunEC\");\n+            NamedParameterSpec spec = new NamedParameterSpec(curveName);\n+            kpg.initialize(spec);\n+        }\n+    }\n+\n+    @Benchmark\n+    public KeyPair keyPairGen() {\n+        return kpg.generateKeyPair();\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/KeyPairGenerators.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -80,0 +80,2 @@\n+        \/\/ System.setProperty(\"jdk.tls.namedGroups\", \"secp256r1\");\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.security.*;\n+import java.security.spec.ECGenParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 3)\n+public class Signatures {\n+    private Signature signer;\n+\n+    @Param({\"64\", \"512\", \"2048\", \"16384\"})\n+    private int messageLength;\n+\n+    @Param({\"secp256r1\", \"secp384r1\", \"secp521r1\", \"Ed25519\", \"Ed448\"})\n+    private String curveName;\n+\n+    private byte[] message;\n+\n+    record CurveSpec(String curveName, String signName) {\n+        \/\/ blank\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        message = new byte[messageLength];\n+        (new Random(System.nanoTime())).nextBytes(message);\n+\n+        String signName = switch (curveName) {\n+            case \"secp256r1\" -> \"Sha256WithECDSA\";\n+            case \"secp384r1\" -> \"Sha384WithECDSA\";\n+            case \"secp521r1\" -> \"Sha512WithECDSA\";\n+            case \"Ed25519\" -> \"Ed25519\";\n+            case \"Ed448\" -> \"Ed448\";\n+            default -> throw new RuntimeException();\n+        };\n+\n+        KeyPair kp;\n+        if (curveName.startsWith(\"secp\")) {\n+            AlgorithmParameters params =\n+                    AlgorithmParameters.getInstance(\"EC\", \"SunEC\");\n+            params.init(new ECGenParameterSpec(curveName));\n+            ECGenParameterSpec ecParams =\n+                    params.getParameterSpec(ECGenParameterSpec.class);\n+\n+            KeyPairGenerator kpg =\n+                    KeyPairGenerator.getInstance(\"EC\", \"SunEC\");\n+            kpg.initialize(ecParams);\n+            kp = kpg.generateKeyPair();\n+        } else {\n+            KeyPairGenerator kpg =\n+                    KeyPairGenerator.getInstance(curveName, \"SunEC\");\n+            NamedParameterSpec spec = new NamedParameterSpec(curveName);\n+            kpg.initialize(spec);\n+            kp = kpg.generateKeyPair();\n+        }\n+\n+        signer = Signature.getInstance(signName, \"SunEC\");\n+        signer.initSign(kp.getPrivate());\n+    }\n+\n+    @Benchmark\n+    public byte[] sign() throws SignatureException {\n+        signer.update(message);\n+        return signer.sign();\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/Signatures.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}