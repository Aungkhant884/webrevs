{"files":[{"patch":"@@ -209,3 +209,0 @@\n-        ImmutableIntegerModuloP xElem = ops.getField().getElement(x);\n-        ImmutableIntegerModuloP yElem = ops.getField().getElement(y);\n-        AffinePoint affP = new AffinePoint(xElem, yElem);\n@@ -214,1 +211,1 @@\n-        Point product = ops.multiply(affP, order);\n+        Point product = ops.multiply(key.getW(), order);\n@@ -278,6 +275,2 @@\n-        ImmutableIntegerModuloP x =\n-            field.getElement(pubKey.getW().getAffineX());\n-        ImmutableIntegerModuloP y =\n-            field.getElement(pubKey.getW().getAffineY());\n-        Point product = ops.multiply(new AffinePoint(x, y),\n-            scalar.asByteArray(keySize));\n+        Point product =\n+                ops.multiply(pubKey.getW(), scalar.asByteArray(keySize));\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -246,3 +246,0 @@\n-        AffinePoint pub = new AffinePoint(field.getElement(pp.getAffineX()),\n-                field.getElement(pp.getAffineY()));\n-\n@@ -256,1 +253,1 @@\n-        MutablePoint p2 = ecOps.multiply(pub, temp2);\n+        MutablePoint p2 = ecOps.multiply(pp, temp2);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDSAOperations.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -194,5 +194,1 @@\n-        ECPoint genPoint = ecParams.getGenerator();\n-        ImmutableIntegerModuloP x = field.getElement(genPoint.getAffineX());\n-        ImmutableIntegerModuloP y = field.getElement(genPoint.getAffineY());\n-        AffinePoint affGen = new AffinePoint(x, y);\n-        Point pub = ops.multiply(affGen, privArr);\n+        Point pub = ops.multiply(ecParams.getGenerator(), privArr);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECKeyPairGenerator.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import sun.security.util.CurveDB;\n+import sun.security.util.KnownOIDs;\n@@ -49,0 +51,4 @@\n+    private static final ECOperations secp256r1Ops =\n+        new ECOperations(IntegerPolynomialP256.ONE.getElement(\n+                CurveDB.lookup(KnownOIDs.secp256r1.value()).getCurve().getB()),\n+                P256OrderField.ONE);\n@@ -75,1 +81,1 @@\n-        if (!(curve.getField() instanceof ECFieldFp)) {\n+        if (!(curve.getField() instanceof ECFieldFp primeField)) {\n@@ -78,1 +84,0 @@\n-        ECFieldFp primeField = (ECFieldFp) curve.getField();\n@@ -196,29 +201,0 @@\n-    \/*\n-     * 4-bit branchless array lookup for projective points.\n-     *\/\n-    private void lookup4(ProjectivePoint.Immutable[] arr, int index,\n-        ProjectivePoint.Mutable result, IntegerModuloP zero) {\n-\n-        for (int i = 0; i < 16; i++) {\n-            int xor = index ^ i;\n-            int bit3 = (xor & 0x8) >>> 3;\n-            int bit2 = (xor & 0x4) >>> 2;\n-            int bit1 = (xor & 0x2) >>> 1;\n-            int bit0 = (xor & 0x1);\n-            int inverse = bit0 | bit1 | bit2 | bit3;\n-            int set = 1 - inverse;\n-\n-            ProjectivePoint.Immutable pi = arr[i];\n-            result.conditionalSet(pi, set);\n-        }\n-    }\n-\n-    private void double4(ProjectivePoint.Mutable p, MutableIntegerModuloP t0,\n-        MutableIntegerModuloP t1, MutableIntegerModuloP t2,\n-        MutableIntegerModuloP t3, MutableIntegerModuloP t4) {\n-\n-        for (int i = 0; i < 4; i++) {\n-            setDouble(p, t0, t1, t2, t3, t4);\n-        }\n-    }\n-\n@@ -234,0 +210,2 @@\n+        return PointMultiplier.of(this, affineP).pointMultiply(s);\n+    }\n@@ -235,51 +213,2 @@\n-        \/\/ 4-bit windowed multiply with branchless lookup.\n-        \/\/ The mixed addition is faster, so it is used to construct the array\n-        \/\/ at the beginning of the operation.\n-\n-        IntegerFieldModuloP field = affineP.getX().getField();\n-        ImmutableIntegerModuloP zero = field.get0();\n-        \/\/ temporaries\n-        MutableIntegerModuloP t0 = zero.mutable();\n-        MutableIntegerModuloP t1 = zero.mutable();\n-        MutableIntegerModuloP t2 = zero.mutable();\n-        MutableIntegerModuloP t3 = zero.mutable();\n-        MutableIntegerModuloP t4 = zero.mutable();\n-\n-        ProjectivePoint.Mutable result = new ProjectivePoint.Mutable(field);\n-        result.getY().setValue(field.get1().mutable());\n-\n-        ProjectivePoint.Immutable[] pointMultiples =\n-            new ProjectivePoint.Immutable[16];\n-        \/\/ 0P is neutral---same as initial result value\n-        pointMultiples[0] = result.fixed();\n-\n-        ProjectivePoint.Mutable ps = new ProjectivePoint.Mutable(field);\n-        ps.setValue(affineP);\n-        \/\/ 1P = P\n-        pointMultiples[1] = ps.fixed();\n-\n-        \/\/ the rest are calculated using mixed point addition\n-        for (int i = 2; i < 16; i++) {\n-            setSum(ps, affineP, t0, t1, t2, t3, t4);\n-            pointMultiples[i] = ps.fixed();\n-        }\n-\n-        ProjectivePoint.Mutable lookupResult = ps.mutable();\n-\n-        for (int i = s.length - 1; i >= 0; i--) {\n-\n-            double4(result, t0, t1, t2, t3, t4);\n-\n-            int high = (0xFF & s[i]) >>> 4;\n-            lookup4(pointMultiples, high, lookupResult, zero);\n-            setSum(result, lookupResult, t0, t1, t2, t3, t4);\n-\n-            double4(result, t0, t1, t2, t3, t4);\n-\n-            int low = 0xF & s[i];\n-            lookup4(pointMultiples, low, lookupResult, zero);\n-            setSum(result, lookupResult, t0, t1, t2, t3, t4);\n-        }\n-\n-        return result;\n-\n+    public MutablePoint multiply(ECPoint ecPoint, byte[] s) {\n+        return PointMultiplier.of(this, ecPoint).pointMultiply(s);\n@@ -407,1 +336,0 @@\n-\n@@ -473,1 +401,0 @@\n-\n@@ -489,1 +416,0 @@\n-}\n@@ -491,0 +417,282 @@\n+    sealed interface PointMultiplier {\n+        Map<ECPoint, PointMultiplier> multipliers = Map.of(\n+                Secp256R1GeneratorMultiplier.point,\n+                Secp256R1GeneratorMultiplier.multiplier);\n+\n+        \/\/ Multiply the point by a scalar and return the result as a mutable\n+        \/\/ point.  The multiplier point is specified by the implementation of\n+        \/\/ this interface, which could be a general EC point or EC generator\n+        \/\/ point.\n+        ProjectivePoint.Mutable pointMultiply(byte[] scalar);\n+\n+        static PointMultiplier of(ECOperations ecOps, AffinePoint affPoint) {\n+            PointMultiplier multiplier = multipliers.get(affPoint.toECPoint());\n+            if (multiplier == null) {\n+                multiplier = new Default(ecOps, affPoint);\n+            }\n+\n+            return multiplier;\n+        }\n+\n+        static PointMultiplier of(ECOperations ecOps, ECPoint ecPoint) {\n+            PointMultiplier multiplier = multipliers.get(ecPoint);\n+            if (multiplier == null) {\n+                AffinePoint affPoint =\n+                        AffinePoint.fromECPoint(ecPoint, ecOps.getField());\n+                multiplier = new Default(ecOps, affPoint);\n+            }\n+\n+            return multiplier;\n+        }\n+\n+        private static void lookup(\n+                ProjectivePoint.Immutable[] ips, int index,\n+                ProjectivePoint.Mutable result) {\n+            for (int i = 0; i < 16; i++) {\n+                int xor = index ^ i;\n+                int bit3 = (xor & 0x8) >>> 3;\n+                int bit2 = (xor & 0x4) >>> 2;\n+                int bit1 = (xor & 0x2) >>> 1;\n+                int bit0 = (xor & 0x1);\n+                int inverse = bit0 | bit1 | bit2 | bit3;\n+                int set = 1 - inverse;\n+\n+                ProjectivePoint.Immutable pi = ips[i];\n+                result.conditionalSet(pi, set);\n+            }\n+        }\n+\n+        final class Default implements PointMultiplier {\n+            private final AffinePoint affineP;\n+            private final ECOperations ecOps;\n+\n+            private Default(ECOperations ecOps, AffinePoint affineP) {\n+                this.ecOps = ecOps;\n+                this.affineP = affineP;\n+            }\n+\n+            @Override\n+            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+                \/\/ 4-bit windowed multiply with branchless lookup.\n+                \/\/ The mixed addition is faster, so it is used to construct\n+                \/\/ the array at the beginning of the operation.\n+\n+                IntegerFieldModuloP field = affineP.getX().getField();\n+                ImmutableIntegerModuloP zero = field.get0();\n+                \/\/ temporaries\n+                MutableIntegerModuloP t0 = zero.mutable();\n+                MutableIntegerModuloP t1 = zero.mutable();\n+                MutableIntegerModuloP t2 = zero.mutable();\n+                MutableIntegerModuloP t3 = zero.mutable();\n+                MutableIntegerModuloP t4 = zero.mutable();\n+\n+                ProjectivePoint.Mutable result =\n+                        new ProjectivePoint.Mutable(field);\n+                result.getY().setValue(field.get1().mutable());\n+\n+                ProjectivePoint.Immutable[] pointMultiples =\n+                        new ProjectivePoint.Immutable[16];\n+                \/\/ 0P is neutral---same as initial result value\n+                pointMultiples[0] = result.fixed();\n+\n+                ProjectivePoint.Mutable ps = new ProjectivePoint.Mutable(field);\n+                ps.setValue(affineP);\n+                \/\/ 1P = P\n+                pointMultiples[1] = ps.fixed();\n+\n+                \/\/ the rest are calculated using mixed point addition\n+                for (int i = 2; i < 16; i++) {\n+                    ecOps.setSum(ps, affineP, t0, t1, t2, t3, t4);\n+                    pointMultiples[i] = ps.fixed();\n+                }\n+\n+                ProjectivePoint.Mutable lookupResult = ps.mutable();\n+\n+                for (int i = s.length - 1; i >= 0; i--) {\n+                    double4(result, t0, t1, t2, t3, t4);\n+\n+                    int high = (0xFF & s[i]) >>> 4;\n+                    lookup(pointMultiples, high, lookupResult);\n+                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+\n+                    double4(result, t0, t1, t2, t3, t4);\n+\n+                    int low = 0xF & s[i];\n+                    lookup(pointMultiples, low, lookupResult);\n+                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+                }\n+\n+                return result;\n+            }\n+\n+            private void double4(ProjectivePoint.Mutable p,\n+                    MutableIntegerModuloP t0, MutableIntegerModuloP t1,\n+                    MutableIntegerModuloP t2, MutableIntegerModuloP t3,\n+                    MutableIntegerModuloP t4) {\n+                for (int i = 0; i < 4; i++) {\n+                    ecOps.setDouble(p, t0, t1, t2, t3, t4);\n+                }\n+            }\n+        }\n+\n+        final class Secp256R1GeneratorMultiplier implements PointMultiplier {\n+            private static final ECPoint point =\n+                    CurveDB.lookup(\"secp256r1\").getGenerator();\n+            private static final PointMultiplier multiplier =\n+                    new Secp256R1GeneratorMultiplier();\n+\n+            private static final ImmutableIntegerModuloP zero =\n+                    IntegerPolynomialP256.ONE.get0();\n+            private static final ImmutableIntegerModuloP one =\n+                    IntegerPolynomialP256.ONE.get1();\n+\n+            @Override\n+            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+                MutableIntegerModuloP t0 = zero.mutable();\n+                MutableIntegerModuloP t1 = zero.mutable();\n+                MutableIntegerModuloP t2 = zero.mutable();\n+                MutableIntegerModuloP t3 = zero.mutable();\n+                MutableIntegerModuloP t4 = zero.mutable();\n+\n+                ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n+                        zero.mutable(),\n+                        one.mutable(),\n+                        zero.mutable());\n+                ProjectivePoint.Mutable r = d.mutable();\n+                for (int i = 15; i >= 0; i--) {\n+                    secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n+                    for (int j = 3; j >= 0; j--) {\n+                        int pos = i + j * 16;\n+                        int index = (posit(s, pos + 192) << 3) |\n+                                    (posit(s, pos + 128) << 2) |\n+                                    (posit(s, pos +  64) << 1) |\n+                                     posit(s, pos);\n+\n+                        lookup(P256.points[j], index, r);\n+                        secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n+                    }\n+                }\n+\n+                return d;\n+            }\n+\n+            private static int posit(byte[] k, int i) {\n+                return (k[i >> 3] >> (i & 0x07)) & 0x01;\n+            }\n+\n+            \/\/ Lazy loading of the tables.\n+            private static final class P256 {\n+                \/\/ Pre-computed tables to speed up the point multiplication.\n+                \/\/\n+                \/\/ This is a 4 dimensions table, and each dimension contains\n+                \/\/ 16 elements. For the 1st demension, each element in it is  \n+                \/\/ a pre-computed generator point multiplication value.\n+                \/\/\n+                \/\/ index   |    point\n+                \/\/ --------+----------------\n+                \/\/ 0x0000  | 0G\n+                \/\/ 0x0001  | 1G\n+                \/\/ 0x0002  | (2^64)G\n+                \/\/ 0x0003  | (2^64 + 1)G\n+                \/\/ 0x0004  | 2^128G\n+                \/\/ 0x0005  | (2^128 + 1)G\n+                \/\/ 0x0006  | (2^128 + 2^64)G\n+                \/\/ 0x0007  | (2^128 + 2^64 + 1)G\n+                \/\/ 0x0008  | 2^192G\n+                \/\/ 0x0009  | (2^192 + 1)G\n+                \/\/ 0x000A  | (2^192 + 2^64)G\n+                \/\/ 0x000B  | (2^192 + 2^64 + 1)G\n+                \/\/ 0x000C  | (2^192 + 2^128)G\n+                \/\/ 0x000D  | (2^192 + 2^128 + 1)G\n+                \/\/ 0x000E  | (2^192 + 2^128 + 2^64)G\n+                \/\/ 0x000F  | (2^192 + 2^128 + 2^64 + 1)G\n+                \/\/\n+                \/\/ For the following dimensions, each element is multiplied\n+                \/\/ by 2^16 of the corresponding element value in the previous\n+                \/\/ dimension.\n+                private static final ProjectivePoint.Immutable[][] points;\n+\n+                \/\/ Generate the pre-computed tables.  This block may be\n+                \/\/ replaced with hard-coded tables in order to speed up\n+                \/\/ the class loading.\n+                static {\n+                    points = new ProjectivePoint.Immutable[4][16];\n+                    BigInteger[] factors = new BigInteger[] {\n+                            BigInteger.ONE,\n+                            BigInteger.TWO.pow(64),\n+                            BigInteger.TWO.pow(128),\n+                            BigInteger.TWO.pow(192)\n+                    };\n+\n+                    BigInteger[] base = new BigInteger[16];\n+                    base[0] = BigInteger.ZERO;\n+                    base[1] = BigInteger.ONE;\n+                    base[2] = factors[1];\n+                    for (int i = 3; i < 16; i++) {\n+                        base[i] = BigInteger.ZERO;\n+                        for (int k = 0; k < 4; k++) {\n+                            if (((i >>> k) & 0x01) != 0) {\n+                                base[i] = base[i].add(factors[k]);\n+                            }\n+                        }\n+                    }\n+\n+                    for (int d = 0; d < 4; d++) {\n+                        for (int w = 0; w < 16; w++) {\n+                            BigInteger bi = base[w];\n+                            if (d != 0) {\n+                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                            }\n+                            if (w == 0) {\n+                                points[d][0] = new ProjectivePoint.Immutable(\n+                                    zero.fixed(), one.fixed(), zero.fixed());\n+                            } else {\n+                                PointMultiplier multiplier = new Default(\n+                                    secp256r1Ops, AffinePoint.fromECPoint(\n+                                        point, zero.getField()));\n+                                byte[] s = bi.toByteArray();\n+                                ArrayUtil.reverse(s);\n+                                ProjectivePoint.Mutable m =\n+                                        multiplier.pointMultiply(s);\n+                                points[d][w] = m.setValue(m.asAffine()).fixed();\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ Check that the tables are correctly generated.\n+                    if (ECOperations.class.desiredAssertionStatus()) {\n+                        verifyTables(base);\n+                    }\n+                }\n+\n+                private static void verifyTables(BigInteger[] base) {\n+                    for (int d = 0; d < 4; d++) {\n+                        for (int w = 0; w < 16; w++) {\n+                            BigInteger bi = base[w];\n+                            if (d != 0) {\n+                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                            }\n+                            if (w != 0) {\n+                                byte[] s = new byte[32];\n+                                byte[] b = bi.toByteArray();\n+                                ArrayUtil.reverse(b);\n+                                System.arraycopy(b, 0, s, 0, b.length);\n+\n+                                ProjectivePoint.Mutable m =\n+                                        multiplier.pointMultiply(s);\n+                                ProjectivePoint.Immutable v =\n+                                        m.setValue(m.asAffine()).fixed();\n+                                if (!v.getX().asBigInteger().equals(\n+                                        points[d][w].getX().asBigInteger()) ||\n+                                    !v.getY().asBigInteger().equals(\n+                                        points[d][w].getY().asBigInteger())) {\n+                                    throw new RuntimeException();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":293,"deletions":85,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.security.util.math.IntegerFieldModuloP;\n@@ -29,0 +30,1 @@\n+import java.security.spec.ECPoint;\n@@ -47,0 +49,11 @@\n+    public static AffinePoint fromECPoint(\n+            ECPoint ecPoint, IntegerFieldModuloP field) {\n+        return new AffinePoint(\n+                field.getElement(ecPoint.getAffineX()),\n+                field.getElement(ecPoint.getAffineY()));\n+    }\n+\n+    public ECPoint toECPoint() {\n+        return new ECPoint(x.asBigInteger(), y.asBigInteger());\n+    }\n+\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/point\/AffinePoint.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 3)\n+public class KeyPairGenerators {\n+    @Param({\"secp256r1\", \"secp384r1\", \"secp521r1\", \"Ed25519\", \"Ed448\"})\n+    private String curveName;\n+\n+    private KeyPairGenerator kpg;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        if (curveName.startsWith(\"secp\")) {\n+            AlgorithmParameters params =\n+                    AlgorithmParameters.getInstance(\"EC\", \"SunEC\");\n+            params.init(new ECGenParameterSpec(curveName));\n+            ECGenParameterSpec ecParams =\n+                    params.getParameterSpec(ECGenParameterSpec.class);\n+\n+            kpg = KeyPairGenerator.getInstance(\"EC\", \"SunEC\");\n+            kpg.initialize(ecParams);\n+        } else {\n+            kpg = KeyPairGenerator.getInstance(curveName, \"SunEC\");\n+            NamedParameterSpec spec = new NamedParameterSpec(curveName);\n+            kpg.initialize(spec);\n+        }\n+    }\n+\n+    @Benchmark\n+    public KeyPair keyPairGen() {\n+        return kpg.generateKeyPair();\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/KeyPairGenerators.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.security.*;\n+import java.security.spec.ECGenParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 3)\n+public class Signatures {\n+    private Signature signer;\n+\n+    @Param({\"64\", \"512\", \"2048\", \"16384\"})\n+    private int messageLength;\n+\n+    @Param({\"secp256r1\", \"secp384r1\", \"secp521r1\", \"Ed25519\", \"Ed448\"})\n+    private String curveName;\n+\n+    private byte[] message;\n+\n+    record CurveSpec(String curveName, String signName) {\n+        \/\/ blank\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        message = new byte[messageLength];\n+        (new Random(System.nanoTime())).nextBytes(message);\n+\n+        String signName = switch (curveName) {\n+            case \"secp256r1\" -> \"Sha256WithECDSA\";\n+            case \"secp384r1\" -> \"Sha384WithECDSA\";\n+            case \"secp521r1\" -> \"Sha512WithECDSA\";\n+            case \"Ed25519\" -> \"Ed25519\";\n+            case \"Ed448\" -> \"Ed448\";\n+            default -> throw new RuntimeException();\n+        };\n+\n+        KeyPair kp;\n+        if (curveName.startsWith(\"secp\")) {\n+            AlgorithmParameters params =\n+                    AlgorithmParameters.getInstance(\"EC\", \"SunEC\");\n+            params.init(new ECGenParameterSpec(curveName));\n+            ECGenParameterSpec ecParams =\n+                    params.getParameterSpec(ECGenParameterSpec.class);\n+\n+            KeyPairGenerator kpg =\n+                    KeyPairGenerator.getInstance(\"EC\", \"SunEC\");\n+            kpg.initialize(ecParams);\n+            kp = kpg.generateKeyPair();\n+        } else {\n+            KeyPairGenerator kpg =\n+                    KeyPairGenerator.getInstance(curveName, \"SunEC\");\n+            NamedParameterSpec spec = new NamedParameterSpec(curveName);\n+            kpg.initialize(spec);\n+            kp = kpg.generateKeyPair();\n+        }\n+\n+        signer = Signature.getInstance(signName, \"SunEC\");\n+        signer.initSign(kp.getPrivate());\n+    }\n+\n+    @Benchmark\n+    public byte[] sign() throws SignatureException {\n+        signer.update(message);\n+        return signer.sign();\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/Signatures.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}