{"files":[{"patch":"@@ -209,3 +209,0 @@\n-        ImmutableIntegerModuloP xElem = ops.getField().getElement(x);\n-        ImmutableIntegerModuloP yElem = ops.getField().getElement(y);\n-        AffinePoint affP = new AffinePoint(xElem, yElem);\n@@ -214,1 +211,1 @@\n-        Point product = ops.multiply(affP, order);\n+        Point product = ops.multiply(key.getW(), order);\n@@ -278,6 +275,2 @@\n-        ImmutableIntegerModuloP x =\n-            field.getElement(pubKey.getW().getAffineX());\n-        ImmutableIntegerModuloP y =\n-            field.getElement(pubKey.getW().getAffineY());\n-        Point product = ops.multiply(new AffinePoint(x, y),\n-            scalar.asByteArray(keySize));\n+        Point product =\n+                ops.multiply(pubKey.getW(), scalar.asByteArray(keySize));\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -246,3 +246,0 @@\n-        AffinePoint pub = new AffinePoint(field.getElement(pp.getAffineX()),\n-                field.getElement(pp.getAffineY()));\n-\n@@ -256,1 +253,1 @@\n-        MutablePoint p2 = ecOps.multiply(pub, temp2);\n+        MutablePoint p2 = ecOps.multiply(pp, temp2);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDSAOperations.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -194,5 +194,1 @@\n-        ECPoint genPoint = ecParams.getGenerator();\n-        ImmutableIntegerModuloP x = field.getElement(genPoint.getAffineX());\n-        ImmutableIntegerModuloP y = field.getElement(genPoint.getAffineY());\n-        AffinePoint affGen = new AffinePoint(x, y);\n-        Point pub = ops.multiply(affGen, privArr);\n+        Point pub = ops.multiply(ecParams.getGenerator(), privArr);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECKeyPairGenerator.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,5 @@\n-public sealed class ECOperations {\n+public class ECOperations {\n+    private static final ECOperations secp256r1Ops =\n+        new ECOperations(IntegerPolynomialP256.ONE.getElement(\n+                CurveDB.lookup(KnownOIDs.secp256r1.value()).getCurve().getB()),\n+                P256OrderField.ONE);\n@@ -413,9 +417,0 @@\n-    static final class Secp256R1Ops extends ECOperations {\n-        private static final ECOperations instance = new Secp256R1Ops();\n-        Secp256R1Ops() {\n-            super(IntegerPolynomialP256.ONE.getElement(\n-                CurveDB.lookup(KnownOIDs.secp256r1.value()).getCurve().getB()),\n-                P256OrderField.ONE);\n-        }\n-    }\n-\n@@ -423,2 +418,3 @@\n-        Map<ECPoint, PointMultiplier> multipliers =\n-                    Map.of(Secp256R1.point, Secp256R1.multiplier);\n+        Map<ECPoint, PointMultiplier> multipliers = Map.of(\n+                Secp256R1GeneratorMultiplier.point,\n+                Secp256R1GeneratorMultiplier.multiplier);\n@@ -426,1 +422,5 @@\n-        ProjectivePoint.Mutable pointMultiply(byte[] s);\n+        \/\/ Multiply the point by a scalar and return the result as a mutable\n+        \/\/ point.  The multiplier point is specified by the implementation of\n+        \/\/ this interface, which could be a general EC point or EC generator\n+        \/\/ point.\n+        ProjectivePoint.Mutable pointMultiply(byte[] scalar);\n@@ -538,1 +538,1 @@\n-        final class Secp256R1 implements PointMultiplier {\n+        final class Secp256R1GeneratorMultiplier implements PointMultiplier {\n@@ -541,1 +541,2 @@\n-            private static final PointMultiplier multiplier = new Secp256R1();\n+            private static final PointMultiplier multiplier =\n+                    new Secp256R1GeneratorMultiplier();\n@@ -545,0 +546,2 @@\n+            private static final ImmutableIntegerModuloP one =\n+                    IntegerPolynomialP256.ONE.get1();\n@@ -556,1 +559,1 @@\n-                        zero.getField().get1().mutable(),\n+                        one.mutable(),\n@@ -560,1 +563,1 @@\n-                    Secp256R1Ops.instance.setDouble(d, t0, t1, t2, t3, t4);\n+                    secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n@@ -569,1 +572,1 @@\n-                        Secp256R1Ops.instance.setSum(d, r, t0, t1, t2, t3, t4);\n+                        secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n@@ -579,1 +582,0 @@\n-        }\n@@ -581,23 +583,54 @@\n-        final class P256 {\n-            private static final ProjectivePoint.Immutable[][] points;\n-\n-            \/\/ Generate the pre-computed tables.  This block may be replaced\n-            \/\/ with hard-coded tables in order to speed up the class loading.\n-            static {\n-                points = new ProjectivePoint.Immutable[4][16];\n-                BigInteger[] factors = new BigInteger[] {\n-                        BigInteger.ONE,\n-                        BigInteger.TWO.pow(64),\n-                        BigInteger.TWO.pow(128),\n-                        BigInteger.TWO.pow(192)\n-                };\n-\n-                BigInteger[] base = new BigInteger[16];\n-                base[0] = BigInteger.ZERO;\n-                base[1] = BigInteger.ONE;\n-                base[2] = factors[1];\n-                for (int i = 3; i < 16; i++) {\n-                    base[i] = BigInteger.ZERO;\n-                    for (int k = 0; k < 4; k++) {\n-                        if (((i >>> k) & 0x01) != 0) {\n-                            base[i] = base[i].add(factors[k]);\n+            \/\/ Lazy loading of the tables.\n+            private static final class P256 {\n+                \/\/ Pre-computed tables to speed up the point multiplication.\n+                \/\/\n+                \/\/ This is a 4 dimensions table, and each dimension contains\n+                \/\/ 16 elements. For the 1st demension, each element in it is  \n+                \/\/ a pre-computed generator point multiplication value.\n+                \/\/\n+                \/\/ index   |    point\n+                \/\/ --------+----------------\n+                \/\/ 0x0000  | 0G\n+                \/\/ 0x0001  | 1G\n+                \/\/ 0x0002  | (2^64)G\n+                \/\/ 0x0003  | (2^64 + 1)G\n+                \/\/ 0x0004  | 2^128G\n+                \/\/ 0x0005  | (2^128 + 1)G\n+                \/\/ 0x0006  | (2^128 + 2^64)G\n+                \/\/ 0x0007  | (2^128 + 2^64 + 1)G\n+                \/\/ 0x0008  | 2^192G\n+                \/\/ 0x0009  | (2^192 + 1)G\n+                \/\/ 0x000A  | (2^192 + 2^64)G\n+                \/\/ 0x000B  | (2^192 + 2^64 + 1)G\n+                \/\/ 0x000C  | (2^192 + 2^128)G\n+                \/\/ 0x000D  | (2^192 + 2^128 + 1)G\n+                \/\/ 0x000E  | (2^192 + 2^128 + 2^64)G\n+                \/\/ 0x000F  | (2^192 + 2^128 + 2^64 + 1)G\n+                \/\/\n+                \/\/ For the following dimensions, each element is multiplied\n+                \/\/ by 2^16 of the corresponding element value in the previous\n+                \/\/ dimension.\n+                private static final ProjectivePoint.Immutable[][] points;\n+\n+                \/\/ Generate the pre-computed tables.  This block may be\n+                \/\/ replaced with hard-coded tables in order to speed up\n+                \/\/ the class loading.\n+                static {\n+                    points = new ProjectivePoint.Immutable[4][16];\n+                    BigInteger[] factors = new BigInteger[] {\n+                            BigInteger.ONE,\n+                            BigInteger.TWO.pow(64),\n+                            BigInteger.TWO.pow(128),\n+                            BigInteger.TWO.pow(192)\n+                    };\n+\n+                    BigInteger[] base = new BigInteger[16];\n+                    base[0] = BigInteger.ZERO;\n+                    base[1] = BigInteger.ONE;\n+                    base[2] = factors[1];\n+                    for (int i = 3; i < 16; i++) {\n+                        base[i] = BigInteger.ZERO;\n+                        for (int k = 0; k < 4; k++) {\n+                            if (((i >>> k) & 0x01) != 0) {\n+                                base[i] = base[i].add(factors[k]);\n+                            }\n@@ -606,1 +639,0 @@\n-                }\n@@ -608,21 +640,19 @@\n-                for (int d = 0; d < 4; d++) {\n-                    for (int w = 0; w < 16; w++) {\n-                        BigInteger bi = base[w];\n-                        if (d != 0) {\n-                            bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n-                        }\n-                        if (w == 0) {\n-                            points[d][0] = new ProjectivePoint.Immutable(\n-                                    Secp256R1.zero.fixed(),\n-                                    Secp256R1.zero.getField().get1().fixed(),\n-                                    Secp256R1.zero.fixed());\n-                        } else {\n-                            PointMultiplier multiplier = new Default(\n-                                    Secp256R1Ops.instance,\n-                                    AffinePoint.fromECPoint(Secp256R1.point,\n-                                            Secp256R1.zero.getField()));\n-                            byte[] s = bi.toByteArray();\n-                            ArrayUtil.reverse(s);\n-                            ProjectivePoint.Mutable m =\n-                                    multiplier.pointMultiply(s);\n-                            points[d][w] = m.setValue(m.asAffine()).fixed();\n+                    for (int d = 0; d < 4; d++) {\n+                        for (int w = 0; w < 16; w++) {\n+                            BigInteger bi = base[w];\n+                            if (d != 0) {\n+                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                            }\n+                            if (w == 0) {\n+                                points[d][0] = new ProjectivePoint.Immutable(\n+                                    zero.fixed(), one.fixed(), zero.fixed());\n+                            } else {\n+                                PointMultiplier multiplier = new Default(\n+                                    secp256r1Ops, AffinePoint.fromECPoint(\n+                                        point, zero.getField()));\n+                                byte[] s = bi.toByteArray();\n+                                ArrayUtil.reverse(s);\n+                                ProjectivePoint.Mutable m =\n+                                        multiplier.pointMultiply(s);\n+                                points[d][w] = m.setValue(m.asAffine()).fixed();\n+                            }\n@@ -631,0 +661,5 @@\n+\n+                    \/\/ Check that the tables are correctly generated.\n+                    if (ECOperations.class.desiredAssertionStatus()) {\n+                        verifyTables(base);\n+                    }\n@@ -633,22 +668,23 @@\n-                \/\/ Check that the tables are correctly generated.\n-                for (int d = 0; d < 4; d++) {\n-                    for (int w = 0; w < 16; w++) {\n-                        BigInteger bi = base[w];\n-                        if (d != 0) {\n-                            bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n-                        }\n-                        if (w != 0) {\n-                            byte[] s = new byte[32];\n-                            byte[] b = bi.toByteArray();\n-                            ArrayUtil.reverse(b);\n-                            System.arraycopy(b, 0, s, 0, b.length);\n-\n-                            ProjectivePoint.Mutable m =\n-                                    Secp256R1.multiplier.pointMultiply(s);\n-                            ProjectivePoint.Immutable v =\n-                                    m.setValue(m.asAffine()).fixed();\n-                            if (!v.getX().asBigInteger().equals(\n-                                    points[d][w].getX().asBigInteger()) ||\n-                                !v.getY().asBigInteger().equals(\n-                                    points[d][w].getY().asBigInteger())) {\n-                                throw new RuntimeException();\n+                private static void verifyTables(BigInteger[] base) {\n+                    for (int d = 0; d < 4; d++) {\n+                        for (int w = 0; w < 16; w++) {\n+                            BigInteger bi = base[w];\n+                            if (d != 0) {\n+                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                            }\n+                            if (w != 0) {\n+                                byte[] s = new byte[32];\n+                                byte[] b = bi.toByteArray();\n+                                ArrayUtil.reverse(b);\n+                                System.arraycopy(b, 0, s, 0, b.length);\n+\n+                                ProjectivePoint.Mutable m =\n+                                        multiplier.pointMultiply(s);\n+                                ProjectivePoint.Immutable v =\n+                                        m.setValue(m.asAffine()).fixed();\n+                                if (!v.getX().asBigInteger().equals(\n+                                        points[d][w].getX().asBigInteger()) ||\n+                                    !v.getY().asBigInteger().equals(\n+                                        points[d][w].getY().asBigInteger())) {\n+                                    throw new RuntimeException();\n+                                }\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":122,"deletions":86,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-        \/\/ System.setProperty(\"jdk.tls.namedGroups\", \"secp256r1\");\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}