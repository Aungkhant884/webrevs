{"files":[{"patch":"@@ -3218,1 +3218,1 @@\n-    log_warning(os)(\"os::split_reserved_memory failed for [\" RANGE_FORMAT \")\",\n+    log_warning(os)(\"os::split_reserved_memory failed for \" RANGE_FORMAT,\n@@ -3220,1 +3220,2 @@\n-    assert(false, \"os::split_reserved_memory failed for [\" RANGE_FORMAT \")\",\n+    os::print_memory_mappings((char*)base, size, tty);\n+    assert(false, \"os::split_reserved_memory failed for \" RANGE_FORMAT,\n@@ -6000,1 +6001,4 @@\n-  assert(start != NULL && end != NULL && end > start, \"Sanity\");\n+  \/\/ Print it like this:\n+  \/\/\n+  \/\/ Base: <xxxxx>: [xxxx - xxxx], state=MEM_xxx, prot=x, type=MEM_xxx       (region 1)\n+  \/\/                [xxxx - xxxx], state=MEM_xxx, prot=x, type=MEM_xxx       (region 2)\n@@ -6003,2 +6007,0 @@\n-  address last_region_end = NULL;\n-  st->print_cr(\"AllocationBase: \" PTR_FORMAT \":\", allocation_base);\n@@ -6006,0 +6008,1 @@\n+  bool first_line = true;\n@@ -6007,0 +6010,6 @@\n+    if (first_line) {\n+      st->print(\"Base \" PTR_FORMAT \": \", p2i(allocation_base));\n+    } else {\n+      st->print_raw(NOT_LP64 (\"                 \")\n+                    LP64_ONLY(\"                         \"));\n+    }\n@@ -6024,1 +6033,1 @@\n-    st->print(\", prot=%x, type=\", (unsigned)minfo->AllocationProtect);\n+    st->print(\", prot=%x, type=\", (unsigned)minfo->Protect);\n@@ -6031,0 +6040,12 @@\n+    \/\/ At the start of every allocation, print some more information about this mapping.\n+    \/\/ Notes:\n+    \/\/  - this could be beefed up a lot, similar to os::print_location\n+    \/\/  - for now we just query the allocation start point. This may be confusing for cases where\n+    \/\/    the kernel merges multiple mappings.\n+    if (first_line) {\n+      char buf[MAX_PATH];\n+      int dummy;\n+      if (os::dll_address_to_library_name(allocation_base, buf, sizeof(buf), &dummy)) {\n+        st->print(\" %s\", buf);\n+      }\n+    }\n@@ -6032,0 +6053,1 @@\n+    \/\/ Next region...\n@@ -6040,0 +6062,1 @@\n+    first_line = false;\n@@ -6051,1 +6074,8 @@\n-  while (p < end) {\n+  if (p == NULL) { \/\/ Lets skip the zero pages.\n+    p += os::vm_allocation_granularity();\n+  }\n+  address p2 = p; \/\/ guard against wraparounds\n+  int fuse = 0;\n+\n+  while (p < end && p >= p2) {\n+    p2 = p;\n@@ -6069,2 +6099,19 @@\n-      \/\/ advance probe pointer.\n-      p += os::vm_allocation_granularity();\n+      \/\/ MSDN doc on VirtualQuery is unclear about what it means if it returns an error.\n+      \/\/  In particular, whether querying an address outside any mappings would report\n+      \/\/  a MEM_FREE region or just return an error. From experiments, it seems to return\n+      \/\/  a MEM_FREE region for unmapped areas in valid address space and an error if we\n+      \/\/  are outside valid address space.\n+      \/\/ Here, we advance the probe pointer by alloc granularity. But if the range to print\n+      \/\/  is large, this may take a long time. Therefore lets stop right away if the address\n+      \/\/  is outside of what we know are valid addresses on Windows. Also, add a loop fuse.\n+      static const address end_phys = (address)(LP64_ONLY(0x7ffffffffffULL) NOT_LP64(3*G));\n+      if (p >= end_phys) {\n+        break;\n+      } else {\n+        \/\/ Advance probe pointer, but with a fuse to break long loops.\n+        if (fuse++ == 100000) {\n+          break;\n+        }\n+        \/\/ Advance probe pointer.\n+        p += os::vm_allocation_granularity();\n+      }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":56,"deletions":9,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1740,0 +1740,5 @@\n+\/\/ Prints all mappings\n+void os::print_memory_mappings(outputStream* st) {\n+  os::print_memory_mappings(NULL, (size_t)-1, st);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -352,0 +352,2 @@\n+  \/\/ Prints all mappings\n+  static void print_memory_mappings(outputStream* st);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -498,5 +499,26 @@\n-TEST_VM(os, show_mappings_1) {\n-  \/\/ Display an arbitrary large address range. Make this works, does not hang, etc.\n-  char dummy[16 * K]; \/\/ silent truncation is fine, we don't care.\n-  stringStream ss(dummy, sizeof(dummy));\n-  os::print_memory_mappings((char*)0x1000, LP64_ONLY(1024) NOT_LP64(3) * G, &ss);\n+static void test_show_mappings(address start, size_t size) {\n+  \/\/ Note: should this overflow, thats okay. stream will silently truncate. Does not matter for the test.\n+  const size_t buflen = 4 * M;\n+  char* buf = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n+  buf[0] = '\\0';\n+  stringStream ss(buf, buflen);\n+  if (start != NULL) {\n+    os::print_memory_mappings((char*)start, size, &ss);\n+  } else {\n+    os::print_memory_mappings(&ss); \/\/ prints full address space\n+  }\n+  \/\/ Still an empty implementation on MacOS and AIX\n+#if defined(LINUX) || defined(_WIN32)\n+  EXPECT_NE(buf[0], '\\0');\n+#endif\n+  \/\/ buf[buflen - 1] = '\\0';\n+  \/\/ tty->print_raw(buf);\n+  FREE_C_HEAP_ARRAY(char, buf);\n+}\n+\n+TEST_VM(os, show_mappings_small_range) {\n+  test_show_mappings((address)0x100000, 2 * G);\n+}\n+\n+TEST_VM(os, show_mappings_full_range) {\n+  test_show_mappings(NULL, 0);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"}]}