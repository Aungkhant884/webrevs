{"files":[{"patch":"@@ -3218,1 +3218,1 @@\n-    log_warning(os)(\"os::split_reserved_memory failed for [\" RANGE_FORMAT \")\",\n+    log_warning(os)(\"os::split_reserved_memory failed for \" RANGE_FORMAT,\n@@ -3220,1 +3220,2 @@\n-    assert(false, \"os::split_reserved_memory failed for [\" RANGE_FORMAT \")\",\n+    os::print_memory_mappings(base, size, tty);\n+    assert(false, \"os::split_reserved_memory failed for \" RANGE_FORMAT,\n@@ -5992,0 +5993,27 @@\n+\/\/ Helper for print_one_mapping: print n words, both as hex and ascii.\n+\/\/ Use Safefetch for all values.\n+static void print_snippet(const void* p, outputStream* st) {\n+  static const int num_words = LP64_ONLY(3) NOT_LP64(6);\n+  static const int num_bytes = num_words * sizeof(int);\n+  intptr_t v[num_words];\n+  const int errval = 0xDE210244;\n+  for (int i = 0; i < num_words; i++) {\n+    v[i] = SafeFetchN((intptr_t*)p + i, errval);\n+    if (v[i] == errval &&\n+        SafeFetchN((intptr_t*)p + i, ~errval) == ~errval) {\n+      return;\n+    }\n+  }\n+  st->put('[');\n+  for (int i = 0; i < num_words; i++) {\n+    st->print(INTPTR_FORMAT \" \", v[i]);\n+  }\n+  const char* b = (char*)v;\n+  st->put('\\\"');\n+  for (int i = 0; i < num_bytes; i++) {\n+    st->put(::isgraph(b[i]) ? b[i] : '.');\n+  }\n+  st->put('\\\"');\n+  st->put(']');\n+}\n+\n@@ -5998,1 +6026,4 @@\n-  assert(start != NULL && end != NULL && end > start, \"Sanity\");\n+  \/\/ Print it like this:\n+  \/\/\n+  \/\/ Base: <xxxxx>: [xxxx - xxxx], state=MEM_xxx, prot=x, type=MEM_xxx       (region 1)\n+  \/\/                [xxxx - xxxx], state=MEM_xxx, prot=x, type=MEM_xxx       (region 2)\n@@ -6001,2 +6032,0 @@\n-  address last_region_end = NULL;\n-  st->print_cr(\"AllocationBase: \" PTR_FORMAT \":\", allocation_base);\n@@ -6004,0 +6033,2 @@\n+  bool first_line = true;\n+  bool is_dll = false;\n@@ -6005,0 +6036,6 @@\n+    if (first_line) {\n+      st->print(\"Base \" PTR_FORMAT \": \", p2i(allocation_base));\n+    } else {\n+      st->print_raw(NOT_LP64 (\"                 \")\n+                    LP64_ONLY(\"                         \"));\n+    }\n@@ -6017,3 +6054,3 @@\n-      case MEM_COMMIT: st->print(\"MEM_COMMIT\"); break;\n-      case MEM_FREE: st->print(\"MEM_FREE\"); break;\n-      case MEM_RESERVE: st->print(\"MEM_RESERVE\"); break;\n+      case MEM_COMMIT:  st->print_raw(\"MEM_COMMIT \"); break;\n+      case MEM_FREE:    st->print_raw(\"MEM_FREE   \"); break;\n+      case MEM_RESERVE: st->print_raw(\"MEM_RESERVE\"); break;\n@@ -6022,1 +6059,1 @@\n-    st->print(\", prot=%x, type=\", (unsigned)minfo->AllocationProtect);\n+    st->print(\", prot=%3x, type=\", (unsigned)minfo->Protect);\n@@ -6024,3 +6061,3 @@\n-      case MEM_IMAGE: st->print(\"MEM_IMAGE\"); break;\n-      case MEM_MAPPED: st->print(\"MEM_MAPPED\"); break;\n-      case MEM_PRIVATE: st->print(\"MEM_PRIVATE\"); break;\n+      case MEM_IMAGE:   st->print_raw(\"MEM_IMAGE  \"); break;\n+      case MEM_MAPPED:  st->print_raw(\"MEM_MAPPED \"); break;\n+      case MEM_PRIVATE: st->print_raw(\"MEM_PRIVATE\"); break;\n@@ -6029,0 +6066,19 @@\n+    \/\/ At the start of every allocation, print some more information about this mapping.\n+    \/\/ Notes:\n+    \/\/  - this could be beefed up a lot, similar to os::print_location\n+    \/\/  - for now we just query the allocation start point. This may be confusing for cases where\n+    \/\/    the kernel merges multiple mappings.\n+    if (first_line) {\n+      char buf[MAX_PATH];\n+      if (os::dll_address_to_library_name(allocation_base, buf, sizeof(buf), nullptr)) {\n+        st->print(\", %s\", buf);\n+        is_dll = true;\n+      }\n+    }\n+    \/\/ If memory is accessible, and we do not know anything else about it, print a snippet\n+    if (!is_dll &&\n+        minfo->State == MEM_COMMIT &&\n+        !(minfo->Protect & PAGE_NOACCESS || minfo->Protect & PAGE_GUARD)) {\n+      st->print_raw(\", \");\n+      print_snippet(region_start, st);\n+    }\n@@ -6030,0 +6086,1 @@\n+    \/\/ Next region...\n@@ -6038,0 +6095,1 @@\n+    first_line = false;\n@@ -6049,1 +6107,8 @@\n-  while (p < end) {\n+  if (p == nullptr) { \/\/ Lets skip the zero pages.\n+    p += os::vm_allocation_granularity();\n+  }\n+  address p2 = p; \/\/ guard against wraparounds\n+  int fuse = 0;\n+\n+  while (p < end && p >= p2) {\n+    p2 = p;\n@@ -6067,2 +6132,18 @@\n-      \/\/ advance probe pointer.\n-      p += os::vm_allocation_granularity();\n+      \/\/ MSDN doc on VirtualQuery is unclear about what it means if it returns an error.\n+      \/\/  In particular, whether querying an address outside any mappings would report\n+      \/\/  a MEM_FREE region or just return an error. From experiments, it seems to return\n+      \/\/  a MEM_FREE region for unmapped areas in valid address space and an error if we\n+      \/\/  are outside valid address space.\n+      \/\/ Here, we advance the probe pointer by alloc granularity. But if the range to print\n+      \/\/  is large, this may take a long time. Therefore lets stop right away if the address\n+      \/\/  is outside of what we know are valid addresses on Windows. Also, add a loop fuse.\n+      static const address end_virt = (address)(LP64_ONLY(0x7ffffffffffULL) NOT_LP64(3*G));\n+      if (p >= end_virt) {\n+        break;\n+      } else {\n+        \/\/ Advance probe pointer, but with a fuse to break long loops.\n+        if (fuse++ == 100000) {\n+          break;\n+        }\n+        p += os::vm_allocation_granularity();\n+      }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":96,"deletions":15,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1740,0 +1740,5 @@\n+\/\/ Prints all mappings\n+void os::print_memory_mappings(outputStream* st) {\n+  os::print_memory_mappings(nullptr, (size_t)-1, st);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -352,0 +352,2 @@\n+  \/\/ Prints all mappings\n+  static void print_memory_mappings(outputStream* st);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -497,5 +498,37 @@\n-TEST_VM(os, show_mappings_1) {\n-  \/\/ Display an arbitrary large address range. Make this works, does not hang, etc.\n-  char dummy[16 * K]; \/\/ silent truncation is fine, we don't care.\n-  stringStream ss(dummy, sizeof(dummy));\n-  os::print_memory_mappings((char*)0x1000, LP64_ONLY(1024) NOT_LP64(3) * G, &ss);\n+static void test_show_mappings(address start, size_t size) {\n+  \/\/ Note: should this overflow, thats okay. stream will silently truncate. Does not matter for the test.\n+  const size_t buflen = 4 * M;\n+  char* buf = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n+  buf[0] = '\\0';\n+  stringStream ss(buf, buflen);\n+  if (start != nullptr) {\n+    os::print_memory_mappings((char*)start, size, &ss);\n+  } else {\n+    os::print_memory_mappings(&ss); \/\/ prints full address space\n+  }\n+  \/\/ Still an empty implementation on MacOS and AIX\n+#if defined(LINUX) || defined(_WIN32)\n+  EXPECT_NE(buf[0], '\\0');\n+#endif\n+  \/\/ buf[buflen - 1] = '\\0';\n+  \/\/ tty->print_raw(buf);\n+  FREE_C_HEAP_ARRAY(char, buf);\n+}\n+\n+TEST_VM(os, show_mappings_small_range) {\n+  test_show_mappings((address)0x100000, 2 * G);\n+}\n+\n+TEST_VM(os, show_mappings_full_range) {\n+  \/\/ Reserve a small range and fill it with a marker string, should show up\n+  \/\/ on implementations displaying range snippets\n+  char* p = os::reserve_memory(1 * M, mtInternal);\n+  if (p != nullptr) {\n+    if (os::commit_memory(p, 1 * M, false)) {\n+      strcpy(p, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n+    }\n+  }\n+  test_show_mappings(nullptr, 0);\n+  if (p != nullptr) {\n+    os::release_memory(p, 1 * M);\n+  }\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"}]}