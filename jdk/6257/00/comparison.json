{"files":[{"patch":"@@ -34,1 +34,0 @@\n-#include \"oops\/reflectionAccessorImplKlassHelper.hpp\"\n@@ -175,1 +174,1 @@\n-    \/\/ e.g. \"+--- jdk.internal.reflect.DelegatingClassLoader\"\n+    \/\/ e.g. +-- \"app\", jdk.internal.loader.ClassLoaders$AppClassLoader\n@@ -235,8 +234,0 @@\n-\n-            \/\/ Special treatment for generated core reflection accessor classes: print invocation target.\n-            if (ReflectionAccessorImplKlassHelper::is_generated_accessor(lci->_klass)) {\n-              st->print(\" (invokes: \");\n-              ReflectionAccessorImplKlassHelper::print_invocation_target(st, lci->_klass);\n-              st->print(\")\");\n-            }\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"oops\/reflectionAccessorImplKlassHelper.hpp\"\n@@ -477,6 +476,0 @@\n-  \/\/ Special treatment for generated core reflection accessor classes: print invocation target.\n-  if (ReflectionAccessorImplKlassHelper::is_generated_accessor(klass)) {\n-    st->print(\" (invokes: \");\n-    ReflectionAccessorImplKlassHelper::print_invocation_target(st, klass);\n-    st->print(\")\");\n-  }\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"oops\/reflectionAccessorImplKlassHelper.hpp\"\n@@ -49,7 +48,0 @@\n-\n-  \/\/ Special treatment for generated core reflection accessor classes: print invocation target.\n-  if (ReflectionAccessorImplKlassHelper::is_generated_accessor(k)) {\n-    _out->print(\" (invokes: \");\n-    ReflectionAccessorImplKlassHelper::print_invocation_target(_out, k);\n-    _out->print(\")\");\n-  }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/printMetaspaceInfoKlassClosure.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/constantPool.hpp\"\n-#include \"oops\/reflectionAccessorImplKlassHelper.hpp\"\n-#include \"utilities\/constantTag.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/\/ This code extracts name of target class, method and signature from the constant pool of a class\n-\/\/ assumed to be of type jdk\/internal\/reflect\/Generated{SerializationConstructor|Constructor|Method}AccessorXXX.\n-\/\/ Since this may be affected by bitrot if these classes change, extra care is taken to make the\n-\/\/ release build of this coding robust.\n-\n-\/\/ We extract target class name, method name and sig from the constant pool of the Accessor class.\n-\/\/ This is an excerpt of the Constant pool (see jdk\/internal\/reflect\/MethodAccessorGenerator.java:)\n-\n-\/\/ (^  = Only present if generating SerializationConstructorAccessor)\n-\/\/ 1    [UTF-8] [This class's name]\n-\/\/ 2    [CONSTANT_Class_info] for above\n-\/\/ 3    [UTF-8] \"jdk\/internal\/reflect\/{MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl}\"\n-\/\/ 4    [CONSTANT_Class_info] for above\n-\/\/ 5    [UTF-8] [Target class's name]\n-\/\/ 6    [CONSTANT_Class_info] for above\n-\/\/ 7^   [UTF-8] [Serialization: Class's name in which to invoke constructor]\n-\/\/ 8^   [CONSTANT_Class_info] for above\n-\/\/ 9    [UTF-8] target method or constructor name\n-\/\/ 10   [UTF-8] target method or constructor signature\n-\n-\/\/ Note that these strings are found at slightly different slots depending on the class type:\n-\/\/ - MethodAccessorImpl, ConstructoreAccessorImpl: slots 5, 7 and 8.\n-\/\/ - SerializationConstructorAccessorImpl: slots 5, 9 and 10.\n-\/\/ Unfortunately SerializationConstructorAccessorImpl is a child of ConstructoreAccessorImpl and there\n-\/\/  is no easy way to tell them apart. So we examine parent class name.\n-\n-enum cpi_slots {\n-  cpi_slot_parent_class_name = 3,\n-  cpi_slot_target_class_name = 5,\n-  cpi_slot_target_method_name = 7,\n-  cpi_slot_target_method_name_sca = 9, \/\/ SerializationConstructorAccessor case, see above\n-  cpi_slot_target_method_sig = 8,\n-  cpi_slot_target_method_sig_sca = 10  \/\/ SerializationConstructorAccessor case, see above\n-};\n-\n-\/\/ Returns a string, resource-area allocated, from an UTF8 slot in the constant pool in the\n-\/\/ given Klass*.\n-static const char* get_string_from_cp_with_checks(const InstanceKlass* k, int cpi) {\n-  const char* s = NULL;\n-  const ConstantPool* const cp = k->constants();\n-\n-  assert(cp != NULL, \"No cp?\");\n-  assert(cp->is_within_bounds(cpi), \"Unexpected constant pool layout for \\\"%s\\\", child class of Generated{Method|Constructor}AccessorImplXXX\"\n-         \" (cpi %d out of bounds for [0..%d)).\", k->external_name(), cpi, cp->length());\n-  assert(cp->tag_at(cpi).is_utf8(), \"Unexpected constant pool layout for \\\"%s\\\", child class of Generated{Method|Constructor}AccessorImplXXX\"\n-         \" (no UTF8 at cpi %d (%u)).\", k->external_name(), cpi, cp->tag_at(cpi).value());\n-\n-  \/\/ Be nice in release: lets not crash, just return NULL.\n-  if (cp != NULL && cp->is_within_bounds(cpi) && cp->tag_at(cpi).is_utf8()) {\n-    s = cp->symbol_at(cpi)->as_C_string();\n-  }\n-\n-  return s;\n-}\n-\n-\/\/ helper, returns true if class name of given class matches a given prefix\n-static bool classname_matches_prefix(const Klass* k, const char* prefix) {\n-  const char* classname = k->external_name();\n-  if (classname != NULL) {\n-    if (::strncmp(classname, prefix, strlen(prefix)) == 0) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ Returns true if k is of type jdk\/internal\/reflect\/GeneratedMethodAccessorXXX.\n-bool ReflectionAccessorImplKlassHelper::is_generated_method_accessor(const InstanceKlass* k) {\n-  return k->super() == vmClasses::reflect_MethodAccessorImpl_klass() &&\n-         classname_matches_prefix(k, \"jdk.internal.reflect.GeneratedMethodAccessor\");\n-}\n-\n-\/\/ Returns true if k is of type jdk\/internal\/reflect\/GeneratedConstructorAccessorXXX.\n-bool ReflectionAccessorImplKlassHelper::is_generated_constructor_accessor(const InstanceKlass* k) {\n-  return k->super() == vmClasses::reflect_ConstructorAccessorImpl_klass() &&\n-         classname_matches_prefix(k, \"jdk.internal.reflect.GeneratedConstructorAccessor\");\n-}\n-\n-\/\/ Returns true if k is of type jdk\/internal\/reflect\/GeneratedSerializationConstructorAccessorXXX.\n-bool ReflectionAccessorImplKlassHelper::is_generated_method_serialization_constructor_accessor(const InstanceKlass* k) {\n-  \/\/ GeneratedSerializationConstructorAccessor is not a direct subclass of ConstructorAccessorImpl\n-  const Klass* sk = k->super();\n-  if (sk != NULL && sk->super() == vmClasses::reflect_ConstructorAccessorImpl_klass() &&\n-      classname_matches_prefix(k, \"jdk.internal.reflect.GeneratedSerializationConstructorAccessor\")) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-const char* ReflectionAccessorImplKlassHelper::get_target_class_name(const InstanceKlass* k) {\n-  return get_string_from_cp_with_checks(k, cpi_slot_target_class_name);\n-}\n-\n-const char* ReflectionAccessorImplKlassHelper::get_target_method_name(const InstanceKlass* k) {\n-  const int target_method_name_cpi =\n-      is_generated_method_serialization_constructor_accessor(k) ? cpi_slot_target_method_name_sca : cpi_slot_target_method_name;\n-  return get_string_from_cp_with_checks(k, target_method_name_cpi);\n-}\n-\n-const char* ReflectionAccessorImplKlassHelper::get_target_method_signature(const InstanceKlass* k) {\n-  const int target_method_name_cpi =\n-      is_generated_method_serialization_constructor_accessor(k) ? cpi_slot_target_method_sig_sca : cpi_slot_target_method_sig;\n-  return get_string_from_cp_with_checks(k, target_method_name_cpi);\n-}\n-\n-\/\/ Returns true if this is either one of jdk\/internal\/reflect\/Generated{SerializationConstructor|Constructor|Method}AccessorXXX\n-\/\/ and it is safe to call print_invocation_target(k)\n-bool ReflectionAccessorImplKlassHelper::is_generated_accessor(const Klass* k) {\n-  if (k != NULL && k->is_instance_klass()) {\n-    const InstanceKlass* ik = InstanceKlass::cast(k);\n-    if (ik->is_initialized()) {\n-      return is_generated_method_accessor(ik) ||\n-             is_generated_constructor_accessor(ik) ||\n-             is_generated_method_serialization_constructor_accessor(ik);\n-    }\n-  }\n-  return false;\n-}\n-void ReflectionAccessorImplKlassHelper::print_invocation_target(outputStream* out, Klass* k) {\n-  assert(ReflectionAccessorImplKlassHelper::is_generated_accessor(k), \"Invariant\");\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  ResourceMark rm;\n-  const char* target_class_name = ReflectionAccessorImplKlassHelper::get_target_class_name(ik);\n-  const char* target_method_name = ReflectionAccessorImplKlassHelper::get_target_method_name(ik);\n-  const char* target_method_signature = ReflectionAccessorImplKlassHelper::get_target_method_signature(ik);\n-  out->print(\"%s::%s %s\",\n-      target_class_name != NULL ? target_class_name : \"?\",\n-      target_method_name != NULL ? target_method_name : \"?\",\n-      target_method_signature != NULL ? target_method_signature : \"?\");\n-}\n","filename":"src\/hotspot\/share\/oops\/reflectionAccessorImplKlassHelper.cpp","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_OOPS_REFLECTIONACCESSORIMPLKLASSHELPER_HPP\n-#define SHARE_OOPS_REFLECTIONACCESSORIMPLKLASSHELPER_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-\n-class InstanceKlass;\n-\n-\/\/ Helper for classes derived from jdk\/internal\/reflect\/{Method|Constructor}AccessorImpl:\n-\/\/ offers convenience functions to extract the names of target class\/method\/signature\n-\/\/ from the constant pool of these classes.\n-class ReflectionAccessorImplKlassHelper: public AllStatic {\n-\n-  \/\/ Returns true if k is of type jdk\/internal\/reflect\/GeneratedMethodAccessorXXX.\n-  static bool is_generated_method_accessor(const InstanceKlass* k);\n-\n-  \/\/ Returns true if k is of type jdk\/internal\/reflect\/GeneratedConstructorAccessorXXX.\n-  static bool is_generated_constructor_accessor(const InstanceKlass* k);\n-\n-  \/\/ Returns true if k is of type jdk\/internal\/reflect\/GeneratedSerializationConstructorAccessorXXX.\n-  static bool is_generated_method_serialization_constructor_accessor(const InstanceKlass* k);\n-\n-  \/\/ Assuming k is of type jdk\/internal\/reflect\/Generated{SerializationConstructor|Constructor|Method}AccessorXXX,\n-  \/\/ the name of the target class as resource-area allocated string.\n-  static const char* get_target_class_name(const InstanceKlass* k);\n-\n-  \/\/ Assuming k is of type jdk\/internal\/reflect\/Generated{SerializationConstructor|Constructor|Method}AccessorXXX,\n-  \/\/ the name of the target method as resource-area allocated string.\n-  static const char* get_target_method_name(const InstanceKlass* k);\n-\n-  \/\/ Assuming k is of type jdk\/internal\/reflect\/Generated{SerializationConstructor|Constructor|Method}AccessorXXX,\n-  \/\/ the signature of the target method as resource-area allocated string.\n-  static const char* get_target_method_signature(const InstanceKlass* k);\n-\n-public:\n-\n-  \/\/ Returns true if k is of type jdk\/internal\/reflect\/Generated{SerializationConstructor|Constructor|Method}AccessorXXX\n-  \/\/ and it is safe to call print_invocation_target(k)\n-  static bool is_generated_accessor(const Klass* k);\n-\n-  \/\/ Assuming k is of type jdk\/internal\/reflect\/Generated{SerializationConstructor|Constructor|Method}AccessorXXX,\n-  \/\/ print out target class, method, signature in one line.\n-  static void print_invocation_target(outputStream* out, Klass* k);\n-\n-};\n-\n-\n-\n-\n-#endif \/\/ SHARE_OOPS_REFLECTIONACCESSORIMPLKLASSHELPER_HPP\n","filename":"src\/hotspot\/share\/oops\/reflectionAccessorImplKlassHelper.hpp","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -56,4 +56,0 @@\n-\/\/      +-- jdk.internal.reflect.DelegatingClassLoader\n-\/\/      |\n-\/\/      +-- \"Kevin\", ClassLoaderHierarchyTest$TestClassLoader\n-\/\/      |\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ClassLoaderHierarchyTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-    \/\/ 0x00000008003b5508  0x0000000000000000  0x00007f001c2d4760       1      6144      4040  jdk.internal.reflect.DelegatingClassLoader\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ClassLoaderStatsTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import jdk.test.lib.dcmd.CommandExecutor;\n-import jdk.test.lib.dcmd.JMXExecutor;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-\/*\n- * @test\n- * @summary Test that various diagnostic commands which can show core reflection\n- *          invocation targets do so correctly (See: JDK-8203343).\n- * @library \/test\/lib\n- * @run testng\/othervm -Dsun.reflect.noInflation=true -Djdk.reflect.useDirectMethodHandle=false ShowReflectionTargetTest\n- * @author stuefe\n- *\/\n-\n-public class ShowReflectionTargetTest {\n-\n-    @SuppressWarnings(\"unused\")\n-    private static class Dummy {\n-        int _i;\n-        public Dummy(int i) { _i = i; }\n-        public int get_i() { return _i; }\n-    }\n-\n-    public void run(CommandExecutor executor) throws Exception {\n-        \/\/ Do some reflection; since we set -Dsun.reflect.noInflation=true, this should\n-        \/\/ immediately generate Generated{Method|Constructor}Accessor objects.\n-        Class<?> c = Class.forName(\"ShowReflectionTargetTest$Dummy\");\n-        Constructor<?> ctor = c.getConstructor(int.class);\n-        Method m = c.getMethod(\"get_i\");\n-\n-        Object o = ctor.newInstance(17);\n-        int j = ((Integer)m.invoke(o)).intValue();\n-        Assert.assertEquals(j, 17);\n-\n-        \/\/ Now invoke VM.class_hierarchy and check its output.\n-        \/\/ Should show reflection targets, e.g.:\n-        \/\/ ....\n-        \/\/        |--jdk.internal.reflect.MagicAccessorImpl\/null\n-        \/\/        |  |--jdk.internal.reflect.FieldAccessorImpl\/null\n-        \/\/        |  |  |--jdk.internal.reflect.UnsafeFieldAccessorImpl\/null\n-        \/\/        |  |  |  |--jdk.internal.reflect.UnsafeStaticFieldAccessorImpl\/null\n-        \/\/        |  |  |  |  |--jdk.internal.reflect.UnsafeQualifiedStaticFieldAccessorImpl\/null\n-        \/\/        |  |  |  |  |  |--jdk.internal.reflect.UnsafeQualifiedStaticObjectFieldAccessorImpl\/null\n-        \/\/        |  |--jdk.internal.reflect.ConstructorAccessorImpl\/null\n-        \/\/        |  |  |--jdk.internal.reflect.DelegatingConstructorAccessorImpl\/null\n-        \/\/        |  |  |--jdk.internal.reflect.NativeConstructorAccessorImpl\/null\n-        \/\/ >       |  |  |--jdk.internal.reflect.GeneratedConstructorAccessor1\/0x00007f75f04889b0 (invokes: java\/lang\/management\/ManagementPermission::<init> (Ljava\/lang\/String;)V)\n-        \/\/ >       |  |  |--jdk.internal.reflect.GeneratedConstructorAccessor2\/0x00007f75f0494990 (invokes: ShowReflectionTargetTest$Dummy::<init> (I)V)\n-        \/\/        |  |  |--jdk.internal.reflect.BootstrapConstructorAccessorImpl\/null\n-        \/\/        |  |--jdk.internal.reflect.MethodAccessorImpl\/null\n-        \/\/ >       |  |  |--jdk.internal.reflect.GeneratedMethodAccessor1\/0x00007f75f0494450 (invokes: ShowReflectionTargetTest$Dummy::get_i ()I)\n-        \/\/        |  |  |--jdk.internal.reflect.DelegatingMethodAccessorImpl\/null\n-        \/\/ ...\n-\n-        OutputAnalyzer output = executor.execute(\"VM.class_hierarchy\");\n-\n-        output.shouldMatch(\".*jdk.internal.reflect.GeneratedConstructorAccessor.*invokes.*ShowReflectionTargetTest\\\\$Dummy::<init>.*\");\n-        output.shouldMatch(\".*jdk.internal.reflect.GeneratedMethodAccessor.*invokes.*ShowReflectionTargetTest\\\\$Dummy::get_i.*\");\n-\n-    }\n-\n-    @Test\n-    public void jmx() throws Exception {\n-        run(new JMXExecutor());\n-    }\n-\n-}\n-\n-\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ShowReflectionTargetTest.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"}]}