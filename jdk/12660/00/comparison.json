{"files":[{"patch":"@@ -370,3 +370,1 @@\n-      bool failures = false;\n-      r->verify(_vo, &failures);\n-      if (failures) {\n+      if (r->verify(_vo)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,3 +67,1 @@\n-  Klass* k = obj->klass();\n-  const char* class_name = k->external_name();\n-  out->print_cr(\"class name %s\", class_name);\n+  obj->print_name_on(out);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -251,2 +251,2 @@\n-  bool has_failures() { return _num_failures != 0; }\n-  size_t num_failures() { return _num_failures; }\n+  bool has_failures() const { return _num_failures != 0; }\n+  size_t num_failures() const { return _num_failures; }\n@@ -255,0 +255,4 @@\n+\n+  \/\/ Returns whether the given oop is an oop, with some extra checks regarding\n+  \/\/ the klass of that oop that might be broken.\n+  static inline bool is_oop_safe(oop obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -318,0 +318,23 @@\n+inline bool G1VerificationClosure::is_oop_safe(oop obj) {\n+  if (!oopDesc::is_oop(obj)) {\n+    log_error(gc, verify)(PTR_FORMAT \" not an oop\", p2i(obj));\n+    return false;\n+  }\n+\n+  \/\/ Now examine the Klass a little more closely.\n+  Klass* klass = obj->klass_raw();\n+\n+  bool is_metaspace_object = Metaspace::contains(klass);\n+  if (!is_metaspace_object) {\n+    log_error(gc, verify)(\"klass \" PTR_FORMAT \" of object \" PTR_FORMAT \" \"\n+                          \"not metadata\", p2i(klass), p2i(obj));\n+    return false;\n+  } else if (!klass->is_klass()) {\n+    log_error(gc, verify)(\"klass \" PTR_FORMAT \" of object \" PTR_FORMAT \" \"\n+                          \"not a klass\", p2i(klass), p2i(obj));\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-void HeapRegion::verify_code_roots(VerifyOption vo, bool* failures) const {\n+bool HeapRegion::verify_code_roots(VerifyOption vo) const {\n@@ -392,1 +392,1 @@\n-    return;\n+    return false;\n@@ -402,1 +402,1 @@\n-    return;\n+    return false;\n@@ -411,1 +411,2 @@\n-    if (code_roots_length > 0) {\n+    bool has_code_roots = code_roots_length > 0;\n+    if (has_code_roots) {\n@@ -414,1 +415,0 @@\n-      *failures = true;\n@@ -416,1 +416,1 @@\n-    return;\n+    return has_code_roots;\n@@ -420,1 +420,2 @@\n-    if (code_roots_length > 0) {\n+    bool has_code_roots = code_roots_length > 0;\n+    if (has_code_roots) {\n@@ -423,1 +424,0 @@\n-      *failures = true;\n@@ -425,1 +425,1 @@\n-    return;\n+    return has_code_roots;\n@@ -431,3 +431,1 @@\n-  if (cb_cl.failures()) {\n-    *failures = true;\n-  }\n+  return cb_cl.failures();\n@@ -462,2 +460,4 @@\n-class VerifyRemSetClosure : public G1VerificationClosure {\n-  G1CardTable *_ct;\n+\/\/ Closure that glues together validity check for oop references (first),\n+\/\/ then optionally verifies the remembered set for that reference.\n+class G1VerifyLiveAndRemSetClosure : public BasicOopIterateClosure {\n+  G1VerifyLiveClosure _live_closure;\n@@ -465,4 +465,5 @@\n-  template <class T>\n-  void do_oop_work(T* p) {\n-    assert(_containing_obj != nullptr, \"Precondition\");\n-    assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo), \"Precondition\");\n+  \/\/ Helper closure to verify the remembered set entry of a given reference. Assumes\n+  \/\/ that the reference passed to it has already been checked for validity (or may\n+  \/\/ be null).\n+  class VerifyRemSetClosure : public G1VerificationClosure {\n+    G1CardTable *_ct;\n@@ -470,4 +471,4 @@\n-    T heap_oop = RawAccess<>::oop_load(p);\n-    if (CompressedOops::is_null(heap_oop)) {\n-      return;\n-    }\n+    template <class T>\n+    void do_oop_work(T* p) {\n+      assert(_containing_obj != nullptr, \"Precondition\");\n+      assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo), \"Precondition\");\n@@ -475,1 +476,7 @@\n-    oop obj = CompressedOops::decode_raw_not_null(heap_oop);\n+      T heap_oop = RawAccess<>::oop_load(p);\n+      if (CompressedOops::is_null(heap_oop)) {\n+        return;\n+      }\n+\n+      oop obj = CompressedOops::decode_raw_not_null(heap_oop);\n+      assert(is_oop_safe(obj), \"must be\");\n@@ -477,6 +484,3 @@\n-    HeapRegion* from = _g1h->heap_region_containing(p);\n-    HeapRegion* to = _g1h->heap_region_containing_or_null(obj);\n-    if (to != nullptr &&\n-        from != to &&\n-        !to->is_pinned() &&\n-        to->rem_set()->is_complete()) {\n+      HeapRegion* from = _g1h->heap_region_containing(p);\n+      HeapRegion* to = _g1h->heap_region_containing(obj);\n+      if (from != to && !from->is_young() && to->rem_set()->is_complete()) {\n@@ -484,3 +488,3 @@\n-      jbyte cv_obj = *_ct->byte_for_const(_containing_obj);\n-      jbyte cv_field = *_ct->byte_for_const(p);\n-      const jbyte dirty = G1CardTable::dirty_card_val();\n+        jbyte cv_obj = *_ct->byte_for_const(_containing_obj);\n+        jbyte cv_field = *_ct->byte_for_const(p);\n+        const jbyte dirty = G1CardTable::dirty_card_val();\n@@ -488,5 +492,4 @@\n-      bool is_bad = !(from->is_young() ||\n-                      to->rem_set()->contains_reference(p) ||\n-                      (_containing_obj->is_objArray() ?\n-                       cv_field == dirty :\n-                       cv_obj == dirty || cv_field == dirty));\n+        bool is_bad = !(to->rem_set()->contains_reference(p) ||\n+                        (_containing_obj->is_objArray() ?\n+                         cv_field == dirty :\n+                         cv_obj == dirty || cv_field == dirty));\n@@ -494,4 +497,4 @@\n-      if (is_bad) {\n-        ResourceMark rm;\n-        Log(gc, verify) log;\n-        LogStream ls(log.error());\n+        if (is_bad) {\n+          ResourceMark rm;\n+          Log(gc, verify) log;\n+          LogStream ls(log.error());\n@@ -499,1 +502,1 @@\n-        MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n+          MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n@@ -501,1 +504,11 @@\n-        if (!has_failures()) {\n+          if (!has_failures()) {\n+            log.error(\"----------\");\n+          }\n+          log.error(\"Missing rem set entry:\");\n+          log.error(\"Field \" PTR_FORMAT \" of obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n+                    p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n+          _containing_obj->print_on(&ls);\n+          log.error(\"points to obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n+                    p2i(obj), HR_FORMAT_PARAMS(to), to->rem_set()->get_state_str());\n+          print_object(&ls, obj);\n+          log.error(\"Obj head CTE = %d, field CTE = %d.\", cv_obj, cv_field);\n@@ -503,0 +516,1 @@\n+          _num_failures++;\n@@ -504,12 +518,0 @@\n-        log.error(\"Missing rem set entry:\");\n-        log.error(\"Field \" PTR_FORMAT \" of obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-                  p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n-        _containing_obj->print_on(&ls);\n-        log.error(\"points to obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n-                  p2i(obj), HR_FORMAT_PARAMS(to), to->rem_set()->get_state_str());\n-        if (oopDesc::is_oop(obj)) {\n-          obj->print_on(&ls);\n-        }\n-        log.error(\"Obj head CTE = %d, field CTE = %d.\", cv_obj, cv_field);\n-        log.error(\"----------\");\n-        _num_failures++;\n@@ -518,1 +520,0 @@\n-  }\n@@ -520,2 +521,2 @@\n-public:\n-  VerifyRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo), _ct(g1h->card_table()) {}\n+  public:\n+    VerifyRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo), _ct(g1h->card_table()) {}\n@@ -523,3 +524,5 @@\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p) { do_oop_work(p); }\n-};\n+    virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n+    virtual void do_oop(oop* p) { do_oop_work(p); }\n+  } _remset_closure;\n+\n+  bool _verify_remsets;\n@@ -527,6 +530,0 @@\n-\/\/ Closure that applies the given two closures in sequence.\n-class G1Mux2Closure : public BasicOopIterateClosure {\n-  OopClosure* _c1;\n-  OopClosure* _c2;\n-public:\n-  G1Mux2Closure(OopClosure *c1, OopClosure *c2) { _c1 = c1; _c2 = c2; }\n@@ -534,3 +531,8 @@\n-    \/\/ Apply first closure; then apply the second.\n-    _c1->do_oop(p);\n-    _c2->do_oop(p);\n+    size_t num_failures_before = _live_closure.num_failures();\n+    _live_closure.do_oop(p);\n+\n+    if (_verify_remsets &&\n+        \/\/ Do not try verifying remembered sets if that reference already had a failure.\n+        num_failures_before != _live_closure.num_failures()) {\n+      _remset_closure.do_oop(p);\n+    }\n@@ -538,1 +540,14 @@\n-  virtual inline void do_oop(oop* p) { do_oop_work(p); }\n+\n+public:\n+  G1VerifyLiveAndRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo, bool verify_remsets) :\n+    _live_closure(g1h, vo),\n+    _remset_closure(g1h, vo),\n+    _verify_remsets(verify_remsets) { }\n+\n+  void set_containing_obj(oop const obj) {\n+    _live_closure.set_containing_obj(obj);\n+    _remset_closure.set_containing_obj(obj);\n+  }\n+\n+  size_t num_failures() const { return _live_closure.num_failures() + _remset_closure.num_failures(); }\n+\n@@ -540,0 +555,1 @@\n+  virtual inline void do_oop(oop* p) { do_oop_work(p); }\n@@ -542,2 +558,1 @@\n-void HeapRegion::verify(VerifyOption vo,\n-                        bool* failures) const {\n+bool HeapRegion::verify_liveness_and_remset(VerifyOption vo) const {\n@@ -545,10 +560,8 @@\n-  *failures = false;\n-  HeapWord* p = bottom();\n-  HeapWord* prev_p = NULL;\n-  G1VerifyLiveClosure vl_cl(g1h, vo);\n-  VerifyRemSetClosure vr_cl(g1h, vo);\n-  bool is_region_humongous = is_humongous();\n-  \/\/ We cast p to an oop, so region-bottom must be an obj-start.\n-  assert(!is_region_humongous || is_starts_humongous(), \"invariant\");\n-  size_t object_num = 0;\n-  while (p < top()) {\n+\n+  bool verify_rem_sets = !g1h->collector_state()->in_full_gc() || G1VerifyRSetsDuringFullGC;\n+  G1VerifyLiveAndRemSetClosure cl(g1h, vo, verify_rem_sets);\n+\n+  size_t other_failures = 0;\n+\n+  HeapWord* p;\n+  for (p = bottom(); p < top(); p += block_size(p)) {\n@@ -556,47 +569,3 @@\n-    size_t obj_size = block_size(p);\n-    object_num += 1;\n-\n-    if (!g1h->is_obj_dead_cond(obj, this, vo)) {\n-      if (oopDesc::is_oop(obj)) {\n-        Klass* klass = obj->klass();\n-        bool is_metaspace_object = Metaspace::contains(klass);\n-        if (!is_metaspace_object) {\n-          log_error(gc, verify)(\"klass \" PTR_FORMAT \" of object \" PTR_FORMAT \" \"\n-                                \"not metadata\", p2i(klass), p2i(obj));\n-          *failures = true;\n-          return;\n-        } else if (!klass->is_klass()) {\n-          log_error(gc, verify)(\"klass \" PTR_FORMAT \" of object \" PTR_FORMAT \" \"\n-                                \"not a klass\", p2i(klass), p2i(obj));\n-          *failures = true;\n-          return;\n-        } else {\n-          vl_cl.set_containing_obj(obj);\n-          if (!g1h->collector_state()->in_full_gc() || G1VerifyRSetsDuringFullGC) {\n-            \/\/ verify liveness and rem_set\n-            vr_cl.set_containing_obj(obj);\n-            G1Mux2Closure mux(&vl_cl, &vr_cl);\n-            obj->oop_iterate(&mux);\n-\n-            if (vr_cl.has_failures()) {\n-              *failures = true;\n-            }\n-            if (vr_cl.num_failures() >= G1MaxVerifyFailures) {\n-              return;\n-            }\n-          } else {\n-            \/\/ verify only liveness\n-            obj->oop_iterate(&vl_cl);\n-          }\n-          if (vl_cl.has_failures()) {\n-            *failures = true;\n-          }\n-          if (vl_cl.num_failures() >= G1MaxVerifyFailures) {\n-            return;\n-          }\n-        }\n-      } else {\n-        log_error(gc, verify)(PTR_FORMAT \" not an oop\", p2i(obj));\n-        *failures = true;\n-        return;\n-      }\n+\n+    if (g1h->is_obj_dead_cond(obj, this, vo)) {\n+      continue;\n@@ -604,2 +573,27 @@\n-    prev_p = p;\n-    p += obj_size;\n+\n+    if (G1VerificationClosure::is_oop_safe(obj)) {\n+      cl.set_containing_obj(obj);\n+      obj->oop_iterate(&cl);\n+    } else {\n+      other_failures++;\n+    }\n+\n+    if ((cl.num_failures() + other_failures) >= G1MaxVerifyFailures) {\n+      return true;\n+    }\n+  }\n+\n+  if (!is_humongous() && p != top()) {\n+    log_error(gc, verify)(\"end of last object \" PTR_FORMAT \" does not match top \" PTR_FORMAT,\n+                          p2i(p), p2i(top()));\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool HeapRegion::verify(VerifyOption vo) const {\n+  \/\/ We cast p to an oop, so region-bottom must be an obj-start.\n+  assert(!is_humongous() || is_starts_humongous(), \"invariant\");\n+\n+  if (verify_liveness_and_remset(vo)) {\n+    return true;\n@@ -613,1 +607,1 @@\n-  if (is_region_humongous) {\n+  if (is_humongous()) {\n@@ -617,2 +611,1 @@\n-      *failures = true;\n-      return;\n+      return true;\n@@ -622,8 +615,1 @@\n-  if (!is_region_humongous && p != top()) {\n-    log_error(gc, verify)(\"end of last object \" PTR_FORMAT \" \"\n-                          \"does not match top \" PTR_FORMAT, p2i(p), p2i(top()));\n-    *failures = true;\n-    return;\n-  }\n-\n-  verify_code_roots(vo, failures);\n+  return verify_code_roots(vo);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":129,"deletions":143,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -582,1 +582,3 @@\n-  void verify_code_roots(VerifyOption vo, bool* failures) const;\n+  \/\/ Returns whether there has been a failure.\n+  bool verify_code_roots(VerifyOption vo) const;\n+  bool verify_liveness_and_remset(VerifyOption vo) const;\n@@ -587,1 +589,1 @@\n-  void verify(VerifyOption vo, bool* failures) const;\n+  bool verify(VerifyOption vo) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  if (is_in(object->klass_or_null())) {\n+  if (is_in(object->klass_raw())) {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,10 @@\n+void oopDesc::print_name_on(outputStream* st) const {\n+  if (*((juint*)this) == badHeapWordVal) {\n+    st->print_cr(\"BAD WORD\");\n+  } else if (*((juint*)this) == badMetaWordVal) {\n+    st->print_cr(\"BAD META WORD\");\n+  } else {\n+    st->print_cr(\"%s\", klass()->external_name());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -228,2 +228,2 @@\n-  void print_on(outputStream* st) const;        \/\/ First level print\n-  void print_value_on(outputStream* st) const;  \/\/ Second level print.\n+  void print_on(outputStream* st) const;         \/\/ First level print\n+  void print_value_on(outputStream* st) const;   \/\/ Second level print.\n@@ -231,0 +231,1 @@\n+  void print_name_on(outputStream* st) const;    \/\/ External name printing.\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}