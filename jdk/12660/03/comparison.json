{"files":[{"patch":"@@ -370,3 +370,1 @@\n-      bool failures = false;\n-      r->verify(_vo, &failures);\n-      if (failures) {\n+      if (r->verify(_vo)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,13 +61,0 @@\n-\n-G1VerificationClosure::G1VerificationClosure(G1CollectedHeap* g1h, VerifyOption vo) :\n-  _g1h(g1h), _containing_obj(nullptr), _num_failures(0), _vo(vo) { }\n-\n-void G1VerificationClosure::print_object(outputStream* out, oop obj) {\n-#ifdef PRODUCT\n-  Klass* k = obj->klass();\n-  const char* class_name = k->external_name();\n-  out->print_cr(\"class name %s\", class_name);\n-#else \/\/ PRODUCT\n-  obj->print_on(out);\n-#endif \/\/ PRODUCT\n-}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -237,32 +237,0 @@\n-class G1VerificationClosure : public BasicOopIterateClosure {\n-protected:\n-  G1CollectedHeap* _g1h;\n-  oop _containing_obj;\n-  size_t _num_failures;\n-  VerifyOption _vo;\n-\n-public:\n-  G1VerificationClosure(G1CollectedHeap* g1h, VerifyOption vo);\n-\n-  void set_containing_obj(oop obj) {\n-    _containing_obj = obj;\n-  }\n-\n-  bool has_failures() { return _num_failures != 0; }\n-  size_t num_failures() { return _num_failures; }\n-\n-  void print_object(outputStream* out, oop obj);\n-};\n-\n-class G1VerifyLiveClosure : public G1VerificationClosure {\n-\n-  template <class T>\n-  inline void do_oop_work(T* p);\n-\n-public:\n-  G1VerifyLiveClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo) {}\n-\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p) { do_oop_work(p); }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -275,43 +275,0 @@\n-template <class T>\n-inline void G1VerifyLiveClosure::do_oop_work(T* p) {\n-  assert(_containing_obj != nullptr, \"Precondition\");\n-  assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo), \"Precondition\");\n-\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (CompressedOops::is_null(heap_oop)) {\n-    return;\n-  }\n-\n-  ResourceMark rm;\n-\n-  Log(gc, verify) log;\n-  LogStream ls(log.error());\n-\n-  oop obj = CompressedOops::decode_raw_not_null(heap_oop);\n-  bool is_in_heap = _g1h->is_in(obj);\n-\n-  if (!is_in_heap || _g1h->is_obj_dead_cond(obj, _vo)) {\n-    MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n-\n-    if (!has_failures()) {\n-      log.error(\"----------\");\n-    }\n-\n-    HeapRegion* from = _g1h->heap_region_containing(p);\n-    log.error(\"Field \" PTR_FORMAT \" of live obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-              p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n-    print_object(&ls, _containing_obj);\n-\n-    if (!is_in_heap) {\n-      log.error(\"points to address \" PTR_FORMAT \" outside of heap\", p2i(obj));\n-    } else {\n-      HeapRegion* to = _g1h->heap_region_containing(obj);\n-      log.error(\"points to dead obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n-                p2i(obj), HR_FORMAT_PARAMS(to), to->rem_set()->get_state_str());\n-      print_object(&ls, obj);\n-    }\n-    log.error(\"----------\");\n-    _num_failures++;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-void HeapRegion::verify_code_roots(VerifyOption vo, bool* failures) const {\n+bool HeapRegion::verify_code_roots(VerifyOption vo) const {\n@@ -392,1 +392,1 @@\n-    return;\n+    return false;\n@@ -402,1 +402,1 @@\n-    return;\n+    return false;\n@@ -411,1 +411,2 @@\n-    if (code_roots_length > 0) {\n+    bool has_code_roots = code_roots_length > 0;\n+    if (has_code_roots) {\n@@ -414,1 +415,0 @@\n-      *failures = true;\n@@ -416,1 +416,1 @@\n-    return;\n+    return has_code_roots;\n@@ -420,1 +420,2 @@\n-    if (code_roots_length > 0) {\n+    bool has_code_roots = code_roots_length > 0;\n+    if (has_code_roots) {\n@@ -423,1 +424,0 @@\n-      *failures = true;\n@@ -425,1 +425,1 @@\n-    return;\n+    return has_code_roots;\n@@ -431,3 +431,1 @@\n-  if (cb_cl.failures()) {\n-    *failures = true;\n-  }\n+  return cb_cl.failures();\n@@ -462,1 +460,36 @@\n-class VerifyRemSetClosure : public G1VerificationClosure {\n+static bool is_oop_safe(oop obj) {\n+  if (!oopDesc::is_oop(obj)) {\n+    log_error(gc, verify)(PTR_FORMAT \" not an oop\", p2i(obj));\n+    return false;\n+  }\n+\n+  \/\/ Now examine the Klass a little more closely.\n+  Klass* klass = obj->klass_raw();\n+\n+  bool is_metaspace_object = Metaspace::contains(klass);\n+  if (!is_metaspace_object) {\n+    log_error(gc, verify)(\"klass \" PTR_FORMAT \" of object \" PTR_FORMAT \" \"\n+                          \"not metadata\", p2i(klass), p2i(obj));\n+    return false;\n+  } else if (!klass->is_klass()) {\n+    log_error(gc, verify)(\"klass \" PTR_FORMAT \" of object \" PTR_FORMAT \" \"\n+                          \"not a klass\", p2i(klass), p2i(obj));\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+\/\/ Closure that glues together validity check for oop references (first),\n+\/\/ then optionally verifies the remembered set for that reference.\n+class G1VerifyLiveAndRemSetClosure : public BasicOopIterateClosure {\n+  using CardValue = CardTable::CardValue;\n+\n+  G1CollectedHeap* _g1h;\n+  VerifyOption _vo;\n+  bool _verify_remsets;\n+\n+  oop _containing_obj;\n+\n+  size_t _num_failures;\n+\n@@ -465,4 +498,1 @@\n-  template <class T>\n-  void do_oop_work(T* p) {\n-    assert(_containing_obj != nullptr, \"Precondition\");\n-    assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo), \"Precondition\");\n+  bool has_failures() const { return _num_failures != 0; }\n@@ -470,4 +500,11 @@\n-    T heap_oop = RawAccess<>::oop_load(p);\n-    if (CompressedOops::is_null(heap_oop)) {\n-      return;\n-    }\n+  void print_object(outputStream* out, oop obj) {\n+#ifdef PRODUCT\n+    obj->print_name_on(out);\n+#else \/\/ PRODUCT\n+    obj->print_on(out);\n+#endif \/\/ PRODUCT\n+  }\n+\n+  template<class T>\n+  bool verify_liveness(T* p, oop obj) {\n+    bool is_in_heap = _g1h->is_in(obj);\n@@ -475,1 +512,4 @@\n-    oop obj = CompressedOops::decode_raw_not_null(heap_oop);\n+    if (!is_in_heap || _g1h->is_obj_dead_cond(obj, _vo)) {\n+      ResourceMark rm;\n+      Log(gc, verify) log;\n+      LogStream ls(log.error());\n@@ -477,0 +517,28 @@\n+      MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n+\n+      if (!has_failures()) {\n+        log.error(\"----------\");\n+      }\n+\n+      HeapRegion* from = _g1h->heap_region_containing(p);\n+      log.error(\"Field \" PTR_FORMAT \" of live obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n+                p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n+      print_object(&ls, _containing_obj);\n+\n+      if (!is_in_heap) {\n+        log.error(\"points to address \" PTR_FORMAT \" outside of heap\", p2i(obj));\n+      } else {\n+        HeapRegion* to = _g1h->heap_region_containing(obj);\n+        log.error(\"points to dead obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n+                  p2i(obj), HR_FORMAT_PARAMS(to), to->rem_set()->get_state_str());\n+        print_object(&ls, obj);\n+      }\n+      log.error(\"----------\");\n+      _num_failures++;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  template <class T>\n+  void verify_remset(T* p, oop obj) {\n@@ -478,12 +546,8 @@\n-    HeapRegion* to = _g1h->heap_region_containing_or_null(obj);\n-    if (to != nullptr &&\n-        from != to &&\n-        !to->is_pinned() &&\n-        to->rem_set()->is_complete()) {\n-\n-      jbyte cv_obj = *_ct->byte_for_const(_containing_obj);\n-      jbyte cv_field = *_ct->byte_for_const(p);\n-      const jbyte dirty = G1CardTable::dirty_card_val();\n-\n-      bool is_bad = !(from->is_young() ||\n-                      to->rem_set()->contains_reference(p) ||\n+    HeapRegion* to = _g1h->heap_region_containing(obj);\n+    if (from != to && !from->is_young() && to->rem_set()->is_complete()) {\n+\n+      CardValue cv_obj = *_ct->byte_for_const(_containing_obj);\n+      CardValue cv_field = *_ct->byte_for_const(p);\n+      const CardValue dirty = G1CardTable::dirty_card_val();\n+\n+      bool is_bad = !(to->rem_set()->contains_reference(p) ||\n@@ -510,3 +574,1 @@\n-        if (oopDesc::is_oop(obj)) {\n-          obj->print_on(&ls);\n-        }\n+        print_object(&ls, obj);\n@@ -520,2 +582,4 @@\n-public:\n-  VerifyRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo), _ct(g1h->card_table()) {}\n+  template <class T>\n+  void do_oop_work(T* p) {\n+    assert(_containing_obj != nullptr, \"must be\");\n+    assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo), \"Precondition\");\n@@ -523,3 +587,11 @@\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p) { do_oop_work(p); }\n-};\n+    T heap_oop = RawAccess<>::oop_load(p);\n+    if (CompressedOops::is_null(heap_oop)) {\n+      return;\n+    }\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+\n+    bool is_live = verify_liveness(p, obj);\n+    if (is_live && _verify_remsets) {\n+      verify_remset(p, obj);\n+    }\n+  }\n@@ -527,4 +599,0 @@\n-\/\/ Closure that applies the given two closures in sequence.\n-class G1Mux2Closure : public BasicOopIterateClosure {\n-  OopClosure* _c1;\n-  OopClosure* _c2;\n@@ -532,5 +600,10 @@\n-  G1Mux2Closure(OopClosure *c1, OopClosure *c2) { _c1 = c1; _c2 = c2; }\n-  template <class T> inline void do_oop_work(T* p) {\n-    \/\/ Apply first closure; then apply the second.\n-    _c1->do_oop(p);\n-    _c2->do_oop(p);\n+  G1VerifyLiveAndRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo, bool verify_remsets) :\n+    _g1h(G1CollectedHeap::heap()),\n+    _vo(vo),\n+    _verify_remsets(verify_remsets),\n+    _containing_obj(nullptr),\n+    _num_failures(0),\n+    _ct(_g1h->card_table()) { }\n+\n+  void set_containing_obj(oop const obj) {\n+    _containing_obj = obj;\n@@ -538,1 +611,3 @@\n-  virtual inline void do_oop(oop* p) { do_oop_work(p); }\n+\n+  size_t num_failures() const { return _num_failures; }\n+\n@@ -540,0 +615,1 @@\n+  virtual inline void do_oop(oop* p) { do_oop_work(p); }\n@@ -542,2 +618,1 @@\n-void HeapRegion::verify(VerifyOption vo,\n-                        bool* failures) const {\n+bool HeapRegion::verify_liveness_and_remset(VerifyOption vo) const {\n@@ -545,10 +620,8 @@\n-  *failures = false;\n-  HeapWord* p = bottom();\n-  HeapWord* prev_p = NULL;\n-  G1VerifyLiveClosure vl_cl(g1h, vo);\n-  VerifyRemSetClosure vr_cl(g1h, vo);\n-  bool is_region_humongous = is_humongous();\n-  \/\/ We cast p to an oop, so region-bottom must be an obj-start.\n-  assert(!is_region_humongous || is_starts_humongous(), \"invariant\");\n-  size_t object_num = 0;\n-  while (p < top()) {\n+\n+  bool verify_rem_sets = !g1h->collector_state()->in_full_gc() || G1VerifyRSetsDuringFullGC;\n+  G1VerifyLiveAndRemSetClosure cl(g1h, vo, verify_rem_sets);\n+\n+  size_t other_failures = 0;\n+\n+  HeapWord* p;\n+  for (p = bottom(); p < top(); p += block_size(p)) {\n@@ -556,47 +629,14 @@\n-    size_t obj_size = block_size(p);\n-    object_num += 1;\n-\n-    if (!g1h->is_obj_dead_cond(obj, this, vo)) {\n-      if (oopDesc::is_oop(obj)) {\n-        Klass* klass = obj->klass();\n-        bool is_metaspace_object = Metaspace::contains(klass);\n-        if (!is_metaspace_object) {\n-          log_error(gc, verify)(\"klass \" PTR_FORMAT \" of object \" PTR_FORMAT \" \"\n-                                \"not metadata\", p2i(klass), p2i(obj));\n-          *failures = true;\n-          return;\n-        } else if (!klass->is_klass()) {\n-          log_error(gc, verify)(\"klass \" PTR_FORMAT \" of object \" PTR_FORMAT \" \"\n-                                \"not a klass\", p2i(klass), p2i(obj));\n-          *failures = true;\n-          return;\n-        } else {\n-          vl_cl.set_containing_obj(obj);\n-          if (!g1h->collector_state()->in_full_gc() || G1VerifyRSetsDuringFullGC) {\n-            \/\/ verify liveness and rem_set\n-            vr_cl.set_containing_obj(obj);\n-            G1Mux2Closure mux(&vl_cl, &vr_cl);\n-            obj->oop_iterate(&mux);\n-\n-            if (vr_cl.has_failures()) {\n-              *failures = true;\n-            }\n-            if (vr_cl.num_failures() >= G1MaxVerifyFailures) {\n-              return;\n-            }\n-          } else {\n-            \/\/ verify only liveness\n-            obj->oop_iterate(&vl_cl);\n-          }\n-          if (vl_cl.has_failures()) {\n-            *failures = true;\n-          }\n-          if (vl_cl.num_failures() >= G1MaxVerifyFailures) {\n-            return;\n-          }\n-        }\n-      } else {\n-        log_error(gc, verify)(PTR_FORMAT \" not an oop\", p2i(obj));\n-        *failures = true;\n-        return;\n-      }\n+\n+    if (g1h->is_obj_dead_cond(obj, this, vo)) {\n+      continue;\n+    }\n+\n+    if (is_oop_safe(obj)) {\n+      cl.set_containing_obj(obj);\n+      obj->oop_iterate(&cl);\n+    } else {\n+      other_failures++;\n+    }\n+\n+    if ((cl.num_failures() + other_failures) >= G1MaxVerifyFailures) {\n+      return true;\n@@ -604,2 +644,16 @@\n-    prev_p = p;\n-    p += obj_size;\n+  }\n+\n+  if (!is_humongous() && p != top()) {\n+    log_error(gc, verify)(\"end of last object \" PTR_FORMAT \" does not match top \" PTR_FORMAT,\n+                          p2i(p), p2i(top()));\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool HeapRegion::verify(VerifyOption vo) const {\n+  \/\/ We cast p to an oop, so region-bottom must be an obj-start.\n+  assert(!is_humongous() || is_starts_humongous(), \"invariant\");\n+\n+  if (verify_liveness_and_remset(vo)) {\n+    return true;\n@@ -613,1 +667,1 @@\n-  if (is_region_humongous) {\n+  if (is_humongous()) {\n@@ -617,2 +671,1 @@\n-      *failures = true;\n-      return;\n+      return true;\n@@ -622,8 +675,1 @@\n-  if (!is_region_humongous && p != top()) {\n-    log_error(gc, verify)(\"end of last object \" PTR_FORMAT \" \"\n-                          \"does not match top \" PTR_FORMAT, p2i(p), p2i(top()));\n-    *failures = true;\n-    return;\n-  }\n-\n-  verify_code_roots(vo, failures);\n+  return verify_code_roots(vo);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":170,"deletions":124,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -582,1 +582,3 @@\n-  void verify_code_roots(VerifyOption vo, bool* failures) const;\n+  \/\/ Returns whether there has been a failure.\n+  bool verify_code_roots(VerifyOption vo) const;\n+  bool verify_liveness_and_remset(VerifyOption vo) const;\n@@ -587,1 +589,1 @@\n-  void verify(VerifyOption vo, bool* failures) const;\n+  bool verify(VerifyOption vo) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  if (is_in(object->klass_or_null())) {\n+  if (is_in(object->klass_raw())) {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,10 @@\n+void oopDesc::print_name_on(outputStream* st) const {\n+  if (*((juint*)this) == badHeapWordVal) {\n+    st->print_cr(\"BAD WORD\");\n+  } else if (*((juint*)this) == badMetaWordVal) {\n+    st->print_cr(\"BAD META WORD\");\n+  } else {\n+    st->print_cr(\"%s\", klass()->external_name());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -228,2 +228,2 @@\n-  void print_on(outputStream* st) const;        \/\/ First level print\n-  void print_value_on(outputStream* st) const;  \/\/ Second level print.\n+  void print_on(outputStream* st) const;         \/\/ First level print\n+  void print_value_on(outputStream* st) const;   \/\/ Second level print.\n@@ -231,0 +231,1 @@\n+  void print_name_on(outputStream* st) const;    \/\/ External name printing.\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}