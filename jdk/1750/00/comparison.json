{"files":[{"patch":"@@ -1683,0 +1683,4 @@\n+  log_info(cds)(\"Mapped %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n+                is_static() ? \"static \" : \"dynamic\",\n+                MetaspaceShared::bm, p2i(si->mapped_base()), p2i(si->mapped_end()),\n+                shared_region_name[MetaspaceShared::bm]);\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1367,1 +1367,1 @@\n-  ReservedSpace archive_space_rs, class_space_rs;\n+  ReservedSpace total_space_rs, archive_space_rs, class_space_rs;\n@@ -1369,2 +1369,5 @@\n-  char* mapped_base_address = reserve_address_space_for_archives(static_mapinfo, dynamic_mapinfo,\n-                                                                 use_requested_addr, archive_space_rs,\n+  char* mapped_base_address = reserve_address_space_for_archives(static_mapinfo,\n+                                                                 dynamic_mapinfo,\n+                                                                 use_requested_addr,\n+                                                                 total_space_rs,\n+                                                                 archive_space_rs,\n@@ -1420,0 +1423,1 @@\n+        assert(!total_space_rs.is_reserved(), \"Should not be reserved for Windows\");\n@@ -1475,0 +1479,1 @@\n+          assert(ccs_end > cds_base, \"Sanity check\");\n@@ -1487,1 +1492,1 @@\n-    release_reserved_spaces(archive_space_rs, class_space_rs);\n+    release_reserved_spaces(total_space_rs, archive_space_rs, class_space_rs);\n@@ -1536,0 +1541,4 @@\n+\/\/    - total_space_rs will be reserved as whole for archive_space_rs and\n+\/\/      class_space_rs if UseCompressedClassPointers is true.\n+\/\/      On Windows, try reserve archive_space_rs and class_space_rs\n+\/\/      separately first if use_archive_base_addr is true.\n@@ -1550,0 +1559,1 @@\n+                                                          ReservedSpace& total_space_rs,\n@@ -1615,5 +1625,18 @@\n-  ReservedSpace total_rs;\n-  if (base_address != NULL) {\n-    \/\/ Reserve at the given archive base address, or not at all.\n-    total_rs = ReservedSpace(total_range_size, archive_space_alignment,\n-                             false \/* bool large *\/, (char*) base_address);\n+  assert(total_range_size > ccs_begin_offset, \"must be\");\n+  if (use_windows_memory_mapping() && use_archive_base_addr) {\n+    if (base_address != nullptr) {\n+      \/\/ On Windows, we cannot safely split a reserved memory space into two (see JDK-8255917).\n+      \/\/ Hence, we optimistically reserve archive space and class space side-by-side. We only\n+      \/\/ do this for use_archive_base_addr=true since for use_archive_base_addr=false case\n+      \/\/ caller will not split the combined space for mapping, instead read the archive data\n+      \/\/ via sequential file IO.\n+      address ccs_base = base_address + archive_space_size + gap_size;\n+      archive_space_rs = ReservedSpace(archive_space_size, archive_space_alignment,\n+                                       false \/* large *\/, (char*)base_address);\n+      class_space_rs   = ReservedSpace(class_space_size, class_space_alignment,\n+                                       false \/* large *\/, (char*)ccs_base);\n+    }\n+    if (!archive_space_rs.is_reserved() || !class_space_rs.is_reserved()) {\n+      release_reserved_spaces(total_space_rs, archive_space_rs, class_space_rs);\n+      return NULL;\n+    }\n@@ -1621,14 +1644,7 @@\n-    \/\/ Reserve at any address, but leave it up to the platform to choose a good one.\n-    total_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size);\n-  }\n-\n-  if (!total_rs.is_reserved()) {\n-    return NULL;\n-  }\n-\n-  \/\/ Paranoid checks:\n-  assert(base_address == NULL || (address)total_rs.base() == base_address,\n-         \"Sanity (\" PTR_FORMAT \" vs \" PTR_FORMAT \")\", p2i(base_address), p2i(total_rs.base()));\n-  assert(is_aligned(total_rs.base(), archive_space_alignment), \"Sanity\");\n-  assert(total_rs.size() == total_range_size, \"Sanity\");\n-  assert(CompressedKlassPointers::is_valid_base((address)total_rs.base()), \"Sanity\");\n+    if (use_archive_base_addr && base_address != nullptr) {\n+      total_space_rs = ReservedSpace(total_range_size, archive_space_alignment,\n+                                     false \/* bool large *\/, (char*) base_address);\n+    } else {\n+      \/\/ Reserve at any address, but leave it up to the platform to choose a good one.\n+      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size);\n+    }\n@@ -1636,6 +1652,3 @@\n-  \/\/ Now split up the space into ccs and cds archive. For simplicity, just leave\n-  \/\/  the gap reserved at the end of the archive space.\n-  archive_space_rs = total_rs.first_part(ccs_begin_offset,\n-                                         (size_t)os::vm_allocation_granularity(),\n-                                         \/*split=*\/true);\n-  class_space_rs = total_rs.last_part(ccs_begin_offset);\n+    if (!total_space_rs.is_reserved()) {\n+      return NULL;\n+    }\n@@ -1643,0 +1656,16 @@\n+    \/\/ Paranoid checks:\n+    assert(base_address == NULL || (address)total_space_rs.base() == base_address,\n+           \"Sanity (\" PTR_FORMAT \" vs \" PTR_FORMAT \")\", p2i(base_address), p2i(total_space_rs.base()));\n+    assert(is_aligned(total_space_rs.base(), archive_space_alignment), \"Sanity\");\n+    assert(total_space_rs.size() == total_range_size, \"Sanity\");\n+    assert(CompressedKlassPointers::is_valid_base((address)total_space_rs.base()), \"Sanity\");\n+\n+    \/\/ Now split up the space into ccs and cds archive. For simplicity, just leave\n+    \/\/  the gap reserved at the end of the archive space. Do not do real splitting.\n+    archive_space_rs = total_space_rs.first_part(ccs_begin_offset,\n+                                                 (size_t)os::vm_allocation_granularity(),\n+                                                 \/*split=*\/false);\n+    class_space_rs = total_space_rs.last_part(ccs_begin_offset);\n+    MemTracker::record_virtual_memory_split_reserved(total_space_rs.base(), total_space_rs.size(),\n+                                                     ccs_begin_offset);\n+  }\n@@ -1661,1 +1690,2 @@\n-void MetaspaceShared::release_reserved_spaces(ReservedSpace& archive_space_rs,\n+void MetaspaceShared::release_reserved_spaces(ReservedSpace& total_space_rs,\n+                                              ReservedSpace& archive_space_rs,\n@@ -1663,7 +1693,12 @@\n-  if (archive_space_rs.is_reserved()) {\n-    log_debug(cds)(\"Released shared space (archive) \" INTPTR_FORMAT, p2i(archive_space_rs.base()));\n-    archive_space_rs.release();\n-  }\n-  if (class_space_rs.is_reserved()) {\n-    log_debug(cds)(\"Released shared space (classes) \" INTPTR_FORMAT, p2i(class_space_rs.base()));\n-    class_space_rs.release();\n+  if (total_space_rs.is_reserved()) {\n+    log_debug(cds)(\"Released shared space (archive + class) \" INTPTR_FORMAT, p2i(total_space_rs.base()));\n+    total_space_rs.release();\n+  } else {\n+    if (archive_space_rs.is_reserved()) {\n+      log_debug(cds)(\"Released shared space (archive) \" INTPTR_FORMAT, p2i(archive_space_rs.base()));\n+      archive_space_rs.release();\n+    }\n+    if (class_space_rs.is_reserved()) {\n+      log_debug(cds)(\"Released shared space (classes) \" INTPTR_FORMAT, p2i(class_space_rs.base()));\n+      class_space_rs.release();\n+    }\n@@ -1713,0 +1748,1 @@\n+    mapinfo->unmap_region(MetaspaceShared::bm);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":73,"deletions":37,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -291,0 +291,1 @@\n+                                                  ReservedSpace& total_space_rs,\n@@ -293,2 +294,3 @@\n-  static void release_reserved_spaces(ReservedSpace& archive_space_rs,\n-                                      ReservedSpace& class_space_rs);\n+ static void release_reserved_spaces(ReservedSpace& total_space_rs,\n+                                     ReservedSpace& archive_space_rs,\n+                                     ReservedSpace& class_space_rs);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1726,0 +1726,3 @@\n+  if (!res) {\n+    log_info(os)(\"os::release_memory(\" PTR_FORMAT \", \" SIZE_FORMAT \") failed\", p2i(addr), bytes);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-                rgn.flag_name(),  p2i(rgn.base()), rgn.size(), (result ? \"Succeeded\" : \"Failed\"));\n+                reserved_rgn->flag_name(),  p2i(rgn.base()), rgn.size(), (result ? \"Succeeded\" : \"Failed\"));\n@@ -509,6 +509,20 @@\n-  if (reserved_rgn->flag() == mtClassShared &&\n-      reserved_rgn->contain_region(addr, size)) {\n-    \/\/ This is an unmapped CDS region, which is part of the reserved shared\n-    \/\/ memory region.\n-    \/\/ See special handling in VirtualMemoryTracker::add_reserved_region also.\n-    return true;\n+  if (reserved_rgn->flag() == mtClassShared) {\n+    if (reserved_rgn->contain_region(addr, size)) {\n+      \/\/ This is an unmapped CDS region, which is part of the reserved shared\n+      \/\/ memory region.\n+      \/\/ See special handling in VirtualMemoryTracker::add_reserved_region also.\n+      return true;\n+    }\n+\n+    if (size > reserved_rgn->size()) {\n+      \/\/ This is from release the whole region spanning from archive space to class space,\n+      \/\/ so we release them altogether.\n+      ReservedMemoryRegion class_rgn(addr + reserved_rgn->size(),\n+                                     (size - reserved_rgn->size()));\n+      ReservedMemoryRegion* cls_rgn = _reserved_regions->find(class_rgn);\n+      assert(cls_rgn != NULL, \"Class space region  not recorded?\");\n+      assert(cls_rgn->flag() == mtClass, \"Must be class type\");\n+      remove_released_region(reserved_rgn);\n+      remove_released_region(cls_rgn);\n+      return true;\n+    }\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -341,0 +341,1 @@\n+ -runtime\/cds\/appcds\/MismatchedPathTriggerMemoryRelease.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+    \/\/ failed pattern\n+    private static String failedPattern = \"os::release_memory\\\\(0x[0-9a-fA-F]*,\\\\s[0-9]*\\\\)\\\\sfailed\";\n+\n@@ -71,1 +74,2 @@\n-                 .shouldContain(\"Try to map archive(s) at an alternative address\");\n+                 .shouldContain(\"Try to map archive(s) at an alternative address\")\n+                 .shouldNotMatch(failedPattern);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/SharedBaseAddress.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test MismatchedPathTriggerMemoryRelease\n+ * @summary Mismatched path at runtime will cause reserved memory released\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/Hello.java\n+ * @run main\/timeout=240 MismatchedPathTriggerMemoryRelease\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class MismatchedPathTriggerMemoryRelease {\n+    private static String ERR_MSGS[] = {\n+        \"UseSharedSpaces: shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)\",\n+        \"UseSharedSpaces: Unable to map shared spaces\"};\n+    private static String RELEASE_SPACE_MATCH =\n+        \"Released shared space\\\\s(\\\\(archive\\\\s*\\\\+\\\\s*class\\\\) | ?)0(x|X)[0-9a-fA-F]+$\";\n+    private static String OS_RELEASE_MATCH =\n+        \"os::release_memory\\\\(0(x|X)[0-9a-fA-F]+,\\\\s[0-9]+\\\\)\\\\sfailed\";\n+    public static void main(String[] args) throws Exception {\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+\n+        OutputAnalyzer dumpOutput = TestCommon.dump(\n+            appJar, new String[] {\"Hello\"}, \"-XX:SharedBaseAddress=0\");\n+        TestCommon.checkDump(dumpOutput, \"Loading classes to share\");\n+\n+        \/\/ Normal exit\n+        OutputAnalyzer execOutput = TestCommon.exec(appJar, \"Hello\");\n+        TestCommon.checkExec(execOutput, \"Hello World\");\n+\n+        \/\/ mismatched jar\n+        execOutput = TestCommon.exec(\"non-exist.jar\",\n+                                     \"-Xshare:auto\",\n+                                     \"-Xlog:os,cds=debug\",\n+                                     \"-XX:NativeMemoryTracking=detail\",\n+                                     \"-XX:SharedBaseAddress=0\",\n+                                     \"Hello\");\n+        execOutput.shouldHaveExitValue(1);\n+        for (String err : ERR_MSGS) {\n+            execOutput.shouldContain(err);\n+        }\n+        execOutput.shouldMatch(RELEASE_SPACE_MATCH);\n+        execOutput.shouldNotMatch(OS_RELEASE_MATCH); \/\/ os::release only log release failed message\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/MismatchedPathTriggerMemoryRelease.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}