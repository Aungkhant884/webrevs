{"files":[{"patch":"@@ -126,4 +126,52 @@\n-import static javax.lang.model.element.ElementKind.*;\n-import static javax.lang.model.type.TypeKind.*;\n-\n-import static com.sun.source.doctree.DocTree.Kind.*;\n+import static com.sun.source.doctree.DocTree.Kind.ATTRIBUTE;\n+import static com.sun.source.doctree.DocTree.Kind.AUTHOR;\n+import static com.sun.source.doctree.DocTree.Kind.COMMENT;\n+import static com.sun.source.doctree.DocTree.Kind.DEPRECATED;\n+import static com.sun.source.doctree.DocTree.Kind.DOC_COMMENT;\n+import static com.sun.source.doctree.DocTree.Kind.DOC_ROOT;\n+import static com.sun.source.doctree.DocTree.Kind.END_ELEMENT;\n+import static com.sun.source.doctree.DocTree.Kind.ENTITY;\n+import static com.sun.source.doctree.DocTree.Kind.ERRONEOUS;\n+import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;\n+import static com.sun.source.doctree.DocTree.Kind.HIDDEN;\n+import static com.sun.source.doctree.DocTree.Kind.IDENTIFIER;\n+import static com.sun.source.doctree.DocTree.Kind.INHERIT_DOC;\n+import static com.sun.source.doctree.DocTree.Kind.LINK;\n+import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n+import static com.sun.source.doctree.DocTree.Kind.LITERAL;\n+import static com.sun.source.doctree.DocTree.Kind.PARAM;\n+import static com.sun.source.doctree.DocTree.Kind.PROVIDES;\n+import static com.sun.source.doctree.DocTree.Kind.REFERENCE;\n+import static com.sun.source.doctree.DocTree.Kind.RETURN;\n+import static com.sun.source.doctree.DocTree.Kind.SEE;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n+import static com.sun.source.doctree.DocTree.Kind.SINCE;\n+import static com.sun.source.doctree.DocTree.Kind.START_ELEMENT;\n+import static com.sun.source.doctree.DocTree.Kind.TEXT;\n+import static com.sun.source.doctree.DocTree.Kind.THROWS;\n+import static com.sun.source.doctree.DocTree.Kind.UNKNOWN_BLOCK_TAG;\n+import static com.sun.source.doctree.DocTree.Kind.UNKNOWN_INLINE_TAG;\n+import static com.sun.source.doctree.DocTree.Kind.USES;\n+import static com.sun.source.doctree.DocTree.Kind.VALUE;\n+import static com.sun.source.doctree.DocTree.Kind.VERSION;\n+import static javax.lang.model.element.ElementKind.ANNOTATION_TYPE;\n+import static javax.lang.model.element.ElementKind.CLASS;\n+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;\n+import static javax.lang.model.element.ElementKind.ENUM;\n+import static javax.lang.model.element.ElementKind.ENUM_CONSTANT;\n+import static javax.lang.model.element.ElementKind.FIELD;\n+import static javax.lang.model.element.ElementKind.INTERFACE;\n+import static javax.lang.model.element.ElementKind.METHOD;\n+import static javax.lang.model.element.ElementKind.RECORD;\n+import static javax.lang.model.element.ElementKind.STATIC_INIT;\n+import static javax.lang.model.element.ElementKind.TYPE_PARAMETER;\n+import static javax.lang.model.type.TypeKind.ARRAY;\n+import static javax.lang.model.type.TypeKind.DECLARED;\n+import static javax.lang.model.type.TypeKind.ERROR;\n+import static javax.lang.model.type.TypeKind.INTERSECTION;\n+import static javax.lang.model.type.TypeKind.NONE;\n+import static javax.lang.model.type.TypeKind.TYPEVAR;\n+import static javax.lang.model.type.TypeKind.VOID;\n+import static javax.lang.model.type.TypeKind.WILDCARD;\n@@ -908,1 +956,2 @@\n-        addSuperInterfaces(te.asType(), results);\n+        addSuperInterfaces(te.asType(), results, new HashSet<>());\n+        assert noSameTypes(results);\n@@ -912,1 +961,35 @@\n-    private void addSuperInterfaces(TypeMirror type, Set<TypeMirror> results) {\n+    private boolean noSameTypes(Set<TypeMirror> results) {\n+        for (TypeMirror t1 : results) {\n+            for (TypeMirror t2 : results) {\n+                if (t1 == t2) {\n+                    continue;\n+                }\n+                if (typeUtils.isSameType(t1, t2)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/*\n+     * Instances of TypeMirror should be compared using\n+     * Types.isSameType. However, there's no hash function\n+     * consistent with that method. This makes it problematic to\n+     * store TypeMirror in a collection that relies on hashing.\n+     *\n+     * To work around that, along with accumulating the resulting set of type\n+     * mirrors, we also maintain a set of elements that correspond to those\n+     * type mirrors. Element provides strong equals and hashCode. We only add\n+     * a type mirror into the result set if we don't already have an element\n+     * that corresponds to this type mirror in the set of seen elements.\n+     *\n+     * Although this might seem wrong, as an instance of Element corresponds\n+     * to multiple instances of TypeMirror (one-to-many), in an\n+     * inheritance hierarchy the correspondence is effectively one-to-one.\n+     * This is because it is NOT possible for a type to be a subtype\n+     * of different generic invocations of the same supertype; e.g.,\n+     *\n+     *     interface X extends G<A>, G<B>\n+     *\/\n+    private void addSuperInterfaces(TypeMirror type, Set<TypeMirror> results, Set<Element> visited) {\n@@ -919,0 +1002,3 @@\n+                if (!visited.add(e)) {\n+                    continue; \/\/ seen it before\n+                }\n@@ -922,1 +1008,1 @@\n-                addSuperInterfaces(t, results);\n+                addSuperInterfaces(t, results, visited);\n@@ -932,1 +1018,1 @@\n-            addSuperInterfaces(superType, results);\n+            addSuperInterfaces(superType, results, visited);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":94,"deletions":8,"binary":false,"changes":102,"status":"modified"}]}