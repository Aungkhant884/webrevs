{"files":[{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -32,14 +33,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import static java.io.ObjectStreamConstants.SC_SERIALIZABLE;\n-import static java.io.ObjectStreamConstants.STREAM_MAGIC;\n-import static java.io.ObjectStreamConstants.STREAM_VERSION;\n-import static java.io.ObjectStreamConstants.TC_CLASSDESC;\n-import static java.io.ObjectStreamConstants.TC_ENDBLOCKDATA;\n-import static java.io.ObjectStreamConstants.TC_NULL;\n-import static java.io.ObjectStreamConstants.TC_OBJECT;\n-import static java.io.ObjectStreamConstants.TC_STRING;\n-import static java.lang.System.out;\n-import static org.testng.Assert.assertEquals;\n-\n@@ -48,1 +35,0 @@\n-import java.io.DataOutputStream;\n@@ -55,3 +41,5 @@\n-import java.io.UncheckedIOException;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n+import jdk.test.lib.serial.SerialObjectBuilder;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+import static org.testng.Assert.assertEquals;\n@@ -117,1 +105,1 @@\n-        byte[] bytes = SerialByteStreamBuilder\n+        byte[] bytes = SerialObjectBuilder\n@@ -126,1 +114,1 @@\n-        bytes = SerialByteStreamBuilder\n+        bytes = SerialObjectBuilder\n@@ -146,1 +134,1 @@\n-        byte[] bytes = SerialByteStreamBuilder\n+        byte[] bytes = SerialObjectBuilder\n@@ -176,1 +164,1 @@\n-            byte[] builderBytes = SerialByteStreamBuilder\n+            byte[] builderBytes = SerialObjectBuilder\n@@ -194,1 +182,1 @@\n-            byte[] builderBytes = SerialByteStreamBuilder\n+            byte[] builderBytes = SerialObjectBuilder\n@@ -203,1 +191,1 @@\n-            builderBytes = SerialByteStreamBuilder\n+            builderBytes = SerialObjectBuilder\n@@ -211,1 +199,1 @@\n-            builderBytes = SerialByteStreamBuilder\n+            builderBytes = SerialObjectBuilder\n@@ -226,1 +214,1 @@\n-            builderBytes = SerialByteStreamBuilder\n+            builderBytes = SerialObjectBuilder\n@@ -234,1 +222,1 @@\n-            builderBytes = SerialByteStreamBuilder\n+            builderBytes = SerialObjectBuilder\n@@ -252,1 +240,1 @@\n-        byte[] builderBytes = SerialByteStreamBuilder\n+        byte[] builderBytes = SerialObjectBuilder\n@@ -261,1 +249,1 @@\n-        builderBytes = SerialByteStreamBuilder\n+        builderBytes = SerialObjectBuilder\n@@ -283,1 +271,1 @@\n-            byte[] builderBytes = SerialByteStreamBuilder\n+            byte[] builderBytes = SerialObjectBuilder\n@@ -299,1 +287,1 @@\n-            byte[] builderBytes = SerialByteStreamBuilder\n+            byte[] builderBytes = SerialObjectBuilder\n@@ -320,1 +308,1 @@\n-            byte[] builderBytes = SerialByteStreamBuilder\n+            byte[] builderBytes = SerialObjectBuilder\n@@ -336,1 +324,1 @@\n-            byte[] builderBytes = SerialByteStreamBuilder\n+            byte[] builderBytes = SerialObjectBuilder\n@@ -356,1 +344,1 @@\n-        byte[] builderBytes = SerialByteStreamBuilder\n+        byte[] builderBytes = SerialObjectBuilder\n@@ -380,1 +368,1 @@\n-        byte[] builderBytes = SerialByteStreamBuilder\n+        byte[] builderBytes = SerialObjectBuilder\n@@ -409,154 +397,0 @@\n-\n-    static class SerialByteStreamBuilder {\n-\n-        private final ObjectOutputStream objectOutputStream;\n-        private final ByteArrayOutputStream byteArrayOutputStream;\n-\n-        record NameAndType<T>(String name, Class<T>type) {}\n-\n-        private String className;\n-        private final LinkedHashMap<NameAndType<?>, Object> primFields = new LinkedHashMap<>();\n-        private final LinkedHashMap<NameAndType<?>, Object> objectFields = new LinkedHashMap<>();\n-\n-        private SerialByteStreamBuilder() {\n-            try {\n-                byteArrayOutputStream = new ByteArrayOutputStream();\n-                objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        }\n-\n-        public static SerialByteStreamBuilder newBuilder(String className) {\n-            return (new SerialByteStreamBuilder()).className(className);\n-        }\n-\n-        private SerialByteStreamBuilder className(String className) {\n-            this.className = className;\n-            return this;\n-        }\n-\n-        public <T> SerialByteStreamBuilder addPrimitiveField(String name, Class<T> type, T value) {\n-            if (!type.isPrimitive())\n-                throw new IllegalArgumentException(\"Unexpected non-primitive field: \" + type);\n-            primFields.put(new NameAndType<>(name, type), value);\n-            return this;\n-        }\n-\n-        public <T> SerialByteStreamBuilder addField(String name, Class<T> type, T value) {\n-            if (type.isPrimitive())\n-                throw new IllegalArgumentException(\"Unexpected primitive field: \" + type);\n-            objectFields.put(new NameAndType<>(name, type), value);\n-            return this;\n-        }\n-\n-        private static int getPrimitiveSignature(Class<?> cl) {\n-            if (cl == Integer.TYPE) return 'I';\n-            else if (cl == Byte.TYPE) return 'B';\n-            else if (cl == Long.TYPE) return 'J';\n-            else if (cl == Float.TYPE) return 'F';\n-            else if (cl == Double.TYPE) return 'D';\n-            else if (cl == Short.TYPE) return 'S';\n-            else if (cl == Character.TYPE) return 'C';\n-            else if (cl == Boolean.TYPE) return 'Z';\n-            else throw new InternalError();\n-        }\n-\n-        private static void writeUTF(DataOutputStream out, String str) throws IOException {\n-            int utflen = str.length(); \/\/ assume ASCII\n-            assert utflen <= 0xFFFF;\n-            out.writeShort(utflen);\n-            out.writeBytes(str);\n-        }\n-\n-        private void writePrimFieldsDesc(DataOutputStream out) throws IOException {\n-            for (Map.Entry<NameAndType<?>, Object> entry : primFields.entrySet()) {\n-                assert entry.getKey().type() != void.class;\n-                out.writeByte(getPrimitiveSignature(entry.getKey().type())); \/\/ prim_typecode\n-                out.writeUTF(entry.getKey().name());                         \/\/ fieldName\n-            }\n-        }\n-\n-        private void writePrimFieldsValues(DataOutputStream out) throws IOException {\n-            for (Map.Entry<NameAndType<?>, Object> entry : primFields.entrySet()) {\n-                Class<?> cl = entry.getKey().type();\n-                Object value = entry.getValue();\n-                if (cl == Integer.TYPE) out.writeInt((int) value);\n-                else if (cl == Byte.TYPE) out.writeByte((byte) value);\n-                else if (cl == Long.TYPE) out.writeLong((long) value);\n-                else if (cl == Float.TYPE) out.writeFloat((float) value);\n-                else if (cl == Double.TYPE) out.writeDouble((double) value);\n-                else if (cl == Short.TYPE) out.writeShort((short) value);\n-                else if (cl == Character.TYPE) out.writeChar((char) value);\n-                else if (cl == Boolean.TYPE) out.writeBoolean((boolean) value);\n-                else throw new InternalError();\n-            }\n-        }\n-\n-        private void writeObjectFieldDesc(DataOutputStream out) throws IOException {\n-            for (Map.Entry<NameAndType<?>, Object> entry : objectFields.entrySet()) {\n-                Class<?> cl = entry.getKey().type();\n-                assert !cl.isPrimitive();\n-                \/\/ obj_typecode\n-                if (cl.isArray()) {\n-                    out.writeByte('[');\n-                } else {\n-                    out.writeByte('L');\n-                }\n-                writeUTF(out, entry.getKey().name());\n-                out.writeByte(TC_STRING);\n-                writeUTF(out,\n-                         (cl.isArray() ? cl.getName() : \"L\" + cl.getName() + \";\")\n-                             .replace('.', '\/'));\n-            }\n-        }\n-\n-        private void writeObject(DataOutputStream out, Object value) throws IOException {\n-            objectOutputStream.reset();\n-            byteArrayOutputStream.reset();\n-            objectOutputStream.writeUnshared(value);\n-            out.write(byteArrayOutputStream.toByteArray());\n-        }\n-\n-        private void writeObjectFieldValues(DataOutputStream out) throws IOException {\n-            for (Map.Entry<NameAndType<?>, Object> entry : objectFields.entrySet()) {\n-                Class<?> cl = entry.getKey().type();\n-                assert !cl.isPrimitive();\n-                if (cl == String.class) {\n-                    out.writeByte(TC_STRING);\n-                    writeUTF(out, (String) entry.getValue());\n-                } else {\n-                    writeObject(out, entry.getValue());\n-                }\n-            }\n-        }\n-\n-        private int numFields() {\n-            return primFields.size() + objectFields.size();\n-        }\n-\n-        public byte[] build() {\n-            try {\n-                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-                DataOutputStream dos = new DataOutputStream(baos);\n-                dos.writeShort(STREAM_MAGIC);\n-                dos.writeShort(STREAM_VERSION);\n-                dos.writeByte(TC_OBJECT);\n-                dos.writeByte(TC_CLASSDESC);\n-                dos.writeUTF(className);\n-                dos.writeLong(0L);\n-                dos.writeByte(SC_SERIALIZABLE);\n-                dos.writeShort(numFields());      \/\/ number of fields\n-                writePrimFieldsDesc(dos);\n-                writeObjectFieldDesc(dos);\n-                dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n-                dos.writeByte(TC_NULL);           \/\/ no superclasses\n-                writePrimFieldsValues(dos);\n-                writeObjectFieldValues(dos);\n-                dos.close();\n-                return baos.toByteArray();\n-            } catch (IOException unexpected) {\n-                throw new AssertionError(unexpected);\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/DifferentStreamFieldsTest.java","additions":23,"deletions":189,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.serial;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import static java.io.ObjectStreamConstants.*;\n+\n+\/**\n+ * A basic builder of a serial object.\n+ *\/\n+public class SerialObjectBuilder {\n+\n+    private final ObjectOutputStream objectOutputStream;\n+    private final ByteArrayOutputStream byteArrayOutputStream;\n+\n+    private record NameAndType<T>(String name, Class<T>type) { }\n+\n+    private String className;\n+    private long suid;\n+    private SerialObjectBuilder superClass;\n+    private final LinkedHashMap<NameAndType<?>, Object> primFields = new LinkedHashMap<>();\n+    private final LinkedHashMap<NameAndType<?>, Object> objectFields = new LinkedHashMap<>();\n+\n+    private SerialObjectBuilder() {\n+        try {\n+            byteArrayOutputStream = new ByteArrayOutputStream();\n+            objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    public static SerialObjectBuilder newBuilder(String className) {\n+        return (new SerialObjectBuilder()).className(className);\n+    }\n+\n+    private SerialObjectBuilder className(String className) {\n+        this.className = className;\n+        return this;\n+    }\n+\n+    public SerialObjectBuilder suid(long suid) {\n+        this.suid = suid;\n+        return this;\n+    }\n+\n+    public SerialObjectBuilder superClass(SerialObjectBuilder superClass) {\n+        this.superClass = superClass;\n+        return this;\n+    }\n+\n+    public <T> SerialObjectBuilder addPrimitiveField(String name, Class<T> type, T value) {\n+        if (!type.isPrimitive())\n+            throw new IllegalArgumentException(\"Unexpected non-primitive field: \" + type);\n+        primFields.put(new NameAndType<>(name, type), value);\n+        return this;\n+    }\n+\n+    public <T> SerialObjectBuilder addField(String name, Class<T> type, T value) {\n+        if (type.isPrimitive())\n+            throw new IllegalArgumentException(\"Unexpected primitive field: \" + type);\n+        objectFields.put(new NameAndType<>(name, type), value);\n+        return this;\n+    }\n+\n+    private static void writeUTF(DataOutputStream out, String str) throws IOException {\n+        assert str.codePoints().noneMatch(cp -> cp > 127); \/\/ only ASCII for now\n+        int utflen = str.length();\n+        assert utflen <= 0xFFFF;  \/\/ only small strings for now\n+        out.writeShort(utflen);\n+        out.writeBytes(str);\n+    }\n+\n+    private void writePrimFieldsDesc(DataOutputStream out) throws IOException {\n+        for (Map.Entry<NameAndType<?>, Object> entry : primFields.entrySet()) {\n+            Class<?> primClass = entry.getKey().type();\n+            assert primClass.isPrimitive();\n+            assert primClass != void.class;\n+            out.writeByte(primClass.descriptorString().getBytes()[0]);   \/\/ prim_typecode\n+            out.writeUTF(entry.getKey().name());                         \/\/ fieldName\n+        }\n+    }\n+\n+    private void writePrimFieldsValues(DataOutputStream out) throws IOException {\n+        for (Map.Entry<NameAndType<?>, Object> entry : primFields.entrySet()) {\n+            Class<?> cl = entry.getKey().type();\n+            Object value = entry.getValue();\n+            if (cl == Integer.TYPE) out.writeInt((int) value);\n+            else if (cl == Byte.TYPE) out.writeByte((byte) value);\n+            else if (cl == Long.TYPE) out.writeLong((long) value);\n+            else if (cl == Float.TYPE) out.writeFloat((float) value);\n+            else if (cl == Double.TYPE) out.writeDouble((double) value);\n+            else if (cl == Short.TYPE) out.writeShort((short) value);\n+            else if (cl == Character.TYPE) out.writeChar((char) value);\n+            else if (cl == Boolean.TYPE) out.writeBoolean((boolean) value);\n+            else throw new InternalError();\n+        }\n+    }\n+\n+    private void writeObjectFieldDesc(DataOutputStream out) throws IOException {\n+        for (Map.Entry<NameAndType<?>, Object> entry : objectFields.entrySet()) {\n+            Class<?> cl = entry.getKey().type();\n+            assert !cl.isPrimitive();\n+            \/\/ obj_typecode\n+            if (cl.isArray()) {\n+                out.writeByte('[');\n+            } else {\n+                out.writeByte('L');\n+            }\n+            writeUTF(out, entry.getKey().name());\n+            out.writeByte(TC_STRING);\n+            writeUTF(out, cl.descriptorString());\n+        }\n+    }\n+\n+    private void writeObject(DataOutputStream out, Object value) throws IOException {\n+        objectOutputStream.reset();\n+        byteArrayOutputStream.reset();\n+        objectOutputStream.writeUnshared(value);\n+        out.write(byteArrayOutputStream.toByteArray());\n+    }\n+\n+    private void writeObjectFieldValues(DataOutputStream out) throws IOException {\n+        for (Map.Entry<NameAndType<?>, Object> entry : objectFields.entrySet()) {\n+            Class<?> cl = entry.getKey().type();\n+            assert !cl.isPrimitive();\n+            if (cl == String.class) {\n+                out.writeByte(TC_STRING);\n+                writeUTF(out, (String) entry.getValue());\n+            } else {\n+                writeObject(out, entry.getValue());\n+            }\n+        }\n+    }\n+\n+    private int numFields() {\n+        return primFields.size() + objectFields.size();\n+    }\n+\n+    private static void writeClassDesc(DataOutputStream dos,\n+                                       SerialObjectBuilder sb)\n+        throws IOException\n+    {\n+        dos.writeByte(TC_CLASSDESC);\n+        dos.writeUTF(sb.className);\n+        dos.writeLong(sb.suid);\n+        dos.writeByte(SC_SERIALIZABLE);\n+        dos.writeShort(sb.numFields());      \/\/ number of fields\n+        sb.writePrimFieldsDesc(dos);\n+        sb.writeObjectFieldDesc(dos);\n+        dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n+        if (sb.superClass == null) {\n+            dos.writeByte(TC_NULL);       \/\/ no superclasses\n+        } else {\n+            writeClassDesc(dos, sb.superClass);\n+        }\n+    }\n+\n+    public byte[] build() {\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            DataOutputStream dos = new DataOutputStream(baos);\n+            dos.writeShort(STREAM_MAGIC);\n+            dos.writeShort(STREAM_VERSION);\n+            dos.writeByte(TC_OBJECT);\n+            writeClassDesc(dos, this);\n+            if (superClass != null) {\n+                superClass.writePrimFieldsValues(dos);\n+                superClass.writeObjectFieldValues(dos);\n+            }\n+            writePrimFieldsValues(dos);\n+            writeObjectFieldValues(dos);\n+            dos.close();\n+            return baos.toByteArray();\n+        } catch (IOException unexpected) {\n+            throw new AssertionError(unexpected);\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/serial\/SerialObjectBuilder.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"}]}