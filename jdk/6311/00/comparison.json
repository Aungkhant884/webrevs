{"files":[{"patch":"@@ -85,0 +85,2 @@\n+TOOL_GENERATEZIP = $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n+    build.tools.generatezip.GenerateZip\n","filename":"make\/ToolsJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+include ..\/ToolsJdk.gmk\n+\n@@ -137,0 +139,2 @@\n+  # For reproducible builds set the zip access & modify times to SOURCE_DATE_EPOCH\n+  # by using a ziptmp folder to generate final zip from using GenerateZip.\n@@ -159,0 +163,2 @@\n+\t$(RM) -r $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\n+\t$(MKDIR) -p $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/files\n@@ -161,1 +167,2 @@\n-\t    (cd $$s && $(ZIPEXE) -qru $$($1_ZIP_OPTIONS) $$@ . \\\n+\t    (cd $$s && $(ZIPEXE) -qru $$($1_ZIP_OPTIONS) \\\n+\t        $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/tmp.zip . \\\n@@ -166,1 +173,8 @@\n-\t) true \\\n+\t) true\n+\t$$(call ExecuteWithLog, \\\n+\t    $$(SUPPORT_OUTPUTDIR)\/generatezip\/$$(patsubst $$(OUTPUTDIR)\/%,%, $$@), \\\n+\t    (cd $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/files && \\\n+\t     $(RM) $$@ && \\\n+\t     $(UNZIP) -q $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/tmp.zip && \\\n+\t     $(TOOL_GENERATEZIP) -f $$@ -t $(SOURCE_DATE_EPOCH) . \\\n+\t    ))$$(NEWLINE) \\\n","filename":"make\/common\/ZipArchive.gmk","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package build.tools.generatezip;\n+\n+import java.io.*;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.util.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipInputStream;\n+import java.util.zip.ZipOutputStream;\n+\n+\/**\n+ * Generate a zip file in a \"reproducible\" manner from the input files or\n+ * directory.\n+ * Standard zip tools rely on OS file list querying whose ordering varies\n+ * by platform architecture, this class ensures the zip entries are ordered\n+ * and also supports SOURCE_DATE_EPOCH timestamps.\n+ *\/\n+public class GenerateZip {\n+    String fname = null;\n+    String zname = \"\";\n+    long   timestamp = -1L;\n+    List<String> files = new ArrayList<>();;\n+    boolean verbose = false;\n+\n+    Set<File> entries = new LinkedHashSet<>();\n+\n+    private boolean ok;\n+\n+    public GenerateZip() {\n+    }\n+\n+    public synchronized boolean run(String args[]) {\n+        ok = true;\n+        if (!parseArgs(args)) {\n+            return false;\n+        }\n+        try {\n+            zname = fname.replace(File.separatorChar, '\/');\n+            if (zname.startsWith(\".\/\")) {\n+                zname = zname.substring(2);\n+            }\n+\n+            if (verbose) System.out.println(\"Files or directories to zip: \"+files);\n+\n+            File zipFile = new File(fname);\n+            \/\/ Check archive to create does not exist\n+            if (!zipFile.exists()) {\n+                \/\/ Process Files\n+                for(String file : files) {\n+                    Path filepath = Paths.get(file);\n+                    processFiles(filepath);\n+                }\n+\n+                try (FileOutputStream out = new FileOutputStream(fname)) {\n+                    boolean createOk = create(new BufferedOutputStream(out, 4096));\n+                    if (ok) {\n+                        ok = createOk;\n+                    }\n+                }\n+            } else {\n+                error(\"Target zip file \"+fname+\" already exists.\");\n+                ok = false;\n+            }\n+        } catch (IOException e) {\n+            fatalError(e);\n+            ok = false;\n+        } catch (Error ee) {\n+            ee.printStackTrace();\n+            ok = false;\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            ok = false;\n+        }\n+        return ok;\n+    }\n+\n+    boolean parseArgs(String args[]) {\n+        try {\n+            boolean parsingIncludes = false;\n+            boolean parsingExcludes = false;\n+            int count = 0;\n+            while(count < args.length) {\n+                if (args[count].startsWith(\"-\")) {\n+                    String flag = args[count].substring(1);\n+                    switch (flag.charAt(0)) {\n+                    case 'f':\n+                        fname = args[++count];\n+                        break;\n+                    case 't':\n+                        \/\/ SOURCE_DATE_EPOCH timestamp specified\n+                        timestamp = Long.parseLong(args[++count]) * 1000;\n+                        break;\n+                    case 'v':\n+                        verbose = true;\n+                        break;\n+                    default:\n+                        error(String.format(\"Illegal option -%s\", String.valueOf(flag.charAt(0))));\n+                        usageError();\n+                        return false;\n+                    }\n+                } else {\n+                    \/\/ file or dir to zip\n+                    files.add(args[count]);\n+                }\n+                count++;\n+            }\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            usageError();\n+            return false;\n+        } catch (NumberFormatException e) {\n+            usageError();\n+            return false;\n+        }\n+        if (fname == null) {\n+            error(String.format(\"-f <archiveName> must be specified\"));\n+            usageError();\n+            return false;\n+        }\n+        \/\/ If no files specified then default to current directory\n+        if (files.size() == 0) {\n+            error(\"No input directory or files were specified\");\n+            usageError();\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    \/\/ Walk tree matching files and adding to entries list\n+    void processFiles(Path path) throws IOException {\n+        File fpath = path.toFile();\n+        boolean pathIsDir = fpath.isDirectory();\n+\n+        \/\/ Keep a sorted Set of files to be processed, so that the Jmod is reproducible\n+        \/\/ as Files.walkFileTree order is not defined\n+        SortedMap<String, Path> filesToProcess  = new TreeMap<String, Path>();\n+\n+        Files.walkFileTree(path, Set.of(FileVisitOption.FOLLOW_LINKS),\n+            Integer.MAX_VALUE, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                    throws IOException\n+                {\n+                    Path relPath;\n+                    String name;\n+                    if (pathIsDir) {\n+                        relPath = path.relativize(file);\n+                        name = relPath.toString();\n+                    } else {\n+                        relPath = file;\n+                        name = file.toString();\n+                    }\n+                    filesToProcess.put(name, file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+        });\n+\n+        \/\/ Process files in sorted order\n+        for (Map.Entry<String, Path> entry : filesToProcess.entrySet()) {\n+            String name = entry.getKey();\n+            Path   filepath = entry.getValue();\n+\n+            File f = filepath.toFile();\n+            entries.add(f);\n+        }\n+    }\n+\n+    \/\/ Create new zip from entries\n+    boolean create(OutputStream out) throws IOException\n+    {\n+        try (ZipOutputStream zos = new ZipOutputStream(out)) {\n+            for (File file: entries) {\n+                addFile(zos, file);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ Ensure a consistent entry name format\n+    String entryName(String name) {\n+        name = name.replace(File.separatorChar, '\/');\n+\n+        if (name.startsWith(\"\/\")) {\n+            name = name.substring(1);\n+        } else if (name.startsWith(\".\/\")) {\n+            name = name.substring(2);\n+        }\n+        return name;\n+    }\n+\n+    \/\/ Add File to Zip\n+    void addFile(ZipOutputStream zos, File file) throws IOException {\n+        String name = file.getPath();\n+        boolean isDir = file.isDirectory();\n+        if (isDir) {\n+            name = name.endsWith(File.separator) ? name : (name + File.separator);\n+        }\n+        name = entryName(name);\n+\n+        if (name.equals(\"\") || name.equals(\".\") || name.equals(zname)) {\n+            return;\n+        }\n+\n+        long size = isDir ? 0 : file.length();\n+\n+        if (verbose) {\n+            System.out.println(\"Adding: \"+name);\n+        }\n+\n+        ZipEntry e = new ZipEntry(name);\n+        \/\/ Set to specified timestamp if set otherwise use file lastModified time\n+        if (timestamp != -1L) {\n+            e.setTime(timestamp);\n+        } else {\n+            e.setTime(file.lastModified());\n+        }\n+        if (size == 0) {\n+            e.setMethod(ZipEntry.STORED);\n+            e.setSize(0);\n+            e.setCrc(0);\n+        }\n+        zos.putNextEntry(e);\n+        if (!isDir) {\n+            byte[] buf = new byte[8192];\n+            int len;\n+            try (FileInputStream fis = new FileInputStream(file);\n+                 FileChannel fic = fis.getChannel()) {\n+                fic.transferTo(0, fic.size(), Channels.newChannel(zos));\n+            }\n+        }\n+        zos.closeEntry();\n+    }\n+\n+    void usageError() {\n+        error(\n+        \"Usage: GenerateZip [-v] -f <zip_file> <files_or_directories>\\n\" +\n+        \"Options:\\n\" +\n+        \"   -v  verbose output\\n\" +\n+        \"   -f  specify archive file name to create\\n\" +\n+        \"   -t  specific SOURCE_DATE_EPOCH value to use for timestamps\\n\" +\n+        \"If any file is a directory then it is processed recursively.\\n\");\n+    }\n+\n+    void fatalError(Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+    protected void error(String s) {\n+        System.err.println(s);\n+    }\n+\n+    public static void main(String args[]) {\n+        GenerateZip z = new GenerateZip();\n+        System.exit(z.run(args) ? 0 : 1);\n+    }\n+}\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatezip\/GenerateZip.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"}]}