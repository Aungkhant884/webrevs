{"files":[{"patch":"@@ -82,0 +82,1 @@\n+import jdk.internal.reflect.MethodInheritance;\n@@ -3648,1 +3649,1 @@\n-        PublicMethods pms = new PublicMethods();\n+        MethodInheritance inheritance = new MethodInheritance();\n@@ -3650,1 +3651,1 @@\n-            pms.merge(m);\n+            inheritance.merge(m);\n@@ -3656,1 +3657,1 @@\n-                pms.merge(m);\n+                inheritance.merge(m);\n@@ -3664,1 +3665,1 @@\n-                    pms.merge(m);\n+                    inheritance.merge(m);\n@@ -3669,1 +3670,1 @@\n-        res = pms.toArray();\n+        res = inheritance.toArray();\n@@ -3751,1 +3752,1 @@\n-        PublicMethods.MethodList res = getMethodsRecursive(\n+        MethodInheritance.MethodList res = getMethodsRecursive(\n@@ -3761,3 +3762,3 @@\n-    private PublicMethods.MethodList getMethodsRecursive(String name,\n-                                                         Class<?>[] parameterTypes,\n-                                                         boolean includeStatic) {\n+    private MethodInheritance.MethodList getMethodsRecursive(String name,\n+                                                             Class<?>[] parameterTypes,\n+                                                             boolean includeStatic) {\n@@ -3766,1 +3767,1 @@\n-        PublicMethods.MethodList res = PublicMethods.MethodList\n+        MethodInheritance.MethodList res = MethodInheritance.MethodList\n@@ -3785,1 +3786,1 @@\n-            res = PublicMethods.MethodList.merge(\n+            res = MethodInheritance.MethodList.merge(\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.Constructor;\n@@ -38,0 +39,2 @@\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n@@ -57,0 +60,1 @@\n+import jdk.internal.reflect.MethodInheritance;\n@@ -73,1 +77,1 @@\n-public class MethodHandleProxies {\n+public final class MethodHandleProxies {\n@@ -78,2 +82,2 @@\n-     * Produces an instance of the given single-method interface which redirects\n-     * its calls to the given method handle.\n+     * Produces an instance of the given single-method interface or abstract\n+     * class which redirects its calls to the given method handle.\n@@ -81,1 +85,2 @@\n-     * A single-method interface is an interface which declares a uniquely named method.\n+     * A single-method interface or abstract class is a class or interface which\n+     * declares a uniquely named abstract method.\n@@ -89,1 +94,2 @@\n-     * The interface must be public, not {@linkplain Class#isHidden() hidden},\n+     * The interface or abstract class must be public, not\n+     * {@linkplain Class#isHidden() hidden},\n@@ -91,1 +97,2 @@\n-     * No additional access checks are performed.\n+     * If it is an abstract class, it must have a protected or public no-arg\n+     * constructor.  No additional access checks are performed.\n@@ -142,5 +149,0 @@\n-     * Future versions of this API may accept additional types,\n-     * such as abstract classes with single abstract methods.\n-     * Future versions of this API may also equip wrapper instances\n-     * with one or more additional public \"marker\" interfaces.\n-     * <p>\n@@ -153,0 +155,1 @@\n+     *            or abstract class\n@@ -165,2 +168,10 @@\n-        if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))\n-            throw newIllegalArgumentException(\"not a public interface\", intfc.getName());\n+        if (intfc.isArray() || intfc.isPrimitive())\n+            throw newIllegalArgumentException(\"not a class or interface\", intfc.getName());\n+        var mods = intfc.getModifiers();\n+        if (!Modifier.isPublic(mods))\n+            throw newIllegalArgumentException(\"not a public class or interface\", intfc.getName());\n+        if (!Modifier.isAbstract(mods))\n+            throw newIllegalArgumentException(\"not an abstract class or interface\", intfc.getName());\n+        if (!Modifier.isInterface(mods) && !hasAccessibleNoArgConstructor(intfc))\n+            throw newIllegalArgumentException(\"an abstract class with no public or protected no-arg constructor\",\n+                    intfc.getName());\n@@ -168,1 +179,1 @@\n-            throw newIllegalArgumentException(\"a sealed interface\", intfc.getName());\n+            throw newIllegalArgumentException(\"a sealed class or interface\", intfc.getName());\n@@ -170,1 +181,1 @@\n-            throw newIllegalArgumentException(\"a hidden interface\", intfc.getName());\n+            throw newIllegalArgumentException(\"a hidden class or interface\", intfc.getName());\n@@ -215,1 +226,1 @@\n-    private record MethodInfo(MethodTypeDesc desc, List<ClassDesc> thrown, String fieldName) {}\n+    private record MethodInfo(boolean hasProtectedAccess, MethodTypeDesc desc, List<ClassDesc> thrown, String fieldName) {}\n@@ -228,0 +239,77 @@\n+    \/\/ ClassValue, InputStream, OutputStream ...\n+    private static boolean hasAccessibleNoArgConstructor(Class<?> abstractClass) {\n+        Constructor<?> constructor;\n+        @SuppressWarnings(\"removal\")\n+        var sm = System.getSecurityManager();\n+        if (sm != null) {\n+            try {\n+                @SuppressWarnings(\"removal\")\n+                Constructor<?> ctor = AccessController.doPrivileged(\n+                        new PrivilegedExceptionAction<>() {\n+                            @Override\n+                            public Constructor<?> run() throws Exception {\n+                                return abstractClass.getDeclaredConstructor();\n+                            }\n+                        });\n+                constructor = ctor;\n+            } catch (PrivilegedActionException e) {\n+                return false;\n+            }\n+        } else {\n+            try {\n+                constructor = abstractClass.getConstructor();\n+            } catch (NoSuchMethodException e) {\n+                return false;\n+            }\n+        }\n+        int mods = constructor.getModifiers();\n+        return Modifier.isPublic(mods) || Modifier.isProtected(mods);\n+    }\n+\n+    \/**\n+     * Finds abstract methods, protected or public, from super classes and interfaces.\n+     * @param type the abstract interface or class\n+     * @return an array of all abstract methods to override\n+     *\/\n+    private static Method[] findMethods(Class<?> type) {\n+        MethodInheritance inheritance = new MethodInheritance();\n+        \/\/ Find public abstract methods\n+        for (var method : type.getMethods()) {\n+            if (Modifier.isAbstract(method.getModifiers()) && !isObjectMethod(method)) {\n+                inheritance.merge(method);\n+            }\n+        }\n+\n+        \/\/ Find protected abstract methods\n+        \/\/ protected methods only come from super classes\n+        @SuppressWarnings(\"removal\")\n+        var sm = System.getSecurityManager();\n+        for (Class<?> c = type; c != Object.class && c != null; c = c.getSuperclass()) {\n+            Method[] methods;\n+            if (sm != null) {\n+                final var cl = c;\n+                \/\/ Using lambda here causes caller problems\n+                @SuppressWarnings(\"removal\")\n+                Method[] mths = AccessController.doPrivileged(\n+                        new PrivilegedAction<>() {\n+                            @Override\n+                            public Method[] run() {\n+                                return cl.getDeclaredMethods();\n+                            }\n+                        });\n+                methods = mths;\n+            } else {\n+                methods = c.getDeclaredMethods();\n+            }\n+\n+            for (var method : methods) {\n+                var mod = method.getModifiers();\n+                if (Modifier.isAbstract(mod) && Modifier.isProtected(mod)) {\n+                    inheritance.merge(method);\n+                }\n+            }\n+        }\n+\n+        return inheritance.toArray();\n+    }\n+\n@@ -234,8 +322,2 @@\n-        for (Method m : intfc.getMethods()) {\n-            if (!Modifier.isAbstract(m.getModifiers()))\n-                continue;\n-\n-            if (isObjectMethod(m))\n-                continue;\n-\n-            \/\/ ensure it's SAM interface\n+        for (Method m : findMethods(intfc)) {\n+            \/\/ ensure it's SAM type\n@@ -259,1 +341,1 @@\n-            methods.add(new MethodInfo(desc(mt), exceptionTypeDescs, fieldName));\n+            methods.add(new MethodInfo(Modifier.isProtected(m.getModifiers()), desc(mt), exceptionTypeDescs, fieldName));\n@@ -282,1 +364,1 @@\n-        byte[] template = createTemplate(loader, ClassDesc.of(className), desc(intfc), uniqueName, methods);\n+        byte[] template = createTemplate(loader, ClassDesc.of(className), desc(intfc), uniqueName, methods, !intfc.isInterface());\n@@ -363,1 +445,1 @@\n-     * @param ifaceDesc the given interface\n+     * @param ifaceDesc the given interface or abstract class\n@@ -366,0 +448,1 @@\n+     * @param isAbstractClass whether the given class is an abstract class instead of an interface\n@@ -369,1 +452,2 @@\n-                                         String methodName, List<MethodInfo> methods) {\n+                                         String methodName, List<MethodInfo> methods, boolean isAbstractClass) {\n+        var superTypeDesc = isAbstractClass ? ifaceDesc : CD_Object;\n@@ -372,1 +456,1 @@\n-            clb.withSuperclass(CD_Object);\n+\n@@ -374,1 +458,4 @@\n-            clb.withInterfaceSymbols(ifaceDesc);\n+            clb.withSuperclass(superTypeDesc);\n+            if (!isAbstractClass) {\n+                clb.withInterfaceSymbols(ifaceDesc);\n+            }\n@@ -393,1 +480,1 @@\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.invokespecial(superTypeDesc, INIT_NAME, MTD_void);\n@@ -449,1 +536,2 @@\n-                clb.withMethodBody(methodName, mi.desc, ACC_PUBLIC, cob -> cob\n+                clb.withMethodBody(methodName, mi.desc, mi.hasProtectedAccess()\n+                        ? ACC_PROTECTED : ACC_PUBLIC, cob -> cob\n@@ -580,0 +668,3 @@\n+        \/\/ abstract class Object method overrides must be implemented in subclasses\n+        if (!m.getDeclaringClass().isInterface())\n+            return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":123,"deletions":32,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n-package java.lang;\n-\n-import jdk.internal.reflect.ReflectionFactory;\n+package jdk.internal.reflect;\n@@ -31,1 +29,0 @@\n-import java.security.AccessController;\n@@ -37,2 +34,2 @@\n- * A collection of most specific public methods. Methods are added to it using\n- * {@link #merge(Method)} method. Only the most specific methods for a\n+ * A collection of most specific methods in inheritance. Methods are added to\n+ * it using {@link #merge(Method)} method. Only the most specific methods for a\n@@ -41,1 +38,1 @@\n-final class PublicMethods {\n+public final class MethodInheritance {\n@@ -61,1 +58,1 @@\n-    void merge(Method method) {\n+    public void merge(Method method) {\n@@ -76,1 +73,1 @@\n-    Method[] toArray() {\n+    public Method[] toArray() {\n@@ -91,1 +88,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -93,2 +89,1 @@\n-            AccessController.doPrivileged(\n-                new ReflectionFactory.GetReflectionFactoryAction());\n+            ReflectionFactory.getReflectionFactory();\n@@ -131,1 +126,1 @@\n-     * Node of a inked list containing Method(s) sharing the same\n+     * Node of a linked list containing Method(s) sharing the same\n@@ -134,3 +129,3 @@\n-    static final class MethodList {\n-        Method method;\n-        MethodList next;\n+    public static final class MethodList {\n+        private final Method method;\n+        private MethodList next;\n@@ -148,1 +143,1 @@\n-        static MethodList filter(Method[] methods, String name,\n+        public static MethodList filter(Method[] methods, String name,\n@@ -175,1 +170,1 @@\n-        static MethodList merge(MethodList head, MethodList methodList) {\n+        public static MethodList merge(MethodList head, MethodList methodList) {\n@@ -259,1 +254,1 @@\n-        Method getMostSpecific() {\n+        public Method getMostSpecific() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodInheritance.java","additions":14,"deletions":19,"binary":false,"changes":33,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/PublicMethods.java","status":"renamed"},{"patch":"@@ -30,0 +30,1 @@\n+import java.io.InputStream;\n@@ -69,1 +70,1 @@\n-    public void testUsual() throws Throwable {\n+    public void testInterface() throws Throwable {\n@@ -78,0 +79,10 @@\n+    @Test\n+    public void testAbstractClass() throws Throwable {\n+        AtomicInteger ai = new AtomicInteger(5);\n+        var mh = MethodHandles.lookup().findVirtual(AtomicInteger.class, \"getAndIncrement\", methodType(int.class));\n+        InputStream is = asInterfaceInstance(InputStream.class, mh.bindTo(ai));\n+        assertEquals(5, is.read());\n+        assertEquals(6, is.read());\n+        assertEquals(7, is.read());\n+    }\n+\n@@ -134,0 +145,4 @@\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(int.class, mh),\n+                \"primitive type\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(Object[].class, mh),\n+                \"array class\");\n@@ -144,0 +159,6 @@\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(BaseAbs.class, mh),\n+                \"no abstract method\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(ArgConstructor.class, mh),\n+                \"no no-arg constructor\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(InaccessibleConstructor.class, mh),\n+                \"no-arg constructor not accessible\");\n@@ -147,1 +168,1 @@\n-     * Tests that non-sealed interfaces can be implemented.\n+     * Tests that certain classes or interfaces can be implemented.\n@@ -150,4 +171,7 @@\n-    public void testNonSealed() {\n-        MethodHandle target = MethodHandles.constant(String.class, \"Non-Sealed\");\n-        NonSealed proxy = asInterfaceInstance(NonSealed.class, target);\n-        assertEquals(proxy.m(), \"Non-Sealed\");\n+    public void testAccepted() {\n+        var returnValue = new String(new char[] {'4', '2'});\n+        var mh = MethodHandles.constant(String.class, returnValue);\n+        var nonSealedProxy = asInterfaceInstance(NonSealed.class, mh);\n+        assertSame(returnValue, nonSealedProxy.m());\n+        var overrideProxy = asInterfaceInstance(ObjectOverride.class, mh);\n+        assertSame(returnValue, overrideProxy.toString());\n@@ -378,0 +402,22 @@\n+\n+    public abstract static class BaseAbs {\n+    }\n+\n+    public abstract static class ChildAbs extends BaseAbs {\n+        protected abstract void take();\n+    }\n+\n+    public abstract static class ArgConstructor {\n+        protected ArgConstructor(Void arg) {}\n+        protected abstract String work();\n+    }\n+\n+    public abstract static class InaccessibleConstructor {\n+        InaccessibleConstructor() {}\n+        protected abstract String work();\n+    }\n+\n+    public abstract static class ObjectOverride {\n+        @Override\n+        public abstract String toString();\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":52,"deletions":6,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.InputStream;\n@@ -40,0 +41,4 @@\n+    public abstract static class NestedAbstractClass {\n+        protected abstract void task();\n+    }\n+\n@@ -48,1 +53,2 @@\n-        for (Class<?> cl : List.of(Runnable.class, Client.class, NestedInterface.class)) {\n+        for (Class<?> cl : List.of(Runnable.class, Client.class, NestedInterface.class,\n+                InputStream.class, NestedAbstractClass.class)) {\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WithSecurityManagerTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.reflect.Modifier;\n@@ -38,0 +39,1 @@\n+import java.util.function.BooleanSupplier;\n@@ -199,4 +201,15 @@\n-        System.gc(); \/\/ helps debug if incorrect items are weakly referenced\n-        var wrapper2 = asInterfaceInstance(ifaceClass, mh);\n-        assertSame(implClass, wrapper2.getClass(),\n-                \"MHP should reuse old implementation class when available\");\n+        class ImplClassChangeChecker implements BooleanSupplier {\n+            \/\/ have to manually unroll for implClass cannot be final\n+            final Class<?> impl;\n+            ImplClassChangeChecker(Class<?> impl) {\n+                this.impl = impl;\n+            }\n+            @Override\n+            public boolean getAsBoolean() {\n+                return asInterfaceInstance(ifaceClass, mh).getClass() != impl;\n+            }\n+        }\n+\n+        if (ForceGC.waitFor(new ImplClassChangeChecker(implClass), 50L)) {\n+            fail(\"MHP should reuse old implementation class when available\");\n+        }\n@@ -208,1 +221,0 @@\n-        wrapper2 = null;\n@@ -214,0 +226,45 @@\n+\n+    \/**\n+     * Ensures that abstract classes with fields that have same name and type\n+     * as impl internal fields won't affect the implementation.\n+     *\/\n+    @Test\n+    public void testFieldShadowing() {\n+        var value = new String(new char[] {'4', '2'});\n+        var mh = MethodHandles.constant(String.class, value);\n+        var inst = asInterfaceInstance(Shadowing.class, mh);\n+        assertSame(Shadowing.class, wrapperInstanceType(inst));\n+        assertSame(mh, wrapperInstanceTarget(inst));\n+        assertSame(value, inst.produce());\n+    }\n+\n+    public abstract static class Shadowing {\n+        protected static final Class<?> interfaceType = MethodHandles.class;\n+        protected final MethodHandle target = MethodHandles.zero(int.class);\n+        private final MethodHandle m0 = MethodHandles.zero(double.class);\n+\n+        public abstract String produce();\n+    }\n+\n+    \/**\n+     * Ensures that in abstract classes, abstract methods keep their\n+     * existing access level (public, protected).\n+     *\/\n+    @Test\n+    public void testMethodAccess() throws Throwable {\n+        var value = new String(new char[] {'4', '2'});\n+        var mh = MethodHandles.constant(String.class, value);\n+        mh = MethodHandles.dropArguments(mh, 0, int.class);\n+        var inst = asInterfaceInstance(Accesses.class, mh);\n+        var implClass = inst.getClass();\n+        assertTrue(Modifier.isPublic(implClass.getDeclaredMethod(\"work\", Integer.class).getModifiers()),\n+                \"public method not public in implementation wrapper\");\n+        assertTrue(Modifier.isProtected(implClass.getDeclaredMethod(\"work\", int.class).getModifiers()),\n+                \"protected method not protected in implementation wrapper\");\n+    }\n+\n+    public abstract static class Accesses {\n+        public abstract String work(Integer a);\n+        protected abstract String work(int a);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java","additions":62,"deletions":5,"binary":false,"changes":67,"status":"modified"}]}