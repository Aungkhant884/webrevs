{"files":[{"patch":"@@ -2407,1 +2407,1 @@\n-      peerEnv->describe_pending_exception(true);\n+      peerEnv->describe_pending_exception(tty);\n@@ -2571,1 +2571,1 @@\n-        peerJVMCIEnv->describe_pending_exception(true);\n+        peerJVMCIEnv->describe_pending_exception(tty);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -313,2 +313,44 @@\n-\/\/ Prints a pending exception (if any) and its stack trace.\n-void JVMCIEnv::describe_pending_exception(bool clear) {\n+\/\/ Prints a pending exception (if any) and its stack trace to st.\n+\/\/ Also partially logs the stack trace to the JVMCI event log.\n+void JVMCIEnv::describe_pending_exception(outputStream* st) {\n+  char* stack_trace = nullptr;\n+  if (pending_exception_as_string(nullptr, (const char**) &stack_trace)) {\n+    st->print_raw_cr(stack_trace);\n+\n+    \/\/ Use up to half the lines of the JVMCI event log to\n+    \/\/ show the stack trace.\n+    char* cursor = stack_trace;\n+    int line = 0;\n+    const int max_lines = LogEventsBufferEntries \/ 2;\n+    char* last_line = nullptr;\n+    while (*cursor != '\\0') {\n+      char* eol = strchr(cursor, '\\n');\n+      if (eol == nullptr) {\n+        if (line == max_lines - 1) {\n+          last_line = cursor;\n+        } else if (line < max_lines) {\n+          JVMCI_event_1(\"%s\", cursor);\n+        }\n+        cursor = cursor + strlen(cursor);\n+      } else {\n+        *eol = '\\0';\n+        if (line == max_lines - 1) {\n+          last_line = cursor;\n+        } else if (line < max_lines) {\n+          JVMCI_event_1(\"%s\", cursor);\n+        }\n+        cursor = eol + 1;\n+      }\n+      line++;\n+    }\n+    if (last_line != nullptr) {\n+      if (line > max_lines) {\n+        JVMCI_event_1(\"%s [elided %d more stack trace lines]\", last_line, line - max_lines);\n+      } else {\n+        JVMCI_event_1(\"%s\", last_line);\n+      }\n+    }\n+  }\n+}\n+\n+bool JVMCIEnv::pending_exception_as_string(const char** to_string, const char** stack_trace) {\n@@ -316,0 +358,3 @@\n+  JVMCIObject to_string_obj;\n+  JVMCIObject stack_trace_obj;\n+  bool had_nested_exception = false;\n@@ -318,5 +363,21 @@\n-    if (jni()->ExceptionCheck()) {\n-      jthrowable ex = !clear ? jni()->ExceptionOccurred() : nullptr;\n-      jni()->ExceptionDescribe();\n-      if (ex != nullptr) {\n-        jni()->Throw(ex);\n+    jthrowable ex = jni()->ExceptionOccurred();\n+    if (ex != NULL) {\n+      jni()->ExceptionClear();\n+      jobjectArray pair = (jobjectArray) jni()->CallStaticObjectMethod(\n+        JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+        JNIJVMCI::HotSpotJVMCIRuntime::exceptionToString_method(),\n+        ex, to_string != nullptr, stack_trace != nullptr);\n+      if (jni()->ExceptionCheck()) {\n+        \/\/ As last resort, dump nested exception\n+        jni()->ExceptionDescribe();\n+        had_nested_exception = true;\n+      } else {\n+        guarantee(pair != nullptr, \"pair is null\");\n+        int len = jni()->GetArrayLength(pair);\n+        guarantee(len == 2, \"bad len is %d\", len);\n+        if (to_string != nullptr) {\n+          to_string_obj = JVMCIObject::create(jni()->GetObjectArrayElement(pair, 0), false);\n+        }\n+        if (stack_trace != nullptr) {\n+          stack_trace_obj = JVMCIObject::create(jni()->GetObjectArrayElement(pair, 1), false);\n+        }\n@@ -324,0 +385,2 @@\n+    } else {\n+      return false;\n@@ -327,1 +390,48 @@\n-      JVMCIRuntime::describe_pending_hotspot_exception(THREAD, clear);\n+      Handle exception(THREAD, PENDING_EXCEPTION);\n+      CLEAR_PENDING_EXCEPTION;\n+      JavaCallArguments jargs;\n+      jargs.push_oop(exception);\n+      jargs.push_int(to_string != nullptr);\n+      jargs.push_int(stack_trace != nullptr);\n+      JavaValue result(T_OBJECT);\n+      JavaCalls::call_static(&result,\n+                              HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),\n+                              vmSymbols::exceptionToString_name(),\n+                              vmSymbols::exceptionToString_signature(), &jargs, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        Handle nested_exception(THREAD, PENDING_EXCEPTION);\n+        CLEAR_PENDING_EXCEPTION;\n+        java_lang_Throwable::print_stack_trace(nested_exception, tty);\n+        \/\/ Clear and ignore any exceptions raised during printing\n+        CLEAR_PENDING_EXCEPTION;\n+        had_nested_exception = true;\n+      } else {\n+        oop pair = result.get_oop();\n+        guarantee(pair->is_objArray(), \"must be\");\n+        objArrayOop pair_arr = objArrayOop(pair);\n+        int len = pair_arr->length();\n+        guarantee(len == 2, \"bad len is %d\", len);\n+        if (to_string != nullptr) {\n+          to_string_obj = HotSpotJVMCI::wrap(pair_arr->obj_at(0));\n+        }\n+        if (stack_trace != nullptr) {\n+          stack_trace_obj = HotSpotJVMCI::wrap(pair_arr->obj_at(1));\n+        }\n+      }\n+    } else {\n+      return false;\n+    }\n+  }\n+  if (had_nested_exception) {\n+    if (to_string != nullptr) {\n+      *to_string = \"nested exception occurred converting exception to string\";\n+    }\n+    if (stack_trace != nullptr) {\n+      *stack_trace = \"nested exception occurred converting exception stack to string\";\n+    }\n+  } else {\n+    if (to_string_obj.is_non_null()) {\n+      *to_string = as_utf8_string(to_string_obj);\n+    }\n+    if (stack_trace_obj.is_non_null()) {\n+      *stack_trace = as_utf8_string(stack_trace_obj);\n@@ -330,0 +440,1 @@\n+  return true;\n@@ -332,0 +443,1 @@\n+\n@@ -773,2 +885,3 @@\n-    int length = jni()->GetStringLength(str.as_jstring());\n-    int utf8_length = jni()->GetStringUTFLength(str.as_jstring());\n+    jstring jstr = str.as_jstring();\n+    int length = jni()->GetStringLength(jstr);\n+    int utf8_length = jni()->GetStringUTFLength(jstr);\n@@ -776,1 +889,1 @@\n-    jni()->GetStringUTFRegion(str.as_jstring(), 0, length, result);\n+    jni()->GetStringUTFRegion(jstr, 0, length, result);\n@@ -905,1 +1018,1 @@\n-    describe_pending_exception(true);\n+    describe_pending_exception(tty);\n@@ -961,24 +1074,0 @@\n-\n-JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {\n-  JavaThread* THREAD = JVMCI::compilation_tick(JavaThread::current()); \/\/ For exception macros.\n-  if (is_hotspot()) {\n-    JavaCallArguments jargs;\n-    jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));\n-    JavaValue result(T_OBJECT);\n-    JavaCalls::call_static(&result,\n-                           HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),\n-                           vmSymbols::callToString_name(),\n-                           vmSymbols::callToString_signature(), &jargs, CHECK_(JVMCIObject()));\n-    return wrap(result.get_oop());\n-  } else {\n-    JNIAccessMark jni(this, THREAD);\n-    jobject result = (jstring) jni()->CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                                     JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),\n-                                                     object.as_jobject());\n-    if (jni()->ExceptionCheck()) {\n-      return JVMCIObject();\n-    }\n-    return wrap(result);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":125,"deletions":36,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  \/\/ Prints the toString() and stack trace of a pending exception.\n+  \/\/ Prints the stack trace of a pending exception to `st` and clears the exception.\n@@ -254,2 +254,8 @@\n-  \/\/ If `clear` is false, the pending exception will remain pending upon return.\n-  void describe_pending_exception(bool clear);\n+  void describe_pending_exception(outputStream* st);\n+\n+  \/\/ Gets the output of calling toString and\/or printStactTrace on the pending exception.\n+  \/\/ If to_string is not null, the output of toString is returned in it.\n+  \/\/ If stack_trace is not null, the output of printStackTrace is returned in it.\n+  \/\/ Returns false if there is no pending exception otherwise clears the pending\n+  \/\/ exception and returns true.\n+  bool pending_exception_as_string(const char** to_string, const char** stack_trace);\n@@ -336,2 +342,0 @@\n-  JVMCIObject call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCI_TRAPS);\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    JVMCIENV->describe_pending_exception(true);  \\\n+    JVMCIENV->describe_pending_exception(tty);   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciExceptions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, callToString, callToString_signature, (JVMCIObject object, JVMCI_TRAPS)) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, exceptionToString, exceptionToString_signature, (JVMCIObject object, bool toString, bool stackTrace, JVMCI_TRAPS)) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -1605,1 +1606,1 @@\n-void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {\n+void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD) {\n@@ -1608,2 +1609,0 @@\n-    const char* exception_file = THREAD->exception_file();\n-    int exception_line = THREAD->exception_line();\n@@ -1615,3 +1614,0 @@\n-    if (!clear) {\n-      THREAD->set_pending_exception(exception(), exception_file, exception_line);\n-    }\n@@ -1630,1 +1626,1 @@\n-      JVMCIENV->describe_pending_exception(true);\n+      JVMCIENV->describe_pending_exception(tty);\n@@ -1632,1 +1628,1 @@\n-      describe_pending_hotspot_exception(THREAD, true);\n+      describe_pending_hotspot_exception(THREAD);\n@@ -1635,1 +1631,1 @@\n-    \/\/ Allow error reporting thread to print the stack trace.\n+    \/\/ Allow error reporting thread time to print the stack trace.\n@@ -1988,1 +1984,5 @@\n-    const char* failure_reason = os::strdup(err_msg(\"uncaught exception in %s\", function), mtJVMCI);\n+    const char* pending_string = nullptr;\n+    const char* pending_stack_trace = nullptr;\n+    JVMCIENV->pending_exception_as_string(&pending_string, &pending_stack_trace);\n+    if (pending_string == nullptr) pending_string = \"null\";\n+    const char* failure_reason = os::strdup(err_msg(\"uncaught exception in %s [%s]\", function, pending_string), mtJVMCI);\n@@ -1993,0 +1993,1 @@\n+    JVMCI_event_1(\"%s\", failure_reason);\n@@ -1997,3 +1998,4 @@\n-      JVMCIENV->describe_pending_exception(true);\n-    } else {\n-      JVMCIENV->clear_pending_exception();\n+      if (pending_stack_trace != nullptr) {\n+        LogStream ls(log.info());\n+        ls.print_raw_cr(pending_stack_trace);\n+      }\n@@ -2044,0 +2046,5 @@\n+#ifdef ASSERT\n+  if (JVMCIENV->has_pending_exception() && JVMCICompileMethodExceptionIsFatal) {\n+    fatal_exception(JVMCIENV, \"testing JVMCI fatal exception handling\");\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-  static void describe_pending_hotspot_exception(JavaThread* THREAD, bool clear);\n+  static void describe_pending_hotspot_exception(JavaThread* THREAD);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+  CHECK_NOT_SET(JVMCICompileMethodExceptionIsFatal,  EnableJVMCI)\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -155,0 +155,4 @@\n+  notproduct(bool, JVMCICompileMethodExceptionIsFatal, false,               \\\n+          \"An exception thrown by HotSpotJVMCIRuntime::compileMethod \"      \\\n+          \"is fatal. Used to test error handling only.\")                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-  template(callToString_name,                                     \"callToString\")                                                         \\\n-  template(callToString_signature,                                \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\")                               \\\n+  template(exceptionToString_name,                                \"exceptionToString\")                                                    \\\n+  template(exceptionToString_signature,                           \"(Ljava\/lang\/Throwable;ZZ)[Ljava\/lang\/String;\")                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -42,0 +43,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -201,2 +203,13 @@\n-    static String callToString(Object o) {\n-        return o.toString();\n+    static String[] exceptionToString(Throwable o, boolean toString, boolean stackTrace) {\n+        String[] res = {null, null};\n+        if (toString) {\n+            res[0] = o.toString();\n+        }\n+        if (stackTrace) {\n+            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+            try (PrintStream ps = new PrintStream(buf)) {\n+                o.printStackTrace(ps);\n+            }\n+            res[1] = buf.toString(StandardCharsets.UTF_8);\n+        }\n+        return res;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+compiler.jvmci.TestUncaughtErrorInCompileMethod\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestUncaughtErrorInCompileMethod.config","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests handling of an exception thrown by HotSpotJVMCIRuntime.compileMethod.\n+ * @requires vm.jvmci\n+ * @requires vm.debug\n+ * @library \/test\/lib \/\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.services\n+ * @run driver jdk.test.lib.FileInstaller .\/TestUncaughtErrorInCompileMethod.config\n+ *     .\/META-INF\/services\/jdk.vm.ci.services.JVMCIServiceLocator\n+ * @run driver compiler.jvmci.TestUncaughtErrorInCompileMethod\n+ *\/\n+\n+package compiler.jvmci;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.vm.ci.services.JVMCIServiceLocator;\n+import jdk.vm.ci.runtime.JVMCICompiler;\n+import jdk.vm.ci.runtime.JVMCICompilerFactory;\n+import jdk.vm.ci.runtime.JVMCIRuntime;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class TestUncaughtErrorInCompileMethod extends JVMCIServiceLocator {\n+\n+    \/**\n+     * Name of file whose existence implies that a JVMCICompiler has been created.\n+     *\/\n+    static String tmpFileName = \"ErrorCompilerCreated.\" + System.nanoTime();\n+\n+    \/**\n+     * @param args if args.length != 0, then executing in subprocess\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            testSubprocess(false);\n+            testSubprocess(true);\n+        } else {\n+            File watch = new File(tmpFileName);\n+            int total = 0;\n+            long start = System.currentTimeMillis();\n+\n+            \/\/ Use a 5 sec timeout just in case the compiler creation fails\n+            while (System.currentTimeMillis() - start < 5000) {\n+                total += getTime();\n+                if (watch.exists()) {\n+                    watch.delete();\n+                    break;\n+                }\n+            }\n+            System.out.println(total);\n+        }\n+    }\n+\n+    private static long getTime() {\n+        return System.currentTimeMillis();\n+    }\n+\n+    static void testSubprocess(boolean fatalError) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+UseJVMCICompiler\", \"-Djvmci.Compiler=ErrorCompiler\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+PrintCompilation\",\n+            \"--add-exports=jdk.internal.vm.ci\/jdk.vm.ci.services=ALL-UNNAMED\",\n+            \"-XX:\" + (fatalError ? \"+\" : \"-\") + \"JVMCICompileMethodExceptionIsFatal\",\n+            \"-XX:+PrintWarnings\",\n+            \"-Xbootclasspath\/a:.\",\n+            TestUncaughtErrorInCompileMethod.class.getName(), \"true\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        if (fatalError) {\n+            output.shouldContain(\"fatal error: Fatal exception in JVMCI: testing JVMCI fatal exception handling\");\n+            output.shouldNotHaveExitValue(0);\n+            File hs_err_file = openHsErrFileFromOutput(output);\n+            Path hsErrPath = hs_err_file.toPath();\n+            if (!Files.exists(hsErrPath)) {\n+                throw new RuntimeException(\"hs_err_pid file missing at \" + hsErrPath);\n+            }\n+            String hsErr = Files.readString(hsErrPath);\n+\n+            \/*\n+             * JVMCI Events (11 events):\n+             * ...\n+             * Event: 0.274 Thread 0x0000000146819210 compiler.jvmci.TestUncaughtErrorInCompileMethod$CompilerCreationError\n+             * Event: 0.274 Thread 0x0000000146819210  at compiler.jvmci.TestUncaughtErrorInCompileMethod$1.createCompiler(TestUncaughtErrorInCompileMethod.java:147)\n+             * Event: 0.274 Thread 0x0000000146819210  at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.getCompiler(HotSpotJVMCIRuntime.java:829)\n+             * Event: 0.274 Thread 0x0000000146819210  at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.compileMethod(HotSpotJVMCIRuntime.java:943)\n+             *\/\n+\n+            \/\/ Check that hs-err contains the stack trace of the fatal exception (sample shown above)\n+            String[] stackTraceSubstrings = {\n+                \"at compiler.jvmci.TestUncaughtErrorInCompileMethod$1.createCompiler(TestUncaughtErrorInCompileMethod.java\",\n+                \"at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.compileMethod(HotSpotJVMCIRuntime.java\"\n+            };\n+            for (String expect : stackTraceSubstrings) {\n+                if (!hsErr.contains(expect)) {\n+                    throw new RuntimeException(\"Could not find \\\"\" + expect + \"\\\" in \" + hsErrPath);\n+                }\n+            }\n+        } else {\n+            output.shouldContain(\"COMPILE SKIPPED: uncaught exception in call_HotSpotJVMCIRuntime_compileMethod [compiler.jvmci.TestUncaughtErrorInCompileMethod$CompilerCreationError]\");\n+            output.shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    public TestUncaughtErrorInCompileMethod() {\n+    }\n+\n+    static class CompilerCreationError extends InternalError {}\n+\n+    @Override\n+    public <S> S getProvider(Class<S> service) {\n+        if (service == JVMCICompilerFactory.class) {\n+            return service.cast(new JVMCICompilerFactory() {\n+                @Override\n+                public String getCompilerName() {\n+                    return \"ErrorCompiler\";\n+                }\n+\n+                @Override\n+                public JVMCICompiler createCompiler(JVMCIRuntime runtime) {\n+                    File watch = new File(tmpFileName);\n+                    try {\n+                        watch.createNewFile();\n+                    } catch (IOException e) {\n+                        e.printStackTrace();\n+                    }\n+                    throw new CompilerCreationError();\n+                }\n+            });\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Given the output of a java VM that crashed, extract the name of the hs-err file from the output\n+     *\/\n+    public static String extractHsErrFileNameFromOutput(OutputAnalyzer output) {\n+        output.shouldMatch(\"# A fatal error has been detected.*\");\n+\n+        \/\/ extract hs-err file\n+        String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n+        if (hs_err_file == null) {\n+            throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n+        }\n+\n+        return hs_err_file;\n+    }\n+\n+    \/**\n+     * Given the output of a java VM that crashed, extract the name of the hs-err file from the output,\n+     * open that file and return its File.\n+     *\/\n+    public static File openHsErrFileFromOutput(OutputAnalyzer output) {\n+        String name = extractHsErrFileNameFromOutput(output);\n+        File f = new File(name);\n+        if (!f.exists()) {\n+            throw new RuntimeException(\"Cannot find hs-err file at \" + f.getAbsolutePath());\n+        }\n+        return f;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestUncaughtErrorInCompileMethod.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"}]}