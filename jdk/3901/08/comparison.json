{"files":[{"patch":"@@ -330,0 +330,4 @@\n+  unsigned identity_hash() const {\n+    return (unsigned)((uintptr_t)this >> 3);\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderData.hpp\"\n@@ -56,1 +57,2 @@\n-  unsigned int hash = method->klass_name()->identity_hash();\n+  unsigned int hash = method->method_holder()->class_loader_data()->identity_hash();\n+  hash = (hash * 31) ^ method->klass_name()->identity_hash();\n","filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,8 @@\n+    private MethodHandle generateWithSameName() throws ReflectiveOperationException {\n+        byte[] buf = new byte[100];\n+        int size = writeClass(buf, \"MH$$\");\n+        \/\/ use different classloader instances to load the classes with the same name\n+        Class<?> cls = new ResolvedMethodTableHash().defineClass(null, buf, 0, size);\n+        return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n+    }\n+\n@@ -85,1 +93,6 @@\n-            handles.add(generator.generate(\"MH$\" + i));\n+            \/\/ prevents metaspace oom\n+            if (i % 20 != 0) {\n+                handles.add(generator.generate(\"MH$\" + i));\n+            } else {\n+                handles.add(generator.generateWithSameName());\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/MemberName\/ResolvedMethodTableHash.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}