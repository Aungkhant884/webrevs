{"files":[{"patch":"@@ -1254,0 +1254,48 @@\n+#ifndef PRODUCT\n+\/\/ Check if any of live methods dependencies have been invalidated.\n+\/\/ (this is expensive!)\n+static void check_live_nmethods_dependencies(DepChange& changes) {\n+  \/\/ Checked dependencies are allocated into this ResourceMark\n+  ResourceMark rm;\n+\n+  \/\/ Turn off dependency tracing while actually testing dependencies.\n+  FlagSetting fs(Dependencies::_verify_in_progress, true);\n+\n+  typedef ResourceHashtable<DependencySignature, int, 11027,\n+                            AnyObj::RESOURCE_AREA, mtInternal,\n+                            &DependencySignature::hash,\n+                            &DependencySignature::equals> DepTable;\n+\n+  DepTable* table = new DepTable();\n+\n+  \/\/ Iterate over live nmethods and check dependencies of all nmethods that are not\n+  \/\/ marked for deoptimization. A particular dependency is only checked once.\n+  NMethodIterator iter(NMethodIterator::only_not_unloading);\n+  while(iter.next()) {\n+    nmethod* nm = iter.method();\n+    \/\/ Only notify for live nmethods\n+    if (!nm->is_marked_for_deoptimization()) {\n+      for (Dependencies::DepStream deps(nm); deps.next(); ) {\n+        \/\/ Construct abstraction of a dependency.\n+        DependencySignature* current_sig = new DependencySignature(deps);\n+\n+        \/\/ Determine if dependency is already checked. table->put(...) returns\n+        \/\/ 'true' if the dependency is added (i.e., was not in the hashtable).\n+        if (table->put(*current_sig, 1)) {\n+          if (deps.check_dependency() != nullptr) {\n+            \/\/ Dependency checking failed. Print out information about the failed\n+            \/\/ dependency and finally fail with an assert. We can fail here, since\n+            \/\/ dependency checking is never done in a product build.\n+            tty->print_cr(\"Failed dependency:\");\n+            changes.print();\n+            nm->print();\n+            nm->print_dependencies_on(tty);\n+            assert(false, \"Should have been marked for deoptimization\");\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+#endif\n+\n@@ -1275,1 +1323,1 @@\n-    nmethod::check_all_dependencies(changes);\n+    check_live_nmethods_dependencies(changes);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2151,45 +2151,0 @@\n-\n-void nmethod::check_all_dependencies(DepChange& changes) {\n-  \/\/ Checked dependencies are allocated into this ResourceMark\n-  ResourceMark rm;\n-\n-  \/\/ Turn off dependency tracing while actually testing dependencies.\n-  NOT_PRODUCT( FlagSetting fs(Dependencies::_verify_in_progress, true));\n-\n-  typedef ResourceHashtable<DependencySignature, int, 11027,\n-                            AnyObj::RESOURCE_AREA, mtInternal,\n-                            &DependencySignature::hash,\n-                            &DependencySignature::equals> DepTable;\n-\n-  DepTable* table = new DepTable();\n-\n-  \/\/ Iterate over live nmethods and check dependencies of all nmethods that are not\n-  \/\/ marked for deoptimization. A particular dependency is only checked once.\n-  NMethodIterator iter(NMethodIterator::only_not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    \/\/ Only notify for live nmethods\n-    if (!nm->is_marked_for_deoptimization()) {\n-      for (Dependencies::DepStream deps(nm); deps.next(); ) {\n-        \/\/ Construct abstraction of a dependency.\n-        DependencySignature* current_sig = new DependencySignature(deps);\n-\n-        \/\/ Determine if dependency is already checked. table->put(...) returns\n-        \/\/ 'true' if the dependency is added (i.e., was not in the hashtable).\n-        if (table->put(*current_sig, 1)) {\n-          if (deps.check_dependency() != nullptr) {\n-            \/\/ Dependency checking failed. Print out information about the failed\n-            \/\/ dependency and finally fail with an assert. We can fail here, since\n-            \/\/ dependency checking is never done in a product build.\n-            tty->print_cr(\"Failed dependency:\");\n-            changes.print();\n-            nm->print();\n-            nm->print_dependencies_on(tty);\n-            assert(false, \"Should have been marked for deoptimization\");\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -680,4 +680,0 @@\n-  \/\/ tells if any of this method's dependencies have been invalidated\n-  \/\/ (this is expensive!)\n-  static void check_all_dependencies(DepChange& changes);\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}