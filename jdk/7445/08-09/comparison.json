{"files":[{"patch":"@@ -71,0 +71,2 @@\n+ * @see java.lang.module.ModuleDescriptor.Exports.Modifier\n+ * @see java.lang.module.ModuleDescriptor.Opens.Modifier\n@@ -239,2 +241,0 @@\n-    \/\/ For now, reuse ElementType rather than defining a separate\n-    \/\/ type.\n@@ -245,6 +245,0 @@\n-    private AccessFlag(Set<Location> locations) {\n-        this.mask = 0x0;\n-        this.sourceModifier = false;\n-        this.locations = locations;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -33,0 +33,4 @@\n+import java.util.Map;\n+import java.util.LinkedHashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -38,0 +42,1 @@\n+        testDisjoint();\n@@ -70,0 +75,53 @@\n+\n+    \/\/ Test that if access flags have a matching mask, their locations\n+    \/\/ are disjoint.\n+    private static void testDisjoint() {\n+        \/\/ First build the mask -> access flags map...\n+        Map<Integer, Set<AccessFlag>> maskToFlags = new LinkedHashMap<>();\n+\n+        for (var accessFlag : AccessFlag.values()) {\n+            Integer mask = accessFlag.mask();\n+            Set<AccessFlag> flags = maskToFlags.get(mask);\n+\n+            if (flags == null ) {\n+                flags = new HashSet<>();\n+                flags.add(accessFlag);\n+                maskToFlags.put(mask, flags);\n+            } else {\n+                flags.add(accessFlag);\n+            }\n+        }\n+\n+        \/\/ Then test for disjointness\n+        for (var entry : maskToFlags.entrySet()) {\n+            var value = entry.getValue();\n+            if (value.size() == 0) {\n+                throw new AssertionError(\"Bad flag set \" + entry);\n+            } else if (value.size() == 1) {\n+                \/\/ Need at least two flags to be non-disjointness to\n+                \/\/ be possible\n+                continue;\n+            }\n+\n+            Set<AccessFlag.Location> locations = new HashSet<>();\n+            for (var accessFlag : value) {\n+                for (var location : accessFlag.locations()) {\n+                    boolean added = locations.add(location);\n+                    if (!added) {\n+                        reportError(location, accessFlag,\n+                                    entry.getKey(), value);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void reportError(AccessFlag.Location location,\n+                                    AccessFlag accessFlag,\n+                                    Integer mask, Set<AccessFlag> value) {\n+        System.err.println(\"Location \" + location +\n+                           \" from \" + accessFlag +\n+                           \" already present for 0x\" +\n+                           Integer.toHexString(mask) + \": \" + value);\n+        throw new RuntimeException();\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"}]}