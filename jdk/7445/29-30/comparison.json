{"files":[{"patch":"@@ -27,1 +27,3 @@\n- * @summary Test expected AccessFlag's on methods\n+ * @summary Test expected AccessFlag's on methods and parameters\n+ * @compile -parameters MethodAccessFlagTest.java\n+ * @run main MethodAccessFlagTest\n@@ -30,0 +32,3 @@\n+\/\/ Use -parameters flag to javac to have access flag information about\n+\/\/ parameters preserved in the resulting class file.\n+\n@@ -38,1 +43,1 @@\n- * At a source level, constructors can be modifiers as public,\n+ * At a source level, constructors can have modifiers public,\n@@ -43,0 +48,2 @@\n+ *\n+ * Method parameters can be final, synthetic, and mandated.\n@@ -56,0 +63,73 @@\n+\n+        \/\/ Hard-code information about parameter modifiers; could be\n+        \/\/ represented as annotations on the class and decoded.\n+        for (var ctor : NestedClass.class.getConstructors()) {\n+            for (var parameter : ctor.getParameters()) {\n+                String expected = null;\n+                if (parameter.getType() == int.class) {\n+                    \/\/ The explicit int parameter is expected to have\n+                    \/\/ the final flag\n+                    expected = \"[FINAL]\";\n+                } else {\n+                    \/\/ The implicit this$0 parameter is expected to have the\n+                    \/\/ final and mandated flags\n+                    expected = \"[FINAL, MANDATED]\";\n+                }\n+                checkString(parameter.toString(),\n+                            parameter.accessFlags().toString(),\n+                            expected);\n+            }\n+        }\n+\n+        for (var method : BridgeExample.class.getDeclaredMethods()) {\n+            \/\/ Find the two \"clone\" methods, one implicit and one\n+            \/\/ explicit\n+            if (!method.getName().equals(\"clone\")) {\n+                throw new RuntimeException(\"Unexpected name for \" + method);\n+            }\n+            String expected = null;\n+            if (method.getReturnType() == Object.class) {\n+                expected = \"[PUBLIC, BRIDGE, SYNTHETIC]\";\n+            } else {\n+                expected = \"[PUBLIC]\";\n+            }\n+            checkString(method.toString(),\n+                        method.accessFlags().toString(),\n+                        expected);\n+        }\n+\n+        \/\/ Hard-code information about parameter modifiers; could be\n+        \/\/ represented as annotations on the class and decoded.\n+        for (var ctor : TestEnum.class.getDeclaredConstructors()) {\n+            \/\/ Each of the two parameters used in javac's enum\n+            \/\/ constructor implementation is synthetic. This may need\n+            \/\/ to be updated if javac's enum constructor generation\n+            \/\/ idiom changes.\n+            for (var parameter : ctor.getParameters()) {\n+                checkString(parameter.toString(),\n+                            parameter.accessFlags().toString(),\n+                            \"[SYNTHETIC]\");\n+            }\n+        }\n+\n+    }\n+\n+    class NestedClass {\n+        private int i;\n+        \/\/ Implicit leading parameter\n+        public NestedClass(final int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    class BridgeExample implements Cloneable {\n+        public BridgeExample(){}\n+        \/\/ Triggers generation of a bridge method.\n+        public BridgeExample clone() {\n+            return new BridgeExample();\n+        }\n+    }\n+\n+    \/\/ Use as a host for a constructor with synthetic parameters\n+    enum TestEnum {\n+        INSTANCE;\n@@ -63,5 +143,11 @@\n-            if (!emf.value().equals(actual)) {\n-                throw new RuntimeException(\"On \" + method +\n-                                           \" expected \" + emf.value() +\n-                                           \" got \" + actual);\n-            }\n+            checkString(method.toString(), emf.value(), actual);\n+        }\n+    }\n+\n+    private static void checkString(String declaration,\n+                               String expected,\n+                               String actual) {\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"On \" + declaration +\n+                                       \" expected \" + expected +\n+                                       \" got \" + actual);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/MethodAccessFlagTest.java","additions":93,"deletions":7,"binary":false,"changes":100,"status":"modified"}]}