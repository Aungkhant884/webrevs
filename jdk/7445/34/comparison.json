{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -1315,0 +1316,1 @@\n+     * @see #accessFlags()\n@@ -1325,0 +1327,33 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag access\n+     * flags} for this class, possibly empty}\n+     *\n+     * <p> If the underlying class is an array class, then its\n+     * {@code PUBLIC}, {@code PRIVATE} and {@code PROTECTED}\n+     * access flags are the same as those of its component type.  If this\n+     * {@code Class} object represents a primitive type or void, the\n+     * {@code PUBLIC} access flag is present, and the\n+     * {@code PROTECTED} and {@code PRIVATE} access flags are always\n+     * absent. If this {@code Class} object represents an array class, a\n+     * primitive type or void, then the {@code FINAL} access flag is always\n+     * present and the interface access flag is always\n+     * absent. The values of its other access flags are not determined\n+     * by this specification.\n+     *\n+     * @see #getModifiers()\n+     * @jvms 4.1 The ClassFile Structure\n+     * @jvms 4.7.6 The InnerClasses Attribute\n+     * @since 20\n+     *\/\n+    public Set<AccessFlag> accessFlags() {\n+        \/\/ This likely needs some refinement. Exploration of hidden\n+        \/\/ classes, array classes.  Location.CLASS allows SUPER and\n+        \/\/ AccessFlag.MODULE which INNER_CLASS forbids. INNER_CLASS\n+        \/\/ allows PRIVATE, PROTECTED, and STATIC, which are not\n+        \/\/ allowed on Location.CLASS.\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                                            (isMemberClass() || isLocalClass() ||\n+                                             isAnonymousClass() || isArray()) ?\n+                                            AccessFlag.Location.INNER_CLASS :\n+                                            AccessFlag.Location.CLASS);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -108,1 +109,1 @@\n-        OPEN,\n+        OPEN(AccessFlag.OPEN.mask()),\n@@ -117,1 +118,1 @@\n-        AUTOMATIC,\n+        AUTOMATIC(0 \/* no flag per above comment *\/),\n@@ -122,1 +123,1 @@\n-        SYNTHETIC,\n+        SYNTHETIC(AccessFlag.SYNTHETIC.mask()),\n@@ -127,2 +128,1 @@\n-        MANDATED;\n-    }\n+        MANDATED(AccessFlag.MANDATED.mask());\n@@ -130,0 +130,6 @@\n+        private final int mask;\n+        private Modifier(int mask) {\n+            this.mask = mask;\n+        }\n+        private int mask() {return mask;}\n+    }\n@@ -155,1 +161,1 @@\n-            TRANSITIVE,\n+            TRANSITIVE(AccessFlag.TRANSITIVE.mask()),\n@@ -161,1 +167,1 @@\n-            STATIC,\n+            STATIC(AccessFlag.STATIC_PHASE.mask()),\n@@ -167,1 +173,1 @@\n-            SYNTHETIC,\n+            SYNTHETIC(AccessFlag.SYNTHETIC.mask()),\n@@ -173,2 +179,6 @@\n-            MANDATED;\n-\n+            MANDATED(AccessFlag.MANDATED.mask());\n+            private final int mask;\n+            private Modifier(int mask) {\n+                this.mask = mask;\n+            }\n+            private int mask() {return mask;}\n@@ -176,1 +186,0 @@\n-\n@@ -206,0 +215,15 @@\n+        \/**\n+         * {@return an unmodifiable set of the module {@linkplain AccessFlag\n+         * requires flags, possibly empty}}\n+         * @see #modifiers()\n+         * @jvms 4.7.25 The Module Attribute\n+         * @since 20\n+         *\/\n+        public Set<AccessFlag> accessFlags() {\n+            int mask = 0;\n+            for (var modifier : mods) {\n+                mask |= modifier.mask();\n+            }\n+            return AccessFlag.maskToAccessFlags(mask, AccessFlag.Location.MODULE_REQUIRES);\n+        }\n+\n@@ -379,1 +403,1 @@\n-            SYNTHETIC,\n+            SYNTHETIC(AccessFlag.SYNTHETIC.mask()),\n@@ -385,1 +409,1 @@\n-            MANDATED;\n+            MANDATED(AccessFlag.MANDATED.mask());\n@@ -387,0 +411,5 @@\n+            private final int mask;\n+            private Modifier(int mask) {\n+                this.mask = mask;\n+            }\n+            private int mask() {return mask;}\n@@ -420,0 +449,15 @@\n+        \/**\n+         * {@return an unmodifiable set of the module {@linkplain AccessFlag\n+         * export flags} for this module descriptor, possibly empty}\n+         * @see #modifiers()\n+         * @jvms 4.7.25 The Module Attribute\n+         * @since 20\n+         *\/\n+        public Set<AccessFlag> accessFlags() {\n+            int mask = 0;\n+            for (var modifier : mods) {\n+                mask |= modifier.mask();\n+            }\n+            return AccessFlag.maskToAccessFlags(mask, AccessFlag.Location.MODULE_EXPORTS);\n+        }\n+\n@@ -582,1 +626,1 @@\n-            SYNTHETIC,\n+            SYNTHETIC(AccessFlag.SYNTHETIC.mask()),\n@@ -588,2 +632,6 @@\n-            MANDATED;\n-\n+            MANDATED(AccessFlag.MANDATED.mask());\n+            private final int mask;\n+            private Modifier(int mask) {\n+                this.mask = mask;\n+            }\n+            private int mask() {return mask;}\n@@ -623,0 +671,15 @@\n+        \/**\n+         * {@return an unmodifiable set of the module {@linkplain AccessFlag\n+         * opens flags}, possibly empty}\n+         * @see #modifiers()\n+         * @jvms 4.7.25 The Module Attribute\n+         * @since 20\n+         *\/\n+        public Set<AccessFlag> accessFlags() {\n+            int mask = 0;\n+            for (var modifier : mods) {\n+                mask |= modifier.mask();\n+            }\n+            return AccessFlag.maskToAccessFlags(mask, AccessFlag.Location.MODULE_OPENS);\n+        }\n+\n@@ -1293,0 +1356,15 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * module flags}, possibly empty}\n+     * @see #modifiers()\n+     * @jvms 4.7.25 The Module Attribute\n+     * @since 20\n+     *\/\n+    public Set<AccessFlag> accessFlags() {\n+        int mask = 0;\n+        for (var modifier : modifiers) {\n+            mask |= modifier.mask();\n+        }\n+        return AccessFlag.maskToAccessFlags(mask, AccessFlag.Location.MODULE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":94,"deletions":16,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -0,0 +1,447 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import static java.util.Map.entry;\n+\n+\/**\n+ * Represents a JVM access or module-related flag on a runtime member,\n+ * such as a {@linkplain Class class}, {@linkplain Field field}, or\n+ * {@linkplain Executable method}.\n+ *\n+ * <P>JVM access and module-related flags are related to, but distinct\n+ * from Java language {@linkplain Modifier modifiers}. Some modifiers\n+ * and access flags have a one-to-one correspondence, such as {@code\n+ * public}. In other cases, some language-level modifiers do\n+ * <em>not<\/em> have an access flag, such as {@code sealed} (JVMS\n+ * {@jvms 4.7.31}) and some access flags have no corresponding\n+ * modifier, such as {@linkplain #SYNTHETIC synthetic}.\n+ *\n+ * <p>The values for the constants representing the access and module\n+ * flags are taken from sections of <cite>The Java Virtual Machine\n+ * Specification<\/cite> including {@jvms 4.1} (class access and\n+ * property modifiers), {@jvms 4.5} (field access and property flags),\n+ * {@jvms 4.6} (method access and property flags), {@jvms 4.7.6}\n+ * (nested class access and property flags), {@jvms 4.7.24} (method\n+ * parameters), and {@jvms 4.7.25} (module flags and requires,\n+ * exports, and opens flags).\n+ *\n+ * <p>The {@linkplain #mask() mask} values for the different access\n+ * flags are <em>not<\/em> distinct. Flags are defined for different\n+ * kinds of JVM structures and the same bit position has different\n+ * meanings in different contexts. For example, {@code 0x0000_0040}\n+ * indicates a {@link #VOLATILE volatile} field but a {@linkplain\n+ * #BRIDGE bridge method}; {@code 0x0000_0080} indicates a {@link\n+ * #TRANSIENT transient} field but a {@linkplain #VARARGS variable\n+ * arity (varargs)} method.\n+ *\n+ * @implSpec\n+ * The access flag constants are ordered by non-decreasing mask\n+ * value; that is the mask value of a constant is greater than or\n+ * equal to the mask value of an immediate neighbor to its (syntactic)\n+ * left. If new constants are added, this property will be\n+ * maintained. That implies new constants will not necessarily be\n+ * added at the end of the existing list.\n+ *\n+ * @apiNote\n+ * The JVM class file format has a new version defined for each new\n+ * {@linkplain Runtime.Version#feature() feature release}. A new class\n+ * file version may define new access flags or retire old ones. {@code\n+ * AccessFlag} is intended to model the set of access flags across\n+ * class file format versions. The range of versions an access flag is\n+ * recognized is not explicitly indicated in this API. See the current\n+ * <cite>The Java Virtual Machine Specification<\/cite> for\n+ * details. Unless otherwise indicated, access flags can be assumed to\n+ * be recognized in the {@linkplain Runtime#version() current\n+ * version}.\n+ *\n+ * @see java.lang.reflect.Modifier\n+ * @see java.lang.module.ModuleDescriptor.Modifier\n+ * @see java.lang.module.ModuleDescriptor.Requires.Modifier\n+ * @see java.lang.module.ModuleDescriptor.Exports.Modifier\n+ * @see java.lang.module.ModuleDescriptor.Opens.Modifier\n+ * @see java.compiler\/javax.lang.model.element.Modifier\n+ * @since 20\n+ *\/\n+@SuppressWarnings(\"doclint:reference\") \/\/ cross-module link\n+public enum AccessFlag {\n+    \/**\n+     * The access flag {@code ACC_PUBLIC}, corresponding to the source\n+     * modifier {@link Modifier#PUBLIC public} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#PUBLIC}<\/code>.\n+     *\/\n+    PUBLIC(Modifier.PUBLIC, true,\n+           Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n+                  Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_PRIVATE}, corresponding to the\n+     * source modifier {@link Modifier#PRIVATE private} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#PRIVATE}<\/code>.\n+     *\/\n+    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+\n+    \/**\n+     * The access flag {@code ACC_PROTECTED}, corresponding to the\n+     * source modifier {@link Modifier#PROTECTED protected} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#PROTECTED}<\/code>.\n+     *\/\n+    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+\n+    \/**\n+     * The access flag {@code ACC_STATIC}, corresponding to the source\n+     * modifier {@link Modifier#STATIC static} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#STATIC}<\/code>.\n+     *\/\n+    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+\n+    \/**\n+     * The access flag {@code ACC_FINAL}, corresponding to the source\n+     * modifier {@link Modifier#FINAL final} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#FINAL}<\/code>.\n+     *\/\n+    FINAL(Modifier.FINAL, true,\n+          Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n+                 Location.INNER_CLASS, Location.METHOD_PARAMETER)),\n+\n+    \/**\n+     * The access flag {@code ACC_SUPER} with a mask value of {@code\n+     * 0x0020}.\n+     *\n+     * @apiNote\n+     * In Java SE 8 and above, the JVM treats the {@code ACC_SUPER}\n+     * flag as set in every class file (JVMS {@jvms 4.1}).\n+     *\/\n+    SUPER(0x0000_0020, false, Location.SET_CLASS),\n+\n+    \/**\n+     * The module flag {@code ACC_OPEN} with a mask value of {@code\n+     * 0x0020}.\n+     * @see java.lang.module.ModuleDescriptor#isOpen\n+     *\/\n+    OPEN(0x0000_0020, false, Set.of(Location.MODULE)),\n+\n+    \/**\n+     * The module requires flag {@code ACC_TRANSITIVE} with a mask\n+     * value of {@code 0x0020}.\n+     * @see java.lang.module.ModuleDescriptor.Requires.Modifier#TRANSITIVE\n+     *\/\n+    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES),\n+\n+    \/**\n+     * The access flag {@code ACC_SYNCHRONIZED}, corresponding to the\n+     * source modifier {@link Modifier#SYNCHRONIZED synchronized} with\n+     * a mask value of <code>{@value \"0x%04x\" Modifier#SYNCHRONIZED}<\/code>.\n+     *\/\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD),\n+\n+    \/**\n+     * The module requires flag {@code ACC_STATIC_PHASE} with a mask\n+     * value of {@code 0x0040}.\n+     * @see java.lang.module.ModuleDescriptor.Requires.Modifier#STATIC\n+     *\/\n+    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES),\n+\n+     \/**\n+      * The access flag {@code ACC_VOLATILE}, corresponding to the\n+      * source modifier {@link Modifier#VOLATILE volatile} with a mask\n+      * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n+      *\/\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD),\n+\n+    \/**\n+     * The access flag {@code ACC_BRIDGE} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#BRIDGE}<\/code>\n+     * @see Method#isBridge()\n+     *\/\n+    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD),\n+\n+    \/**\n+     * The access flag {@code ACC_TRANSIENT}, corresponding to the\n+     * source modifier {@link Modifier#TRANSIENT transient} with a\n+     * mask value of <code>{@value \"0x%04x\" Modifier#TRANSIENT}<\/code>.\n+     *\/\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD),\n+\n+    \/**\n+     * The access flag {@code ACC_VARARGS} with a mask value of\n+     <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n+     * @see Executable#isVarArgs()\n+     *\/\n+    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD),\n+\n+    \/**\n+     * The access flag {@code ACC_NATIVE}, corresponding to the source\n+     * modifier {@link Modifier#NATIVE native} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#NATIVE}<\/code>.\n+     *\/\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD),\n+\n+    \/**\n+     * The access flag {@code ACC_INTERFACE} with a mask value of\n+     * {@code 0x0200}.\n+     * @see Class#isInterface()\n+     *\/\n+    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS),\n+\n+    \/**\n+     * The access flag {@code ACC_ABSTRACT}, corresponding to the\n+     * source modifier {@link Modifier#ABSTRACT abstract} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#ABSTRACT}<\/code>.\n+     *\/\n+    ABSTRACT(Modifier.ABSTRACT, true,\n+             Set.of(Location.CLASS, Location.METHOD, Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_STRICT}, corresponding to the source\n+     * modifier {@link Modifier#STRICT strictfp} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#STRICT}<\/code>.\n+     *\n+     * @apiNote\n+     * The {@code ACC_STRICT} access flag is defined for class file\n+     * major versions 46 through 60, inclusive (JVMS {@jvms 4.6}),\n+     * corresponding to Java SE 1.2 through 16.\n+     *\/\n+    STRICT(Modifier.STRICT, true, Location.SET_METHOD),\n+\n+    \/**\n+     * The access flag {@code ACC_SYNTHETIC} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#SYNTHETIC}<\/code>.\n+     * @see Class#isSynthetic()\n+     * @see Executable#isSynthetic()\n+     * @see java.lang.module.ModuleDescriptor.Modifier#SYNTHETIC\n+     *\/\n+    SYNTHETIC(Modifier.SYNTHETIC, false,\n+              Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n+                     Location.INNER_CLASS, Location.METHOD_PARAMETER,\n+                     Location.MODULE, Location.MODULE_REQUIRES,\n+                     Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+\n+    \/**\n+     * The access flag {@code ACC_ANNOTATION} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#ANNOTATION}<\/code>.\n+     * @see Class#isAnnotation()\n+     *\/\n+    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS),\n+\n+    \/**\n+     * The access flag {@code ACC_ENUM} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#ENUM}<\/code>.\n+     * @see Class#isEnum()\n+     *\/\n+    ENUM(Modifier.ENUM, false,\n+         Set.of(Location.CLASS, Location.FIELD, Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_MANDATED} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#MANDATED}<\/code>.\n+     *\/\n+    MANDATED(Modifier.MANDATED, false,\n+             Set.of(Location.METHOD_PARAMETER,\n+                    Location.MODULE, Location.MODULE_REQUIRES,\n+                    Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+\n+    \/**\n+     * The access flag {@code ACC_MODULE} with a mask value of {@code\n+     * 0x8000}.\n+     *\/\n+    MODULE(0x0000_8000, false, Location.SET_CLASS)\n+    ;\n+\n+    \/\/ May want to override toString for a different enum constant ->\n+    \/\/ name mapping.\n+\n+    private final int mask;\n+    private final boolean sourceModifier;\n+\n+    \/\/ Intentionally using Set rather than EnumSet since EnumSet is\n+    \/\/ mutable.\n+    private final Set<Location> locations;\n+\n+    private AccessFlag(int mask, boolean sourceModifier, Set<Location> locations) {\n+        this.mask = mask;\n+        this.sourceModifier = sourceModifier;\n+        this.locations = locations;\n+    }\n+\n+    \/**\n+     * {@return the corresponding integer mask for the access flag}\n+     *\/\n+    public int mask() {\n+        return mask;\n+    }\n+\n+    \/**\n+     * {@return whether or not the flag has a directly corresponding\n+     * modifier in the Java programming language}\n+     *\/\n+    public boolean sourceModifier() {\n+        return sourceModifier;\n+    }\n+\n+    \/**\n+     * {@return kinds of constructs the flag can be applied to}\n+     *\/\n+    public Set<Location> locations() {\n+        return locations;\n+    }\n+\n+    \/**\n+     * {@return an unmodifiable set of access flags for the given mask value\n+     * appropriate for the location in question}\n+     *\n+     * @param mask bit mask of access flags\n+     * @param location context to interpret mask value\n+     * @throws IllegalArgumentException if the mask contains bit\n+     * positions not support for the location in question\n+     *\/\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location) {\n+        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n+        for (var accessFlag : LocationToFlags.locationToFlags.get(location)) {\n+            int accessMask = accessFlag.mask();\n+            if ((mask &  accessMask) != 0) {\n+                result.add(accessFlag);\n+                mask = mask & ~accessMask;\n+            }\n+        }\n+        if (mask != 0) {\n+            throw new IllegalArgumentException(\"Unmatched bit position 0x\" +\n+                                               Integer.toHexString(mask) +\n+                                               \" for location \" + location);\n+        }\n+        return Collections.unmodifiableSet(result);\n+    }\n+\n+    \/**\n+     * A location within a class file where flags can be applied.\n+     *\n+     * Note that since these locations represent class file structures\n+     * rather than language structures many language structures, such\n+     * as constructors and interfaces, are <em>not<\/em> present.\n+     * @since 20\n+     *\/\n+    public enum Location {\n+        \/**\n+         * Class location.\n+         * @jvms 4.1 The ClassFile Structure\n+         *\/\n+        CLASS,\n+\n+        \/**\n+         * Field location.\n+         * @jvms 4.5 Fields\n+         *\/\n+        FIELD,\n+\n+        \/**\n+         * Method location.\n+         * @jvms 4.6 Method\n+         *\/\n+        METHOD,\n+\n+        \/**\n+         * Inner class location.\n+         * @jvms 4.7.6 The InnerClasses Attribute\n+         *\/\n+        INNER_CLASS,\n+\n+        \/**\n+         * Method parameter loccation.\n+         * @jvms 4.7.24. The MethodParameters Attribute\n+         *\/\n+        METHOD_PARAMETER,\n+\n+        \/**\n+         * Module location\n+         * @jvms 4.7.25. The Module Attribute\n+         *\/\n+        MODULE,\n+\n+        \/**\n+         * Module requires location\n+         * @jvms 4.7.25. The Module Attribute\n+         *\/\n+        MODULE_REQUIRES,\n+\n+        \/**\n+         * Module exports location\n+         * @jvms 4.7.25. The Module Attribute\n+         *\/\n+        MODULE_EXPORTS,\n+\n+        \/**\n+         * Module opens location\n+         * @jvms 4.7.25. The Module Attribute\n+         *\/\n+        MODULE_OPENS;\n+\n+        \/\/ Repeated sets of locations used by AccessFlag constants\n+        private static final Set<Location> SET_FIELD_METHOD_INNER_CLASS =\n+            Set.of(FIELD, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_METHOD = Set.of(METHOD);\n+        private static final Set<Location> SET_FIELD = Set.of(FIELD);\n+        private static final Set<Location> SET_CLASS = Set.of(CLASS);\n+        private static final Set<Location> SET_CLASS_INNER_CLASS =\n+            Set.of(CLASS, INNER_CLASS);\n+        private static final Set<Location> SET_MODULE_REQUIRES =\n+            Set.of(MODULE_REQUIRES);\n+    }\n+\n+    private static class LocationToFlags {\n+        private static Map<Location, Set<AccessFlag>> locationToFlags =\n+            Map.ofEntries(entry(Location.CLASS,\n+                                Set.of(PUBLIC, FINAL, SUPER,\n+                                       INTERFACE, ABSTRACT,\n+                                       SYNTHETIC, ANNOTATION,\n+                                       ENUM, AccessFlag.MODULE)),\n+                          entry(Location.FIELD,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                       STATIC, FINAL, VOLATILE,\n+                                       TRANSIENT, SYNTHETIC, ENUM)),\n+                          entry(Location.METHOD,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                       STATIC, FINAL, SYNCHRONIZED,\n+                                       BRIDGE, VARARGS, NATIVE,\n+                                       ABSTRACT, STRICT, SYNTHETIC)),\n+                          entry(Location.INNER_CLASS,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                       STATIC, FINAL, INTERFACE, ABSTRACT,\n+                                       SYNTHETIC, ANNOTATION, ENUM)),\n+                          entry(Location.METHOD_PARAMETER,\n+                                Set.of(FINAL, SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE,\n+                                Set.of(OPEN, SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE_REQUIRES,\n+                                Set.of(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE_EXPORTS,\n+                                Set.of(SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE_OPENS,\n+                                Set.of(SYNTHETIC, MANDATED)));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":447,"deletions":0,"binary":false,"changes":447,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Set;\n@@ -207,0 +208,1 @@\n+     * @see #accessFlags\n@@ -210,0 +212,15 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * access flags} for the executable represented by this object,\n+     * possibly empty}\n+     *\n+     * @see #getModifiers()\n+     * @jvms 4.6 Methods\n+     * @since 20\n+     *\/\n+    @Override\n+    public Set<AccessFlag> accessFlags() {\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                                            AccessFlag.Location.METHOD);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Set;\n@@ -205,0 +206,1 @@\n+     * @see #accessFlags()\n@@ -212,0 +214,12 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * access flags} for this field, possibly empty}\n+     * @see #getModifiers()\n+     * @jvms 4.5 Fields\n+     * @since 20\n+     *\/\n+    @Override\n+    public Set<AccessFlag> accessFlags() {\n+        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Set;\n+\n@@ -79,0 +81,1 @@\n+     * @see #accessFlags()\n@@ -82,0 +85,15 @@\n+\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * access flags} for this member, possibly empty}\n+     *\n+     * @implSpec\n+     * The default implementation throws {@link\n+     * UnsupportedOperationException}.\n+     * @see #getModifiers()\n+     * @since 20\n+     *\/\n+    public default Set<AccessFlag> accessFlags() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Member.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -257,0 +257,1 @@\n+     * @see AccessFlag#PUBLIC\n@@ -263,0 +264,1 @@\n+     * @see AccessFlag#PRIVATE\n@@ -269,0 +271,1 @@\n+     * @see AccessFlag#PROTECTED\n@@ -275,0 +278,1 @@\n+     * @see AccessFlag#STATIC\n@@ -281,0 +285,1 @@\n+     * @see AccessFlag#FINAL\n@@ -287,0 +292,1 @@\n+     * @see AccessFlag#SYNCHRONIZED\n@@ -293,0 +299,1 @@\n+     * @see AccessFlag#VOLATILE\n@@ -299,0 +306,1 @@\n+     * @see AccessFlag#TRANSIENT\n@@ -305,0 +313,1 @@\n+     * @see AccessFlag#NATIVE\n@@ -311,0 +320,1 @@\n+     * @see AccessFlag#INTERFACE\n@@ -317,0 +327,1 @@\n+     * @see AccessFlag#ABSTRACT\n@@ -323,0 +334,1 @@\n+     * @see AccessFlag#STRICT\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Set;\n@@ -164,0 +165,14 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * access flags} for the parameter represented by this object,\n+     * possibly empty}\n+     *\n+     * @see #getModifiers()\n+     * @jvms 4.7.24 The MethodParameters Attribute\n+     * @since 20\n+     *\/\n+    public Set<AccessFlag> accessFlags() {\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                                            AccessFlag.Location.METHOD_PARAMETER);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Parameter.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Basic tests of AccessFlag\n+ *\/\n+\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.EnumSet;\n+import java.util.Map;\n+import java.util.LinkedHashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class BasicAccessFlagTest {\n+    public static void main(String... args) throws Exception {\n+        testSourceModifiers();\n+        testMaskOrdering();\n+        testDisjoint();\n+        testMaskToAccessFlagsPositive();\n+    }\n+\n+    \/*\n+     * Verify sourceModifier() == true access flags have a\n+     * corresponding constant in java.lang.reflect.Modifier.\n+     *\/\n+    private static void testSourceModifiers() throws Exception {\n+        Class<?> modifierClass = Modifier.class;\n+\n+        for(AccessFlag accessFlag : AccessFlag.values()) {\n+            if (accessFlag.sourceModifier()) {\n+                \/\/ Check for consistency\n+                Field f = modifierClass.getField(accessFlag.name());\n+                if (accessFlag.mask() != f.getInt(null) ) {\n+                    throw new RuntimeException(\"Unexpected mask for \" +\n+                                               accessFlag);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ The mask values of the enum constants must be non-decreasing;\n+    \/\/ in other words stay the same (for colliding mask values) or go\n+    \/\/ up.\n+    private static void testMaskOrdering() {\n+        AccessFlag[] values = AccessFlag.values();\n+        for (int i = 1; i < values.length; i++) {\n+            AccessFlag left  = values[i-1];\n+            AccessFlag right = values[i];\n+            if (left.mask() > right.mask()) {\n+                throw new RuntimeException(left\n+                                           + \"has a greater mask than \"\n+                                           + right);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that if access flags have a matching mask, their locations\n+    \/\/ are disjoint.\n+    private static void testDisjoint() {\n+        \/\/ First build the mask -> access flags map...\n+        Map<Integer, Set<AccessFlag>> maskToFlags = new LinkedHashMap<>();\n+\n+        for (var accessFlag : AccessFlag.values()) {\n+            Integer mask = accessFlag.mask();\n+            Set<AccessFlag> flags = maskToFlags.get(mask);\n+\n+            if (flags == null ) {\n+                flags = new HashSet<>();\n+                flags.add(accessFlag);\n+                maskToFlags.put(mask, flags);\n+            } else {\n+                flags.add(accessFlag);\n+            }\n+        }\n+\n+        \/\/ ...then test for disjointness\n+        for (var entry : maskToFlags.entrySet()) {\n+            var value = entry.getValue();\n+            if (value.size() == 0) {\n+                throw new AssertionError(\"Bad flag set \" + entry);\n+            } else if (value.size() == 1) {\n+                \/\/ Need at least two flags to be non-disjointness to\n+                \/\/ be possible\n+                continue;\n+            }\n+\n+            Set<AccessFlag.Location> locations = new HashSet<>();\n+            for (var accessFlag : value) {\n+                for (var location : accessFlag.locations()) {\n+                    boolean added = locations.add(location);\n+                    if (!added) {\n+                        reportError(location, accessFlag,\n+                                    entry.getKey(), value);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void reportError(AccessFlag.Location location,\n+                                    AccessFlag accessFlag,\n+                                    Integer mask, Set<AccessFlag> value) {\n+        System.err.println(\"Location \" + location +\n+                           \" from \" + accessFlag +\n+                           \" already present for 0x\" +\n+                           Integer.toHexString(mask) + \": \" + value);\n+        throw new RuntimeException();\n+    }\n+\n+    \/\/ For each access flag, make sure it is recognized on every kind\n+    \/\/ of location it can apply to\n+    private static void testMaskToAccessFlagsPositive() {\n+        for (var accessFlag : AccessFlag.values()) {\n+            Set<AccessFlag> expectedSet = EnumSet.of(accessFlag);\n+            for (var location : accessFlag.locations()) {\n+                Set<AccessFlag> computedSet =\n+                    AccessFlag.maskToAccessFlags(accessFlag.mask(), location);\n+                if (!expectedSet.equals(computedSet)) {\n+                    throw new RuntimeException(\"Bad set computation on \" +\n+                                               accessFlag + \", \" + location);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on classes.\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+\/*\n+ * Class access flags that can directly or indirectly declared in\n+ * source include:\n+ * public, private, protected, static, final, interface, abstract,\n+ * annotation, enum.\n+ *\n+ * Additionally, the access flags super and synthetic cannot be\n+ * explicitly applied.\n+ *\n+ * This test is written on top of the facilities of core reflection.\n+ *\n+ * Note that core reflection does not offer a supported mechanism to\n+ * return the Class object created from a module-info.class\n+ * file. Therefore, this test does not attempt to probe the setting of\n+ * that access flag.\n+ *\n+ * For a class, the VM must treat the class as if the ACC_SUPER bit\n+ * were set, but that bit is cleared by HotSpot when it is passed out\n+ * to the core reflection libraries. Therefore, this test does not\n+ * attempt to check whether or not AccessFlag.SUPER is set.\n+ *\/\n+@ExpectedClassFlags(\"[PUBLIC, FINAL]\")\n+public final class ClassAccessFlagTest {\n+    public static void main(String... args) {\n+        \/\/ Top-level and axuillary classes; i.e. non-inner classes\n+        Class<?>[] testClasses = {\n+            ClassAccessFlagTest.class,\n+            TestInterface.class,\n+            ExpectedClassFlags.class,\n+            TestOuterEnum.class\n+        };\n+        checkClasses(testClasses);\n+\n+        \/\/ Nested classes of ClassAccessFlagTest\n+        checkClasses(ClassAccessFlagTest.class.getDeclaredClasses());\n+\n+        checkPrimitives();\n+        checkArrays();\n+    }\n+\n+    private static void checkClasses(Class<?>[] classes) {\n+        for (var clazz : classes) {\n+            checkClass(clazz);\n+        }\n+    }\n+\n+    private static void checkClass(Class<?> clazz) {\n+        ExpectedClassFlags expected =\n+            clazz.getAnnotation(ExpectedClassFlags.class);\n+        if (expected != null) {\n+            String actual = clazz.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + clazz +\n+                                           \" expected \" + expected.value() +\n+                                           \" got \" + actual);\n+            }\n+        }\n+    }\n+\n+    private static void checkPrimitives() {\n+        final Class<?>[] primitives = {\n+            byte.class,\n+            int.class,\n+            long.class,\n+            short.class,\n+            char.class,\n+            float.class,\n+            double.class,\n+            boolean.class,\n+            void.class \/\/ same access flag rules\n+        };\n+\n+        var mustBePresent = Set.of(AccessFlag.PUBLIC, AccessFlag.FINAL);\n+        var mustBeAbsent = Set.of(AccessFlag.PRIVATE,\n+                                  AccessFlag.PROTECTED,\n+                                  AccessFlag.INTERFACE);\n+\n+        for(var primClass : primitives) {\n+            \/\/ PUBLIC must be present, PROTECTED and PRIVATE must be\n+            \/\/ absent.\n+            \/\/ FINAL must be present, INTERFACE must be absent.\n+            var accessFlags = primClass.accessFlags();\n+            if (!accessFlags.containsAll(mustBePresent)) {\n+                throw new RuntimeException(\"Missing mandatory flags on \" +\n+                                           primClass);\n+            }\n+\n+            if (containsAny(accessFlags, mustBeAbsent)) {\n+                throw new RuntimeException(\"Unexpected flags present on \" +\n+                                           primClass);\n+            }\n+        }\n+    }\n+\n+    private static boolean containsAny(Set<AccessFlag> input,\n+                                       Set<AccessFlag> test) {\n+        var copy = new HashSet<>(input);\n+        return copy.removeAll(test);\n+    }\n+\n+    private static void checkArrays() {\n+        Class<?>[] accessClasses = {\n+            PublicInterface.class,\n+            ProtectedInterface.class,\n+            PrivateInterface.class,\n+        };\n+\n+        for (var accessClass : accessClasses) {\n+            AccessFlag accessLevel;\n+            var flags = accessClass.accessFlags();\n+            if (flags.contains(AccessFlag.PUBLIC))\n+                accessLevel = AccessFlag.PUBLIC;\n+            else if (flags.contains(AccessFlag.PROTECTED))\n+                accessLevel = AccessFlag.PROTECTED;\n+            else if (flags.contains(AccessFlag.PRIVATE))\n+                accessLevel = AccessFlag.PRIVATE;\n+            else\n+                accessLevel = null;\n+\n+            var arrayClass = accessClass.arrayType();\n+            \/\/ Access modifier must match on the array type\n+            if (accessLevel != null) {\n+                if (!arrayClass.accessFlags().contains(accessLevel)) {\n+                    throw new RuntimeException(\"Mismatched access flags on \" +\n+                                               arrayClass);\n+                }\n+            } else {\n+                if (containsAny(arrayClass.accessFlags(),\n+                                Set.of(AccessFlag.PUBLIC,\n+                                       AccessFlag.PROTECTED,\n+                                       AccessFlag.PRIVATE))) {\n+                    throw new RuntimeException(\"Unexpected access flags on \" +\n+                                               arrayClass);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ inner classes and interfaces; possible flags on INNER_CLASS\n+    \/\/ locations:\n+    \/\/ PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, INTERFACE, ABSTRACT,\n+    \/\/ SYNTHETIC, ANNOTATION, ENUM.\n+\n+    @ExpectedClassFlags(\"[PUBLIC, STATIC, INTERFACE, ABSTRACT]\")\n+    public      interface PublicInterface {}\n+    @ExpectedClassFlags(\"[PROTECTED, STATIC, INTERFACE, ABSTRACT]\")\n+    protected   interface ProtectedInterface {}\n+    @ExpectedClassFlags(\"[PRIVATE, STATIC, INTERFACE, ABSTRACT]\")\n+    private     interface PrivateInterface {}\n+    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    \/*package*\/ interface PackageInterface {}\n+\n+    @ExpectedClassFlags(\"[FINAL]\")\n+    \/*package*\/ final class TestFinalClass {}\n+\n+    @ExpectedClassFlags(\"[ABSTRACT]\")\n+    \/*package*\/ abstract class TestAbstractClass {}\n+\n+    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT, ANNOTATION]\")\n+    \/*package*\/ @interface TestMarkerAnnotation {}\n+\n+    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+    public enum MetaSynVar {\n+        QUUX;\n+    }\n+\n+    \/\/ Is there is at least one special enum constant, the enum class\n+    \/\/ itself is implicitly abstract rather than final.\n+    @ExpectedClassFlags(\"[PROTECTED, STATIC, ABSTRACT, ENUM]\")\n+    protected enum MetaSynVar2 {\n+        WOMBAT{\n+            @Override\n+            public int foo() {return 42;}\n+        };\n+        public abstract int foo();\n+    }\n+\n+    @ExpectedClassFlags(\"[PRIVATE, ABSTRACT]\")\n+    private abstract class Foo {}\n+\n+    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    interface StaticTestInterface {}\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@ExpectedClassFlags(\"[INTERFACE, ABSTRACT, ANNOTATION]\")\n+@interface ExpectedClassFlags {\n+    String value();\n+}\n+\n+@ExpectedClassFlags(\"[INTERFACE, ABSTRACT]\")\n+interface TestInterface {}\n+\n+\n+@ExpectedClassFlags(\"[FINAL, ENUM]\")\n+enum TestOuterEnum {\n+    INSTANCE;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on fields.\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+\/*\n+ * Field modifiers include:\n+ * public, private, protected, static, final, volatile, transient,\n+ *\n+ * Additionall, the access flags enum and synthetic cannot be\n+ * explicitly applied.\n+ *\/\n+public class FieldAccessFlagTest {\n+    public static void main(String... args) {\n+        for (var field :\n+                 FieldAccessFlagTest.class.getDeclaredFields()) {\n+            checkField(field);\n+        }\n+\n+        for (var field :\n+                 MetaSynVar.class.getDeclaredFields()) {\n+            checkField(field);\n+        }\n+    }\n+\n+    private static void checkField(Field field) {\n+        ExpectedFieldFlags expected =\n+            field.getAnnotation(ExpectedFieldFlags.class);\n+        if (expected != null) {\n+            String actual = field.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + field +\n+                                           \" expected \" + expected.value() +\n+                                           \" got \" + actual);\n+            }\n+        }\n+    }\n+\n+    \/\/ Fields\n+    @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL]\")\n+    public static final String f1 = \"foo\";\n+\n+    @ExpectedFieldFlags(\"[PRIVATE, VOLATILE, TRANSIENT]\")\n+    private volatile transient String secret = \"xxyzzy\";\n+\n+    @ExpectedFieldFlags(\"[PROTECTED]\")\n+    protected String meadow = \"\";\n+\n+    \/\/ Enum constant should have the enum access flag set\n+    static enum MetaSynVar {\n+        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        FOO,\n+\n+        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        BAR;\n+\n+        @ExpectedFieldFlags(\"[PRIVATE]\") \/\/ no \"ENUM\"\n+        private int field = 0;\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    private @interface ExpectedFieldFlags {\n+        String value();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/FieldAccessFlagTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on methods and parameters\n+ * @compile -parameters MethodAccessFlagTest.java\n+ * @run main MethodAccessFlagTest\n+ *\/\n+\n+\/\/ Use -parameters flag to javac to have access flag information about\n+\/\/ parameters preserved in the resulting class file.\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+\/*\n+ * Method modifiers include:\n+ * public, private, protected, static, final, synchronized,\n+ * bridge, varargs, native, abstract, strictfp, synthetic,\n+ *\n+ * At a source level, constructors can have modifiers public,\n+ * protected, or private.\n+ *\n+ * The modifiers bridge and synthetic cannot be applied directly and\n+ * strictfp can only be applied in older source versions.\n+ *\n+ * Method parameters can be final, synthetic, and mandated.\n+ *\/\n+public abstract class MethodAccessFlagTest {\n+    @ExpectedMethodFlags(\"[PUBLIC, STATIC, VARARGS]\")\n+    public static void main(String... args) {\n+        for (var ctor :\n+                 MethodAccessFlagTest.class.getDeclaredConstructors()) {\n+            checkExecutable(ctor);\n+        }\n+\n+        for (var method :\n+                 MethodAccessFlagTest.class.getDeclaredMethods()) {\n+            checkExecutable(method);\n+        }\n+\n+        \/\/ Hard-code information about parameter modifiers; could be\n+        \/\/ represented as annotations on the class and decoded.\n+        for (var ctor : NestedClass.class.getConstructors()) {\n+            for (var parameter : ctor.getParameters()) {\n+                String expected = null;\n+                if (parameter.getType() == int.class) {\n+                    \/\/ The explicit int parameter is expected to have\n+                    \/\/ the final flag\n+                    expected = \"[FINAL]\";\n+                } else {\n+                    \/\/ The implicit this$0 parameter is expected to have the\n+                    \/\/ final and mandated flags\n+                    expected = \"[FINAL, MANDATED]\";\n+                }\n+                checkString(parameter.toString(),\n+                            parameter.accessFlags().toString(),\n+                            expected);\n+            }\n+        }\n+\n+        for (var method : BridgeExample.class.getDeclaredMethods()) {\n+            \/\/ Find the two \"clone\" methods, one implicit and one\n+            \/\/ explicit\n+            if (!method.getName().equals(\"clone\")) {\n+                throw new RuntimeException(\"Unexpected name for \" + method);\n+            }\n+            String expected = null;\n+            if (method.getReturnType() == Object.class) {\n+                expected = \"[PUBLIC, BRIDGE, SYNTHETIC]\";\n+            } else {\n+                expected = \"[PUBLIC]\";\n+            }\n+            checkString(method.toString(),\n+                        method.accessFlags().toString(),\n+                        expected);\n+        }\n+\n+        \/\/ Hard-code information about parameter modifiers; could be\n+        \/\/ represented as annotations on the class and decoded.\n+        for (var ctor : TestEnum.class.getDeclaredConstructors()) {\n+            \/\/ Each of the two parameters used in javac's enum\n+            \/\/ constructor implementation is synthetic. This may need\n+            \/\/ to be updated if javac's enum constructor generation\n+            \/\/ idiom changes.\n+            for (var parameter : ctor.getParameters()) {\n+                checkString(parameter.toString(),\n+                            parameter.accessFlags().toString(),\n+                            \"[SYNTHETIC]\");\n+            }\n+        }\n+\n+    }\n+\n+    class NestedClass {\n+        private int i;\n+        \/\/ Implicit leading parameter\n+        public NestedClass(final int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    class BridgeExample implements Cloneable {\n+        public BridgeExample(){}\n+        \/\/ Triggers generation of a bridge method.\n+        public BridgeExample clone() {\n+            return new BridgeExample();\n+        }\n+    }\n+\n+    \/\/ Use as a host for a constructor with synthetic parameters\n+    enum TestEnum {\n+        INSTANCE;\n+    }\n+\n+    private static void checkExecutable(Executable method) {\n+        ExpectedMethodFlags emf =\n+            method.getAnnotation(ExpectedMethodFlags.class);\n+        if (emf != null) {\n+            String actual = method.accessFlags().toString();\n+            checkString(method.toString(), emf.value(), actual);\n+        }\n+    }\n+\n+    private static void checkString(String declaration,\n+                               String expected,\n+                               String actual) {\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"On \" + declaration +\n+                                       \" expected \" + expected +\n+                                       \" got \" + actual);\n+        }\n+    }\n+\n+    \/\/ Constructors\n+    @ExpectedMethodFlags(\"[PUBLIC]\")\n+    public MethodAccessFlagTest() {}\n+\n+    @ExpectedMethodFlags(\"[PROTECTED]\")\n+    protected MethodAccessFlagTest(int i) {super();}\n+\n+    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    private MethodAccessFlagTest(String s) {super();}\n+\n+    \/\/ Methods\n+    @ExpectedMethodFlags(\"[PROTECTED, SYNCHRONIZED]\")\n+    protected synchronized void m0() {}\n+\n+    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    private void m1() {}\n+\n+    @ExpectedMethodFlags(\"[ABSTRACT]\")\n+    abstract void m2();\n+\n+    @ExpectedMethodFlags(\"[PUBLIC, FINAL]\")\n+    public final void m3() {}\n+\n+    @ExpectedMethodFlags(\"[NATIVE]\")\n+    native void m4();\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    private @interface ExpectedMethodFlags {\n+        String value();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/MethodAccessFlagTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on module-related structures.\n+ *\/\n+\n+import java.lang.reflect.AccessFlag;\n+import java.lang.module.*;\n+import java.util.Set;\n+\n+public class ModuleDescriptorAccessFlagTest {\n+    public static void main(String... args) {\n+        \/\/ Test ModuleDescriptor.Modifier\n+        var openMod = ModuleDescriptor.newModule(\"foo\",\n+                                                 Set.of(ModuleDescriptor.Modifier.OPEN,\n+                                                        ModuleDescriptor.Modifier.SYNTHETIC,\n+                                                        ModuleDescriptor.Modifier.MANDATED)).build();\n+        checkAccessFlags(openMod, openMod.accessFlags(), \"[OPEN, SYNTHETIC, MANDATED]\");\n+        \/\/ AUTOMATIC does not have a corresponding access flag so is\n+        \/\/ *not* tested here.\n+\n+        \/\/ Test ModuleDescriptor.Requires.Modifier\n+        var requireMod = ModuleDescriptor.newModule(\"bar\")\n+            .requires(Set.of(ModuleDescriptor.Requires.Modifier.STATIC,\n+                             ModuleDescriptor.Requires.Modifier.SYNTHETIC,\n+                             ModuleDescriptor.Requires.Modifier.TRANSITIVE), \"baz\")\n+            .build();\n+\n+        for (ModuleDescriptor.Requires requires : requireMod.requires()) {\n+            if (\"java.base\".equals(requires.name())) {\n+                checkAccessFlags(requires, requires.accessFlags(), \"[MANDATED]\");\n+            } else {\n+                \/\/ Note \"STATIC_PHASE\" rather than \"STATIC\"\n+                checkAccessFlags(requires, requires.accessFlags(), \"[TRANSITIVE, STATIC_PHASE, SYNTHETIC]\");\n+            }\n+        }\n+\n+        \/\/ Test ModuleDescriptor.Exports.Modifier\n+        var exportMod = ModuleDescriptor.newModule(\"baz\")\n+            .exports(Set.of(ModuleDescriptor.Exports.Modifier.MANDATED,\n+                            ModuleDescriptor.Exports.Modifier.SYNTHETIC), \"quux\")\n+            .build();\n+        for (ModuleDescriptor.Exports exports : exportMod.exports()) {\n+            checkAccessFlags(exports, exports.accessFlags(), \"[SYNTHETIC, MANDATED]\");\n+        }\n+\n+        \/\/ Test ModuleDescriptor.Opens.Modifier\n+        var opensMod = ModuleDescriptor.newModule(\"quux\")\n+            .exports(Set.of(ModuleDescriptor.Exports.Modifier.MANDATED,\n+                            ModuleDescriptor.Exports.Modifier.SYNTHETIC), \"xxyzzy\")\n+            .build();\n+        for (ModuleDescriptor.Opens opens : exportMod.opens()) {\n+            checkAccessFlags(opens, opens.accessFlags(), \"[SYNTHETIC, MANDATED]\");\n+        }\n+    }\n+\n+    private static void checkAccessFlags(Object o, Set<AccessFlag> accessFlags, String expected) {\n+        String actual = accessFlags.toString();\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"On \" + o.toString() +\n+                                       \" expected \" + expected +\n+                                       \" got \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ModuleDescriptorAccessFlagTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected value of STRICT AccessFlag\n+ * @compile -source 16 -target 16 StrictAccessFlagTest.java\n+ * @run main StrictAccessFlagTest\n+ *\/\n+\n+\/\/ Note: cannot use --release 16 because the accessFlags() method is\n+\/\/ not found in release 16; therefore -source and -target are used\n+\/\/ instead.\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+\/*\n+ * Test expected value of ACC_STRICT access flag.\n+ *\/\n+\/\/ Declaring the class strictfp implicitly sets ACC_STRICT on all its\n+\/\/ methods and constructors.\n+public strictfp class StrictAccessFlagTest {\n+    @ExpectedFlags(\"[PUBLIC, STATIC, VARARGS, STRICT]\")\n+    public static void main(String... args) {\n+        for (var ctor :\n+                 StrictAccessFlagTest.class.getDeclaredConstructors()) {\n+            checkExecutable(ctor);\n+        }\n+\n+        for (var method :\n+                 StrictAccessFlagTest.class.getDeclaredMethods()) {\n+            checkExecutable(method);\n+        }\n+    }\n+\n+    private static void checkExecutable(Executable method) {\n+        ExpectedFlags expected =\n+            method.getAnnotation(ExpectedFlags.class);\n+        if (expected != null) {\n+            String actual = method.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + method +\n+                                           \" expected \" + expected.value() +\n+                                           \" got \" + actual);\n+            }\n+        }\n+    }\n+\n+    \/\/ Constructor\n+    @ExpectedFlags(\"[PUBLIC, STRICT]\")\n+    public StrictAccessFlagTest() {}\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    private @interface ExpectedFlags {\n+        String value();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/StrictAccessFlagTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}