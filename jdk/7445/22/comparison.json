{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -1315,0 +1316,1 @@\n+     * @see #accessFlags()\n@@ -1325,0 +1327,19 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag access\n+     * flags} for this class, possibly empty}\n+     * @see #getModifiers()\n+     * @jvms 4.1 The ClassFile Structure\n+     * @jvms 4.7.6 The InnerClasses Attribute\n+     * @since 20\n+     *\/\n+    public Set<AccessFlag> accessFlags() {\n+        \/\/ This likely needs some refinement. Exploration of hidden\n+        \/\/ classes, array classes.  Location.CLASS allows SUPER and\n+        \/\/ AccessFlag.MODULE which INNER_CLASS forbids. INNER_CLASS\n+        \/\/ allows PRIVATE, PROTECTED, and STATIC, which are not\n+        \/\/ allowed on Location.CLASS.\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                                            (isMemberClass() || isLocalClass() || isAnonymousClass()) ?\n+                                            AccessFlag.Location.INNER_CLASS :\n+                                            AccessFlag.Location.CLASS);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -108,1 +109,1 @@\n-        OPEN,\n+        OPEN(AccessFlag.OPEN.mask()),\n@@ -117,1 +118,1 @@\n-        AUTOMATIC,\n+        AUTOMATIC(0 \/* no flag per above comment *\/),\n@@ -122,1 +123,1 @@\n-        SYNTHETIC,\n+        SYNTHETIC(AccessFlag.SYNTHETIC.mask()),\n@@ -127,2 +128,1 @@\n-        MANDATED;\n-    }\n+        MANDATED(AccessFlag.MANDATED.mask());\n@@ -130,0 +130,6 @@\n+        private int mask;\n+        private Modifier(int mask) {\n+            this.mask = mask;\n+        }\n+        private int mask() {return mask;}\n+    }\n@@ -155,1 +161,1 @@\n-            TRANSITIVE,\n+            TRANSITIVE(AccessFlag.TRANSITIVE.mask()),\n@@ -161,1 +167,1 @@\n-            STATIC,\n+            STATIC(AccessFlag.STATIC_PHASE.mask()),\n@@ -167,1 +173,1 @@\n-            SYNTHETIC,\n+            SYNTHETIC(AccessFlag.SYNTHETIC.mask()),\n@@ -173,2 +179,6 @@\n-            MANDATED;\n-\n+            MANDATED(AccessFlag.MANDATED.mask());\n+            private int mask;\n+            private Modifier(int mask) {\n+                this.mask = mask;\n+            }\n+            private int mask() {return mask;}\n@@ -176,1 +186,0 @@\n-\n@@ -206,0 +215,15 @@\n+        \/**\n+         * {@return an unmodifiable set of the module {@linkplain AccessFlag\n+         * requires flags, possibly empty}}\n+         * @see #modifiers()\n+         * @jvms 4.7.25 The Module Attribute\n+         * @since 20\n+         *\/\n+        public Set<AccessFlag> accessFlags() {\n+            int mask = 0;\n+            for (var modifier : mods) {\n+                mask |= modifier.mask();\n+            }\n+            return AccessFlag.maskToAccessFlags(mask, AccessFlag.Location.MODULE_REQUIRES);\n+        }\n+\n@@ -379,1 +403,1 @@\n-            SYNTHETIC,\n+            SYNTHETIC(AccessFlag.SYNTHETIC.mask()),\n@@ -385,1 +409,1 @@\n-            MANDATED;\n+            MANDATED(AccessFlag.MANDATED.mask());\n@@ -387,0 +411,5 @@\n+            private int mask;\n+            private Modifier(int mask) {\n+                this.mask = mask;\n+            }\n+            private int mask() {return mask;}\n@@ -420,0 +449,15 @@\n+        \/**\n+         * {@return an unmodifiable set of the module {@linkplain AccessFlag\n+         * export flags} for this module descriptor, possibly empty}\n+         * @see #modifiers()\n+         * @jvms 4.7.25 The Module Attribute\n+         * @since 20\n+         *\/\n+        public Set<AccessFlag> accessFlags() {\n+            int mask = 0;\n+            for (var modifier : mods) {\n+                mask |= modifier.mask();\n+            }\n+            return AccessFlag.maskToAccessFlags(mask, AccessFlag.Location.MODULE_EXPORTS);\n+        }\n+\n@@ -582,1 +626,1 @@\n-            SYNTHETIC,\n+            SYNTHETIC(AccessFlag.SYNTHETIC.mask()),\n@@ -588,2 +632,6 @@\n-            MANDATED;\n-\n+            MANDATED(AccessFlag.MANDATED.mask());\n+            private int mask;\n+            private Modifier(int mask) {\n+                this.mask = mask;\n+            }\n+            private int mask() {return mask;}\n@@ -623,0 +671,15 @@\n+        \/**\n+         * {@return an unmodifiable set of the module {@linkplain AccessFlag\n+         * opens flags}, possibly empty}\n+         * @see #modifiers()\n+         * @jvms 4.7.25 The Module Attribute\n+         * @since 20\n+         *\/\n+        public Set<AccessFlag> accessFlags() {\n+            int mask = 0;\n+            for (var modifier : mods) {\n+                mask |= modifier.mask();\n+            }\n+            return AccessFlag.maskToAccessFlags(mask, AccessFlag.Location.MODULE_OPENS);\n+        }\n+\n@@ -1293,0 +1356,15 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * module flags}, possibly empty}\n+     * @see #modifiers()\n+     * @jvms 4.7.25 The Module Attribute\n+     * @since 20\n+     *\/\n+    public Set<AccessFlag> accessFlags() {\n+        int mask = 0;\n+        for (var modifier : modifiers) {\n+            mask |= modifier.mask();\n+        }\n+        return AccessFlag.maskToAccessFlags(mask, AccessFlag.Location.MODULE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":94,"deletions":16,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -0,0 +1,420 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import static java.util.Map.entry;\n+\n+\/**\n+ * Represents a JVM access or module-related flag on a runtime member,\n+ * such as a {@linkplain Class class}, {@linkplain Field field}, or\n+ * {@linkplain Executable method}.\n+ *\n+ * <P>JVM access and module-related flags are related to, but distinct\n+ * from Java language {@linkplain Modifier modifiers}. Some modifiers\n+ * and access flags have a one-to-one correspondence, such as {@code\n+ * public}. In other cases, some language-level modifiers do\n+ * <em>not<\/em> have an access flag, such as {@code sealed} (JVMS\n+ * {@jvms 4.7.31}) and some access flags have no corresponding\n+ * modifier, such as {@linkplain #SYNTHETIC synthetic}.\n+ *\n+ * <p>The values for the constants representing the access and module\n+ * flags are taken from sections of <cite>The Java Virtual Machine\n+ * Specification<\/cite> including {@jvms 4.1} (class access and\n+ * property modifiers), {@jvms 4.5} (field access and property flags),\n+ * {@jvms 4.6} (method access and property flags), {@jvms 4.7.6}\n+ * (nested class access and property flags), {@jvms 4.7.24} (method\n+ * parameters), and {@jvms 4.7.25} (module flags and requires,\n+ * exports, and opens flags).\n+ *\n+ * <p>The {@linkplain #mask() mask} values for the different access\n+ * flags are <em>not<\/em> distinct. Flags are defined for different\n+ * kinds of JVM structures and the same bit position has different\n+ * meanings in different contexts. For example, {@code 0x0000_0040}\n+ * indicates a {@link #VOLATILE volatile} field but a {@linkplain\n+ * #BRIDGE bridge method}; {@code 0x0000_0080} indicates a {@link\n+ * #TRANSIENT transient} field but a {@linkplain #VARARGS variable\n+ * arity (varargs)} method.\n+ *\n+ * <p>The access flag constants are ordered by non-decreasing mask\n+ * value; that is the mask value of a constant is greater than or\n+ * equal to the mask value of an immediate neighbor to its (syntactic)\n+ * left. If new constants are added, this property will be\n+ * maintained. That implies new constants will not necessarily be\n+ * added at the end of the existing list.\n+ *\n+ * @see java.lang.reflect.Modifier\n+ * @see java.lang.module.ModuleDescriptor.Modifier\n+ * @see java.lang.module.ModuleDescriptor.Requires.Modifier\n+ * @see java.lang.module.ModuleDescriptor.Exports.Modifier\n+ * @see java.lang.module.ModuleDescriptor.Opens.Modifier\n+ * @see java.compiler\/javax.lang.model.element.Modifier\n+ * @since 20\n+ *\/\n+@SuppressWarnings(\"doclint:reference\") \/\/ cross-module link\n+public enum AccessFlag {\n+    \/**\n+     * The access flag {@code ACC_PUBLIC}, corresponding to the source\n+     * modifier {@link Modifier#PUBLIC public} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#PUBLIC}<\/code>.\n+     *\/\n+    PUBLIC(Modifier.PUBLIC, true,\n+           Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n+                  Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_PRIVATE}, corresponding to the\n+     * source modifier {@link Modifier#PRIVATE private} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#PRIVATE}<\/code>.\n+     *\/\n+    PRIVATE(Modifier.PRIVATE, true,\n+            Set.of(Location.FIELD, Location.METHOD, Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_PROTECTED}, corresponding to the\n+     * source modifier {@link Modifier#PROTECTED protected} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#PROTECTED}<\/code>.\n+     *\/\n+    PROTECTED(Modifier.PROTECTED, true,\n+              Set.of(Location.FIELD, Location.METHOD, Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_STATIC}, corresponding to the source\n+     * modifier {@link Modifier#STATIC static} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#STATIC}<\/code>.\n+     *\/\n+    STATIC(Modifier.STATIC, true,\n+           Set.of(Location.FIELD, Location.METHOD, Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_FINAL}, corresponding to the source\n+     * modifier {@link Modifier#FINAL final} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#FINAL}<\/code>.\n+     *\/\n+    FINAL(Modifier.FINAL, true,\n+          Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n+                 Location.INNER_CLASS, Location.METHOD_PARAMETER)),\n+\n+    \/**\n+     * The access flag {@code ACC_SUPER} with a mask value of {@code\n+     * 0x0020}.\n+     *\/\n+    SUPER(0x0000_0020, false, Set.of(Location.CLASS)),\n+\n+    \/**\n+     * The module flag {@code ACC_OPEN} with a mask value of {@code\n+     * 0x0020}.\n+     * @see java.lang.module.ModuleDescriptor#isOpen\n+     *\/\n+    OPEN(0x0000_0020, false, Set.of(Location.MODULE)),\n+\n+    \/**\n+     * The module requires flag {@code ACC_TRANSITIVE} with a mask\n+     * value of {@code 0x0020}.\n+     * @see java.lang.module.ModuleDescriptor.Requires.Modifier#TRANSITIVE\n+     *\/\n+    TRANSITIVE(0x0000_0020, false, Set.of(Location.MODULE_REQUIRES)),\n+\n+    \/**\n+     * The access flag {@code ACC_SYNCHRONIZED}, corresponding to the\n+     * source modifier {@link Modifier#SYNCHRONIZED synchronized} with\n+     * a mask value of <code>{@value \"0x%04x\" Modifier#SYNCHRONIZED}<\/code>.\n+     *\/\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Set.of(Location.METHOD)),\n+\n+    \/**\n+     * The module requires flag {@code ACC_STATIC_PHASE} with a mask\n+     * value of {@code 0x0040}.\n+     * @see java.lang.module.ModuleDescriptor.Requires.Modifier#STATIC\n+     *\/\n+    STATIC_PHASE(0x0000_0040, false, Set.of(Location.MODULE_REQUIRES)),\n+\n+     \/**\n+      * The access flag {@code ACC_VOLATILE}, corresponding to the\n+      * source modifier {@link Modifier#VOLATILE volatile} with a mask\n+      * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n+      *\/\n+    VOLATILE(Modifier.VOLATILE, true, Set.of(Location.FIELD)),\n+\n+    \/**\n+     * The access flag {@code ACC_BRIDGE} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#BRIDGE}<\/code>\n+     * @see Method#isBridge()\n+     *\/\n+    BRIDGE(Modifier.BRIDGE, false, Set.of(Location.METHOD)),\n+\n+    \/**\n+     * The access flag {@code ACC_TRANSIENT}, corresponding to the\n+     * source modifier {@link Modifier#TRANSIENT transient} with a\n+     * mask value of <code>{@value \"0x%04x\" Modifier#TRANSIENT}<\/code>.\n+     *\/\n+    TRANSIENT(Modifier.TRANSIENT, true, Set.of(Location.FIELD)),\n+\n+    \/**\n+     * The access flag {@code ACC_VARARGS} with a mask value of\n+     <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n+     * @see Executable#isVarArgs()\n+     *\/\n+    VARARGS(Modifier.VARARGS, false, Set.of(Location.METHOD)),\n+\n+    \/**\n+     * The access flag {@code ACC_NATIVE}, corresponding to the source\n+     * modifier {@link Modifier#NATIVE native} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#NATIVE}<\/code>.\n+     *\/\n+    NATIVE(Modifier.NATIVE, true, Set.of(Location.METHOD)),\n+\n+    \/**\n+     * The access flag {@code ACC_INTERFACE} with a mask value of\n+     * {@code 0x0200}.\n+     * @see Class#isInterface()\n+     *\/\n+    INTERFACE(Modifier.INTERFACE, false,\n+              Set.of(Location.CLASS, Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_ABSTRACT}, corresponding to the\n+     * source modifier {@link Modifier#ABSTRACT abstract} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#ABSTRACT}<\/code>.\n+     *\/\n+    ABSTRACT(Modifier.ABSTRACT, true,\n+             Set.of(Location.CLASS, Location.METHOD, Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_STRICT}, corresponding to the source\n+     * modifier {@link Modifier#STRICT strictfp} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#STRICT}<\/code>.\n+     *\/\n+    STRICT(Modifier.STRICT, true, Set.of(Location.METHOD)),\n+\n+    \/**\n+     * The access flag {@code ACC_SYNTHETIC} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#SYNTHETIC}<\/code>.\n+     * @see Class#isSynthetic()\n+     * @see Executable#isSynthetic()\n+     * @see java.lang.module.ModuleDescriptor.Modifier#SYNTHETIC\n+     *\/\n+    SYNTHETIC(Modifier.SYNTHETIC, false,\n+              Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n+                     Location.INNER_CLASS, Location.METHOD_PARAMETER,\n+                     Location.MODULE, Location.MODULE_REQUIRES,\n+                     Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+\n+    \/**\n+     * The access flag {@code ACC_ANNOTATION} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#ANNOTATION}<\/code>.\n+     * @see Class#isAnnotation()\n+     *\/\n+    ANNOTATION(Modifier.ANNOTATION, false,\n+               Set.of(Location.CLASS, Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_ENUM} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#ENUM}<\/code>.\n+     * @see Class#isEnum()\n+     *\/\n+    ENUM(Modifier.ENUM, false,\n+         Set.of(Location.CLASS, Location.FIELD, Location.INNER_CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_MANDATED} with a mask value of\n+     * <code>{@value \"0x%04x\" Modifier#MANDATED}<\/code>.\n+     *\/\n+    MANDATED(Modifier.MANDATED, false,\n+             Set.of(Location.METHOD_PARAMETER,\n+                    Location.MODULE, Location.MODULE_REQUIRES,\n+                    Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+\n+    \/**\n+     * The access flag {@code ACC_MODULE} with a mask value of {@code\n+     * 0x8000}.\n+     *\/\n+    MODULE(0x0000_8000, false, Set.of(Location.CLASS))\n+    ;\n+\n+    \/\/ May want to override toString for a different enum constant ->\n+    \/\/ name mapping.\n+\n+    private int mask;\n+    private boolean sourceModifier;\n+\n+    \/\/ Intentionally using Set rather than EnumSet since EnumSet is\n+    \/\/ mutable.\n+    private Set<Location> locations;\n+\n+    private AccessFlag(int mask, boolean sourceModifier, Set<Location> locations) {\n+        this.mask = mask;\n+        this.sourceModifier = sourceModifier;\n+        this.locations = locations;\n+    }\n+\n+    \/**\n+     * {@return the corresponding integer mask for the access flag}\n+     *\/\n+    public int mask() {\n+        return mask;\n+    }\n+\n+    \/**\n+     * {@return whether or not the flag has a directly corresponding\n+     * modifier in the Java programming language}\n+     *\/\n+    public boolean sourceModifier() {\n+        return sourceModifier;\n+    }\n+\n+    \/**\n+     * {@return kinds of constructs the flag can be applied to}\n+     *\/\n+    public Set<Location> locations() {\n+        return locations;\n+    }\n+\n+    \/**\n+     * {@return a set of access flags for the given mask value\n+     * appropriate for the location in question}\n+     *\n+     * @param mask bit mask of access flags\n+     * @param location context to interpret mask value\n+     * @throws IllegalArgumentException if the mask contains bit\n+     * positions not support for the location in question\n+     *\/\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location) {\n+        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n+        for (var accessFlag : LocationToFlags.locationToFlags.get(location)) {\n+            int accessMask = accessFlag.mask();\n+            if ((mask &  accessMask) != 0) {\n+                result.add(accessFlag);\n+                mask = mask & ~accessMask;\n+            }\n+        }\n+        if (mask != 0) {\n+            throw new IllegalArgumentException(\"Unmatched bit position 0x\" +\n+                                               Integer.toHexString(mask) +\n+                                               \" for location \" + location);\n+        }\n+        return Collections.unmodifiableSet(result);\n+    }\n+\n+    \/**\n+     * A location within a class file where flags can be applied.\n+     *\n+     * Note that since these locations represent class file structures\n+     * rather than language structures many language structures, such\n+     * as constructors and interfaces, are <em>not<\/em> present.\n+     * @since 20\n+     *\/\n+    public enum Location {\n+        \/**\n+         * Class location.\n+         * @jvms 4.1 The ClassFile Structure\n+         *\/\n+        CLASS,\n+\n+        \/**\n+         * Field location.\n+         * @jvms 4.5 Fields\n+         *\/\n+        FIELD,\n+\n+        \/**\n+         * Method location.\n+         * @jvms 4.6 Method\n+         *\/\n+        METHOD,\n+\n+        \/**\n+         * Inner class location.\n+         * @jvms 4.7.6 The InnerClasses Attribute\n+         *\/\n+        INNER_CLASS,\n+\n+        \/**\n+         * Method parameter loccation.\n+         * @jvms 4.7.24. The MethodParameters Attribute\n+         *\/\n+        METHOD_PARAMETER,\n+\n+        \/**\n+         * Module location\n+         * @jvms 4.7.25. The Module Attribute\n+         *\/\n+        MODULE,\n+\n+        \/**\n+         * Module requires location\n+         * @jvms 4.7.25. The Module Attribute\n+         *\/\n+        MODULE_REQUIRES,\n+\n+        \/**\n+         * Module exports location\n+         * @jvms 4.7.25. The Module Attribute\n+         *\/\n+        MODULE_EXPORTS,\n+\n+        \/**\n+         * Module opens location\n+         * @jvms 4.7.25. The Module Attribute\n+         *\/\n+        MODULE_OPENS;\n+\n+    }\n+\n+    private static class LocationToFlags {\n+        private static Map<Location, Set<AccessFlag>> locationToFlags =\n+            Map.ofEntries(entry(Location.CLASS,\n+                                Set.of(PUBLIC, FINAL, SUPER,\n+                                       INTERFACE, ABSTRACT,\n+                                       SYNTHETIC, ANNOTATION,\n+                                       ENUM, AccessFlag.MODULE)),\n+                          entry(Location.FIELD,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                       STATIC, FINAL, VOLATILE,\n+                                       TRANSIENT, SYNTHETIC, ENUM)),\n+                          entry(Location.METHOD,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                       STATIC, FINAL, SYNCHRONIZED,\n+                                       BRIDGE, VARARGS, NATIVE,\n+                                       ABSTRACT, STRICT, SYNTHETIC)),\n+                          entry(Location.INNER_CLASS,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                       STATIC, FINAL, INTERFACE, ABSTRACT,\n+                                       SYNTHETIC, ANNOTATION, ENUM)),\n+                          entry(Location.METHOD_PARAMETER,\n+                                Set.of(FINAL, SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE,\n+                                Set.of(OPEN, SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE_REQUIRES,\n+                                Set.of(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE_EXPORTS,\n+                                Set.of(SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE_OPENS,\n+                                Set.of(SYNTHETIC, MANDATED)));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Set;\n@@ -207,0 +208,1 @@\n+     * @see #accessFlags\n@@ -210,0 +212,19 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * access flags} for the executable represented by this object,\n+     * possibly empty}\n+     *\n+     * @implSpec\n+     * Map this executable's {@linkplain #getModifiers() modifiers} to\n+     * access flags using {@link AccessFlag#maskToAccessFlags} for a\n+     * {@linkplain AccessFlag.Location#METHOD method location}\n+     *\n+     * @see #getModifiers()\n+     * @jvms 4.6 Methods\n+     * @since 20\n+     *\/\n+    @Override\n+    public Set<AccessFlag> accessFlags() {\n+        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.METHOD);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Set;\n@@ -205,0 +206,1 @@\n+     * @see #accessFlags()\n@@ -212,0 +214,12 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * access flags} for this field, possibly empty}\n+     * @see #getModifiers()\n+     * @jvms 4.5 Fields\n+     * @since 20\n+     *\/\n+    @Override\n+    public Set<AccessFlag> accessFlags() {\n+        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Set;\n+\n@@ -79,0 +81,1 @@\n+     * @see #accessFlags()\n@@ -82,0 +85,14 @@\n+\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * access flags} for this member, possibly empty}\n+     *\n+     * @implSpec\n+     * The default implementation returns an empty set.\n+     * @see #getModifiers()\n+     * @since 20\n+     *\/\n+    public default Set<AccessFlag> accessFlags() {\n+        return Set.of();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Member.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -257,0 +257,1 @@\n+     * @see AccessFlag#PUBLIC\n@@ -263,0 +264,1 @@\n+     * @see AccessFlag#PRIVATE\n@@ -269,0 +271,1 @@\n+     * @see AccessFlag#PROTECTED\n@@ -275,0 +278,1 @@\n+     * @see AccessFlag#STATIC\n@@ -281,0 +285,1 @@\n+     * @see AccessFlag#FINAL\n@@ -287,0 +292,1 @@\n+     * @see AccessFlag#SYNCHRONIZED\n@@ -293,0 +299,1 @@\n+     * @see AccessFlag#VOLATILE\n@@ -299,0 +306,1 @@\n+     * @see AccessFlag#TRANSIENT\n@@ -305,0 +313,1 @@\n+     * @see AccessFlag#NATIVE\n@@ -311,0 +320,1 @@\n+     * @see AccessFlag#INTERFACE\n@@ -317,0 +327,1 @@\n+     * @see AccessFlag#ABSTRACT\n@@ -323,0 +334,1 @@\n+     * @see AccessFlag#STRICT\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Set;\n@@ -164,0 +165,14 @@\n+    \/**\n+     * {@return an unmodifiable set of the {@linkplain AccessFlag\n+     * access flags} for the parameter represented by this object,\n+     * possibly empty}\n+     *\n+     * @see #getModifiers()\n+     * @jvms 4.7.24 The MethodParameters Attribute\n+     * @since 20\n+     *\/\n+    public Set<AccessFlag> accessFlags() {\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                                            AccessFlag.Location.METHOD_PARAMETER);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Parameter.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Basic tests of AccessFlag\n+ *\/\n+\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.EnumSet;\n+import java.util.Map;\n+import java.util.LinkedHashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class BasicAccessFlagTest {\n+    public static void main(String... args) throws Exception {\n+        testSourceModifiers();\n+        testMaskOrdering();\n+        testDisjoint();\n+        testMaskToAccessFlagsPositive();\n+    }\n+\n+    private static void testSourceModifiers() throws Exception {\n+        Class<?> modifierClass = Modifier.class;\n+\n+        for(AccessFlag accessFlag : AccessFlag.values()) {\n+            if (accessFlag.sourceModifier()) {\n+                \/\/ Check for consistency\n+                Field f = modifierClass.getField(accessFlag.name());\n+                if (accessFlag.mask() != f.getInt(null) ) {\n+                    throw new RuntimeException(\"Unexpected mask for \" +\n+                                               accessFlag);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ The mask values of the enum constants must be non-decreasing;\n+    \/\/ in other words stay the same (for colliding mask values) or go\n+    \/\/ up.\n+    private static void testMaskOrdering() {\n+        AccessFlag[] values = AccessFlag.values();\n+        for (int i = 1; i < values.length; i++) {\n+            AccessFlag left  = values[i-1];\n+            AccessFlag right = values[i];\n+            if (left.mask() > right.mask()) {\n+                throw new RuntimeException(left\n+                                           + \"has a greater mask than \"\n+                                           + right);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that if access flags have a matching mask, their locations\n+    \/\/ are disjoint.\n+    private static void testDisjoint() {\n+        \/\/ First build the mask -> access flags map...\n+        Map<Integer, Set<AccessFlag>> maskToFlags = new LinkedHashMap<>();\n+\n+        for (var accessFlag : AccessFlag.values()) {\n+            Integer mask = accessFlag.mask();\n+            Set<AccessFlag> flags = maskToFlags.get(mask);\n+\n+            if (flags == null ) {\n+                flags = new HashSet<>();\n+                flags.add(accessFlag);\n+                maskToFlags.put(mask, flags);\n+            } else {\n+                flags.add(accessFlag);\n+            }\n+        }\n+\n+        \/\/ Then test for disjointness\n+        for (var entry : maskToFlags.entrySet()) {\n+            var value = entry.getValue();\n+            if (value.size() == 0) {\n+                throw new AssertionError(\"Bad flag set \" + entry);\n+            } else if (value.size() == 1) {\n+                \/\/ Need at least two flags to be non-disjointness to\n+                \/\/ be possible\n+                continue;\n+            }\n+\n+            Set<AccessFlag.Location> locations = new HashSet<>();\n+            for (var accessFlag : value) {\n+                for (var location : accessFlag.locations()) {\n+                    boolean added = locations.add(location);\n+                    if (!added) {\n+                        reportError(location, accessFlag,\n+                                    entry.getKey(), value);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void reportError(AccessFlag.Location location,\n+                                    AccessFlag accessFlag,\n+                                    Integer mask, Set<AccessFlag> value) {\n+        System.err.println(\"Location \" + location +\n+                           \" from \" + accessFlag +\n+                           \" already present for 0x\" +\n+                           Integer.toHexString(mask) + \": \" + value);\n+        throw new RuntimeException();\n+    }\n+\n+    \/\/ For each access flag, make sure it is recognized on every kind\n+    \/\/ of location it can apply to\n+    private static void testMaskToAccessFlagsPositive() {\n+        for (var accessFlag : AccessFlag.values()) {\n+            Set<AccessFlag> expectedSet = EnumSet.of(accessFlag);\n+            for (var location : accessFlag.locations()) {\n+                Set<AccessFlag> computedSet =\n+                    AccessFlag.maskToAccessFlags(accessFlag.mask(), location);\n+                if (!expectedSet.equals(computedSet)) {\n+                    throw new RuntimeException(\"Bad set computation on \" +\n+                                               accessFlag + \", \" + location);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}