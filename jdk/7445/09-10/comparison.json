{"files":[{"patch":"@@ -28,1 +28,2 @@\n-import java.lang.annotation.ElementType;\n+import java.util.Collections;\n+import java.util.Map;\n@@ -30,1 +31,1 @@\n-import static java.lang.annotation.ElementType.*;\n+import static java.util.Map.entry;\n@@ -273,0 +274,26 @@\n+    \/**\n+     * {@return a set of access flags for the given mask value\n+     * appropriate for the location in question}\n+     *\n+     * @param mask bit mask of access flags\n+     * @param location context to interpret mask value\n+     * @throw IllegalArgumentException if the mask contains bit\n+     * positions not support for the location in question\n+     *\/\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location) {\n+        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n+        for (var accessFlag : LocationToFlags.locationToFlags.get(location)) {\n+            int accessMask = accessFlag.mask();\n+            if ((mask &  accessMask) != 0) {\n+                result.add(accessFlag);\n+                mask = mask & ~accessMask;\n+            }\n+        }\n+        if (mask != 0) {\n+            throw new IllegalArgumentException(\"Unmatched bit position 0x\" +\n+                                               Integer.toHexString(mask) +\n+                                               \" for location \" + location);\n+        }\n+        return Collections.unmodifiableSet(result);\n+    }\n+\n@@ -331,0 +358,33 @@\n+\n+    }\n+\n+    private static class LocationToFlags {\n+        private static Map<Location, Set<AccessFlag>> locationToFlags =\n+            Map.ofEntries(entry(Location.CLASS,\n+                                Set.of(PUBLIC, FINAL, SUPER,\n+                                       INTERFACE, ABSTRACT,\n+                                       SYNTHETIC, ANNOTATION,\n+                                       ENUM, AccessFlag.MODULE)),\n+                          entry(Location.FIELD,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                       STATIC, FINAL, VOLATILE,\n+                                       TRANSIENT, SYNTHETIC, ENUM)),\n+                          entry(Location.METHOD,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                       STATIC, FINAL, SYNCHRONIZED,\n+                                       BRIDGE, VARARGS, NATIVE,\n+                                       ABSTRACT, STRICT, SYNTHETIC)),\n+                          entry(Location.INNER_CLASS,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                       STATIC, FINAL, INTERFACE, ABSTRACT,\n+                                       SYNTHETIC, ANNOTATION, ENUM)),\n+                          entry(Location.METHOD_PARAMETER,\n+                                Set.of(FINAL, SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE,\n+                                Set.of(OPEN, SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE_REQUIRES,\n+                                Set.of(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE_EXPORTS,\n+                                Set.of(SYNTHETIC, MANDATED)),\n+                          entry(Location.MODULE_OPENS,\n+                                Set.of(SYNTHETIC, MANDATED)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":62,"deletions":2,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -43,0 +44,1 @@\n+        testMaskToAccessFlagsPositive();\n@@ -128,0 +130,16 @@\n+\n+    \/\/ For each access flag, make sure it is recognized on every kind\n+    \/\/ of location it can apply to\n+    private static void testMaskToAccessFlagsPositive() {\n+        for (var accessFlag : AccessFlag.values()) {\n+            Set<AccessFlag> expectedSet = EnumSet.of(accessFlag);\n+            for (var location : accessFlag.locations()) {\n+                Set<AccessFlag> computedSet =\n+                    AccessFlag.maskToAccessFlags(accessFlag.mask(), location);\n+                if (!expectedSet.equals(computedSet)) {\n+                    throw new RuntimeException(\"Bad set computation on \" +\n+                                               accessFlag + \", \" + location);\n+                }\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}