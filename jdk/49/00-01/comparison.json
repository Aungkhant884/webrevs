{"files":[{"patch":"@@ -536,5 +536,1 @@\n-  if test \"x$OPENJDK_$1_LIBC\" = \"xmusl\"; then\n-    HOTSPOT_$1_LIBC=$OPENJDK_$1_LIBC\n-  else\n-    HOTSPOT_$1_LIBC=\"\"\n-  fi\n+  HOTSPOT_$1_LIBC=$OPENJDK_$1_LIBC\n","filename":"make\/autoconf\/platform.m4","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -624,2 +624,2 @@\n-  os::Linux::set_libc_version(\"unknown\");\n-  os::Linux::set_libpthread_version(\"unknown\");\n+  os::Linux::set_libc_version(\"musl - unknown\");\n+  os::Linux::set_libpthread_version(\"musl - unknown\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -282,4 +282,11 @@\n-    \/\/ To improve portability across platforms and avoid conflicts\n-    \/\/ between GNU and XSI versions of strerror_r, plain strerror is used.\n-    \/\/ It's safe because this code is not used in any multithreaded environment.\n-    char* msg = strerror(errno);\n+\n+    \/\/ strerror_r() API function is not compatible in different implementations:\n+    \/\/ GNU-specific:  char *strerror_r(int errnum, char *buf, size_t buflen);\n+    \/\/ XSI-compliant: int   strerror_r(int errnum, char *buf, size_t buflen);\n+    char buf[200];\n+#if defined(__GLIBC__) && defined(_GNU_SOURCE)\n+    char* msg = strerror_r(errno, buf, sizeof(buf));\n+#else\n+    int rc = strerror_r(errno, buf, sizeof(buf));\n+    char* msg = (rc == 0) ? (char*)buf : \"Unknown\";\n+#endif\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_proc.c","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-#if defined(__GLIBC)\n+#ifdef __GLIBC__\n","filename":"test\/hotspot\/jtreg\/runtime\/TLS\/exestack-tls.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}