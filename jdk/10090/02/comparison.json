{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-  public AddressException(String detail, long addr) {\n-    super(detail);\n+  public AddressException(String message, long addr) {\n+    super(message);\n@@ -44,1 +44,6 @@\n-    return Long.toHexString(addr);\n+    String msg = super.getMessage();\n+    if (msg != null) {\n+      return msg;\n+    } else {\n+      return Long.toHexString(addr);\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/AddressException.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  private long pageSize;\n@@ -180,0 +181,1 @@\n+    this.pageSize = pageSize;\n@@ -235,0 +237,13 @@\n+  \/** If an address for a 64-bit value starts on the last 32-bit word of a\n+      page, then we can't use the page cache to read it because it will cause\n+      an ArrayIndexOutOfBoundsException when reading past the end of the page. *\/\n+  private boolean canUsePageCacheFor64bitRead(long address) {\n+    long pageMask = ~(pageSize - 1);\n+    if ((address & pageMask) != ((address + 4) & pageMask)) {\n+      \/\/ This address starts on the last 32-bit word of the page.\n+      \/\/ Cannot use the page cache in that case.\n+      return false;\n+    }\n+    return true;\n+  }\n+\n@@ -259,2 +274,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -273,2 +286,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -279,1 +290,1 @@\n-    if (useFastAccessors) {\n+    if (useFastAccessors && canUsePageCacheFor64bitRead(address)) {\n@@ -287,2 +298,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -301,2 +310,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -315,2 +322,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -321,1 +326,1 @@\n-    if (useFastAccessors) {\n+    if (useFastAccessors && canUsePageCacheFor64bitRead(address)) {\n@@ -329,2 +334,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -343,2 +346,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -349,1 +350,1 @@\n-    if (useFastAccessors) {\n+    if (useFastAccessors && (numBytes != 8 || canUsePageCacheFor64bitRead(address))) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerBase.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+  protected boolean supports32bitAlignmentOf64bitTypes;\n@@ -33,1 +34,2 @@\n-  public DebuggerUtilities(long addressSize, boolean isBigEndian) {\n+    public DebuggerUtilities(long addressSize, boolean isBigEndian,\n+                             boolean supports32bitAlignmentOf64bitTypes) {\n@@ -36,0 +38,1 @@\n+    this.supports32bitAlignmentOf64bitTypes = supports32bitAlignmentOf64bitTypes;\n@@ -56,0 +59,7 @@\n+    \/\/ Allow 32-bit alignment for 64-bit types on some hosts.\n+    if (supports32bitAlignmentOf64bitTypes) {\n+      if (address % 4 == 0) {\n+        return;\n+      }\n+    }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerUtilities.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,6 @@\n+\n+  \/** Indicates whether the underlying machine supports 64-bit types\n+      that are only 32-bit aligned. *\/\n+  default public boolean supports32bitAlignmentOf64bitTypes() {\n+    return false;\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/MachineDescription.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,4 @@\n+\n+  public boolean supports32bitAlignmentOf64bitTypes() {\n+    return true;\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/MachineDescriptionIntelX86.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,14 +191,2 @@\n-                                      machDesc.isBigEndian()) {\n-           public void checkAlignment(long address, long alignment) {\n-             \/\/ Need to override default checkAlignment because we need to\n-             \/\/ relax alignment constraints on Bsd\/x86\n-             if ( (address % alignment != 0)\n-                &&(alignment != 8 || address % 4 != 0)) {\n-                throw new UnalignedAddressException(\n-                        \"Trying to read at address: \"\n-                      + addressValueToString(address)\n-                      + \" with alignment: \" + alignment,\n-                        address);\n-             }\n-           }\n-        };\n+                                      machDesc.isBigEndian(),\n+                                      machDesc.supports32bitAlignmentOf64bitTypes());\n@@ -487,24 +475,0 @@\n-    \/** Need to override this to relax alignment checks on x86. *\/\n-    public long readCInteger(long address, long numBytes, boolean isUnsigned)\n-        throws UnmappedAddressException, UnalignedAddressException {\n-        \/\/ Only slightly relaxed semantics -- this is a hack, but is\n-        \/\/ necessary on x86 where it seems the compiler is\n-        \/\/ putting some global 64-bit data on 32-bit boundaries\n-        if (numBytes == 8) {\n-            utils.checkAlignment(address, 4);\n-        } else {\n-            utils.checkAlignment(address, numBytes);\n-        }\n-        byte[] data = readBytes(address, numBytes);\n-        return utils.dataToCInteger(data, isUnsigned);\n-    }\n-\n-    \/\/ Overridden from DebuggerBase because we need to relax alignment\n-    \/\/ constraints on x86\n-    public long readJLong(long address)\n-        throws UnmappedAddressException, UnalignedAddressException {\n-        utils.checkAlignment(address, jintSize);\n-        byte[] data = readBytes(address, jlongSize);\n-        return utils.dataToJLong(data, jlongSize);\n-    }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebuggerLocal.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -210,14 +210,2 @@\n-                                      machDesc.isBigEndian()) {\n-           public void checkAlignment(long address, long alignment) {\n-             \/\/ Need to override default checkAlignment because we need to\n-             \/\/ relax alignment constraints on Linux\/x86\n-             if ( (address % alignment != 0)\n-                &&(alignment != 8 || address % 4 != 0)) {\n-                throw new UnalignedAddressException(\n-                        \"Trying to read at address: \"\n-                      + addressValueToString(address)\n-                      + \" with alignment: \" + alignment,\n-                        address);\n-             }\n-           }\n-        };\n+                                      machDesc.isBigEndian(),\n+                                      machDesc.supports32bitAlignmentOf64bitTypes());\n@@ -544,24 +532,0 @@\n-    \/** Need to override this to relax alignment checks on x86. *\/\n-    public long readCInteger(long address, long numBytes, boolean isUnsigned)\n-        throws UnmappedAddressException, UnalignedAddressException {\n-        \/\/ Only slightly relaxed semantics -- this is a hack, but is\n-        \/\/ necessary on x86 where it seems the compiler is\n-        \/\/ putting some global 64-bit data on 32-bit boundaries\n-        if (numBytes == 8) {\n-            utils.checkAlignment(address, 4);\n-        } else {\n-            utils.checkAlignment(address, numBytes);\n-        }\n-        byte[] data = readBytes(address, numBytes);\n-        return utils.dataToCInteger(data, isUnsigned);\n-    }\n-\n-    \/\/ Overridden from DebuggerBase because we need to relax alignment\n-    \/\/ constraints on x86\n-    public long readJLong(long address)\n-        throws UnmappedAddressException, UnalignedAddressException {\n-        utils.checkAlignment(address, jintSize);\n-        byte[] data = readBytes(address, jlongSize);\n-        return utils.dataToJLong(data, jlongSize);\n-    }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxDebuggerLocal.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  private boolean unalignedAccessesOkay = false;\n@@ -53,2 +52,3 @@\n-      machDesc = remoteDebugger.getMachineDescription();\n-      utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian());\n+      this.machDesc = remoteDebugger.getMachineDescription();\n+      utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian(),\n+                                    machDesc.supports32bitAlignmentOf64bitTypes());\n@@ -60,1 +60,0 @@\n-        unalignedAccessesOkay = true;\n@@ -63,1 +62,0 @@\n-        unalignedAccessesOkay = true;\n@@ -66,1 +64,0 @@\n-        unalignedAccessesOkay = true;\n@@ -77,1 +74,0 @@\n-        unalignedAccessesOkay = false;\n@@ -231,35 +227,0 @@\n-  \/** Need to override this to relax alignment checks on x86. *\/\n-  public long readCInteger(long address, long numBytes, boolean isUnsigned)\n-    throws UnmappedAddressException, UnalignedAddressException {\n-    if (!unalignedAccessesOkay) {\n-      utils.checkAlignment(address, numBytes);\n-    } else {\n-      \/\/ Only slightly relaxed semantics -- this is a hack, but is\n-      \/\/ necessary on x86 where it seems the compiler is\n-      \/\/ putting some global 64-bit data on 32-bit boundaries\n-      if (numBytes == 8) {\n-        utils.checkAlignment(address, 4);\n-      } else {\n-        utils.checkAlignment(address, numBytes);\n-      }\n-    }\n-    byte[] data = readBytes(address, numBytes);\n-    return utils.dataToCInteger(data, isUnsigned);\n-  }\n-\n-  \/\/ Overridden from DebuggerBase because we need to relax alignment\n-  \/\/ constraints on x86\n-  public long readJLong(long address)\n-    throws UnmappedAddressException, UnalignedAddressException {\n-    \/\/ FIXME: allow this to be configurable. Undesirable to add a\n-    \/\/ dependency on the runtime package here, though, since this\n-    \/\/ package should be strictly underneath it.\n-    if (unalignedAccessesOkay) {\n-      utils.checkAlignment(address, jintSize);\n-    } else {\n-      utils.checkAlignment(address, jlongSize);\n-    }\n-    byte[] data = readBytes(address, jlongSize);\n-    return utils.dataToJLong(data, jlongSize);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/remote\/RemoteDebuggerClient.java","additions":3,"deletions":42,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -98,14 +98,2 @@\n-    utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian()) {\n-           public void checkAlignment(long address, long alignment) {\n-             \/\/ Need to override default checkAlignment because we need to\n-             \/\/ relax alignment constraints on Windows\/x86\n-             if ( (address % alignment != 0)\n-                &&(alignment != 8 || address % 4 != 0)) {\n-                throw new UnalignedAddressException(\n-                        \"Trying to read at address: \"\n-                      + addressValueToString(address)\n-                      + \" with alignment: \" + alignment,\n-                        address);\n-             }\n-           }\n-        };\n+    utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian(),\n+                                  machDesc.supports32bitAlignmentOf64bitTypes());\n@@ -272,16 +260,0 @@\n-  \/\/----------------------------------------------------------------------\n-  \/\/ Overridden from DebuggerBase because we need to relax alignment\n-  \/\/ constraints on x86\n-\n-  public long readJLong(long address)\n-    throws UnmappedAddressException, UnalignedAddressException {\n-    checkJavaConfigured();\n-    \/\/ FIXME: allow this to be configurable. Undesirable to add a\n-    \/\/ dependency on the runtime package here, though, since this\n-    \/\/ package should be strictly underneath it.\n-    \/\/    utils.checkAlignment(address, jlongSize);\n-    utils.checkAlignment(address, jintSize);\n-    byte[] data = readBytes(address, jlongSize);\n-    return utils.dataToJLong(data, jlongSize);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":2,"deletions":30,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -220,0 +220,9 @@\n+            \/\/ Use findpc on an address that is only 4 byte aligned and is the\n+            \/\/ last 4 bytes of a 4k page. This is for testing JDK-8292201.\n+            String badAddress = tid.substring(0, tid.length() - 3) + \"ffc\";\n+            cmdStr = \"findpc \" + badAddress;\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmdStr, List.of(\"In unknown location\"));\n+            runTest(withCore, cmds, expStrMap);\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+            long startTime = System.currentTimeMillis();\n@@ -79,1 +80,2 @@\n-            System.out.println(\"###### End of all output:\");\n+            long elapsedTime = System.currentTimeMillis() - startTime;\n+            System.out.println(\"###### End of all output which took \" + elapsedTime + \"ms\");\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/JShellHeapDumpTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}