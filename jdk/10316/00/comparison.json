{"files":[{"patch":"@@ -268,3 +268,22 @@\n-        \/\/ If predefine app image is provided, then just sign it and return.\n-        if (PREDEFINED_APP_IMAGE.fetchFrom(params) != null) {\n-            doSigning(params);\n+        \/\/ If predefined app image is provided, then just sign it and return.\n+        Path predefinedAppImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n+        if (predefinedAppImage != null) {\n+            \/\/ Mark app image as signed, before we signing it.\n+            AppImageFile appImageFile =\n+                AppImageFile.load(predefinedAppImage);\n+            appImageFile.setIsSigned(true);\n+            AppImageFile.save(predefinedAppImage, null, appImageFile);\n+\n+            boolean markUnsigned = false;\n+            try {\n+                markUnsigned = !doSigning(params);\n+            } catch (Exception ex) {\n+                markUnsigned = true;\n+            } finally {\n+                \/\/ Undo marking image as signed if needed.\n+                if (markUnsigned) {\n+                    appImageFile.setIsSigned(false);\n+                    AppImageFile.save(predefinedAppImage, null, appImageFile);\n+                }\n+            }\n+\n@@ -366,1 +385,1 @@\n-    private void doSigning(Map<String, ? super Object> params)\n+    private boolean doSigning(Map<String, ? super Object> params)\n@@ -390,0 +409,1 @@\n+            return false; \/\/ Since we unsigned app image\n@@ -391,0 +411,2 @@\n+\n+        return true;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-        AppImageFile.save(root, params);\n+        AppImageFile.save(root, params, null);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AbstractAppImageBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n@@ -64,0 +66,1 @@\n+    private final String appVersion;\n@@ -67,1 +70,1 @@\n-    private final boolean signed;\n+    private boolean signed;\n@@ -76,3 +79,4 @@\n-    private AppImageFile(Path appImageDir, String launcherName, String mainClass,\n-            List<LauncherInfo> launcherInfos, String creatorVersion,\n-            String creatorPlatform, String signedStr, String appStoreStr) {\n+    private AppImageFile(Path appImageDir, String appVersion, String launcherName,\n+            String mainClass, List<LauncherInfo> launcherInfos,\n+            String creatorVersion, String creatorPlatform, String signedStr,\n+            String appStoreStr) {\n@@ -88,0 +92,4 @@\n+        if (appVersion == null || appVersion.length() == 0) {\n+            isValid = false;\n+        }\n+\n@@ -114,1 +122,2 @@\n-                \"error.invalid-app-image\"), appImageDir));\n+                \"error.invalid-app-image\"), appImageDir,\n+                AppImageFile.getPathInAppImage(appImageDir)));\n@@ -117,0 +126,1 @@\n+        this.appVersion = appVersion;\n@@ -135,0 +145,7 @@\n+    \/**\n+     * Returns application version. Never returns null or empty value.\n+     *\/\n+    String getAppVersion() {\n+        return appVersion;\n+    }\n+\n@@ -149,0 +166,4 @@\n+    public void setIsSigned(boolean v) {\n+        signed = v;\n+    }\n+\n@@ -153,1 +174,1 @@\n-    boolean isAppStore() {\n+    public boolean isAppStore() {\n@@ -169,1 +190,2 @@\n-     * Saves file with application image info in application image.\n+     * Saves file with application image info in application image using params\n+     * or appImage. Both params or appImage cannot be valid.\n@@ -171,0 +193,2 @@\n+     * @param params - parameters used to generate application image\n+     * @param appImage - instance of already existing application image file\n@@ -172,0 +196,2 @@\n+     * @throws IllegalArgumentException - If both params and appImage are null or\n+     *                                    If both params and appImage are not null\n@@ -173,2 +199,30 @@\n-    static void save(Path appImageDir, Map<String, Object> params)\n-            throws IOException {\n+    static void save(Path appImageDir,\n+            Map<String, Object> params,\n+            AppImageFile appImage) throws IOException {\n+        if ((params == null && appImage == null) ||\n+            (params != null && appImage != null)) {\n+                throw new IllegalArgumentException();\n+        }\n+\n+        final String appVersionSave;\n+        final String mainLauncherSave;\n+        final String mainClassSave;\n+        final String signedSave;\n+        final String appStoreSave;\n+        final List<LauncherInfo> addLauncherInfoSave;\n+        if (params != null) {\n+            appVersionSave = VERSION.fetchFrom(params);\n+            mainLauncherSave = APP_NAME.fetchFrom(params);\n+            mainClassSave = MAIN_CLASS.fetchFrom(params);\n+            signedSave = SIGN_BUNDLE.fetchFrom(params).toString();\n+            appStoreSave = APP_STORE.fetchFrom(params).toString();\n+            addLauncherInfoSave = null;\n+        } else {\n+            appVersionSave = appImage.getAppVersion();\n+            mainLauncherSave = appImage.getLauncherName();\n+            mainClassSave = appImage.getMainClass();\n+            signedSave = String.valueOf(appImage.isSigned());\n+            appStoreSave = String.valueOf(appImage.isAppStore());\n+            addLauncherInfoSave = appImage.getAddLaunchers();\n+        }\n+\n@@ -181,1 +235,1 @@\n-            xml.writeCharacters(VERSION.fetchFrom(params));\n+            xml.writeCharacters(appVersionSave);\n@@ -185,1 +239,1 @@\n-            xml.writeCharacters(APP_NAME.fetchFrom(params));\n+            xml.writeCharacters(mainLauncherSave);\n@@ -189,1 +243,1 @@\n-            xml.writeCharacters(MAIN_CLASS.fetchFrom(params));\n+            xml.writeCharacters(mainClassSave);\n@@ -193,1 +247,1 @@\n-            xml.writeCharacters(SIGN_BUNDLE.fetchFrom(params).toString());\n+            xml.writeCharacters(signedSave);\n@@ -197,1 +251,1 @@\n-            xml.writeCharacters(APP_STORE.fetchFrom(params).toString());\n+            xml.writeCharacters(appStoreSave);\n@@ -200,11 +254,12 @@\n-            List<Map<String, ? super Object>> addLaunchers =\n-                ADD_LAUNCHERS.fetchFrom(params);\n-\n-            for (var launcherParams : addLaunchers) {\n-                var li = new LauncherInfo(launcherParams);\n-                xml.writeStartElement(\"add-launcher\");\n-                xml.writeAttribute(\"name\", li.getName());\n-                xml.writeAttribute(\"shortcut\", Boolean.toString(li.isShortcut()));\n-                xml.writeAttribute(\"menu\", Boolean.toString(li.isMenu()));\n-                xml.writeAttribute(\"service\", Boolean.toString(li.isService()));\n-                xml.writeEndElement();\n+            if (addLauncherInfoSave != null) {\n+                for (var li : addLauncherInfoSave) {\n+                    addLauncherInfo(xml, li);\n+                }\n+            } else {\n+                List<Map<String, ? super Object>> addLaunchers =\n+                    ADD_LAUNCHERS.fetchFrom(params);\n+\n+                for (var launcherParams : addLaunchers) {\n+                    var li = new LauncherInfo(launcherParams);\n+                    addLauncherInfo(xml, li);\n+                }\n@@ -215,0 +270,10 @@\n+    static void addLauncherInfo(XMLStreamWriter xml, LauncherInfo li)\n+            throws XMLStreamException {\n+        xml.writeStartElement(\"add-launcher\");\n+        xml.writeAttribute(\"name\", li.getName());\n+        xml.writeAttribute(\"shortcut\", Boolean.toString(li.isShortcut()));\n+        xml.writeAttribute(\"menu\", Boolean.toString(li.isMenu()));\n+        xml.writeAttribute(\"service\", Boolean.toString(li.isService()));\n+        xml.writeEndElement();\n+    }\n+\n@@ -227,0 +292,3 @@\n+            String appVersion = xpathQueryNullable(xPath,\n+                    \"\/jpackage-state\/app-version\/text()\", doc);\n+\n@@ -255,2 +323,3 @@\n-            return new AppImageFile(appImageDir, mainLauncher, mainClass,\n-                    launcherInfos, version, platform, signedStr, appStoreStr);\n+            return new AppImageFile(appImageDir, appVersion, mainLauncher,\n+                    mainClass, launcherInfos, version, platform, signedStr,\n+                    appStoreStr);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":96,"deletions":27,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir ({0})\n-error.invalid-app-image=Error: app-image dir ({0}) generated by another jpackage version or malformed .jpackage.xml\n+error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n+error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\"\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir ({0})\n-error.invalid-app-image=Error: app-image dir ({0}) generated by another jpackage version or malformed .jpackage.xml\n+error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n+error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\"\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources_de.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir ({0})\n-error.invalid-app-image=Error: app-image dir ({0}) generated by another jpackage version or malformed .jpackage.xml\n+error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n+error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\"\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources_ja.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir ({0})\n-error.invalid-app-image=Error: app-image dir ({0}) generated by another jpackage version or malformed .jpackage.xml\n+error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n+error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\"\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -398,0 +398,3 @@\n+     *\n+     * Special case for masOS. If this is sign app image command, returns value\n+     * of \"--app-image\".\n@@ -402,0 +405,3 @@\n+            if (TKit.isOSX() && hasArgument(\"--app-image\")) {\n+                return Path.of(getArgumentValue(\"--app-image\", () -> null));\n+            }\n@@ -821,1 +827,4 @@\n-        final Path lookupPath = AppImageFile.getPathInAppImage(Path.of(\"\"));\n+        Path appImageDir = Path.of(\"\");\n+        if (isImagePackageType() && hasArgument(\"--app-image\")) {\n+            appImageDir = Path.of(getArgumentValue(\"--app-image\", () -> null));\n+        }\n@@ -823,0 +832,1 @@\n+        final Path lookupPath = AppImageFile.getPathInAppImage(appImageDir);\n@@ -827,0 +837,18 @@\n+\n+            \/\/ If file exist validated important values based on arguments\n+            \/\/ Exclude validation when we generating packages from predefined\n+            \/\/ app images, since we do not know if image is signed or not.\n+            if (isImagePackageType() || !hasArgument(\"--app-image\")) {\n+                final Path rootDir = isImagePackageType() ? outputBundle() :\n+                        pathToUnpackedPackageFile(appInstallationDirectory());\n+\n+                boolean expectedValue = hasArgument(\"--mac-sign\");\n+                boolean actualValue = AppImageFile.load(rootDir).isSigned();\n+                TKit.assertTrue(expectedValue == actualValue,\n+                    \"Unexptected value in app image file for <signed>\");\n+\n+                expectedValue = hasArgument(\"--mac-app-store\");\n+                actualValue = AppImageFile.load(rootDir).isAppStore();\n+                TKit.assertTrue(expectedValue == actualValue,\n+                    \"Unexptected value in app image file for <app-store>\");\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        params.put(Arguments.CLIOptions.VERSION.getId(), \"\");\n+        params.put(Arguments.CLIOptions.VERSION.getId(), \"1.0\");\n@@ -107,0 +107,1 @@\n+                    \"<app-version>1.0<\/app-version>\",\n@@ -115,0 +116,1 @@\n+                    \"<app-version>1.0<\/app-version>\",\n@@ -124,0 +126,1 @@\n+                    \"<app-version>1.0<\/app-version>\",\n@@ -211,1 +214,1 @@\n-        AppImageFile.save(tempFolder.getRoot().toPath(), params);\n+        AppImageFile.save(tempFolder.getRoot().toPath(), params, null);\n@@ -218,1 +221,4 @@\n-        Assert.assertTrue(ex.getMessage().contains(\"malformed .jpackage.xml\"));\n+        Assert.assertTrue(ex.getMessage()\n+                .contains(\"generated by another jpackage version or malformed\"));\n+        Assert.assertTrue(ex.getMessage()\n+                .endsWith(\".jpackage.xml\\\"\"));\n","filename":"test\/jdk\/tools\/jpackage\/junit\/jdk\/jpackage\/internal\/AppImageFileTest.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-        verifySignature(appImageCmd, signAppImage);\n+        SigningBase.verifyAppImageSignature(appImageCmd, signAppImage, \"testAL\");\n@@ -100,1 +100,1 @@\n-        cmd.execute();\n+        cmd.executeAndAssertImageCreated();\n@@ -103,15 +103,1 @@\n-        verifySignature(appImageCmd, true);\n-    }\n-\n-    private void verifySignature(JPackageCommand appImageCmd, boolean isSigned) throws Exception {\n-        Path launcherPath = appImageCmd.appLauncherPath();\n-        SigningBase.verifyCodesign(launcherPath, isSigned);\n-\n-        Path testALPath = launcherPath.getParent().resolve(\"testAL\");\n-        SigningBase.verifyCodesign(testALPath, isSigned);\n-\n-        Path appImage = appImageCmd.outputBundle();\n-        SigningBase.verifyCodesign(appImage, isSigned);\n-        if (isSigned) {\n-            SigningBase.verifySpctl(appImage, \"exec\");\n-        }\n+        SigningBase.verifyAppImageSignature(appImageCmd, true, \"testAL\");\n@@ -120,1 +106,0 @@\n-\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTwoStepsTest.java","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.ApplicationLayout;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n+\n+\/**\n+ * Tests generation of dmg and pkg from signed predefined app image which was\n+ * signed using two step process (generate app image and then signed using\n+ * --app-image and --mac-sign). Test will generate pkg and verifies its\n+ * signature. It verifies that dmg is not signed, but app image inside dmg\n+ * is signed. This test requires that the machine is configured with test\n+ * certificate for \"Developer ID Installer: jpackage.openjdk.java.net\" in\n+ * jpackagerTest keychain with always allowed access to this keychain for user\n+ * which runs test.\n+ * note:\n+ * \"jpackage.openjdk.java.net\" can be over-ridden by systerm property\n+ * \"jpackage.mac.signing.key.user.name\", and\n+ * \"jpackagerTest\" can be over-ridden by system property\n+ * \"jpackage.mac.signing.keychain\"\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --type pkg,dmg --app-image\n+ * @library ..\/helpers\n+ * @library \/test\/lib\n+ * @library base\n+ * @key jpackagePlatformPackage\n+ * @build SigningBase\n+ * @build SigningCheck\n+ * @build jtreg.SkippedException\n+ * @build jdk.jpackage.test.*\n+ * @build SigningPackageFromTwoStepAppImageTest\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningPackageFromTwoStepAppImageTest\n+ *\/\n+public class SigningPackageFromTwoStepAppImageTest {\n+\n+    private static void verifyPKG(JPackageCommand cmd) {\n+        if (!cmd.hasArgument(\"--mac-sign\")) {\n+            return; \/\/ Nothing to check if not signed\n+        }\n+\n+        Path outputBundle = cmd.outputBundle();\n+        SigningBase.verifyPkgutil(outputBundle);\n+        SigningBase.verifySpctl(outputBundle, \"install\");\n+    }\n+\n+    private static void verifyDMG(JPackageCommand cmd) {\n+        \/\/ DMG always unsigned, so we will check it\n+        Path outputBundle = cmd.outputBundle();\n+        SigningBase.verifyCodesign(outputBundle, false);\n+    }\n+\n+    private static void verifyAppImageInDMG(JPackageCommand cmd) {\n+        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n+            \/\/ We will be called with all folders in DMG since JDK-8263155, but\n+            \/\/ we only need to verify app.\n+            if (dmgImage.endsWith(cmd.name() + \".app\")) {\n+                Path launcherPath = ApplicationLayout.platformAppImage()\n+                    .resolveAt(dmgImage).launchersDirectory().resolve(cmd.name());\n+                SigningBase.verifyCodesign(launcherPath, true);\n+                SigningBase.verifyCodesign(dmgImage, true);\n+                SigningBase.verifySpctl(dmgImage, \"exec\");\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public static void test(boolean signAppImage) throws Exception {\n+        SigningCheck.checkCertificates();\n+\n+        Path appimageOutput = TKit.createTempDirectory(\"appimage\");\n+\n+        \/\/ Generate app image. Signed or unsigned based on test\n+        \/\/ parameter. We should able to sign predfined app images\n+        \/\/ which are signed or unsigned.\n+        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n+                .setArgumentValue(\"--dest\", appimageOutput);\n+        if (signAppImage) {\n+            appImageCmd.addArguments(\"--mac-sign\", \"--mac-signing-key-user-name\",\n+                    SigningBase.DEV_NAME, \"--mac-signing-keychain\",\n+                    SigningBase.KEYCHAIN);\n+        }\n+\n+        \/\/ Generate app image\n+        appImageCmd.executeAndAssertHelloAppImageCreated();\n+\n+        \/\/ Double check if it is signed or unsigned based on signAppImage\n+        SigningBase.verifyAppImageSignature(appImageCmd, signAppImage);\n+\n+        \/\/ Sign app image\n+        JPackageCommand appImageSignedCmd = new JPackageCommand();\n+        appImageSignedCmd.setPackageType(PackageType.IMAGE)\n+            .addArguments(\"--app-image\", appImageCmd.outputBundle().toAbsolutePath())\n+            .addArguments(\"--mac-sign\")\n+            .addArguments(\"--mac-signing-key-user-name\", SigningBase.DEV_NAME)\n+            .addArguments(\"--mac-signing-keychain\", SigningBase.KEYCHAIN);\n+        appImageSignedCmd.executeAndAssertImageCreated();\n+\n+        \/\/ Should be signed app image\n+        SigningBase.verifyAppImageSignature(appImageCmd, true);\n+\n+        new PackageTest()\n+                .forTypes(PackageType.MAC)\n+                .addInitializer(cmd -> {\n+                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n+                    cmd.removeArgumentWithValue(\"--input\");\n+                    if (signAppImage) {\n+                        cmd.addArguments(\"--mac-sign\",\n+                                \"--mac-signing-key-user-name\",\n+                                SigningBase.DEV_NAME,\n+                                \"--mac-signing-keychain\",\n+                                SigningBase.KEYCHAIN);\n+                    }\n+                })\n+                .forTypes(PackageType.MAC_PKG)\n+                .addBundleVerifier(\n+                    SigningPackageFromTwoStepAppImageTest::verifyPKG)\n+                .forTypes(PackageType.MAC_DMG)\n+                .addBundleVerifier(\n+                    SigningPackageFromTwoStepAppImageTest::verifyDMG)\n+                .addBundleVerifier(\n+                    SigningPackageFromTwoStepAppImageTest::verifyAppImageInDMG)\n+                .run();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageFromTwoStepAppImageTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.jpackage.test.JPackageCommand;\n@@ -150,0 +151,18 @@\n+    public static void verifyAppImageSignature(JPackageCommand appImageCmd,\n+            boolean isSigned, String... launchers) throws Exception {\n+        Path launcherPath = appImageCmd.appLauncherPath();\n+        SigningBase.verifyCodesign(launcherPath, isSigned);\n+\n+        final List<String> launchersList = List.of(launchers);\n+        launchersList.forEach(launcher -> {\n+            Path testALPath = launcherPath.getParent().resolve(launcher);\n+            SigningBase.verifyCodesign(testALPath, isSigned);\n+        });\n+\n+        Path appImage = appImageCmd.outputBundle();\n+        SigningBase.verifyCodesign(appImage, isSigned);\n+        if (isSigned) {\n+            SigningBase.verifySpctl(appImage, \"exec\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"}]}