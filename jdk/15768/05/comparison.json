{"files":[{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.HexDigits;\n@@ -406,6 +408,3 @@\n-                out.append(prefix);\n-                toHexDigits(out, bytes[fromIndex]);\n-                if (suffix.isEmpty() && delimiter.isEmpty() && prefix.isEmpty()) {\n-                    for (int i = 1; i < length; i++) {\n-                        toHexDigits(out, bytes[fromIndex + i]);\n-                    }\n+                String s = formatOptDelimiter(bytes, fromIndex, toIndex);\n+                if (s != null) {\n+                    out.append(s);\n@@ -413,0 +412,2 @@\n+                    out.append(prefix);\n+                    toHexDigits(out, bytes[fromIndex]);\n@@ -419,0 +420,1 @@\n+                    out.append(suffix);\n@@ -420,1 +422,0 @@\n-                out.append(suffix);\n@@ -445,0 +446,2 @@\n+\n+        boolean ucase = digitCase == Case.UPPERCASE;\n@@ -450,2 +453,4 @@\n-                rep[i * 2] = (byte)toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 2 + 1] = (byte)toLowHexDigit(bytes[fromIndex + i]);\n+                ByteArrayLittleEndian.setShort(\n+                        rep,\n+                        i * 2,\n+                        HexDigits.digitPair(bytes[fromIndex + i], ucase));\n@@ -458,2 +463,4 @@\n-            rep[0] = (byte) toHighHexDigit(bytes[fromIndex]);\n-            rep[1] = (byte) toLowHexDigit(bytes[fromIndex]);\n+            ByteArrayLittleEndian.setShort(\n+                    rep,\n+                    0,\n+                    HexDigits.digitPair(bytes[fromIndex], ucase));\n@@ -462,2 +469,4 @@\n-                rep[i * 3    ] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 3 + 1] = (byte) toLowHexDigit(bytes[fromIndex + i]);\n+                ByteArrayLittleEndian.setShort(\n+                        rep,\n+                        i * 3,\n+                        HexDigits.digitPair(bytes[fromIndex + i], ucase));\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -94,0 +94,24 @@\n+    \/**\n+     * For values from 0 to 256 return a short encoding a pair of hex ASCII-encoded digit characters in little-endian\n+     * @param i value to convert\n+     * @param ucase ture uppper case, false lower case\n+     * @return a short encoding a pair of hex ASCII-encoded digit characters\n+     *\/\n+    public static short digitPair(int i, boolean ucase) {\n+        \/*\n+         * 0b0100_0000_0100_0000 is a selector that selects letters (1 << 6),\n+         * uppercase or not, and shifting it right by 1 bit incidentally\n+         * becomes a bit offset between cases (1 << 5).\n+         *\n+         *  ([0-9] & 0b100_0000) >> 1 => 0\n+         *  ([a-f] & 0b100_0000) >> 1 => 32\n+         *\n+         *  [0-9] -  0 => [0-9]\n+         *  [a-f] - 32 => [A-F]\n+         *\/\n+        short v = DIGITS[i & 0xff];\n+        return ucase\n+                ? (short) (v - ((v & 0b0100_0000_0100_0000) >> 1))\n+                : v;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -96,0 +96,19 @@\n+    @Benchmark\n+    public String formatLower() {\n+        return HexFormat.of().formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatUpper() {\n+        return HexFormat.of().withUpperCase().formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatLowerCached() {\n+        return LOWER_FORMATTER.formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatUpperCached() {\n+        return UPPER_FORMATTER.formatHex(bytes);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/HexFormatBench.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"}]}