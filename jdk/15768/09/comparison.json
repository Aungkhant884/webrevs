{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.HexDigits;\n@@ -153,9 +154,1 @@\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n@@ -406,6 +399,3 @@\n-                out.append(prefix);\n-                toHexDigits(out, bytes[fromIndex]);\n-                if (suffix.isEmpty() && delimiter.isEmpty() && prefix.isEmpty()) {\n-                    for (int i = 1; i < length; i++) {\n-                        toHexDigits(out, bytes[fromIndex + i]);\n-                    }\n+                String s = formatOptDelimiter(bytes, fromIndex, toIndex);\n+                if (s != null) {\n+                    out.append(s);\n@@ -413,0 +403,2 @@\n+                    out.append(prefix);\n+                    toHexDigits(out, bytes[fromIndex]);\n@@ -419,0 +411,1 @@\n+                    out.append(suffix);\n@@ -420,1 +413,0 @@\n-                out.append(suffix);\n@@ -441,0 +433,1 @@\n+        char sep;\n@@ -445,0 +438,2 @@\n+\n+        boolean ucase = digitCase == Case.UPPERCASE;\n@@ -450,2 +445,4 @@\n-                rep[i * 2] = (byte)toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 2 + 1] = (byte)toLowHexDigit(bytes[fromIndex + i]);\n+                short pair = HexDigits.digitPair(bytes[fromIndex + i], ucase);\n+                int pos = i * 2;\n+                rep[pos] = (byte)pair;\n+                rep[pos + 1] = (byte)(pair >>> 8);\n@@ -453,1 +450,1 @@\n-        } else if (delimiter.length() == 1 && delimiter.charAt(0) < 256) {\n+        } else if (delimiter.length() == 1 && (sep = delimiter.charAt(0)) < 256) {\n@@ -456,1 +453,0 @@\n-            char sep = delimiter.charAt(0);\n@@ -458,2 +454,3 @@\n-            rep[0] = (byte) toHighHexDigit(bytes[fromIndex]);\n-            rep[1] = (byte) toLowHexDigit(bytes[fromIndex]);\n+            short pair = HexDigits.digitPair(bytes[fromIndex], ucase);\n+            rep[0] = (byte)pair;\n+            rep[1] = (byte)(pair >>> 8);\n@@ -461,3 +458,5 @@\n-                rep[i * 3 - 1] = (byte) sep;\n-                rep[i * 3    ] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 3 + 1] = (byte) toLowHexDigit(bytes[fromIndex + i]);\n+                int pos = i * 3;\n+                pair = HexDigits.digitPair(bytes[fromIndex + i], ucase);\n+                rep[pos - 1] = (byte) sep;\n+                rep[pos] = (byte)pair;\n+                rep[pos + 1] = (byte)(pair >>> 8);\n@@ -891,1 +890,1 @@\n-        return ((ch >>> 8) == 0 && DIGITS[ch] >= 0);\n+        return ((ch >>> 7) == 0 && DIGITS[ch] >= 0);\n@@ -909,1 +908,1 @@\n-        if ((ch >>> 8) == 0 && (value = DIGITS[ch]) >= 0) {\n+        if ((ch >>> 7) == 0 && (value = DIGITS[ch]) >= 0) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -94,0 +94,24 @@\n+    \/**\n+     * For values from 0 to 255 return a short encoding a pair of hex ASCII-encoded digit characters in little-endian\n+     * @param i value to convert\n+     * @param ucase true uppper case, false lower case\n+     * @return a short encoding a pair of hex ASCII-encoded digit characters\n+     *\/\n+    public static short digitPair(int i, boolean ucase) {\n+        \/*\n+         * 0b0100_0000_0100_0000 is a selector that selects letters (1 << 6),\n+         * uppercase or not, and shifting it right by 1 bit incidentally\n+         * becomes a bit offset between cases (1 << 5).\n+         *\n+         *  ([0-9] & 0b100_0000) >> 1 => 0\n+         *  ([a-f] & 0b100_0000) >> 1 => 32\n+         *\n+         *  [0-9] -  0 => [0-9]\n+         *  [a-f] - 32 => [A-F]\n+         *\/\n+        short v = DIGITS[i & 0xff];\n+        return ucase\n+                ? (short) (v - ((v & 0b0100_0000_0100_0000) >> 1))\n+                : v;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -96,0 +96,19 @@\n+    @Benchmark\n+    public String formatLower() {\n+        return HexFormat.of().formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatUpper() {\n+        return HexFormat.of().withUpperCase().formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatLowerCached() {\n+        return LOWER_FORMATTER.formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatUpperCached() {\n+        return UPPER_FORMATTER.formatHex(bytes);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/HexFormatBench.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"}]}