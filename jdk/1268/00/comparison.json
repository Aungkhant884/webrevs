{"files":[{"patch":"@@ -479,1 +479,1 @@\n-        epsilongc g1gc graal jvmci minimal shenandoahgc zgc\"\n+        epsilongc graal jvmci minimal zgc\"\n","filename":"make\/autoconf\/jvm-features.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_GC_SHENANDOAH_SHENANDOAHBARRIERSETASSEMBLER_ZERO_HPP\n+#define CPU_ZERO_GC_SHENANDOAH_SHENANDOAHBARRIERSETASSEMBLER_ZERO_HPP\n+\n+class ShenandoahBarrierSetAssembler;\n+\n+#endif \/\/ CPU_ZERO_GC_SHENANDOAH_SHENANDOAHBARRIERSETASSEMBLER_ZERO_HPP\n","filename":"src\/hotspot\/cpu\/zero\/gc\/shenandoah\/shenandoahBarrierSetAssembler_zero.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/access.inline.hpp\"\n@@ -123,0 +124,22 @@\n+int ZeroInterpreter::Reference_get_entry(Method* method, intptr_t UNUSED, TRAPS) {\n+  JavaThread* thread = THREAD->as_Java_thread();\n+  ZeroStack* stack = thread->zero_stack();\n+  intptr_t* topOfStack = stack->sp();\n+\n+  oop ref = STACK_OBJECT(0);\n+\n+  \/\/ Shortcut if reference is known NULL\n+  if (ref == NULL) {\n+    return normal_entry(method, 0, THREAD);\n+  }\n+\n+  \/\/ Read the referent with weaker semantics, and let GCs handle the rest.\n+  const int referent_offset = java_lang_ref_Reference::referent_offset();\n+  oop obj = HeapAccess<IN_HEAP | ON_WEAK_OOP_REF>::oop_load_at(ref, referent_offset);\n+\n+  SET_STACK_OBJECT(obj, 0);\n+\n+  \/\/ No deoptimized frames on the stack\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  static int Reference_get_entry(Method* method, intptr_t UNUSED, TRAPS);\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -167,17 +167,1 @@\n-#if INCLUDE_G1GC\n-  if (UseG1GC) {\n-    \/\/ We need to generate have a routine that generates code to:\n-    \/\/   * load the value in the referent field\n-    \/\/   * passes that value to the pre-barrier.\n-    \/\/\n-    \/\/ In the case of G1 this will record the value of the\n-    \/\/ referent in an SATB buffer if marking is active.\n-    \/\/ This will cause concurrent marking to mark the referent\n-    \/\/ field as live.\n-    Unimplemented();\n-  }\n-#endif \/\/ INCLUDE_G1GC\n-\n-  \/\/ If G1 is not enabled then attempt to go through the normal entry point\n-  \/\/ Reference.get could be instrumented by jvmti\n-  return NULL;\n+  return generate_entry((address) ZeroInterpreter::Reference_get_entry);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"}]}