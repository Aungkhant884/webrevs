{"files":[{"patch":"@@ -358,1 +358,1 @@\n-    guarantee(Thread::is_JavaThread_protected(target, \/* checkTLHOnly *\/ true),\n+    guarantee(Thread::is_JavaThread_protected_by_TLH(target),\n@@ -415,1 +415,1 @@\n-    guarantee(Thread::is_JavaThread_protected(target, \/* checkTLHOnly *\/ true),\n+    guarantee(Thread::is_JavaThread_protected_by_TLH(target),\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -439,3 +439,1 @@\n-\/\/ mechanism? If checkTLHOnly is true (default is false), then we only check\n-\/\/ if the target JavaThread is protected by a ThreadsList (if any) associated\n-\/\/ with the calling Thread.\n+\/\/ mechanism?\n@@ -443,1 +441,1 @@\n-bool Thread::is_JavaThread_protected(const JavaThread* p, bool checkTLHOnly) {\n+bool Thread::is_JavaThread_protected(const JavaThread* p) {\n@@ -445,7 +443,0 @@\n-  if (!checkTLHOnly) {\n-    \/\/ Do the simplest check first:\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      \/\/ The target is protected since JavaThreads cannot exit\n-      \/\/ while we're at a safepoint.\n-      return true;\n-    }\n@@ -453,6 +444,6 @@\n-    \/\/ If the target hasn't been started yet then it is trivially\n-    \/\/ \"protected\". We assume the caller is the thread that will do\n-    \/\/ the starting.\n-    if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n-      return true;\n-    }\n+  \/\/ Do the simplest check first:\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    \/\/ The target is protected since JavaThreads cannot exit\n+    \/\/ while we're at a safepoint.\n+    return true;\n+  }\n@@ -460,7 +451,19 @@\n-    \/\/ Now make the simple checks based on who the caller is:\n-    if (current_thread == p || Threads_lock->owner() == current_thread) {\n-      \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n-      \/\/ Second check is the same as Threads_lock->owner_is_self(),\n-      \/\/ but we already have the current thread so check directly.\n-      return true;\n-    }\n+  \/\/ If the target hasn't been started yet then it is trivially\n+  \/\/ \"protected\". We assume the caller is the thread that will do\n+  \/\/ the starting.\n+  if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n+    return true;\n+  }\n+\n+  \/\/ Now make the simple checks based on who the caller is:\n+  if (current_thread == p || Threads_lock->owner() == current_thread) {\n+    \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n+    \/\/ Second check is the same as Threads_lock->owner_is_self(),\n+    \/\/ but we already have the current thread so check directly.\n+    return true;\n+  }\n+\n+  \/\/ Check the ThreadsLists associated with the calling thread (if any)\n+  \/\/ to see if one of them protects the target JavaThread:\n+  if (is_JavaThread_protected_by_TLH(p)) {\n+    return true;\n@@ -469,0 +472,21 @@\n+  \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n+  \/\/ are missing a ThreadsListHandle or other protection mechanism:\n+  \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n+  \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n+\n+  \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n+  \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n+  \/\/ we'll be able to figure out what protection mechanism is missing.\n+  assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n+         \" is not protected and not handshake safe.\", p2i(p));\n+\n+  \/\/ The target JavaThread is not protected so it is not safe to query:\n+  return false;\n+}\n+\n+\/\/ Is the target JavaThread protected by a ThreadsListHandle (TLH) associated\n+\/\/ with the calling Thread?\n+\/\/\n+bool Thread::is_JavaThread_protected_by_TLH(const JavaThread* p) {\n+  Thread* current_thread = Thread::current();\n+\n@@ -479,14 +503,1 @@\n-  if (!checkTLHOnly) {\n-    \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n-    \/\/ are missing a ThreadsListHandle or other protection mechanism:\n-    \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n-    \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n-\n-    \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n-    \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n-    \/\/ we'll be able to figure out what protection mechanism is missing.\n-    assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n-           \" is not protected and not handshake safe.\", p2i(p));\n-  }\n-\n-  \/\/ The target JavaThread is not protected so it is not safe to query:\n+  \/\/ The target JavaThread is not protected by a TLH so it is not safe to query:\n@@ -1753,1 +1764,1 @@\n-  guarantee(Thread::is_JavaThread_protected(this, \/* checkTLHOnly *\/ true),\n+  guarantee(Thread::is_JavaThread_protected_by_TLH(this),\n@@ -1759,1 +1770,1 @@\n-  guarantee(Thread::is_JavaThread_protected(this, \/* checkTLHOnly *\/ true),\n+  guarantee(Thread::is_JavaThread_protected_by_TLH(this),\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":51,"deletions":40,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -203,4 +203,5 @@\n-  \/\/ mechanism? If checkTLHOnly is true (default is false), then we only check\n-  \/\/ if the target JavaThread is protected by a ThreadsList (if any) associated\n-  \/\/ with the calling Thread.\n-  static bool is_JavaThread_protected(const JavaThread* p, bool checkTLHOnly = false);\n+  \/\/ mechanism?\n+  static bool is_JavaThread_protected(const JavaThread* p);\n+  \/\/ Is the target JavaThread protected by a ThreadsListHandle (TLH) associated\n+  \/\/ with the calling Thread?\n+  static bool is_JavaThread_protected_by_TLH(const JavaThread* p);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}