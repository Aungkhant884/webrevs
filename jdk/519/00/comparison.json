{"files":[{"patch":"@@ -86,1 +86,0 @@\n-@SuppressWarnings(\"unchecked\")\n@@ -93,0 +92,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -188,2 +188,4 @@\n-        class LocalClass {}\n-        Cloneable clone = new Cloneable() {};\n+        class LocalClass {\n+        }\n+        Cloneable clone = new Cloneable() {\n+        };\n@@ -774,1 +776,1 @@\n-                            ResolvedJavaMethod resolvedmethod = type.resolveMethod(m, context);\n+                            ResolvedJavaMethod resolvedMethod = type.resolveMethod(m, context);\n@@ -777,1 +779,1 @@\n-                                assertNull(resolvedmethod);\n+                                assertNull(resolvedMethod);\n@@ -780,1 +782,1 @@\n-                                assertEquals(m.toString(), i, resolvedmethod);\n+                                assertEquals(m.toString(), i, resolvedMethod);\n@@ -785,0 +787,19 @@\n+                \/\/ For backwards compatibility treat constructors as resolvable even though they\n+                \/\/ aren't virtually dispatched.\n+                ResolvedJavaType declaringClass = metaAccess.lookupJavaType(c);\n+                for (Constructor<?> m : c.getDeclaredConstructors()) {\n+                    ResolvedJavaMethod decl = metaAccess.lookupJavaMethod(m);\n+                    ResolvedJavaMethod impl = type.resolveMethod(decl, declaringClass);\n+                    assertEquals(m.toString(), decl, impl);\n+                }\n+                for (Method m : c.getDeclaredMethods()) {\n+                    if (isStatic(m.getModifiers())) {\n+                        \/\/ resolveMethod really shouldn't be called with static methods and the\n+                        \/\/ result is is somewhat inconsistent so just ignore them\n+                        continue;\n+                    }\n+                    ResolvedJavaMethod decl = metaAccess.lookupJavaMethod(m);\n+                    ResolvedJavaMethod impl = type.resolveMethod(decl, declaringClass);\n+                    ResolvedJavaMethod expected = isSignaturePolymorphic(decl) ? null : decl;\n+                    assertEquals(m.toString(), expected, impl);\n+                }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"}]}