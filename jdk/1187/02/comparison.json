{"files":[{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/test\/lib \/\n@@ -28,1 +29,4 @@\n- * @run main compiler.floatingpoint.NaNTest\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.floatingpoint.NaNTest\n@@ -33,0 +37,3 @@\n+import jdk.test.lib.Platform;\n+import sun.hotspot.WhiteBox;\n+\n@@ -34,0 +41,2 @@\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n@@ -68,2 +77,20 @@\n-        testFloat();\n-        testDouble();\n+        \/\/ Some platforms are known to strip signaling NaNs.\n+        \/\/ The block below can be used to except them.\n+        boolean expectStableFloats = true;\n+        boolean expectStableDoubles = true;\n+\n+        \/\/ On x86_32 without relevant SSE-enabled stubs, we are entering\n+        \/\/ native methods that use FPU instructions, and those strip the\n+        \/\/ signaling NaNs.\n+        if (Platform.isX86()) {\n+            int sse = WHITE_BOX.getIntxVMFlag(\"UseSSE\").intValue();\n+            expectStableFloats = (sse >= 1);\n+            expectStableDoubles = (sse >= 2);\n+        }\n+\n+        if (expectStableFloats) {\n+           testFloat();\n+        }\n+        if (expectStableDoubles) {\n+           testDouble();\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/NaNTest.java","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"}]}