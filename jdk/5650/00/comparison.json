{"files":[{"patch":"@@ -88,0 +88,3 @@\n+#ifndef PRODUCT\n+    _evac_failure_inject_counter(0),\n+#endif\n@@ -417,0 +420,6 @@\n+#ifndef PRODUCT\n+bool G1ParScanThreadState::inject_evacuation_failure() {\n+  return _g1h->evac_failure_injector()->evacuation_should_fail(_evac_failure_inject_counter);\n+}\n+#endif\n+\n@@ -461,1 +470,1 @@\n-  if (_g1h->evac_failure_injector()->evacuation_should_fail()) {\n+  if (inject_evacuation_failure()) {\n@@ -518,1 +527,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -101,0 +101,3 @@\n+#ifndef PRODUCT\n+  size_t _evac_failure_inject_counter;\n+#endif\n@@ -105,0 +108,2 @@\n+  bool inject_evacuation_failure() PRODUCT_RETURN_( return false; );\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,5 +75,2 @@\n-  if (G1EvacuationFailureALot) {\n-    _last_collection_with_evacuation_failure = G1CollectedHeap::heap()->total_collections();\n-    _evacuation_failure_object_count = 0;\n-    _inject_evacuation_failure_for_current_gc = false;\n-  }\n+  _last_collection_with_evacuation_failure = G1CollectedHeap::heap()->total_collections();\n+  _inject_evacuation_failure_for_current_gc = false;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-\n-  \/\/ The number of evacuations between induced failures.\n-  volatile size_t _evacuation_failure_object_count;\n@@ -62,2 +59,3 @@\n-  \/\/ Return true if it's time to cause an evacuation failure.\n-  bool evacuation_should_fail() PRODUCT_RETURN_( return false; );\n+  \/\/ Return true if it's time to cause an evacuation failure; the caller\n+  \/\/ provides the (preferably thread-local) counter to minimize performance impact.\n+  bool evacuation_should_fail(size_t& counter) PRODUCT_RETURN_( return false; );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n+\n@@ -30,1 +32,0 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n@@ -34,2 +35,2 @@\n-inline bool G1YoungGCEvacFailureInjector::evacuation_should_fail() {\n-  if (!G1EvacuationFailureALot || !_inject_evacuation_failure_for_current_gc) {\n+inline bool G1YoungGCEvacFailureInjector::evacuation_should_fail(size_t& counter) {\n+  if (!_inject_evacuation_failure_for_current_gc) {\n@@ -41,1 +42,1 @@\n-  if (++_evacuation_failure_object_count < G1EvacuationFailureALotCount) {\n+  if (++counter < G1EvacuationFailureALotCount) {\n@@ -44,1 +45,1 @@\n-  _evacuation_failure_object_count = 0;\n+  counter = 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"}]}