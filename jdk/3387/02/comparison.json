{"files":[{"patch":"@@ -957,2 +957,1 @@\n-\/\/ This hierarchy walker inspects subtypes of a given type,\n-\/\/ trying to find a \"bad\" class which breaks a dependency.\n+\/\/ This hierarchy walker inspects subtypes of a given type, trying to find a \"bad\" class which breaks a dependency.\n@@ -960,3 +959,2 @@\n-\/\/ While searching around, we ignore \"participants\", which\n-\/\/ are already known to the dependency.\n-class ClassHierarchyWalker {\n+\/\/ While searching around, we ignore \"participants\", which are already known to the dependency.\n+class AbstractClassHierarchyWalker {\n@@ -967,3 +965,2 @@\n-  \/\/ optional method descriptor to check for:\n-  Symbol* _name;\n-  Symbol* _signature;\n+  \/\/ if non-zero, tells how many witnesses to convert to participants\n+  uint _record_witnesses;\n@@ -972,2 +969,2 @@\n-  Klass*  _participants[PARTICIPANT_LIMIT+1];\n-  uint    _num_participants;\n+  Klass* _participants[PARTICIPANT_LIMIT+1];\n+  uint   _num_participants;\n@@ -975,2 +972,3 @@\n-  \/\/ cache of method lookups\n-  Method* _found_methods[PARTICIPANT_LIMIT+1];\n+#ifdef ASSERT\n+  uint _nof_requests; \/\/ one-shot walker\n+#endif \/\/ ASSERT\n@@ -978,2 +976,7 @@\n-  \/\/ if non-zero, tells how many witnesses to convert to participants\n-  uint    _record_witnesses;\n+  static PerfCounter* _perf_find_witness_anywhere_calls_count;\n+  static PerfCounter* _perf_find_witness_anywhere_steps_count;\n+  static PerfCounter* _perf_find_witness_in_calls_count;\n+\n+ protected:\n+  virtual Klass* find_witness_in(KlassDepChange* changes) = 0;\n+  virtual Klass* find_witness_anywhere(InstanceKlass* context_type) = 0;\n@@ -981,5 +984,8 @@\n-  void initialize(Klass* participant) {\n-    _record_witnesses = 0;\n-    _participants[0]  = participant;\n-    _found_methods[0] = NULL;\n-    _num_participants = 0;\n+  AbstractClassHierarchyWalker(Klass* participant) : _record_witnesses(0), _num_participants(0)\n+#ifdef ASSERT\n+  , _nof_requests(0)\n+#endif \/\/ ASSERT\n+  {\n+    for (uint i = 0; i < PARTICIPANT_LIMIT+1; i++) {\n+      _participants[i] = NULL;\n+    }\n@@ -987,4 +993,1 @@\n-      \/\/ Terminating NULL.\n-      _participants[1] = NULL;\n-      _found_methods[1] = NULL;\n-      _num_participants = 1;\n+      add_participant(participant);\n@@ -994,4 +997,7 @@\n-  void initialize_from_method(Method* m) {\n-    assert(m != NULL && m->is_method(), \"sanity\");\n-    _name      = m->name();\n-    _signature = m->signature();\n+  bool is_participant(Klass* k) {\n+    for (uint i = 0; i < _num_participants; i++) {\n+      if (_participants[i] == k) {\n+        return true;\n+      }\n+    }\n+    return false;\n@@ -1000,22 +1006,7 @@\n- public:\n-  \/\/ The walker is initialized to recognize certain methods and\/or types\n-  \/\/ as friendly participants.\n-  ClassHierarchyWalker(Klass* participant, Method* m) {\n-    initialize_from_method(m);\n-    initialize(participant);\n-  }\n-  ClassHierarchyWalker(Method* m) {\n-    initialize_from_method(m);\n-    initialize(NULL);\n-  }\n-  ClassHierarchyWalker(Klass* participant = NULL) {\n-    _name      = NULL;\n-    _signature = NULL;\n-    initialize(participant);\n-  }\n-  ClassHierarchyWalker(Klass* participants[], uint num_participants) {\n-    _name      = NULL;\n-    _signature = NULL;\n-    initialize(NULL);\n-    for (uint i = 0; i < num_participants; ++i) {\n-      add_participant(participants[i]);\n+  bool record_witness(Klass* witness) {\n+    if (_record_witnesses > 0) {\n+      --_record_witnesses;\n+      add_participant(witness);\n+      return false; \/\/ not a witness\n+    } else {\n+      return true; \/\/ is a witness\n@@ -1025,5 +1016,5 @@\n-  \/\/ This is common code for two searches:  One for concrete subtypes,\n-  \/\/ the other for concrete method implementations and overrides.\n-  bool doing_subtype_search() {\n-    return _name == NULL;\n-  }\n+  class CountingClassHierarchyIterator : public ClassHierarchyIterator {\n+   private:\n+    jlong _nof_steps;\n+   public:\n+    CountingClassHierarchyIterator(InstanceKlass* root) : ClassHierarchyIterator(root), _nof_steps(0) {}\n@@ -1031,5 +1022,4 @@\n-  int num_participants() { return _num_participants; }\n-  Klass* participant(uint n) {\n-    assert(n <= _num_participants, \"oob\");\n-    return _participants[n];\n-  }\n+    void next() {\n+      _nof_steps++;\n+      ClassHierarchyIterator::next();\n+    }\n@@ -1037,2 +1027,10 @@\n-  \/\/ Note:  If n==num_participants, returns NULL.\n-  Method* found_method(uint n) {\n+    ~CountingClassHierarchyIterator() {\n+      if (UsePerfData) {\n+        _perf_find_witness_anywhere_steps_count->inc(_nof_steps);\n+      }\n+    }\n+  };\n+\n+ public:\n+  uint num_participants() { return _num_participants; }\n+  Klass* participant(uint n) {\n@@ -1040,7 +1038,3 @@\n-    Method* fm = _found_methods[n];\n-    assert(n == _num_participants || fm != NULL, \"proper usage\");\n-    if (fm != NULL && fm->method_holder() != _participants[n]) {\n-      \/\/ Default methods from interfaces can be added to classes. In\n-      \/\/ that case the holder of the method is not the class but the\n-      \/\/ interface where it's defined.\n-      assert(fm->is_default_method(), \"sanity\");\n+    if (n < _num_participants) {\n+      return _participants[n];\n+    } else {\n@@ -1049,1 +1043,0 @@\n-    return fm;\n@@ -1053,0 +1046,1 @@\n+    assert(!is_participant(participant), \"sanity\");\n@@ -1056,2 +1050,0 @@\n-    _participants[np+1] = NULL;\n-    _found_methods[np+1] = NULL;\n@@ -1066,44 +1058,49 @@\n-  bool is_witness(Klass* k) {\n-    if (doing_subtype_search()) {\n-      if (Dependencies::is_concrete_klass(k)) {\n-        return record_witness(k); \/\/ concrete subtype\n-      } else {\n-        return false; \/\/ not a concrete class\n-      }\n-    } else if (!k->is_instance_klass()) {\n-      return false; \/\/ no methods to find in an array type\n-    } else {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      \/\/ Search class hierarchy first, skipping private implementations\n-      \/\/ as they never override any inherited methods\n-      Method* m = ik->find_instance_method(_name, _signature, Klass::PrivateLookupMode::skip);\n-      if (Dependencies::is_concrete_method(m, ik)) {\n-        return record_witness(k, m); \/\/ concrete method found\n-      } else {\n-        \/\/ Check for re-abstraction of method\n-        if (!ik->is_interface() && m != NULL && m->is_abstract()) {\n-          \/\/ Found a matching abstract method 'm' in the class hierarchy.\n-          \/\/ This is fine iff 'k' is an abstract class and all concrete subtypes\n-          \/\/ of 'k' override 'm' and are participates of the current search.\n-          ClassHierarchyWalker wf(_participants, _num_participants);\n-          Klass* w = wf.find_witness_subtype(ik);\n-          if (w != NULL) {\n-            Method* wm = InstanceKlass::cast(w)->find_instance_method(_name, _signature, Klass::PrivateLookupMode::skip);\n-            if (!Dependencies::is_concrete_method(wm, w)) {\n-              \/\/ Found a concrete subtype 'w' which does not override abstract method 'm'.\n-              \/\/ Bail out because 'm' could be called with 'w' as receiver (leading to an\n-              \/\/ AbstractMethodError) and thus the method we are looking for is not unique.\n-              return record_witness(k, m);\n-            }\n-          }\n-        }\n-        \/\/ Check interface defaults also, if any exist.\n-        Array<Method*>* default_methods = ik->default_methods();\n-        if (default_methods != NULL) {\n-          Method* dm = ik->find_method(default_methods, _name, _signature);\n-          if (Dependencies::is_concrete_method(dm, NULL)) {\n-            return record_witness(k, dm); \/\/ default method found\n-          }\n-        }\n-        return false; \/\/ no concrete method found\n-      }\n+  Klass* find_witness(InstanceKlass* context_type, KlassDepChange* changes = NULL);\n+\n+  static void init();\n+  static void print_statistics();\n+};\n+\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_calls_count = NULL;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_steps_count = NULL;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_in_calls_count       = NULL;\n+\n+void AbstractClassHierarchyWalker::init() {\n+  if (UsePerfData) {\n+    EXCEPTION_MARK;\n+    _perf_find_witness_anywhere_calls_count =\n+        PerfDataManager::create_counter(SUN_CI, \"findWitnessAnywhere\", PerfData::U_Events, CHECK);\n+    _perf_find_witness_anywhere_steps_count =\n+        PerfDataManager::create_counter(SUN_CI, \"findWitnessAnywhereSteps\", PerfData::U_Events, CHECK);\n+    _perf_find_witness_in_calls_count =\n+        PerfDataManager::create_counter(SUN_CI, \"findWitnessIn\", PerfData::U_Events, CHECK);\n+  }\n+}\n+\n+Klass* AbstractClassHierarchyWalker::find_witness(InstanceKlass* context_type, KlassDepChange* changes) {\n+  \/\/ Current thread must be in VM (not native mode, as in CI):\n+  assert(must_be_in_vm(), \"raw oops here\");\n+  \/\/ Must not move the class hierarchy during this check:\n+  assert_locked_or_safepoint(Compile_lock);\n+  assert(_nof_requests++ == 0, \"repeated requests are not supported\");\n+\n+  assert(changes == NULL || changes->involves_context(context_type), \"irrelevant dependency\");\n+\n+  \/\/ (Note: Interfaces do not have subclasses.)\n+  \/\/ If it is an interface, search its direct implementors.\n+  \/\/ (Their subclasses are additional indirect implementors. See InstanceKlass::add_implementor().)\n+  if (context_type->is_interface()) {\n+    int nof_impls = context_type->nof_implementors();\n+    if (nof_impls == 0) {\n+      return NULL; \/\/ no implementors\n+    } else if (nof_impls == 1) { \/\/ unique implementor\n+      assert(context_type != context_type->implementor(), \"not unique\");\n+      context_type = InstanceKlass::cast(context_type->implementor());\n+    } else { \/\/ nof_impls >= 2\n+      \/\/ Avoid this case: *I.m > { A.m, C }; B.m > C\n+      \/\/ Here, I.m has 2 concrete implementations, but m appears unique\n+      \/\/ as A.m, because the search misses B.m when checking C.\n+      \/\/ The inherited method B.m was getting missed by the walker\n+      \/\/ when interface 'I' was the starting point.\n+      \/\/ %%% Until this is fixed more systematically, bail out.\n+      return context_type;\n@@ -1112,0 +1109,1 @@\n+  assert(!context_type->is_interface(), \"no interfaces allowed\");\n@@ -1113,7 +1111,8 @@\n-  bool is_participant(Klass* k) {\n-    if (k == _participants[0]) {\n-      return true;\n-    } else if (_num_participants <= 1) {\n-      return false;\n-    } else {\n-      return in_list(k, &_participants[1]);\n+  if (changes != NULL) {\n+    if (UsePerfData) {\n+      _perf_find_witness_in_calls_count->inc();\n+    }\n+    return find_witness_in(changes);\n+  } else {\n+    if (UsePerfData) {\n+      _perf_find_witness_anywhere_calls_count->inc();\n@@ -1121,0 +1120,1 @@\n+    return find_witness_anywhere(context_type);\n@@ -1122,0 +1122,1 @@\n+}\n@@ -1123,3 +1124,17 @@\n-  bool record_witness(Klass* witness, Method* m) {\n-    _found_methods[_num_participants] = m;\n-    return record_witness(witness);\n+class ConcreteSubtypeFinder : public AbstractClassHierarchyWalker {\n+ private:\n+  bool is_witness(Klass* k);\n+\n+ protected:\n+  virtual Klass* find_witness_in(KlassDepChange* changes);\n+  virtual Klass* find_witness_anywhere(InstanceKlass* context_type);\n+\n+ public:\n+  ConcreteSubtypeFinder(Klass* participant = NULL) : AbstractClassHierarchyWalker(participant) {}\n+};\n+\n+bool ConcreteSubtypeFinder::is_witness(Klass* k) {\n+  if (Dependencies::is_concrete_klass(k)) {\n+    return record_witness(k); \/\/ concrete subtype\n+  } else {\n+    return false; \/\/ not a concrete class\n@@ -1127,0 +1142,1 @@\n+}\n@@ -1128,10 +1144,11 @@\n-  \/\/ It is used by is_witness() to fill up participant list (of predefined size)\n-  \/\/ and to report the first witness candidate which doesn't fit into the list.\n-  \/\/ Returns true when no more witnesses can be recorded.\n-  bool record_witness(Klass* witness) {\n-    if (_record_witnesses == 0) {\n-      return true; \/\/ report the witness\n-    } else {\n-      --_record_witnesses;\n-      add_participant(witness);\n-      return false; \/\/ record the witness\n+Klass* ConcreteSubtypeFinder::find_witness_in(KlassDepChange* changes) {\n+  \/\/ When looking for unexpected concrete types, do not look beneath expected ones:\n+  \/\/  * CX > CC > C' is OK, even if C' is new.\n+  \/\/  * CX > { CC,  C' } is not OK if C' is new, and C' is the witness.\n+  Klass* new_type = changes->new_type();\n+  assert(!is_participant(new_type), \"only old classes are participants\");\n+  \/\/ If the new type is a subtype of a participant, we are done.\n+  for (uint i = 0; i < num_participants(); i++) {\n+    if (changes->involves_context(participant(i))) {\n+      \/\/ new guy is protected from this check by previous participant\n+      return NULL;\n@@ -1140,5 +1157,16 @@\n-  static bool in_list(Klass* x, Klass** list) {\n-    for (int i = 0; ; i++) {\n-      Klass* y = list[i];\n-      if (y == NULL)  break;\n-      if (y == x)  return true;\n+  if (is_witness(new_type)) {\n+    return new_type;\n+  }\n+  \/\/ No witness found.  The dependency remains unbroken.\n+  return NULL;\n+}\n+\n+Klass* ConcreteSubtypeFinder::find_witness_anywhere(InstanceKlass* context_type) {\n+  for (CountingClassHierarchyIterator iter(context_type); !iter.done(); iter.next()) {\n+    Klass* sub = iter.klass();\n+    \/\/ Do not report participant types.\n+    if (is_participant(sub)) {\n+      \/\/ Don't walk beneath a participant since it hides witnesses.\n+      iter.skip_subclasses();\n+    } else if (is_witness(sub)) {\n+      return sub; \/\/ found a witness\n@@ -1146,1 +1174,0 @@\n-    return false;  \/\/ not in list\n@@ -1148,0 +1175,3 @@\n+  \/\/ No witness found.  The dependency remains unbroken.\n+  return NULL;\n+}\n@@ -1149,5 +1179,4 @@\n-  class CountingClassHierarchyIterator : public ClassHierarchyIterator {\n-   private:\n-    jlong _nof_steps;\n-   public:\n-    CountingClassHierarchyIterator(InstanceKlass* root) : ClassHierarchyIterator(root), _nof_steps(0) {}\n+class ConcreteMethodFinder : public AbstractClassHierarchyWalker {\n+ private:\n+  Symbol* _name;\n+  Symbol* _signature;\n@@ -1155,4 +1184,2 @@\n-    void next() {\n-      _nof_steps++;\n-      ClassHierarchyIterator::next();\n-    }\n+  \/\/ cache of method lookups\n+  Method* _found_methods[PARTICIPANT_LIMIT+1];\n@@ -1160,6 +1187,5 @@\n-    ~CountingClassHierarchyIterator() {\n-      if (UsePerfData) {\n-        _perf_find_witness_anywhere_steps_count->inc(_nof_steps);\n-      }\n-    }\n-  };\n+  bool is_witness(Klass* k);\n+\n+ protected:\n+  virtual Klass* find_witness_in(KlassDepChange* changes);\n+  virtual Klass* find_witness_anywhere(InstanceKlass* context_type);\n@@ -1167,8 +1193,0 @@\n- private:\n-  \/\/ the actual search method:\n-  Klass* find_witness_anywhere(InstanceKlass* context_type,\n-                               bool participants_hide_witnesses);\n-  \/\/ the spot-checking version:\n-  Klass* find_witness_in(KlassDepChange& changes,\n-                         InstanceKlass* context_type,\n-                         bool participants_hide_witnesses);\n@@ -1176,11 +1194,7 @@\n-  Klass* find_witness_subtype(InstanceKlass* context_type, KlassDepChange* changes = NULL) {\n-    assert(doing_subtype_search(), \"must set up a subtype search\");\n-    \/\/ When looking for unexpected concrete types,\n-    \/\/ do not look beneath expected ones.\n-    const bool participants_hide_witnesses = true;\n-    \/\/ CX > CC > C' is OK, even if C' is new.\n-    \/\/ CX > { CC,  C' } is not OK if C' is new, and C' is the witness.\n-    if (changes != NULL) {\n-      return find_witness_in(*changes, context_type, participants_hide_witnesses);\n-    } else {\n-      return find_witness_anywhere(context_type, participants_hide_witnesses);\n+  ConcreteMethodFinder(Method* m, Klass* participant = NULL) : AbstractClassHierarchyWalker(participant) {\n+    assert(m != NULL && m->is_method(), \"sanity\");\n+    _name      = m->name();\n+    _signature = m->signature();\n+\n+    for (int i = 0; i < PARTICIPANT_LIMIT+1; i++) {\n+      _found_methods[i] = NULL;\n@@ -1189,10 +1203,12 @@\n-  Klass* find_witness_definer(InstanceKlass* context_type, KlassDepChange* changes = NULL) {\n-    assert(!doing_subtype_search(), \"must set up a method definer search\");\n-    \/\/ When looking for unexpected concrete methods,\n-    \/\/ look beneath expected ones, to see if there are overrides.\n-    const bool participants_hide_witnesses = true;\n-    \/\/ CX.m > CC.m > C'.m is not OK, if C'.m is new, and C' is the witness.\n-    if (changes != NULL) {\n-      return find_witness_in(*changes, context_type, !participants_hide_witnesses);\n-    } else {\n-      return find_witness_anywhere(context_type, !participants_hide_witnesses);\n+\n+  \/\/ Note:  If n==num_participants, returns NULL.\n+  Method* found_method(uint n) {\n+    assert(n <= num_participants(), \"oob\");\n+    Method* fm = _found_methods[n];\n+    assert(n == num_participants() || fm != NULL, \"proper usage\");\n+    if (fm != NULL && fm->method_holder() != participant(n)) {\n+      \/\/ Default methods from interfaces can be added to classes. In\n+      \/\/ that case the holder of the method is not the class but the\n+      \/\/ interface where it's defined.\n+      assert(fm->is_default_method(), \"sanity\");\n+      return NULL;\n@@ -1200,0 +1216,11 @@\n+    return fm;\n+  }\n+\n+  void add_participant(Klass* participant) {\n+    AbstractClassHierarchyWalker::add_participant(participant);\n+    _found_methods[num_participants()] = NULL;\n+  }\n+\n+  bool record_witness(Klass* witness, Method* m) {\n+    _found_methods[num_participants()] = m;\n+    return AbstractClassHierarchyWalker::record_witness(witness);\n@@ -1212,3 +1239,59 @@\n-PerfCounter* ClassHierarchyWalker::_perf_find_witness_anywhere_calls_count = NULL;\n-PerfCounter* ClassHierarchyWalker::_perf_find_witness_anywhere_steps_count = NULL;\n-PerfCounter* ClassHierarchyWalker::_perf_find_witness_in_calls_count       = NULL;\n+bool ConcreteMethodFinder::is_witness(Klass* k) {\n+  if (is_participant(k)) {\n+    return false; \/\/ do not report participant types\n+  }\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    \/\/ Search class hierarchy first, skipping private implementations\n+    \/\/ as they never override any inherited methods\n+    Method* m = ik->find_instance_method(_name, _signature, Klass::PrivateLookupMode::skip);\n+    if (Dependencies::is_concrete_method(m, ik)) {\n+      return record_witness(k, m); \/\/ concrete method found\n+    } else {\n+      \/\/ Check for re-abstraction of method\n+      if (!ik->is_interface() && m != NULL && m->is_abstract()) {\n+        \/\/ Found a matching abstract method 'm' in the class hierarchy.\n+        \/\/ This is fine iff 'k' is an abstract class and all concrete subtypes\n+        \/\/ of 'k' override 'm' and are participates of the current search.\n+        ConcreteSubtypeFinder wf;\n+        for (uint i = 0; i < num_participants(); i++) {\n+          Klass* p = participant(i);\n+          wf.add_participant(p);\n+        }\n+        Klass* w = wf.find_witness(ik);\n+        if (w != NULL) {\n+          Method* wm = InstanceKlass::cast(w)->find_instance_method(_name, _signature, Klass::PrivateLookupMode::skip);\n+          if (!Dependencies::is_concrete_method(wm, w)) {\n+            \/\/ Found a concrete subtype 'w' which does not override abstract method 'm'.\n+            \/\/ Bail out because 'm' could be called with 'w' as receiver (leading to an\n+            \/\/ AbstractMethodError) and thus the method we are looking for is not unique.\n+            return record_witness(k, m);\n+          }\n+        }\n+      }\n+      \/\/ Check interface defaults also, if any exist.\n+      Array<Method*>* default_methods = ik->default_methods();\n+      if (default_methods != NULL) {\n+        Method* dm = ik->find_method(default_methods, _name, _signature);\n+        if (Dependencies::is_concrete_method(dm, NULL)) {\n+          return record_witness(k, dm); \/\/ default method found\n+        }\n+      }\n+      return false; \/\/ no concrete method found\n+    }\n+  } else {\n+    return false; \/\/ no methods to find in an array type\n+  }\n+}\n+\n+Klass* ConcreteMethodFinder::find_witness_in(KlassDepChange* changes) {\n+  \/\/ When looking for unexpected concrete methods, look beneath expected ones, to see if there are overrides.\n+  \/\/  * CX.m > CC.m > C'.m is not OK, if C'.m is new, and C' is the witness.\n+  Klass* new_type = changes->new_type();\n+  assert(!is_participant(new_type), \"only old classes are participants\");\n+  if (is_witness(new_type)) {\n+    return new_type;\n+  }\n+  \/\/ No witness found.  The dependency remains unbroken.\n+  return NULL;\n+}\n@@ -1216,9 +1299,7 @@\n-void ClassHierarchyWalker::init() {\n-  if (UsePerfData) {\n-    EXCEPTION_MARK;\n-    _perf_find_witness_anywhere_calls_count =\n-        PerfDataManager::create_counter(SUN_CI, \"findWitnessAnywhere\", PerfData::U_Events, CHECK);\n-    _perf_find_witness_anywhere_steps_count =\n-        PerfDataManager::create_counter(SUN_CI, \"findWitnessAnywhereSteps\", PerfData::U_Events, CHECK);\n-    _perf_find_witness_in_calls_count =\n-        PerfDataManager::create_counter(SUN_CI, \"findWitnessIn\", PerfData::U_Events, CHECK);\n+Klass* ConcreteMethodFinder::find_witness_anywhere(InstanceKlass* context_type) {\n+  \/\/ Walk hierarchy under a context type, looking for unexpected types.\n+  for (CountingClassHierarchyIterator iter(context_type); !iter.done(); iter.next()) {\n+    Klass* sub = iter.klass();\n+    if (is_witness(sub)) {\n+      return sub; \/\/ found a witness\n+    }\n@@ -1226,0 +1307,2 @@\n+  \/\/ No witness found.  The dependency remains unbroken.\n+  return NULL;\n@@ -1286,95 +1369,0 @@\n-Klass* ClassHierarchyWalker::find_witness_in(KlassDepChange& changes,\n-                                             InstanceKlass* context_type,\n-                                             bool participants_hide_witnesses) {\n-  assert(changes.involves_context(context_type), \"irrelevant dependency\");\n-  Klass* new_type = changes.new_type();\n-\n-  if (UsePerfData) {\n-    _perf_find_witness_in_calls_count->inc();\n-  }\n-\n-  \/\/ Current thread must be in VM (not native mode, as in CI):\n-  assert(must_be_in_vm(), \"raw oops here\");\n-  \/\/ Must not move the class hierarchy during this check:\n-  assert_locked_or_safepoint(Compile_lock);\n-\n-  int nof_impls = context_type->nof_implementors();\n-  if (nof_impls > 1) {\n-    \/\/ Avoid this case: *I.m > { A.m, C }; B.m > C\n-    \/\/ %%% Until this is fixed more systematically, bail out.\n-    \/\/ See corresponding comment in find_witness_anywhere.\n-    return context_type;\n-  }\n-\n-  assert(!is_participant(new_type), \"only old classes are participants\");\n-  if (participants_hide_witnesses) {\n-    \/\/ If the new type is a subtype of a participant, we are done.\n-    for (int i = 0; i < num_participants(); i++) {\n-      if (changes.involves_context(participant(i))) {\n-        \/\/ new guy is protected from this check by previous participant\n-        return NULL;\n-      }\n-    }\n-  }\n-\n-  if (is_witness(new_type)) {\n-    return new_type;\n-  }\n-\n-  return NULL;\n-}\n-\n-\/\/ Walk hierarchy under a context type, looking for unexpected types.\n-Klass* ClassHierarchyWalker::find_witness_anywhere(InstanceKlass* context_type, bool participants_hide_witnesses) {\n-  \/\/ Current thread must be in VM (not native mode, as in CI):\n-  assert(must_be_in_vm(), \"raw oops here\");\n-  \/\/ Must not move the class hierarchy during this check:\n-  assert_locked_or_safepoint(Compile_lock);\n-\n-  if (UsePerfData) {\n-    _perf_find_witness_anywhere_calls_count->inc();\n-  }\n-\n-  \/\/ Check the root of the sub-hierarchy first.\n-\n-  \/\/ (Note: Interfaces do not have subclasses.)\n-  \/\/ If it is an interface, search its direct implementors.\n-  \/\/ (Their subclasses are additional indirect implementors. See InstanceKlass::add_implementor().)\n-  if (context_type->is_interface()) {\n-    int nof_impls = context_type->nof_implementors();\n-    if (nof_impls == 0) {\n-      return NULL; \/\/ no implementors\n-    } else if (nof_impls == 1) { \/\/ unique implementor\n-      assert(context_type != context_type->implementor(), \"not unique\");\n-      context_type = context_type->implementor();\n-    } else { \/\/ nof_impls >= 2\n-      \/\/ Avoid this case: *I.m > { A.m, C }; B.m > C\n-      \/\/ Here, I.m has 2 concrete implementations, but m appears unique\n-      \/\/ as A.m, because the search misses B.m when checking C.\n-      \/\/ The inherited method B.m was getting missed by the walker\n-      \/\/ when interface 'I' was the starting point.\n-      \/\/ %%% Until this is fixed more systematically, bail out.\n-      return context_type;\n-    }\n-  }\n-\n-  assert(!context_type->is_interface(), \"not allowed\");\n-\n-  for (CountingClassHierarchyIterator iter(context_type); !iter.done(); iter.next()) {\n-    Klass* sub = iter.klass();\n-\n-    \/\/ Do not report participant types.\n-    if (is_participant(sub)) {\n-      \/\/ Walk beneath a participant only when it doesn't hide witnesses.\n-      if (participants_hide_witnesses) {\n-        iter.skip_subclasses();\n-      }\n-    } else if (is_witness(sub)) {\n-      return sub; \/\/ found a witness\n-    }\n-  }\n-  \/\/ No witness found.  The dependency remains unbroken.\n-  return NULL;\n-}\n-\n-\n@@ -1486,2 +1474,3 @@\n-  ClassHierarchyWalker wf(conck);\n-  return wf.find_witness_subtype(ctxk, changes);\n+  ConcreteSubtypeFinder wf(conck);\n+  Klass* k = wf.find_witness(ctxk, changes);\n+  return k;\n@@ -1497,1 +1486,1 @@\n-  ClassHierarchyWalker wf(ctxk);   \/\/ Ignore ctxk when walking.\n+  ConcreteSubtypeFinder wf(ctxk);  \/\/ Ignore ctxk when walking.\n@@ -1499,1 +1488,1 @@\n-  Klass* wit = wf.find_witness_subtype(ctxk);\n+  Klass* wit = wf.find_witness(ctxk);\n@@ -1531,2 +1520,3 @@\n-  ClassHierarchyWalker wf(uniqm->method_holder(), uniqm);\n-  return wf.find_witness_definer(ctxk, changes);\n+  ConcreteMethodFinder wf(uniqm, uniqm->method_holder());\n+  Klass* k = wf.find_witness(ctxk, changes);\n+  return k;\n@@ -1544,1 +1534,0 @@\n-  ClassHierarchyWalker wf(m);\n@@ -1546,0 +1535,1 @@\n+  ConcreteMethodFinder wf(m);\n@@ -1547,1 +1537,1 @@\n-  Klass* wit = wf.find_witness_definer(ctxk);\n+  Klass* wit = wf.find_witness(ctxk);\n@@ -1779,1 +1769,1 @@\n-  ClassHierarchyWalker::print_statistics();\n+  AbstractClassHierarchyWalker::print_statistics();\n@@ -1782,1 +1772,1 @@\n-void ClassHierarchyWalker::print_statistics() {\n+void AbstractClassHierarchyWalker::print_statistics() {\n@@ -1812,1 +1802,1 @@\n-  ClassHierarchyWalker::init();\n+  AbstractClassHierarchyWalker::init();\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":293,"deletions":303,"binary":false,"changes":596,"status":"modified"}]}