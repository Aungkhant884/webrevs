{"files":[{"patch":"@@ -1818,0 +1818,12 @@\n+\/\/ Helper for pretouch_memory. p must be int-aligned.  This must use a\n+\/\/ store, not just a load. On many OSes loads from fresh memory would be\n+\/\/ satisfied from a single mapped page containing all zeros.  We need to\n+\/\/ store something to each page to get them backed by their own memory,\n+\/\/ which is the effect we want here.  An atomic add of zero is used instead\n+\/\/ of a simple store, allowing the memory to be used while pretouch is in\n+\/\/ progress, rather than requiring users of the memory to wait until the\n+\/\/ entire range has been touched.\n+static inline void pretouch_memory_location(void* p) {\n+  Atomic::add(reinterpret_cast<int*>(p), 0, memory_order_relaxed);\n+}\n+\n@@ -1819,6 +1831,19 @@\n-  for (volatile char *p = (char*)start; p < (char*)end; p += page_size) {\n-    \/\/ Note: this must be a store, not a load. On many OSes loads from fresh\n-    \/\/ memory would be satisfied from a single mapped page containing all zeros.\n-    \/\/ We need to store something to each page to get them backed by their own\n-    \/\/ memory, which is the effect we want here.\n-    *p = 0;\n+  assert(is_power_of_2(page_size), \"page size misaligned: %zu\", page_size);\n+  assert(page_size >= sizeof(int), \"page size too small: %zu\", page_size);\n+  end = align_down(end, sizeof(int));\n+  if (start < end) {\n+    start = align_up(start, sizeof(int)); \/\/ Can't overflow or exceed end.\n+    void* last_page = align_down(reinterpret_cast<char*>(end) - 1, page_size);\n+    if (start <= last_page) {\n+      \/\/ Touch up to but not including the last page, to avoid using\n+      \/\/ possibly overflowed final increment.\n+      for (char* p = reinterpret_cast<char*>(start); p < last_page; p += page_size) {\n+        pretouch_memory_location(p);\n+      }\n+      \/\/ Touch the last (possibly partial) page.\n+      pretouch_memory_location(last_page);\n+    } else if (start < end) {\n+      \/\/ Exactly one partial page in the range.\n+      assert(pointer_delta(end, start, 1) < page_size, \"invariant\");\n+      pretouch_memory_location(start);\n+    } \/\/ Else empty range after int-alignment.\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -371,4 +371,5 @@\n-  \/\/ to make the OS back the memory range with actual memory.\n-  \/\/ Current implementation may not touch the last page if unaligned addresses\n-  \/\/ are passed.\n-  static void   pretouch_memory(void* start, void* end, size_t page_size = vm_page_size());\n+  \/\/ to make the OS back the memory range with actual memory.  Touching does not\n+  \/\/ affect the values in memory; other threads may use the pages while the\n+  \/\/ pretouch operation is in progress.\n+  \/\/ precondition: page_size is a power of 2 and >= sizeof(int).\n+  static void pretouch_memory(void* start, void* end, size_t page_size = vm_page_size());\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}