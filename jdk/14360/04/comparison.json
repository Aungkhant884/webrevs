{"files":[{"patch":"@@ -404,0 +404,4 @@\n+\n+JVM_ENTRY_NO_ENV(void, jfr_emit_data_loss(JNIEnv* env, jobject jvm, jlong bytes))\n+  EventDataLoss::commit(bytes, 0L);\n+JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,0 +165,2 @@\n+void JNICALL jfr_emit_data_loss(JNIEnv* env, jobject jvm, jlong bytes);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,2 @@\n-      (char*)\"hostTotalMemory\", (char*)\"()J\", (void*) jfr_host_total_memory\n+      (char*)\"hostTotalMemory\", (char*)\"()J\", (void*) jfr_host_total_memory,\n+      (char*)\"emitDataLoss\", (char*)\"(J)V\", (void*)jfr_emit_data_loss\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-\/\/ so they can a later staged be removed.\n+\/\/ so they can at a later staged be removed.\n@@ -66,0 +66,7 @@\n+        try {\n+            if (!SecuritySupport.exists(p)) {\n+                return true;\n+            }\n+        } catch (IOException e) {\n+            \/\/ ignore\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/FilePurger.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -644,0 +644,7 @@\n+\n+    \/**\n+     * Emit a jdk.DataLoss event for the specified amount of bytes.\n+     *\n+     * @param bytes number of bytes that were lost\n+     *\/\n+    public native void emitDataLoss(long bytes);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal;\n+\n+\/**\n+ * Error that is thrown when a chunkfile is missing. It is an Error in\n+ * order to catch it by JFR, and clearly show the repository has been\n+ * tampered with to explain any missing data.\n+ *\/\n+class MissingChunkFileError extends Error {\n+    private static final long serialVersionUID = 1L;\n+    \/**\n+     * The error message.\n+     *\n+     * @param errorMessage\n+     *\/\n+    public MissingChunkFileError(String errorMessage) {\n+        super(errorMessage);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MissingChunkFileError.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import static jdk.jfr.internal.LogLevel.ERROR;\n@@ -451,4 +452,13 @@\n-        chunk.finish(time);\n-        for (PlatformRecording r : getRecordings()) {\n-            if (r != ignoreMe && r.getState() == RecordingState.RUNNING) {\n-                r.appendChunk(chunk);\n+        if (chunk.finish(time)) {\n+            for (PlatformRecording r : getRecordings()) {\n+                if (r != ignoreMe && r.getState() == RecordingState.RUNNING) {\n+                    r.appendChunk(chunk);\n+                }\n+            }\n+        } else {\n+            if (chunk.isMissingFile()) {\n+                \/\/ With one chunkfile found missing, its likely more could've been removed too. Iterate through all recordings,\n+                \/\/ and check for missing files. This will emit more error logs that can be seen in subsequent recordings.\n+                for (PlatformRecording r : getRecordings()) {\n+                    r.removeNonExistantPaths();\n+                }\n@@ -501,6 +511,9 @@\n-            synchronized (this) {\n-                if (jvm.shouldRotateDisk()) {\n-                    rotateDisk();\n-                }\n-                if (isToDisk()) {\n-                    EventLog.update();\n+            long wait = Options.getWaitInterval();\n+            try {\n+                synchronized (this) {\n+                    if (jvm.shouldRotateDisk()) {\n+                        rotateDisk();\n+                    }\n+                    if (isToDisk()) {\n+                        EventLog.update();\n+                    }\n@@ -508,0 +521,7 @@\n+                long minDelta = PeriodicEvents.doPeriodic();\n+                wait = Math.min(minDelta, Options.getWaitInterval());\n+            } catch(Throwable t) {\n+                \/\/ Catch everything and log, but don't allow it to end the periodic task\n+                Logger.log(JFR_SYSTEM, ERROR, \"Error in Periodic task: \" + t.getClass().getName() + \", \" + t.getMessage());\n+            } finally {\n+                takeNap(wait);\n@@ -509,3 +529,0 @@\n-            long minDelta = PeriodicEvents.doPeriodic();\n-            long wait = Math.min(minDelta, Options.getWaitInterval());\n-            takeNap(wait);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import static jdk.jfr.internal.LogLevel.ERROR;\n+import static jdk.jfr.internal.LogLevel.INFO;\n@@ -35,0 +37,1 @@\n+import java.nio.file.NoSuchFileException;\n@@ -181,1 +184,1 @@\n-                           \"Unable to complete I\/O operation when dumping recording \\\"\" + getName() + \"\\\" (\" + getId() + \")\");\n+                           \"Unable to complete I\/O operation when dumping recording \\\"\" + getName() + \"\\\" (\" + getId() + \") \" + e.getClass() + \" \" + e.getMessage());\n@@ -719,11 +722,27 @@\n-                userPath.doPrivilegedIO(() -> {\n-                    try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {\n-                        long bytes = cc.transferTo(fc);\n-                        Logger.log(LogTag.JFR, LogLevel.INFO, \"Transferred \" + bytes + \" bytes from the disk repository\");\n-                        \/\/ No need to force if no data was transferred, which avoids IOException when device is \/dev\/null\n-                        if (bytes != 0) {\n-                            fc.force(true);\n-                        }\n-                    }\n-                    return null;\n-                });\n+            transferChunksWithRetry(userPath);\n+        }\n+    }\n+\n+    private void transferChunksWithRetry(WriteableUserPath userPath) throws IOException {\n+        userPath.doPrivilegedIO(() -> {\n+            try {\n+                transferChunks(userPath);\n+            } catch (NoSuchFileException nsfe) {\n+                Logger.log(LogTag.JFR, LogLevel.ERROR, \"Missing chunkfile when writing recording \\\"\" + name + \"\\\" (\" + id + \") to \" + userPath.getRealPathText() + \".\");\n+                \/\/ if one chunkfile was missing, its likely more are missing\n+                removeNonExistantPaths();\n+                \/\/ and try the transfer again\n+                transferChunks(userPath);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void transferChunks(WriteableUserPath userPath) throws IOException {\n+        try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {\n+            long bytes = cc.transferTo(fc);\n+            Logger.log(LogTag.JFR, LogLevel.INFO, \"Transferred \" + bytes + \" bytes from the disk repository\");\n+            \/\/ No need to force if no data was transferred, which avoids IOException when device is \/dev\/null\n+            if (bytes != 0) {\n+                fc.force(true);\n+            }\n@@ -881,0 +900,23 @@\n+\n+    void removeNonExistantPaths() {\n+        synchronized (recorder) {\n+            Iterator<RepositoryChunk> it = chunks.iterator();\n+            Logger.log(JFR, INFO, \"Checking for missing chunkfiles for recording \\\"\" + name + \"\\\" (\" + id + \")\");\n+            while (it.hasNext()) {\n+                RepositoryChunk chunk = it.next();\n+                if (chunk.isMissingFile()) {\n+                    String msg = \"Chunkfile \\\"\" + chunk.getFile() + \"\\\" is missing. \" +\n+                                 \"Data loss might occur from \" + chunk.getStartTime();\n+                    if (chunk.getEndTime() != null) {\n+                        msg += \" to \" + chunk.getEndTime();\n+                    }\n+                    Logger.log(JFR, ERROR, msg);\n+\n+                    JVM.getJVM().emitDataLoss(chunk.getSize());\n+\n+                    it.remove();\n+                    removed(chunk);\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":55,"deletions":13,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.time.Period;\n+import java.time.Duration;\n@@ -33,0 +35,1 @@\n+import java.util.Optional;\n@@ -34,0 +37,2 @@\n+import jdk.jfr.events.ErrorThrownEvent;\n+import jdk.jfr.internal.MissingChunkFileError;\n@@ -58,1 +63,1 @@\n-    void finish(Instant endTime) {\n+    boolean finish(Instant endTime) {\n@@ -60,1 +65,7 @@\n-            finishWithException(endTime);\n+            unFinishedRAF.close();\n+            size = SecuritySupport.getFileSize(chunkFile);\n+            this.endTime = endTime;\n+            if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {\n+                Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Chunk finished: \" + chunkFile);\n+            }\n+            return true;\n@@ -62,10 +73,9 @@\n-            Logger.log(LogTag.JFR, LogLevel.ERROR, \"Could not finish chunk. \" + e.getClass() + \" \"+ e.getMessage());\n-        }\n-    }\n-\n-    private void finishWithException(Instant endTime) throws IOException {\n-        unFinishedRAF.close();\n-        this.size = SecuritySupport.getFileSize(chunkFile);\n-        this.endTime = endTime;\n-        if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Chunk finished: \" + chunkFile);\n+            final String reason;\n+            if (isMissingFile()) {\n+                reason = \"Chunkfile \\\"\"+ getFile() + \"\\\" is missing. \" +\n+                         \"Data loss might occur from \" + getStartTime() + \" to \" + endTime;\n+            } else {\n+                reason = e.getClass() + \" \" + e.getMessage();\n+            }\n+            Logger.log(LogTag.JFR, LogLevel.ERROR, \"Could not finish chunk. \" + reason);\n+            return false;\n@@ -103,0 +113,1 @@\n+\n@@ -106,4 +117,0 @@\n-        if (!isFinished()) {\n-            finish(Instant.MIN);\n-        }\n-         delete(chunkFile);\n@@ -116,0 +123,2 @@\n+        } finally {\n+            delete(chunkFile);\n@@ -177,0 +186,8 @@\n+\n+    boolean isMissingFile() {\n+        try {\n+            return !SecuritySupport.exists(chunkFile);\n+        } catch (IOException ioe) {\n+            return true;\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"}]}