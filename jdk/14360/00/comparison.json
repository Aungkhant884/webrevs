{"files":[{"patch":"@@ -66,0 +66,7 @@\n+        try {\n+            if (!SecuritySupport.exists(p)) {\n+                return true;\n+            }\n+        } catch (IOException e) {\n+            \/\/ ignore\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/FilePurger.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal;\n+\n+\/**\n+ * Error that is thrown when a chunkfile is missing. It is an Error in\n+ * order to catch it by JFR, and clearly show the repository has been\n+ * tampered with to explain any missing data.\n+ *\/\n+class MissingChunkFileError extends Error {\n+    private static final long serialVersionUID = 1L;\n+    \/**\n+     * The error message.\n+     *\n+     * @param errorMessage\n+     *\/\n+    public MissingChunkFileError(String errorMessage) {\n+        super(errorMessage);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MissingChunkFileError.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import static jdk.jfr.internal.LogLevel.ERROR;\n@@ -34,0 +35,1 @@\n+import java.io.FileNotFoundException;\n@@ -451,4 +453,6 @@\n-        chunk.finish(time);\n-        for (PlatformRecording r : getRecordings()) {\n-            if (r != ignoreMe && r.getState() == RecordingState.RUNNING) {\n-                r.appendChunk(chunk);\n+        try {\n+            chunk.finish(time);\n+            for (PlatformRecording r : getRecordings()) {\n+                if (r != ignoreMe && r.getState() == RecordingState.RUNNING) {\n+                    r.appendChunk(chunk);\n+                }\n@@ -456,0 +460,9 @@\n+        } catch (FileNotFoundException e)  {\n+            chunk.emitMissingChunkFileEvent(time);\n+            \/\/ With one chunkfile found missing, its likely more could've been removed too. Iterate through all recordings,\n+            \/\/ and check for missing files. This will emit more error logs that can be seen in subsequent recordings.\n+            for (PlatformRecording r : getRecordings()) {\n+                r.removeNonExistantPaths();\n+            }\n+        } catch (IOException e) {\n+            Logger.log(LogTag.JFR, LogLevel.ERROR, \"Finishing chunk failed: \" + e.getClass().getName() + \", \" + e.getMessage());\n@@ -499,6 +512,9 @@\n-            synchronized (this) {\n-                if (jvm.shouldRotateDisk()) {\n-                    rotateDisk();\n-                }\n-                if (isToDisk()) {\n-                    EventLog.update();\n+            long wait = Options.getWaitInterval();\n+            try {\n+                synchronized (this) {\n+                    if (jvm.shouldRotateDisk()) {\n+                        rotateDisk();\n+                    }\n+                    if (isToDisk()) {\n+                        EventLog.update();\n+                    }\n@@ -506,0 +522,7 @@\n+                long minDelta = PeriodicEvents.doPeriodic();\n+                wait = Math.min(minDelta, Options.getWaitInterval());\n+            } catch(Throwable t) {\n+                \/\/ Catch everything and log, but don't allow it to end the periodic task\n+                Logger.log(JFR_SYSTEM, ERROR, \"Error in Periodic task: \" + t.getClass().getName() + \", \" + t.getMessage());\n+            } finally {\n+                takeNap(wait);\n@@ -507,3 +530,0 @@\n-            long minDelta = PeriodicEvents.doPeriodic();\n-            long wait = Math.min(minDelta, Options.getWaitInterval());\n-            takeNap(wait);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import static jdk.jfr.internal.LogLevel.ERROR;\n+import static jdk.jfr.internal.LogLevel.INFO;\n@@ -720,7 +722,8 @@\n-                    try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {\n-                        long bytes = cc.transferTo(fc);\n-                        Logger.log(LogTag.JFR, LogLevel.INFO, \"Transferred \" + bytes + \" bytes from the disk repository\");\n-                        \/\/ No need to force if no data was transferred, which avoids IOException when device is \/dev\/null\n-                        if (bytes != 0) {\n-                            fc.force(true);\n-                        }\n+                    try {\n+                        transferChunks(userPath);\n+                    } catch (java.nio.file.NoSuchFileException nsfe) {\n+                        Logger.log(LogTag.JFR, LogLevel.ERROR, \"Chunkfile was missing when dumping recording: \" + nsfe.getMessage() + \".\");\n+                        \/\/ if one chunkfile was missing, its likely more are missing\n+                        removeNonExistantPaths();\n+                        \/\/ and try the transfer again\n+                        transferChunks(userPath);\n@@ -733,0 +736,11 @@\n+    private void transferChunks(WriteableUserPath userPath) throws IOException {\n+        try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {\n+            long bytes = cc.transferTo(fc);\n+            Logger.log(LogTag.JFR, LogLevel.INFO, \"Transferred \" + bytes + \" bytes from the disk repository\");\n+            \/\/ No need to force if no data was transferred, which avoids IOException when device is \/dev\/null\n+            if (bytes != 0) {\n+                fc.force(true);\n+            }\n+        }\n+    }\n+\n@@ -881,0 +895,15 @@\n+\n+    void removeNonExistantPaths() {\n+        synchronized (recorder) {\n+            Iterator<RepositoryChunk> it = chunks.iterator();\n+            Logger.log(JFR, INFO, \"Checking for missing chunkfiles for recording \\\"\" + name + \"\\\" (\" + id + \")\");\n+            while (it.hasNext()) {\n+                RepositoryChunk chunk = it.next();\n+                if (chunk.isMissingFile()) {\n+                    chunk.emitMissingChunkFileEvent();\n+                    it.remove();\n+                    removed(chunk);\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.FileNotFoundException;\n@@ -32,0 +33,2 @@\n+import java.time.Period;\n+import java.time.Duration;\n@@ -33,0 +36,1 @@\n+import java.util.Optional;\n@@ -34,0 +38,2 @@\n+import jdk.jfr.events.ErrorThrownEvent;\n+import jdk.jfr.internal.MissingChunkFileError;\n@@ -58,1 +64,1 @@\n-    void finish(Instant endTime) {\n+    void finish(Instant endTime) throws FileNotFoundException, IOException {\n@@ -60,1 +66,6 @@\n-            finishWithException(endTime);\n+            unFinishedRAF.close();\n+            this.size = SecuritySupport.getFileSize(chunkFile);\n+            this.endTime = endTime;\n+            if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {\n+                Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Chunk finished: \" + chunkFile);\n+            }\n@@ -63,9 +74,5 @@\n-        }\n-    }\n-\n-    private void finishWithException(Instant endTime) throws IOException {\n-        unFinishedRAF.close();\n-        this.size = SecuritySupport.getFileSize(chunkFile);\n-        this.endTime = endTime;\n-        if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Chunk finished: \" + chunkFile);\n+            if (this.isMissingFile()) {\n+                throw new FileNotFoundException();\n+            } else {\n+                throw e;\n+            }\n@@ -103,0 +110,1 @@\n+\n@@ -106,4 +114,0 @@\n-        if (!isFinished()) {\n-            finish(Instant.MIN);\n-        }\n-         delete(chunkFile);\n@@ -116,0 +120,2 @@\n+        } finally {\n+            delete(chunkFile);\n@@ -169,0 +175,21 @@\n+\n+    boolean isMissingFile() {\n+        try {\n+            if (!SecuritySupport.exists(chunkFile)) {\n+                return true;\n+            }\n+        } catch (IOException ioe) {\n+            \/\/ ignore\n+        }\n+        return false;\n+    }\n+\n+    void emitMissingChunkFileEvent() {\n+        emitMissingChunkFileEvent(this.endTime);\n+    }\n+\n+    void emitMissingChunkFileEvent(Instant endTime) {\n+        String message = \"Chunkfile \\\"\"+ chunkFile.toString() + \"\\\" is missing.\";\n+        Logger.log(LogTag.JFR, LogLevel.ERROR, message + \" Data loss might occur from \" + startTime.toString() + (endTime != null ? \" to \" + endTime.toString() : \"\"));\n+        ErrorThrownEvent.commit(startTime.getNano(), endTime != null ? Duration.between(startTime, endTime).toNanos() : 0L, message, MissingChunkFileError.class);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":42,"deletions":15,"binary":false,"changes":57,"status":"modified"}]}