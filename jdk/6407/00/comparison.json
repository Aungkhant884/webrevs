{"files":[{"patch":"@@ -522,0 +522,1 @@\n+  Node *last_n = block->get_node(--sched_slot);\n@@ -604,0 +605,11 @@\n+    \/\/ If n is related to the last_n(last selected node)\n+    \/\/ and the latency of last_n is greater than 1, another node can be inserted between the n and last_n.\n+    if (last_n) {\n+      for (uint j = 0; j < n->req() ; j++) {\n+        if ((n->in(j) == last_n) && (n->latency(j) > 1)) { \/\/relate && latency is large\n+          n_choice = 1;\n+          break;\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2318,28 +2318,0 @@\n-  int latency = _current_latency[n->_idx];\n-\n-  \/\/ Insert in latency order (insertion sort)\n-  uint i;\n-  for ( i=0; i < _available.size(); i++ )\n-    if (_current_latency[_available[i]->_idx] > latency)\n-      break;\n-\n-  \/\/ Special Check for compares following branches\n-  if( n->is_Mach() && _scheduled.size() > 0 ) {\n-    int op = n->as_Mach()->ideal_Opcode();\n-    Node *last = _scheduled[0];\n-    if( last->is_MachIf() && last->in(1) == n &&\n-        ( op == Op_CmpI ||\n-          op == Op_CmpU ||\n-          op == Op_CmpUL ||\n-          op == Op_CmpP ||\n-          op == Op_CmpF ||\n-          op == Op_CmpD ||\n-          op == Op_CmpL ) ) {\n-\n-      \/\/ Recalculate position, moving to front of same latency\n-      for ( i=0 ; i < _available.size(); i++ )\n-        if (_current_latency[_available[i]->_idx] >= latency)\n-          break;\n-    }\n-  }\n-\n@@ -2347,1 +2319,1 @@\n-  _available.insert(i, n);\n+  _available.insert(_available.size(), n);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"}]}