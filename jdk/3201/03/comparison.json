{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -446,3 +446,5 @@\n-            Method old =\n-                getterMap.put(decapitalize(propertyName),\n-                            method);\n+            \/\/ Don't decapitalize if this is a record component name.\n+            \/\/ We only decapitalize for getXxxx(), isXxxx(), and setXxxx()\n+            String name = c.isRecord() && method.getName().equals(propertyName)\n+                    ? propertyName : decapitalize(propertyName);\n+            Method old = getterMap.put(name, method);\n@@ -865,0 +867,3 @@\n+                {\n+                    new RecordCompositeBuilder(targetClass, itemNames),\n+                },\n@@ -1142,1 +1147,1 @@\n-    private static final class CompositeBuilderViaConstructor\n+    private static class CompositeBuilderViaConstructor\n@@ -1149,1 +1154,1 @@\n-        private String[] getConstPropValues(Constructor<?> ctr) {\n+        String[] getConstPropValues(Constructor<?> ctr) {\n@@ -1174,2 +1179,1 @@\n-                return \"no constructor has either @ConstructorParameters \" +\n-                       \"or @ConstructorProperties annotation\";\n+                return reportNoConstructor();\n@@ -1199,3 +1203,1 @@\n-                String annotationName =\n-                    constr.isAnnotationPresent(ConstructorParameters.class) ?\n-                        \"@ConstructorParameters\" : \"@ConstructorProperties\";\n+                String matchingMechanism = matchingMechanism(constr);\n@@ -1209,1 +1211,1 @@\n-                        annotationName + \" annotation: \" + constr;\n+                                referenceMechannism(matchingMechanism) +\": \" + constr;\n@@ -1222,1 +1224,1 @@\n-                            annotationName + \" includes name \" + propertyName +\n+                            matchingMechanism + \" includes name \" + propertyName +\n@@ -1237,1 +1239,1 @@\n-                            annotationName + \" contains property \" +\n+                            matchingMechanism + \" contains property \" +\n@@ -1246,1 +1248,1 @@\n-                            annotationName + \" gives property \" + propertyName +\n+                            matchingMechanism + \" gives property \" + propertyName +\n@@ -1255,4 +1257,1 @@\n-                        \"More than one constructor has \" +\n-                        \"@ConstructorParameters or @ConstructorProperties \" +\n-                        \"annotation with this set of names: \" +\n-                        Arrays.toString(propertyNames);\n+                            reportMultipleConstructorsFoundFor(propertyNames);\n@@ -1295,4 +1294,1 @@\n-                                \"Constructors with @ConstructorParameters or \" +\n-                                \"@ConstructorProperties annotation \" +\n-                                \"would be ambiguous for these items: \" +\n-                                names;\n+                                    reportConstructorsAmbiguousFor(names);\n@@ -1308,1 +1304,35 @@\n-        final Object fromCompositeData(CompositeData cd,\n+        String reportNoConstructor() {\n+            return \"no constructor has either @ConstructorParameters \" +\n+                    \"or @ConstructorProperties annotation\";\n+        }\n+\n+        String matchingMechanism(Constructor<?> constr) {\n+            return constr.isAnnotationPresent(ConstructorParameters.class) ?\n+                    \"@ConstructorParameters\" : \"@ConstructorProperties\";\n+        }\n+\n+        String referenceMechannism(String matchingMechanism) {\n+            return matchingMechanism + \" annotation\";\n+        }\n+\n+        String reportMultipleConstructorsFoundFor(String... propertyNames) {\n+            return \"More than one constructor has \" +\n+                    \"@ConstructorParameters or @ConstructorProperties \" +\n+                    \"annotation with this set of names: \" +\n+                    Arrays.toString(propertyNames);\n+        }\n+\n+        String reportConstructorsAmbiguousFor(Set<String> names) {\n+            return \"Constructors with @ConstructorParameters or \" +\n+                    \"@ConstructorProperties annotation \" +\n+                    \"would be ambiguous for these items: \" +\n+                    names;\n+        }\n+\n+        String reportNoConstructorFoundFor(Set<String> names) {\n+            return  \"No constructor has either @ConstructorParameters \" +\n+                    \"or @ConstructorProperties annotation for this set of \" +\n+                    \"items: \" + names;\n+        }\n+\n+        Object fromCompositeData(CompositeData cd,\n@@ -1333,4 +1363,1 @@\n-                final String msg =\n-                    \"No constructor has either @ConstructorParameters \" +\n-                    \"or @ConstructorProperties annotation for this set of \" +\n-                    \"items: \" + ct.keySet();\n+                final String msg = reportNoConstructorFoundFor(ct.keySet());\n@@ -1382,0 +1409,67 @@\n+    \/** Builder for when the target class is a record *\/\n+    private static final class RecordCompositeBuilder\n+            extends CompositeBuilderViaConstructor {\n+\n+        RecordCompositeBuilder(Class<?> targetClass, String[] itemNames) {\n+            super(targetClass, itemNames);\n+        }\n+\n+        String[] getConstPropValues(Constructor<?> ctor) {\n+            var components = getTargetClass().getRecordComponents();\n+            var ptypes = ctor.getGenericParameterTypes();\n+            if (components.length != ptypes.length) {\n+                return super.getConstPropValues(ctor);\n+            }\n+            var len = components.length;\n+            String[] res = new String[len];\n+            for (int i=0; i < len ; i++) {\n+                if (!ptypes[i].equals(components[i].getGenericType())) {\n+                    return super.getConstPropValues(ctor);\n+                }\n+                res[i] = components[i].getName();\n+            }\n+            return res;\n+        }\n+\n+        String applicable(Method[] getters) throws InvalidObjectException {\n+            Class<?> targetClass = getTargetClass();\n+            if (!targetClass.isRecord())\n+                return \"class is not a record\";\n+\n+            return super.applicable(getters);\n+        }\n+\n+        @Override\n+        Object fromCompositeData(CompositeData cd, String[] itemNames, MXBeanMapping[] mappings)\n+                throws InvalidObjectException {\n+            return super.fromCompositeData(cd, itemNames, mappings);\n+        }\n+\n+        String reportNoConstructor() {\n+            return \"canonical constructor for record not found\";\n+        }\n+\n+        String matchingMechanism(Constructor<?> constr) {\n+            return \"canonical constructor\";\n+        }\n+\n+        String referenceMechannism(String matchingMechanism) {\n+            return matchingMechanism;\n+        }\n+\n+        String reportMultipleConstructorsFoundFor(String... propertyNames) {\n+            return \"More than one constructor has this set of names: \" +\n+                    Arrays.toString(propertyNames);\n+        }\n+\n+        String reportConstructorsAmbiguousFor(Set<String> names) {\n+            return \"Constructors would be ambiguous for these items: \" +\n+                    names;\n+        }\n+\n+        String reportNoConstructorFoundFor(Set<String> names) {\n+            return  \"No constructor has this set of \" +\n+                    \"items: \" + names;\n+        }\n+    }\n+\n@@ -1507,1 +1601,10 @@\n-        if (name.startsWith(\"get\"))\n+        var c = m.getDeclaringClass();\n+        if (c.isRecord()) {\n+            for (var rc : c.getRecordComponents()) {\n+                if (name.equals(rc.getName())\n+                        && m.getReturnType() == rc.getType()) {\n+                    rest = name;\n+                    break;\n+                }\n+            }\n+        } else if (name.startsWith(\"get\"))\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/DefaultMXBeanMappingFactory.java","additions":132,"deletions":29,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.lang.reflect.RecordComponent;\n@@ -534,0 +535,7 @@\n+        <tr>\n+          <th scope=\"row\">{@linkplain Record Record classes}<\/th>\n+          <td>{@link CompositeType}, if possible<br>\n+            (see below)<\/td>\n+          <td>{@link CompositeData}<br>\n+            (see below)<\/td>\n+        <\/tr>\n@@ -546,1 +554,2 @@\n-          <td>{@link CompositeData}<\/td>\n+          <td>{@link CompositeData}<br>\n+            (see below)<\/td>\n@@ -659,0 +668,37 @@\n+    <h3 id=\"records\">Mappings for Records<\/h3>\n+\n+    <p>A {@linkplain Record record} can be converted to a\n+      {@link CompositeType} if and only if all its\n+      {@linkplain Class#getRecordComponents() components} are\n+      convertible to open types.\n+      Otherwise, it is not convertible.<\/p>\n+\n+    <p>A record whose components are all convertible to open\n+      types, is itself convertible to a {@link CompositeType}\n+      as follows.\n+      The type name of this {@code CompositeType}\n+      is determined by the same <a href=\"#type-names\">type name rules<\/a>\n+      defined by the <a href=\"#composite-map\">mapping for other types<\/a>\n+      below. Its getters are the accessors for the {@linkplain\n+      RecordComponent record components}.<\/p>\n+\n+    <p>A record is reconstructed using its canonical constructor.\n+      The canonical constructor doesn't require the presence of\n+      {@link ConstructorParameters &#64;javax.management.ConstructorParameters}\n+      or {@code @java.beans.ConstructorProperties} annotations. If these\n+      annotations are present on the canonical constructor they\n+      will be ignored.<\/p>\n+\n+    <p>If the {@link CompositeData} from which the record is reconstructed\n+      doesn't contain all the record components, the MXBean framework\n+      will attempt to reconstruct the record in the same way than\n+      for <a href=\"#composite-map\">other types<\/a>:\n+      non canonical constructors may be used if\n+      annotated with either the {@link ConstructorParameters\n+      &#64;javax.management.ConstructorParameters} or\n+      {@code @java.beans.ConstructorProperties} annotation.<\/p>\n+\n+    <p>The complete rules for the mapping are detailed as part\n+      of the <a href=\"#composite-map\">Mapping for other types<\/a>\n+      below.<\/p>\n+\n@@ -750,1 +796,2 @@\n-    <p>Given a Java class or interface <em>J<\/em> that does not match the other\n+    <p>Given a record <em>J<\/em>, or a Java class or interface\n+      <em>J<\/em> that does not match the other\n@@ -756,1 +803,3 @@\n-    <p>The class is examined for getters using the conventions\n+    <p>If <em>J<\/em> is a {@link Record}, its getters are the\n+      accessors for the {@linkplain RecordComponent record components}.\n+      Otherwise, the class is examined for getters using the conventions\n@@ -787,1 +836,7 @@\n-    <p>Notice that the first character (or code point) is converted to\n+    <p>If the class is a {@link Record} and the getter is a component\n+       accessor for a record component {@code name} of type <em>T<\/em>,\n+       then the item in the {@code CompositeType} has the same name\n+       as the record component, and has type <em>opentype(T)<\/em>.<\/p>\n+\n+    <p>Notice that unless the class is a {@code Record}, the\n+      first character (or code point) is converted to\n@@ -849,0 +904,11 @@\n+      <li><p>Otherwise, if <em>J<\/em> is a {@link Record} class,\n+        and the record canonical constructor is applicable,\n+        an instance of <em>J<\/em> is reconstructed by calling\n+        the record canonical constructor.\n+        The canonical constructor, if applicable, is called\n+        with the appropriate reconstructed items from the\n+        {@code CompositeData}. The canonical constructor\n+        is <em>applicable<\/em> if all the properties named\n+        by the record components are present in the\n+        {@code CompositeData}.<\/p><\/li>\n+\n@@ -965,0 +1031,9 @@\n+      <li>Record:\n+\n+        <blockquote>\n+          <pre>\n+ public record NamedNumber(int number, String name) {}\n+          <\/pre>\n+        <\/blockquote>\n+      <\/li>\n+\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MXBean.java","additions":80,"deletions":5,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,609 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.InvalidObjectException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.management.Attribute;\n+import javax.management.ConstructorParameters;\n+import javax.management.JMX;\n+import javax.management.MBeanException;\n+import javax.management.MBeanServer;\n+import javax.management.MBeanServerConnection;\n+import javax.management.MBeanServerFactory;\n+import javax.management.NotCompliantMBeanException;\n+import javax.management.ObjectName;\n+import javax.management.StandardMBean;\n+import javax.management.openmbean.CompositeData;\n+import javax.management.openmbean.CompositeDataSupport;\n+import javax.management.openmbean.CompositeDataView;\n+import javax.management.openmbean.CompositeType;\n+import javax.management.openmbean.OpenDataException;\n+import javax.management.openmbean.OpenType;\n+import javax.management.remote.JMXConnector;\n+import javax.management.remote.JMXConnectorServer;\n+import javax.management.remote.JMXConnectorServerFactory;\n+import javax.management.remote.JMXServiceURL;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * @test\n+ * @bug 8264124\n+ * @run testng RecordsMXBeanTest\n+ *\/\n+public class RecordsMXBeanTest {\n+    \/\/ Simple record with open types\n+    public record Data(List<Integer> ints, Map<String, List<String>> map) {}\n+    \/\/ Used to test case in component names\n+    public record MixedCases(int Foo, int BarBar, int foo) {}\n+    \/\/ Used to test nested records\n+    public record DataPoint(Data x, Data y, MixedCases mixed) {}\n+    \/\/ Used to test reconstruction using a non-canonical constructor\n+    public record Annotated(int x, int y, int z) {\n+        @ConstructorParameters(value = {\"y\", \"x\"})\n+        public Annotated(int y, int x) {\n+            this(x,y,-1);\n+        }\n+    }\n+    \/\/ Used to test reconstruction using a static `from` method\n+    public record FromMethod(int x, int y, int z) {\n+        public static FromMethod from(CompositeData cd) {\n+            int x = (int) cd.get(\"x\");\n+            int y = (int) cd.get(\"y\");\n+            int z = -x -y;\n+            return new FromMethod(x, y, z);\n+        }\n+    }\n+    \/\/ A record that exposes methods that look like\n+    \/\/ getters... These should be ignored - only the\n+    \/\/ record components should be considered.\n+    public record Trickster(int x, int y) {\n+        public int getZ() { return -x() -y(); }\n+        public boolean isTricky() { return true; }\n+    }\n+    \/\/ A regular class similar to the Trickster,\n+    \/\/ but this time z and tricky should appear\n+    \/\/ in the composite data\n+    public static class TricksterToo {\n+        final int x;\n+        final int y;\n+        @ConstructorParameters({\"x\", \"y\"})\n+        public TricksterToo(int x, int y) {\n+            this.x = x; this.y = y;\n+        }\n+        public int getX() { return x; }\n+        public int getY() { return y; }\n+        public int getZ() { return -x -y; }\n+        public boolean isTricky() { return true; }\n+    }\n+    \/\/ A record with a conflicting name getX\/x which\n+    \/\/ should ensure that non component getters are ignored\n+    public record RWithGetter(int x, int y) {\n+        public int getX() { return x;}\n+    }\n+    \/\/ A record with an annotated cannonical constructor.\n+    \/\/ Annotation should be ignored\n+    public record WithAnno(int x, int y) {\n+        @ConstructorParameters({\"y\", \"x\"})\n+        public WithAnno(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+    \/\/ A record that implements CompositeDataView\n+    public record WithCDV(int x, int y) implements CompositeDataView {\n+        @Override\n+        public CompositeData toCompositeData(CompositeType ct) {\n+            if (ct == null) return null;\n+            try {\n+                return new CompositeDataSupport(ct, new String[]{\"x\", \"y\"}, new Object[]{x() + 1, y() + 2});\n+            } catch (OpenDataException x) {\n+                throw new IllegalArgumentException(ct.getTypeName(), x);\n+            }\n+        }\n+    }\n+\n+    \/\/ A read only MXBean interface\n+    public interface RecordsMXBean {\n+        public Data getData();\n+        public DataPoint getDataPoint();\n+        public default Map<String, DataPoint> allPoints() {\n+            return Map.of(\"allpoints\", getDataPoint());\n+        }\n+    }\n+\n+    \/\/ A read-write MXBean interface\n+    public interface Records2MXBean extends RecordsMXBean {\n+        public void setDataPoint(DataPoint point);\n+    }\n+\n+    \/\/ An implementation of the read-only MXBean interface which is\n+    \/\/ itself a record (this is already supported)\n+    public record Records(DataPoint point) implements RecordsMXBean {\n+        @Override\n+        public Data getData() {\n+            return point().x();\n+        }\n+\n+        @Override\n+        public DataPoint getDataPoint() {\n+            return point();\n+        }\n+\n+        @Override\n+        public Map<String, DataPoint> allPoints() {\n+            return Map.of(\"point\", point());\n+        }\n+    }\n+\n+    \/\/ An implementation of the read-write MXBean interface\n+    public static class Records2 implements Records2MXBean {\n+        private volatile DataPoint point = new DataPoint(\n+                new Data(List.of(1, 2), Map.of(\"foo\", List.of(\"bar\"))),\n+                new Data(List.of(3, 4), Map.of(\"bar\", List.of(\"foo\"))),\n+                new MixedCases(5, 6, 7)\n+                );\n+\n+        @Override\n+        public Data getData() {\n+            return point.x;\n+        }\n+\n+        @Override\n+        public DataPoint getDataPoint() {\n+            return point;\n+        }\n+\n+        @Override\n+        public void setDataPoint(DataPoint point) {\n+            this.point = point;\n+        }\n+\n+        @Override\n+        public Map<String, DataPoint> allPoints() {\n+            return Map.of(\"point\", point);\n+        }\n+    }\n+\n+    \/\/ A complex MXBean interface used to test reconstruction\n+    \/\/ of records through non-canonical annotated constructors\n+    \/\/ and static `from` method\n+    public interface ComplexMXBean {\n+        Annotated getAnnotated();\n+        void setAnnotated(Annotated annotated);\n+        FromMethod getFromMethod();\n+        void setFromMethod(FromMethod fromMethod);\n+        Trickster getTrickster();\n+        void setTrickster(Trickster trick);\n+        TricksterToo getTricksterToo();\n+        void setTricksterToo(TricksterToo trick);\n+        RWithGetter getR();\n+        void setR(RWithGetter r);\n+        WithAnno getWithAnno();\n+        void setWithAnno(WithAnno r);\n+        WithCDV getCDV();\n+        void setCDV(WithCDV cdv);\n+    }\n+\n+    \/\/ An implementation of the complex MXBean interface\n+    public static class Complex implements ComplexMXBean {\n+        private volatile Annotated annotated = new Annotated(1, 2, 3);\n+        private volatile FromMethod fromMethod = new FromMethod(1, 2, 3);\n+        private volatile Trickster trickster = new Trickster(4, 5);\n+        private volatile TricksterToo too = new TricksterToo(6, 7);\n+        private volatile RWithGetter r = new RWithGetter(8, 9);\n+        private volatile WithAnno withAnno = new WithAnno(10, 11);\n+        private volatile WithCDV withCDV = new WithCDV(12, 13);\n+\n+        @Override\n+        public Annotated getAnnotated() {\n+            return annotated;\n+        }\n+\n+        @Override\n+        public void setAnnotated(Annotated annotated) {\n+            this.annotated = annotated;\n+        }\n+\n+        @Override\n+        public FromMethod getFromMethod() {\n+            return fromMethod;\n+        }\n+\n+        @Override\n+        public void setFromMethod(FromMethod fromMethod) {\n+            this.fromMethod = fromMethod;\n+        }\n+\n+        @Override\n+        public Trickster getTrickster() {\n+            return trickster;\n+        }\n+\n+        @Override\n+        public void setTrickster(Trickster trickster) {\n+            this.trickster = trickster;\n+        }\n+\n+        @Override\n+        public TricksterToo getTricksterToo() {\n+            return too;\n+        }\n+\n+        @Override\n+        public void setTricksterToo(TricksterToo trick) {\n+            too = trick;\n+        }\n+\n+        @Override\n+        public RWithGetter getR() {\n+            return r;\n+        }\n+\n+        @Override\n+        public void setR(RWithGetter r) {\n+            this.r = r;\n+        }\n+\n+        @Override\n+        public WithAnno getWithAnno() {\n+            return withAnno;\n+        }\n+\n+        @Override\n+        public void setWithAnno(WithAnno r) {\n+            this.withAnno = r;\n+        }\n+\n+        @Override\n+        public WithCDV getCDV() {\n+            return withCDV;\n+        }\n+\n+        @Override\n+        public void setCDV(WithCDV cdv) {\n+            withCDV = cdv;\n+        }\n+    }\n+\n+    public record NonCompliantR1(int x, Object y) {\n+        public int getX() { return x;}\n+    }\n+    public interface NC1MXBean {\n+        public NonCompliantR1 getNCR1();\n+    }\n+    public class NC1 implements NC1MXBean {\n+        private volatile NonCompliantR1 ncr1 = new NonCompliantR1(1,2);\n+\n+        @Override\n+        public NonCompliantR1 getNCR1() {\n+            return ncr1;\n+        }\n+    }\n+\n+    public record NonCompliantR2(int x, List<? super Integer> y) {\n+    }\n+    public interface NC2MXBean {\n+        public NonCompliantR2 getNCR2();\n+    }\n+    public class NC2 implements NC2MXBean {\n+        private volatile NonCompliantR2 ncr2 = new NonCompliantR2(1,List.of(2));\n+\n+        @Override\n+        public NonCompliantR2 getNCR2() {\n+            return ncr2;\n+        }\n+    }\n+\n+    @DataProvider(name = \"wrapInStandardMBean\")\n+    Object[][] wrapInStandardMBean() {\n+        return new Object[][] {\n+                new Object[] {\"wrapped in StandardMBean\", true},\n+                new Object[] {\"not wrapped in StandardMBean\", false}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"wrapInStandardMBean\")\n+    public void testLocal(String desc, boolean standard) throws Exception {\n+        \/\/ test local\n+        System.out.println(\"\\nTest local \" + desc);\n+        MBeanServer mbs = MBeanServerFactory.newMBeanServer(\"test\");\n+        test(mbs, mbs, standard);\n+    }\n+\n+    @Test(dataProvider = \"wrapInStandardMBean\")\n+    public void testRemote(String desc, boolean standard) throws Exception {\n+        \/\/ test remote\n+        System.out.println(\"\\nTest remote \" + desc);\n+        MBeanServer mbs = MBeanServerFactory.newMBeanServer(\"test\");\n+        final JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:\/\/\");\n+        JMXConnectorServer server =\n+                JMXConnectorServerFactory.newJMXConnectorServer(url, null, mbs);\n+        server.start();\n+        try {\n+            JMXConnector ctor = server.toJMXConnector(null);\n+            ctor.connect();\n+            try {\n+                test(mbs, ctor.getMBeanServerConnection(), standard);\n+            } finally {\n+                ctor.close();\n+            }\n+        } finally {\n+            server.stop();\n+        }\n+    }\n+\n+    private void test(MBeanServer server, MBeanServerConnection connection, boolean standard)\n+            throws Exception {\n+\n+        \/\/ test RecordsMXBean via MBeanServerConnection\n+        assertTrue(JMX.isMXBeanInterface(RecordsMXBean.class));\n+        Records records = new Records(new DataPoint(\n+                new Data(List.of(1, 2), Map.of(\"foo\", List.of(\"bar\"))),\n+                new Data(List.of(3, 4), Map.of(\"bar\", List.of(\"foo\"))),\n+                new MixedCases(5, 6, 7)\n+        ));\n+        ObjectName recname = new ObjectName(\"test:type=Records\");\n+        var mbean = standard\n+                ? new StandardMBean(records, RecordsMXBean.class, true)\n+                : records;\n+        server.registerMBean(mbean, recname);\n+        RecordsMXBean mxBean = JMX.newMXBeanProxy(connection, recname, RecordsMXBean.class);\n+        Records retrieved = new Records(mxBean.getDataPoint());\n+        assertEquals(retrieved, records);\n+        assertEquals(mxBean.allPoints(), records.allPoints());\n+\n+        \/\/ test Records2MXBean via MBeanServerConnection\n+        assertTrue(JMX.isMXBeanInterface(Records2MXBean.class));\n+        Records2 records2 = new Records2();\n+        assertEquals(records2.allPoints(), records.allPoints());\n+        ObjectName recname2 = new ObjectName(\"test:type=Records2\");\n+        var mbean2 = standard\n+                ? new StandardMBean(records2, Records2MXBean.class, true)\n+                : records2;\n+        server.registerMBean(mbean2, recname2);\n+        Records2MXBean mxBean2 = JMX.newMXBeanProxy(connection, recname2, Records2MXBean.class);\n+        Records retrieved2 = new Records(mxBean2.getDataPoint());\n+        assertEquals(retrieved2, records);\n+        assertEquals(mxBean2.allPoints(), records.allPoints());\n+\n+        \/\/ mutate Records2MXBean via MBeanServerConnection\n+        DataPoint point2 = new DataPoint(records.point().y(), records.point().x(), records.point().mixed());\n+        mxBean2.setDataPoint(point2);\n+        assertEquals(mxBean2.getDataPoint(), point2);\n+        assertEquals(mxBean2.allPoints(), Map.of(\"point\", point2));\n+\n+        \/\/ test reconstruction through non-canonical constructor and from method\n+        Complex complex = new Complex();\n+        var complexMBean = new StandardMBean(complex, ComplexMXBean.class, true);\n+        ObjectName recname3 = new ObjectName(\"test:type=Complex\");\n+        var mbean3 = standard ? complexMBean : complex;\n+        server.registerMBean(complexMBean, recname3);\n+        ComplexMXBean mBean5 = JMX.newMXBeanProxy(connection, recname3, ComplexMXBean.class);\n+        var annotated = mBean5.getAnnotated();\n+        assertEquals(annotated, complex.getAnnotated());\n+        \/\/ Obtain the CompositeData that corresponds to the Annotated record\n+        var cd = (CompositeData) complexMBean.getAttribute(\"Annotated\");\n+        var ct = cd.getCompositeType();\n+        \/\/ Construct a version of the \"Annotated\" composite data where z is missing\n+        var nct = new CompositeType(ct.getTypeName(), ct.getDescription(), new String[] {\"x\", \"y\"},\n+                new String[] {ct.getDescription(\"x\"), ct.getDescription(\"y\")},\n+                new OpenType<?>[] {ct.getType(\"x\"), ct.getType(\"y\")});\n+        var ncd = new CompositeDataSupport(nct, new String[] {\"x\", \"y\"},\n+                new Object[] {cd.get(\"x\"), cd.get(\"y\")});\n+        \/\/ send the modified composite data to remote, and check\n+        \/\/ that the non-canonical constructor was called (this constructor\n+        \/\/ sets z = -1)\n+        connection.setAttribute(recname3, new Attribute(\"Annotated\", ncd));\n+        var annotated2 = mBean5.getAnnotated();\n+        assertEquals(annotated2.x(), annotated.x());\n+        assertEquals(annotated2.y(), annotated2.y());\n+        assertEquals(annotated2.z(), -1);\n+        \/\/ gets the FromMethod record, and check that the `from` method\n+        \/\/ we defined was called. When reconstructed from our `from` method,\n+        \/\/ z will be set to z = -x -y;\n+        var from = mBean5.getFromMethod();\n+        assertEquals(from.x(), 1);\n+        assertEquals(from.y(), 2);\n+        assertEquals(from.z(), -3);\n+        mBean5.setFromMethod(new FromMethod(2, 1, 3));\n+        from = mBean5.getFromMethod();\n+        assertEquals(from.x(), 2);\n+        assertEquals(from.y(), 1);\n+        assertEquals(from.z(), -3);\n+        \/\/ checks that the presence of getter-like methods doesn't\n+        \/\/ prevent the record from being reconstructed.\n+        var cdtrick = (CompositeData) connection.getAttribute(recname3, \"Trickster\");\n+        println(\"tricky\", cdtrick);\n+        assertEquals(cdtrick.getCompositeType().keySet(), Set.of(\"x\", \"y\"));\n+        var trick = mBean5.getTrickster();\n+        assertEquals(trick.x(), 4);\n+        assertEquals(trick.y(), 5);\n+        assertEquals(trick.getZ(), -9);\n+        assertTrue(trick.isTricky());\n+        mBean5.setTrickster(new Trickster(5, 4));\n+        trick = mBean5.getTrickster();\n+        assertEquals(trick.x(), 5);\n+        assertEquals(trick.y(), 4);\n+        assertEquals(trick.getZ(), -9);\n+        assertTrue(trick.isTricky());\n+        \/\/ get the \"TricksterToo\" composite data\n+        var cdtoo = (CompositeData) connection.getAttribute(recname3, \"TricksterToo\");\n+        println(\"tricky too\", cdtoo);\n+        assertEquals(cdtoo.getCompositeType().keySet(), Set.of(\"x\", \"y\", \"tricky\", \"z\"));\n+        var too = mBean5.getTricksterToo();\n+        assertEquals(too.getX(), 6);\n+        assertEquals(too.getY(), 7);\n+        assertEquals(too.getZ(), -13);\n+        assertTrue(too.isTricky());\n+        mBean5.setTricksterToo(new TricksterToo(7, 6));\n+        too = mBean5.getTricksterToo();\n+        assertEquals(too.getX(), 7);\n+        assertEquals(too.getY(), 6);\n+        assertEquals(too.getZ(), -13);\n+        assertTrue(too.isTricky());\n+\n+        \/\/ builds a composite data that contains more fields than\n+        \/\/ the record...\n+        var cdtype = cdtrick.getCompositeType();\n+        var itemNames = List.of(\"x\", \"y\", \"z\", \"tricky\").toArray(new String[0]);\n+        var itemDesc = Stream.of(itemNames)\n+                .map(cdtoo.getCompositeType()::getDescription)\n+                .toArray(String[]::new);\n+        var itemTypes = Stream.of(itemNames)\n+                .map(cdtoo.getCompositeType()::getType)\n+                .toArray(OpenType<?>[]::new);\n+        var cdtype2 = new CompositeType(cdtype.getTypeName(),\n+                cdtype.getDescription(), itemNames, itemDesc, itemTypes);\n+        var values = Stream.of(itemNames).map(cdtoo::get).toArray();\n+        var cdtrick2 = new CompositeDataSupport(cdtype2, itemNames, values);\n+        \/\/ sets the composite data with more fields - the superfluous fields\n+        \/\/ should be ignored...\n+        connection.setAttribute(recname3, new Attribute(\"Trickster\", cdtrick2));\n+        \/\/ get the composite data we just set\n+        var cdtrick3 = (CompositeData) connection.getAttribute(recname3, \"Trickster\");\n+        assertEquals(cdtrick3.getCompositeType().keySet(), Set.of(\"x\", \"y\"));\n+        \/\/ get the \"Trickster\" through the MXBean proxy\n+        var trick3 = mBean5.getTrickster();\n+        assertEquals(trick3.x(), 6);\n+        assertEquals(trick3.y(), 7);\n+        assertEquals(trick3.getZ(), -13);\n+        assertEquals(trick3.isTricky(), true);\n+        \/\/ get record that has both x() and getX()\n+        var rWithGetter = mBean5.getR();\n+        assertEquals(rWithGetter.x(), rWithGetter.getX());\n+        assertEquals(rWithGetter.x(), 8);\n+        assertEquals(rWithGetter.y(), 9);\n+        mBean5.setR(new RWithGetter(rWithGetter.y(), rWithGetter.x()));\n+        rWithGetter = mBean5.getR();\n+        assertEquals(rWithGetter.x(), rWithGetter.getX());\n+        assertEquals(rWithGetter.x(), 9);\n+        assertEquals(rWithGetter.y(), 8);\n+\n+        var withAnno = mBean5.getWithAnno();\n+        assertEquals(withAnno.x(), 10);\n+        assertEquals(withAnno.y(), 11);\n+        withAnno = new WithAnno(12, 13);\n+        mBean5.setWithAnno(withAnno);\n+        withAnno = mBean5.getWithAnno();\n+        assertEquals(withAnno.x(), 12);\n+        assertEquals(withAnno.y(), 13);\n+\n+        \/\/ WithCDV.toCompositeData adds 1 to x and 2 to y,\n+        \/\/ we can check how many time it's been called\n+        \/\/ by looking at the values for x and y.\n+        var cdv = mBean5.getCDV();\n+        assertEquals(cdv.x(), 13 \/* 12 + 1 *\/, \"x\");\n+        assertEquals(cdv.y(), 15 \/* 13 + 2 *\/, \"y\");\n+        mBean5.setCDV(new WithCDV(14, 15));\n+        cdv = mBean5.getCDV();\n+        assertEquals(cdv.x(), 16 \/* 14 + 1*2 *\/, \"x\");\n+        assertEquals(cdv.y(), 19 \/* 15 + 2*2 *\/, \"y\");\n+\n+        \/\/ Test non compliant records: this one has an Object (not mappable to OpenType)\n+        var recname4 = new ObjectName(\"test:type=NCR1\");\n+        var x = standard\n+                ? expectThrows(IllegalArgumentException.class,\n+                () -> new StandardMBean(new NC1(), NC1MXBean.class, true))\n+                : expectThrows(NotCompliantMBeanException.class,\n+                () -> server.registerMBean(new NC1(), recname4));\n+        reportExpected(x);\n+        assertEquals( originalCause(x).getClass(), OpenDataException.class);\n+\n+        \/\/ Test non compliant records: this one has a List<? super Integer>\n+        \/\/ (not mappable to OpenType)\n+        var recname5 = new ObjectName(\"test:type=NCR2\");\n+        var x2 = standard\n+                ? expectThrows(IllegalArgumentException.class,\n+                () -> new StandardMBean(new NC2(), NC2MXBean.class, true))\n+                : expectThrows(NotCompliantMBeanException.class,\n+                () -> server.registerMBean(new NC2(), recname5));\n+        reportExpected(x2);\n+        assertEquals( originalCause(x2).getClass(), OpenDataException.class);\n+\n+        \/\/ test that a composite data that doesn't have all the records\n+        \/\/ components prevents the record from being reconstructed.\n+        var recname6 = new ObjectName(\"test:type=Records2,instance=6\");\n+        Records2 rec2 = new Records2();\n+        var mbean6 = standard\n+                ? new StandardMBean(rec2, Records2MXBean.class, true)\n+                : rec2;\n+        server.registerMBean(mbean6, recname6);\n+        var cd6 = (CompositeData) server.getAttribute(recname6, \"DataPoint\");\n+        var cdt6 = cd6.getCompositeType();\n+        var itemNames6 = List.of(\"x\", \"mixed\")\n+                .toArray(String[]::new);\n+        var itemDesc6 = Stream.of(itemNames6)\n+                .map(cdt6::getDescription)\n+                .toArray(String[]::new);\n+        var itemTypes6 = Stream.of(itemNames6)\n+                .map(cdt6::getType)\n+                .toArray(OpenType<?>[]::new);\n+        var notmappable = new CompositeType(cdt6.getTypeName(),\n+                cdt6.getDescription(),\n+                itemNames6,\n+                itemDesc6,\n+                itemTypes6);\n+        var itemValues6 = Stream.of(itemNames6)\n+                .map(cd6::get)\n+                .toArray();\n+        var cd6mod = new CompositeDataSupport(notmappable, itemNames6, itemValues6);\n+        var attribute6 = new Attribute(\"DataPoint\", cd6mod);\n+        var x3 = expectThrows(MBeanException.class,\n+                standard ? () -> ((StandardMBean)mbean6).setAttribute(attribute6)\n+                         : () -> server.setAttribute(recname6, attribute6));\n+        reportExpected(x3);\n+        assertEquals(originalCause(x3).getClass(), InvalidObjectException.class);\n+\n+    }\n+\n+    static final void reportExpected(Throwable x) {\n+        System.out.println(\"\\nGot expected exception: \" + x);\n+        Throwable cause = x;\n+        while ((cause = cause.getCause()) != null) {\n+            System.out.println(\"\\tCaused by: \" + cause);\n+        }\n+    }\n+\n+    static final Throwable originalCause(Throwable t) {\n+        while (t.getCause() != null) t = t.getCause();\n+        return t;\n+    }\n+\n+    static void println(String name, CompositeData cd) {\n+        var cdt = cd.getCompositeType();\n+        System.out.printf(\"%s: %s %s\\n\", name, cdt.getTypeName(),\n+                cdt.keySet().stream()\n+                .map(k -> k + \"=\" + cd.get(k))\n+                .collect(Collectors.joining(\", \", \"{ \", \" }\")));\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/management\/mxbean\/RecordsMXBeanTest.java","additions":609,"deletions":0,"binary":false,"changes":609,"status":"added"}]}