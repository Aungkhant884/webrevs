{"files":[{"patch":"@@ -505,2 +505,0 @@\n-  void do_irem();\n-\n@@ -547,1 +545,0 @@\n-  Node*   jump_if_join(Node* iffalse, Node* iftrue);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -221,11 +221,0 @@\n-\/\/ return Region node\n-Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {\n-  Node *region  = new RegionNode(3); \/\/ 2 results\n-  record_for_igvn(region);\n-  region->init_req(1, iffalse);\n-  region->init_req(2, iftrue );\n-  _gvn.set_type(region, Type::CONTROL);\n-  region = _gvn.transform(region);\n-  set_control (region);\n-  return region;\n-}\n@@ -1161,44 +1150,0 @@\n-void Parse::do_irem() {\n-  \/\/ Must keep both values on the expression-stack during null-check\n-  zero_check_int(peek());\n-  \/\/ Compile-time detect of null-exception?\n-  if (stopped())  return;\n-\n-  Node* b = pop();\n-  Node* a = pop();\n-\n-  const Type *t = _gvn.type(b);\n-  if (t != Type::TOP) {\n-    const TypeInt *ti = t->is_int();\n-    if (ti->is_con()) {\n-      int divisor = ti->get_con();\n-      \/\/ check for positive power of 2\n-      if (divisor > 0 &&\n-          (divisor & ~(divisor-1)) == divisor) {\n-        \/\/ yes !\n-        Node *mask = _gvn.intcon((divisor - 1));\n-        \/\/ Sigh, must handle negative dividends\n-        Node *zero = _gvn.intcon(0);\n-        IfNode *ifff = jump_if_fork_int(a, zero, BoolTest::lt, PROB_FAIR, COUNT_UNKNOWN);\n-        Node *iff = _gvn.transform( new IfFalseNode(ifff) );\n-        Node *ift = _gvn.transform( new IfTrueNode (ifff) );\n-        Node *reg = jump_if_join(ift, iff);\n-        Node *phi = PhiNode::make(reg, NULL, TypeInt::INT);\n-        \/\/ Negative path; negate\/and\/negate\n-        Node *neg = _gvn.transform( new SubINode(zero, a) );\n-        Node *andn= _gvn.transform( new AndINode(neg, mask) );\n-        Node *negn= _gvn.transform( new SubINode(zero, andn) );\n-        phi->init_req(1, negn);\n-        \/\/ Fast positive case\n-        Node *andx = _gvn.transform( new AndINode(a, mask) );\n-        phi->init_req(2, andx);\n-        \/\/ Push the merge\n-        push( _gvn.transform(phi) );\n-        return;\n-      }\n-    }\n-  }\n-  \/\/ Default case\n-  push( _gvn.transform( new ModINode(control(),a,b) ) );\n-}\n-\n@@ -2199,1 +2144,7 @@\n-    do_irem();\n+    \/\/ Must keep both values on the expression-stack during null-check\n+    zero_check_int(peek());\n+    \/\/ Compile-time detect of null-exception?\n+    if (stopped())  return;\n+    b = pop();\n+    a = pop();\n+    push(_gvn.transform(new ModINode(control(), a, b)));\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":7,"deletions":56,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Test for x % 2^n (n is constant)\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class ModPowerOf2 {\n+    @Benchmark\n+    public int testPositivePowerOf2() {\n+        int sum = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            sum += i % 1;\n+            sum += i % 2;\n+            sum += i % 4;\n+            sum += i % 8;\n+            sum += i % 16;\n+            sum += i % 32;\n+            sum += i % 64;\n+            sum += i % 128;\n+            sum += i % 256;\n+            sum += i % 512;\n+            sum += i % 1024;\n+            sum += i % 2048;\n+            sum += i % 4096;\n+            sum += i % 8192;\n+            sum += i % 16384;\n+            sum += i % 32768;\n+            sum += i % 65536;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testNegativePowerOf2() {\n+        int sum = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            sum += i % -1;\n+            sum += i % -2;\n+            sum += i % -4;\n+            sum += i % -8;\n+            sum += i % -16;\n+            sum += i % -32;\n+            sum += i % -64;\n+            sum += i % -128;\n+            sum += i % -256;\n+            sum += i % -512;\n+            sum += i % -1024;\n+            sum += i % -2048;\n+            sum += i % -4096;\n+            sum += i % -8192;\n+            sum += i % -16384;\n+            sum += i % -32768;\n+            sum += i % -65536;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testMixedPowerOf2() {\n+        int sum = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            sum += i % -1;\n+            sum += i % 1;\n+            sum += i % -2;\n+            sum += i % 2;\n+            sum += i % -4;\n+            sum += i % 4;\n+            sum += i % -8;\n+            sum += i % 8;\n+            sum += i % -16;\n+            sum += i % 16;\n+            sum += i % -32;\n+            sum += i % 32;\n+            sum += i % -64;\n+            sum += i % 64;\n+            sum += i % -128;\n+            sum += i % 128;\n+            sum += i % -256;\n+            sum += i % 256;\n+            sum += i % -512;\n+            sum += i % 512;\n+            sum += i % -1024;\n+            sum += i % 1024;\n+            sum += i % -2048;\n+            sum += i % 2048;\n+            sum += i % -4096;\n+            sum += i % 4096;\n+            sum += i % -8192;\n+            sum += i % 8192;\n+            sum += i % -16384;\n+            sum += i % 16384;\n+            sum += i % -32768;\n+            sum += i % 32768;\n+            sum += i % -65536;\n+            sum += i % 65536;\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ModPowerOf2.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}