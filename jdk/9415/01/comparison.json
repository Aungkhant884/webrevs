{"files":[{"patch":"@@ -726,1 +726,1 @@\n-  \/\/ Jump to the entry point of the i2c stub.\n+  \/\/ Jump to the entry point of the c2i stub.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1016,1 +1016,3 @@\n-                                 int& stack_slots) {\n+                                 int& stack_slots,\n+                                 int& interpreted_entry_offset,\n+                                 int& compiled_entry_offset) {\n@@ -1018,2 +1020,1 @@\n-  Address resolve(SharedRuntime::get_resolve_static_call_stub(),\n-                  relocInfo::static_call_type);\n+  Address resolve(SharedRuntime::get_resolve_static_call_stub(), relocInfo::static_call_type);\n@@ -1021,1 +1022,0 @@\n-  stack_slots = 2; \/\/ will be overwritten\n@@ -1026,1 +1026,3 @@\n-  __ enter();\n+  \/\/ i2i entry used at interp_only_mode only\n+  interpreted_entry_offset = __ pc() - start;\n+  {\n@@ -1028,1 +1030,24 @@\n-  OopMap* map = continuation_enter_setup(masm, stack_slots);\n+#ifdef ASSERT\n+    Label is_interp_only;\n+    __ ldrw(rscratch1, Address(rthread, JavaThread::interp_only_mode_offset()));\n+    __ cbnzw(rscratch1, is_interp_only);\n+    __ stop(\"enterSpecial interpreter entry called when not in interp_only_mode\");\n+    __ bind(is_interp_only);\n+#endif\n+\n+    \/\/ Read interpreter arguments into registers (this is an ad-hoc i2c adapter)\n+    __ ldr(c_rarg1, Address(esp, Interpreter::stackElementSize*2));\n+    __ ldr(c_rarg2, Address(esp, Interpreter::stackElementSize*1));\n+    __ ldr(c_rarg3, Address(esp, Interpreter::stackElementSize*0));\n+    __ push_cont_fastpath(rthread);\n+\n+    __ enter();\n+    stack_slots = 2; \/\/ will be adjusted in setup\n+    OopMap* map = continuation_enter_setup(masm, stack_slots);\n+    \/\/ The frame is complete here, but we only record it for the compiled entry, so the frame would appear unsafe,\n+    \/\/ but that's okay because at the very worst we'll miss an async sample, but we're in interp_only_mode anyway.\n+\n+    fill_continuation_entry(masm);\n+\n+    __ cmp(c_rarg2, (u1)0);\n+    __ br(Assembler::NE, call_thaw);\n@@ -1030,2 +1055,20 @@\n-  \/\/ Frame is now completed as far as size and linkage.\n-  frame_complete =__ pc() - start;\n+    address mark = __ pc();\n+    __ trampoline_call1(resolve, NULL, false);\n+\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+\n+    __ b(exit);\n+\n+    CodeBuffer* cbuf = masm->code_section()->outer();\n+    CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n+  }\n+\n+  \/\/ compiled entry\n+  __ align(CodeEntryAlignment);\n+  compiled_entry_offset = __ pc() - start;\n+\n+  __ enter();\n+  stack_slots = 2; \/\/ will be adjusted in setup\n+  OopMap* map = continuation_enter_setup(masm, stack_slots);\n+  frame_complete = __ pc() - start;\n@@ -1039,1 +1082,0 @@\n-\n@@ -1082,1 +1124,1 @@\n-  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n+  CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n@@ -1172,1 +1214,1 @@\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n+    int vep_offset = 0;\n@@ -1177,0 +1219,1 @@\n+    int interpreted_entry_offset = -1;\n@@ -1184,1 +1227,3 @@\n-                         stack_slots);\n+                         stack_slots,\n+                         interpreted_entry_offset,\n+                         vep_offset);\n@@ -1196,1 +1241,1 @@\n-    ContinuationEntry::set_enter_code(nm);\n+    ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":58,"deletions":13,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1279,1 +1279,3 @@\n-                                 int& stack_slots) {\n+                                 int& stack_slots,\n+                                 int& interpreted_entry_offset,\n+                                 int& compiled_entry_offset) {\n@@ -1301,0 +1303,3 @@\n+  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n+                         relocInfo::static_call_type);\n+\n@@ -1303,0 +1308,57 @@\n+  Label L_thaw, L_exit;\n+\n+  \/\/ i2i entry used at interp_only_mode only\n+  interpreted_entry_offset = __ pc() - start;\n+  {\n+#ifdef ASSERT\n+    Label is_interp_only;\n+    __ cmpb(Address(r15_thread, JavaThread::interp_only_mode_offset()), 0);\n+    __ jcc(Assembler::notEqual, is_interp_only);\n+    __ stop(\"enterSpecial interpreter entry called when not in interp_only_mode\");\n+    __ bind(is_interp_only);\n+#endif\n+\n+    __ pop(rax); \/\/ return address\n+    \/\/ Read interpreter arguments into registers (this is an ad-hoc i2c adapter)\n+    __ movptr(c_rarg1, Address(rsp, Interpreter::stackElementSize*2));\n+    __ movl(c_rarg2,   Address(rsp, Interpreter::stackElementSize*1));\n+    __ movl(c_rarg3,   Address(rsp, Interpreter::stackElementSize*0));\n+    __ andptr(rsp, -16); \/\/ Ensure compiled code always sees stack at proper alignment\n+    __ push(rax); \/\/ return address\n+    __ push_cont_fastpath();\n+\n+    __ enter();\n+\n+    stack_slots = 2; \/\/ will be adjusted in setup\n+    OopMap* map = continuation_enter_setup(masm, stack_slots);\n+    \/\/ The frame is complete here, but we only record it for the compiled entry, so the frame would appear unsafe,\n+    \/\/ but that's okay because at the very worst we'll miss an async sample, but we're in interp_only_mode anyway.\n+\n+    __ verify_oop(reg_cont_obj);\n+\n+    fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+\n+    \/\/ If continuation, call to thaw. Otherwise, resolve the call and exit.\n+    __ testptr(reg_is_cont, reg_is_cont);\n+    __ jcc(Assembler::notZero, L_thaw);\n+\n+    \/\/ --- Resolve path\n+\n+    \/\/ Make sure the call is patchable\n+    __ align(BytesPerWord, __ offset() + NativeCall::displacement_offset);\n+    \/\/ Emit stub for static call\n+    CodeBuffer* cbuf = masm->code_section()->outer();\n+    address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, __ pc());\n+    if (stub == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n+    __ call(resolve);\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+\n+    __ jmp(L_exit);\n+  }\n+\n+  \/\/ compiled entry\n+  __ align(CodeEntryAlignment);\n+  compiled_entry_offset = __ pc() - start;\n@@ -1315,2 +1377,0 @@\n-  Label L_thaw, L_exit;\n-\n@@ -1337,2 +1397,0 @@\n-  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n-                         relocInfo::static_call_type);\n@@ -1477,1 +1535,1 @@\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n+    int vep_offset = 0;\n@@ -1482,0 +1540,1 @@\n+    int interpreted_entry_offset = -1;\n@@ -1487,1 +1546,3 @@\n-                         stack_slots);\n+                         stack_slots,\n+                         interpreted_entry_offset,\n+                         vep_offset);\n@@ -1499,1 +1560,1 @@\n-    ContinuationEntry::set_enter_code(nm);\n+    ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":69,"deletions":8,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -656,0 +657,7 @@\n+void CompiledStaticCall::compute_entry_for_continuation_entry(const methodHandle& m, StaticCallInfo& info) {\n+  if (ContinuationEntry::is_interpreted_call(instruction_address())) {\n+    info._to_interpreter = true;\n+    info._entry = m()->get_c2i_entry();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -348,0 +348,1 @@\n+  void compute_entry_for_continuation_entry(const methodHandle& m, StaticCallInfo& info);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -1331,1 +1332,1 @@\n-    mh->_i2i_entry = mh->get_i2c_entry();\n+    mh->_i2i_entry = ContinuationEntry::interpreted_entry();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/compiledIC.hpp\"\n@@ -37,0 +38,2 @@\n+CompiledMethod* ContinuationEntry::_enter_special = nullptr;\n+int ContinuationEntry::_interpreted_entry_offset = 0;\n@@ -38,1 +41,1 @@\n-void ContinuationEntry::set_enter_code(CompiledMethod* cm) {\n+void ContinuationEntry::set_enter_code(CompiledMethod* cm, int interpreted_entry_offset) {\n@@ -41,0 +44,20 @@\n+\n+  _enter_special = cm;\n+  _interpreted_entry_offset = interpreted_entry_offset;\n+  assert(_enter_special->code_contains(compiled_entry()),    \"entry not in enterSpecial\");\n+  assert(_enter_special->code_contains(interpreted_entry()), \"entry not in enterSpecial\");\n+  assert(interpreted_entry() < compiled_entry(), \"unexpected code layout\");\n+}\n+\n+address ContinuationEntry::compiled_entry() {\n+  return _enter_special->verified_entry_point();\n+}\n+\n+address ContinuationEntry::interpreted_entry() {\n+  return _enter_special->code_begin() + _interpreted_entry_offset;\n+}\n+\n+bool ContinuationEntry::is_interpreted_call(address call_address) {\n+  assert(_enter_special->code_contains(call_address), \"call not in enterSpecial\");\n+  assert(call_address >= interpreted_entry(), \"unexpected location\");\n+  return call_address < compiled_entry();\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-  static void set_enter_code(CompiledMethod* nm); \/\/ friend SharedRuntime::generate_native_wrapper\n+  static void set_enter_code(CompiledMethod* cm, int interpreted_entry_offset);\n+  static bool is_interpreted_call(address call_address);\n@@ -60,0 +61,2 @@\n+  static CompiledMethod* _enter_special;\n+  static int _interpreted_entry_offset;\n@@ -93,0 +96,5 @@\n+  static address compiled_entry();\n+  static address interpreted_entry();\n+\n+  static CompiledMethod* enter_special() { return _enter_special; }\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1346,0 +1346,3 @@\n+        if (is_nmethod && caller_nm->method()->is_continuation_enter_intrinsic()) {\n+          ssc->compute_entry_for_continuation_entry(callee_method, static_call_info);\n+        }\n@@ -1560,0 +1563,1 @@\n+  bool enter_special = false;\n@@ -1563,0 +1567,9 @@\n+\n+    if (current->is_interp_only_mode()) {\n+      RegisterMap reg_map(current, false);\n+      frame stub_frame = current->last_frame();\n+      assert(stub_frame.is_runtime_frame(), \"must be a runtimeStub\");\n+      frame caller = stub_frame.sender(&reg_map);\n+      enter_special = caller.cb() != NULL && caller.cb()->is_compiled()\n+        && caller.cb()->as_compiled_method()->method()->is_continuation_enter_intrinsic();\n+    }\n@@ -1564,0 +1577,12 @@\n+\n+  if (current->is_interp_only_mode() && enter_special) {\n+    \/\/ enterSpecial is compiled and calls this method to resolve the call to Continuation::enter\n+    \/\/ but in interp_only_mode we need to go to the interpreted entry\n+    \/\/ The c2i won't patch in this mode -- see fixup_callers_callsite\n+    \/\/\n+    \/\/ This should probably be done in all cases, not just enterSpecial (see JDK-8218403),\n+    \/\/ but that's part of a larger fix, and the situation is worse for enterSpecial, as it has no\n+    \/\/ interpreted version.\n+    return callee_method->get_c2i_entry();\n+  }\n+\n@@ -1994,0 +2019,3 @@\n+  assert(!JavaThread::current()->is_interp_only_mode() || !nm->method()->is_continuation_enter_intrinsic()\n+    || ContinuationEntry::is_interpreted_call(return_pc), \"interp_only_mode but not in enterSpecial interpreted entry\");\n+\n@@ -2030,0 +2058,7 @@\n+      if (nm->method()->is_continuation_enter_intrinsic()) {\n+        assert(ContinuationEntry::is_interpreted_call(call->instruction_address()) == JavaThread::current()->is_interp_only_mode(),\n+          \"mode: %d\", JavaThread::current()->is_interp_only_mode());\n+        if (ContinuationEntry::is_interpreted_call(call->instruction_address())) {\n+          return;\n+        }\n+      }\n@@ -3059,1 +3094,1 @@\n-        buffer.initialize_stubs_size(64);\n+        buffer.initialize_stubs_size(128);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -123,0 +123,3 @@\n+    \/\/ the following methods have to copy the same Javadoc as in MemoryLayout, or subclasses will just show\n+    \/\/ the Object methods javadoc\n+\n@@ -128,1 +131,1 @@\n-        return name.hashCode() << Long.hashCode(alignment);\n+        return Objects.hash(name, size, alignment);\n@@ -137,1 +140,2 @@\n-     *     <li>two value layouts are considered equal if they have the same byte order (see {@link ValueLayout#order()})<\/li>\n+     *     <li>two value layouts are considered equal if they have the same {@linkplain ValueLayout#order() order},\n+     *     and {@linkplain ValueLayout#carrier() carrier}<\/li>\n@@ -144,1 +148,1 @@\n-     * @param that the object to be compared for equality with this layout.\n+     * @param other the object to be compared for equality with this layout.\n@@ -148,2 +152,2 @@\n-    public boolean equals(Object that) {\n-        if (this == that) {\n+    public boolean equals(Object other) {\n+        if (this == other) {\n@@ -153,6 +157,4 @@\n-        if (!(that instanceof AbstractLayout)) {\n-            return false;\n-        }\n-\n-        return Objects.equals(name, ((AbstractLayout) that).name) &&\n-                Objects.equals(alignment, ((AbstractLayout) that).alignment);\n+        return other instanceof AbstractLayout otherLayout &&\n+                name.equals(otherLayout.name) &&\n+                size == otherLayout.size &&\n+                alignment == otherLayout.alignment;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AbstractLayout.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -146,4 +146,3 @@\n-        if (!(other instanceof GroupLayout g)) {\n-            return false;\n-        }\n-        return kind.equals(g.kind) && elements.equals(g.elements);\n+        return other instanceof GroupLayout otherGroup &&\n+                kind == otherGroup.kind &&\n+                elements.equals(otherGroup.elements);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-     *     <li>two value layouts are considered equal if they have the same byte order (see {@link ValueLayout#order()})<\/li>\n+     *     <li>two value layouts are considered equal if they have the same {@linkplain ValueLayout#order() order},\n+     *     and {@linkplain ValueLayout#carrier() carrier}<\/li>\n@@ -594,1 +595,1 @@\n-     * @param that the object to be compared for equality with this layout.\n+     * @param other the object to be compared for equality with this layout.\n@@ -597,1 +598,1 @@\n-    boolean equals(Object that);\n+    boolean equals(Object other);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -127,1 +127,0 @@\n-     * @throws UnsupportedOperationException if this sequence layout does not have an element count.\n@@ -190,2 +189,0 @@\n-     * @throws UnsupportedOperationException if this sequence layout, or one of the nested sequence layouts being\n-     * flattened, does not have an element count.\n@@ -217,4 +214,3 @@\n-        if (!(other instanceof SequenceLayout s)) {\n-            return false;\n-        }\n-        return elemCount == s.elemCount && elementLayout.equals(s.elementLayout);\n+        return other instanceof SequenceLayout otherSeq &&\n+                elemCount == otherSeq.elemCount &&\n+                elementLayout.equals(otherSeq.elementLayout);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -105,0 +108,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -113,7 +119,3 @@\n-        if (!(other instanceof ValueLayout v)) {\n-            return false;\n-        }\n-        return carrier.equals(v.carrier) &&\n-            order.equals(v.order) &&\n-            bitSize() == v.bitSize() &&\n-            alignment == v.alignment;\n+        return other instanceof ValueLayout otherValue &&\n+                carrier.equals(otherValue.carrier) &&\n+                order.equals(otherValue.order);\n@@ -174,1 +176,1 @@\n-     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints.\n+     * @throws UnsupportedOperationException if {@code bitAlignment() > bitSize()}.\n@@ -201,0 +203,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -203,1 +208,1 @@\n-        return Objects.hash(super.hashCode(), order, bitSize(), alignment);\n+        return Objects.hash(super.hashCode(), order, carrier);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -740,1 +740,1 @@\n-     * is not supported by this map's entry set iterator.\n+     *         is not supported by this map's entry set iterator.\n@@ -742,6 +742,1 @@\n-     * prevents it from being stored in this map\n-     * @throws NullPointerException if the specified function is null, or the\n-     * specified replacement value is null, and this map does not permit null\n-     * values\n-     * @throws ClassCastException if a replacement value is of an inappropriate\n-     *         type for this map\n+     *         prevents it from being stored in this map\n@@ -749,2 +744,2 @@\n-     * @throws NullPointerException if function or a replacement value is null,\n-     *         and this map does not permit null keys or values\n+     * @throws NullPointerException if the specified function is null, or if a\n+     *         replacement value is null and this map does not permit null values\n@@ -756,1 +751,1 @@\n-     * removed during iteration\n+     *         removed during iteration\n","filename":"src\/java.base\/share\/classes\/java\/util\/Map.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n- * @LastModified: June 2022\n+ * @LastModified: July 2022\n@@ -153,0 +153,4 @@\n+    private boolean overLimit = false;\n+    public int grpLimit = 0;\n+    public int opLimit = 0;\n+    public int totalOpLimit = 0;\n@@ -379,0 +383,1 @@\n+          totalOpCount++;\n@@ -384,0 +389,1 @@\n+              totalOpCount++;\n@@ -393,0 +399,10 @@\n+      \/*\n+       * Sets the overLimit status as soon as the count of operators is over the\n+       * limit, which in turn triggers the XPathParser to report an error.\n+      *\/\n+      if (grpLimit > 0 && grpCount > grpLimit\n+              || opLimit > 0 && opCount > opLimit\n+              || totalOpLimit > 0 && totalOpCount > totalOpLimit) {\n+          overLimit = true;\n+      }\n+\n@@ -594,0 +610,1 @@\n+      overLimit = false;\n@@ -600,0 +617,1 @@\n+      if (overLimit) return null;\n@@ -674,0 +692,1 @@\n+            if (overLimit) return null;\n@@ -676,1 +695,0 @@\n-      totalOpCount += opCount;\n@@ -680,0 +698,4 @@\n+    public boolean isOverLimit() {\n+        return overLimit;\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/java_cup\/internal\/runtime\/lr_parser.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @LastModified: Jan 2022\n+ * @LastModified: July 2022\n@@ -49,3 +49,0 @@\n-    private int grpLimit = 0;\n-    private int opLimit = 0;\n-    private int totalOpLimit = 0;\n@@ -1121,3 +1118,10 @@\n-            int grpCount = getCount(ID_GROUP);\n-            int opCount = getCount(ID_OPERATOR);\n-            int totalOpCount = getCount(ID_TOTAL_OPERATOR);\n+            \/*\n+             * While the Java CUP parser is used for parsing symbols, the error\n+             * report mechanism has so far been kept within the Xalan implementation.\n+             * An error, i.e. the count of operators is over the limit, is\n+             * therefore handled here.\n+            *\/\n+            if (isOverLimit()) {\n+                int grpCount = getCount(ID_GROUP);\n+                int opCount = getCount(ID_OPERATOR);\n+                int totalOpCount = getCount(ID_TOTAL_OPERATOR);\n@@ -1125,19 +1129,20 @@\n-            String errCode = null;\n-            Object[] params = null;\n-            if (grpLimit > 0 && grpCount > grpLimit) {\n-                errCode = ErrorMsg.XPATH_GROUP_LIMIT;\n-                params = new Object[]{grpCount, grpLimit,\n-                    _xmlSM.getStateLiteral(Limit.XPATH_GROUP_LIMIT)};\n-            } else if (opLimit > 0 && opCount > opLimit) {\n-                errCode = ErrorMsg.XPATH_OPERATOR_LIMIT;\n-                params = new Object[]{opCount, opLimit,\n-                    _xmlSM.getStateLiteral(Limit.XPATH_OP_LIMIT)};\n-            } else if (totalOpLimit > 0 && totalOpCount > totalOpLimit) {\n-                errCode = ErrorMsg.XPATH_TOTAL_OPERATOR_LIMIT;\n-                params = new Object[]{totalOpCount, totalOpLimit,\n-                    _xmlSM.getStateLiteral(Limit.XPATH_TOTALOP_LIMIT)};\n-            }\n-            if (errCode != null) {\n-                _parser.reportError(Constants.FATAL,\n-                        new ErrorMsg(errCode, lineNumber, params));\n-                throw new RuntimeException(ErrorMsg.XPATH_LIMIT);\n+                String errCode = null;\n+                Object[] params = null;\n+                if (grpLimit > 0 && grpCount > grpLimit) {\n+                    errCode = ErrorMsg.XPATH_GROUP_LIMIT;\n+                    params = new Object[]{grpCount, grpLimit,\n+                        _xmlSM.getStateLiteral(Limit.XPATH_GROUP_LIMIT)};\n+                } else if (opLimit > 0 && opCount > opLimit) {\n+                    errCode = ErrorMsg.XPATH_OPERATOR_LIMIT;\n+                    params = new Object[]{opCount, opLimit,\n+                        _xmlSM.getStateLiteral(Limit.XPATH_OP_LIMIT)};\n+                } else if (totalOpLimit > 0 && totalOpCount > totalOpLimit) {\n+                    errCode = ErrorMsg.XPATH_TOTAL_OPERATOR_LIMIT;\n+                    params = new Object[]{totalOpCount, totalOpLimit,\n+                        _xmlSM.getStateLiteral(Limit.XPATH_TOTALOP_LIMIT)};\n+                }\n+                if (errCode != null) {\n+                    _parser.reportError(Constants.FATAL,\n+                            new ErrorMsg(errCode, lineNumber, params));\n+                    throw new RuntimeException(ErrorMsg.XPATH_LIMIT);\n+                }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/XPathParser.java","additions":31,"deletions":26,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1697,3 +1697,1 @@\n-            Set<Object> labels = new HashSet<>(); \/\/ The set of case labels.\n-            List<Type> coveredTypesForPatterns = List.nil();\n-            List<Type> coveredTypesForConstants = List.nil();\n+            Set<Object> constants = new HashSet<>(); \/\/ The set of case constants.\n@@ -1735,1 +1733,1 @@\n-                            } else if (!labels.add(sym)) {\n+                            } else if (!constants.add(sym)) {\n@@ -1737,2 +1735,0 @@\n-                            } else {\n-                                checkCaseLabelDominated(label.pos(), coveredTypesForConstants, sym.type);\n@@ -1768,1 +1764,1 @@\n-                                } else if (!labels.add(pattype.constValue())) {\n+                                } else if (!constants.add(pattype.constValue())) {\n@@ -1770,2 +1766,0 @@\n-                                } else {\n-                                    checkCaseLabelDominated(label.pos(), coveredTypesForConstants, types.boxedTypeOrType(pattype));\n@@ -1823,7 +1817,0 @@\n-                        checkCaseLabelDominated(pat.pos(), coveredTypesForPatterns, patternType);\n-                        if (!patternType.isErroneous()) {\n-                            coveredTypesForConstants = coveredTypesForConstants.prepend(patternType);\n-                            if (unguarded) {\n-                                coveredTypesForPatterns = coveredTypesForPatterns.prepend(patternType);\n-                            }\n-                        }\n@@ -1853,0 +1840,1 @@\n+                chk.checkSwitchCaseLabelDominated(cases);\n@@ -1878,8 +1866,0 @@\n-        private void checkCaseLabelDominated(DiagnosticPosition pos,\n-                                             List<Type> coveredTypes, Type patternType) {\n-            for (Type existing : coveredTypes) {\n-                if (types.isSubtype(patternType, existing)) {\n-                    log.error(pos, Errors.PatternDominated);\n-                }\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4379,0 +4379,87 @@\n+    void checkSwitchCaseLabelDominated(List<JCCase> cases) {\n+        List<JCCaseLabel> caseLabels = List.nil();\n+        for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+            JCCase c = l.head;\n+            for (JCCaseLabel label : c.labels) {\n+                if (label.hasTag(DEFAULTCASELABEL) || TreeInfo.isNullCaseLabel(label)) {\n+                    continue;\n+                }\n+                Type currentType = labelType(label);\n+                for (JCCaseLabel testCaseLabel : caseLabels) {\n+                    Type testType = labelType(testCaseLabel);\n+                    if (types.isSubtype(currentType, testType) &&\n+                        !currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n+                        \/\/the current label is potentially dominated by the existing (test) label, check:\n+                        boolean dominated = false;\n+                        if (label instanceof JCConstantCaseLabel) {\n+                            dominated |= !(testCaseLabel instanceof JCConstantCaseLabel);\n+                        } else if (label instanceof JCPatternCaseLabel patternCL &&\n+                                   testCaseLabel instanceof JCPatternCaseLabel testPatternCaseLabel &&\n+                                   TreeInfo.unguardedCaseLabel(testCaseLabel)) {\n+                            dominated = patternDominated(testPatternCaseLabel.pat,\n+                                                         patternCL.pat);\n+                        }\n+                        if (dominated) {\n+                            log.error(label.pos(), Errors.PatternDominated);\n+                        }\n+                    }\n+                }\n+                caseLabels = caseLabels.prepend(label);\n+            }\n+        }\n+    }\n+        \/\/where:\n+        private Type labelType(JCCaseLabel label) {\n+            return types.erasure(switch (label.getTag()) {\n+                case PATTERNCASELABEL -> ((JCPatternCaseLabel) label).pat.type;\n+                case CONSTANTCASELABEL -> types.boxedTypeOrType(((JCConstantCaseLabel) label).expr.type);\n+                default -> throw Assert.error(\"Unexpected tree kind: \" + label.getTag());\n+            });\n+        }\n+        private boolean patternDominated(JCPattern existingPattern, JCPattern currentPattern) {\n+            Type existingPatternType = types.erasure(existingPattern.type);\n+            Type currentPatternType = types.erasure(currentPattern.type);\n+            if (existingPatternType.isPrimitive() ^ currentPatternType.isPrimitive()) {\n+                return false;\n+            }\n+            if (existingPatternType.isPrimitive()) {\n+                return types.isSameType(existingPatternType, currentPatternType);\n+            } else {\n+                if (!types.isSubtype(currentPatternType, existingPatternType)) {\n+                    return false;\n+                }\n+            }\n+            while (existingPattern instanceof JCParenthesizedPattern parenthesized) {\n+                existingPattern = parenthesized.pattern;\n+            }\n+            while (currentPattern instanceof JCParenthesizedPattern parenthesized) {\n+                currentPattern = parenthesized.pattern;\n+            }\n+            if (currentPattern instanceof JCBindingPattern) {\n+                return existingPattern instanceof JCBindingPattern;\n+            } else if (currentPattern instanceof JCRecordPattern currentRecordPattern) {\n+                if (existingPattern instanceof JCBindingPattern) {\n+                    return true;\n+                } else if (existingPattern instanceof JCRecordPattern existingRecordPattern) {\n+                    List<JCPattern> existingNested = existingRecordPattern.nested;\n+                    List<JCPattern> currentNested = currentRecordPattern.nested;\n+                    if (existingNested.size() != currentNested.size()) {\n+                        return false;\n+                    }\n+                    while (existingNested.nonEmpty()) {\n+                        if (!patternDominated(existingNested.head, currentNested.head)) {\n+                            return false;\n+                        }\n+                        existingNested = existingNested.tail;\n+                        currentNested = currentNested.tail;\n+                    }\n+                    return true;\n+                } else {\n+                    Assert.error(\"Unknown pattern: \" + existingPattern.getTag());\n+                }\n+            } else {\n+                Assert.error(\"Unknown pattern: \" + currentPattern.getTag());\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Collections;\n@@ -35,1 +36,0 @@\n-import java.util.Map.Entry;\n@@ -163,2 +163,2 @@\n-        for (Entry<ThrowsTree, ExecutableElement> entry : throwsTags.entrySet()) {\n-            Element e = entry.getValue();\n+        Map<ThrowsTree, ExecutableElement> flattenedExceptions = flatten(throwsTags, writer);\n+        flattenedExceptions.forEach((ThrowsTree t, ExecutableElement e) -> {\n@@ -166,3 +166,2 @@\n-            ThrowsTree tag = entry.getKey();\n-            Element te = ch.getException(tag);\n-            String excName = tag.getExceptionName().toString();\n+            Element te = ch.getException(t);\n+            String excName = t.getExceptionName().toString();\n@@ -173,1 +172,1 @@\n-                continue;\n+                return;\n@@ -178,1 +177,1 @@\n-            result.add(writer.throwsTagOutput(e, tag, substituteType));\n+            result.add(writer.throwsTagOutput(e, t, substituteType));\n@@ -186,1 +185,1 @@\n-        }\n+        });\n@@ -191,0 +190,46 @@\n+    \/*\n+     * A single @throws tag from an overriding method can correspond to multiple\n+     * @throws tags from an overridden method.\n+     *\/\n+    private Map<ThrowsTree, ExecutableElement> flatten(Map<ThrowsTree, ExecutableElement> throwsTags,\n+                                                       TagletWriter writer) {\n+        Map<ThrowsTree, ExecutableElement> result = new LinkedHashMap<>();\n+        throwsTags.forEach((tag, taggedElement) -> {\n+            var expandedTags = expand(tag, taggedElement, writer);\n+            assert Collections.disjoint(result.entrySet(), expandedTags.entrySet());\n+            result.putAll(expandedTags);\n+        });\n+        return result;\n+    }\n+\n+    private Map<ThrowsTree, ExecutableElement> expand(ThrowsTree tag,\n+                                                      ExecutableElement e,\n+                                                      TagletWriter writer) {\n+\n+        \/\/ This method uses Map.of() to create maps of size zero and one.\n+        \/\/ While such maps are effectively ordered, the syntax is more\n+        \/\/ compact than that of LinkedHashMap.\n+\n+        \/\/ peek into @throws description\n+        if (tag.getDescription().stream().noneMatch(d -> d.getKind() == DocTree.Kind.INHERIT_DOC)) {\n+            \/\/ nothing to inherit\n+            return Map.of(tag, e);\n+        }\n+        var input = new DocFinder.Input(writer.configuration().utils, e, this, new DocFinder.DocTreeInfo(tag, e), false, true);\n+        var output = DocFinder.search(writer.configuration(), input);\n+        if (output.tagList.size() <= 1) {\n+            \/\/ outer code will handle this trivial case of inheritance\n+            return Map.of(tag, e);\n+        }\n+        if (tag.getDescription().size() > 1) {\n+            \/\/ there's more to description than just {@inheritDoc}\n+            \/\/ it's likely a documentation error\n+            var ch = writer.configuration().utils.getCommentHelper(e);\n+            writer.configuration().getMessages().error(ch.getDocTreePath(tag), \"doclet.inheritDocWithinInappropriateTag\");\n+            return Map.of();\n+        }\n+        Map<ThrowsTree, ExecutableElement> tags = new LinkedHashMap<>();\n+        output.tagList.forEach(t -> tags.put((ThrowsTree) t, (ExecutableElement) output.holder));\n+        return tags;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":54,"deletions":9,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-\n-serviceability\/jvmti\/vthread\/ContStackDepthTest\/ContStackDepthTest.java 8288949 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+vmTestbase\/nsk\/jdwp\/ThreadReference\/ForceEarlyReturn\/forceEarlyReturn002\/forceEarlyReturn002.java 8286789 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-svc-vthread.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+\n+vmTestbase\/gc\/gctests\/MemoryEaterMT\/MemoryEaterMT.java        8289582   windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -756,0 +756,1 @@\n+jdk\/jfr\/event\/runtime\/TestActiveSettingEvent.java               8287832 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8067757\n+ * @bug 8067757 6509045\n@@ -353,0 +353,214 @@\n+\n+    @Test\n+    public void testUncheckedExceptionTag(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyRuntimeException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException if this\n+                     * @throws MyRuntimeException if that\n+                     *\/\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I1 extends I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException {@inheritDoc}\n+                     *\/\n+                    @Override\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class IImpl implements I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException {@inheritDoc}\n+                     *\/\n+                    @Override\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class C {\n+\n+                    \/**\n+                     * @throws MyRuntimeException if this\n+                     * @throws MyRuntimeException if that\n+                     *\/\n+                    public void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class C1 extends C {\n+\n+                    \/**\n+                     * @throws MyRuntimeException {@inheritDoc}\n+                     *\/\n+                    @Override\n+                    public void m() { }\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/IImpl.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"I.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"I.html\" title=\"interface in x\">I<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - if this<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - if that<\/dd>\n+                <\/dl>\"\"\");\n+        checkOutput(\"x\/I1.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"I.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"I.html\" title=\"interface in x\">I<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - if this<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - if that<\/dd>\n+                <\/dl>\"\"\");\n+        checkOutput(\"x\/C1.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"C.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code><a href=\"C.html\" title=\"class in x\">C<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - if this<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - if that<\/dd>\n+                <\/dl>\"\"\");\n+    }\n+\n+    @Test\n+    public void testWholeShebang(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyRuntimeException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException always\n+                     *\/\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I1 extends I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException sometimes\n+                     * @throws MyRuntimeException rarely\n+                     * @throws MyRuntimeException \"{@inheritDoc}\"\n+                     *\/\n+                    @Override\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I2 extends I1 {\n+\n+                    \/**\n+                     * @throws MyRuntimeException occasionally\n+                     * @throws MyRuntimeException {@inheritDoc}\n+                     * @throws MyRuntimeException frequently\n+                     *\/\n+                    @Override\n+                    void m() throws MyRuntimeException,\n+                                    MyRuntimeException,\n+                                    MyRuntimeException,\n+                                    MyRuntimeException;\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/I.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - always<\/dd>\n+                <\/dl>\"\"\");\n+        checkOutput(\"x\/I1.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"I.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"I.html\" title=\"interface in x\">I<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - sometimes<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - rarely<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - \"always\"<\/dd>\n+                <\/dl>\"\"\");\n+        checkOutput(\"x\/I2.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"I.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"I.html\" title=\"interface in x\">I<\/a><\/code><\/dd>\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"I1.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"I1.html\" title=\"interface in x\">I1<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - occasionally<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - sometimes<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - rarely<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - \"always\"<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - frequently<\/dd>\n+                <\/dl>\"\"\");\n+    }\n+\n+    @Test\n+    public void testError(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyRuntimeException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException sometimes\n+                     * @throws MyRuntimeException rarely\n+                     *\/\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I1 extends I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException \"{@inheritDoc}\"\n+                     *\/\n+                    @Override\n+                    void m();\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                I1.java:6: error: @inheritDoc cannot be used within this tag\n+                     * @throws MyRuntimeException \"{@inheritDoc}\"\n+                       ^\n+                       \"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritanceMultiple\/TestOneToMany.java","additions":215,"deletions":1,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -139,0 +139,75 @@\n+    int testRecordPatternsDominated1() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R r: return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated2() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R(int a): return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated3() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R r when guard(): return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated4() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R(int a) when guard(): return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    boolean guard() {\n+        return false;\n+    }\n+\n+    int testRecordPatternsDominated5() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case ((R r)): return 1;\n+            case ((R(int a))): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated6() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case ((R(int a))): return 1;\n+            case ((R(int a))): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated7() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R r when true: return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated8() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R(int a) when true: return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -13,0 +13,6 @@\n+Domination.java:144:18: compiler.err.pattern.dominated\n+Domination.java:153:18: compiler.err.pattern.dominated\n+Domination.java:184:18: compiler.err.pattern.dominated\n+Domination.java:193:18: compiler.err.pattern.dominated\n+Domination.java:202:18: compiler.err.pattern.dominated\n+Domination.java:211:18: compiler.err.pattern.dominated\n@@ -15,1 +21,1 @@\n-12 errors\n+18 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-SwitchErrors.java:200:44: compiler.err.pattern.dominated\n+SwitchErrors.java:200:44: compiler.err.flows.through.from.pattern\n@@ -39,1 +39,1 @@\n-SwitchErrors.java:232:44: compiler.err.pattern.dominated\n+SwitchErrors.java:232:44: compiler.err.flows.through.from.pattern\n@@ -58,1 +58,1 @@\n-55 errors\n+55 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}