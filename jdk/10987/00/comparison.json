{"files":[{"patch":"@@ -86,1 +86,0 @@\n-    _rs_length_diff_seq(TruncatedSeqLength),\n@@ -108,1 +107,0 @@\n-  _rs_length_diff_seq.set_initial(0.0);\n@@ -195,4 +193,0 @@\n-void G1Analytics::report_rs_length_diff(double rs_length_diff, bool for_young_only_phase) {\n-  _rs_length_diff_seq.add(rs_length_diff, for_young_only_phase);\n-}\n-\n@@ -280,2 +274,1 @@\n-  return predict_size(&_rs_length_seq, for_young_only_phase) +\n-    predict_size(&_rs_length_diff_seq, for_young_only_phase);\n+  return predict_size(&_rs_length_seq, for_young_only_phase);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-  G1PhaseDependentSeq _rs_length_diff_seq;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1Analytics.hpp\"\n@@ -50,4 +51,0 @@\n-double G1CollectionSet::predict_region_non_copy_time_ms(HeapRegion* hr) const {\n-  return _policy->predict_region_non_copy_time_ms(hr, collector_state()->in_young_only_phase());\n-}\n-\n@@ -66,1 +63,0 @@\n-  _recorded_rs_length(0),\n@@ -69,6 +65,1 @@\n-  _inc_collection_set_stats(NULL),\n-  _inc_bytes_used_before(0),\n-  _inc_recorded_rs_length(0),\n-  _inc_recorded_rs_length_diff(0),\n-  _inc_predicted_non_copy_time_ms(0.0),\n-  _inc_predicted_non_copy_time_ms_diff(0.0) {\n+  _inc_bytes_used_before(0) {\n@@ -79,1 +70,0 @@\n-  FREE_C_HEAP_ARRAY(IncCollectionSetRegionStat, _inc_collection_set_stats);\n@@ -102,1 +92,0 @@\n-  _inc_collection_set_stats = NEW_C_HEAP_ARRAY(IncCollectionSetRegionStat, max_region_length, mtGC);\n@@ -118,4 +107,0 @@\n-void G1CollectionSet::set_recorded_rs_length(size_t rs_length) {\n-  _recorded_rs_length = rs_length;\n-}\n-\n@@ -137,1 +122,0 @@\n-  _recorded_rs_length += hr->rem_set()->occupied();\n@@ -155,5 +139,0 @@\n-#ifdef ASSERT\n-  for (uint i = 0; i < _collection_set_max_length; i++) {\n-    _inc_collection_set_stats[i].reset();\n-  }\n-#endif\n@@ -163,5 +142,0 @@\n-  _inc_recorded_rs_length = 0;\n-  _inc_recorded_rs_length_diff = 0;\n-  _inc_predicted_non_copy_time_ms = 0.0;\n-  _inc_predicted_non_copy_time_ms_diff = 0.0;\n-\n@@ -174,13 +148,0 @@\n-\n-  \/\/ The two \"main\" fields, _inc_recorded_rs_length and\n-  \/\/ _inc_predicted_non_copy_time_ms, are updated by the thread\n-  \/\/ that adds a new region to the CSet. Further updates by the\n-  \/\/ concurrent refinement thread that samples the young RSet lengths\n-  \/\/ are accumulated in the *_diff fields. Here we add the diffs to\n-  \/\/ the \"main\" fields.\n-\n-  _inc_recorded_rs_length += _inc_recorded_rs_length_diff;\n-  _inc_predicted_non_copy_time_ms += _inc_predicted_non_copy_time_ms_diff;\n-\n-  _inc_recorded_rs_length_diff = 0;\n-  _inc_predicted_non_copy_time_ms_diff = 0.0;\n@@ -242,25 +203,0 @@\n-void G1CollectionSet::update_young_region_prediction(HeapRegion* hr,\n-                                                     size_t new_rs_length) {\n-  \/\/ Update the CSet information that is dependent on the new RS length\n-  assert(hr->is_young(), \"Precondition\");\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"should not be at a safepoint\");\n-\n-  IncCollectionSetRegionStat* stat = &_inc_collection_set_stats[hr->hrm_index()];\n-\n-  size_t old_rs_length = stat->_rs_length;\n-  assert(old_rs_length <= new_rs_length,\n-         \"Remembered set decreased (changed from \" SIZE_FORMAT \" to \" SIZE_FORMAT \" region %u type %s)\",\n-         old_rs_length, new_rs_length, hr->hrm_index(), hr->get_short_type_str());\n-  size_t rs_length_diff = new_rs_length - old_rs_length;\n-  stat->_rs_length = new_rs_length;\n-  _inc_recorded_rs_length_diff += rs_length_diff;\n-\n-  double old_non_copy_time = stat->_non_copy_time_ms;\n-  assert(old_non_copy_time >= 0.0, \"Non copy time for region %u not initialized yet, is %.3f\", hr->hrm_index(), old_non_copy_time);\n-  double new_non_copy_time = predict_region_non_copy_time_ms(hr);\n-  double non_copy_time_ms_diff = new_non_copy_time - old_non_copy_time;\n-\n-  stat->_non_copy_time_ms = new_non_copy_time;\n-  _inc_predicted_non_copy_time_ms_diff += non_copy_time_ms_diff;\n-}\n-\n@@ -288,14 +224,0 @@\n-    size_t rs_length = hr->rem_set()->occupied();\n-    double non_copy_time = predict_region_non_copy_time_ms(hr);\n-\n-    \/\/ Cache the values we have added to the aggregated information\n-    \/\/ in the heap region in case we have to remove this region from\n-    \/\/ the incremental collection set, or it is updated by the\n-    \/\/ rset sampling code\n-\n-    IncCollectionSetRegionStat* stat = &_inc_collection_set_stats[hr->hrm_index()];\n-    stat->_rs_length = rs_length;\n-    stat->_non_copy_time_ms = non_copy_time;\n-\n-    _inc_recorded_rs_length += rs_length;\n-    _inc_predicted_non_copy_time_ms += non_copy_time;\n@@ -403,1 +325,2 @@\n-  size_t pending_cards = _policy->pending_cards_at_gc_start() + _g1h->hot_card_cache()->num_entries();\n+  size_t pending_cards = _policy->pending_cards_at_gc_start() +\n+                         _g1h->hot_card_cache()->num_entries();\n@@ -420,4 +343,0 @@\n-  \/\/ The number of recorded young regions is the incremental\n-  \/\/ collection set's current size\n-  set_recorded_rs_length(_inc_recorded_rs_length);\n-\n@@ -425,1 +344,4 @@\n-  double predicted_eden_time = _inc_predicted_non_copy_time_ms + _policy->predict_eden_copy_time_ms(eden_region_length);\n+  \/\/ Base time already includes the whole remembered set related time, so do not add that here\n+  \/\/ again.\n+  double predicted_eden_time = _policy->predict_young_region_other_time_ms(eden_region_length) +\n+                               _policy->predict_eden_copy_time_ms(eden_region_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":8,"deletions":86,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -164,5 +164,0 @@\n-  \/\/ The number of cards in the remembered set in the collection set. Set from\n-  \/\/ the incrementally built collection set at the start of an evacuation\n-  \/\/ pause, and updated as more regions are added to the collection set.\n-  size_t _recorded_rs_length;\n-\n@@ -177,16 +172,0 @@\n-  \/\/ Information about eden regions in the incremental collection set.\n-  struct IncCollectionSetRegionStat {\n-    \/\/ The predicted non-copy time that was added to the total incremental value\n-    \/\/ for the collection set.\n-    double _non_copy_time_ms;\n-    \/\/ The remembered set length that was added to the total incremental value\n-    \/\/ for the collection set.\n-    size_t _rs_length;\n-\n-#ifdef ASSERT\n-    \/\/ Resets members to \"uninitialized\" values.\n-    void reset() { _rs_length = ~(size_t)0; _non_copy_time_ms = -1.0; }\n-#endif\n-  };\n-\n-  IncCollectionSetRegionStat* _inc_collection_set_stats;\n@@ -202,25 +181,0 @@\n-  \/\/ The RSet lengths recorded for regions in the CSet. It is updated\n-  \/\/ by the thread that adds a new region to the CSet. We assume that\n-  \/\/ only one thread can be allocating a new CSet region (currently,\n-  \/\/ it does so after taking the Heap_lock) hence no need to\n-  \/\/ synchronize updates to this field.\n-  size_t _inc_recorded_rs_length;\n-\n-  \/\/ A concurrent refinement thread periodically samples the young\n-  \/\/ region RSets and needs to update _inc_recorded_rs_length as\n-  \/\/ the RSets grow. Instead of having to synchronize updates to that\n-  \/\/ field we accumulate them in this field and add it to\n-  \/\/ _inc_recorded_rs_length_diff at the start of a GC.\n-  size_t _inc_recorded_rs_length_diff;\n-\n-  \/\/ The predicted elapsed time it will take to collect the regions in\n-  \/\/ the CSet. This is updated by the thread that adds a new region to\n-  \/\/ the CSet. See the comment for _inc_recorded_rs_length about\n-  \/\/ MT-safety assumptions.\n-  double _inc_predicted_non_copy_time_ms;\n-\n-  \/\/ See the comment for _inc_recorded_rs_length_diff.\n-  double _inc_predicted_non_copy_time_ms_diff;\n-\n-  void set_recorded_rs_length(size_t rs_length);\n-\n@@ -232,2 +186,0 @@\n-  double predict_region_non_copy_time_ms(HeapRegion* hr) const;\n-\n@@ -325,2 +277,0 @@\n-  size_t recorded_rs_length() { return _recorded_rs_length; }\n-\n@@ -344,4 +294,0 @@\n-  \/\/ Update information about hr in the aggregated information for\n-  \/\/ the incrementally built collection set.\n-  void update_young_region_prediction(HeapRegion* hr, size_t new_rs_length);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -291,2 +291,0 @@\n-    \/\/ Update the collection set policy information for this region.\n-    _cset->update_young_region_prediction(r, rs_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -511,1 +511,0 @@\n-  double survivor_regions_evac_time = 0.0;\n@@ -513,0 +512,1 @@\n+  double survivor_regions_evac_time = predict_young_region_other_time_ms(_g1h->survivor()->length());\n@@ -516,1 +516,1 @@\n-    survivor_regions_evac_time += predict_region_total_time_ms(*it, collector_state()->in_young_only_phase());\n+    survivor_regions_evac_time += predict_region_copy_time_ms(*it);\n@@ -518,0 +518,1 @@\n+\n@@ -851,4 +852,0 @@\n-    const size_t recorded_rs_length = _collection_set->recorded_rs_length();\n-    const size_t rs_length_diff = _rs_length > recorded_rs_length ? _rs_length - recorded_rs_length : 0;\n-    _analytics->report_rs_length_diff(rs_length_diff, is_young_only_pause);\n-\n@@ -875,5 +872,2 @@\n-    \/\/ Do not update RS lengths and the number of pending cards with information from mixed gc:\n-    \/\/ these are is wildly different to during young only gc and mess up young gen sizing right\n-    \/\/ after the mixed gc phase.\n-    _analytics->report_pending_cards((double) _pending_cards_at_gc_start, is_young_only_pause);\n-    _analytics->report_rs_length((double) _rs_length, is_young_only_pause);\n+    _analytics->report_pending_cards((double)pending_cards_at_gc_start(), is_young_only_pause);\n+    _analytics->report_rs_length((double)_rs_length, is_young_only_pause);\n@@ -1056,0 +1050,4 @@\n+double G1Policy::predict_young_region_other_time_ms(uint count) const {\n+  return _analytics->predict_young_other_time_ms(count);\n+}\n+\n@@ -1072,2 +1070,1 @@\n-double G1Policy::predict_region_non_copy_time_ms(HeapRegion* hr,\n-                                                 bool for_young_only_phase) const {\n+double G1Policy::predict_region_merge_scan_time(HeapRegion* hr, bool for_young_only_phase) const {\n@@ -1077,1 +1074,1 @@\n-  double region_elapsed_time_ms =\n+  return\n@@ -1080,0 +1077,4 @@\n+}\n+\n+double G1Policy::predict_region_non_copy_time_ms(HeapRegion* hr,\n+                                                 bool for_young_only_phase) const {\n@@ -1081,0 +1082,1 @@\n+  double region_elapsed_time_ms = predict_region_merge_scan_time(hr, for_young_only_phase);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -145,0 +145,3 @@\n+  \/\/ Base time contains handling remembered sets and constant other time of the\n+  \/\/ whole young gen, refinement buffers, and copying survivors.\n+  \/\/ Basically everything but copying eden regions.\n@@ -147,0 +150,1 @@\n+  \/\/ Copy time for a region is copying live data.\n@@ -148,0 +152,4 @@\n+  \/\/ Merge-scan time for a region is handling remembered sets of that region (as a single unit).\n+  double predict_region_merge_scan_time(HeapRegion* hr, bool for_young_only_phase) const;\n+  \/\/ Non-copy time for a region is handling remembered sets and other time.\n+  double predict_region_non_copy_time_ms(HeapRegion* hr, bool for_young_only_phase) const;\n@@ -151,2 +159,7 @@\n-  double predict_eden_copy_time_ms(uint count, size_t* bytes_to_copy = NULL) const;\n-  double predict_region_non_copy_time_ms(HeapRegion* hr, bool for_young_only_phase) const;\n+  \/\/ Predict other time for count young regions.\n+  double predict_young_region_other_time_ms(uint count) const;\n+  \/\/ Predict copying live data time for count eden regions. Return the predict bytes if\n+  \/\/ bytes_to_copy is non-nullptr.\n+  double predict_eden_copy_time_ms(uint count, size_t* bytes_to_copy = nullptr) const;\n+  \/\/ Total time for a region is handling remembered sets (as a single unit), copying its live data\n+  \/\/ and other time.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"}]}