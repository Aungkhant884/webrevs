{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,1 @@\n-                    ctx.reference = new HardReference<K>(ctx);\n+                    ctx.reference = new HardReference<>(ctx);\n@@ -142,1 +142,1 @@\n-                    ctx.reference = new SoftReference<K>(ctx);\n+                    ctx.reference = new SoftReference<>(ctx);\n@@ -146,1 +146,1 @@\n-                    ctx.reference = new WeakReference<K>(ctx);\n+                    ctx.reference = new WeakReference<>(ctx);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/ReentrantContextProvider.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-        = new ConcurrentLinkedQueue<Reference<K>>();\n+        = new ConcurrentLinkedQueue<>();\n@@ -66,1 +66,1 @@\n-        Reference<K> ref = null;\n+        Reference<K> ref;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/ReentrantContextProviderCLQ.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-        = new ThreadLocal<Reference<K>>();\n+        = new ThreadLocal<>();\n@@ -74,1 +74,1 @@\n-        this.ctxProviderCLQ = new ReentrantContextProviderCLQ<K>(refTypeCLQ) {\n+        this.ctxProviderCLQ = new ReentrantContextProviderCLQ<>(refTypeCLQ) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/ReentrantContextProviderTL.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.marlin;\n+\n+import static sun.java2d.marlin.ArrayCacheConst.ARRAY_SIZES;\n+import static sun.java2d.marlin.ArrayCacheConst.BUCKETS;\n+import static sun.java2d.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n+\n+import static sun.java2d.marlin.MarlinConst.DO_STATS;\n+import static sun.java2d.marlin.MarlinConst.DO_CHECKS;\n+import static sun.java2d.marlin.MarlinConst.DO_CLEAN_DIRTY;\n+import static sun.java2d.marlin.MarlinConst.DO_LOG_WIDEN_ARRAY;\n+import static sun.java2d.marlin.MarlinConst.DO_LOG_OVERSIZE;\n+\n+import static sun.java2d.marlin.MarlinUtils.logInfo;\n+import static sun.java2d.marlin.MarlinUtils.logException;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Arrays;\n+\n+import sun.java2d.marlin.ArrayCacheConst.BucketStats;\n+import sun.java2d.marlin.ArrayCacheConst.CacheStats;\n+\n+\/*\n+ * Note that the ArrayCache[BYTE\/INT\/FLOAT\/DOUBLE] files are nearly identical except\n+ * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n+ * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n+ * files are generated with the following command lines:\n+ *\/\n+\n+final class ArrayCacheByte {\n+\n+    \/* members *\/\n+    private final int bucketCapacity;\n+    private WeakReference<Bucket[]> refBuckets = null;\n+    final CacheStats stats;\n+\n+    ArrayCacheByte(final int bucketCapacity) {\n+        this.bucketCapacity = bucketCapacity;\n+        this.stats = (DO_STATS) ?\n+            new CacheStats(\"ArrayCacheByte(Dirty)\") : null;\n+    }\n+\n+    Bucket getCacheBucket(final int length) {\n+        final int bucket = ArrayCacheConst.getBucket(length);\n+        return getBuckets()[bucket];\n+    }\n+\n+    private Bucket[] getBuckets() {\n+        \/\/ resolve reference:\n+        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n+\n+        \/\/ create a new buckets ?\n+        if (buckets == null) {\n+            buckets = new Bucket[BUCKETS];\n+\n+            for (int i = 0; i < BUCKETS; i++) {\n+                buckets[i] = new Bucket(ARRAY_SIZES[i], bucketCapacity,\n+                        (DO_STATS) ? stats.bucketStats[i] : null);\n+            }\n+\n+            \/\/ update weak reference:\n+            refBuckets = new WeakReference<>(buckets);\n+        }\n+        return buckets;\n+    }\n+\n+    Reference createRef(final int initialSize) {\n+        return new Reference(this, initialSize);\n+    }\n+\n+    static final class Reference {\n+\n+        \/\/ initial array reference (direct access)\n+        final byte[] initial;\n+        private final ArrayCacheByte cache;\n+\n+        Reference(final ArrayCacheByte cache, final int initialSize) {\n+            this.cache = cache;\n+            this.initial = createArray(initialSize);\n+            if (DO_STATS) {\n+                cache.stats.totalInitial += initialSize;\n+            }\n+        }\n+\n+        byte[] getArray(final int length) {\n+            if (length <= MAX_ARRAY_SIZE) {\n+                return cache.getCacheBucket(length).getArray();\n+            }\n+            if (DO_STATS) {\n+                cache.stats.oversize++;\n+            }\n+            if (DO_LOG_OVERSIZE) {\n+                logInfo(\"ArrayCacheByte(Dirty): \"\n+                        + \"getArray[oversize]: length=\\t\" + length);\n+            }\n+            return createArray(length);\n+        }\n+\n+        byte[] widenArray(final byte[] array, final int usedSize,\n+                          final int needSize)\n+        {\n+            final int length = array.length;\n+            if (DO_CHECKS && length >= needSize) {\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                cache.stats.resize++;\n+            }\n+\n+            \/\/ maybe change bucket:\n+            \/\/ ensure getNewSize() > newSize:\n+            final byte[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n+\n+            \/\/ use wrapper to ensure proper copy:\n+            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n+\n+            \/\/ maybe return current array:\n+            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n+\n+            if (DO_LOG_WIDEN_ARRAY) {\n+                logInfo(\"ArrayCacheByte(Dirty): \"\n+                        + \"widenArray[\" + res.length\n+                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n+                        + \"\\tneeded length=\\t\" + needSize);\n+            }\n+            return res;\n+        }\n+\n+        boolean doCleanRef(final byte[] array) {\n+            return DO_CLEAN_DIRTY || (array != initial);\n+        }\n+\n+        byte[] putArray(final byte[] array)\n+        {\n+            \/\/ dirty array helper:\n+            return putArray(array, 0, array.length);\n+        }\n+\n+        byte[] putArray(final byte[] array, final int fromIndex,\n+                        final int toIndex)\n+        {\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                if (DO_CLEAN_DIRTY && (toIndex != 0)) {\n+                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n+                    fill(array, fromIndex, toIndex, (byte)0);\n+                }\n+                \/\/ ensure to never store initial arrays in cache:\n+                if (array != initial) {\n+                    cache.getCacheBucket(array.length).putArray(array);\n+                }\n+            }\n+            return initial;\n+        }\n+    }\n+\n+    static final class Bucket {\n+\n+        private int tail = 0;\n+        private final int arraySize;\n+        private final byte[][] arrays;\n+        private final BucketStats stats;\n+\n+        Bucket(final int arraySize,\n+               final int capacity, final BucketStats stats)\n+        {\n+            this.arraySize = arraySize;\n+            this.stats = stats;\n+            this.arrays = new byte[capacity][];\n+        }\n+\n+        byte[] getArray() {\n+            if (DO_STATS) {\n+                stats.getOp++;\n+            }\n+            \/\/ use cache:\n+            if (tail != 0) {\n+                final byte[] array = arrays[--tail];\n+                arrays[tail] = null;\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                stats.createOp++;\n+            }\n+            return createArray(arraySize);\n+        }\n+\n+        void putArray(final byte[] array)\n+        {\n+            if (DO_CHECKS && (array.length != arraySize)) {\n+                logInfo(\"ArrayCacheByte(Dirty): \"\n+                        + \"bad length = \" + array.length);\n+                return;\n+            }\n+            if (DO_STATS) {\n+                stats.returnOp++;\n+            }\n+            \/\/ fill cache:\n+            if (arrays.length > tail) {\n+                arrays[tail++] = array;\n+\n+                if (DO_STATS) {\n+                    stats.updateMaxSize(tail);\n+                }\n+            } else if (DO_CHECKS) {\n+                logInfo(\"ArrayCacheByte(Dirty): \"\n+                        + \"array capacity exceeded !\");\n+            }\n+        }\n+    }\n+\n+    static byte[] createArray(final int length) {\n+        return new byte[length];\n+    }\n+\n+    static void fill(final byte[] array, final int fromIndex,\n+                     final int toIndex, final byte value)\n+    {\n+        \/\/ clear array data:\n+        Arrays.fill(array, fromIndex, toIndex, value);\n+        if (DO_CHECKS) {\n+            check(array, fromIndex, toIndex, value);\n+        }\n+    }\n+\n+    static void check(final byte[] array, final int fromIndex,\n+                      final int toIndex, final byte value)\n+    {\n+        if (DO_CHECKS) {\n+            \/\/ check zero on full array:\n+            for (int i = 0; i < array.length; i++) {\n+                if (array[i] != value) {\n+                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n+                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n+                            + Arrays.toString(array), new Throwable());\n+\n+                    \/\/ ensure array is correctly filled:\n+                    Arrays.fill(array, value);\n+\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/ArrayCacheByte.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.marlin;\n+\n+import static sun.java2d.marlin.ArrayCacheConst.ARRAY_SIZES;\n+import static sun.java2d.marlin.ArrayCacheConst.BUCKETS;\n+import static sun.java2d.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n+\n+import static sun.java2d.marlin.MarlinConst.DO_STATS;\n+import static sun.java2d.marlin.MarlinConst.DO_CHECKS;\n+import static sun.java2d.marlin.MarlinConst.DO_CLEAN_DIRTY;\n+import static sun.java2d.marlin.MarlinConst.DO_LOG_WIDEN_ARRAY;\n+import static sun.java2d.marlin.MarlinConst.DO_LOG_OVERSIZE;\n+\n+import static sun.java2d.marlin.MarlinUtils.logInfo;\n+import static sun.java2d.marlin.MarlinUtils.logException;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Arrays;\n+\n+import sun.java2d.marlin.ArrayCacheConst.BucketStats;\n+import sun.java2d.marlin.ArrayCacheConst.CacheStats;\n+\n+\/*\n+ * Note that the ArrayCache[BYTE\/INT\/FLOAT\/DOUBLE] files are nearly identical except\n+ * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n+ * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n+ * files are generated with the following command lines:\n+ *\/\n+\n+final class ArrayCacheDouble {\n+\n+    \/* members *\/\n+    private final int bucketCapacity;\n+    private WeakReference<Bucket[]> refBuckets = null;\n+    final CacheStats stats;\n+\n+    ArrayCacheDouble(final int bucketCapacity) {\n+        this.bucketCapacity = bucketCapacity;\n+        this.stats = (DO_STATS) ?\n+            new CacheStats(\"ArrayCacheDouble(Dirty)\") : null;\n+    }\n+\n+    Bucket getCacheBucket(final int length) {\n+        final int bucket = ArrayCacheConst.getBucket(length);\n+        return getBuckets()[bucket];\n+    }\n+\n+    private Bucket[] getBuckets() {\n+        \/\/ resolve reference:\n+        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n+\n+        \/\/ create a new buckets ?\n+        if (buckets == null) {\n+            buckets = new Bucket[BUCKETS];\n+\n+            for (int i = 0; i < BUCKETS; i++) {\n+                buckets[i] = new Bucket(ARRAY_SIZES[i], bucketCapacity,\n+                        (DO_STATS) ? stats.bucketStats[i] : null);\n+            }\n+\n+            \/\/ update weak reference:\n+            refBuckets = new WeakReference<>(buckets);\n+        }\n+        return buckets;\n+    }\n+\n+    Reference createRef(final int initialSize) {\n+        return new Reference(this, initialSize);\n+    }\n+\n+    static final class Reference {\n+\n+        \/\/ initial array reference (direct access)\n+        final double[] initial;\n+        private final ArrayCacheDouble cache;\n+\n+        Reference(final ArrayCacheDouble cache, final int initialSize) {\n+            this.cache = cache;\n+            this.initial = createArray(initialSize);\n+            if (DO_STATS) {\n+                cache.stats.totalInitial += initialSize;\n+            }\n+        }\n+\n+        double[] getArray(final int length) {\n+            if (length <= MAX_ARRAY_SIZE) {\n+                return cache.getCacheBucket(length).getArray();\n+            }\n+            if (DO_STATS) {\n+                cache.stats.oversize++;\n+            }\n+            if (DO_LOG_OVERSIZE) {\n+                logInfo(\"ArrayCacheDouble(Dirty): \"\n+                        + \"getArray[oversize]: length=\\t\" + length);\n+            }\n+            return createArray(length);\n+        }\n+\n+        double[] widenArray(final double[] array, final int usedSize,\n+                          final int needSize)\n+        {\n+            final int length = array.length;\n+            if (DO_CHECKS && length >= needSize) {\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                cache.stats.resize++;\n+            }\n+\n+            \/\/ maybe change bucket:\n+            \/\/ ensure getNewSize() > newSize:\n+            final double[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n+\n+            \/\/ use wrapper to ensure proper copy:\n+            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n+\n+            \/\/ maybe return current array:\n+            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n+\n+            if (DO_LOG_WIDEN_ARRAY) {\n+                logInfo(\"ArrayCacheDouble(Dirty): \"\n+                        + \"widenArray[\" + res.length\n+                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n+                        + \"\\tneeded length=\\t\" + needSize);\n+            }\n+            return res;\n+        }\n+\n+        boolean doCleanRef(final double[] array) {\n+            return DO_CLEAN_DIRTY || (array != initial);\n+        }\n+\n+        double[] putArray(final double[] array)\n+        {\n+            \/\/ dirty array helper:\n+            return putArray(array, 0, array.length);\n+        }\n+\n+        double[] putArray(final double[] array, final int fromIndex,\n+                        final int toIndex)\n+        {\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                if (DO_CLEAN_DIRTY && (toIndex != 0)) {\n+                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n+                    fill(array, fromIndex, toIndex, 0.0d);\n+                }\n+                \/\/ ensure to never store initial arrays in cache:\n+                if (array != initial) {\n+                    cache.getCacheBucket(array.length).putArray(array);\n+                }\n+            }\n+            return initial;\n+        }\n+    }\n+\n+    static final class Bucket {\n+\n+        private int tail = 0;\n+        private final int arraySize;\n+        private final double[][] arrays;\n+        private final BucketStats stats;\n+\n+        Bucket(final int arraySize,\n+               final int capacity, final BucketStats stats)\n+        {\n+            this.arraySize = arraySize;\n+            this.stats = stats;\n+            this.arrays = new double[capacity][];\n+        }\n+\n+        double[] getArray() {\n+            if (DO_STATS) {\n+                stats.getOp++;\n+            }\n+            \/\/ use cache:\n+            if (tail != 0) {\n+                final double[] array = arrays[--tail];\n+                arrays[tail] = null;\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                stats.createOp++;\n+            }\n+            return createArray(arraySize);\n+        }\n+\n+        void putArray(final double[] array)\n+        {\n+            if (DO_CHECKS && (array.length != arraySize)) {\n+                logInfo(\"ArrayCacheDouble(Dirty): \"\n+                        + \"bad length = \" + array.length);\n+                return;\n+            }\n+            if (DO_STATS) {\n+                stats.returnOp++;\n+            }\n+            \/\/ fill cache:\n+            if (arrays.length > tail) {\n+                arrays[tail++] = array;\n+\n+                if (DO_STATS) {\n+                    stats.updateMaxSize(tail);\n+                }\n+            } else if (DO_CHECKS) {\n+                logInfo(\"ArrayCacheDouble(Dirty): \"\n+                        + \"array capacity exceeded !\");\n+            }\n+        }\n+    }\n+\n+    static double[] createArray(final int length) {\n+        return new double[length];\n+    }\n+\n+    static void fill(final double[] array, final int fromIndex,\n+                     final int toIndex, final double value)\n+    {\n+        \/\/ clear array data:\n+        Arrays.fill(array, fromIndex, toIndex, value);\n+        if (DO_CHECKS) {\n+            check(array, fromIndex, toIndex, value);\n+        }\n+    }\n+\n+    static void check(final double[] array, final int fromIndex,\n+                      final int toIndex, final double value)\n+    {\n+        if (DO_CHECKS) {\n+            \/\/ check zero on full array:\n+            for (int i = 0; i < array.length; i++) {\n+                if (array[i] != value) {\n+                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n+                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n+                            + Arrays.toString(array), new Throwable());\n+\n+                    \/\/ ensure array is correctly filled:\n+                    Arrays.fill(array, value);\n+\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/ArrayCacheDouble.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.marlin;\n+\n+import static sun.java2d.marlin.ArrayCacheConst.ARRAY_SIZES;\n+import static sun.java2d.marlin.ArrayCacheConst.BUCKETS;\n+import static sun.java2d.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n+\n+import static sun.java2d.marlin.MarlinConst.DO_STATS;\n+import static sun.java2d.marlin.MarlinConst.DO_CHECKS;\n+import static sun.java2d.marlin.MarlinConst.DO_CLEAN_DIRTY;\n+import static sun.java2d.marlin.MarlinConst.DO_LOG_WIDEN_ARRAY;\n+import static sun.java2d.marlin.MarlinConst.DO_LOG_OVERSIZE;\n+\n+import static sun.java2d.marlin.MarlinUtils.logInfo;\n+import static sun.java2d.marlin.MarlinUtils.logException;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Arrays;\n+\n+import sun.java2d.marlin.ArrayCacheConst.BucketStats;\n+import sun.java2d.marlin.ArrayCacheConst.CacheStats;\n+\n+\/*\n+ * Note that the ArrayCache[BYTE\/INT\/FLOAT\/DOUBLE] files are nearly identical except\n+ * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n+ * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n+ * files are generated with the following command lines:\n+ *\/\n+\n+final class ArrayCacheInt {\n+\n+    \/* members *\/\n+    private final int bucketCapacity;\n+    private WeakReference<Bucket[]> refBuckets = null;\n+    final CacheStats stats;\n+\n+    ArrayCacheInt(final int bucketCapacity) {\n+        this.bucketCapacity = bucketCapacity;\n+        this.stats = (DO_STATS) ?\n+            new CacheStats(\"ArrayCacheInt(Dirty)\") : null;\n+    }\n+\n+    Bucket getCacheBucket(final int length) {\n+        final int bucket = ArrayCacheConst.getBucket(length);\n+        return getBuckets()[bucket];\n+    }\n+\n+    private Bucket[] getBuckets() {\n+        \/\/ resolve reference:\n+        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n+\n+        \/\/ create a new buckets ?\n+        if (buckets == null) {\n+            buckets = new Bucket[BUCKETS];\n+\n+            for (int i = 0; i < BUCKETS; i++) {\n+                buckets[i] = new Bucket(ARRAY_SIZES[i], bucketCapacity,\n+                        (DO_STATS) ? stats.bucketStats[i] : null);\n+            }\n+\n+            \/\/ update weak reference:\n+            refBuckets = new WeakReference<>(buckets);\n+        }\n+        return buckets;\n+    }\n+\n+    Reference createRef(final int initialSize) {\n+        return new Reference(this, initialSize);\n+    }\n+\n+    static final class Reference {\n+\n+        \/\/ initial array reference (direct access)\n+        final int[] initial;\n+        private final ArrayCacheInt cache;\n+\n+        Reference(final ArrayCacheInt cache, final int initialSize) {\n+            this.cache = cache;\n+            this.initial = createArray(initialSize);\n+            if (DO_STATS) {\n+                cache.stats.totalInitial += initialSize;\n+            }\n+        }\n+\n+        int[] getArray(final int length) {\n+            if (length <= MAX_ARRAY_SIZE) {\n+                return cache.getCacheBucket(length).getArray();\n+            }\n+            if (DO_STATS) {\n+                cache.stats.oversize++;\n+            }\n+            if (DO_LOG_OVERSIZE) {\n+                logInfo(\"ArrayCacheInt(Dirty): \"\n+                        + \"getArray[oversize]: length=\\t\" + length);\n+            }\n+            return createArray(length);\n+        }\n+\n+        int[] widenArray(final int[] array, final int usedSize,\n+                          final int needSize)\n+        {\n+            final int length = array.length;\n+            if (DO_CHECKS && length >= needSize) {\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                cache.stats.resize++;\n+            }\n+\n+            \/\/ maybe change bucket:\n+            \/\/ ensure getNewSize() > newSize:\n+            final int[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n+\n+            \/\/ use wrapper to ensure proper copy:\n+            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n+\n+            \/\/ maybe return current array:\n+            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n+\n+            if (DO_LOG_WIDEN_ARRAY) {\n+                logInfo(\"ArrayCacheInt(Dirty): \"\n+                        + \"widenArray[\" + res.length\n+                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n+                        + \"\\tneeded length=\\t\" + needSize);\n+            }\n+            return res;\n+        }\n+\n+        boolean doCleanRef(final int[] array) {\n+            return DO_CLEAN_DIRTY || (array != initial);\n+        }\n+\n+        int[] putArray(final int[] array)\n+        {\n+            \/\/ dirty array helper:\n+            return putArray(array, 0, array.length);\n+        }\n+\n+        int[] putArray(final int[] array, final int fromIndex,\n+                        final int toIndex)\n+        {\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                if (DO_CLEAN_DIRTY && (toIndex != 0)) {\n+                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n+                    fill(array, fromIndex, toIndex, 0);\n+                }\n+                \/\/ ensure to never store initial arrays in cache:\n+                if (array != initial) {\n+                    cache.getCacheBucket(array.length).putArray(array);\n+                }\n+            }\n+            return initial;\n+        }\n+    }\n+\n+    static final class Bucket {\n+\n+        private int tail = 0;\n+        private final int arraySize;\n+        private final int[][] arrays;\n+        private final BucketStats stats;\n+\n+        Bucket(final int arraySize,\n+               final int capacity, final BucketStats stats)\n+        {\n+            this.arraySize = arraySize;\n+            this.stats = stats;\n+            this.arrays = new int[capacity][];\n+        }\n+\n+        int[] getArray() {\n+            if (DO_STATS) {\n+                stats.getOp++;\n+            }\n+            \/\/ use cache:\n+            if (tail != 0) {\n+                final int[] array = arrays[--tail];\n+                arrays[tail] = null;\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                stats.createOp++;\n+            }\n+            return createArray(arraySize);\n+        }\n+\n+        void putArray(final int[] array)\n+        {\n+            if (DO_CHECKS && (array.length != arraySize)) {\n+                logInfo(\"ArrayCacheInt(Dirty): \"\n+                        + \"bad length = \" + array.length);\n+                return;\n+            }\n+            if (DO_STATS) {\n+                stats.returnOp++;\n+            }\n+            \/\/ fill cache:\n+            if (arrays.length > tail) {\n+                arrays[tail++] = array;\n+\n+                if (DO_STATS) {\n+                    stats.updateMaxSize(tail);\n+                }\n+            } else if (DO_CHECKS) {\n+                logInfo(\"ArrayCacheInt(Dirty): \"\n+                        + \"array capacity exceeded !\");\n+            }\n+        }\n+    }\n+\n+    static int[] createArray(final int length) {\n+        return new int[length];\n+    }\n+\n+    static void fill(final int[] array, final int fromIndex,\n+                     final int toIndex, final int value)\n+    {\n+        \/\/ clear array data:\n+        Arrays.fill(array, fromIndex, toIndex, value);\n+        if (DO_CHECKS) {\n+            check(array, fromIndex, toIndex, value);\n+        }\n+    }\n+\n+    static void check(final int[] array, final int fromIndex,\n+                      final int toIndex, final int value)\n+    {\n+        if (DO_CHECKS) {\n+            \/\/ check zero on full array:\n+            for (int i = 0; i < array.length; i++) {\n+                if (array[i] != value) {\n+                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n+                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n+                            + Arrays.toString(array), new Throwable());\n+\n+                    \/\/ ensure array is correctly filled:\n+                    Arrays.fill(array, value);\n+\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/ArrayCacheInt.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.marlin;\n+\n+import static sun.java2d.marlin.ArrayCacheConst.ARRAY_SIZES;\n+import static sun.java2d.marlin.ArrayCacheConst.BUCKETS;\n+import static sun.java2d.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n+\n+import static sun.java2d.marlin.MarlinConst.DO_STATS;\n+import static sun.java2d.marlin.MarlinConst.DO_CHECKS;\n+import static sun.java2d.marlin.MarlinConst.DO_LOG_WIDEN_ARRAY;\n+import static sun.java2d.marlin.MarlinConst.DO_LOG_OVERSIZE;\n+\n+import static sun.java2d.marlin.MarlinUtils.logInfo;\n+import static sun.java2d.marlin.MarlinUtils.logException;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Arrays;\n+\n+import sun.java2d.marlin.ArrayCacheConst.BucketStats;\n+import sun.java2d.marlin.ArrayCacheConst.CacheStats;\n+\n+\/*\n+ * Note that the ArrayCache[BYTE\/INT\/FLOAT\/DOUBLE] files are nearly identical except\n+ * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n+ * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n+ * files are generated with the following command lines:\n+ *\/\n+\n+final class ArrayCacheIntClean {\n+\n+    \/* members *\/\n+    private final int bucketCapacity;\n+    private WeakReference<Bucket[]> refBuckets = null;\n+    final CacheStats stats;\n+\n+    ArrayCacheIntClean(final int bucketCapacity) {\n+        this.bucketCapacity = bucketCapacity;\n+        this.stats = (DO_STATS) ?\n+            new CacheStats(\"ArrayCacheInt(Clean)\") : null;\n+    }\n+\n+    Bucket getCacheBucket(final int length) {\n+        final int bucket = ArrayCacheConst.getBucket(length);\n+        return getBuckets()[bucket];\n+    }\n+\n+    private Bucket[] getBuckets() {\n+        \/\/ resolve reference:\n+        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n+\n+        \/\/ create a new buckets ?\n+        if (buckets == null) {\n+            buckets = new Bucket[BUCKETS];\n+\n+            for (int i = 0; i < BUCKETS; i++) {\n+                buckets[i] = new Bucket(ARRAY_SIZES[i], bucketCapacity,\n+                        (DO_STATS) ? stats.bucketStats[i] : null);\n+            }\n+\n+            \/\/ update weak reference:\n+            refBuckets = new WeakReference<>(buckets);\n+        }\n+        return buckets;\n+    }\n+\n+    Reference createRef(final int initialSize) {\n+        return new Reference(this, initialSize);\n+    }\n+\n+    static final class Reference {\n+\n+        \/\/ initial array reference (direct access)\n+        final int[] initial;\n+        private final ArrayCacheIntClean cache;\n+\n+        Reference(final ArrayCacheIntClean cache, final int initialSize) {\n+            this.cache = cache;\n+            this.initial = createArray(initialSize);\n+            if (DO_STATS) {\n+                cache.stats.totalInitial += initialSize;\n+            }\n+        }\n+\n+        int[] getArray(final int length) {\n+            if (length <= MAX_ARRAY_SIZE) {\n+                return cache.getCacheBucket(length).getArray();\n+            }\n+            if (DO_STATS) {\n+                cache.stats.oversize++;\n+            }\n+            if (DO_LOG_OVERSIZE) {\n+                logInfo(\"ArrayCacheInt(Clean): \"\n+                        + \"getArray[oversize]: length=\\t\" + length);\n+            }\n+            return createArray(length);\n+        }\n+\n+        int[] widenArray(final int[] array, final int usedSize,\n+                          final int needSize)\n+        {\n+            final int length = array.length;\n+            if (DO_CHECKS && length >= needSize) {\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                cache.stats.resize++;\n+            }\n+\n+            \/\/ maybe change bucket:\n+            \/\/ ensure getNewSize() > newSize:\n+            final int[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n+\n+            \/\/ use wrapper to ensure proper copy:\n+            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n+\n+            \/\/ maybe return current array:\n+            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n+\n+            if (DO_LOG_WIDEN_ARRAY) {\n+                logInfo(\"ArrayCacheInt(Clean): \"\n+                        + \"widenArray[\" + res.length\n+                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n+                        + \"\\tneeded length=\\t\" + needSize);\n+            }\n+            return res;\n+        }\n+\n+        boolean doSetRef(final int[] array) {\n+            return (array != initial);\n+        }\n+\n+        int[] putArrayClean(final int[] array)\n+        {\n+            \/\/ must be protected by doSetRef() call !\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                \/\/ ensure to never store initial arrays in cache:\n+                cache.getCacheBucket(array.length).putArray(array);\n+            }\n+            return initial;\n+        }\n+\n+        int[] putArray(final int[] array, final int fromIndex,\n+                        final int toIndex)\n+        {\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                if (toIndex != 0) {\n+                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n+                    fill(array, fromIndex, toIndex, 0);\n+                }\n+                \/\/ ensure to never store initial arrays in cache:\n+                if (array != initial) {\n+                    cache.getCacheBucket(array.length).putArray(array);\n+                }\n+            }\n+            return initial;\n+        }\n+    }\n+\n+    static final class Bucket {\n+\n+        private int tail = 0;\n+        private final int arraySize;\n+        private final int[][] arrays;\n+        private final BucketStats stats;\n+\n+        Bucket(final int arraySize,\n+               final int capacity, final BucketStats stats)\n+        {\n+            this.arraySize = arraySize;\n+            this.stats = stats;\n+            this.arrays = new int[capacity][];\n+        }\n+\n+        int[] getArray() {\n+            if (DO_STATS) {\n+                stats.getOp++;\n+            }\n+            \/\/ use cache:\n+            if (tail != 0) {\n+                final int[] array = arrays[--tail];\n+                arrays[tail] = null;\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                stats.createOp++;\n+            }\n+            return createArray(arraySize);\n+        }\n+\n+        void putArray(final int[] array)\n+        {\n+            if (DO_CHECKS && (array.length != arraySize)) {\n+                logInfo(\"ArrayCacheInt(Clean): \"\n+                        + \"bad length = \" + array.length);\n+                return;\n+            }\n+            if (DO_STATS) {\n+                stats.returnOp++;\n+            }\n+            \/\/ fill cache:\n+            if (arrays.length > tail) {\n+                arrays[tail++] = array;\n+\n+                if (DO_STATS) {\n+                    stats.updateMaxSize(tail);\n+                }\n+            } else if (DO_CHECKS) {\n+                logInfo(\"ArrayCacheInt(Clean): \"\n+                        + \"array capacity exceeded !\");\n+            }\n+        }\n+    }\n+\n+    static int[] createArray(final int length) {\n+        return new int[length];\n+    }\n+\n+    static void fill(final int[] array, final int fromIndex,\n+                     final int toIndex, final int value)\n+    {\n+        \/\/ clear array data:\n+        Arrays.fill(array, fromIndex, toIndex, value);\n+        if (DO_CHECKS) {\n+            check(array, fromIndex, toIndex, value);\n+        }\n+    }\n+\n+    static void check(final int[] array, final int fromIndex,\n+                      final int toIndex, final int value)\n+    {\n+        if (DO_CHECKS) {\n+            \/\/ check zero on full array:\n+            for (int i = 0; i < array.length; i++) {\n+                if (array[i] != value) {\n+                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n+                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n+                            + Arrays.toString(array), new Throwable());\n+\n+                    \/\/ ensure array is correctly filled:\n+                    Arrays.fill(array, value);\n+\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/ArrayCacheIntClean.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import static sun.java2d.marlin.ArrayCacheConst.ARRAY_SIZES;\n-import static sun.java2d.marlin.ArrayCacheConst.BUCKETS;\n-import static sun.java2d.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n-import static sun.java2d.marlin.MarlinUtils.logInfo;\n-import static sun.java2d.marlin.MarlinUtils.logException;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-\n-import sun.java2d.marlin.ArrayCacheConst.BucketStats;\n-import sun.java2d.marlin.ArrayCacheConst.CacheStats;\n-\n-\/*\n- * Note that the [BYTE\/INT\/FLOAT\/DOUBLE]ArrayCache files are nearly identical except\n- * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n- * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n- * files are generated with the following command lines:\n- *\/\n-\/\/ % sed -e 's\/(b\\yte)[ ]*\/\/g' -e 's\/b\\yte\/int\/g' -e 's\/B\\yte\/Int\/g' < B\\yteArrayCache.java > IntArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0f\/g' -e 's\/(b\\yte)[ ]*\/(float) \/g' -e 's\/b\\yte\/float\/g' -e 's\/B\\yte\/Float\/g' < B\\yteArrayCache.java > FloatArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0d\/g' -e 's\/(b\\yte)[ ]*\/(double) \/g' -e 's\/b\\yte\/double\/g' -e 's\/B\\yte\/Double\/g' < B\\yteArrayCache.java > DoubleArrayCache.java\n-\n-final class ByteArrayCache implements MarlinConst {\n-\n-    final boolean clean;\n-    private final int bucketCapacity;\n-    private WeakReference<Bucket[]> refBuckets = null;\n-    final CacheStats stats;\n-\n-    ByteArrayCache(final boolean clean, final int bucketCapacity) {\n-        this.clean = clean;\n-        this.bucketCapacity = bucketCapacity;\n-        this.stats = (DO_STATS) ?\n-            new CacheStats(getLogPrefix(clean) + \"ByteArrayCache\") : null;\n-    }\n-\n-    Bucket getCacheBucket(final int length) {\n-        final int bucket = ArrayCacheConst.getBucket(length);\n-        return getBuckets()[bucket];\n-    }\n-\n-    private Bucket[] getBuckets() {\n-        \/\/ resolve reference:\n-        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n-\n-        \/\/ create a new buckets ?\n-        if (buckets == null) {\n-            buckets = new Bucket[BUCKETS];\n-\n-            for (int i = 0; i < BUCKETS; i++) {\n-                buckets[i] = new Bucket(clean, ARRAY_SIZES[i], bucketCapacity,\n-                        (DO_STATS) ? stats.bucketStats[i] : null);\n-            }\n-\n-            \/\/ update weak reference:\n-            refBuckets = new WeakReference<Bucket[]>(buckets);\n-        }\n-        return buckets;\n-    }\n-\n-    Reference createRef(final int initialSize) {\n-        return new Reference(this, initialSize);\n-    }\n-\n-    static final class Reference {\n-\n-        \/\/ initial array reference (direct access)\n-        final byte[] initial;\n-        private final boolean clean;\n-        private final ByteArrayCache cache;\n-\n-        Reference(final ByteArrayCache cache, final int initialSize) {\n-            this.cache = cache;\n-            this.clean = cache.clean;\n-            this.initial = createArray(initialSize);\n-            if (DO_STATS) {\n-                cache.stats.totalInitial += initialSize;\n-            }\n-        }\n-\n-        byte[] getArray(final int length) {\n-            if (length <= MAX_ARRAY_SIZE) {\n-                return cache.getCacheBucket(length).getArray();\n-            }\n-            if (DO_STATS) {\n-                cache.stats.oversize++;\n-            }\n-            if (DO_LOG_OVERSIZE) {\n-                logInfo(getLogPrefix(clean) + \"ByteArrayCache: \"\n-                        + \"getArray[oversize]: length=\\t\" + length);\n-            }\n-            return createArray(length);\n-        }\n-\n-        byte[] widenArray(final byte[] array, final int usedSize,\n-                          final int needSize)\n-        {\n-            final int length = array.length;\n-            if (DO_CHECKS && length >= needSize) {\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                cache.stats.resize++;\n-            }\n-\n-            \/\/ maybe change bucket:\n-            \/\/ ensure getNewSize() > newSize:\n-            final byte[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n-\n-            \/\/ use wrapper to ensure proper copy:\n-            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n-\n-            \/\/ maybe return current array:\n-            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n-\n-            if (DO_LOG_WIDEN_ARRAY) {\n-                logInfo(getLogPrefix(clean) + \"ByteArrayCache: \"\n-                        + \"widenArray[\" + res.length\n-                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n-                        + \"\\tneeded length=\\t\" + needSize);\n-            }\n-            return res;\n-        }\n-\n-        byte[] putArray(final byte[] array)\n-        {\n-            \/\/ dirty array helper:\n-            return putArray(array, 0, array.length);\n-        }\n-\n-        byte[] putArray(final byte[] array, final int fromIndex,\n-                        final int toIndex)\n-        {\n-            if (array.length <= MAX_ARRAY_SIZE) {\n-                if ((clean || DO_CLEAN_DIRTY) && (toIndex != 0)) {\n-                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n-                    fill(array, fromIndex, toIndex, (byte)0);\n-                }\n-                \/\/ ensure to never store initial arrays in cache:\n-                if (array != initial) {\n-                    cache.getCacheBucket(array.length).putArray(array);\n-                }\n-            }\n-            return initial;\n-        }\n-    }\n-\n-    static final class Bucket {\n-\n-        private int tail = 0;\n-        private final int arraySize;\n-        private final boolean clean;\n-        private final byte[][] arrays;\n-        private final BucketStats stats;\n-\n-        Bucket(final boolean clean, final int arraySize,\n-               final int capacity, final BucketStats stats)\n-        {\n-            this.arraySize = arraySize;\n-            this.clean = clean;\n-            this.stats = stats;\n-            this.arrays = new byte[capacity][];\n-        }\n-\n-        byte[] getArray() {\n-            if (DO_STATS) {\n-                stats.getOp++;\n-            }\n-            \/\/ use cache:\n-            if (tail != 0) {\n-                final byte[] array = arrays[--tail];\n-                arrays[tail] = null;\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                stats.createOp++;\n-            }\n-            return createArray(arraySize);\n-        }\n-\n-        void putArray(final byte[] array)\n-        {\n-            if (DO_CHECKS && (array.length != arraySize)) {\n-                logInfo(getLogPrefix(clean) + \"ByteArrayCache: \"\n-                        + \"bad length = \" + array.length);\n-                return;\n-            }\n-            if (DO_STATS) {\n-                stats.returnOp++;\n-            }\n-            \/\/ fill cache:\n-            if (arrays.length > tail) {\n-                arrays[tail++] = array;\n-\n-                if (DO_STATS) {\n-                    stats.updateMaxSize(tail);\n-                }\n-            } else if (DO_CHECKS) {\n-                logInfo(getLogPrefix(clean) + \"ByteArrayCache: \"\n-                        + \"array capacity exceeded !\");\n-            }\n-        }\n-    }\n-\n-    static byte[] createArray(final int length) {\n-        return new byte[length];\n-    }\n-\n-    static void fill(final byte[] array, final int fromIndex,\n-                     final int toIndex, final byte value)\n-    {\n-        \/\/ clear array data:\n-        Arrays.fill(array, fromIndex, toIndex, value);\n-        if (DO_CHECKS) {\n-            check(array, fromIndex, toIndex, value);\n-        }\n-    }\n-\n-    static void check(final byte[] array, final int fromIndex,\n-                      final int toIndex, final byte value)\n-    {\n-        if (DO_CHECKS) {\n-            \/\/ check zero on full array:\n-            for (int i = 0; i < array.length; i++) {\n-                if (array[i] != value) {\n-                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n-                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n-                            + Arrays.toString(array), new Throwable());\n-\n-                    \/\/ ensure array is correctly filled:\n-                    Arrays.fill(array, value);\n-\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    static String getLogPrefix(final boolean clean) {\n-        return (clean) ? \"Clean\" : \"Dirty\";\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/ByteArrayCache.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n-    };\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/CollinearSimplifier.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1201,0 +1201,4 @@\n+        logInfo(\"sun.java2d.renderer.profile          = \"\n+                + (MarlinProperties.isProfileQuality() ?\n+                    \"quality\" : \"speed\"));\n+\n@@ -1234,0 +1238,5 @@\n+        logInfo(\"sun.java2d.renderer.stroker.joinError= \"\n+                + MarlinProperties.getStrokerJoinError());\n+        logInfo(\"sun.java2d.renderer.stroker.joinStyle= \"\n+                + MarlinProperties.getStrokerJoinStyle());\n+\n@@ -1252,0 +1261,5 @@\n+        logInfo(\"sun.java2d.renderer.skip_rdr         = \"\n+                + MarlinProperties.isSkipRenderer());\n+        logInfo(\"sun.java2d.renderer.skip_pipe        = \"\n+                + MarlinProperties.isSkipRenderTiles());\n+\n@@ -1271,0 +1285,1 @@\n+        logInfo(\"SORT         = \" + MergeSort.SORT_TYPE);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DMarlinRenderingEngine.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.java2d.marlin;\n+\n+\/**\n+ * DPQS Sorter context\n+ *\/\n+final class DPQSSorterContext {\n+\n+    static final boolean LOG_ALLOC = false;\n+    static final boolean CHECK_ALLOC = false && LOG_ALLOC;\n+\n+    \/**\n+     * Max capacity of the index array for tracking runs.\n+     *\/\n+    static final int MAX_RUN_CAPACITY = DualPivotQuicksort20191112Ext.MAX_RUN_CAPACITY;\n+\n+    \/* members *\/\n+    final int[] run;\n+    int[] auxA;\n+    int[] auxB;\n+    boolean runInit;\n+\n+    DPQSSorterContext() {\n+        \/\/ preallocate max runs:\n+        if (LOG_ALLOC) {\n+            MarlinUtils.logInfo(\"alloc run: \" + MAX_RUN_CAPACITY);\n+        }\n+        run = new int[MAX_RUN_CAPACITY];\n+    }\n+\n+    void initBuffers(final int length, final int[] a, final int[] b) {\n+        auxA = a;\n+        if (CHECK_ALLOC && (a.length < length)) {\n+            if (LOG_ALLOC) {\n+                MarlinUtils.logInfo(\"alloc auxA: \" + length);\n+            }\n+            auxA = new int[length];\n+        }\n+        auxB = b;\n+        if (CHECK_ALLOC && (b.length < length)) {\n+            if (LOG_ALLOC) {\n+                MarlinUtils.logInfo(\"alloc auxB: \" + length);\n+            }\n+            auxB = new int[length];\n+        }\n+        runInit = true;\n+    }\n+\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DPQSSorterContext.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-     * @see java.awt.geom.Path2D.Float#moveTo\n+     * @see java.awt.geom.Path2D.Double#moveTo\n@@ -35,1 +35,1 @@\n-     * @see java.awt.geom.Path2D.Float#lineTo\n+     * @see java.awt.geom.Path2D.Double#lineTo\n@@ -40,1 +40,1 @@\n-     * @see java.awt.geom.Path2D.Float#quadTo\n+     * @see java.awt.geom.Path2D.Double#quadTo\n@@ -46,1 +46,1 @@\n-     * @see java.awt.geom.Path2D.Float#curveTo\n+     * @see java.awt.geom.Path2D.Double#curveTo\n@@ -53,1 +53,1 @@\n-     * @see java.awt.geom.Path2D.Float#closePath\n+     * @see java.awt.geom.Path2D.Double#closePath\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DPathConsumer2D.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import sun.java2d.marlin.TransformingPathConsumer2D.StartFlagPathConsumer2D;\n@@ -43,1 +44,1 @@\n-final class Dasher implements DPathConsumer2D, MarlinConst {\n+final class Dasher implements StartFlagPathConsumer2D, MarlinConst {\n@@ -93,1 +94,1 @@\n-    final DoubleArrayCache.Reference dashes_ref;\n+    final ArrayCacheDouble.Reference dashes_ref;\n@@ -95,1 +96,1 @@\n-    final DoubleArrayCache.Reference firstSegmentsBuffer_ref;\n+    final ArrayCacheDouble.Reference firstSegmentsBuffer_ref;\n@@ -226,1 +227,6 @@\n-            dash = dashes_ref.putArray(dash);\n+            if (dashes_ref.doCleanRef(dash)) {\n+                dash = dashes_ref.putArray(dash);\n+            }\n+        }\n+        if (firstSegmentsBuffer_ref.doCleanRef(firstSegmentsBuffer)) {\n+            firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);\n@@ -228,1 +234,0 @@\n-        firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);\n@@ -346,2 +351,9 @@\n-        \/\/ small arraycopy (2, 4 or 6) but with offset:\n-        System.arraycopy(pts, off, buf, segIdx, len);\n+\n+        if (true && (len == 2)) {\n+            \/\/ most probable case:\n+            buf[segIdx    ] = pts[off    ];\n+            buf[segIdx + 1] = pts[off + 1];\n+        } else {\n+            \/\/ small arraycopy (4 or 6) but with offset:\n+            System.arraycopy(pts, off, buf, segIdx, len);\n+        }\n@@ -351,0 +363,20 @@\n+    \/* Callback from CurveClipSplitter *\/\n+    @Override\n+    public void setStartFlag(boolean first) {\n+        if (first) {\n+            \/\/ reset flag:\n+            rdrCtx.firstFlags &= 0b011;\n+        } else {\n+            rdrCtx.firstFlags |= 0b100;\n+        }\n+    }\n+\n+    public void setMonotonizerStartFlag(boolean first) {\n+        if (first) {\n+            \/\/ reset flag:\n+            rdrCtx.firstFlags &= 0b101;\n+        } else {\n+            rdrCtx.firstFlags |= 0b010;\n+        }\n+    }\n+\n@@ -541,1 +573,1 @@\n-        if (pointCurve(_curCurvepts, type)) {\n+        if (Helpers.isPointCurve(_curCurvepts, type)) {\n@@ -597,1 +629,1 @@\n-        if (pointCurve(_curCurvepts, type)) {\n+        if (Helpers.isPointCurve(_curCurvepts, type)) {\n@@ -617,9 +649,0 @@\n-    private static boolean pointCurve(final double[] curve, final int type) {\n-        for (int i = 2; i < type; i++) {\n-            if (curve[i] != curve[i-2]) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n@@ -707,1 +730,3 @@\n-            goLeft(); \/\/ initializes nextT and lenAtNextT properly\n+            \/\/ initializes nextT and lenAtNextT properly\n+            goLeft();\n+\n@@ -813,1 +838,1 @@\n-                if (n == 1 && !Double.isNaN(nextRoots[0])) {\n+                if (n == 1) {\n@@ -960,1 +985,0 @@\n-\n@@ -990,0 +1014,5 @@\n+\n+            if (i == 0) {\n+                \/\/ disable start flag:\n+                setMonotonizerStartFlag(false);\n+            }\n@@ -991,0 +1020,2 @@\n+        \/\/ reset start flag:\n+        setMonotonizerStartFlag(true);\n@@ -1046,1 +1077,0 @@\n-\n@@ -1075,0 +1105,5 @@\n+\n+            if (i == 0) {\n+                \/\/ disable start flag:\n+                setMonotonizerStartFlag(false);\n+            }\n@@ -1076,0 +1111,2 @@\n+        \/\/ reset start flag:\n+        setMonotonizerStartFlag(true);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Dasher.java","additions":60,"deletions":23,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import static sun.java2d.marlin.ArrayCacheConst.ARRAY_SIZES;\n-import static sun.java2d.marlin.ArrayCacheConst.BUCKETS;\n-import static sun.java2d.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n-import static sun.java2d.marlin.MarlinUtils.logInfo;\n-import static sun.java2d.marlin.MarlinUtils.logException;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-\n-import sun.java2d.marlin.ArrayCacheConst.BucketStats;\n-import sun.java2d.marlin.ArrayCacheConst.CacheStats;\n-\n-\/*\n- * Note that the [BYTE\/INT\/FLOAT\/DOUBLE]ArrayCache files are nearly identical except\n- * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n- * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n- * files are generated with the following command lines:\n- *\/\n-\/\/ % sed -e 's\/(b\\yte)[ ]*\/\/g' -e 's\/b\\yte\/int\/g' -e 's\/B\\yte\/Int\/g' < B\\yteArrayCache.java > IntArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0f\/g' -e 's\/(b\\yte)[ ]*\/(float) \/g' -e 's\/b\\yte\/float\/g' -e 's\/B\\yte\/Float\/g' < B\\yteArrayCache.java > FloatArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0d\/g' -e 's\/(b\\yte)[ ]*\/(double) \/g' -e 's\/b\\yte\/double\/g' -e 's\/B\\yte\/Double\/g' < B\\yteArrayCache.java > DoubleArrayCache.java\n-\n-final class DoubleArrayCache implements MarlinConst {\n-\n-    final boolean clean;\n-    private final int bucketCapacity;\n-    private WeakReference<Bucket[]> refBuckets = null;\n-    final CacheStats stats;\n-\n-    DoubleArrayCache(final boolean clean, final int bucketCapacity) {\n-        this.clean = clean;\n-        this.bucketCapacity = bucketCapacity;\n-        this.stats = (DO_STATS) ?\n-            new CacheStats(getLogPrefix(clean) + \"DoubleArrayCache\") : null;\n-    }\n-\n-    Bucket getCacheBucket(final int length) {\n-        final int bucket = ArrayCacheConst.getBucket(length);\n-        return getBuckets()[bucket];\n-    }\n-\n-    private Bucket[] getBuckets() {\n-        \/\/ resolve reference:\n-        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n-\n-        \/\/ create a new buckets ?\n-        if (buckets == null) {\n-            buckets = new Bucket[BUCKETS];\n-\n-            for (int i = 0; i < BUCKETS; i++) {\n-                buckets[i] = new Bucket(clean, ARRAY_SIZES[i], bucketCapacity,\n-                        (DO_STATS) ? stats.bucketStats[i] : null);\n-            }\n-\n-            \/\/ update weak reference:\n-            refBuckets = new WeakReference<Bucket[]>(buckets);\n-        }\n-        return buckets;\n-    }\n-\n-    Reference createRef(final int initialSize) {\n-        return new Reference(this, initialSize);\n-    }\n-\n-    static final class Reference {\n-\n-        \/\/ initial array reference (direct access)\n-        final double[] initial;\n-        private final boolean clean;\n-        private final DoubleArrayCache cache;\n-\n-        Reference(final DoubleArrayCache cache, final int initialSize) {\n-            this.cache = cache;\n-            this.clean = cache.clean;\n-            this.initial = createArray(initialSize);\n-            if (DO_STATS) {\n-                cache.stats.totalInitial += initialSize;\n-            }\n-        }\n-\n-        double[] getArray(final int length) {\n-            if (length <= MAX_ARRAY_SIZE) {\n-                return cache.getCacheBucket(length).getArray();\n-            }\n-            if (DO_STATS) {\n-                cache.stats.oversize++;\n-            }\n-            if (DO_LOG_OVERSIZE) {\n-                logInfo(getLogPrefix(clean) + \"DoubleArrayCache: \"\n-                        + \"getArray[oversize]: length=\\t\" + length);\n-            }\n-            return createArray(length);\n-        }\n-\n-        double[] widenArray(final double[] array, final int usedSize,\n-                          final int needSize)\n-        {\n-            final int length = array.length;\n-            if (DO_CHECKS && length >= needSize) {\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                cache.stats.resize++;\n-            }\n-\n-            \/\/ maybe change bucket:\n-            \/\/ ensure getNewSize() > newSize:\n-            final double[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n-\n-            \/\/ use wrapper to ensure proper copy:\n-            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n-\n-            \/\/ maybe return current array:\n-            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n-\n-            if (DO_LOG_WIDEN_ARRAY) {\n-                logInfo(getLogPrefix(clean) + \"DoubleArrayCache: \"\n-                        + \"widenArray[\" + res.length\n-                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n-                        + \"\\tneeded length=\\t\" + needSize);\n-            }\n-            return res;\n-        }\n-\n-        double[] putArray(final double[] array)\n-        {\n-            \/\/ dirty array helper:\n-            return putArray(array, 0, array.length);\n-        }\n-\n-        double[] putArray(final double[] array, final int fromIndex,\n-                        final int toIndex)\n-        {\n-            if (array.length <= MAX_ARRAY_SIZE) {\n-                if ((clean || DO_CLEAN_DIRTY) && (toIndex != 0)) {\n-                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n-                    fill(array, fromIndex, toIndex, 0.0d);\n-                }\n-                \/\/ ensure to never store initial arrays in cache:\n-                if (array != initial) {\n-                    cache.getCacheBucket(array.length).putArray(array);\n-                }\n-            }\n-            return initial;\n-        }\n-    }\n-\n-    static final class Bucket {\n-\n-        private int tail = 0;\n-        private final int arraySize;\n-        private final boolean clean;\n-        private final double[][] arrays;\n-        private final BucketStats stats;\n-\n-        Bucket(final boolean clean, final int arraySize,\n-               final int capacity, final BucketStats stats)\n-        {\n-            this.arraySize = arraySize;\n-            this.clean = clean;\n-            this.stats = stats;\n-            this.arrays = new double[capacity][];\n-        }\n-\n-        double[] getArray() {\n-            if (DO_STATS) {\n-                stats.getOp++;\n-            }\n-            \/\/ use cache:\n-            if (tail != 0) {\n-                final double[] array = arrays[--tail];\n-                arrays[tail] = null;\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                stats.createOp++;\n-            }\n-            return createArray(arraySize);\n-        }\n-\n-        void putArray(final double[] array)\n-        {\n-            if (DO_CHECKS && (array.length != arraySize)) {\n-                logInfo(getLogPrefix(clean) + \"DoubleArrayCache: \"\n-                        + \"bad length = \" + array.length);\n-                return;\n-            }\n-            if (DO_STATS) {\n-                stats.returnOp++;\n-            }\n-            \/\/ fill cache:\n-            if (arrays.length > tail) {\n-                arrays[tail++] = array;\n-\n-                if (DO_STATS) {\n-                    stats.updateMaxSize(tail);\n-                }\n-            } else if (DO_CHECKS) {\n-                logInfo(getLogPrefix(clean) + \"DoubleArrayCache: \"\n-                        + \"array capacity exceeded !\");\n-            }\n-        }\n-    }\n-\n-    static double[] createArray(final int length) {\n-        return new double[length];\n-    }\n-\n-    static void fill(final double[] array, final int fromIndex,\n-                     final int toIndex, final double value)\n-    {\n-        \/\/ clear array data:\n-        Arrays.fill(array, fromIndex, toIndex, value);\n-        if (DO_CHECKS) {\n-            check(array, fromIndex, toIndex, value);\n-        }\n-    }\n-\n-    static void check(final double[] array, final int fromIndex,\n-                      final int toIndex, final double value)\n-    {\n-        if (DO_CHECKS) {\n-            \/\/ check zero on full array:\n-            for (int i = 0; i < array.length; i++) {\n-                if (array[i] != value) {\n-                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n-                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n-                            + Arrays.toString(array), new Throwable());\n-\n-                    \/\/ ensure array is correctly filled:\n-                    Arrays.fill(array, value);\n-\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    static String getLogPrefix(final boolean clean) {\n-        return (clean) ? \"Clean\" : \"Dirty\";\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DoubleArrayCache.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -0,0 +1,882 @@\n+\/*\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.marlin;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * This class implements powerful and fully optimized versions, both\n+ * sequential and parallel, of the Dual-Pivot Quicksort algorithm by\n+ * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n+ * offers O(n log(n)) performance on all data sets, and is typically\n+ * faster than traditional (one-pivot) Quicksort implementations.\n+ *\n+ * There are also additional algorithms, invoked from the Dual-Pivot\n+ * Quicksort, such as mixed insertion sort, merging of runs and heap\n+ * sort, counting sort and parallel merge sort.\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ * @author Jon Bentley\n+ * @author Josh Bloch\n+ * @author Doug Lea\n+ *\n+ * @version 2018.08.18\n+ *\n+ * @since 1.7 * 14\n+ *\/\n+public final class DualPivotQuicksort20191112Ext {\n+\n+    private static final boolean FAST_ISORT = true;\n+\n+    \/*\n+    From OpenJDK14 source code:\n+    8226297: Dual-pivot quicksort improvements\n+        Reviewed-by: dl, lbourges\n+        Contributed-by: Vladimir Yaroslavskiy <vlv.spb.ru@mail.ru>\n+        Tue, 12 Nov 2019 13:49:40 -0800\n+     *\/\n+    \/**\n+     * Prevents instantiation.\n+     *\/\n+    private DualPivotQuicksort20191112Ext() {\n+    }\n+\n+    \/**\n+     * Max array size to use mixed insertion sort.\n+     *\/\n+    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;\n+\n+    \/**\n+     * Max array size to use insertion sort.\n+     *\/\n+    private static final int MAX_INSERTION_SORT_SIZE = 44;\n+\n+    \/**\n+     * Min array size to try merging of runs.\n+     *\/\n+    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n+\n+    \/**\n+     * Min size of the first run to continue with scanning.\n+     *\/\n+    private static final int MIN_FIRST_RUN_SIZE = 16;\n+\n+    \/**\n+     * Min factor for the first runs to continue scanning.\n+     *\/\n+    private static final int MIN_FIRST_RUNS_FACTOR = 7;\n+\n+    \/**\n+     * Max capacity of the index array for tracking runs.\n+     *\/\n+    \/* private *\/ static final int MAX_RUN_CAPACITY = 5 << 10;\n+\n+    \/**\n+     * Threshold of mixed insertion sort is incremented by this value.\n+     *\/\n+    private static final int DELTA = 3 << 1;\n+\n+    \/**\n+     * Max recursive partitioning depth before using heap sort.\n+     *\/\n+    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n+\n+\n+    \/**\n+     * Sorts the specified range of the array.\n+     *\n+     * @param sorter sorter context\n+     * @param a the array to be sorted\n+     * @param auxA auxiliary storage for the array to be sorted\n+     * @param b the secondary array to be ordered\n+     * @param auxB auxiliary storage for the permutation array to be handled\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(DPQSSorterContext sorter, int[] a, int[] auxA, int[] b, int[] auxB, int low, int high) {\n+        \/*\n+         * LBO Shortcut: Invoke insertion sort on the leftmost part.\n+         *\/\n+        if (FAST_ISORT && ((high - low) <= MAX_INSERTION_SORT_SIZE)) {\n+            insertionSort(a, b, low, high);\n+            return;\n+        }\n+\n+        sorter.initBuffers(high, auxA, auxB);\n+        sort(sorter, a, b, 0, low, high);\n+    }\n+\n+    \/**\n+     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n+     * other sorts in special-cases, possibly with parallel partitions.\n+     *\n+     * @param sorter sorter context\n+     * @param a the array to be sorted\n+     * @param b the secondary array to be ordered\n+     * @param bits the combination of recursion depth and bit flag, where\n+     *        the right bit \"0\" indicates that array is the leftmost part\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void sort(DPQSSorterContext sorter, int[] a, int[] b, int bits, int low, int high) {\n+        while (true) {\n+            int end = high - 1, size = high - low;\n+\n+            \/*\n+             * Run mixed insertion sort on small non-leftmost parts.\n+             *\/\n+            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                mixedInsertionSort(a, b, low, high - 3 * ((size >> 5) << 3), high);\n+                return;\n+            }\n+\n+            \/*\n+             * Invoke insertion sort on small leftmost part.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE) {\n+                insertionSort(a, b, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * Check if the whole array or large non-leftmost\n+             * parts are nearly sorted and then merge runs.\n+             *\/\n+            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n+                    && tryMergeRuns(sorter, a, b, low, size)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort if execution\n+             * time is becoming quadratic.\n+             *\/\n+            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, b, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * Use an inexpensive approximation of the golden ratio\n+             * to select five sample elements and determine pivots.\n+             *\/\n+            int step = (size >> 3) * 3 + 3;\n+\n+            \/*\n+             * Five elements around (and including) the central element\n+             * will be used for pivot selection as described below. The\n+             * unequal choice of spacing these elements was empirically\n+             * determined to work well on a wide variety of inputs.\n+             *\/\n+            int e1 = low + step;\n+            int e5 = end - step;\n+            int e3 = (e1 + e5) >>> 1;\n+            int e2 = (e1 + e3) >>> 1;\n+            int e4 = (e3 + e5) >>> 1;\n+            int a3 = a[e3];\n+\n+            \/*\n+             * Sort these elements in place by the combination\n+             * of 4-element sorting network and insertion sort.\n+             *\n+             *    5 ------o-----------o------------\n+             *            |           |\n+             *    4 ------|-----o-----o-----o------\n+             *            |     |           |\n+             *    2 ------o-----|-----o-----o------\n+             *                  |     |\n+             *    1 ------------o-----o------------\n+             *\/\n+            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n+            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n+            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n+            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n+            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+\n+            if (a3 < a[e2]) {\n+                if (a3 < a[e1]) {\n+                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+                } else {\n+                    a[e3] = a[e2]; a[e2] = a3;\n+                }\n+            } else if (a3 > a[e4]) {\n+                if (a3 > a[e5]) {\n+                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+                } else {\n+                    a[e3] = a[e4]; a[e4] = a3;\n+                }\n+            }\n+\n+            \/\/ Pointers\n+            int lower = low; \/\/ The index of the last element of the left part\n+            int upper = end; \/\/ The index of the first element of the right part\n+\n+            \/*\n+             * Partitioning with 2 pivots in case of different elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+\n+                \/*\n+                 * Use the first and fifth of the five sorted elements as\n+                 * the pivots. These values are inexpensive approximation\n+                 * of tertiles. Note, that pivot1 < pivot2.\n+                 *\/\n+                int pivotA1 = a[e1];\n+                int pivotA2 = a[e5];\n+                int pivotB1 = b[e1];\n+                int pivotB2 = b[e5];\n+\n+                \/*\n+                 * The first and the last elements to be sorted are moved\n+                 * to the locations formerly occupied by the pivots. When\n+                 * partitioning is completed, the pivots are swapped back\n+                 * into their final positions, and excluded from the next\n+                 * subsequent sorting.\n+                 *\/\n+                a[e1] = a[lower];\n+                a[e5] = a[upper];\n+                b[e1] = b[lower];\n+                b[e5] = b[upper];\n+\n+                \/*\n+                 * Skip elements, which are less or greater than the pivots.\n+                 *\/\n+                while (a[++lower] < pivotA1);\n+                while (a[--upper] > pivotA2);\n+\n+                \/*\n+                 * Backward 3-interval partitioning\n+                 *\n+                 *   left part                 central part          right part\n+                 * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+                 * +------------------------------------------------------------+\n+                 *             ^       ^                            ^\n+                 *             |       |                            |\n+                 *           lower     k                          upper\n+                 *\n+                 * Invariants:\n+                 *\n+                 *              all in (low, lower] < pivot1\n+                 *    pivot1 <= all in (k, upper)  <= pivot2\n+                 *              all in [upper, end) > pivot2\n+                 *\n+                 * Pointer k is the last index of ?-part\n+                 *\/\n+                for (int unused = --lower, k = ++upper; --k > lower; ) {\n+                    int ak = a[k];\n+                    int bk = b[k];\n+\n+                    if (ak < pivotA1) { \/\/ Move a[k] to the left side\n+                        while (lower < k) {\n+                            if (a[++lower] >= pivotA1) {\n+                                if (a[lower] > pivotA2) {\n+                                    a[k] = a[--upper];\n+                                    a[upper] = a[lower];\n+                                    b[k] = b[  upper];\n+                                    b[upper] = b[lower];\n+                                } else {\n+                                    a[k] = a[lower];\n+                                    b[k] = b[lower];\n+                                }\n+                                a[lower] = ak;\n+                                b[lower] = bk;\n+                                break;\n+                            }\n+                        }\n+                    } else if (ak > pivotA2) { \/\/ Move a[k] to the right side\n+                        a[k] = a[--upper];\n+                        a[upper] = ak;\n+                        b[k] = b[  upper];\n+                        b[upper] = bk;\n+                    }\n+                }\n+\n+                \/*\n+                 * Swap the pivots into their final positions.\n+                 *\/\n+                a[low] = a[lower]; a[lower] = pivotA1;\n+                a[end] = a[upper]; a[upper] = pivotA2;\n+\n+                b[low] = b[lower]; b[lower] = pivotB1;\n+                b[end] = b[upper]; b[upper] = pivotB2;\n+\n+                \/*\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n+                 *\/\n+                sort(sorter, a, b, bits | 1, lower + 1, upper);\n+                sort(sorter, a, b, bits | 1, upper + 1, high);\n+\n+            } else { \/\/ Use single pivot in case of many equal elements\n+\n+                \/*\n+                 * Use the third of the five sorted elements as the pivot.\n+                 * This value is inexpensive approximation of the median.\n+                 *\/\n+                int pivotA = a[e3];\n+                int pivotB = b[e3];\n+\n+                \/*\n+                 * The first element to be sorted is moved to the\n+                 * location formerly occupied by the pivot. After\n+                 * completion of partitioning the pivot is swapped\n+                 * back into its final position, and excluded from\n+                 * the next subsequent sorting.\n+                 *\/\n+                a[e3] = a[lower];\n+                b[e3] = b[lower];\n+\n+                \/*\n+                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 *\n+                 *   left part                 central part    right part\n+                 * +------------------------------------------------------+\n+                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+                 * +------------------------------------------------------+\n+                 *              ^           ^                ^\n+                 *              |           |                |\n+                 *            lower         k              upper\n+                 *\n+                 * Invariants:\n+                 *\n+                 *   all in (low, lower] < pivot\n+                 *   all in (k, upper)  == pivot\n+                 *   all in [upper, end] > pivot\n+                 *\n+                 * Pointer k is the last index of ?-part\n+                 *\/\n+                for (int k = ++upper; --k > lower; ) {\n+                    int ak = a[k];\n+\n+                    if (ak != pivotA) {\n+                        a[k] = pivotA;\n+                        int bk = b[k];\n+\n+                        if (ak < pivotA) { \/\/ Move a[k] to the left side\n+                            while (a[++lower] < pivotA);\n+\n+                            if (a[lower] > pivotA) {\n+                                a[k] = a[--upper];\n+                                a[upper] = a[lower];\n+                                b[k] = b[  upper];\n+                                b[upper] = b[lower];\n+                            } else {\n+                                a[k] = a[lower];\n+                                b[k] = b[lower];\n+                            }\n+                            a[lower] = ak;\n+                            b[lower] = bk;\n+                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                            a[k] = a[--upper];\n+                            a[upper] = ak;\n+                            b[k] = b[  upper];\n+                            b[upper] = bk;\n+                        }\n+                    }\n+                }\n+\n+                \/*\n+                 * Swap the pivot into its final position.\n+                 *\/\n+                a[low] = a[lower]; a[lower] = pivotA;\n+                b[low] = b[lower]; b[lower] = pivotB;\n+\n+                \/*\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n+                 *\/\n+                sort(sorter, a, b, bits | 1, upper, high);\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using mixed insertion sort.\n+     *\n+     * Mixed insertion sort is combination of simple insertion sort,\n+     * pin insertion sort and pair insertion sort.\n+     *\n+     * In the context of Dual-Pivot Quicksort, the pivot element\n+     * from the left part plays the role of sentinel, because it\n+     * is less than any elements from the given part. Therefore,\n+     * expensive check of the left range can be skipped on each\n+     * iteration unless it is the leftmost call.\n+     *\n+     * @param a the array to be sorted\n+     * @param b the secondary array to be ordered\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param end the index of the last element for simple insertion sort\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void mixedInsertionSort(int[] a, int[] b, int low, int end, int high) {\n+        if (end == high) {\n+\n+            \/*\n+             * Invoke simple insertion sort on tiny array.\n+             *\/\n+            for (int i; ++low < end; ) {\n+                int ai = a[i = low];\n+\n+                if (ai < a[i - 1]) {\n+                    int bi = b[i];\n+\n+                    while (ai < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = ai;\n+                    b[i + 1] = bi;\n+                }\n+            }\n+        } else {\n+\n+            \/*\n+             * Start with pin insertion sort on small part.\n+             *\n+             * Pin insertion sort is extended simple insertion sort.\n+             * The main idea of this sort is to put elements larger\n+             * than an element called pin to the end of array (the\n+             * proper area for such elements). It avoids expensive\n+             * movements of these elements through the whole array.\n+             *\/\n+            int pin = a[end];\n+\n+            for (int i, p = high; ++low < end; ) {\n+                int ai = a[i = low];\n+                int bi = b[i];\n+\n+                if (ai < a[i - 1]) { \/\/ Small element\n+\n+                    \/*\n+                     * Insert small element into sorted part.\n+                     *\/\n+                    a[i] = a[i - 1];\n+                    b[i] = b[--i];\n+\n+                    while (ai < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = ai;\n+                    b[i + 1] = bi;\n+\n+                } else if (p > i && ai > pin) { \/\/ Large element\n+\n+                    \/*\n+                     * Find element smaller than pin.\n+                     *\/\n+                    while (a[--p] > pin);\n+\n+                    \/*\n+                     * Swap it with large element.\n+                     *\/\n+                    if (p > i) {\n+                        ai = a[p];\n+                        a[p] = a[i];\n+                        bi = b[p];\n+                        b[p] = b[i];\n+                    }\n+\n+                    \/*\n+                     * Insert small element into sorted part.\n+                     *\/\n+                    while (ai < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = ai;\n+                    b[i + 1] = bi;\n+                }\n+            }\n+\n+            \/*\n+             * Continue with pair insertion sort on remain part.\n+             *\/\n+            for (int i; low < high; ++low) {\n+                int a1 = a[i = low], a2 = a[++low];\n+                int b1 = b[i],       b2 = b[  low];\n+\n+                \/*\n+                 * Insert two elements per iteration: at first, insert the\n+                 * larger element and then insert the smaller element, but\n+                 * from the position where the larger element was inserted.\n+                 *\/\n+                if (a1 > a2) {\n+\n+                    while (a1 < a[--i]) {\n+                        a[i + 2] = a[i];\n+                        b[i + 2] = b[i];\n+                    }\n+                    a[++i + 1] = a1;\n+                    b[  i + 1] = b1;\n+\n+                    while (a2 < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = a2;\n+                    b[i + 1] = b2;\n+\n+                } else if (a1 < a[i - 1]) {\n+\n+                    while (a2 < a[--i]) {\n+                        a[i + 2] = a[i];\n+                        b[i + 2] = b[i];\n+                    }\n+                    a[++i + 1] = a2;\n+                    b[  i + 1] = b2;\n+\n+                    while (a1 < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = a1;\n+                    b[i + 1] = b1;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param b the secondary array to be ordered\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void insertionSort(int[] a, int[] b, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            int ai = a[i = k];\n+\n+            if (ai < a[i - 1]) {\n+                int bi = b[i];\n+\n+                while (--i >= low && ai < a[i]) {\n+                    a[i + 1] = a[i];\n+                    b[i + 1] = b[i];\n+                }\n+                a[i + 1] = ai;\n+                b[i + 1] = bi;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param b the secondary array to be ordered\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void heapSort(int[] a, int[] b, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, b, --k, a[k], b[k], low, high);\n+        }\n+        while (--high > low) {\n+            int maxA = a[low];\n+            int maxB = b[low];\n+            pushDown(a, b, low, a[high], b[high], low, high);\n+            a[high] = maxA;\n+            b[high] = maxB;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param b the secondary array to be ordered\n+     * @param p the start index\n+     * @param valueA the given element in a\n+     * @param valueB the given element in b\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(int[] a, int[] b, int p, int valueA, int valueB, int low, int high) {\n+        for (int k;; a[p] = a[k], b[p] = b[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= valueA) {\n+                break;\n+            }\n+        }\n+        a[p] = valueA;\n+        b[p] = valueB;\n+    }\n+\n+    \/**\n+     * Tries to sort the specified range of the array.\n+     *\n+     * @param sorter sorter context\n+     * @param a the array to be sorted\n+     * @param b the secondary array to be ordered\n+     * @param low the index of the first element to be sorted\n+     * @param size the array size\n+     * @return true if finally sorted, false otherwise\n+     *\/\n+    private static boolean tryMergeRuns(DPQSSorterContext sorter, int[] a, int[] b, int low, int size) {\n+\n+        \/*\n+         * The run array is constructed only if initial runs are\n+         * long enough to continue, run[i] then holds start index\n+         * of the i-th sequence of elements in non-descending order.\n+         *\/\n+        int[] run = null;\n+        int high = low + size;\n+        int count = 1, last = low;\n+\n+        \/*\n+         * Identify all possible runs.\n+         *\/\n+        for (int k = low + 1; k < high; ) {\n+\n+            \/*\n+             * Find the end index of the current run.\n+             *\/\n+            if (a[k - 1] < a[k]) {\n+\n+                \/\/ Identify ascending sequence\n+                while (++k < high && a[k - 1] <= a[k]);\n+\n+            } else if (a[k - 1] > a[k]) {\n+\n+                \/\/ Identify descending sequence\n+                while (++k < high && a[k - 1] >= a[k]);\n+\n+                \/\/ Reverse into ascending order\n+                for (int i = last - 1, j = k, t; ++i < --j && a[i] > a[j]; ) {\n+                    t = a[i]; a[i] = a[j]; a[j] = t;\n+                    t = b[i]; b[i] = b[j]; b[j] = t;\n+                }\n+            } else { \/\/ Identify constant sequence\n+                for (int ak = a[k]; ++k < high && ak == a[k]; );\n+\n+                if (k < high) {\n+                    continue;\n+                }\n+            }\n+\n+            \/*\n+             * Check special cases.\n+             *\/\n+            if (sorter.runInit || run == null) {\n+                sorter.runInit = false; \/\/ LBO\n+\n+                if (k == high) {\n+\n+                    \/*\n+                     * The array is monotonous sequence,\n+                     * and therefore already sorted.\n+                     *\/\n+                    return true;\n+                }\n+\n+                if (k - low < MIN_FIRST_RUN_SIZE) {\n+\n+                    \/*\n+                     * The first run is too small\n+                     * to proceed with scanning.\n+                     *\/\n+                    return false;\n+                }\n+\n+\/\/                System.out.println(\"alloc run\");\n+\/\/                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = sorter.run; \/\/ LBO: prealloc\n+                run[0] = low;\n+\n+            } else if (a[last - 1] > a[last]) {\n+\n+                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+\n+                    \/*\n+                     * The first runs are not long\n+                     * enough to continue scanning.\n+                     *\/\n+                    return false;\n+                }\n+\n+                if (++count == MAX_RUN_CAPACITY) {\n+\n+                    \/*\n+                     * Array is not highly structured.\n+                     *\/\n+                    return false;\n+                }\n+\n+                if (false && count == run.length) {\n+\n+                    \/*\n+                     * Increase capacity of index array.\n+                     *\/\n+\/\/                  System.out.println(\"alloc run (resize)\");\n+                    run = Arrays.copyOf(run, count << 1);\n+                }\n+            }\n+            run[count] = (last = k);\n+\n+            \/\/ fix ALMOST_CONTIGUOUS ie consecutive (ascending \/ descending runs)\n+            if (k < high - 1) {\n+                k++; \/\/ LBO\n+            }\n+        }\n+\n+        \/*\n+         * Merge runs of highly structured array.\n+         *\/\n+        if (count > 1) {\n+            int[] auxA = sorter.auxA;\n+            int[] auxB = sorter.auxB;\n+            int offset = low;\n+\n+            \/\/ LBO: prealloc\n+            if ((auxA.length < size || auxB.length < size)) {\n+\/\/                System.out.println(\"alloc aux: \"+size);\n+                auxA = new int[size];\n+                auxB = new int[size];\n+            }\n+            mergeRuns(a, auxA, b, auxB, offset, 1, run, 0, count);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Merges the specified runs.\n+     *\n+     * @param srcA the source array for the array to be sorted (a)\n+     * @param dstA the temporary buffer used in merging (a)\n+     * @param srcB the source array for the secondary array to be ordered (b)\n+     * @param offset the start index in the source, inclusive\n+     * @param dstB the temporary buffer used in merging (b)\n+     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n+     * @param run the start indexes of the runs, inclusive\n+     * @param lo the start index of the first run, inclusive\n+     * @param hi the start index of the last run, inclusive\n+     * @return the destination where runs are merged\n+     *\/\n+    private static int[] mergeRuns(int[] srcA, int[] dstA, int[] srcB, int[] dstB, int offset,\n+                                   int aim, int[] run, int lo, int hi) {\n+\n+        if (hi - lo == 1) {\n+            if (aim >= 0) {\n+                return srcA;\n+            }\n+            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n+                --j, --i, dstA[j] = srcA[i], dstB[j] = srcB[i]\n+            );\n+            return dstA;\n+        }\n+\n+        \/*\n+         * Split into approximately equal parts.\n+         *\/\n+        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= rmi);\n+\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        int[] a1, a2;\n+        a1 = mergeRuns(srcA, dstA, srcB, dstB, offset, -aim, run, lo, mi);\n+        a2 = mergeRuns(srcA, dstA, srcB, dstB, offset,    0, run, mi, hi);\n+\n+        int[] b1, b2;\n+        b1 = a1 == srcA ? srcB : dstB;\n+        b2 = a2 == srcA ? srcB : dstB;\n+\n+        int[] resA = a1 == srcA ? dstA : srcA;\n+        int[] resB = a1 == srcA ? dstB : srcB;\n+\n+        int k   = a1 == srcA ? run[lo] - offset : run[lo];\n+        int lo1 = a1 == dstA ? run[lo] - offset : run[lo];\n+        int hi1 = a1 == dstA ? run[mi] - offset : run[mi];\n+        int lo2 = a2 == dstA ? run[mi] - offset : run[mi];\n+        int hi2 = a2 == dstA ? run[hi] - offset : run[hi];\n+\n+        mergeParts(resA, resB, k, a1, b1, lo1, hi1, a2, b2, lo2, hi2);\n+\n+        return resA;\n+    }\n+\n+    \/**\n+     * Merges the sorted parts.\n+     *\n+     * @param dstA the destination where parts are merged (a)\n+     * @param dstB the destination where parts are merged (b)\n+     * @param k the start index of the destination, inclusive\n+     * @param a1 the first part (a)\n+     * @param b1 the first part (b)\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param a2 the second part (a)\n+     * @param b2 the second part (b)\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(int[] dstA, int[] dstB, int k,\n+                                   int[] a1, int[] b1, int lo1, int hi1, int[] a2, int[] b2, int lo2, int hi2) {\n+\/\/ ...\n+        \/*\n+         * Merge small parts sequentially.\n+         *\/\n+        while (lo1 < hi1 && lo2 < hi2) {\n+            if (a1[lo1] < a2[lo2]) {\n+                dstA[k] = a1[lo1];\n+                dstB[k] = b1[lo1];\n+                k++; lo1++;\n+            } else {\n+                dstA[k] = a2[lo2];\n+                dstB[k] = b2[lo2];\n+                k++; lo2++;\n+            }\n+        }\n+        if (dstA != a1 || k < lo1) {\n+            while (lo1 < hi1) {\n+                dstA[k] = a1[lo1];\n+                dstB[k] = b1[lo1];\n+                k++; lo1++;\n+            }\n+        }\n+        if (dstA != a2 || k < lo2) {\n+            while (lo2 < hi2) {\n+                dstA[k] = a2[lo2];\n+                dstB[k] = b2[lo2];\n+                k++; lo2++;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DualPivotQuicksort20191112Ext.java","additions":882,"deletions":0,"binary":false,"changes":882,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,5 +36,0 @@\n-    \/\/ Copied from sun.misc.FloatConsts:\n-    public static final int FLOAT_SIGNIFICAND_WIDTH = 24;   \/\/ sun.misc.FloatConsts.SIGNIFICAND_WIDTH\n-    public static final int FLOAT_EXP_BIAS = 127;           \/\/ sun.misc.FloatConsts.EXP_BIAS\n-    public static final int FLOAT_EXP_BIT_MASK = 2139095040;\/\/ sun.misc.FloatConsts.EXP_BIT_MASK\n-    public static final int FLOAT_SIGNIF_BIT_MASK = 8388607;\/\/ sun.misc.FloatConsts.SIGNIF_BIT_MASK\n@@ -55,137 +50,0 @@\n-    \/**\n-     * Returns the smallest (closest to negative infinity) {@code float} value\n-     * that is greater than or equal to the argument and is equal to a\n-     * mathematical integer. Special cases:\n-     * <ul><li>If the argument value is already equal to a mathematical integer,\n-     * then the result is the same as the argument.  <li>If the argument is NaN\n-     * or an infinity or positive zero or negative zero, then the result is the\n-     * same as the argument.  <li>If the argument value is less than zero but\n-     * greater than -1.0, then the result is negative zero.<\/ul> Note that the\n-     * value of {@code StrictMath.ceil(x)} is exactly the value of\n-     * {@code -StrictMath.floor(-x)}.\n-     *\n-     * @param a a value.\n-     * @return the smallest (closest to negative infinity) floating-point value\n-     * that is greater than or equal to the argument and is equal to a\n-     * mathematical integer.\n-     *\/\n-    public static float ceil_f(final float a) {\n-        \/\/ Derived from StrictMath.ceil(double):\n-\n-        \/\/ Inline call to Math.getExponent(a) to\n-        \/\/ compute only once Float.floatToRawIntBits(a)\n-        final int doppel = Float.floatToRawIntBits(a);\n-\n-        final int exponent = ((doppel & FLOAT_EXP_BIT_MASK)\n-                >> (FLOAT_SIGNIFICAND_WIDTH - 1))\n-                - FLOAT_EXP_BIAS;\n-\n-        if (exponent < 0) {\n-            \/*\n-             * Absolute value of argument is less than 1.\n-             * floorOrceil(-0.0) => -0.0\n-             * floorOrceil(+0.0) => +0.0\n-             *\/\n-            return ((a == 0.0f) ? a :\n-                    ( (a < 0.0f) ? -0.0f : 1.0f) );\n-        }\n-        if (CHECK_OVERFLOW && (exponent >= 23)) { \/\/ 52 for double\n-            \/*\n-             * Infinity, NaN, or a value so large it must be integral.\n-             *\/\n-            return a;\n-        }\n-        \/\/ Else the argument is either an integral value already XOR it\n-        \/\/ has to be rounded to one.\n-        assert exponent >= 0 && exponent <= 22; \/\/ 51 for double\n-\n-        final int intpart = doppel\n-                & (~(FLOAT_SIGNIF_BIT_MASK >> exponent));\n-\n-        if (intpart == doppel) {\n-            return a; \/\/ integral value (including 0)\n-        }\n-\n-        \/\/ 0 handled above as an integer\n-        \/\/ sign: 1 for negative, 0 for positive numbers\n-        \/\/ add : 0 for negative and 1 for positive numbers\n-        return Float.intBitsToFloat(intpart) + ((~intpart) >>> 31);\n-    }\n-\n-    \/**\n-     * Returns the largest (closest to positive infinity) {@code float} value\n-     * that is less than or equal to the argument and is equal to a mathematical\n-     * integer. Special cases:\n-     * <ul><li>If the argument value is already equal to a mathematical integer,\n-     * then the result is the same as the argument.  <li>If the argument is NaN\n-     * or an infinity or positive zero or negative zero, then the result is the\n-     * same as the argument.<\/ul>\n-     *\n-     * @param a a value.\n-     * @return the largest (closest to positive infinity) floating-point value\n-     * that less than or equal to the argument and is equal to a mathematical\n-     * integer.\n-     *\/\n-    public static float floor_f(final float a) {\n-        \/\/ Derived from StrictMath.floor(double):\n-\n-        \/\/ Inline call to Math.getExponent(a) to\n-        \/\/ compute only once Float.floatToRawIntBits(a)\n-        final int doppel = Float.floatToRawIntBits(a);\n-\n-        final int exponent = ((doppel & FLOAT_EXP_BIT_MASK)\n-                >> (FLOAT_SIGNIFICAND_WIDTH - 1))\n-                - FLOAT_EXP_BIAS;\n-\n-        if (exponent < 0) {\n-            \/*\n-             * Absolute value of argument is less than 1.\n-             * floorOrceil(-0.0) => -0.0\n-             * floorOrceil(+0.0) => +0.0\n-             *\/\n-            return ((a == 0.0f) ? a :\n-                    ( (a < 0.0f) ? -1.0f : 0.0f) );\n-        }\n-        if (CHECK_OVERFLOW && (exponent >= 23)) { \/\/ 52 for double\n-            \/*\n-             * Infinity, NaN, or a value so large it must be integral.\n-             *\/\n-            return a;\n-        }\n-        \/\/ Else the argument is either an integral value already XOR it\n-        \/\/ has to be rounded to one.\n-        assert exponent >= 0 && exponent <= 22; \/\/ 51 for double\n-\n-        final int intpart = doppel\n-                & (~(FLOAT_SIGNIF_BIT_MASK >> exponent));\n-\n-        if (intpart == doppel) {\n-            return a; \/\/ integral value (including 0)\n-        }\n-\n-        \/\/ 0 handled above as an integer\n-        \/\/ sign: 1 for negative, 0 for positive numbers\n-        \/\/ add : -1 for negative and 0 for positive numbers\n-        return Float.intBitsToFloat(intpart) + (intpart >> 31);\n-    }\n-\n-    \/**\n-     * Faster alternative to ceil(float) optimized for the integer domain\n-     * and supporting NaN and +\/-Infinity.\n-     *\n-     * @param a a value.\n-     * @return the largest (closest to positive infinity) integer value\n-     * that less than or equal to the argument and is equal to a mathematical\n-     * integer.\n-     *\/\n-    public static int ceil_int(final float a) {\n-        final int intpart = (int) a;\n-\n-        if (a <= intpart\n-                || (CHECK_OVERFLOW && intpart == Integer.MAX_VALUE)\n-                || CHECK_NAN && Float.isNaN(a)) {\n-            return intpart;\n-        }\n-        return intpart + 1;\n-    }\n-\n@@ -212,20 +70,0 @@\n-    \/**\n-     * Faster alternative to floor(float) optimized for the integer domain\n-     * and supporting NaN and +\/-Infinity.\n-     *\n-     * @param a a value.\n-     * @return the largest (closest to positive infinity) floating-point value\n-     * that less than or equal to the argument and is equal to a mathematical\n-     * integer.\n-     *\/\n-    public static int floor_int(final float a) {\n-        final int intpart = (int) a;\n-\n-        if (a >= intpart\n-                || (CHECK_OVERFLOW && intpart == Integer.MIN_VALUE)\n-                || CHECK_NAN && Float.isNaN(a)) {\n-            return intpart;\n-        }\n-        return intpart - 1;\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/FloatMath.java","additions":1,"deletions":163,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+    private static final double EPS = 1e-9d;\n+\n@@ -38,0 +40,4 @@\n+    static boolean within(final double x, final double y) {\n+        return within(x, y, EPS);\n+    }\n+\n@@ -39,1 +45,4 @@\n-        final double d = y - x;\n+        return withinD(y - x, err);\n+    }\n+\n+    static boolean withinD(final double d, final double err) {\n@@ -43,0 +52,22 @@\n+    static boolean withinD(final double dx, final double dy, final double err)\n+    {\n+        assert err > 0 : \"\";\n+        \/\/ compare taxicab distance. ERR will always be small, so using\n+        \/\/ true distance won't give much benefit\n+        return (withinD(dx, err) && \/\/ we want to avoid calling Math.abs\n+                withinD(dy, err));  \/\/ this is just as good.\n+    }\n+\n+    static boolean isPointCurve(final double[] curve, final int type) {\n+        return isPointCurve(curve, type, EPS);\n+    }\n+\n+    static boolean isPointCurve(final double[] curve, final int type, final double err) {\n+        for (int i = 2; i < type; i++) {\n+            if (!within(curve[i], curve[i - 2], err)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -61,13 +92,10 @@\n-            final double dis = b*b - 4.0d * a * c;\n-            if (dis > 0.0d) {\n-                final double sqrtDis = Math.sqrt(dis);\n-                \/\/ depending on the sign of b we use a slightly different\n-                \/\/ algorithm than the traditional one to find one of the roots\n-                \/\/ so we can avoid adding numbers of different signs (which\n-                \/\/ might result in loss of precision).\n-                if (b >= 0.0d) {\n-                    zeroes[ret++] = (2.0d * c) \/ (-b - sqrtDis);\n-                    zeroes[ret++] = (-b - sqrtDis) \/ (2.0d * a);\n-                } else {\n-                    zeroes[ret++] = (-b + sqrtDis) \/ (2.0d * a);\n-                    zeroes[ret++] = (2.0d * c) \/ (-b + sqrtDis);\n+            double d = b * b - 4.0d * a * c;\n+            if (d > 0.0d) {\n+                d = Math.sqrt(d);\n+                \/\/ For accuracy, calculate one root using:\n+                \/\/     (-b +\/- d) \/ 2a\n+                \/\/ and the other using:\n+                \/\/     2c \/ (-b +\/- d)\n+                \/\/ Choose the sign of the +\/- so that b+d gets larger in magnitude\n+                if (b < 0.0d) {\n+                    d = -d;\n@@ -75,1 +103,7 @@\n-            } else if (dis == 0.0d) {\n+                final double q = (b + d) \/ -2.0d;\n+                \/\/ We already tested a for being 0 above\n+                zeroes[ret++] = q \/ a;\n+                if (q != 0.0d) {\n+                    zeroes[ret++] = c \/ q;\n+                }\n+            } else if (d == 0.0d) {\n@@ -100,4 +134,0 @@\n-\n-        \/*\n-         * TODO: cleanup all that code after reading Roots3And4.c\n-         *\/\n@@ -116,1 +146,0 @@\n-        final double sub = (1.0d \/ 3.0d) * a;\n@@ -119,0 +148,1 @@\n+        final double sub = (1.0d \/ 3.0d) * a;\n@@ -122,1 +152,0 @@\n-\n@@ -127,1 +156,14 @@\n-        if (D < 0.0d) {\n+\n+        if (within(D, 0.0d)) {\n+            if (within(q, 0.0d)) {\n+                \/* one triple solution *\/\n+                pts[off    ] = (- sub);\n+                num = 1;\n+            } else {\n+                \/* one single and one double solution *\/\n+                final double u = Math.cbrt(-q);\n+                pts[off    ] = (2.0d * u - sub);\n+                pts[off + 1] = (- u - sub);\n+                num = 2;\n+            }\n+        } else if (D < 0.0d) {\n@@ -143,5 +185,0 @@\n-\n-            if (within(D, 0.0d, 1e-8d)) {\n-                pts[off + 1] = ((-1.0d \/ 2.0d) * (u + v) - sub);\n-                num = 2;\n-            }\n@@ -149,1 +186,0 @@\n-\n@@ -624,1 +660,1 @@\n-        final DoubleArrayCache.Reference curves_ref;\n+        final ArrayCacheDouble.Reference curves_ref;\n@@ -626,1 +662,1 @@\n-        final ByteArrayCache.Reference curveTypes_ref;\n+        final ArrayCacheByte.Reference curveTypes_ref;\n@@ -673,1 +709,1 @@\n-            end = 0;\n+            end       = 0;\n@@ -688,2 +724,6 @@\n-            curves     = curves_ref.putArray(curves);\n-            curveTypes = curveTypes_ref.putArray(curveTypes);\n+            if (curves_ref.doCleanRef(curves)) {\n+                curves = curves_ref.putArray(curves);\n+            }\n+            if (curveTypes_ref.doCleanRef(curveTypes)) {\n+                curveTypes = curveTypes_ref.putArray(curveTypes);\n+            }\n@@ -693,1 +733,1 @@\n-            \/\/ use subtraction to avoid integer overflow:\n+            \/\/ use substraction to avoid integer overflow:\n@@ -829,1 +869,1 @@\n-            String ret = \"\";\n+            StringBuilder ret = new StringBuilder();\n@@ -837,1 +877,1 @@\n-                    ret += \"line: \";\n+                    ret.append(\"line: \");\n@@ -841,1 +881,1 @@\n-                    ret += \"quad: \";\n+                    ret.append(\"quad: \");\n@@ -845,1 +885,1 @@\n-                    ret += \"cubic: \";\n+                    ret.append(\"cubic: \");\n@@ -851,2 +891,1 @@\n-                ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+len))\n-                                       + \"\\n\";\n+                ret.append(Arrays.toString(Arrays.copyOfRange(curves, last, last + len))).append(\"\\n\");\n@@ -854,1 +893,1 @@\n-            return ret;\n+            return ret.toString();\n@@ -868,1 +907,1 @@\n-        private final IntArrayCache.Reference indices_ref;\n+        private final ArrayCacheInt.Reference indices_ref;\n@@ -914,2 +953,4 @@\n-            \/\/ values is kept dirty\n-            indices = indices_ref.putArray(indices);\n+            \/\/ indices is kept dirty\n+            if (indices_ref.doCleanRef(indices)) {\n+                indices = indices_ref.putArray(indices);\n+            }\n@@ -953,1 +994,3 @@\n-        void pullAll(final double[] points, final DPathConsumer2D io) {\n+        void pullAll(final double[] points, final DPathConsumer2D io,\n+                     final boolean moveFirst)\n+        {\n@@ -960,1 +1003,9 @@\n-            for (int i = 0, j; i < nc; i++) {\n+            int i = 0;\n+\n+            if (moveFirst) {\n+                int j = _values[i] << 1;\n+                io.moveTo(points[j], points[j + 1]);\n+                i++;\n+            }\n+\n+            for (int j; i < nc; i++) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Helpers.java","additions":98,"deletions":47,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import static sun.java2d.marlin.ArrayCacheConst.ARRAY_SIZES;\n-import static sun.java2d.marlin.ArrayCacheConst.BUCKETS;\n-import static sun.java2d.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n-import static sun.java2d.marlin.MarlinUtils.logInfo;\n-import static sun.java2d.marlin.MarlinUtils.logException;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-\n-import sun.java2d.marlin.ArrayCacheConst.BucketStats;\n-import sun.java2d.marlin.ArrayCacheConst.CacheStats;\n-\n-\/*\n- * Note that the [BYTE\/INT\/FLOAT\/DOUBLE]ArrayCache files are nearly identical except\n- * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n- * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n- * files are generated with the following command lines:\n- *\/\n-\/\/ % sed -e 's\/(b\\yte)[ ]*\/\/g' -e 's\/b\\yte\/int\/g' -e 's\/B\\yte\/Int\/g' < B\\yteArrayCache.java > IntArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0f\/g' -e 's\/(b\\yte)[ ]*\/(float) \/g' -e 's\/b\\yte\/float\/g' -e 's\/B\\yte\/Float\/g' < B\\yteArrayCache.java > FloatArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0d\/g' -e 's\/(b\\yte)[ ]*\/(double) \/g' -e 's\/b\\yte\/double\/g' -e 's\/B\\yte\/Double\/g' < B\\yteArrayCache.java > DoubleArrayCache.java\n-\n-final class IntArrayCache implements MarlinConst {\n-\n-    final boolean clean;\n-    private final int bucketCapacity;\n-    private WeakReference<Bucket[]> refBuckets = null;\n-    final CacheStats stats;\n-\n-    IntArrayCache(final boolean clean, final int bucketCapacity) {\n-        this.clean = clean;\n-        this.bucketCapacity = bucketCapacity;\n-        this.stats = (DO_STATS) ?\n-            new CacheStats(getLogPrefix(clean) + \"IntArrayCache\") : null;\n-    }\n-\n-    Bucket getCacheBucket(final int length) {\n-        final int bucket = ArrayCacheConst.getBucket(length);\n-        return getBuckets()[bucket];\n-    }\n-\n-    private Bucket[] getBuckets() {\n-        \/\/ resolve reference:\n-        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n-\n-        \/\/ create a new buckets ?\n-        if (buckets == null) {\n-            buckets = new Bucket[BUCKETS];\n-\n-            for (int i = 0; i < BUCKETS; i++) {\n-                buckets[i] = new Bucket(clean, ARRAY_SIZES[i], bucketCapacity,\n-                        (DO_STATS) ? stats.bucketStats[i] : null);\n-            }\n-\n-            \/\/ update weak reference:\n-            refBuckets = new WeakReference<Bucket[]>(buckets);\n-        }\n-        return buckets;\n-    }\n-\n-    Reference createRef(final int initialSize) {\n-        return new Reference(this, initialSize);\n-    }\n-\n-    static final class Reference {\n-\n-        \/\/ initial array reference (direct access)\n-        final int[] initial;\n-        private final boolean clean;\n-        private final IntArrayCache cache;\n-\n-        Reference(final IntArrayCache cache, final int initialSize) {\n-            this.cache = cache;\n-            this.clean = cache.clean;\n-            this.initial = createArray(initialSize);\n-            if (DO_STATS) {\n-                cache.stats.totalInitial += initialSize;\n-            }\n-        }\n-\n-        int[] getArray(final int length) {\n-            if (length <= MAX_ARRAY_SIZE) {\n-                return cache.getCacheBucket(length).getArray();\n-            }\n-            if (DO_STATS) {\n-                cache.stats.oversize++;\n-            }\n-            if (DO_LOG_OVERSIZE) {\n-                logInfo(getLogPrefix(clean) + \"IntArrayCache: \"\n-                        + \"getArray[oversize]: length=\\t\" + length);\n-            }\n-            return createArray(length);\n-        }\n-\n-        int[] widenArray(final int[] array, final int usedSize,\n-                          final int needSize)\n-        {\n-            final int length = array.length;\n-            if (DO_CHECKS && length >= needSize) {\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                cache.stats.resize++;\n-            }\n-\n-            \/\/ maybe change bucket:\n-            \/\/ ensure getNewSize() > newSize:\n-            final int[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n-\n-            \/\/ use wrapper to ensure proper copy:\n-            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n-\n-            \/\/ maybe return current array:\n-            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n-\n-            if (DO_LOG_WIDEN_ARRAY) {\n-                logInfo(getLogPrefix(clean) + \"IntArrayCache: \"\n-                        + \"widenArray[\" + res.length\n-                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n-                        + \"\\tneeded length=\\t\" + needSize);\n-            }\n-            return res;\n-        }\n-\n-        int[] putArray(final int[] array)\n-        {\n-            \/\/ dirty array helper:\n-            return putArray(array, 0, array.length);\n-        }\n-\n-        int[] putArray(final int[] array, final int fromIndex,\n-                        final int toIndex)\n-        {\n-            if (array.length <= MAX_ARRAY_SIZE) {\n-                if ((clean || DO_CLEAN_DIRTY) && (toIndex != 0)) {\n-                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n-                    fill(array, fromIndex, toIndex, 0);\n-                }\n-                \/\/ ensure to never store initial arrays in cache:\n-                if (array != initial) {\n-                    cache.getCacheBucket(array.length).putArray(array);\n-                }\n-            }\n-            return initial;\n-        }\n-    }\n-\n-    static final class Bucket {\n-\n-        private int tail = 0;\n-        private final int arraySize;\n-        private final boolean clean;\n-        private final int[][] arrays;\n-        private final BucketStats stats;\n-\n-        Bucket(final boolean clean, final int arraySize,\n-               final int capacity, final BucketStats stats)\n-        {\n-            this.arraySize = arraySize;\n-            this.clean = clean;\n-            this.stats = stats;\n-            this.arrays = new int[capacity][];\n-        }\n-\n-        int[] getArray() {\n-            if (DO_STATS) {\n-                stats.getOp++;\n-            }\n-            \/\/ use cache:\n-            if (tail != 0) {\n-                final int[] array = arrays[--tail];\n-                arrays[tail] = null;\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                stats.createOp++;\n-            }\n-            return createArray(arraySize);\n-        }\n-\n-        void putArray(final int[] array)\n-        {\n-            if (DO_CHECKS && (array.length != arraySize)) {\n-                logInfo(getLogPrefix(clean) + \"IntArrayCache: \"\n-                        + \"bad length = \" + array.length);\n-                return;\n-            }\n-            if (DO_STATS) {\n-                stats.returnOp++;\n-            }\n-            \/\/ fill cache:\n-            if (arrays.length > tail) {\n-                arrays[tail++] = array;\n-\n-                if (DO_STATS) {\n-                    stats.updateMaxSize(tail);\n-                }\n-            } else if (DO_CHECKS) {\n-                logInfo(getLogPrefix(clean) + \"IntArrayCache: \"\n-                        + \"array capacity exceeded !\");\n-            }\n-        }\n-    }\n-\n-    static int[] createArray(final int length) {\n-        return new int[length];\n-    }\n-\n-    static void fill(final int[] array, final int fromIndex,\n-                     final int toIndex, final int value)\n-    {\n-        \/\/ clear array data:\n-        Arrays.fill(array, fromIndex, toIndex, value);\n-        if (DO_CHECKS) {\n-            check(array, fromIndex, toIndex, value);\n-        }\n-    }\n-\n-    static void check(final int[] array, final int fromIndex,\n-                      final int toIndex, final int value)\n-    {\n-        if (DO_CHECKS) {\n-            \/\/ check zero on full array:\n-            for (int i = 0; i < array.length; i++) {\n-                if (array[i] != value) {\n-                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n-                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n-                            + Arrays.toString(array), new Throwable());\n-\n-                    \/\/ ensure array is correctly filled:\n-                    Arrays.fill(array, value);\n-\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    static String getLogPrefix(final boolean clean) {\n-        return (clean) ? \"Clean\" : \"Dirty\";\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/IntArrayCache.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-    private final IntArrayCache.Reference touchedTile_ref;\n+    private final ArrayCacheIntClean.Reference touchedTile_ref;\n@@ -169,1 +169,3 @@\n-        touchedTile = touchedTile_ref.putArray(touchedTile, 0, 0); \/\/ already zero filled\n+        if (touchedTile_ref.doSetRef(touchedTile)) {\n+            touchedTile = touchedTile_ref.putArrayClean(touchedTile); \/\/ already zero filled\n+        }\n@@ -201,1 +203,1 @@\n-                IntArrayCache.fill(touchedTile, tileMin, tileMax, 0);\n+                ArrayCacheInt.fill(touchedTile, tileMin, tileMax, 0);\n@@ -332,1 +334,1 @@\n-        IntArrayCache.fill(alphaRow, from, px1 + 1 - bboxX0, 0);\n+        ArrayCacheInt.fill(alphaRow, from, px1 + 1 - bboxX0, 0);\n@@ -546,2 +548,2 @@\n-            IntArrayCache.check(blkFlags, blkW, blkE, 0);\n-            IntArrayCache.check(alphaRow, from, px1 + 1 - bboxX0, 0);\n+            ArrayCacheInt.check(blkFlags, blkW, blkE, 0);\n+            ArrayCacheInt.check(alphaRow, from, px1 + 1 - bboxX0, 0);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinCache.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,19 @@\n+    \/**\n+     * Return true if the profile is 'quality' (default) over 'speed'\n+     *\n+     * @return true if the profile is 'quality' (default), false otherwise\n+     *\/\n+    public static boolean isProfileQuality() {\n+        final String key = \"sun.java2d.renderer.profile\";\n+        final String profile = getString(key, \"quality\");\n+        if (\"quality\".equals(profile)) {\n+            return true;\n+        }\n+        if (\"speed\".equals(profile)) {\n+            return false;\n+        }\n+        logInfo(\"Invalid value for \" + key + \" = \" + profile\n+                    + \"; expect value in [quality, speed] !\");\n+        return true;\n+    }\n+\n@@ -94,1 +113,2 @@\n-     * (3 by default ie 8 subpixels)\n+     * (3 by default ie 8 subpixels for the quality profile)\n+     * (2 by default ie 4 subpixels for the speed profile)\n@@ -97,1 +117,2 @@\n-        return getInteger(\"sun.java2d.renderer.subPixel_log2_Y\", 3, 0, 8);\n+        final int def = isProfileQuality() ? 3 : 2;\n+        return getInteger(\"sun.java2d.renderer.subPixel_log2_Y\", def, 0, 8);\n@@ -171,0 +192,13 @@\n+    public static float getStrokerJoinError() {\n+        final float def = (1.0f \/ MarlinConst.MIN_SUBPIXELS);\n+        float err = getFloat(\"sun.java2d.renderer.stroker.joinError\",\n+                def,\n+                -1.0f,\n+                10.0f);\n+        return (err < 0.0f) ? def : err;\n+    }\n+\n+    public static int getStrokerJoinStyle() {\n+        return getInteger(\"sun.java2d.renderer.stroker.joinStyle\", -1, -1, 2);\n+    }\n+\n@@ -191,0 +225,4 @@\n+    public static boolean isUseDPQS() {\n+        return getBoolean(\"sun.java2d.renderer.useDPQS\", \"true\");\n+    }\n+\n@@ -205,0 +243,8 @@\n+    public static boolean isSkipRenderer() {\n+        return getBoolean(\"sun.java2d.renderer.skip_rdr\", \"false\");\n+    }\n+\n+    public static boolean isSkipRenderTiles() {\n+        return getBoolean(\"sun.java2d.renderer.skip_pipe\", \"false\");\n+    }\n+\n@@ -230,1 +276,2 @@\n-        return getFloat(\"sun.java2d.renderer.cubic_dec_d2\", 1.0f, 1e-5f, 4.0f);\n+        final float def = isProfileQuality() ? 1.0f : 2.5f;\n+        return getFloat(\"sun.java2d.renderer.cubic_dec_d2\", def, 1e-5f, 4.0f);\n@@ -234,1 +281,2 @@\n-        return getFloat(\"sun.java2d.renderer.cubic_inc_d1\", 0.2f, 1e-6f, 1.0f);\n+        final float def = isProfileQuality() ? 0.2f : 0.5f;\n+        return getFloat(\"sun.java2d.renderer.cubic_inc_d1\", def, 1e-6f, 1.0f);\n@@ -238,1 +286,2 @@\n-        return getFloat(\"sun.java2d.renderer.quad_dec_d2\", 0.5f, 1e-5f, 4.0f);\n+        final float def = isProfileQuality() ? 0.5f : 1.0f;\n+        return getFloat(\"sun.java2d.renderer.quad_dec_d2\", def, 1e-5f, 4.0f);\n@@ -242,0 +291,6 @@\n+    @SuppressWarnings(\"removal\")\n+    static String getString(final String key, final String def) {\n+        return AccessController.doPrivileged(\n+                  new GetPropertyAction(key, def));\n+    }\n+\n@@ -274,1 +329,1 @@\n-        final int ceil = FloatMath.ceil_int( ((float) val) \/ norm);\n+        final int ceil = FloatMath.ceil_int( ((double) val) \/ norm);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinProperties.java","additions":62,"deletions":7,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -787,1 +787,1 @@\n-        String s = Integer.toHexString(v);\n+        StringBuilder s = new StringBuilder(Integer.toHexString(v));\n@@ -789,1 +789,1 @@\n-            s = \"0\" + s;\n+            s.insert(0, \"0\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinTileGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.Arrays;\n+import static sun.java2d.marlin.DualPivotQuicksort20191112Ext.sort;\n+\n@@ -35,2 +38,16 @@\n-    \/\/ insertion sort threshold\n-    public static final int INSERTION_SORT_THRESHOLD = 14;\n+    static final boolean USE_DPQS = MarlinProperties.isUseDPQS();\n+\n+    static final String SORT_TYPE = USE_DPQS ? \"DPQS_20191112\" : \"MERGE\";\n+\n+    static final int DPQS_THRESHOLD = 256;\n+    static final int DISABLE_ISORT_THRESHOLD = 1000;\n+\n+    private static final boolean CHECK_SORTED = false;\n+\n+    static {\n+        MarlinUtils.logInfo(\"MergeSort: DPQS_THRESHOLD: \" + DPQS_THRESHOLD);\n+        MarlinUtils.logInfo(\"MergeSort: DISABLE_ISORT_THRESHOLD: \" + DISABLE_ISORT_THRESHOLD);\n+        if (CHECK_SORTED) {\n+            MarlinUtils.logInfo(\"MergeSort: CHECK_SORTED: \" + CHECK_SORTED);\n+        }\n+    }\n@@ -47,1 +64,4 @@\n-                                final int insertionSortIndex)\n+                                final int insertionSortIndex,\n+                                final boolean skipISort,\n+                                final DPQSSorterContext sorter,\n+                                final boolean useDPQS)\n@@ -53,1 +73,23 @@\n-                                                     + toIndex);\n+                    + toIndex);\n+        }\n+        if (skipISort) {\n+            if (useDPQS) {\n+                \/\/ sort full x\/y in-place\n+                sort(sorter, x, auxX, y, auxY, 0, toIndex);\n+            } else {\n+                \/\/ sort full auxX\/auxY into x\/y\n+                mergeSort(auxX, auxY, auxX, x, auxY, y, 0, toIndex);\n+            }\n+            if (CHECK_SORTED) {\n+                checkRange(x, 0, toIndex);\n+            }\n+            return;\n+        } else {\n+            if (useDPQS) {\n+                \/\/ sort auxX\/auxY in-place\n+                sort(sorter, auxX, x, auxY, y, insertionSortIndex, toIndex);\n+            } else {\n+                \/\/ sort second part only using merge sort\n+                \/\/ x\/y into auxiliary storage (auxX\/auxY)\n+                mergeSort(x, y, x, auxX, y, auxY, insertionSortIndex, toIndex);\n+            }\n@@ -55,4 +97,0 @@\n-\n-        \/\/ sort second part only using merge \/ insertion sort\n-        \/\/ in auxiliary storage (auxX\/auxY)\n-        mergeSort(x, y, x, auxX, y, auxY, insertionSortIndex, toIndex);\n@@ -62,9 +100,0 @@\n-        if ((insertionSortIndex == 0)\n-            || (auxX[insertionSortIndex - 1] <= auxX[insertionSortIndex])) {\n-            \/\/ 34 occurrences\n-            \/\/ no initial left part or both sublists (auxX, auxY) are sorted:\n-            \/\/ copy back data into (x, y):\n-            System.arraycopy(auxX, 0, x, 0, toIndex);\n-            System.arraycopy(auxY, 0, y, 0, toIndex);\n-            return;\n-        }\n@@ -74,1 +103,1 @@\n-                                   && (auxX[p] <= auxX[q]))) {\n+                    && (auxX[p] <= auxX[q]))) {\n@@ -84,0 +113,4 @@\n+\n+        if (CHECK_SORTED) {\n+            checkRange(x, 0, toIndex);\n+        }\n@@ -86,0 +119,3 @@\n+    \/\/ insertion sort threshold for MergeSort()\n+    static final int INSERTION_SORT_THRESHOLD = 14;\n+\n@@ -174,0 +210,9 @@\n+\n+    private static void checkRange(int[] x, int lo, int hi) {\n+        for (int i = lo + 1; i < hi; i++) {\n+            if (x[i - 1] > x[i]) {\n+                MarlinUtils.logInfo(\"Bad sorted x [\" + (i - 1) + \"]\" + Arrays.toString(Arrays.copyOf(x, hi)));\n+                return;\n+            }\n+        }\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MergeSort.java","additions":64,"deletions":19,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        CleanerFactory.cleaner().register(parent, () -> this.free());\n+        CleanerFactory.cleaner().register(parent, this::free);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/OffHeapArray.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-\n+    \/\/ squared tolerance in pixels\n@@ -36,0 +36,1 @@\n+    \/\/ current reference point\n@@ -37,0 +38,4 @@\n+    \/\/ flag indicating if the given point was skipped\n+    private boolean skipped;\n+    \/\/ last skipped point\n+    private double sx, sy;\n@@ -43,0 +48,1 @@\n+        skipped = false;\n@@ -46,0 +52,6 @@\n+    private void finishPath() {\n+        if (skipped) {\n+            _lineTo(sx, sy);\n+        }\n+    }\n+\n@@ -48,0 +60,1 @@\n+        finishPath();\n@@ -53,0 +66,1 @@\n+        finishPath();\n@@ -57,2 +71,27 @@\n-    public long getNativeConsumer() {\n-        return 0;\n+    public void moveTo(final double xe, final double ye) {\n+        finishPath();\n+        delegate.moveTo(xe, ye);\n+        cx = xe;\n+        cy = ye;\n+    }\n+\n+    @Override\n+    public void lineTo(final double xe, final double ye) {\n+        \/\/ Test if segment is too small:\n+        double dx = (xe - cx);\n+        double dy = (ye - cy);\n+\n+        if ((dx * dx + dy * dy) <= SQUARE_TOLERANCE) {\n+            skipped = true;\n+            sx = xe;\n+            sy = ye;\n+            return;\n+        }\n+        _lineTo(xe, ye);\n+    }\n+\n+    private void _lineTo(final double xe, final double ye) {\n+        delegate.lineTo(xe, ye);\n+        cx = xe;\n+        cy = ye;\n+        skipped = false;\n@@ -75,0 +114,3 @@\n+                skipped = true;\n+                sx = xe;\n+                sy = ye;\n@@ -79,1 +121,0 @@\n-        \/\/ final end point:\n@@ -82,0 +123,1 @@\n+        skipped = false;\n@@ -104,0 +146,3 @@\n+                    skipped = true;\n+                    sx = xe;\n+                    sy = ye;\n@@ -109,9 +154,0 @@\n-        \/\/ final end point:\n-        cx = xe;\n-        cy = ye;\n-    }\n-\n-    @Override\n-    public void moveTo(final double xe, final double ye) {\n-        delegate.moveTo(xe, ye);\n-        \/\/ starting point:\n@@ -120,0 +156,1 @@\n+        skipped = false;\n@@ -123,12 +160,2 @@\n-    public void lineTo(final double xe, final double ye) {\n-        \/\/ Test if segment is too small:\n-        double dx = (xe - cx);\n-        double dy = (ye - cy);\n-\n-        if ((dx * dx + dy * dy) <= SQUARE_TOLERANCE) {\n-            return;\n-        }\n-        delegate.lineTo(xe, ye);\n-        \/\/ final end point:\n-        cx = xe;\n-        cy = ye;\n+    public long getNativeConsumer() {\n+        return 0;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/PathSimplifier.java","additions":53,"deletions":26,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-    static final boolean DISABLE_RENDER = false;\n+    static final boolean DISABLE_RENDER = MarlinProperties.isSkipRenderer();\n@@ -147,1 +147,1 @@\n-    private final IntArrayCache.Reference crossings_ref;\n+    private final ArrayCacheInt.Reference crossings_ref;\n@@ -149,1 +149,1 @@\n-    private final IntArrayCache.Reference edgePtrs_ref;\n+    private final ArrayCacheInt.Reference edgePtrs_ref;\n@@ -152,1 +152,1 @@\n-    private final IntArrayCache.Reference aux_crossings_ref;\n+    private final ArrayCacheInt.Reference aux_crossings_ref;\n@@ -154,1 +154,1 @@\n-    private final IntArrayCache.Reference aux_edgePtrs_ref;\n+    private final ArrayCacheInt.Reference aux_edgePtrs_ref;\n@@ -174,1 +174,1 @@\n-    private final IntArrayCache.Reference edgeBuckets_ref;\n+    private final ArrayCacheIntClean.Reference edgeBuckets_ref;\n@@ -176,1 +176,1 @@\n-    private final IntArrayCache.Reference edgeBucketCounts_ref;\n+    private final ArrayCacheIntClean.Reference edgeBucketCounts_ref;\n@@ -395,1 +395,1 @@\n-        \/\/ use subtraction to avoid integer overflow:\n+        \/\/ use substraction to avoid integer overflow:\n@@ -514,1 +514,1 @@\n-    private final IntArrayCache.Reference alphaLine_ref;\n+    private final ArrayCacheIntClean.Reference alphaLine_ref;\n@@ -523,1 +523,1 @@\n-    private final IntArrayCache.Reference blkFlags_ref;\n+    private final ArrayCacheIntClean.Reference blkFlags_ref;\n@@ -616,2 +616,6 @@\n-        crossings = crossings_ref.putArray(crossings);\n-        aux_crossings = aux_crossings_ref.putArray(aux_crossings);\n+        if (crossings_ref.doCleanRef(crossings)) {\n+            crossings = crossings_ref.putArray(crossings);\n+        }\n+        if (aux_crossings_ref.doCleanRef(aux_crossings)) {\n+            aux_crossings = aux_crossings_ref.putArray(aux_crossings);\n+        }\n@@ -619,2 +623,6 @@\n-        edgePtrs = edgePtrs_ref.putArray(edgePtrs);\n-        aux_edgePtrs = aux_edgePtrs_ref.putArray(aux_edgePtrs);\n+        if (edgePtrs_ref.doCleanRef(edgePtrs)) {\n+            edgePtrs = edgePtrs_ref.putArray(edgePtrs);\n+        }\n+        if (aux_edgePtrs_ref.doCleanRef(aux_edgePtrs)) {\n+            aux_edgePtrs = aux_edgePtrs_ref.putArray(aux_edgePtrs);\n+        }\n@@ -622,2 +630,6 @@\n-        alphaLine = alphaLine_ref.putArray(alphaLine, 0, 0); \/\/ already zero filled\n-        blkFlags  = blkFlags_ref.putArray(blkFlags, 0, 0); \/\/ already zero filled\n+        if (alphaLine_ref.doSetRef(alphaLine)) {\n+            alphaLine = alphaLine_ref.putArrayClean(alphaLine); \/\/ already zero filled\n+        }\n+        if (blkFlags_ref.doSetRef(blkFlags)) {\n+            blkFlags  = blkFlags_ref.putArrayClean(blkFlags); \/\/ already zero filled\n+        }\n@@ -641,2 +653,6 @@\n-            edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, 0, 0);\n-            edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts, 0, 0);\n+            if (edgeBuckets_ref.doSetRef(edgeBuckets)) {\n+                edgeBuckets = edgeBuckets_ref.putArrayClean(edgeBuckets);\n+            }\n+            if (edgeBucketCounts_ref.doSetRef(edgeBucketCounts)) {\n+                edgeBucketCounts = edgeBucketCounts_ref.putArrayClean(edgeBucketCounts);\n+            }\n@@ -722,1 +738,1 @@\n-        if (x0 != sx0 || y0 != sy0) {\n+        if ((x0 != sx0) || (y0 != sy0)) {\n@@ -830,0 +846,2 @@\n+        final DPQSSorterContext sorter = rdrCtx.sorterCtx;\n+        boolean skipISort, useDPQS;\n@@ -842,1 +860,1 @@\n-                    rdrCtx.stats.stat_rdr_activeEdges_updates.add(numCrossings);\n+                    rdrCtx.stats.stat_rdr_activeEdges_updates.add(prevNumCrossings);\n@@ -851,1 +869,1 @@\n-                    for (i = 0, newCount = 0; i < numCrossings; i++) {\n+                    for (i = 0, newCount = 0; i < prevNumCrossings; i++) {\n@@ -879,1 +897,1 @@\n-                            = edgePtrs_ref.widenArray(_edgePtrs, numCrossings,\n+                            = edgePtrs_ref.widenArray(_edgePtrs, edgePtrsLen,\n@@ -948,1 +966,1 @@\n-                if ((ptrLen < 10) || (numCrossings < 40)) {\n+                if (((numCrossings <= 40) || ((ptrLen <= 10) && (numCrossings <= MergeSort.DISABLE_ISORT_THRESHOLD)))) {\n@@ -1034,1 +1052,1 @@\n-                                _edgePtrs[i] = _edgePtrs[j];\n+                                _edgePtrs[i]  = _edgePtrs[j];\n@@ -1061,0 +1079,7 @@\n+                    skipISort = (prevNumCrossings >= MergeSort.DISABLE_ISORT_THRESHOLD);\n+                    useDPQS   = MergeSort.USE_DPQS && (skipISort || (ptrLen >= MergeSort.DPQS_THRESHOLD));\n+\n+                    if (DO_STATS && useDPQS) {\n+                        rdrCtx.stats.stat_rdr_crossings_dpqs.add((skipISort) ? numCrossings : ptrLen);\n+                    }\n+\n@@ -1097,8 +1122,10 @@\n-                        if (i >= prevNumCrossings) {\n-                            \/\/ simply store crossing as edgePtrs is in-place:\n-                            \/\/ will be copied and sorted efficiently by mergesort later:\n-                            _crossings[i]     = cross;\n-\n-                        } else if (cross < lastCross) {\n-                            if (DO_STATS) {\n-                                rdrCtx.stats.stat_rdr_crossings_sorts.add(i);\n+                        if (skipISort) {\n+                            if (useDPQS) {\n+                                \/\/ simply store crossing as edgePtrs is in-place:\n+                                \/\/ will be sorted efficiently by DPQS later:\n+                                _crossings[i]     = cross;\n+                            } else {\n+                                \/\/ store crossing\/edgePtrs in auxiliary arrays:\n+                                \/\/ will be sorted efficiently by MergeSort later:\n+                                _aux_crossings[i] = cross;\n+                                _aux_edgePtrs [i] = ecur;\n@@ -1106,9 +1133,10 @@\n-\n-                            \/\/ (straight) insertion sort of crossings:\n-                            j = i - 1;\n-                            _aux_crossings[i] = _aux_crossings[j];\n-                            _aux_edgePtrs[i] = _aux_edgePtrs[j];\n-\n-                            while ((--j >= 0) && (_aux_crossings[j] > cross)) {\n-                                _aux_crossings[j + 1] = _aux_crossings[j];\n-                                _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];\n+                        } else if (i >= prevNumCrossings) {\n+                            if (useDPQS) {\n+                                \/\/ store crossing\/edgePtrs in auxiliary arrays:\n+                                \/\/ will be sorted efficiently by DPQS later:\n+                                _aux_crossings[i] = cross;\n+                                _aux_edgePtrs [i] = ecur;\n+                            } else {\n+                                \/\/ simply store crossing as edgePtrs is in-place:\n+                                \/\/ will be sorted efficiently by MergeSort later:\n+                                _crossings[i]      = cross;\n@@ -1116,3 +1144,0 @@\n-                            _aux_crossings[j + 1] = cross;\n-                            _aux_edgePtrs [j + 1] = ecur;\n-\n@@ -1120,3 +1145,20 @@\n-                            \/\/ auxiliary storage:\n-                            _aux_crossings[i] = lastCross = cross;\n-                            _aux_edgePtrs [i] = ecur;\n+                            if (cross < lastCross) {\n+                                if (DO_STATS) {\n+                                    rdrCtx.stats.stat_rdr_crossings_sorts.add(i);\n+                                }\n+                                \/\/ (straight) insertion sort of crossings:\n+                                j = i - 1;\n+                                _aux_crossings[i] = _aux_crossings[j];\n+                                _aux_edgePtrs [i]  = _aux_edgePtrs[j];\n+\n+                                while ((--j >= 0) && (_aux_crossings[j] > cross)) {\n+                                    _aux_crossings[j + 1] = _aux_crossings[j];\n+                                    _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];\n+                                }\n+                                _aux_crossings[j + 1] = cross;\n+                                _aux_edgePtrs [j + 1] = ecur;\n+                            } else {\n+                                \/\/ auxiliary storage:\n+                                _aux_crossings[i] = lastCross = cross;\n+                                _aux_edgePtrs [i] = ecur;\n+                            }\n@@ -1129,1 +1171,3 @@\n-                                              numCrossings,   prevNumCrossings);\n+                                              numCrossings, prevNumCrossings,\n+                                              skipISort, sorter, useDPQS\n+                                            );\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Renderer.java","additions":93,"deletions":49,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,5 @@\n+    \/\/ bit flags indicating to skip the stroker to process joins\n+    \/\/ bits: 2 : Dasher CurveClipSplitter\n+    \/\/ bits: 1 : Dasher CurveBasicMonotonizer\n+    \/\/ bits: 0 : Stroker CurveClipSplitter\n+    int firstFlags = 0;\n@@ -93,0 +98,2 @@\n+    \/\/ DPQS Sorter context\n+    final DPQSSorterContext sorterCtx;\n@@ -96,1 +103,1 @@\n-    private final IntArrayCache cleanIntCache = new IntArrayCache(true, 5);\n+    private final ArrayCacheIntClean cleanIntCache = new ArrayCacheIntClean(5);\n@@ -98,1 +105,1 @@\n-    private final IntArrayCache dirtyIntCache = new IntArrayCache(false, 5);\n+    private final ArrayCacheInt dirtyIntCache = new ArrayCacheInt(5);\n@@ -100,1 +107,1 @@\n-    private final DoubleArrayCache dirtyDoubleCache = new DoubleArrayCache(false, 4);\n+    private final ArrayCacheDouble dirtyDoubleCache = new ArrayCacheDouble(4);\n@@ -102,1 +109,1 @@\n-    private final ByteArrayCache dirtyByteCache = new ByteArrayCache(false, 2);\n+    private final ArrayCacheByte dirtyByteCache = new ArrayCacheByte(2);\n@@ -149,0 +156,2 @@\n+\n+        sorterCtx = (MergeSort.USE_DPQS) ? new DPQSSorterContext() : null;\n@@ -166,0 +175,1 @@\n+        firstFlags = 0;\n@@ -194,1 +204,1 @@\n-            refPath2D = new WeakReference<Path2D.Double>(p2d);\n+            refPath2D = new WeakReference<>(p2d);\n@@ -212,1 +222,1 @@\n-    IntArrayCache.Reference newCleanIntArrayRef(final int initialSize) {\n+    ArrayCacheIntClean.Reference newCleanIntArrayRef(final int initialSize) {\n@@ -216,1 +226,1 @@\n-    IntArrayCache.Reference newDirtyIntArrayRef(final int initialSize) {\n+    ArrayCacheInt.Reference newDirtyIntArrayRef(final int initialSize) {\n@@ -220,1 +230,1 @@\n-    DoubleArrayCache.Reference newDirtyDoubleArrayRef(final int initialSize) {\n+    ArrayCacheDouble.Reference newDirtyDoubleArrayRef(final int initialSize) {\n@@ -224,1 +234,1 @@\n-    ByteArrayCache.Reference newDirtyByteArrayRef(final int initialSize) {\n+    ArrayCacheByte.Reference newDirtyByteArrayRef(final int initialSize) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/RendererContext.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,2 @@\n+    final StatLong stat_rdr_crossings_dpqs\n+        = new StatLong(\"renderer.crossings.dpqs\");\n@@ -199,0 +201,1 @@\n+        stat_rdr_crossings_dpqs,\n@@ -355,1 +358,1 @@\n-            = new ConcurrentLinkedQueue<RendererStats>();\n+            = new ConcurrentLinkedQueue<>();\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/RendererStats.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import sun.java2d.marlin.TransformingPathConsumer2D.StartFlagPathConsumer2D;\n@@ -36,1 +37,1 @@\n-final class Stroker implements DPathConsumer2D, MarlinConst {\n+final class Stroker implements StartFlagPathConsumer2D, MarlinConst {\n@@ -42,3 +43,6 @@\n-    \/\/ round join threshold = 1 subpixel\n-    private static final double ERR_JOIN = (1.0f \/ MIN_SUBPIXELS);\n-    private static final double ROUND_JOIN_THRESHOLD = ERR_JOIN * ERR_JOIN;\n+    \/\/ join threshold = 1 subpixel (1\/8th pixel):\n+    private static final double JOIN_ERROR = MarlinProperties.getStrokerJoinError();\n+\n+    private static final double ROUND_JOIN_ERROR = 8.0 * JOIN_ERROR; \/\/ (8 h)\n+\n+    private static final int JOIN_STYLE = MarlinProperties.getStrokerJoinStyle();\n@@ -52,0 +56,1 @@\n+    \/\/ members:\n@@ -65,0 +70,1 @@\n+    private double joinLimitMinSq;\n@@ -159,1 +165,20 @@\n-        this.joinStyle = joinStyle;\n+        this.joinStyle = (JOIN_STYLE != -1) ? JOIN_STYLE : joinStyle;\n+\n+        double miterScaledLimit = 0.0;\n+\n+        if (joinStyle == JOIN_MITER) {\n+            miterScaledLimit = miterLimit * lineWidth2;\n+            this.miterLimitSq = miterScaledLimit * miterScaledLimit;\n+\n+            final double limitMin = ((this.rdrCtx.clipInvScale == 0.0d) ? JOIN_ERROR\n+                    : (JOIN_ERROR * this.rdrCtx.clipInvScale))\n+                    + lineWidth2;\n+\n+            this.joinLimitMinSq = limitMin * limitMin;\n+\n+        } else if (joinStyle == JOIN_ROUND) {\n+            \/\/ chord:  s = 2 r * sin( phi \/ 2)\n+            \/\/ height: h = 2 r * sin( phi \/ 4)^2\n+            \/\/ small angles (phi < 90):\n+            \/\/ h = s^2 \/ (8 r)\n+            \/\/ so s^2 = (8 h * r)\n@@ -161,2 +186,3 @@\n-        final double limit = miterLimit * lineWidth2;\n-        this.miterLimitSq = limit * limit;\n+            \/\/ height max (note ROUND_JOIN_ERROR = 8 * JOIN_ERROR)\n+            final double limitMin = ((this.rdrCtx.clipInvScale == 0.0d) ? ROUND_JOIN_ERROR\n+                    : (ROUND_JOIN_ERROR * this.rdrCtx.clipInvScale));\n@@ -164,0 +190,3 @@\n+            \/\/ chord limit (s^2):\n+            this.joinLimitMinSq = limitMin * this.lineWidth2;\n+        }\n@@ -175,2 +204,2 @@\n-            if ((joinStyle == JOIN_MITER) && (margin < limit)) {\n-                margin = limit;\n+            if ((joinStyle == JOIN_MITER) && (margin < miterScaledLimit)) {\n+                margin = miterScaledLimit;\n@@ -272,1 +301,0 @@\n-\n@@ -275,1 +303,1 @@\n-        final double lenSq = domx*domx + domy*domy;\n+        final double lenSq = domx * domx + domy * domy;\n@@ -277,1 +305,1 @@\n-        if (lenSq < ROUND_JOIN_THRESHOLD) {\n+        if (lenSq < joinLimitMinSq) {\n@@ -280,1 +308,0 @@\n-\n@@ -302,1 +329,1 @@\n-        if (cosext >= 0.0d) {\n+        if (cosext >= 0.0) {\n@@ -319,3 +346,4 @@\n-            double nx = my - omy, ny = omx - mx;\n-            double nlen = Math.sqrt(nx*nx + ny*ny);\n-            double scale = lineWidth2\/nlen;\n+            final double nx = my - omy;\n+            final double ny = omx - mx;\n+            final double nlen = Math.sqrt(nx * nx + ny * ny);\n+            final double scale = lineWidth2 \/ nlen;\n@@ -475,1 +503,1 @@\n-        double lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);\n+        final double lenSq = (miterX - x0) * (miterX - x0) + (miterY - y0) * (miterY - y0);\n@@ -482,1 +510,1 @@\n-        if (lenSq < miterLimitSq) {\n+        if ((lenSq < miterLimitSq) && (lenSq >= joinLimitMinSq)) {\n@@ -523,0 +551,1 @@\n+    \/* Callback from CurveClipSplitter *\/\n@@ -524,2 +553,7 @@\n-    public void lineTo(final double x1, final double y1) {\n-        lineTo(x1, y1, false);\n+    public void setStartFlag(boolean first) {\n+        if (first) {\n+            \/\/ reset flag:\n+            rdrCtx.firstFlags &= 0b110;\n+        } else {\n+            rdrCtx.firstFlags |= 0b001;\n+        }\n@@ -528,3 +562,2 @@\n-    private void lineTo(final double x1, final double y1,\n-                        final boolean force)\n-    {\n+    @Override\n+    public void lineTo(final double x1, final double y1) {\n@@ -533,1 +566,1 @@\n-        if (!force && clipRect != null) {\n+        if (clipRect != null) {\n@@ -564,1 +597,0 @@\n-\n@@ -623,2 +655,3 @@\n-            if (cx0 != sx0 || cy0 != sy0) {\n-                lineTo(sx0, sy0, true);\n+            if ((cx0 != sx0) || (cy0 != sy0)) {\n+                \/\/ may subdivide line:\n+                lineTo(sx0, sy0);\n@@ -627,1 +660,3 @@\n-            drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);\n+            \/\/ ignore starting point outside:\n+            if (sOutCode == 0) {\n+                drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);\n@@ -629,1 +664,1 @@\n-            emitLineTo(sx0 + smx, sy0 + smy);\n+                emitLineTo(sx0 + smx, sy0 + smy);\n@@ -631,4 +666,5 @@\n-            if (opened) {\n-                emitLineTo(sx0 - smx, sy0 - smy);\n-            } else {\n-                emitMoveTo(sx0 - smx, sy0 - smy);\n+                if (opened) {\n+                    emitLineTo(sx0 - smx, sy0 - smy);\n+                } else {\n+                    emitMoveTo(sx0 - smx, sy0 - smy);\n+                }\n@@ -781,0 +817,1 @@\n+            prev = DRAWING_OP_TO;\n@@ -788,1 +825,2 @@\n-        } else {\n+        } else if (rdrCtx.firstFlags == 0) {\n+            \/\/ Precision on isCW is causing instabilities with Dasher !\n@@ -799,12 +837,0 @@\n-        prev = DRAWING_OP_TO;\n-    }\n-\n-    private static boolean within(final double x1, final double y1,\n-                                  final double x2, final double y2,\n-                                  final double err)\n-    {\n-        assert err > 0 : \"\";\n-        \/\/ compare taxicab distance. ERR will always be small, so using\n-        \/\/ true distance won't give much benefit\n-        return (Helpers.within(x1, x2, err) && \/\/ we want to avoid calling Math.abs\n-                Helpers.within(y1, y2, err));  \/\/ this is just as good.\n@@ -813,3 +839,3 @@\n-    private void getLineOffsets(final double x1, final double y1,\n-                                final double x2, final double y2,\n-                                final double[] left, final double[] right)\n+    private int getLineOffsets(final double x1, final double y1,\n+                               final double x2, final double y2,\n+                               final double[] left, final double[] right)\n@@ -829,0 +855,2 @@\n+\n+        return 4;\n@@ -842,4 +870,4 @@\n-        final double x1 = pts[off    ], y1 = pts[off + 1];\n-        final double x2 = pts[off + 2], y2 = pts[off + 3];\n-        final double x3 = pts[off + 4], y3 = pts[off + 5];\n-        final double x4 = pts[off + 6], y4 = pts[off + 7];\n+        final double x1 = pts[off    ]; final double y1 = pts[off + 1];\n+        final double x2 = pts[off + 2]; final double y2 = pts[off + 3];\n+        final double x3 = pts[off + 4]; final double y3 = pts[off + 5];\n+        final double x4 = pts[off + 6]; final double y4 = pts[off + 7];\n@@ -847,4 +875,2 @@\n-        double dx4 = x4 - x3;\n-        double dy4 = y4 - y3;\n-        double dx1 = x2 - x1;\n-        double dy1 = y2 - y1;\n+        double dx1 = x2 - x1; double dy1 = y2 - y1;\n+        double dx4 = x4 - x3; double dy4 = y4 - y3;\n@@ -854,2 +880,2 @@\n-        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));\n-        final boolean p3eqp4 = within(x3, y3, x4, y4, 6.0d * Math.ulp(y4));\n+        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Math.ulp(y2));\n+        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Math.ulp(y4));\n@@ -858,2 +884,1 @@\n-            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n-            return 4;\n+            return getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n@@ -871,1 +896,2 @@\n-        double l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;\n+        final double l1sq = dx1 * dx1 + dy1 * dy1;\n+        final double l4sq = dx4 * dx4 + dy4 * dy4;\n@@ -874,2 +900,1 @@\n-            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n-            return 4;\n+            return getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n@@ -925,2 +950,2 @@\n-        double x = (x1 + 3.0d * (x2 + x3) + x4) \/ 8.0d;\n-        double y = (y1 + 3.0d * (y2 + y3) + y4) \/ 8.0d;\n+        final double xm = (x1 + x4 + 3.0d * (x2 + x3)) \/ 8.0d;\n+        final double ym = (y1 + y4 + 3.0d * (y2 + y3)) \/ 8.0d;\n@@ -929,1 +954,2 @@\n-        double dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;\n+        final double dxm = x3 + x4 - (x1 + x2);\n+        final double dym = y3 + y4 - (y1 + y2);\n@@ -937,0 +963,2 @@\n+\n+        \/\/ left side:\n@@ -939,2 +967,2 @@\n-        double xi  = x  + offset1[0]; \/\/ interpolation\n-        double yi  = y  + offset1[1]; \/\/ point\n+        double xi  = xm + offset1[0]; \/\/ interpolation\n+        double yi  = ym + offset1[1]; \/\/ point\n@@ -944,1 +972,4 @@\n-        double invdet43 = 4.0d \/ (3.0d * (dx1 * dy4 - dy1 * dx4));\n+        final double invdet43 = 4.0d \/ (3.0d * (dx1 * dy4 - dy1 * dx4));\n+\n+        double two_pi_m_p1_m_p4x = 2.0d * xi - (x1p + x4p);\n+        double two_pi_m_p1_m_p4y = 2.0d * yi - (y1p + y4p);\n@@ -946,2 +977,0 @@\n-        double two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;\n-        double two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;\n@@ -952,4 +981,20 @@\n-        x2p = x1p + c1*dx1;\n-        y2p = y1p + c1*dy1;\n-        x3p = x4p + c2*dx4;\n-        y3p = y4p + c2*dy4;\n+\n+        if (c1 * c2 > 0.0) {\n+\/\/            System.out.println(\"Buggy solver (left): c1 = \" + c1 + \" c2 = \" + c2);\n+\n+            \/\/ use lower quality approximation but good enough\n+            \/\/ to ensure cuve being in its convex hull\n+            x2p = x2 + offset1[0]; \/\/ 2nd\n+            y2p = y2 + offset1[1]; \/\/ point\n+            x3p = x3 + offset1[0]; \/\/ 3nd\n+            y3p = y3 + offset1[1]; \/\/ point\n+\n+            safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x2p, y2p, x2p-dxm, y2p-dym, leftOff);\n+            x2p = leftOff[2]; y2p = leftOff[3];\n+\n+            safeComputeMiter(x4p, y4p, x4p+dx4, y4p+dy4, x3p, y3p, x3p-dxm, y3p-dym, leftOff);\n+            x3p = leftOff[2]; y3p = leftOff[3];\n+        } else {\n+            x2p = x1p + c1 * dx1; y2p = y1p + c1 * dy1;\n+            x3p = x4p + c2 * dx4; y3p = y4p + c2 * dy4;\n+        }\n@@ -962,3 +1007,10 @@\n-        x1p = x1 - offset0[0]; y1p = y1 - offset0[1];\n-        xi = xi - 2.0d * offset1[0]; yi = yi - 2.0d * offset1[1];\n-        x4p = x4 - offset2[0]; y4p = y4 - offset2[1];\n+        \/\/ Right side:\n+        x1p = x1 - offset0[0]; \/\/ start\n+        y1p = y1 - offset0[1]; \/\/ point\n+        xi =  xm  - offset1[0]; \/\/ interpolation\n+        yi =  ym  - offset1[1]; \/\/ point\n+        x4p = x4 - offset2[0]; \/\/ end\n+        y4p = y4 - offset2[1]; \/\/ point\n+\n+        two_pi_m_p1_m_p4x = 2.0d * xi - (x1p + x4p);\n+        two_pi_m_p1_m_p4y = 2.0d * yi - (y1p + y4p);\n@@ -966,2 +1018,0 @@\n-        two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;\n-        two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;\n@@ -971,4 +1021,19 @@\n-        x2p = x1p + c1*dx1;\n-        y2p = y1p + c1*dy1;\n-        x3p = x4p + c2*dx4;\n-        y3p = y4p + c2*dy4;\n+        if (c1 * c2 > 0.0) {\n+\/\/            System.out.println(\"Buggy solver (right): c1 = \" + c1 + \" c2 = \" + c2);\n+\n+            \/\/ use lower quality approximation but good enough\n+            \/\/ to ensure cuve being in its convex hull\n+            x2p = x2 - offset1[0]; \/\/ 2nd\n+            y2p = y2 - offset1[1]; \/\/ point\n+            x3p = x3 - offset1[0]; \/\/ 3nd\n+            y3p = y3 - offset1[1]; \/\/ point\n+\n+            safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x2p, y2p, x2p-dxm, y2p-dym, rightOff);\n+            x2p = rightOff[2]; y2p = rightOff[3];\n+\n+            safeComputeMiter(x4p, y4p, x4p+dx4, y4p+dy4, x3p, y3p, x3p-dxm, y3p-dym, rightOff);\n+            x3p = rightOff[2]; y3p = rightOff[3];\n+        } else {\n+            x2p = x1p + c1 * dx1; y2p = y1p + c1 * dy1;\n+            x3p = x4p + c2 * dx4; y3p = y4p + c2 * dy4;\n+        }\n@@ -980,0 +1045,1 @@\n+\n@@ -990,3 +1056,3 @@\n-        final double x1 = pts[off    ], y1 = pts[off + 1];\n-        final double x2 = pts[off + 2], y2 = pts[off + 3];\n-        final double x3 = pts[off + 4], y3 = pts[off + 5];\n+        final double x1 = pts[off    ]; final double y1 = pts[off + 1];\n+        final double x2 = pts[off + 2]; final double y2 = pts[off + 3];\n+        final double x3 = pts[off + 4]; final double y3 = pts[off + 5];\n@@ -994,4 +1060,2 @@\n-        final double dx3 = x3 - x2;\n-        final double dy3 = y3 - y2;\n-        final double dx1 = x2 - x1;\n-        final double dy1 = y2 - y1;\n+        final double dx12 = x2 - x1; final double dy12 = y2 - y1;\n+        final double dx23 = x3 - x2; final double dy23 = y3 - y2;\n@@ -999,1 +1063,1 @@\n-        \/\/ if p1=p2 or p3=p4 it means that the derivative at the endpoint\n+        \/\/ if p1=p2 or p2=p3 it means that the derivative at the endpoint\n@@ -1007,4 +1071,3 @@\n-        \/\/ if p1 == p2 && p3 == p4: draw line from p1->p4, unless p1 == p4,\n-        \/\/ in which case ignore.\n-        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));\n-        final boolean p2eqp3 = within(x2, y2, x3, y3, 6.0d * Math.ulp(y3));\n+        \/\/ if p1 == p2 or p2 == p3: draw line from p1->p3\n+        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Math.ulp(y2));\n+        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Math.ulp(y3));\n@@ -1013,2 +1076,1 @@\n-            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n-            return 4;\n+            return getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n@@ -1017,2 +1079,2 @@\n-        \/\/ if p2-p1 and p4-p3 are parallel, that must mean this curve is a line\n-        double dotsq = (dx1 * dx3 + dy1 * dy3);\n+        \/\/ if p2-p1 and p3-p2 are parallel, that must mean this curve is a line\n+        double dotsq = (dx12 * dx23 + dy12 * dy23);\n@@ -1020,1 +1082,2 @@\n-        double l1sq = dx1 * dx1 + dy1 * dy1, l3sq = dx3 * dx3 + dy3 * dy3;\n+        final double l1sq = dx12 * dx12 + dy12 * dy12;\n+        final double l3sq = dx23 * dx23 + dy23 * dy23;\n@@ -1023,2 +1086,1 @@\n-            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n-            return 4;\n+            return getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n@@ -1028,1 +1090,1 @@\n-        \/\/ for any bezier curve the vectors p2-p1 and p4-p3 are parallel to\n+        \/\/ for any bezier curve the vectors p2-p1 and p3-p2 are parallel to\n@@ -1030,2 +1092,2 @@\n-        computeOffset(dx1, dy1, lineWidth2, offset0);\n-        computeOffset(dx3, dy3, lineWidth2, offset1);\n+        computeOffset(dx12, dy12, lineWidth2, offset0);\n+        computeOffset(dx23, dy23, lineWidth2, offset1);\n@@ -1037,1 +1099,2 @@\n-        safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff);\n+\n+        safeComputeMiter(x1p, y1p, x1p+dx12, y1p+dy12, x3p, y3p, x3p-dx23, y3p-dy23, leftOff);\n@@ -1041,3 +1104,6 @@\n-        x1p = x1 - offset0[0]; y1p = y1 - offset0[1];\n-        x3p = x3 - offset1[0]; y3p = y3 - offset1[1];\n-        safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff);\n+        x1p = x1 - offset0[0]; \/\/ start\n+        y1p = y1 - offset0[1]; \/\/ point\n+        x3p = x3 - offset1[0]; \/\/ end\n+        y3p = y3 - offset1[1]; \/\/ point\n+\n+        safeComputeMiter(x1p, y1p, x1p+dx12, y1p+dy12, x3p, y3p, x3p-dx23, y3p-dy23, rightOff);\n@@ -1046,0 +1112,1 @@\n+\n@@ -1090,1 +1157,0 @@\n-\n@@ -1237,1 +1303,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Stroker.java","additions":180,"deletions":115,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -513,1 +513,7 @@\n-    static final class PathClipFilter implements DPathConsumer2D {\n+    static final class PathClipFilter implements StartFlagPathConsumer2D {\n+\n+        private static final boolean TRACE = false;\n+\n+        private static final int MOVE_TO = 0;\n+        private static final int DRAWING_OP_TO = 1; \/\/ ie. curve, line, or quad\n+        private static final int CLOSE = 2;\n@@ -517,0 +523,2 @@\n+        private int prev;\n+\n@@ -528,0 +536,3 @@\n+        \/\/ the outcode of the starting point\n+        private int sOutCode = 0;\n+\n@@ -536,1 +547,1 @@\n-        \/\/ The current point (TODO stupid repeated info)\n+        \/\/ The current point\n@@ -539,3 +550,0 @@\n-        \/\/ The current point OUTSIDE\n-        private double cox0, coy0;\n-\n@@ -567,0 +575,1 @@\n+            this.prev = CLOSE;\n@@ -580,8 +589,6 @@\n-            if (outside) {\n-                \/\/ criteria: inside or totally outside ?\n-                if (gOutCode == 0) {\n-                    finish();\n-                } else {\n-                    this.outside = false;\n-                    stack.reset();\n-                }\n+            \/\/ criteria: inside or totally outside ?\n+            if (gOutCode == 0) {\n+                finish();\n+            } else {\n+                this.outside = false;\n+                stack.reset();\n@@ -613,1 +620,2 @@\n-                stack.pullAll(corners, out);\n+                stack.pullAll(corners, out, (prev == MOVE_TO));\n+                prev = DRAWING_OP_TO;\n@@ -615,3 +623,0 @@\n-            out.lineTo(cox0, coy0);\n-            this.cx0 = cox0;\n-            this.cy0 = coy0;\n@@ -622,1 +627,4 @@\n-            finishPath();\n+            if (TRACE) {\n+                MarlinUtils.logInfo(\"PathDone(\" + sx0 + \", \" + sy0 + \") prev: \" + prev);\n+            }\n+            _closePath();\n@@ -624,0 +632,1 @@\n+            \/\/ note: renderer's pathDone() must handle missing moveTo() if outside\n@@ -626,0 +635,4 @@\n+            \/\/ this shouldn't matter since this object won't be used\n+            \/\/ after the call to this method.\n+            this.prev = CLOSE;\n+\n@@ -633,1 +646,4 @@\n-            finishPath();\n+            if (TRACE) {\n+                MarlinUtils.logInfo(\"ClosePath(\" + sx0 + \", \" + sy0 + \") prev: \" + prev);\n+            }\n+            _closePath();\n@@ -635,1 +651,10 @@\n-            out.closePath();\n+            if (prev == DRAWING_OP_TO) {\n+                out.closePath();\n+            }\n+\n+            \/\/ if outside, moveTo is needed\n+            if (sOutCode != 0) {\n+                this.prev = MOVE_TO;\n+            } else {\n+                this.prev = CLOSE;\n+            }\n@@ -638,1 +663,1 @@\n-            this.cOutCode = Helpers.outcode(sx0, sy0, clipRect);\n+            this.cOutCode = sOutCode;\n@@ -643,0 +668,25 @@\n+        private void _closePath() {\n+            \/\/ preserve outside flag for the lineTo call below\n+            final boolean prevOutside = outside;\n+            if (prevOutside) {\n+                finishPath();\n+            }\n+\n+            if (prev == DRAWING_OP_TO) {\n+                \/\/ Should clip\n+                final int orCode = (cOutCode | sOutCode);\n+                if (orCode != 0) {\n+                    if ((cx0 != sx0) || (cy0 != sy0)) {\n+                        \/\/ restore outside flag before lineTo:\n+                        this.outside = prevOutside;\n+                        \/\/ may subdivide line:\n+                        lineTo(sx0, sy0);\n+                        \/\/ finish if outside caused by lineTo:\n+                        if (outside) {\n+                            finishPath();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -645,1 +695,4 @@\n-            finishPath();\n+            if (TRACE) {\n+                MarlinUtils.logInfo(\"MoveTo(\" + x0 + \", \" + y0 + \") prev: \" + prev);\n+            }\n+            _closePath();\n@@ -647,1 +700,1 @@\n-            out.moveTo(x0, y0);\n+            this.prev = MOVE_TO;\n@@ -650,1 +703,3 @@\n-            this.cOutCode = Helpers.outcode(x0, y0, clipRect);\n+            final int outcode = Helpers.outcode(x0, y0, clipRect);\n+            this.cOutCode = outcode;\n+            this.sOutCode = outcode;\n@@ -653,1 +708,0 @@\n-\n@@ -658,0 +712,6 @@\n+        \/* Callback from CurveClipSplitter *\/\n+        @Override\n+        public void setStartFlag(boolean first) {\n+            \/\/ no-op\n+        }\n+\n@@ -663,0 +723,8 @@\n+            if (TRACE) {\n+                if (subdivide) {\n+                    MarlinUtils.logInfo(\"----------------------\");\n+                }\n+                MarlinUtils.logInfo(\"LineTo c  (\" + cx0 + \", \" + cy0 + \") outcode: \" + outcode0);\n+                MarlinUtils.logInfo(\"LineTo (\" + xe + \", \" + ye + \") outcode: \" + outcode1 + \" outside: \" + outside);\n+            }\n+\n@@ -676,7 +744,2 @@\n-                        if (outside) {\n-                            ret = curveSplitter.splitLine(cox0, coy0, xe, ye,\n-                                                          orCode, this);\n-                        } else {\n-                            ret = curveSplitter.splitLine(cx0, cy0, xe, ye,\n-                                                          orCode, this);\n-                        }\n+                        ret = curveSplitter.splitLine(cx0, cy0, xe, ye,\n+                                                      orCode, this);\n@@ -695,2 +758,6 @@\n-                    this.cox0 = xe;\n-                    this.coy0 = ye;\n+                    this.cx0 = xe;\n+                    this.cy0 = ye;\n+\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"skipped: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n@@ -708,0 +775,13 @@\n+\n+                \/\/ emit last point outside before entering again...\n+                if (outcode0 != 0) {\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"add last point outside: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n+                    if (prev == MOVE_TO) {\n+                        out.moveTo(cx0, cy0);\n+                    } else {\n+                        out.lineTo(cx0, cy0);\n+                    }\n+                    prev = DRAWING_OP_TO;\n+                }\n@@ -710,0 +790,5 @@\n+            if (prev == MOVE_TO) {\n+                out.moveTo(cx0, cy0);\n+            }\n+            prev = DRAWING_OP_TO;\n+\n@@ -713,0 +798,4 @@\n+\n+            if (TRACE && subdivide) {\n+                MarlinUtils.logInfo(\"----------------------\");\n+            }\n@@ -762,0 +851,8 @@\n+            if (TRACE) {\n+                if (subdivide) {\n+                    MarlinUtils.logInfo(\"----------------------\");\n+                }\n+                MarlinUtils.logInfo(\"CurveTo c  (\" + cx0 + \", \" + cy0 + \") outcode: \" + outcode0);\n+                MarlinUtils.logInfo(\"CurveTo (\" + xe + \", \" + ye + \") outcode: \" + outcode3 + \" outside: \" + outside);\n+            }\n+\n@@ -775,9 +872,3 @@\n-                        if (outside) {\n-                            ret = curveSplitter.splitCurve(cox0, coy0, x1, y1,\n-                                                           x2, y2, xe, ye,\n-                                                           orCode, this);\n-                        } else {\n-                            ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,\n-                                                           x2, y2, xe, ye,\n-                                                           orCode, this);\n-                        }\n+                        ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,\n+                                                       x2, y2, xe, ye,\n+                                                       orCode, this);\n@@ -796,2 +887,6 @@\n-                    this.cox0 = xe;\n-                    this.coy0 = ye;\n+                    this.cx0 = xe;\n+                    this.cy0 = ye;\n+\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"skipped: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n@@ -809,0 +904,13 @@\n+\n+                \/\/ emit last point outside before entering again...\n+                if (outcode0 != 0) {\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"add last point outside: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n+                    if (prev == MOVE_TO) {\n+                        out.moveTo(cx0, cy0);\n+                    } else {\n+                        out.lineTo(cx0, cy0);\n+                    }\n+                    prev = DRAWING_OP_TO;\n+                }\n@@ -811,0 +919,5 @@\n+            if (prev == MOVE_TO) {\n+                out.moveTo(cx0, cy0);\n+            }\n+            prev = DRAWING_OP_TO;\n+\n@@ -814,0 +927,4 @@\n+\n+            if (TRACE && subdivide) {\n+                MarlinUtils.logInfo(\"----------------------\");\n+            }\n@@ -824,0 +941,8 @@\n+            if (TRACE) {\n+                if (subdivide) {\n+                    MarlinUtils.logInfo(\"----------------------\");\n+                }\n+                MarlinUtils.logInfo(\"QuadTo c  (\" + cx0 + \", \" + cy0 + \") outcode: \" + outcode0);\n+                MarlinUtils.logInfo(\"QuadTo (\" + xe + \", \" + ye + \") outcode: \" + outcode1 + \" outside: \" + outside);\n+            }\n+\n@@ -837,7 +962,2 @@\n-                        if (outside) {\n-                            ret = curveSplitter.splitQuad(cox0, coy0, x1, y1,\n-                                                          xe, ye, orCode, this);\n-                        } else {\n-                            ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,\n-                                                          xe, ye, orCode, this);\n-                        }\n+                        ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,\n+                                                      xe, ye, orCode, this);\n@@ -856,2 +976,2 @@\n-                    this.cox0 = xe;\n-                    this.coy0 = ye;\n+                    this.cx0 = xe;\n+                    this.cy0 = ye;\n@@ -869,0 +989,13 @@\n+\n+                \/\/ emit last point outside before entering again...\n+                if (outcode0 != 0) {\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"add last point outside: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n+                    if (prev == MOVE_TO) {\n+                        out.moveTo(cx0, cy0);\n+                    } else {\n+                        out.lineTo(cx0, cy0);\n+                    }\n+                    prev = DRAWING_OP_TO;\n+                }\n@@ -871,0 +1004,5 @@\n+            if (prev == MOVE_TO) {\n+                out.moveTo(cx0, cy0);\n+            }\n+            prev = DRAWING_OP_TO;\n+\n@@ -874,0 +1012,4 @@\n+\n+            if (TRACE && subdivide) {\n+                MarlinUtils.logInfo(\"----------------------\");\n+            }\n@@ -882,0 +1024,5 @@\n+    interface StartFlagPathConsumer2D extends DPathConsumer2D {\n+\n+        void setStartFlag(boolean first);\n+    }\n+\n@@ -950,0 +1097,1 @@\n+        \/\/ Use a specific interface to make recursion more obvious\n@@ -953,1 +1101,1 @@\n-                          final DPathConsumer2D out)\n+                          final StartFlagPathConsumer2D out)\n@@ -974,1 +1122,1 @@\n-                          final DPathConsumer2D out)\n+                          final StartFlagPathConsumer2D out)\n@@ -997,1 +1145,1 @@\n-                           final DPathConsumer2D out)\n+                           final StartFlagPathConsumer2D out)\n@@ -1017,1 +1165,1 @@\n-                                                 final DPathConsumer2D out)\n+                                                 final StartFlagPathConsumer2D out)\n@@ -1053,0 +1201,5 @@\n+\n+                if (i == 0) {\n+                    \/\/ disable start flag:\n+                    out.setStartFlag(false);\n+                }\n@@ -1054,0 +1207,2 @@\n+            \/\/ reset start flag:\n+            out.setStartFlag(true);\n@@ -1058,1 +1213,1 @@\n-                                final int off, final DPathConsumer2D out)\n+                                final int off, final StartFlagPathConsumer2D out)\n@@ -1066,1 +1221,1 @@\n-                out.lineTo(pts[off + 2], pts[off + 3]);\n+                out.lineTo( pts[off + 2], pts[off + 3]);\n@@ -1068,2 +1223,2 @@\n-                out.quadTo(pts[off + 2], pts[off + 3],\n-                           pts[off + 4], pts[off + 5]);\n+                out.quadTo( pts[off + 2], pts[off + 3],\n+                            pts[off + 4], pts[off + 5]);\n@@ -1081,1 +1236,1 @@\n-        \/\/ number of split curves\n+        \/\/ number of splitted curves\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/TransformingPathConsumer2D.java","additions":219,"deletions":64,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-    private static final String VERSION = \"marlin-0.9.1.4-Unsafe-OpenJDK\";\n+    private static final String VERSION = \"marlin-0.9.4.6-Unsafe-OpenJDK\";\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Version.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-            if (stats[i].count != 0l) {\n+            if (stats[i].count != 0L) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/stats\/Histogram.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-        if (start != INVALID && elapsed > 0l) {\n+        if (start != INVALID && elapsed > 0L) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/stats\/Monitor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-    public long count = 0l;\n-    public long sum = 0l;\n+    public long count = 0L;\n+    public long sum = 0L;\n@@ -44,2 +44,2 @@\n-        count = 0l;\n-        sum = 0l;\n+        count = 0L;\n+        sum = 0L;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/stats\/StatLong.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+    private static final boolean DO_RENDER = !sun.java2d.marlin.MarlinProperties.isSkipRenderTiles();\n+\n@@ -51,3 +53,2 @@\n-            new ReentrantContextProviderTL<TileState>(\n-                    ReentrantContextProvider.REF_HARD)\n-            {\n+            new ReentrantContextProviderTL<>(\n+                    ReentrantContextProvider.REF_HARD) {\n@@ -163,4 +164,5 @@\n-            context = outpipe.startSequence(sg, s,\n-                                            ts.computeDevBox(abox),\n-                                            abox);\n-\n+            if (DO_RENDER) {\n+                context = outpipe.startSequence(sg, s,\n+                                                ts.computeDevBox(abox),\n+                                                abox);\n+            }\n@@ -188,1 +190,3 @@\n-                    if (a == 0x00 || !outpipe.needTile(context, x, y, w, h)) {\n+                    if ((a == 0x00)\n+                            || (DO_RENDER && !outpipe.needTile(context, x, y, w, h)))\n+                    {\n@@ -190,1 +194,3 @@\n-                        outpipe.skipTile(context, x, y);\n+                        if (DO_RENDER) {\n+                            outpipe.skipTile(context, x, y);\n+                        }\n@@ -200,2 +206,3 @@\n-\n-                    outpipe.renderPathTile(context, atile, 0, tw, x, y, w, h);\n+                    if (DO_RENDER) {\n+                        outpipe.renderPathTile(context, atile, 0, tw, x, y, w, h);\n+                    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/AAShapePipe.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,6 @@\n-    public static String toHexString(float f) {\n-        if (!Float.isNaN(f))\n-            return Float.toHexString(f);\n-        else\n-            return \"NaN(0x\" + Integer.toHexString(Float.floatToRawIntBits(f)) + \")\";\n+    public static String toHexString(double f) {\n+        if (!Double.isNaN(f)) {\n+            return Double.toHexString(f);\n+        } else {\n+            return \"NaN(0x\" + Long.toHexString(Double.doubleToRawLongBits(f)) + \")\";\n+        }\n@@ -41,3 +42,3 @@\n-    public static int test(String testName, float input,\n-                           float result, float expected) {\n-        if (Float.compare(expected, result) != 0) {\n+    public static int test(String testName, double input,\n+                           double result, double expected) {\n+        if (Double.compare(expected, result) != 0) {\n@@ -54,2 +55,2 @@\n-    public static int test_skip_0(String testName, float input,\n-                           float result, float expected)\n+    public static int test_skip_0(String testName, double input,\n+                           double result, double expected)\n@@ -59,1 +60,1 @@\n-        if (Float.compare(expected, result) != 0 && (expected != 0f))\n+        if (Double.compare(expected, result) != 0 && (expected != 0.0))\n@@ -71,1 +72,1 @@\n-    private static int testCeilCase(float input, float expected) {\n+    private static int testCeilCase(double input, double expected) {\n@@ -73,2 +74,0 @@\n-        \/\/ float result:\n-        failures += test(\"FloatMath.ceil_f\", input, FloatMath.ceil_f(input), expected);\n@@ -77,1 +76,0 @@\n-        failures += test(\"FloatMath.ceil_f (int)\", input, (int)FloatMath.ceil_f(input), (int)expected);\n@@ -81,1 +79,1 @@\n-    private static int testFloorCase(float input, float expected) {\n+    private static int testFloorCase(double input, double expected) {\n@@ -83,2 +81,0 @@\n-        \/\/ float result:\n-        failures += test       (\"FloatMath.floor_f\", input, FloatMath.floor_f(input), expected);\n@@ -87,1 +83,0 @@\n-        failures += test_skip_0(\"FloatMath.floor_f (int)\", input, (int)FloatMath.floor_f(input), (int)expected);\n@@ -94,7 +89,7 @@\n-        float [] fixedPoints = {\n-            -0.0f,\n-             0.0f,\n-            -1.0f,\n-             1.0f,\n-            -0x1.0p52f,\n-             0x1.0p52f,\n+        double [] fixedPoints = {\n+            -0.0,\n+             0.0,\n+            -1.0,\n+             1.0,\n+            -0x1.0p52,\n+             0x1.0p52,\n@@ -108,1 +103,1 @@\n-        for(float fixedPoint : fixedPoints) {\n+        for(double fixedPoint : fixedPoints) {\n@@ -114,3 +109,3 @@\n-            float powerOfTwo   = Math.scalb(1.0f, i);\n-            float neighborDown = Math.nextDown(powerOfTwo);\n-            float neighborUp   = Math.nextUp(powerOfTwo);\n+            double powerOfTwo   = Math.scalb(1.0f, i);\n+            double neighborDown = Math.nextDown(powerOfTwo);\n+            double neighborUp   = Math.nextUp(powerOfTwo);\n@@ -119,2 +114,2 @@\n-                failures += testCeilCase( powerOfTwo,  1.0f);\n-                failures += testCeilCase(-powerOfTwo, -0.0f);\n+                failures += testCeilCase( powerOfTwo,  1.0);\n+                failures += testCeilCase(-powerOfTwo, -0.0);\n@@ -122,2 +117,2 @@\n-                failures += testFloorCase( powerOfTwo,  0.0f);\n-                failures += testFloorCase(-powerOfTwo, -1.0f);\n+                failures += testFloorCase( powerOfTwo,  0.0);\n+                failures += testFloorCase(-powerOfTwo, -1.0);\n@@ -125,2 +120,2 @@\n-                failures += testCeilCase( neighborDown, 1.0f);\n-                failures += testCeilCase(-neighborDown, -0.0f);\n+                failures += testCeilCase( neighborDown, 1.0);\n+                failures += testCeilCase(-neighborDown, -0.0);\n@@ -128,2 +123,2 @@\n-                failures += testFloorCase( neighborUp,  0.0f);\n-                failures += testFloorCase(-neighborUp, -1.0f);\n+                failures += testFloorCase( neighborUp,  0.0);\n+                failures += testFloorCase(-neighborUp, -1.0);\n@@ -159,3 +154,3 @@\n-            float f = (float) i;\n-            float neighborDown = Math.nextDown(f);\n-            float neighborUp   = Math.nextUp(f);\n+            double f = (double) i;\n+            double neighborDown = Math.nextDown(f);\n+            double neighborUp   = Math.nextUp(f);\n@@ -183,13 +178,7 @@\n-        float [][] testCases = {\n-            { Float.MIN_VALUE,                           1.0f},\n-            {-Float.MIN_VALUE,                          -0.0f},\n-            { Math.nextDown(Float.MIN_NORMAL),           1.0f},\n-            {-Math.nextDown(Float.MIN_NORMAL),          -0.0f},\n-            { Float.MIN_NORMAL,                          1.0f},\n-            {-Float.MIN_NORMAL,                         -0.0f},\n-\n-            { 0.1f,                                        1.0f},\n-            {-0.1f,                                       -0.0f},\n-\n-            { 0.5f,                                        1.0f},\n-            {-0.5f,                                       -0.0f},\n+        double [][] testCases = {\n+            { Float.MIN_VALUE,                           1.0},\n+            {-Float.MIN_VALUE,                          -0.0},\n+            { Math.nextDown(Float.MIN_NORMAL),           1.0},\n+            {-Math.nextDown(Float.MIN_NORMAL),          -0.0},\n+            { Float.MIN_NORMAL,                          1.0},\n+            {-Float.MIN_NORMAL,                         -0.0},\n@@ -197,2 +186,2 @@\n-            { 1.5f,                                        2.0f},\n-            {-1.5f,                                       -1.0f},\n+            { 0.1,                                        1.0},\n+            {-0.1,                                       -0.0},\n@@ -200,2 +189,2 @@\n-            { 2.5f,                                        3.0f},\n-            {-2.5f,                                       -2.0f},\n+            { 0.5,                                        1.0},\n+            {-0.5,                                       -0.0},\n@@ -203,2 +192,2 @@\n-            { 12.3456789f,                                13.0f},\n-            {-12.3456789f,                               -12.0f},\n+            { 1.5,                                        2.0},\n+            {-1.5,                                       -1.0},\n@@ -206,2 +195,2 @@\n-            { Math.nextDown(1.0f),                         1.0f},\n-            { Math.nextDown(-1.0f),                       -1.0f},\n+            { 2.5,                                        3.0},\n+            {-2.5,                                       -2.0},\n@@ -209,2 +198,2 @@\n-            { Math.nextUp(1.0f),                           2.0f},\n-            { Math.nextUp(-1.0f),                         -0.0f},\n+            { 12.3456789,                                13.0},\n+            {-12.3456789,                               -12.0},\n@@ -212,2 +201,2 @@\n-            { 0x1.0p22f,                                 0x1.0p22f},\n-            {-0x1.0p22f,                                -0x1.0p22f},\n+            { Math.nextDown(1.0),                         1.0},\n+            { Math.nextDown(-1.0),                       -1.0},\n@@ -215,2 +204,2 @@\n-            { Math.nextDown(0x1.0p22f),                  0x1.0p22f},\n-            {-Math.nextUp(0x1.0p22f),                   -0x1.0p22f},\n+            { Math.nextUp(1.0),                           2.0},\n+            { Math.nextUp(-1.0),                         -0.0},\n@@ -218,2 +207,2 @@\n-            { Math.nextUp(0x1.0p22f),                    0x1.0p22f+1f},\n-            {-Math.nextDown(0x1.0p22f),                 -0x1.0p22f+1f},\n+            { 0x1.0p22,                                 0x1.0p22},\n+            {-0x1.0p22,                                -0x1.0p22},\n@@ -221,2 +210,2 @@\n-            { Math.nextDown(0x1.0p23f),                  0x1.0p23f},\n-            {-Math.nextUp(0x1.0p23f),                   -0x1.0p23f-1f},\n+            { Math.nextDown(0x1.0p22),                  0x1.0p22},\n+            {-Math.nextUp(0x1.0p22),                   -0x1.0p22},\n@@ -224,2 +213,2 @@\n-            { Math.nextUp(0x1.0p23f),                    0x1.0p23f+1f},\n-            {-Math.nextDown(0x1.0p23f),                 -0x1.0p23f+1f},\n+            { Math.nextUp(0x1.0p22),                    0x1.0p22 + 1.0},\n+            {-Math.nextDown(0x1.0p22),                 -0x1.0p22 + 1.0}\n@@ -228,1 +217,1 @@\n-        for(float[] testCase : testCases) {\n+        for(double[] testCase : testCases) {\n","filename":"test\/jdk\/sun\/java2d\/marlin\/CeilAndFloorTests.java","additions":65,"deletions":76,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import javax.swing.JButton;\n-import javax.swing.JFrame;\n@@ -35,1 +33,0 @@\n-import javax.swing.WindowConstants;\n@@ -63,4 +60,4 @@\n-            @Override\n-            public void run() {\n-                drawGui();\n-            }\n+                @Override\n+                public void run() {\n+                    drawGui();\n+                }\n@@ -68,1 +65,1 @@\n-            });\n+                });\n","filename":"test\/jdk\/sun\/java2d\/marlin\/DashStrokeTest.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        System.out.println(\"DashedRectClipTest: size = \" + size);\n+        System.out.println(\"DashedRectTest: size = \" + size);\n@@ -98,1 +98,1 @@\n-                    final File file = new File(\"DashedRectClipTest-MAX-\" + MAX + \"-dashed.png\");\n+                    final File file = new File(\"DashedRectTest-MAX-\" + MAX + \"-dashed.png\");\n","filename":"test\/jdk\/sun\/java2d\/marlin\/DashedRectTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.geom.Path2D;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.ImageIO;\n+\n+\/**\n+ * Clip rendering test\n+ *\n+ * @test\n+ * @bug 8297230\n+ * @summary verify that huge polygon is properly rasterized\n+ *\/\n+public class HugePolygonClipTest {\n+\n+    private static final double LARGE_X_COORDINATE = 4194304.250;\n+    private static final int SCENE_WIDTH = 600;\n+    private static final int SCENE_HEIGHT = 400;\n+\n+    private static final float WIDTH = 2.73f;\n+\n+    private static final int G_MASK = 0x0000ff00;\n+    private static final int R_MASK = 0x00ff0000;\n+    private static final int RGB_MASK = 0x00ffffff;\n+\n+    static final boolean SAVE_IMAGE = false;\n+\n+    public static void main(final String[] args) {\n+\n+        \/\/ First display which renderer is tested:\n+        \/\/ JDK9 only:\n+        System.setProperty(\"sun.java2d.renderer.verbose\", \"true\");\n+\n+        \/\/ enable Marlin logging:\n+        System.setProperty(\"sun.java2d.renderer.log\", \"true\");\n+        System.setProperty(\"sun.java2d.renderer.clip\", \"true\");\n+        System.setProperty(\"sun.java2d.renderer.subPixel_log2_X\", \"8\");\n+\n+        System.out.println(\"HugePolygonClipTest: size = \" + SCENE_WIDTH + \" x \" + SCENE_HEIGHT);\n+\n+        final BufferedImage image = new BufferedImage(SCENE_WIDTH, SCENE_HEIGHT, BufferedImage.TYPE_INT_ARGB);\n+\n+        final Graphics2D g2d = (Graphics2D) image.getGraphics();\n+        try {\n+            g2d.setBackground(Color.BLACK);\n+            g2d.clearRect(0, 0, SCENE_WIDTH, SCENE_HEIGHT);\n+\n+            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+            g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n+            g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);\n+\n+            \/\/ original test case => large moveTo in Filler but no bug in Stroker:\n+            double longWidth = LARGE_X_COORDINATE + SCENE_WIDTH + 0.001;\n+\n+            final Path2D veryWidePolygon = new Path2D.Double();\n+            veryWidePolygon.moveTo(longWidth, 50.0);\n+            veryWidePolygon.lineTo(longWidth, 100.0);\n+            veryWidePolygon.lineTo(0.0, 100.0);\n+            veryWidePolygon.lineTo(0.0, 0.0);\n+            veryWidePolygon.closePath();\n+\n+            g2d.translate(-longWidth + SCENE_WIDTH, 100.0);\n+\n+            g2d.setPaint(Color.RED);\n+            g2d.fill(veryWidePolygon);\n+\n+            g2d.setPaint(Color.GREEN);\n+            g2d.setStroke(new BasicStroke(WIDTH));\n+            g2d.draw(veryWidePolygon);\n+\n+            if (SAVE_IMAGE) {\n+                try {\n+                    final File file = new File(\"TestHugePolygonCoords.png\");\n+\n+                    System.out.println(\"Writing file: \" + file.getAbsolutePath());\n+                    ImageIO.write(image, \"PNG\", file);\n+                } catch (IOException ex) {\n+                    ex.printStackTrace();\n+                }\n+            }\n+\n+            \/\/ Check image on few pixels:\n+            final int x = SCENE_WIDTH \/ 2;\n+            checkColumn(image, x, SCENE_HEIGHT);\n+\n+        } finally {\n+            g2d.dispose();\n+        }\n+    }\n+\n+    private static void checkColumn(final BufferedImage image, final int x, final int maxY) {\n+        boolean trigger = false;\n+        boolean inside = false;\n+\n+        for (int y = 0; y < maxY; y++) {\n+            final int rgb = image.getRGB(x, y);\n+            \/\/ System.out.println(\"pixel at (\" + x + \", \" + y + \") = \" + rgb);\n+\n+            if ((rgb & G_MASK) != 0) {\n+                if (!trigger) {\n+                    trigger = true;\n+                    inside = !inside;\n+                    \/\/ System.out.println(\"inside: \"+inside);\n+                }\n+            } else {\n+                trigger = false;\n+\n+                final int mask = (inside) ? R_MASK : RGB_MASK;\n+\n+                final int expected = (rgb & mask);\n+\n+                \/\/ System.out.println(\"pix[\" + y + \"] = \" + expected + \" inside: \" + inside);\n+                if ((inside && (expected == 0))\n+                        || (!inside && (expected != 0))) {\n+                    throw new IllegalStateException(\"bad pixel at (\" + x + \", \" + y\n+                            + \") = \" + expected + \" inside: \" + inside);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/marlin\/HugePolygonClipTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"}]}