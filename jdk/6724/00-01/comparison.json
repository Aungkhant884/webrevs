{"files":[{"patch":"@@ -36,1 +36,1 @@\n- * ofter shrunk or expanded before\/after casting if the element number mismatch.\n+ * ofter shrunk or expanded before\/after casting if the element numbers mismatch.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorCast.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * As spot in 8259353. We need to do a shrink and an expand together to not accidentally zero out\n- * elements in the physical registers that may not be zero in general cases.\n+ * As spot in 8259353. We need to do a shrink and an expand together to not accidentally\n+ * zero out elements in the physical registers that may not be zero in general cases.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorDoubleExpandShrink.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,3 @@\n- *  This class contains method to ensure a resize reinterpret operations work as intended.\n- *  In each test, it is expected to have exactly 1 ReinterpretNode.\n+ *  This class contains method to ensure a resizing reinterpretation operations work as\n+ *  intended.\n+ *  In each test, the ReinterpretNode is expected to appear exactly once.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorExpandShrink.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * This class contains methods to test for reinterpret operations that reinterpret a\n- * vector as a similar vector with another element type. It is complicated to verify\n+ * This class contains methods to test for reinterpretation operations that reinterpret\n+ * a vector as a similar vector with another element type. It is complicated to verify\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorRebracket.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.List;\n@@ -37,1 +38,1 @@\n-    public static final int INVOCATIONS = 100_000;\n+    public static final int INVOCATIONS = 10_000;\n@@ -98,1 +99,27 @@\n-            random.nextBytes(input);\n+            \/\/ We need to generate arrays with NaN or very large values occasionally\n+            boolean normalArray = random.nextBoolean();\n+            var abnormalValue = List.of(Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, -1e30, 1e30);\n+            for (int i = 0; i < isp.length(); i++) {\n+                switch (isp.elementType().getName()) {\n+                    case \"byte\"   -> setByte(input, i, (byte)random.nextInt());\n+                    case \"short\"  -> setShort(input, i, (short)random.nextInt());\n+                    case \"int\"    -> setInt(input, i, random.nextInt());\n+                    case \"long\"   -> setLong(input, i, random.nextLong());\n+                    case \"float\"  -> {\n+                        if (normalArray || random.nextBoolean()) {\n+                            setFloat(input, i, random.nextFloat(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+                        } else {\n+                            setFloat(input, i, abnormalValue.get(random.nextInt(abnormalValue.size())).floatValue());\n+                        }\n+                    }\n+                    case \"double\" -> {\n+                        if (normalArray || random.nextBoolean()) {\n+                            setDouble(input, i, random.nextDouble(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+                        } else {\n+                            setDouble(input, i, abnormalValue.get(random.nextInt(abnormalValue.size())));\n+                        }\n+                    }\n+                    default -> throw new AssertionError();\n+                }\n+            }\n+\n@@ -100,0 +127,1 @@\n+\n@@ -182,0 +210,1 @@\n+\n@@ -183,0 +212,1 @@\n+\n@@ -210,0 +240,1 @@\n+\n@@ -211,0 +242,1 @@\n+\n@@ -219,1 +251,1 @@\n-    \/\/ All this complication is due to the fact vector load and store with respect to byte array introduce\n+    \/\/ All this complication is due to the fact that vector load and store with respect to byte array introduce\n@@ -258,0 +290,1 @@\n+\n@@ -259,0 +292,1 @@\n+\n@@ -291,0 +325,24 @@\n+    public static void setByte(byte[] array, int index, byte value) {\n+        BYTE_ACCESS.set(array, index * Byte.BYTES, value);\n+    }\n+\n+    public static void setShort(byte[] array, int index, short value) {\n+        SHORT_ACCESS.set(array, index * Short.BYTES, value);\n+    }\n+\n+    public static void setInt(byte[] array, int index, int value) {\n+        INT_ACCESS.set(array, index * Integer.BYTES, value);\n+    }\n+\n+    public static void setLong(byte[] array, int index, long value) {\n+        LONG_ACCESS.set(array, index * Long.BYTES, value);\n+    }\n+\n+    public static void setFloat(byte[] array, int index, float value) {\n+        FLOAT_ACCESS.set(array, index * Float.BYTES, value);\n+    }\n+\n+    public static void setDouble(byte[] array, int index, double value) {\n+        DOUBLE_ACCESS.set(array, index * Double.BYTES, value);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":61,"deletions":3,"binary":false,"changes":64,"status":"modified"}]}