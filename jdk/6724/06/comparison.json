{"files":[{"patch":"@@ -144,0 +144,8 @@\n+    public static final String VECTOR_CAST_B2X = START + \"VectorCastB2X\" + MID + END;\n+    public static final String VECTOR_CAST_S2X = START + \"VectorCastS2X\" + MID + END;\n+    public static final String VECTOR_CAST_I2X = START + \"VectorCastI2X\" + MID + END;\n+    public static final String VECTOR_CAST_L2X = START + \"VectorCastL2X\" + MID + END;\n+    public static final String VECTOR_CAST_F2X = START + \"VectorCastF2X\" + MID + END;\n+    public static final String VECTOR_CAST_D2X = START + \"VectorCastD2X\" + MID + END;\n+    public static final String VECTOR_REINTERPRET = START + \"VectorReinterpret\" + MID + END;\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on avx1.\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastAVX1\n+ *\/\n+public class TestVectorCastAVX1 {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.AVX1_CAST_TESTS.stream(),\n+                \"-XX:UseAVX=1\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX1.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on avx2.\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastAVX2\n+ *\/\n+public class TestVectorCastAVX2 {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.AVX2_CAST_TESTS.stream(),\n+                \"-XX:UseAVX=2\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX2.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on avx512.\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastAVX512\n+ *\/\n+public class TestVectorCastAVX512 {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.AVX512_CAST_TESTS.stream(),\n+                \"-XX:UseAVX=3\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on avx512dq.\n+ * @requires vm.cpu.features ~= \".*avx512dq.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastAVX512DQ\n+ *\/\n+public class TestVectorCastAVX512DQ {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.AVX512DQ_CAST_TESTS.stream(),\n+                \"-XX:UseAVX=3\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512DQ.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on neon.\n+ * @requires vm.cpu.features ~= \".*simd.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastNeon\n+ *\/\n+public class TestVectorCastNeon {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.NEON_CAST_TESTS.stream(),\n+                \"-XX:+UseNeon\");\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastNeon.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on sve.\n+ * @requires vm.cpu.features ~= \".*sve.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastSVE\n+ *\/\n+public class TestVectorCastSVE {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.SVE_CAST_TESTS.stream(),\n+                \"-XX:UseSVE=1\");\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastSVE.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorDoubleExpandShrink;\n+import compiler.vectorapi.reshape.tests.TestVectorExpandShrink;\n+import compiler.vectorapi.reshape.tests.TestVectorRebracket;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+import compiler.vectorapi.reshape.utils.VectorSpeciesPair;\n+import java.util.List;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector reinterpret intrinsics work as intended.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorReinterpret\n+ *\/\n+public class TestVectorReinterpret {\n+    private static final List<VectorShape> SHAPE_LIST = List.of(VectorShape.values());\n+    private static final List<Class<?>> ETYPE_LIST = List.of(\n+            byte.class, short.class, int.class, long.class, float.class, double.class\n+    );\n+\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorExpandShrink.class,\n+                SHAPE_LIST.stream()\n+                        .flatMap(s -> SHAPE_LIST.stream()\n+                                .filter(t -> t.vectorBitSize() != s.vectorBitSize())\n+                                .map(t -> VectorSpeciesPair.makePair(VectorSpecies.of(byte.class, s),\n+                                        VectorSpecies.of(byte.class, t))))\n+        );\n+\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorDoubleExpandShrink.class,\n+                SHAPE_LIST.stream()\n+                        .flatMap(s -> SHAPE_LIST.stream()\n+                                .filter(t -> t.vectorBitSize() != s.vectorBitSize())\n+                                .map(t -> VectorSpeciesPair.makePair(VectorSpecies.of(byte.class, s),\n+                                        VectorSpecies.of(byte.class, t))))\n+        );\n+\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorRebracket.class,\n+                SHAPE_LIST.stream()\n+                        .flatMap(shape -> ETYPE_LIST.stream()\n+                                .flatMap(etype -> ETYPE_LIST.stream()\n+                                        .filter(ftype -> ftype != etype)\n+                                        .map(ftype -> VectorSpeciesPair.makePair(VectorSpecies.of(etype, shape),\n+                                                VectorSpecies.of(ftype, shape)))))\n+                        .filter(p -> p.isp().length() > 1 && p.osp().length() > 1),\n+                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\"\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorReinterpret.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,1359 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.tests;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/**\n+ * This class contains all possible cast operations between different vector species.\n+ * The methods only take into consideration the actual cast in C2, as the vectors are\n+ * ofter shrunk or expanded before\/after casting if the element numbers mismatch.\n+ * In each cast, the VectorCastNode is expected to appear exactly once.\n+ *\/\n+public class TestVectorCast {\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toS64(byte[] input, byte[] output) {\n+        vectorCast(B2S, BSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toS64\")\n+    public static void runB64toS64() throws Throwable {\n+        runCastHelper(B2S, BSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toS128(byte[] input, byte[] output) {\n+        vectorCast(B2S, BSPEC64, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toS128\")\n+    public static void runB64toS128() throws Throwable {\n+        runCastHelper(B2S, BSPEC64, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB128toS256(byte[] input, byte[] output) {\n+        vectorCast(B2S, BSPEC128, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB128toS256\")\n+    public static void runB128toS256() throws Throwable {\n+        runCastHelper(B2S, BSPEC128, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB256toS512(byte[] input, byte[] output) {\n+        vectorCast(B2S, BSPEC256, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB256toS512\")\n+    public static void runB256toS512() throws Throwable {\n+        runCastHelper(B2S, BSPEC256, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toI64(byte[] input, byte[] output) {\n+        vectorCast(B2I, BSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toI64\")\n+    public static void runB64toI64() throws Throwable {\n+        runCastHelper(B2I, BSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toI128(byte[] input, byte[] output) {\n+        vectorCast(B2I, BSPEC64, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toI128\")\n+    public static void runB64toI128() throws Throwable {\n+        runCastHelper(B2I, BSPEC64, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toI256(byte[] input, byte[] output) {\n+        vectorCast(B2I, BSPEC64, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toI256\")\n+    public static void runB64toI256() throws Throwable {\n+        runCastHelper(B2I, BSPEC64, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB128toI512(byte[] input, byte[] output) {\n+        vectorCast(B2I, BSPEC128, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB128toI512\")\n+    public static void runB128toI512() throws Throwable {\n+        runCastHelper(B2I, BSPEC128, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toL64(byte[] input, byte[] output) {\n+        vectorCast(B2L, BSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL64\")\n+    public static void runB64toL64() throws Throwable {\n+        runCastHelper(B2L, BSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toL128(byte[] input, byte[] output) {\n+        vectorCast(B2L, BSPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL128\")\n+    public static void runB64toL128() throws Throwable {\n+        runCastHelper(B2L, BSPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toL256(byte[] input, byte[] output) {\n+        vectorCast(B2L, BSPEC64, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL256\")\n+    public static void runB64toL256() throws Throwable {\n+        runCastHelper(B2L, BSPEC64, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toL512(byte[] input, byte[] output) {\n+        vectorCast(B2L, BSPEC64, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL512\")\n+    public static void runB64toL512() throws Throwable {\n+        runCastHelper(B2L, BSPEC64, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toF64(byte[] input, byte[] output) {\n+        vectorCast(B2F, BSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toF64\")\n+    public static void runB64toF64() throws Throwable {\n+        runCastHelper(B2F, BSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toF128(byte[] input, byte[] output) {\n+        vectorCast(B2F, BSPEC64, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toF128\")\n+    public static void runB64toF128() throws Throwable {\n+        runCastHelper(B2F, BSPEC64, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toF256(byte[] input, byte[] output) {\n+        vectorCast(B2F, BSPEC64, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toF256\")\n+    public static void runB64toF256() throws Throwable {\n+        runCastHelper(B2F, BSPEC64, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB128toF512(byte[] input, byte[] output) {\n+        vectorCast(B2F, BSPEC128, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB128toF512\")\n+    public static void runB128toF512() throws Throwable {\n+        runCastHelper(B2F, BSPEC128, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toD64(byte[] input, byte[] output) {\n+        vectorCast(B2D, BSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD64\")\n+    public static void runB64toD64() throws Throwable {\n+        runCastHelper(B2D, BSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toD128(byte[] input, byte[] output) {\n+        vectorCast(B2D, BSPEC64, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD128\")\n+    public static void runB64toD128() throws Throwable {\n+        runCastHelper(B2D, BSPEC64, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toD256(byte[] input, byte[] output) {\n+        vectorCast(B2D, BSPEC64, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD256\")\n+    public static void runB64toD256() throws Throwable {\n+        runCastHelper(B2D, BSPEC64, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toD512(byte[] input, byte[] output) {\n+        vectorCast(B2D, BSPEC64, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD512\")\n+    public static void runB64toD512() throws Throwable {\n+        runCastHelper(B2D, BSPEC64, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toB64(byte[] input, byte[] output) {\n+        vectorCast(S2B, SSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toB64\")\n+    public static void runS64toB64() throws Throwable {\n+        runCastHelper(S2B, SSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toB64(byte[] input, byte[] output) {\n+        vectorCast(S2B, SSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS128toB64\")\n+    public static void runS128toB64() throws Throwable {\n+        runCastHelper(S2B, SSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS256toB128(byte[] input, byte[] output) {\n+        vectorCast(S2B, SSPEC256, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS256toB128\")\n+    public static void runS256toB128() throws Throwable {\n+        runCastHelper(S2B, SSPEC256, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS512toB256(byte[] input, byte[] output) {\n+        vectorCast(S2B, SSPEC512, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS512toB256\")\n+    public static void runS512toB256() throws Throwable {\n+        runCastHelper(S2B, SSPEC512, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toI64(byte[] input, byte[] output) {\n+        vectorCast(S2I, SSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toI64\")\n+    public static void runS64toI64() throws Throwable {\n+        runCastHelper(S2I, SSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toI128(byte[] input, byte[] output) {\n+        vectorCast(S2I, SSPEC64, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS64toI128\")\n+    public static void runS64toI128() throws Throwable {\n+        runCastHelper(S2I, SSPEC64, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toI256(byte[] input, byte[] output) {\n+        vectorCast(S2I, SSPEC128, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS128toI256\")\n+    public static void runS128toI256() throws Throwable {\n+        runCastHelper(S2I, SSPEC128, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS256toI512(byte[] input, byte[] output) {\n+        vectorCast(S2I, SSPEC256, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS256toI512\")\n+    public static void runS256toI512() throws Throwable {\n+        runCastHelper(S2I, SSPEC256, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toL64(byte[] input, byte[] output) {\n+        vectorCast(S2L, SSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toL64\")\n+    public static void runS64toL64() throws Throwable {\n+        runCastHelper(S2L, SSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toL128(byte[] input, byte[] output) {\n+        vectorCast(S2L, SSPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS64toL128\")\n+    public static void runS64toL128() throws Throwable {\n+        runCastHelper(S2L, SSPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toL256(byte[] input, byte[] output) {\n+        vectorCast(S2L, SSPEC64, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS64toL256\")\n+    public static void runS64toL256() throws Throwable {\n+        runCastHelper(S2L, SSPEC64, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toL512(byte[] input, byte[] output) {\n+        vectorCast(S2L, SSPEC128, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS128toL512\")\n+    public static void runS128toL512() throws Throwable {\n+        runCastHelper(S2L, SSPEC128, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toF64(byte[] input, byte[] output) {\n+        vectorCast(S2F, SSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toF64\")\n+    public static void runS64toF64() throws Throwable {\n+        runCastHelper(S2F, SSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toF128(byte[] input, byte[] output) {\n+        vectorCast(S2F, SSPEC64, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS64toF128\")\n+    public static void runS64toF128() throws Throwable {\n+        runCastHelper(S2F, SSPEC64, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toF256(byte[] input, byte[] output) {\n+        vectorCast(S2F, SSPEC128, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS128toF256\")\n+    public static void runS128toF256() throws Throwable {\n+        runCastHelper(S2F, SSPEC128, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS256toF512(byte[] input, byte[] output) {\n+        vectorCast(S2F, SSPEC256, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS256toF512\")\n+    public static void runS256toF512() throws Throwable {\n+        runCastHelper(S2F, SSPEC256, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toD64(byte[] input, byte[] output) {\n+        vectorCast(S2D, SSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toD64\")\n+    public static void runS64toD64() throws Throwable {\n+        runCastHelper(S2D, SSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toD128(byte[] input, byte[] output) {\n+        vectorCast(S2D, SSPEC64, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS64toD128\")\n+    public static void runS64toD128() throws Throwable {\n+        runCastHelper(S2D, SSPEC64, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toD256(byte[] input, byte[] output) {\n+        vectorCast(S2D, SSPEC64, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS64toD256\")\n+    public static void runS64toD256() throws Throwable {\n+        runCastHelper(S2D, SSPEC64, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toD512(byte[] input, byte[] output) {\n+        vectorCast(S2D, SSPEC128, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS128toD512\")\n+    public static void runS128toD512() throws Throwable {\n+        runCastHelper(S2D, SSPEC128, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toB64(byte[] input, byte[] output) {\n+        vectorCast(I2B, ISPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toB64\")\n+    public static void runI64toB64() throws Throwable {\n+        runCastHelper(I2B, ISPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toB64(byte[] input, byte[] output) {\n+        vectorCast(I2B, ISPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI128toB64\")\n+    public static void runI128toB64() throws Throwable {\n+        runCastHelper(I2B, ISPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toB64(byte[] input, byte[] output) {\n+        vectorCast(I2B, ISPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI256toB64\")\n+    public static void runI256toB64() throws Throwable {\n+        runCastHelper(I2B, ISPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI512toB128(byte[] input, byte[] output) {\n+        vectorCast(I2B, ISPEC512, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI512toB128\")\n+    public static void runI512toB128() throws Throwable {\n+        runCastHelper(I2B, ISPEC512, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toS64(byte[] input, byte[] output) {\n+        vectorCast(I2S, ISPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toS64\")\n+    public static void runI64toS64() throws Throwable {\n+        runCastHelper(I2S, ISPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toS64(byte[] input, byte[] output) {\n+        vectorCast(I2S, ISPEC128, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI128toS64\")\n+    public static void runI128toS64() throws Throwable {\n+        runCastHelper(I2S, ISPEC128, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toS128(byte[] input, byte[] output) {\n+        vectorCast(I2S, ISPEC256, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI256toS128\")\n+    public static void runI256toS128() throws Throwable {\n+        runCastHelper(I2S, ISPEC256, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI512toS256(byte[] input, byte[] output) {\n+        vectorCast(I2S, ISPEC512, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI512toS256\")\n+    public static void runI512toS256() throws Throwable {\n+        runCastHelper(I2S, ISPEC512, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toL64(byte[] input, byte[] output) {\n+        vectorCast(I2L, ISPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toL64\")\n+    public static void runI64toL64() throws Throwable {\n+        runCastHelper(I2L, ISPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toL128(byte[] input, byte[] output) {\n+        vectorCast(I2L, ISPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI64toL128\")\n+    public static void runI64toL128() throws Throwable {\n+        runCastHelper(I2L, ISPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toL256(byte[] input, byte[] output) {\n+        vectorCast(I2L, ISPEC128, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI128toL256\")\n+    public static void runI128toL256() throws Throwable {\n+        runCastHelper(I2L, ISPEC128, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toL512(byte[] input, byte[] output) {\n+        vectorCast(I2L, ISPEC256, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI256toL512\")\n+    public static void runI256toL512() throws Throwable {\n+        runCastHelper(I2L, ISPEC256, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toF64(byte[] input, byte[] output) {\n+        vectorCast(I2F, ISPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toF64\")\n+    public static void runI64toF64() throws Throwable {\n+        runCastHelper(I2F, ISPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toF128(byte[] input, byte[] output) {\n+        vectorCast(I2F, ISPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toF128\")\n+    public static void runI128toF128() throws Throwable {\n+        runCastHelper(I2F, ISPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toF256(byte[] input, byte[] output) {\n+        vectorCast(I2F, ISPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toF256\")\n+    public static void runI256toF256() throws Throwable {\n+        runCastHelper(I2F, ISPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI512toF512(byte[] input, byte[] output) {\n+        vectorCast(I2F, ISPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toF512\")\n+    public static void runI512toF512() throws Throwable {\n+        runCastHelper(I2F, ISPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toD64(byte[] input, byte[] output) {\n+        vectorCast(I2D, ISPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toD64\")\n+    public static void runI64toD64() throws Throwable {\n+        runCastHelper(I2D, ISPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toD128(byte[] input, byte[] output) {\n+        vectorCast(I2D, ISPEC64, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI64toD128\")\n+    public static void runI64toD128() throws Throwable {\n+        runCastHelper(I2D, ISPEC64, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toD256(byte[] input, byte[] output) {\n+        vectorCast(I2D, ISPEC128, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI128toD256\")\n+    public static void runI128toD256() throws Throwable {\n+        runCastHelper(I2D, ISPEC128, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toD512(byte[] input, byte[] output) {\n+        vectorCast(I2D, ISPEC256, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI256toD512\")\n+    public static void runI256toD512() throws Throwable {\n+        runCastHelper(I2D, ISPEC256, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toB64(byte[] input, byte[] output) {\n+        vectorCast(L2B, LSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toB64\")\n+    public static void runL64toB64() throws Throwable {\n+        runCastHelper(L2B, LSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toB64(byte[] input, byte[] output) {\n+        vectorCast(L2B, LSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL128toB64\")\n+    public static void runL128toB64() throws Throwable {\n+        runCastHelper(L2B, LSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toB64(byte[] input, byte[] output) {\n+        vectorCast(L2B, LSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL256toB64\")\n+    public static void runL256toB64() throws Throwable {\n+        runCastHelper(L2B, LSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toB64(byte[] input, byte[] output) {\n+        vectorCast(L2B, LSPEC512, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL512toB64\")\n+    public static void runL512toB64() throws Throwable {\n+        runCastHelper(L2B, LSPEC512, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toS64(byte[] input, byte[] output) {\n+        vectorCast(L2S, LSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toS64\")\n+    public static void runL64toS64() throws Throwable {\n+        runCastHelper(L2S, LSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toS64(byte[] input, byte[] output) {\n+        vectorCast(L2S, LSPEC128, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL128toS64\")\n+    public static void runL128toS64() throws Throwable {\n+        runCastHelper(L2S, LSPEC128, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toS64(byte[] input, byte[] output) {\n+        vectorCast(L2S, LSPEC256, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL256toS64\")\n+    public static void runL256toS64() throws Throwable {\n+        runCastHelper(L2S, LSPEC256, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toS128(byte[] input, byte[] output) {\n+        vectorCast(L2S, LSPEC512, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL512toS128\")\n+    public static void runL512toS128() throws Throwable {\n+        runCastHelper(L2S, LSPEC512, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toI64(byte[] input, byte[] output) {\n+        vectorCast(L2I, LSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toI64\")\n+    public static void runL64toI64() throws Throwable {\n+        runCastHelper(L2I, LSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toI64(byte[] input, byte[] output) {\n+        vectorCast(L2I, LSPEC128, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL128toI64\")\n+    public static void runL128toI64() throws Throwable {\n+        runCastHelper(L2I, LSPEC128, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toI128(byte[] input, byte[] output) {\n+        vectorCast(L2I, LSPEC256, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL256toI128\")\n+    public static void runL256toI128() throws Throwable {\n+        runCastHelper(L2I, LSPEC256, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toI256(byte[] input, byte[] output) {\n+        vectorCast(L2I, LSPEC512, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL512toI256\")\n+    public static void runL512toI256() throws Throwable {\n+        runCastHelper(L2I, LSPEC512, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toF64(byte[] input, byte[] output) {\n+        vectorCast(L2F, LSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toF64\")\n+    public static void runL64toF64() throws Throwable {\n+        runCastHelper(L2F, LSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toF64(byte[] input, byte[] output) {\n+        vectorCast(L2F, LSPEC128, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL128toF64\")\n+    public static void runL128toF64() throws Throwable {\n+        runCastHelper(L2F, LSPEC128, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toF128(byte[] input, byte[] output) {\n+        vectorCast(L2F, LSPEC256, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL256toF128\")\n+    public static void runL256toF128() throws Throwable {\n+        runCastHelper(L2F, LSPEC256, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toF256(byte[] input, byte[] output) {\n+        vectorCast(L2F, LSPEC512, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL512toF256\")\n+    public static void runL512toF256() throws Throwable {\n+        runCastHelper(L2F, LSPEC512, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toD64(byte[] input, byte[] output) {\n+        vectorCast(L2D, LSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toD64\")\n+    public static void runL64toD64() throws Throwable {\n+        runCastHelper(L2D, LSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toD128(byte[] input, byte[] output) {\n+        vectorCast(L2D, LSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toD128\")\n+    public static void runL128toD128() throws Throwable {\n+        runCastHelper(L2D, LSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toD256(byte[] input, byte[] output) {\n+        vectorCast(L2D, LSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toD256\")\n+    public static void runL256toD256() throws Throwable {\n+        runCastHelper(L2D, LSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toD512(byte[] input, byte[] output) {\n+        vectorCast(L2D, LSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toD512\")\n+    public static void runL512toD512() throws Throwable {\n+        runCastHelper(L2D, LSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toB64(byte[] input, byte[] output) {\n+        vectorCast(F2B, FSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toB64\")\n+    public static void runF64toB64() throws Throwable {\n+        runCastHelper(F2B, FSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toB64(byte[] input, byte[] output) {\n+        vectorCast(F2B, FSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF128toB64\")\n+    public static void runF128toB64() throws Throwable {\n+        runCastHelper(F2B, FSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toB64(byte[] input, byte[] output) {\n+        vectorCast(F2B, FSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF256toB64\")\n+    public static void runF256toB64() throws Throwable {\n+        runCastHelper(F2B, FSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF512toB128(byte[] input, byte[] output) {\n+        vectorCast(F2B, FSPEC512, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF512toB128\")\n+    public static void runF512toB128() throws Throwable {\n+        runCastHelper(F2B, FSPEC512, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toS64(byte[] input, byte[] output) {\n+        vectorCast(F2S, FSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toS64\")\n+    public static void runF64toS64() throws Throwable {\n+        runCastHelper(F2S, FSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toS64(byte[] input, byte[] output) {\n+        vectorCast(F2S, FSPEC128, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF128toS64\")\n+    public static void runF128toS64() throws Throwable {\n+        runCastHelper(F2S, FSPEC128, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toS128(byte[] input, byte[] output) {\n+        vectorCast(F2S, FSPEC256, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF256toS128\")\n+    public static void runF256toS128() throws Throwable {\n+        runCastHelper(F2S, FSPEC256, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF512toS256(byte[] input, byte[] output) {\n+        vectorCast(F2S, FSPEC512, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF512toS256\")\n+    public static void runF512toS256() throws Throwable {\n+        runCastHelper(F2S, FSPEC512, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toL64(byte[] input, byte[] output) {\n+        vectorCast(F2L, FSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toL64\")\n+    public static void runF64toL64() throws Throwable {\n+        runCastHelper(F2L, FSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toL128(byte[] input, byte[] output) {\n+        vectorCast(F2L, FSPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF64toL128\")\n+    public static void runF64toL128() throws Throwable {\n+        runCastHelper(F2L, FSPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toL256(byte[] input, byte[] output) {\n+        vectorCast(F2L, FSPEC128, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF128toL256\")\n+    public static void runF128toL256() throws Throwable {\n+        runCastHelper(F2L, FSPEC128, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toL512(byte[] input, byte[] output) {\n+        vectorCast(F2L, FSPEC256, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF256toL512\")\n+    public static void runF256toL512() throws Throwable {\n+        runCastHelper(F2L, FSPEC256, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toI64(byte[] input, byte[] output) {\n+        vectorCast(F2I, FSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toI64\")\n+    public static void runF64toI64() throws Throwable {\n+        runCastHelper(F2I, FSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toI128(byte[] input, byte[] output) {\n+        vectorCast(F2I, FSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toI128\")\n+    public static void runF128toI128() throws Throwable {\n+        runCastHelper(F2I, FSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toI256(byte[] input, byte[] output) {\n+        vectorCast(F2I, FSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toI256\")\n+    public static void runF256toI256() throws Throwable {\n+        runCastHelper(F2I, FSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF512toI512(byte[] input, byte[] output) {\n+        vectorCast(F2I, FSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toI512\")\n+    public static void runF512toI512() throws Throwable {\n+        runCastHelper(F2I, FSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toD64(byte[] input, byte[] output) {\n+        vectorCast(F2D, FSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toD64\")\n+    public static void runF64toD64() throws Throwable {\n+        runCastHelper(F2D, FSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toD128(byte[] input, byte[] output) {\n+        vectorCast(F2D, FSPEC64, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF64toD128\")\n+    public static void runF64toD128() throws Throwable {\n+        runCastHelper(F2D, FSPEC64, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toD256(byte[] input, byte[] output) {\n+        vectorCast(F2D, FSPEC128, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF128toD256\")\n+    public static void runF128toD256() throws Throwable {\n+        runCastHelper(F2D, FSPEC128, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toD512(byte[] input, byte[] output) {\n+        vectorCast(F2D, FSPEC256, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF256toD512\")\n+    public static void runF256toD512() throws Throwable {\n+        runCastHelper(F2D, FSPEC256, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toB64(byte[] input, byte[] output) {\n+        vectorCast(D2B, DSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toB64\")\n+    public static void runD64toB64() throws Throwable {\n+        runCastHelper(D2B, DSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toB64(byte[] input, byte[] output) {\n+        vectorCast(D2B, DSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD128toB64\")\n+    public static void runD128toB64() throws Throwable {\n+        runCastHelper(D2B, DSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toB64(byte[] input, byte[] output) {\n+        vectorCast(D2B, DSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD256toB64\")\n+    public static void runD256toB64() throws Throwable {\n+        runCastHelper(D2B, DSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toB64(byte[] input, byte[] output) {\n+        vectorCast(D2B, DSPEC512, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD512toB64\")\n+    public static void runD512toB64() throws Throwable {\n+        runCastHelper(D2B, DSPEC512, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toS64(byte[] input, byte[] output) {\n+        vectorCast(D2S, DSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toS64\")\n+    public static void runD64toS64() throws Throwable {\n+        runCastHelper(D2S, DSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toS64(byte[] input, byte[] output) {\n+        vectorCast(D2S, DSPEC128, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD128toS64\")\n+    public static void runD128toS64() throws Throwable {\n+        runCastHelper(D2S, DSPEC128, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toS64(byte[] input, byte[] output) {\n+        vectorCast(D2S, DSPEC256, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD256toS64\")\n+    public static void runD256toS64() throws Throwable {\n+        runCastHelper(D2S, DSPEC256, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toS128(byte[] input, byte[] output) {\n+        vectorCast(D2S, DSPEC512, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD512toS128\")\n+    public static void runD512toS128() throws Throwable {\n+        runCastHelper(D2S, DSPEC512, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toI64(byte[] input, byte[] output) {\n+        vectorCast(D2I, DSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toI64\")\n+    public static void runD64toI64() throws Throwable {\n+        runCastHelper(D2I, DSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toI64(byte[] input, byte[] output) {\n+        vectorCast(D2I, DSPEC128, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD128toI64\")\n+    public static void runD128toI64() throws Throwable {\n+        runCastHelper(D2I, DSPEC128, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toI128(byte[] input, byte[] output) {\n+        vectorCast(D2I, DSPEC256, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD256toI128\")\n+    public static void runD256toI128() throws Throwable {\n+        runCastHelper(D2I, DSPEC256, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toI256(byte[] input, byte[] output) {\n+        vectorCast(D2I, DSPEC512, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD512toI256\")\n+    public static void runD512toI256() throws Throwable {\n+        runCastHelper(D2I, DSPEC512, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toF64(byte[] input, byte[] output) {\n+        vectorCast(D2F, DSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toF64\")\n+    public static void runD64toF64() throws Throwable {\n+        runCastHelper(D2F, DSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toF64(byte[] input, byte[] output) {\n+        vectorCast(D2F, DSPEC128, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD128toF64\")\n+    public static void runD128toF64() throws Throwable {\n+        runCastHelper(D2F, DSPEC128, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toF128(byte[] input, byte[] output) {\n+        vectorCast(D2F, DSPEC256, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD256toF128\")\n+    public static void runD256toF128() throws Throwable {\n+        runCastHelper(D2F, DSPEC256, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toF256(byte[] input, byte[] output) {\n+        vectorCast(D2F, DSPEC512, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD512toF256\")\n+    public static void runD512toF256() throws Throwable {\n+        runCastHelper(D2F, DSPEC512, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toL64(byte[] input, byte[] output) {\n+        vectorCast(D2L, DSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toL64\")\n+    public static void runD64toL64() throws Throwable {\n+        runCastHelper(D2L, DSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toL128(byte[] input, byte[] output) {\n+        vectorCast(D2L, DSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toL128\")\n+    public static void runD128toL128() throws Throwable {\n+        runCastHelper(D2L, DSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toL256(byte[] input, byte[] output) {\n+        vectorCast(D2L, DSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toL256\")\n+    public static void runD256toL256() throws Throwable {\n+        runCastHelper(D2L, DSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toL512(byte[] input, byte[] output) {\n+        vectorCast(D2L, DSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toL512\")\n+    public static void runD512toL512() throws Throwable {\n+        runCastHelper(D2L, DSPEC512, LSPEC512);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorCast.java","additions":1359,"deletions":0,"binary":false,"changes":1359,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.tests;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+\n+\/**\n+ * As spot in 8259353. We need to do a shrink and an expand together to not accidentally\n+ * zero out elements in the physical registers that may not be zero in general cases.\n+ * In some methods, 2 consecutive ReinterpretNodes may be optimized out.\n+ *\/\n+public class TestVectorDoubleExpandShrink {\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB64toB128(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC64, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB128\")\n+    public static void runB64toB128() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC64, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB64toB256(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC64, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB256\")\n+    public static void runB64toB256() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC64, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB64toB512(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC64, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB512\")\n+    public static void runB64toB512() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC64, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB128toB64(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB64\")\n+    public static void runB128toB64() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB128toB256(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC128, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB256\")\n+    public static void runB128toB256() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC128, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB128toB512(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC128, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB512\")\n+    public static void runB128toB512() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC128, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB256toB64(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB64\")\n+    public static void runB256toB64() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB256toB128(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC256, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB128\")\n+    public static void runB256toB128() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC256, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB256toB512(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC256, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB512\")\n+    public static void runB256toB512() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC256, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB512toB64(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC512, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB64\")\n+    public static void runB512toB64() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC512, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB512toB128(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC512, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB128\")\n+    public static void runB512toB128() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC512, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB512toB256(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC512, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB256\")\n+    public static void runB512toB256() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC512, BSPEC256);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorDoubleExpandShrink.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.tests;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+\n+\/**\n+ *  This class contains method to ensure a resizing reinterpretation operations work as\n+ *  intended.\n+ *  In each test, the ReinterpretNode is expected to appear exactly once.\n+ *\/\n+public class TestVectorExpandShrink {\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toB128(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC64, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB128\")\n+    public static void runB64toB128() throws Throwable {\n+        runExpandShrinkHelper(BSPEC64, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toB256(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC64, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB256\")\n+    public static void runB64toB256() throws Throwable {\n+        runExpandShrinkHelper(BSPEC64, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toB512(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC64, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB512\")\n+    public static void runB64toB512() throws Throwable {\n+        runExpandShrinkHelper(BSPEC64, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toB64(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB64\")\n+    public static void runB128toB64() throws Throwable {\n+        runExpandShrinkHelper(BSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toB256(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC128, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB256\")\n+    public static void runB128toB256() throws Throwable {\n+        runExpandShrinkHelper(BSPEC128, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toB512(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC128, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB512\")\n+    public static void runB128toB512() throws Throwable {\n+        runExpandShrinkHelper(BSPEC128, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toB64(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB64\")\n+    public static void runB256toB64() throws Throwable {\n+        runExpandShrinkHelper(BSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toB128(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC256, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB128\")\n+    public static void runB256toB128() throws Throwable {\n+        runExpandShrinkHelper(BSPEC256, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toB512(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC256, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB512\")\n+    public static void runB256toB512() throws Throwable {\n+        runExpandShrinkHelper(BSPEC256, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toB64(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC512, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB64\")\n+    public static void runB512toB64() throws Throwable {\n+        runExpandShrinkHelper(BSPEC512, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toB128(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC512, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB128\")\n+    public static void runB512toB128() throws Throwable {\n+        runExpandShrinkHelper(BSPEC512, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toB256(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC512, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB256\")\n+    public static void runB512toB256() throws Throwable {\n+        runExpandShrinkHelper(BSPEC512, BSPEC256);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorExpandShrink.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,1360 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.tests;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+\n+\/**\n+ * This class contains methods to test for reinterpretation operations that reinterpret\n+ * a vector as a similar vector with another element type. It is complicated to verify\n+ * the IR in this case since a load\/store with respect to byte array will result in\n+ * additional ReinterpretNodes if the vector element type is not byte. As a result,\n+ * arguments need to be arrays of the correct type.\n+ * In each test, the ReinterpretNode is expected to appear exactly once.\n+ *\/\n+public class TestVectorRebracket {\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toS64(byte[] input, short[] output) {\n+        vectorRebracket(BSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toS64\")\n+    public static void runB64toS64() throws Throwable {\n+        runRebracketHelper(BSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toI64(byte[] input, int[] output) {\n+        vectorRebracket(BSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toI64\")\n+    public static void runB64toI64() throws Throwable {\n+        runRebracketHelper(BSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toL64(byte[] input, long[] output) {\n+        vectorRebracket(BSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL64\")\n+    public static void runB64toL64() throws Throwable {\n+        runRebracketHelper(BSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toF64(byte[] input, float[] output) {\n+        vectorRebracket(BSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toF64\")\n+    public static void runB64toF64() throws Throwable {\n+        runRebracketHelper(BSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toD64(byte[] input, double[] output) {\n+        vectorRebracket(BSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD64\")\n+    public static void runB64toD64() throws Throwable {\n+        runRebracketHelper(BSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toB64(short[] input, byte[] output) {\n+        vectorRebracket(SSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toB64\")\n+    public static void runS64toB64() throws Throwable {\n+        runRebracketHelper(SSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toI64(short[] input, int[] output) {\n+        vectorRebracket(SSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toI64\")\n+    public static void runS64toI64() throws Throwable {\n+        runRebracketHelper(SSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toL64(short[] input, long[] output) {\n+        vectorRebracket(SSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toL64\")\n+    public static void runS64toL64() throws Throwable {\n+        runRebracketHelper(SSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toF64(short[] input, float[] output) {\n+        vectorRebracket(SSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toF64\")\n+    public static void runS64toF64() throws Throwable {\n+        runRebracketHelper(SSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toD64(short[] input, double[] output) {\n+        vectorRebracket(SSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toD64\")\n+    public static void runS64toD64() throws Throwable {\n+        runRebracketHelper(SSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toB64(int[] input, byte[] output) {\n+        vectorRebracket(ISPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toB64\")\n+    public static void runI64toB64() throws Throwable {\n+        runRebracketHelper(ISPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toS64(int[] input, short[] output) {\n+        vectorRebracket(ISPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toS64\")\n+    public static void runI64toS64() throws Throwable {\n+        runRebracketHelper(ISPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toL64(int[] input, long[] output) {\n+        vectorRebracket(ISPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toL64\")\n+    public static void runI64toL64() throws Throwable {\n+        runRebracketHelper(ISPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toF64(int[] input, float[] output) {\n+        vectorRebracket(ISPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toF64\")\n+    public static void runI64toF64() throws Throwable {\n+        runRebracketHelper(ISPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toD64(int[] input, double[] output) {\n+        vectorRebracket(ISPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toD64\")\n+    public static void runI64toD64() throws Throwable {\n+        runRebracketHelper(ISPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toB64(long[] input, byte[] output) {\n+        vectorRebracket(LSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toB64\")\n+    public static void runL64toB64() throws Throwable {\n+        runRebracketHelper(LSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toS64(long[] input, short[] output) {\n+        vectorRebracket(LSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toS64\")\n+    public static void runL64toS64() throws Throwable {\n+        runRebracketHelper(LSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toI64(long[] input, int[] output) {\n+        vectorRebracket(LSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toI64\")\n+    public static void runL64toI64() throws Throwable {\n+        runRebracketHelper(LSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toF64(long[] input, float[] output) {\n+        vectorRebracket(LSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toF64\")\n+    public static void runL64toF64() throws Throwable {\n+        runRebracketHelper(LSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toD64(long[] input, double[] output) {\n+        vectorRebracket(LSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toD64\")\n+    public static void runL64toD64() throws Throwable {\n+        runRebracketHelper(LSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toB64(float[] input, byte[] output) {\n+        vectorRebracket(FSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toB64\")\n+    public static void runF64toB64() throws Throwable {\n+        runRebracketHelper(FSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toS64(float[] input, short[] output) {\n+        vectorRebracket(FSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toS64\")\n+    public static void runF64toS64() throws Throwable {\n+        runRebracketHelper(FSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toI64(float[] input, int[] output) {\n+        vectorRebracket(FSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toI64\")\n+    public static void runF64toI64() throws Throwable {\n+        runRebracketHelper(FSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toL64(float[] input, long[] output) {\n+        vectorRebracket(FSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toL64\")\n+    public static void runF64toL64() throws Throwable {\n+        runRebracketHelper(FSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toD64(float[] input, double[] output) {\n+        vectorRebracket(FSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toD64\")\n+    public static void runF64toD64() throws Throwable {\n+        runRebracketHelper(FSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toB64(double[] input, byte[] output) {\n+        vectorRebracket(DSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toB64\")\n+    public static void runD64toB64() throws Throwable {\n+        runRebracketHelper(DSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toS64(double[] input, short[] output) {\n+        vectorRebracket(DSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toS64\")\n+    public static void runD64toS64() throws Throwable {\n+        runRebracketHelper(DSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toI64(double[] input, int[] output) {\n+        vectorRebracket(DSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toI64\")\n+    public static void runD64toI64() throws Throwable {\n+        runRebracketHelper(DSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toL64(double[] input, long[] output) {\n+        vectorRebracket(DSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toL64\")\n+    public static void runD64toL64() throws Throwable {\n+        runRebracketHelper(DSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toF64(double[] input, float[] output) {\n+        vectorRebracket(DSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toF64\")\n+    public static void runD64toF64() throws Throwable {\n+        runRebracketHelper(DSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toS128(byte[] input, short[] output) {\n+        vectorRebracket(BSPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toS128\")\n+    public static void runB128toS128() throws Throwable {\n+        runRebracketHelper(BSPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toI128(byte[] input, int[] output) {\n+        vectorRebracket(BSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toI128\")\n+    public static void runB128toI128() throws Throwable {\n+        runRebracketHelper(BSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toL128(byte[] input, long[] output) {\n+        vectorRebracket(BSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toL128\")\n+    public static void runB128toL128() throws Throwable {\n+        runRebracketHelper(BSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toF128(byte[] input, float[] output) {\n+        vectorRebracket(BSPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toF128\")\n+    public static void runB128toF128() throws Throwable {\n+        runRebracketHelper(BSPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toD128(byte[] input, double[] output) {\n+        vectorRebracket(BSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toD128\")\n+    public static void runB128toD128() throws Throwable {\n+        runRebracketHelper(BSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toB128(short[] input, byte[] output) {\n+        vectorRebracket(SSPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toB128\")\n+    public static void runS128toB128() throws Throwable {\n+        runRebracketHelper(SSPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toI128(short[] input, int[] output) {\n+        vectorRebracket(SSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toI128\")\n+    public static void runS128toI128() throws Throwable {\n+        runRebracketHelper(SSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toL128(short[] input, long[] output) {\n+        vectorRebracket(SSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toL128\")\n+    public static void runS128toL128() throws Throwable {\n+        runRebracketHelper(SSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toF128(short[] input, float[] output) {\n+        vectorRebracket(SSPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toF128\")\n+    public static void runS128toF128() throws Throwable {\n+        runRebracketHelper(SSPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toD128(short[] input, double[] output) {\n+        vectorRebracket(SSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toD128\")\n+    public static void runS128toD128() throws Throwable {\n+        runRebracketHelper(SSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toB128(int[] input, byte[] output) {\n+        vectorRebracket(ISPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toB128\")\n+    public static void runI128toB128() throws Throwable {\n+        runRebracketHelper(ISPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toS128(int[] input, short[] output) {\n+        vectorRebracket(ISPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toS128\")\n+    public static void runI128toS128() throws Throwable {\n+        runRebracketHelper(ISPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toL128(int[] input, long[] output) {\n+        vectorRebracket(ISPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toL128\")\n+    public static void runI128toL128() throws Throwable {\n+        runRebracketHelper(ISPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toF128(int[] input, float[] output) {\n+        vectorRebracket(ISPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toF128\")\n+    public static void runI128toF128() throws Throwable {\n+        runRebracketHelper(ISPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toD128(int[] input, double[] output) {\n+        vectorRebracket(ISPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toD128\")\n+    public static void runI128toD128() throws Throwable {\n+        runRebracketHelper(ISPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toB128(long[] input, byte[] output) {\n+        vectorRebracket(LSPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toB128\")\n+    public static void runL128toB128() throws Throwable {\n+        runRebracketHelper(LSPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toS128(long[] input, short[] output) {\n+        vectorRebracket(LSPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toS128\")\n+    public static void runL128toS128() throws Throwable {\n+        runRebracketHelper(LSPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toI128(long[] input, int[] output) {\n+        vectorRebracket(LSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toI128\")\n+    public static void runL128toI128() throws Throwable {\n+        runRebracketHelper(LSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toF128(long[] input, float[] output) {\n+        vectorRebracket(LSPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toF128\")\n+    public static void runL128toF128() throws Throwable {\n+        runRebracketHelper(LSPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toD128(long[] input, double[] output) {\n+        vectorRebracket(LSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toD128\")\n+    public static void runL128toD128() throws Throwable {\n+        runRebracketHelper(LSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toB128(float[] input, byte[] output) {\n+        vectorRebracket(FSPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toB128\")\n+    public static void runF128toB128() throws Throwable {\n+        runRebracketHelper(FSPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toS128(float[] input, short[] output) {\n+        vectorRebracket(FSPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toS128\")\n+    public static void runF128toS128() throws Throwable {\n+        runRebracketHelper(FSPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toI128(float[] input, int[] output) {\n+        vectorRebracket(FSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toI128\")\n+    public static void runF128toI128() throws Throwable {\n+        runRebracketHelper(FSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toL128(float[] input, long[] output) {\n+        vectorRebracket(FSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toL128\")\n+    public static void runF128toL128() throws Throwable {\n+        runRebracketHelper(FSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toD128(float[] input, double[] output) {\n+        vectorRebracket(FSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toD128\")\n+    public static void runF128toD128() throws Throwable {\n+        runRebracketHelper(FSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toB128(double[] input, byte[] output) {\n+        vectorRebracket(DSPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toB128\")\n+    public static void runD128toB128() throws Throwable {\n+        runRebracketHelper(DSPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toS128(double[] input, short[] output) {\n+        vectorRebracket(DSPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toS128\")\n+    public static void runD128toS128() throws Throwable {\n+        runRebracketHelper(DSPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toI128(double[] input, int[] output) {\n+        vectorRebracket(DSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toI128\")\n+    public static void runD128toI128() throws Throwable {\n+        runRebracketHelper(DSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toL128(double[] input, long[] output) {\n+        vectorRebracket(DSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toL128\")\n+    public static void runD128toL128() throws Throwable {\n+        runRebracketHelper(DSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toF128(double[] input, float[] output) {\n+        vectorRebracket(DSPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toF128\")\n+    public static void runD128toF128() throws Throwable {\n+        runRebracketHelper(DSPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toS256(byte[] input, short[] output) {\n+        vectorRebracket(BSPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toS256\")\n+    public static void runB256toS256() throws Throwable {\n+        runRebracketHelper(BSPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toI256(byte[] input, int[] output) {\n+        vectorRebracket(BSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toI256\")\n+    public static void runB256toI256() throws Throwable {\n+        runRebracketHelper(BSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toL256(byte[] input, long[] output) {\n+        vectorRebracket(BSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toL256\")\n+    public static void runB256toL256() throws Throwable {\n+        runRebracketHelper(BSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toF256(byte[] input, float[] output) {\n+        vectorRebracket(BSPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toF256\")\n+    public static void runB256toF256() throws Throwable {\n+        runRebracketHelper(BSPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toD256(byte[] input, double[] output) {\n+        vectorRebracket(BSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toD256\")\n+    public static void runB256toD256() throws Throwable {\n+        runRebracketHelper(BSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toB256(short[] input, byte[] output) {\n+        vectorRebracket(SSPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toB256\")\n+    public static void runS256toB256() throws Throwable {\n+        runRebracketHelper(SSPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toI256(short[] input, int[] output) {\n+        vectorRebracket(SSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toI256\")\n+    public static void runS256toI256() throws Throwable {\n+        runRebracketHelper(SSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toL256(short[] input, long[] output) {\n+        vectorRebracket(SSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toL256\")\n+    public static void runS256toL256() throws Throwable {\n+        runRebracketHelper(SSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toF256(short[] input, float[] output) {\n+        vectorRebracket(SSPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toF256\")\n+    public static void runS256toF256() throws Throwable {\n+        runRebracketHelper(SSPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toD256(short[] input, double[] output) {\n+        vectorRebracket(SSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toD256\")\n+    public static void runS256toD256() throws Throwable {\n+        runRebracketHelper(SSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toB256(int[] input, byte[] output) {\n+        vectorRebracket(ISPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toB256\")\n+    public static void runI256toB256() throws Throwable {\n+        runRebracketHelper(ISPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toS256(int[] input, short[] output) {\n+        vectorRebracket(ISPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toS256\")\n+    public static void runI256toS256() throws Throwable {\n+        runRebracketHelper(ISPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toL256(int[] input, long[] output) {\n+        vectorRebracket(ISPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toL256\")\n+    public static void runI256toL256() throws Throwable {\n+        runRebracketHelper(ISPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toF256(int[] input, float[] output) {\n+        vectorRebracket(ISPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toF256\")\n+    public static void runI256toF256() throws Throwable {\n+        runRebracketHelper(ISPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toD256(int[] input, double[] output) {\n+        vectorRebracket(ISPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toD256\")\n+    public static void runI256toD256() throws Throwable {\n+        runRebracketHelper(ISPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toB256(long[] input, byte[] output) {\n+        vectorRebracket(LSPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toB256\")\n+    public static void runL256toB256() throws Throwable {\n+        runRebracketHelper(LSPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toS256(long[] input, short[] output) {\n+        vectorRebracket(LSPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toS256\")\n+    public static void runL256toS256() throws Throwable {\n+        runRebracketHelper(LSPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toI256(long[] input, int[] output) {\n+        vectorRebracket(LSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toI256\")\n+    public static void runL256toI256() throws Throwable {\n+        runRebracketHelper(LSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toF256(long[] input, float[] output) {\n+        vectorRebracket(LSPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toF256\")\n+    public static void runL256toF256() throws Throwable {\n+        runRebracketHelper(LSPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toD256(long[] input, double[] output) {\n+        vectorRebracket(LSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toD256\")\n+    public static void runL256toD256() throws Throwable {\n+        runRebracketHelper(LSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toB256(float[] input, byte[] output) {\n+        vectorRebracket(FSPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toB256\")\n+    public static void runF256toB256() throws Throwable {\n+        runRebracketHelper(FSPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toS256(float[] input, short[] output) {\n+        vectorRebracket(FSPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toS256\")\n+    public static void runF256toS256() throws Throwable {\n+        runRebracketHelper(FSPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toI256(float[] input, int[] output) {\n+        vectorRebracket(FSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toI256\")\n+    public static void runF256toI256() throws Throwable {\n+        runRebracketHelper(FSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toL256(float[] input, long[] output) {\n+        vectorRebracket(FSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toL256\")\n+    public static void runF256toL256() throws Throwable {\n+        runRebracketHelper(FSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toD256(float[] input, double[] output) {\n+        vectorRebracket(FSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toD256\")\n+    public static void runF256toD256() throws Throwable {\n+        runRebracketHelper(FSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toB256(double[] input, byte[] output) {\n+        vectorRebracket(DSPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toB256\")\n+    public static void runD256toB256() throws Throwable {\n+        runRebracketHelper(DSPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toS256(double[] input, short[] output) {\n+        vectorRebracket(DSPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toS256\")\n+    public static void runD256toS256() throws Throwable {\n+        runRebracketHelper(DSPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toI256(double[] input, int[] output) {\n+        vectorRebracket(DSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toI256\")\n+    public static void runD256toI256() throws Throwable {\n+        runRebracketHelper(DSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toL256(double[] input, long[] output) {\n+        vectorRebracket(DSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toL256\")\n+    public static void runD256toL256() throws Throwable {\n+        runRebracketHelper(DSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toF256(double[] input, float[] output) {\n+        vectorRebracket(DSPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toF256\")\n+    public static void runD256toF256() throws Throwable {\n+        runRebracketHelper(DSPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toS512(byte[] input, short[] output) {\n+        vectorRebracket(BSPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toS512\")\n+    public static void runB512toS512() throws Throwable {\n+        runRebracketHelper(BSPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toI512(byte[] input, int[] output) {\n+        vectorRebracket(BSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toI512\")\n+    public static void runB512toI512() throws Throwable {\n+        runRebracketHelper(BSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toL512(byte[] input, long[] output) {\n+        vectorRebracket(BSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toL512\")\n+    public static void runB512toL512() throws Throwable {\n+        runRebracketHelper(BSPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toF512(byte[] input, float[] output) {\n+        vectorRebracket(BSPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toF512\")\n+    public static void runB512toF512() throws Throwable {\n+        runRebracketHelper(BSPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toD512(byte[] input, double[] output) {\n+        vectorRebracket(BSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toD512\")\n+    public static void runB512toD512() throws Throwable {\n+        runRebracketHelper(BSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toB512(short[] input, byte[] output) {\n+        vectorRebracket(SSPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toB512\")\n+    public static void runS512toB512() throws Throwable {\n+        runRebracketHelper(SSPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toI512(short[] input, int[] output) {\n+        vectorRebracket(SSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toI512\")\n+    public static void runS512toI512() throws Throwable {\n+        runRebracketHelper(SSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toL512(short[] input, long[] output) {\n+        vectorRebracket(SSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toL512\")\n+    public static void runS512toL512() throws Throwable {\n+        runRebracketHelper(SSPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toF512(short[] input, float[] output) {\n+        vectorRebracket(SSPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toF512\")\n+    public static void runS512toF512() throws Throwable {\n+        runRebracketHelper(SSPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toD512(short[] input, double[] output) {\n+        vectorRebracket(SSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toD512\")\n+    public static void runS512toD512() throws Throwable {\n+        runRebracketHelper(SSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toB512(int[] input, byte[] output) {\n+        vectorRebracket(ISPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toB512\")\n+    public static void runI512toB512() throws Throwable {\n+        runRebracketHelper(ISPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toS512(int[] input, short[] output) {\n+        vectorRebracket(ISPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toS512\")\n+    public static void runI512toS512() throws Throwable {\n+        runRebracketHelper(ISPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toL512(int[] input, long[] output) {\n+        vectorRebracket(ISPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toL512\")\n+    public static void runI512toL512() throws Throwable {\n+        runRebracketHelper(ISPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toF512(int[] input, float[] output) {\n+        vectorRebracket(ISPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toF512\")\n+    public static void runI512toF512() throws Throwable {\n+        runRebracketHelper(ISPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toD512(int[] input, double[] output) {\n+        vectorRebracket(ISPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toD512\")\n+    public static void runI512toD512() throws Throwable {\n+        runRebracketHelper(ISPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toB512(long[] input, byte[] output) {\n+        vectorRebracket(LSPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toB512\")\n+    public static void runL512toB512() throws Throwable {\n+        runRebracketHelper(LSPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toS512(long[] input, short[] output) {\n+        vectorRebracket(LSPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toS512\")\n+    public static void runL512toS512() throws Throwable {\n+        runRebracketHelper(LSPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toI512(long[] input, int[] output) {\n+        vectorRebracket(LSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toI512\")\n+    public static void runL512toI512() throws Throwable {\n+        runRebracketHelper(LSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toF512(long[] input, float[] output) {\n+        vectorRebracket(LSPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toF512\")\n+    public static void runL512toF512() throws Throwable {\n+        runRebracketHelper(LSPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toD512(long[] input, double[] output) {\n+        vectorRebracket(LSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toD512\")\n+    public static void runL512toD512() throws Throwable {\n+        runRebracketHelper(LSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toB512(float[] input, byte[] output) {\n+        vectorRebracket(FSPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toB512\")\n+    public static void runF512toB512() throws Throwable {\n+        runRebracketHelper(FSPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toS512(float[] input, short[] output) {\n+        vectorRebracket(FSPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toS512\")\n+    public static void runF512toS512() throws Throwable {\n+        runRebracketHelper(FSPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toI512(float[] input, int[] output) {\n+        vectorRebracket(FSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toI512\")\n+    public static void runF512toI512() throws Throwable {\n+        runRebracketHelper(FSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toL512(float[] input, long[] output) {\n+        vectorRebracket(FSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toL512\")\n+    public static void runF512toL512() throws Throwable {\n+        runRebracketHelper(FSPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toD512(float[] input, double[] output) {\n+        vectorRebracket(FSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toD512\")\n+    public static void runF512toD512() throws Throwable {\n+        runRebracketHelper(FSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toB512(double[] input, byte[] output) {\n+        vectorRebracket(DSPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toB512\")\n+    public static void runD512toB512() throws Throwable {\n+        runRebracketHelper(DSPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toS512(double[] input, short[] output) {\n+        vectorRebracket(DSPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toS512\")\n+    public static void runD512toS512() throws Throwable {\n+        runRebracketHelper(DSPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toI512(double[] input, int[] output) {\n+        vectorRebracket(DSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toI512\")\n+    public static void runD512toI512() throws Throwable {\n+        runRebracketHelper(DSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toL512(double[] input, long[] output) {\n+        vectorRebracket(DSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toL512\")\n+    public static void runD512toL512() throws Throwable {\n+        runRebracketHelper(DSPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toF512(double[] input, float[] output) {\n+        vectorRebracket(DSPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toF512\")\n+    public static void runD512toF512() throws Throwable {\n+        runRebracketHelper(DSPEC512, FSPEC512);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorRebracket.java","additions":1360,"deletions":0,"binary":false,"changes":1360,"status":"added"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.utils;\n+\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+import static compiler.vectorapi.reshape.utils.VectorSpeciesPair.makePair;\n+\n+\/**\n+ * The cast intrinsics implemented on each platform, commented out tests are the ones that are\n+ * supposed to work but currently don't.\n+ *\/\n+public class TestCastMethods {\n+    public static final List<VectorSpeciesPair> AVX1_CAST_TESTS = List.of(\n+            makePair(BSPEC64, SSPEC64),\n+            makePair(BSPEC64, SSPEC128),\n+            makePair(BSPEC64, ISPEC128),\n+            makePair(BSPEC64, FSPEC128),\n+            \/\/ makePair(BSPEC64, DSPEC256),\n+            makePair(SSPEC64, BSPEC64),\n+            makePair(SSPEC128, BSPEC64),\n+            makePair(SSPEC64, ISPEC64),\n+            makePair(SSPEC64, ISPEC128),\n+            makePair(SSPEC64, LSPEC128),\n+            makePair(SSPEC64, FSPEC64),\n+            makePair(SSPEC64, FSPEC128),\n+            makePair(SSPEC64, DSPEC128),\n+            \/\/ makePair(SSPEC64, DSPEC256),\n+            makePair(ISPEC128, BSPEC64),\n+            makePair(ISPEC64, SSPEC64),\n+            makePair(ISPEC128, SSPEC64),\n+            makePair(ISPEC64, LSPEC128),\n+            makePair(ISPEC64, FSPEC64),\n+            makePair(ISPEC128, FSPEC128),\n+            makePair(ISPEC64, DSPEC128),\n+            makePair(ISPEC128, DSPEC256),\n+            makePair(LSPEC128, SSPEC64),\n+            makePair(LSPEC128, ISPEC64),\n+            makePair(FSPEC64, ISPEC64),\n+            makePair(FSPEC128, ISPEC128),\n+            makePair(FSPEC64, DSPEC128),\n+            makePair(FSPEC128, DSPEC256),\n+            makePair(DSPEC128, FSPEC64)\n+            \/\/ makePair(DSPEC256, FSPEC128)\n+    );\n+\n+    public static final List<VectorSpeciesPair> AVX2_CAST_TESTS = Stream.concat(AVX1_CAST_TESTS.stream(), List.of(\n+            makePair(BSPEC128, SSPEC256),\n+            makePair(BSPEC64, ISPEC256),\n+            makePair(BSPEC64, LSPEC256),\n+            makePair(BSPEC64, FSPEC256),\n+            makePair(SSPEC256, BSPEC128),\n+            makePair(SSPEC128, ISPEC256),\n+            makePair(SSPEC64, LSPEC256),\n+            makePair(SSPEC128, FSPEC256),\n+            makePair(ISPEC256, BSPEC64),\n+            makePair(ISPEC256, SSPEC128),\n+            makePair(ISPEC128, LSPEC256),\n+            makePair(ISPEC256, FSPEC256),\n+            makePair(LSPEC256, BSPEC64),\n+            makePair(LSPEC256, SSPEC64),\n+            makePair(LSPEC256, ISPEC128),\n+            makePair(FSPEC256, ISPEC256)\n+    ).stream()).toList();\n+\n+    public static final List<VectorSpeciesPair> AVX512_CAST_TESTS = Stream.concat(AVX2_CAST_TESTS.stream(), List.of(\n+            makePair(BSPEC256, SSPEC512),\n+            makePair(BSPEC128, ISPEC512),\n+            makePair(BSPEC64, LSPEC512),\n+            makePair(BSPEC128, FSPEC512),\n+            makePair(BSPEC64, DSPEC512),\n+            makePair(SSPEC512, BSPEC256),\n+            makePair(SSPEC256, ISPEC512),\n+            makePair(SSPEC128, LSPEC512),\n+            makePair(SSPEC256, FSPEC512),\n+            makePair(SSPEC128, DSPEC512),\n+            makePair(ISPEC512, BSPEC128),\n+            makePair(ISPEC512, SSPEC256),\n+            makePair(ISPEC256, LSPEC512),\n+            makePair(ISPEC512, FSPEC512),\n+            makePair(ISPEC256, DSPEC512),\n+            makePair(LSPEC512, BSPEC64),\n+            makePair(LSPEC512, SSPEC128),\n+            makePair(LSPEC512, ISPEC256),\n+            makePair(FSPEC512, ISPEC512),\n+            makePair(FSPEC256, DSPEC512),\n+            makePair(DSPEC512, FSPEC256)\n+    ).stream()).toList();\n+\n+    public static final List<VectorSpeciesPair> AVX512DQ_CAST_TESTS = Stream.concat(AVX512_CAST_TESTS.stream(), List.of(\n+            makePair(LSPEC128, DSPEC128),\n+            makePair(LSPEC256, DSPEC256),\n+            makePair(LSPEC512, DSPEC512),\n+            makePair(DSPEC128, LSPEC128),\n+            makePair(DSPEC256, LSPEC256),\n+            makePair(DSPEC512, LSPEC512)\n+    ).stream()).toList();\n+\n+    public static final List<VectorSpeciesPair> SVE_CAST_TESTS = List.of(\n+            makePair(BSPEC64, SSPEC128),\n+            makePair(BSPEC128, SSPEC256),\n+            makePair(BSPEC256, SSPEC512),\n+            makePair(BSPEC64, ISPEC256),\n+            makePair(BSPEC128, ISPEC512),\n+            makePair(BSPEC64, LSPEC512),\n+            makePair(BSPEC64, FSPEC256),\n+            makePair(BSPEC128, FSPEC512),\n+            makePair(BSPEC64, DSPEC512),\n+            makePair(SSPEC128, BSPEC64),\n+            makePair(SSPEC256, BSPEC128),\n+            makePair(SSPEC512, BSPEC256),\n+            makePair(SSPEC64, ISPEC128),\n+            makePair(SSPEC128, ISPEC256),\n+            makePair(SSPEC256, ISPEC512),\n+            makePair(SSPEC64, LSPEC256),\n+            makePair(SSPEC128, LSPEC512),\n+            makePair(SSPEC64, FSPEC128),\n+            makePair(SSPEC128, FSPEC256),\n+            makePair(SSPEC256, FSPEC512),\n+            makePair(SSPEC64, DSPEC256),\n+            makePair(SSPEC128, DSPEC512),\n+            makePair(ISPEC256, BSPEC64),\n+            makePair(ISPEC512, BSPEC128),\n+            makePair(ISPEC128, SSPEC64),\n+            makePair(ISPEC256, SSPEC128),\n+            makePair(ISPEC512, SSPEC256),\n+            makePair(ISPEC64, LSPEC128),\n+            makePair(ISPEC128, LSPEC256),\n+            makePair(ISPEC256, LSPEC512),\n+            makePair(ISPEC64, FSPEC64),\n+            makePair(ISPEC128, FSPEC128),\n+            makePair(ISPEC256, FSPEC256),\n+            makePair(ISPEC512, FSPEC512),\n+            makePair(ISPEC64, DSPEC128),\n+            makePair(ISPEC128, DSPEC256),\n+            makePair(ISPEC256, DSPEC512),\n+            makePair(LSPEC512, BSPEC64),\n+            makePair(LSPEC256, SSPEC64),\n+            makePair(LSPEC512, SSPEC128),\n+            makePair(LSPEC128, ISPEC64),\n+            makePair(LSPEC256, ISPEC128),\n+            makePair(LSPEC512, ISPEC256),\n+            makePair(LSPEC128, FSPEC64),\n+            makePair(LSPEC256, FSPEC128),\n+            makePair(LSPEC512, FSPEC256),\n+            makePair(LSPEC128, DSPEC128),\n+            makePair(LSPEC256, DSPEC256),\n+            makePair(LSPEC512, DSPEC512),\n+            makePair(FSPEC256, BSPEC64),\n+            makePair(FSPEC512, BSPEC128),\n+            makePair(FSPEC128, SSPEC64),\n+            makePair(FSPEC256, SSPEC128),\n+            makePair(FSPEC512, SSPEC256),\n+            makePair(FSPEC64, ISPEC64),\n+            makePair(FSPEC128, ISPEC128),\n+            makePair(FSPEC256, ISPEC256),\n+            makePair(FSPEC512, ISPEC512),\n+            makePair(FSPEC64, LSPEC128),\n+            makePair(FSPEC128, LSPEC256),\n+            makePair(FSPEC256, LSPEC512),\n+            makePair(FSPEC64, DSPEC128),\n+            makePair(FSPEC128, DSPEC256),\n+            makePair(FSPEC256, DSPEC512),\n+            makePair(DSPEC512, BSPEC64),\n+            makePair(DSPEC256, SSPEC64),\n+            makePair(DSPEC512, SSPEC128),\n+            makePair(DSPEC128, ISPEC64),\n+            makePair(DSPEC256, ISPEC128),\n+            makePair(DSPEC512, ISPEC256),\n+            makePair(DSPEC128, LSPEC128),\n+            makePair(DSPEC256, LSPEC256),\n+            makePair(DSPEC512, LSPEC512),\n+            makePair(DSPEC128, FSPEC64),\n+            makePair(DSPEC256, FSPEC128),\n+            makePair(DSPEC512, FSPEC256)\n+    );\n+\n+    public static final List<VectorSpeciesPair> NEON_CAST_TESTS = List.of(\n+            makePair(BSPEC64, SSPEC64),\n+            makePair(BSPEC64, SSPEC128),\n+            makePair(BSPEC64, ISPEC128),\n+            makePair(BSPEC64, FSPEC128),\n+            makePair(SSPEC64, BSPEC64),\n+            makePair(SSPEC128, BSPEC64),\n+            makePair(SSPEC64, ISPEC128),\n+            makePair(SSPEC64, FSPEC128),\n+            makePair(ISPEC128, BSPEC64),\n+            makePair(ISPEC128, SSPEC64),\n+            makePair(ISPEC64, LSPEC128),\n+            makePair(ISPEC64, FSPEC64),\n+            makePair(ISPEC128, FSPEC128),\n+            makePair(ISPEC64, DSPEC128),\n+            makePair(LSPEC128, ISPEC64),\n+            makePair(LSPEC128, FSPEC64),\n+            makePair(LSPEC128, DSPEC128),\n+            makePair(FSPEC128, BSPEC64),\n+            makePair(FSPEC128, SSPEC64),\n+            makePair(FSPEC64, ISPEC64),\n+            makePair(FSPEC128, ISPEC128),\n+            makePair(FSPEC64, LSPEC128),\n+            makePair(FSPEC64, DSPEC128),\n+            makePair(DSPEC128, ISPEC64),\n+            makePair(DSPEC128, LSPEC128),\n+            makePair(DSPEC128, FSPEC64)\n+    );\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.utils;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+\/**\n+ * Unsafe to check for correctness of reinterpret operations. May be replaced with foreign API later.\n+ *\/\n+public class UnsafeUtils {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static long arrayBase(Class<?> etype) {\n+        return UNSAFE.arrayBaseOffset(etype.arrayType());\n+    }\n+\n+    public static int getByte(Object o, long base, int i) {\n+        \/\/ This is technically an UB, what we need is UNSAFE.getByteUnaligned but they seem to be equivalent\n+        return UNSAFE.getByte(o, base + i);\n+    }\n+\n+    public static void putByte(Object o, long base, int i, int value) {\n+        UNSAFE.putByte(o, base + i, (byte)value);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/UnsafeUtils.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,372 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.utils;\n+\n+import compiler.lib.ir_framework.ForceInline;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.TestFramework;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Array;\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.random.RandomGenerator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+public class VectorReshapeHelper {\n+    public static final int INVOCATIONS = 10_000;\n+\n+    public static final VectorSpecies<Byte>    BSPEC64  =   ByteVector.SPECIES_64;\n+    public static final VectorSpecies<Short>   SSPEC64  =  ShortVector.SPECIES_64;\n+    public static final VectorSpecies<Integer> ISPEC64  =    IntVector.SPECIES_64;\n+    public static final VectorSpecies<Long>    LSPEC64  =   LongVector.SPECIES_64;\n+    public static final VectorSpecies<Float>   FSPEC64  =  FloatVector.SPECIES_64;\n+    public static final VectorSpecies<Double>  DSPEC64  = DoubleVector.SPECIES_64;\n+\n+    public static final VectorSpecies<Byte>    BSPEC128 =   ByteVector.SPECIES_128;\n+    public static final VectorSpecies<Short>   SSPEC128 =  ShortVector.SPECIES_128;\n+    public static final VectorSpecies<Integer> ISPEC128 =    IntVector.SPECIES_128;\n+    public static final VectorSpecies<Long>    LSPEC128 =   LongVector.SPECIES_128;\n+    public static final VectorSpecies<Float>   FSPEC128 =  FloatVector.SPECIES_128;\n+    public static final VectorSpecies<Double>  DSPEC128 = DoubleVector.SPECIES_128;\n+\n+    public static final VectorSpecies<Byte>    BSPEC256 =   ByteVector.SPECIES_256;\n+    public static final VectorSpecies<Short>   SSPEC256 =  ShortVector.SPECIES_256;\n+    public static final VectorSpecies<Integer> ISPEC256 =    IntVector.SPECIES_256;\n+    public static final VectorSpecies<Long>    LSPEC256 =   LongVector.SPECIES_256;\n+    public static final VectorSpecies<Float>   FSPEC256 =  FloatVector.SPECIES_256;\n+    public static final VectorSpecies<Double>  DSPEC256 = DoubleVector.SPECIES_256;\n+\n+    public static final VectorSpecies<Byte>    BSPEC512 =   ByteVector.SPECIES_512;\n+    public static final VectorSpecies<Short>   SSPEC512 =  ShortVector.SPECIES_512;\n+    public static final VectorSpecies<Integer> ISPEC512 =    IntVector.SPECIES_512;\n+    public static final VectorSpecies<Long>    LSPEC512 =   LongVector.SPECIES_512;\n+    public static final VectorSpecies<Float>   FSPEC512 =  FloatVector.SPECIES_512;\n+    public static final VectorSpecies<Double>  DSPEC512 = DoubleVector.SPECIES_512;\n+\n+    public static final String B2X_NODE  = IRNode.VECTOR_CAST_B2X;\n+    public static final String S2X_NODE  = IRNode.VECTOR_CAST_S2X;\n+    public static final String I2X_NODE  = IRNode.VECTOR_CAST_I2X;\n+    public static final String L2X_NODE  = IRNode.VECTOR_CAST_L2X;\n+    public static final String F2X_NODE  = IRNode.VECTOR_CAST_F2X;\n+    public static final String D2X_NODE  = IRNode.VECTOR_CAST_D2X;\n+    public static final String REINTERPRET_NODE = IRNode.VECTOR_REINTERPRET;\n+\n+    public static void runMainHelper(Class<?> testClass, Stream<VectorSpeciesPair> testMethods, String... flags) {\n+        var test = new TestFramework(testClass);\n+        test.setDefaultWarmup(1);\n+        test.addHelperClasses(VectorReshapeHelper.class);\n+        test.addFlags(\"--add-modules=jdk.incubator.vector\");\n+        test.addFlags(flags);\n+        String testMethodNames = testMethods\n+                .filter(p -> p.isp().length() <= VectorSpecies.ofLargestShape(p.isp().elementType()).length())\n+                .filter(p -> p.osp().length() <= VectorSpecies.ofLargestShape(p.osp().elementType()).length())\n+                .map(VectorSpeciesPair::format)\n+                .collect(Collectors.joining(\",\"));\n+        test.addFlags(\"-DTest=\" + testMethodNames);\n+        test.start();\n+    }\n+\n+    @ForceInline\n+    public static <T, U> void vectorCast(VectorOperators.Conversion<T, U> cop,\n+                                         VectorSpecies<T> isp, VectorSpecies<U> osp, byte[] input, byte[] output) {\n+        isp.fromByteArray(input, 0, ByteOrder.nativeOrder())\n+                .convertShape(cop, osp, 0)\n+                .intoByteArray(output, 0, ByteOrder.nativeOrder());\n+    }\n+\n+    public static <T, U> void runCastHelper(VectorOperators.Conversion<T, U> castOp,\n+                                            VectorSpecies<T> isp, VectorSpecies<U> osp) throws Throwable {\n+        var random = RandomGenerator.getDefault();\n+        boolean isUnsignedCast = castOp.name().startsWith(\"ZERO\");\n+        String testMethodName = VectorSpeciesPair.makePair(isp, osp).format();\n+        var caller = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass();\n+        var testMethod = MethodHandles.lookup().findStatic(caller,\n+                testMethodName,\n+                MethodType.methodType(void.class, byte.class.arrayType(), byte.class.arrayType()));\n+        byte[] input = new byte[isp.vectorByteSize()];\n+        byte[] output = new byte[osp.vectorByteSize()];\n+        for (int iter = 0; iter < INVOCATIONS; iter++) {\n+            \/\/ We need to generate arrays with NaN or very large values occasionally\n+            boolean normalArray = random.nextBoolean();\n+            var abnormalValue = List.of(Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, -1e30, 1e30);\n+            for (int i = 0; i < isp.length(); i++) {\n+                switch (isp.elementType().getName()) {\n+                    case \"byte\"   -> setByte(input, i, (byte)random.nextInt());\n+                    case \"short\"  -> setShort(input, i, (short)random.nextInt());\n+                    case \"int\"    -> setInt(input, i, random.nextInt());\n+                    case \"long\"   -> setLong(input, i, random.nextLong());\n+                    case \"float\"  -> {\n+                        if (normalArray || random.nextBoolean()) {\n+                            setFloat(input, i, random.nextFloat(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+                        } else {\n+                            setFloat(input, i, abnormalValue.get(random.nextInt(abnormalValue.size())).floatValue());\n+                        }\n+                    }\n+                    case \"double\" -> {\n+                        if (normalArray || random.nextBoolean()) {\n+                            setDouble(input, i, random.nextDouble(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+                        } else {\n+                            setDouble(input, i, abnormalValue.get(random.nextInt(abnormalValue.size())));\n+                        }\n+                    }\n+                    default -> throw new AssertionError();\n+                }\n+            }\n+\n+            testMethod.invokeExact(input, output);\n+\n+            for (int i = 0; i < osp.length(); i++) {\n+                Number expected, actual;\n+                if (i < isp.length()) {\n+                    Number initial = switch (isp.elementType().getName()) {\n+                        case \"byte\"   -> getByte(input, i);\n+                        case \"short\"  -> getShort(input, i);\n+                        case \"int\"    -> getInt(input, i);\n+                        case \"long\"   -> getLong(input, i);\n+                        case \"float\"  -> getFloat(input, i);\n+                        case \"double\" -> getDouble(input, i);\n+                        default -> throw new AssertionError();\n+                    };\n+                    expected = switch (osp.elementType().getName()) {\n+                        case \"byte\" -> initial.byteValue();\n+                        case \"short\" -> {\n+                            if (isUnsignedCast) {\n+                                yield (short) (initial.longValue() & ((1L << isp.elementSize()) - 1));\n+                            } else {\n+                                yield initial.shortValue();\n+                            }\n+                        }\n+                        case \"int\" -> {\n+                            if (isUnsignedCast) {\n+                                yield (int) (initial.longValue() & ((1L << isp.elementSize()) - 1));\n+                            } else {\n+                                yield initial.intValue();\n+                            }\n+                        }\n+                        case \"long\" -> {\n+                            if (isUnsignedCast) {\n+                                yield (long) (initial.longValue() & ((1L << isp.elementSize()) - 1));\n+                            } else {\n+                                yield initial.longValue();\n+                            }\n+                        }\n+                        case \"float\" -> initial.floatValue();\n+                        case \"double\" -> initial.doubleValue();\n+                        default -> throw new AssertionError();\n+                    };\n+                } else {\n+                    expected = switch (osp.elementType().getName()) {\n+                        case \"byte\"   -> (byte)0;\n+                        case \"short\"  -> (short)0;\n+                        case \"int\"    -> (int)0;\n+                        case \"long\"   -> (long)0;\n+                        case \"float\"  -> (float)0;\n+                        case \"double\" -> (double)0;\n+                        default -> throw new AssertionError();\n+                    };\n+                }\n+                actual = switch (osp.elementType().getName()) {\n+                    case \"byte\"   -> getByte(output, i);\n+                    case \"short\"  -> getShort(output, i);\n+                    case \"int\"    -> getInt(output, i);\n+                    case \"long\"   -> getLong(output, i);\n+                    case \"float\"  -> getFloat(output, i);\n+                    case \"double\" -> getDouble(output, i);\n+                    default -> throw new AssertionError();\n+                };\n+                Asserts.assertEquals(expected, actual);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public static <T, U> void vectorExpandShrink(VectorSpecies<T> isp, VectorSpecies<U> osp, byte[] input, byte[] output) {\n+        isp.fromByteArray(input, 0, ByteOrder.nativeOrder())\n+                .reinterpretShape(osp, 0)\n+                .intoByteArray(output, 0, ByteOrder.nativeOrder());\n+    }\n+\n+    public static <T, U> void runExpandShrinkHelper(VectorSpecies<T> isp, VectorSpecies<U> osp) throws Throwable {\n+        var random = RandomGenerator.getDefault();\n+        String testMethodName = VectorSpeciesPair.makePair(isp, osp).format();\n+        var caller = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass();\n+        var testMethod = MethodHandles.lookup().findStatic(caller,\n+                testMethodName,\n+                MethodType.methodType(void.class, byte.class.arrayType(), byte.class.arrayType()));\n+        byte[] input = new byte[isp.vectorByteSize()];\n+        byte[] output = new byte[osp.vectorByteSize()];\n+        for (int iter = 0; iter < INVOCATIONS; iter++) {\n+            random.nextBytes(input);\n+\n+            testMethod.invokeExact(input, output);\n+\n+            for (int i = 0; i < osp.vectorByteSize(); i++) {\n+                int expected = i < isp.vectorByteSize() ? input[i] : 0;\n+                int actual = output[i];\n+                Asserts.assertEquals(expected, actual);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public static <T, U> void vectorDoubleExpandShrink(VectorSpecies<T> isp, VectorSpecies<U> osp, byte[] input, byte[] output) {\n+        isp.fromByteArray(input, 0, ByteOrder.nativeOrder())\n+                .reinterpretShape(osp, 0)\n+                .reinterpretShape(isp, 0)\n+                .intoByteArray(output, 0, ByteOrder.nativeOrder());\n+    }\n+\n+    public static <T, U> void runDoubleExpandShrinkHelper(VectorSpecies<T> isp, VectorSpecies<U> osp) throws Throwable {\n+        var random = RandomGenerator.getDefault();\n+        String testMethodName = VectorSpeciesPair.makePair(isp, osp).format();\n+        var caller = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass();\n+        var testMethod = MethodHandles.lookup().findStatic(caller,\n+                testMethodName,\n+                MethodType.methodType(void.class, byte.class.arrayType(), byte.class.arrayType()));\n+        byte[] input = new byte[isp.vectorByteSize()];\n+        byte[] output = new byte[isp.vectorByteSize()];\n+        for (int iter = 0; iter < INVOCATIONS; iter++) {\n+            random.nextBytes(input);\n+\n+            testMethod.invokeExact(input, output);\n+\n+            for (int i = 0; i < isp.vectorByteSize(); i++) {\n+                int expected = i < osp.vectorByteSize() ? input[i] : 0;\n+                int actual = output[i];\n+                Asserts.assertEquals(expected, actual);\n+            }\n+        }\n+    }\n+\n+    \/\/ All this complication is due to the fact that vector load and store with respect to byte array introduce\n+    \/\/ additional ReinterpretNodes, several ReinterpretNodes back to back being optimized make the number of\n+    \/\/ nodes remaining in the IR becomes unpredictable.\n+    @ForceInline\n+    public static <T, U> void vectorRebracket(VectorSpecies<T> isp, VectorSpecies<U> osp, Object input, Object output) {\n+        var outputVector = isp.fromArray(input, 0).reinterpretShape(osp, 0);\n+        var otype = osp.elementType();\n+        if (otype == byte.class) {\n+            ((ByteVector)outputVector).intoArray((byte[])output, 0);\n+        } else if (otype == short.class) {\n+            ((ShortVector)outputVector).intoArray((short[])output, 0);\n+        } else if (otype == int.class) {\n+            ((IntVector)outputVector).intoArray((int[])output, 0);\n+        } else if (otype == long.class) {\n+            ((LongVector)outputVector).intoArray((long[])output, 0);\n+        } else if (otype == float.class) {\n+            ((FloatVector)outputVector).intoArray((float[])output, 0);\n+        } else if (otype == double.class) {\n+            ((DoubleVector)outputVector).intoArray((double[])output, 0);\n+        } else {\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    public static <T, U> void runRebracketHelper(VectorSpecies<T> isp, VectorSpecies<U> osp) throws Throwable {\n+        var random = RandomGenerator.getDefault();\n+        String testMethodName = VectorSpeciesPair.makePair(isp, osp).format();\n+        var caller = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass();\n+        var testMethod = MethodHandles.lookup().findStatic(caller,\n+                    testMethodName,\n+                    MethodType.methodType(void.class, isp.elementType().arrayType(), osp.elementType().arrayType()))\n+                .asType(MethodType.methodType(void.class, Object.class, Object.class));\n+        Object input = Array.newInstance(isp.elementType(), isp.length());\n+        Object output = Array.newInstance(osp.elementType(), osp.length());\n+        long ibase = UnsafeUtils.arrayBase(isp.elementType());\n+        long obase = UnsafeUtils.arrayBase(osp.elementType());\n+        for (int iter = 0; iter < INVOCATIONS; iter++) {\n+            for (int i = 0; i < isp.vectorByteSize(); i++) {\n+                UnsafeUtils.putByte(input, ibase, i, random.nextInt());\n+            }\n+\n+            testMethod.invokeExact(input, output);\n+\n+            for (int i = 0; i < osp.vectorByteSize(); i++) {\n+                int expected = i < isp.vectorByteSize() ? UnsafeUtils.getByte(input, ibase, i) : 0;\n+                int actual = UnsafeUtils.getByte(output, obase, i);\n+                Asserts.assertEquals(expected, actual);\n+            }\n+        }\n+    }\n+\n+    public static byte getByte(byte[] array, int index) {\n+        return (byte)BYTE_ACCESS.get(array, index * Byte.BYTES);\n+    }\n+\n+    public static short getShort(byte[] array, int index) {\n+        return (short)SHORT_ACCESS.get(array, index * Short.BYTES);\n+    }\n+\n+    public static int getInt(byte[] array, int index) {\n+        return (int)INT_ACCESS.get(array, index * Integer.BYTES);\n+    }\n+\n+    public static long getLong(byte[] array, int index) {\n+        return (long)LONG_ACCESS.get(array, index * Long.BYTES);\n+    }\n+\n+    public static float getFloat(byte[] array, int index) {\n+        return (float)FLOAT_ACCESS.get(array, index * Float.BYTES);\n+    }\n+\n+    public static double getDouble(byte[] array, int index) {\n+        return (double)DOUBLE_ACCESS.get(array, index * Double.BYTES);\n+    }\n+\n+    public static void setByte(byte[] array, int index, byte value) {\n+        BYTE_ACCESS.set(array, index * Byte.BYTES, value);\n+    }\n+\n+    public static void setShort(byte[] array, int index, short value) {\n+        SHORT_ACCESS.set(array, index * Short.BYTES, value);\n+    }\n+\n+    public static void setInt(byte[] array, int index, int value) {\n+        INT_ACCESS.set(array, index * Integer.BYTES, value);\n+    }\n+\n+    public static void setLong(byte[] array, int index, long value) {\n+        LONG_ACCESS.set(array, index * Long.BYTES, value);\n+    }\n+\n+    public static void setFloat(byte[] array, int index, float value) {\n+        FLOAT_ACCESS.set(array, index * Float.BYTES, value);\n+    }\n+\n+    public static void setDouble(byte[] array, int index, double value) {\n+        DOUBLE_ACCESS.set(array, index * Double.BYTES, value);\n+    }\n+\n+    private static final VarHandle BYTE_ACCESS   = MethodHandles.arrayElementVarHandle(byte.class.arrayType());\n+    private static final VarHandle SHORT_ACCESS  = MethodHandles.byteArrayViewVarHandle(short.class.arrayType(),  ByteOrder.nativeOrder());\n+    private static final VarHandle INT_ACCESS    = MethodHandles.byteArrayViewVarHandle(int.class.arrayType(),    ByteOrder.nativeOrder());\n+    private static final VarHandle LONG_ACCESS   = MethodHandles.byteArrayViewVarHandle(long.class.arrayType(),   ByteOrder.nativeOrder());\n+    private static final VarHandle FLOAT_ACCESS  = MethodHandles.byteArrayViewVarHandle(float.class.arrayType(),  ByteOrder.nativeOrder());\n+    private static final VarHandle DOUBLE_ACCESS = MethodHandles.byteArrayViewVarHandle(double.class.arrayType(), ByteOrder.nativeOrder());\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":372,"deletions":0,"binary":false,"changes":372,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.utils;\n+\n+import jdk.incubator.vector.VectorSpecies;\n+\n+public record VectorSpeciesPair(VectorSpecies<?> isp, VectorSpecies<?> osp, boolean unsignedCast) {\n+    public static VectorSpeciesPair makePair(VectorSpecies<?> isp, VectorSpecies<?> osp, boolean unsignedCast) {\n+        return new VectorSpeciesPair(isp, osp, unsignedCast);\n+    }\n+\n+    public static VectorSpeciesPair makePair(VectorSpecies<?> isp, VectorSpecies<?> osp) {\n+        return new VectorSpeciesPair(isp, osp, false);\n+    }\n+\n+    public String format() {\n+        return String.format(\"test%s%c%dto%c%d\",\n+                unsignedCast() ? \"U\" : \"\",\n+                Character.toUpperCase(isp().elementType().getName().charAt(0)),\n+                isp().vectorBitSize(),\n+                Character.toUpperCase(osp().elementType().getName().charAt(0)),\n+                osp().vectorBitSize());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorSpeciesPair.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"}]}