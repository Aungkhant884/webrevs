{"files":[{"patch":"@@ -506,0 +506,3 @@\n+        if (!arrayType.isArray()) {\n+            return parseUnknownArray(length, buf);\n+        }\n@@ -531,2 +534,1 @@\n-        } else {\n-            assert componentType.isAnnotation();\n+        } else if (componentType.isAnnotation()) {\n@@ -535,0 +537,2 @@\n+        } else {\n+            return parseUnknownArray(length, buf);\n@@ -756,0 +760,12 @@\n+    private static Object parseUnknownArray(int length,\n+                                            ByteBuffer buf) {\n+        int tag = 0;\n+\n+        for (int i = 0; i < length; i++) {\n+            tag = buf.get();\n+            skipMemberValue(tag, buf);\n+        }\n+\n+        return exceptionProxy(tag);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266791\n+ * @summary Annotation property which is compiled as an array property but\n+ *          changed observed as a singular element should throw an\n+ *          AnnotationTypeMismatchException\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @run main ArityTypeMismatchTest\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+import java.lang.annotation.AnnotationTypeMismatchException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+public class ArityTypeMismatchTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/*\n+         * This test creates an annotation with a member with a non-array type where the annotation\n+         * defines an array property of this type. This can happen if the annotation class is recompiled\n+         * without recompiling the code that declares an annotation of this type. In the example, a\n+         * class is defined to be annotated as\n+         *\n+         * @AnAnnotation(value = {\"v\"}) \/\/ should no longer be an array\n+         * class Carrier { }\n+         *\n+         * where @AnAnnotation expects a singular value.\n+         *\/\n+        ClassWriter writer = new ClassWriter(0);\n+        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n+        AnnotationVisitor v = writer.visitAnnotation(Type.getDescriptor(AnAnnotation.class), true);\n+        AnnotationVisitor v2 = v.visitArray(\"value\");\n+        v2.visit(null, \"v\");\n+        v2.visitEnd();\n+        v.visitEnd();\n+        writer.visitEnd();\n+        byte[] b = writer.toByteArray();\n+        ByteArrayClassLoader cl = new ByteArrayClassLoader(ArityTypeMismatchTest.class.getClassLoader());\n+        cl.init(b);\n+        AnAnnotation sample = cl.loadClass(\"sample.Carrier\").getAnnotation(AnAnnotation.class);\n+        try {\n+            String value = sample.value();\n+            throw new IllegalStateException(\"Found value: \" + value);\n+        } catch (AnnotationTypeMismatchException e) {\n+            if (!e.element().getName().equals(\"value\")) {\n+                throw new IllegalStateException(\"Unexpected element: \" + e.element());\n+            } else if (!e.foundType().equals(\"Array with component tag: [\")) {\n+                throw new IllegalStateException(\"Unexpected type: \" + e.foundType());\n+            }\n+        }\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface AnAnnotation {\n+        String value();\n+    }\n+\n+    public static class ByteArrayClassLoader extends ClassLoader {\n+\n+        public ByteArrayClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+\n+        public void init(byte[] b) {\n+            defineClass(\"sample.Carrier\", b, 0, b.length);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/ArityTypeMismatchTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266766\n+ * @summary An array property of a type that is no longer of a type that is a legal member of an\n+ *          annotation should throw an AnnotationTypeMismatchException.\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @run main ArrayTypeMismatchTest\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.AnnotationTypeMismatchException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ArrayTypeMismatchTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/*\n+         * This test creates an annotation where the annotation member's type is an array with\n+         * a component type that cannot be legally used for an annotation member. This can happen\n+         * if a class is recompiled independencly of the annotation type and linked at runtime\n+         * in this new version. For a test, a class is created as:\n+         *\n+         * package sample;\n+         * @Carrier(value = { @NoAnnotation })\n+         * class Host { }\n+         *\n+         * where NoAnnotation is defined as a regular interface and not as an annotation type.\n+         * The classes are created by using ASM to emulate this state.\n+         *\/\n+        ByteArrayClassLoader cl = new ByteArrayClassLoader(NoAnnotation.class.getClassLoader());\n+        cl.init(annotationType(), carrierType());\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Annotation> host = (Class<? extends Annotation>) cl.loadClass(\"sample.Host\");\n+        Annotation sample = cl.loadClass(\"sample.Carrier\").getAnnotation(host);\n+        try {\n+            Object value = host.getMethod(\"value\").invoke(sample);\n+            throw new IllegalStateException(\"Found value: \" + value);\n+        } catch (InvocationTargetException ite) {\n+            Throwable cause = ite.getCause();\n+            if (cause instanceof AnnotationTypeMismatchException) {\n+                AnnotationTypeMismatchException e = ((AnnotationTypeMismatchException) cause);\n+                if (!e.element().getName().equals(\"value\")) {\n+                    throw new IllegalStateException(\"Unexpected element: \" + e.element());\n+                } else if (!e.foundType().equals(\"Array with component tag: @\")) {\n+                    throw new IllegalStateException(\"Unexpected type: \" + e.foundType());\n+                }\n+            } else {\n+                throw new IllegalStateException(cause);\n+            }\n+        }\n+    }\n+\n+    private static byte[] carrierType() {\n+        ClassWriter writer = new ClassWriter(0);\n+        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n+        AnnotationVisitor v = writer.visitAnnotation(\"Lsample\/Host;\", true);\n+        AnnotationVisitor a = v.visitArray(\"value\");\n+        a.visitAnnotation(null, Type.getDescriptor(NoAnnotation.class)).visitEnd();\n+        a.visitEnd();\n+        v.visitEnd();\n+        writer.visitEnd();\n+        return writer.toByteArray();\n+    }\n+\n+    private static byte[] annotationType() {\n+        ClassWriter writer = new ClassWriter(0);\n+        writer.visit(Opcodes.V1_8,\n+                Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT | Opcodes.ACC_INTERFACE | Opcodes.ACC_ANNOTATION,\n+                \"sample\/Host\",\n+                null,\n+                Type.getInternalName(Object.class),\n+                new String[]{Type.getInternalName(Annotation.class)});\n+        AnnotationVisitor a = writer.visitAnnotation(Type.getDescriptor(Retention.class), true);\n+        a.visitEnum(\"value\", Type.getDescriptor(RetentionPolicy.class), RetentionPolicy.RUNTIME.name());\n+        writer.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,\n+                \"value\",\n+                Type.getMethodDescriptor(Type.getType(NoAnnotation[].class)),\n+                null,\n+                null).visitEnd();\n+        writer.visitEnd();\n+        return writer.toByteArray();\n+    }\n+\n+    public interface NoAnnotation { }\n+\n+    public static class ByteArrayClassLoader extends ClassLoader {\n+\n+        public ByteArrayClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+\n+        void init(byte[] annotationType, byte[] carrierType) {\n+            defineClass(\"sample.Host\", annotationType, 0, annotationType.length);\n+            defineClass(\"sample.Carrier\", carrierType, 0, carrierType.length);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/ArrayTypeMismatchTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"}]}