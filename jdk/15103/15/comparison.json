{"files":[{"patch":"@@ -149,2 +149,2 @@\n-      apt-extra-packages: 'libfreetype-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libc6-i386 libgcc-s1:i386 libstdc++6:i386'\n-      extra-conf-options: '--with-target-bits=32'\n+      apt-extra-packages: 'libfreetype-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libc6-i386 libgcc-s1:i386 libstdc++6:i386 libffi-dev:i386'\n+      extra-conf-options: '--with-target-bits=32 --enable-fallback-linker --enable-libffi-bundling'\n","filename":".github\/workflows\/main.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -429,3 +429,8 @@\n-            dependencies: [\"devkit\", \"gtest\"],\n-            configure_args: concat(common.configure_args_32bit,\n-                \"--with-jvm-variants=minimal,server\", \"--with-zlib=system\"),\n+            dependencies: [\"devkit\", \"gtest\", \"libffi\"],\n+            configure_args: concat(common.configure_args_32bit, [\n+                \"--with-jvm-variants=minimal,server\",\n+                \"--with-zlib=system\",\n+                \"--with-libffi=\" + input.get(\"libffi\", \"home_path\"),\n+                \"--enable-libffi-bundling\",\n+                \"--enable-fallback-linker\"\n+            ])\n","filename":"make\/conf\/jib-profiles.js","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -1063,0 +1064,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-     * @since 20\n+     * @since 22\n@@ -277,1 +277,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-         * @since 20\n+         * @since 22\n@@ -326,1 +326,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -53,0 +52,3 @@\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n@@ -55,1 +57,1 @@\n- * @since 19\n+ * @since 22\n@@ -57,1 +59,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -97,1 +98,1 @@\n-     *         MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+     *         MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -187,1 +186,1 @@\n- *         MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+ *         MemorySegment s = slicingArena.allocateFrom(JAVA_INT, 1, 2, 3, 4, 5);\n@@ -198,1 +197,1 @@\n- * @since 20\n+ * @since 22\n@@ -200,1 +199,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -272,3 +270,1 @@\n-    default MemorySegment allocate(long byteSize, long byteAlignment) {\n-        return ((MemorySessionImpl)scope()).allocate(byteSize, byteAlignment);\n-    }\n+    MemorySegment allocate(long byteSize, long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -47,1 +46,1 @@\n- * @since 19\n+ * @since 22\n@@ -49,1 +48,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -41,1 +40,1 @@\n- * @since 19\n+ * @since 22\n@@ -43,1 +42,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -34,1 +33,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -38,0 +36,1 @@\n+import java.util.Map;\n@@ -39,1 +38,0 @@\n-import java.util.Optional;\n@@ -62,0 +60,6 @@\n+ * A linker provides a way to look up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n+ * For example, a linker implementing the C ABI might choose to provide a canonical layout for the C {@code size_t}\n+ * type. On 64-bit platforms, this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n+ * type names to canonical layouts.\n+ * <p>\n@@ -95,1 +99,1 @@\n- *     MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment str = arena.allocateFrom(\"Hello\");\n@@ -98,1 +102,1 @@\n- * }\n+ *}\n@@ -106,5 +110,2 @@\n- * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n- * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * canonical layout is dependent on the ABI implemented by the native linker (see below).\n@@ -125,1 +126,28 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * <ul>\n+ *     <li>{@code bool}<\/li>\n+ *     <li>{@code char}<\/li>\n+ *     <li>{@code short}<\/li>\n+ *     <li>{@code int}<\/li>\n+ *     <li>{@code long}<\/li>\n+ *     <li>{@code long long}<\/li>\n+ *     <li>{@code float}<\/li>\n+ *     <li>{@code double}<\/li>\n+ *     <li>{@code size_t}<\/li>\n+ *     <li>{@code wchar_t}<\/li>\n+ *     <li>{@code void*}<\/li>\n+ * <\/ul>\n+ * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n+ * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n+ * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n+ * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * A native linker typically does not provide canonical layouts for C's unsigned integral types. Instead, they are\n+ * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n+ * the C type {@code unsigned long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n+ * the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64 according to the\n+ * \"System V Application Binary Interface - AMD64 Architecture Processor Supplement\" (all the examples provided\n+ * here will assume these platform-dependent mappings):\n@@ -140,1 +168,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char} <br> {@code unsigned char}<\/th>\n@@ -143,1 +171,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short} <br> {@code unsigned short}<\/th>\n@@ -146,1 +174,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int} <br> {@code unsigned int}<\/th>\n@@ -149,1 +177,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long} <br> {@code unsigned long}<\/th>\n@@ -152,1 +180,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long} <br> {@code unsigned long long}<\/th>\n@@ -203,14 +231,1 @@\n- * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is {@linkplain MemoryLayout#equals(Object) equal}\n- * to one of the following layout constants:\n- * <ul>\n- * <li>{@link ValueLayout#JAVA_BOOLEAN}<\/li>\n- * <li>{@link ValueLayout#JAVA_BYTE}<\/li>\n- * <li>{@link ValueLayout#JAVA_CHAR}<\/li>\n- * <li>{@link ValueLayout#JAVA_SHORT}<\/li>\n- * <li>{@link ValueLayout#JAVA_INT}<\/li>\n- * <li>{@link ValueLayout#JAVA_LONG}<\/li>\n- * <li>{@link ValueLayout#JAVA_FLOAT}<\/li>\n- * <li>{@link ValueLayout#JAVA_DOUBLE}<\/li>\n- * <\/ul><\/li>\n- * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is\n- * {@linkplain MemoryLayout#equals(Object) equal} to {@link ValueLayout#ADDRESS}<\/li>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n@@ -296,1 +311,1 @@\n- *     MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+ *     MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -393,9 +408,5 @@\n- * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n- * <ol>\n- * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n- * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n- * <\/ol>\n- * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n- * <em>variadic arguments<\/em>. Variadic functions are, essentially, templates that can be <em>specialized<\/em> into multiple\n- * non-variadic functions by replacing the {@code ...} or empty formal parameter list with a list of <em>variadic parameters<\/em>\n- * of a fixed number and type.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared with a\n+ * trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}.\n+ * The arguments passed in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions are,\n+ * essentially, templates that can be <em>specialized<\/em> into multiple non-variadic functions by replacing the\n+ * {@code ...} with a list of <em>variadic parameters<\/em> of a fixed number and type.\n@@ -413,2 +424,2 @@\n- * specialized form of a variadic function, as the variadic parameters of the specialized form will always have a promoted\n- * type.\n+ * types that can be used to replace the {@code ...}, as the variadic parameters of the specialized form of a variadic\n+ * function will always have a promoted type.\n@@ -420,2 +431,1 @@\n- * function descriptor, are called <em>variadic argument layouts<\/em>. For a prototype-less function, the index passed to\n- * {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * function descriptor, are called <em>variadic argument layouts<\/em>.\n@@ -423,5 +433,7 @@\n- * The native linker will reject an attempt to link a specialized function descriptor with any variadic argument layouts\n- * corresponding to a C type that would be subject to default argument promotion (as described above). Exactly which layouts\n- * will be rejected is platform specific, but as an example: on Linux\/x64 the layouts {@link ValueLayout#JAVA_BOOLEAN},\n- * {@link ValueLayout#JAVA_BYTE}, {@link ValueLayout#JAVA_CHAR}, {@link ValueLayout#JAVA_SHORT}, and\n- * {@link ValueLayout#JAVA_FLOAT} will be rejected.\n+ * The native linker does not automatically perform default argument promotions. However, since passing an argument of a\n+ * non-promoted type as a variadic argument is not supported in C, the native linker will reject an attempt to link a\n+ * specialized function descriptor with any variadic argument value layouts corresponding to a non-promoted C type.\n+ * Since the size of the C {@code int} type is platform-specific, exactly which layouts will be rejected is\n+ * platform-specific as well. As an example: on Linux\/x64 the layouts corresponding to the C types {@code _Bool},\n+ * {@code (unsigned) char}, {@code (unsigned) short}, and {@code float} (among others), will be rejected by the linker.\n+ * The {@link #canonicalLayouts()} method can be used to find which layout corresponds to a particular C type.\n@@ -463,2 +475,1 @@\n- *     int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n- * }\n+ *     int res = (int)printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -466,0 +477,1 @@\n+ *}\n@@ -485,1 +497,1 @@\n- * @since 19\n+ * @since 22\n@@ -487,1 +499,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -495,0 +506,2 @@\n+     * @implSpec A native linker implementation is guaranteed to provide canonical layouts for\n+     * <a href=\"#describing-c-sigs\">basic C types<\/a>.\n@@ -498,2 +511,0 @@\n-     *\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n@@ -638,0 +649,16 @@\n+    \/**\n+     * {@return an unmodifiable mapping between the names of data types used by the ABI implemented by this linker and their\n+     * <em>canonical layouts<\/em>}\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n+     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n+     * is no longer exposed, or if its canonical layout is updated.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     *\/\n+    Map<String, MemoryLayout> canonicalLayouts();\n+\n@@ -640,1 +667,1 @@\n-     * @since 20\n+     * @since 22\n@@ -642,1 +669,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -707,0 +733,2 @@\n+         * @apiNote This linker option can not be combined with {@link #critical}.\n+         *\n@@ -749,1 +777,1 @@\n-         * {@return a linker option used to mark a foreign function as <em>trivial<\/em>}\n+         * {@return a linker option used to mark a foreign function as <em>critical<\/em>}\n@@ -751,2 +779,2 @@\n-         * A trivial function is a function that has an extremely short running time\n-         * in all cases (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n+         * A critical function is a function that has an extremely short running time in all cases\n+         * (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n@@ -755,1 +783,1 @@\n-         * optimizations that are only valid for trivial functions.\n+         * optimizations that are only valid for critical functions.\n@@ -757,1 +785,1 @@\n-         * Using this linker option when linking non trivial functions is likely to have adverse effects,\n+         * Using this linker option when linking non-critical functions is likely to have adverse effects,\n@@ -760,2 +788,2 @@\n-        static Option isTrivial() {\n-            return LinkerOptions.IsTrivial.INSTANCE;\n+        static Option critical() {\n+            return LinkerOptions.Critical.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":92,"deletions":64,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.invoke.MethodType;\n@@ -46,1 +47,1 @@\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -51,1 +52,1 @@\n- * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind (see\n+ * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind\n@@ -234,0 +235,37 @@\n+ * <h2 id=\"access-mode-restrictions\">Access mode restrictions<\/h2>\n+ *\n+ * A var handle returned by {@link #varHandle(PathElement...)} or {@link ValueLayout#varHandle()} features certain\n+ * access characteristics, which are derived from the selected layout {@code L}:\n+ * <ul>\n+ * <li>A carrier type {@code T}, derived from {@code L.carrier()}<\/li>\n+ * <li>An alignment constraint {@code A}, derived from {@code L.byteAlignment()}<\/li>\n+ * <li>An access size {@code S}, derived from {@code L.byteSize()}<\/li>\n+ * <\/ul>\n+ * Depending on the above characteristics, the returned var handle might feature certain <i>access mode restrictions<\/i>.\n+ * We say that a var handle is <em>aligned<\/em> if its alignment constraint {@code A} is compatible with the access size\n+ * {@code S}, that is if {@code A >= S}. An aligned var handle is guaranteed to support the following access modes:\n+ * <ul>\n+ * <li>read write access modes for all {@code T}. On 32-bit platforms, access modes\n+ *     {@code get} and {@code set} for {@code long}, {@code double} and {@code MemorySegment}\n+ *     are supported but might lead to word tearing, as described in Section {@jls 17.7}.\n+ *     of <cite>The Java Language Specification<\/cite>.\n+ * <li>atomic update access modes for {@code int}, {@code long},\n+ *     {@code float}, {@code double} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     types for certain currently unsupported access modes.)\n+ * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <\/ul>\n+ * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic update access modes compare\n+ * values using their bitwise representation (see {@link Float#floatToRawIntBits}, {@link Double#doubleToRawLongBits}\n+ * and {@link MemorySegment#address()}, respectively).\n+ * <p>\n+ * Alternatively, a var handle is <em>unaligned<\/em> if its alignment constraint {@code A} is incompatible with the\n+ * access size {@code S}, that is, if {@code A < S}. An unaligned var handle only supports the {@code get} and {@code set}\n+ * access modes. All other access modes will result in {@link UnsupportedOperationException} being thrown. Moreover,\n+ * while supported, access modes {@code get} and {@code set} might lead to word tearing.\n+ *\n@@ -238,1 +276,1 @@\n- * @since 19\n+ * @since 22\n@@ -240,1 +278,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -295,0 +332,38 @@\n+    \/**\n+     * {@return {@code offset + (byteSize() * index)}}\n+     *\n+     * @param offset the base offset\n+     * @param index the index to be scaled by the byte size of this layout\n+     * @throws IllegalArgumentException if {@code offset} or {@code index} is negative\n+     * @throws ArithmeticException if either the addition or multiplication overflows\n+     *\/\n+    @ForceInline\n+    default long scale(long offset, long index) {\n+        if (offset < 0) {\n+            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n+        }\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"Negative index: \" + index);\n+        }\n+\n+        return Math.addExact(offset, Math.multiplyExact(byteSize(), index));\n+    }\n+\n+    \/**\n+     *{@return a method handle that can be used to invoke {@link #scale(long, long)} on this layout}\n+     *\/\n+    default MethodHandle scaleHandle() {\n+        class Holder {\n+            static final MethodHandle MH_SCALE;\n+            static {\n+                try {\n+                    MH_SCALE = MethodHandles.lookup().findVirtual(MemoryLayout.class, \"scale\",\n+                            MethodType.methodType(long.class, long.class, long.class));\n+                } catch (ReflectiveOperationException e) {\n+                    throw new ExceptionInInitializerError(e);\n+                }\n+            }\n+        }\n+        return Holder.MH_SCALE.bindTo(this);\n+    }\n+\n@@ -317,1 +392,2 @@\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has one leading {@code long} parameter representing the base offset;<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -325,1 +401,1 @@\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * offset = b + c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -328,4 +404,5 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * where {@code b} represents the base offset provided as a <em>dynamic<\/em> {@code long} argument, {@code x_1}, {@code x_2},\n+     * ... {@code x_n} represent indices into sequences provided as <em>dynamic<\/em> {@code long} arguments, whereas\n+     * {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants derived from the size of the element\n+     * layout of a sequence, and {@code c_1}, {@code c_2}, ... {@code c_m} are other <em>static<\/em> offset constants\n+     * (such as field offsets) which are derived from the layout path.\n@@ -354,4 +431,6 @@\n-     *     <li>it has as zero or more access coordinates of type {@code long}, one for each\n-     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path. The order of these access\n-     *     coordinates corresponds to the order in which the open path elements occur in the provided\n-     *     layout path.\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset, denoted as {@code B};<\/li>\n+     *     <li>it has zero or more trailing access coordinates of type {@code long}, one for each\n+     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path, denoted as\n+     *     {@code I1, I2, ... In}, respectively. The order of these access coordinates corresponds to the order\n+     *     in which the open path elements occur in the provided layout path.\n@@ -360,14 +439,2 @@\n-     * The final address accessed by the returned var handle can be computed as follows:\n-     *\n-     * <blockquote><pre>{@code\n-     * address = base(segment) + offset\n-     * }<\/pre><\/blockquote>\n-     *\n-     * Where {@code base(segment)} denotes a function that returns the physical base address of the accessed\n-     * memory segment. For native segments, this function just returns the native segment's\n-     * {@linkplain MemorySegment#address() address}. For heap segments, this function is more complex, as the address\n-     * of heap segments is virtualized. The {@code offset} value can be expressed in the following form:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * }<\/pre><\/blockquote>\n+     * If the provided layout path {@code P} contains no dereference elements, then the offset {@code O} of the access\n+     * operation is computed as follows:\n@@ -375,4 +442,3 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * {@snippet lang = \"java\":\n+     * O = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);\n+     * }\n@@ -380,2 +446,15 @@\n-     * Additionally, the provided dynamic values must conform to bounds which are derived from the layout path, that is,\n-     * {@code 0 <= x_i < b_i}, where {@code 1 <= i <= n}, or {@link IndexOutOfBoundsException} is thrown.\n+     * Accessing a memory segment using the var handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n+     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n+     * can be more strict (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n+     * where {@code O} is the accessed offset (computed as above), {@code A} is the size of the selected layout and {@code S}\n+     * is the size of the accessed memory segment.<\/li>\n+     *     <li>The accessed memory segment must be {@link MemorySegment#isAccessibleBy(Thread) accessible} from the\n+     * thread performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed segment must be\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}, or an {@link IllegalStateException} is thrown.<\/li>\n+     * <\/ul>\n@@ -383,3 +462,13 @@\n-     * The base address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n-     * #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more strict\n-     * (but not less) than the alignment constraint of the selected value layout.\n+     * If the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#get(Object...)}\n+     * on the returned var handle will return a new memory segment. The segment is associated with a fresh scope that is\n+     * always alive. Moreover, the size of the segment depends on whether the address layout has a\n+     * {@linkplain AddressLayout#targetLayout() target layout}. More specifically:\n+     * <ul>\n+     *     <li>If the address layout has a target layout {@code T}, then the size of the returned segment\n+     *     is {@code T.byteSize()};<\/li>\n+     *     <li>Otherwise, the address layout has no target layout, and the size of the returned segment\n+     *     is <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>.<\/li>\n+     * <\/ul>\n+     * Moreover, if the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#set(Object...)}\n+     * can throw {@link IllegalArgumentException} if the memory segment representing the address to be written is not a\n+     * {@linkplain MemorySegment#isNative() native} memory segment.\n@@ -387,5 +476,4 @@\n-     * Multiple paths can be chained, with <a href=#deref-path-elements>dereference path elements<\/a>.\n-     * A dereference path element constructs a fresh native memory segment whose base address is the address value\n-     * read obtained by accessing a memory segment at the offset determined by the layout path elements immediately preceding\n-     * the dereference path element. In other words, if a layout path contains one or more dereference path elements,\n-     * the final address accessed by the returned var handle can be computed as follows:\n+     * If the provided layout path has size {@code m} and contains a dereference path element in position {@code k}\n+     * (where {@code k <= m}) then two layout paths {@code P} and {@code P'} are derived, where P contains all the path\n+     * elements from 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1} to\n+     * {@code m} (if any). Then, the returned var handle is computed as follows:\n@@ -393,6 +481,8 @@\n-     * <blockquote><pre>{@code\n-     * address_1 = base(segment) + offset_1\n-     * address_2 = base(segment_1) + offset_2\n-     * ...\n-     * address_k = base(segment_k-1) + offset_k\n-     * }<\/pre><\/blockquote>\n+     * {@snippet lang = \"java\":\n+     * VarHandle baseHandle = this.varHandle(P);\n+     * MemoryLayout target = ((AddressLayout)this.select(P)).targetLayout().get();\n+     * VarHandle targetHandle = target.varHandle(P');\n+     * targetHandle = MethodHandles.insertCoordinates(targetHandle, 1, 0L); \/\/ always access nested targets at offset 0\n+     * targetHandle = MethodHandles.collectCoordinates(targetHandle, 0,\n+     *         baseHandle.toMethodHandle(VarHandle.AccessMode.GET));\n+     * }\n@@ -400,8 +490,14 @@\n-     * where {@code k} is the number of dereference path elements in a layout path, {@code segment} is the input segment,\n-     * {@code segment_1}, ...  {@code segment_k-1} are the segments obtained by dereferencing the address associated with\n-     * a given dereference path element (e.g. {@code segment_1} is a native segment whose base address is {@code address_1}),\n-     * and {@code offset_1}, {@code offset_2}, ... {@code offset_k} are the offsets computed by evaluating\n-     * the path elements after a given dereference operation (these offsets are obtained using the computation described\n-     * above). In these more complex access operations, all memory accesses immediately preceding a dereference operation\n-     * (e.g. those at addresses {@code address_1}, {@code address_2}, ...,  {@code address_k-1} are performed using the\n-     * {@link VarHandle.AccessMode#GET} access mode.\n+     * (The above can be trivially generalized to cases where the provided layout path contains more than one dereference\n+     * path elements).\n+     * <p>\n+     * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n+     * {@snippet lang = \"java\":\n+     *     GroupLayout grp = java.lang.foreign.MemoryLayout.structLayout(\n+     *             MemoryLayout.paddingLayout(4),\n+     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n+     *     );\n+     * }\n+     * To access the member layout named {@code value}, we can construct a var handle as follows:\n+     * {@snippet lang = \"java\":\n+     *     VarHandle handle = grp.varHandle(PathElement.groupElement(\"value\")); \/\/(MemorySegment, long) -> int\n+     * }\n@@ -409,2 +505,2 @@\n-     * @apiNote The resulting var handle features certain <em>access mode restrictions<\/em>, which are common to all\n-     * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view handles}.\n+     * @apiNote The resulting var handle features certain <a href=\"#access-mode-restrictions\"><em>access mode restrictions<\/em><\/a>,\n+     * which are common to all var handles derived from memory layouts.\n@@ -416,1 +512,0 @@\n-     * @see MethodHandles#memorySegmentViewVarHandle(ValueLayout)\n@@ -419,0 +514,4 @@\n+        Objects.requireNonNull(elements);\n+        if (this instanceof ValueLayout vl && elements.length == 0) {\n+            return vl.varHandle(); \/\/ fast path\n+        }\n@@ -430,3 +529,3 @@\n-     *     <li>it has a leading parameter of type {@code MemorySegment}, corresponding to the memory segment\n-     *     to be sliced;<\/li>\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} corresponding to the memory segment to be sliced<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -437,6 +536,2 @@\n-     * The offset of the returned segment is computed as follows:\n-     * {@snippet lang=java :\n-     * long offset = byteOffset(elements);\n-     * long size = select(elements).byteSize();\n-     * MemorySegment slice = segment.asSlice(offset, size);\n-     * }\n+     * The offset {@code O} of the returned segment is computed as if by a call to a\n+     * {@linkplain #byteOffsetHandle(PathElement...) byte offset handle} constructed using the given path elements.\n@@ -444,3 +539,11 @@\n-     * The segment to be sliced must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n-     * {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more\n-     * strict (but not less) than the alignment constraint of the selected value layout.\n+     * Computing a slice of a memory segment using the method handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n+     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n+     * can be more strict (but not less) than the alignment constraint of the selected layout.<\/li>\n+     *     <li>The start offset of the slicing operation (computed as above) must fall fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n+     * where {@code O} is the start offset of the slicing operation (computed as above), {@code A} is the size of the\n+     * selected layout and {@code S} is the size of the accessed memory segment.<\/li>\n+     * <\/ul>\n@@ -504,1 +607,1 @@\n-     * @since 19\n+     * @since 22\n@@ -506,1 +609,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -672,18 +774,0 @@\n-    \/**\n-     * Creates a sequence layout with the given element layout and the maximum element\n-     * count such that it does not overflow a {@code long}.\n-     *\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n-     * }\n-     *\n-     * @param elementLayout the sequence element layout.\n-     * @return a new sequence layout with the given element layout and maximum element count.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n-     *\/\n-    static SequenceLayout sequenceLayout(MemoryLayout elementLayout) {\n-        Objects.requireNonNull(elementLayout);\n-        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":175,"deletions":91,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.lang.foreign.Linker.Option;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n@@ -37,1 +34,2 @@\n-import java.nio.channels.FileChannel.*;\n+import java.nio.channels.FileChannel.MapMode;\n+import java.nio.charset.Charset;\n@@ -49,0 +47,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -50,3 +49,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.layout.ValueLayouts;\n-import jdk.internal.javac.PreviewFeature;\n@@ -130,5 +126,6 @@\n- * For more complex access operations (e.g. structured memory access), clients can obtain a\n- * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) var handle}\n- * that accepts a segment and a {@code long} offset. More complex var handles\n- * can be obtained by adapting a segment var handle view using the var handle combinator functions defined in the\n- * {@link java.lang.invoke.MethodHandles} class:\n+ * More complex access operations can be implemented using var handles. The {@link ValueLayout#varHandle()}\n+ * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout on a memory segment.\n+ * A var handle obtained from a layout supports several additional <a href=MemoryLayout.html#access-mode-restrictions>\n+ * access modes<\/a>. More importantly, var handles can be <em>combined<\/em> with method handles to express complex access\n+ * operations. For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * index can be created as follows:\n@@ -136,1 +133,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang=java:\n@@ -138,7 +135,5 @@\n- * VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n- * MethodHandle multiplyExact = MethodHandles.lookup()\n- *                                           .findStatic(Math.class, \"multiplyExact\",\n- *                                                                   MethodType.methodType(long.class, long.class, long.class));\n- * intHandle = MethodHandles.filterCoordinates(intHandle, 1,\n- *                                             MethodHandles.insertArguments(multiplyExact, 0, ValueLayout.JAVA_INT.byteSize()));\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * VarHandle intHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n+ * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle(); \/\/ <base offset> + <index> * JAVA_INT.byteSize()\n+ *\n+ * intHandle = MethodHandles.filterCoordinates(intHandle, 1, scale);\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + 3 * 4 = 12\n@@ -147,3 +142,5 @@\n- * Alternatively, complex var handles can can be obtained\n- * from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n- * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>:\n+ * To make the process of creating these var handles easier, the method\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)} can be used, by providing it a so called\n+ * <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>. A layout path, consisting of several <em>layout\n+ * path elements<\/em>, selects a value layout to be accessed, which can be nested inside another memory layout. For example,\n+ * we can express the access to an element of an {@code int} array using layout paths like so:\n@@ -153,2 +150,7 @@\n- * VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+ *     ValueLayout.JAVA_INT.withName(\"size\"),\n+ *     MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+ * );\n+ * VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.groupElement(\"data\"),\n+ *                                               MemoryLayout.PathElement.sequenceElement());\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -156,0 +158,9 @@\n+ * Where {@code offsetof(data)} is the offset of the {@code data} element layout of the {@code segmentLayout} layout\n+ *\n+ * Both the var handle returned by {@link ValueLayout#varHandle()} and\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)}, as well as the method handle returned by\n+ * {@link MemoryLayout#byteOffsetHandle(MemoryLayout.PathElement...)} and {@link MemoryLayout#sliceHandle(MemoryLayout.PathElement...)}\n+ * feature a <em>base offset<\/em> parameter. This parameter represents a base offset for the offset computation. This\n+ * parameter allows a client to combine these handles further with additional offset computations. This is demonstrated\n+ * in the first of the two examples above, where {@code intHandle} is combined with a\n+ * {@linkplain MemoryLayout#scaleHandle() scale handle} obtained from {@code ValueLayout.JAVA_INT}.\n@@ -436,1 +447,1 @@\n- * @since 19\n+ * @since 22\n@@ -438,1 +449,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -738,24 +748,0 @@\n-    \/**\n-     * Returns the offset, in bytes, of the provided segment, relative to this\n-     * segment.\n-     *\n-     * <p>The offset is relative to the address of this segment and can be\n-     * a negative or positive value. For instance, if both segments are native\n-     * segments, or heap segments backed by the same array, the resulting offset\n-     * can be computed as follows:\n-     *\n-     * {@snippet lang=java :\n-     * other.address() - address()\n-     * }\n-     *\n-     * If the segments share the same address, {@code 0} is returned. If\n-     * {@code other} is a slice of this segment, the offset is always\n-     * {@code 0 <= x < this.byteSize()}.\n-     *\n-     * @param other the segment to retrieve an offset to.\n-     * @throws UnsupportedOperationException if the two segments cannot be compared, e.g. because they are of\n-     * different kinds, or because they are backed by different Java arrays.\n-     * @return the relative offset, in bytes, of the provided segment.\n-     *\/\n-    long segmentOffset(MemorySegment other);\n-\n@@ -770,1 +756,1 @@\n-     *     byteHandle.set(ValueLayout.JAVA_BYTE, offset, value);\n+     *     segment.set(ValueLayout.JAVA_BYTE, offset, value);\n@@ -1071,1 +1057,2 @@\n-     * Reads a UTF-8 encoded, null-terminated string from this segment at the given offset.\n+     * Reads a null-terminated string from this segment at the given offset, using the\n+     * {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1073,4 +1060,5 @@\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * getString(offset, StandardCharsets.UTF_8);\n+     *}\n+     *\n@@ -1080,3 +1068,4 @@\n-     * @throws IllegalArgumentException if the size of the UTF-8 string is greater than the largest string supported by the platform.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - S}, where {@code S} is the size of the UTF-8\n-     * string (including the terminator character).\n+     * @throws IllegalArgumentException if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1088,2 +1077,2 @@\n-    default String getUtf8String(long offset) {\n-        return SharedUtils.toJavaStringInternal(this, offset);\n+    default String getString(long offset) {\n+        return getString(offset, StandardCharsets.UTF_8);\n@@ -1093,1 +1082,1 @@\n-     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n+     * Reads a null-terminated string from this segment at the given offset, using the provided charset.\n@@ -1099,0 +1088,28 @@\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the string bytes.\n+     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n+     * the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException      if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException         if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                       {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread {@code T},\n+     *                                       such that {@code isAccessibleBy(T) == false}.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    default String getString(long offset, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        return StringSupport.read(this, offset, charset);\n+    }\n+\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1100,4 +1117,4 @@\n-     * If the given string contains any {@code '\\0'} characters, they will be\n-     * copied as well. This means that, depending on the method used to read\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n-     * will appear truncated when read again.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * setString(offset, str, StandardCharsets.UTF_8);\n+     *}\n@@ -1107,1 +1124,3 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - str.getBytes().length() + 1}.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1113,2 +1132,3 @@\n-    default void setUtf8String(long offset, String str) {\n-        Utils.toCString(str.getBytes(StandardCharsets.UTF_8), SegmentAllocator.prefixAllocator(asSlice(offset)));\n+    default void setString(long offset, String str) {\n+        Objects.requireNonNull(str);\n+        setString(offset, str, StandardCharsets.UTF_8);\n@@ -1117,0 +1137,37 @@\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the provided charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     *                the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param str     the Java string to be written into this segment.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException         if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                       {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread {@code T},\n+     *                                       such that {@code isAccessibleBy(T) == false}.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    default void setString(long offset, String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        StringSupport.write(this, offset, charset, str);\n+    }\n@@ -1280,2 +1337,3 @@\n-     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes} or if\n-     * {@code dstOffset > dstSegment.byteSize() - bytes}, or if either {@code srcOffset}, {@code dstOffset}\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if {@code dstOffset > dstSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if either {@code srcOffset}, {@code dstOffset}\n@@ -1323,1 +1381,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -1327,1 +1385,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -1330,0 +1388,1 @@\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - (elementCount * srcLayout.byteSize())}.\n@@ -1360,1 +1419,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n+        return (byte) layout.varHandle().get(this, offset);\n@@ -1380,1 +1439,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1399,1 +1458,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n+        return (boolean) layout.varHandle().get(this, offset);\n@@ -1419,1 +1478,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1438,1 +1497,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n+        return (char) layout.varHandle().get(this, offset);\n@@ -1458,1 +1517,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1477,1 +1536,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n+        return (short) layout.varHandle().get(this, offset);\n@@ -1497,1 +1556,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1516,1 +1575,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n+        return (int) layout.varHandle().get(this, offset);\n@@ -1536,1 +1595,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1555,1 +1614,1 @@\n-        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n+        return (float)layout.varHandle().get(this, offset);\n@@ -1575,1 +1634,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1594,1 +1653,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n+        return (long) layout.varHandle().get(this, offset);\n@@ -1614,1 +1673,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1633,1 +1692,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n+        return (double) layout.varHandle().get(this, offset);\n@@ -1653,1 +1712,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1678,1 +1737,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n+        return (MemorySegment) layout.varHandle().get(this, offset);\n@@ -1699,1 +1758,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1723,1 +1782,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (byte) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1747,1 +1806,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (boolean) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1771,1 +1830,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (char) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1796,1 +1855,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1820,1 +1879,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (short) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1845,1 +1904,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1871,1 +1930,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1896,1 +1955,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1920,1 +1979,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (int) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1945,1 +2004,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1969,1 +2028,1 @@\n-        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (float) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1994,1 +2053,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2018,1 +2077,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (long) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2043,1 +2102,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2067,1 +2126,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (double) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2092,1 +2151,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2122,1 +2181,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (MemorySegment) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2148,1 +2207,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2197,1 +2256,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -2236,1 +2295,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -2311,1 +2370,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":171,"deletions":113,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -38,1 +37,1 @@\n- * @since 20\n+ * @since 22\n@@ -40,1 +39,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Array;\n@@ -31,0 +29,1 @@\n+import java.nio.charset.Charset;\n@@ -33,1 +32,1 @@\n-import java.util.function.Function;\n+\n@@ -35,0 +34,1 @@\n+import jdk.internal.foreign.ArenaImpl;\n@@ -36,2 +36,2 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.foreign.StringSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -73,1 +73,1 @@\n- * @since 19\n+ * @since 22\n@@ -76,1 +76,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -80,1 +79,20 @@\n-     * {@return a new memory segment with a Java string converted into a UTF-8 encoded, null-terminated C string}\n+     * Converts a Java string into a null-terminated C string using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset,\n+     * storing the result into a memory segment.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * allocateFrom(str, StandardCharsets.UTF_8);\n+     *}\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native segment containing the converted C string.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str) {\n+        Objects.requireNonNull(str);\n+        return allocateFrom(str, StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Converts a Java string into a null-terminated C string using the provided charset,\n+     * and storing the result into a memory segment.\n@@ -89,1 +107,1 @@\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n@@ -92,0 +110,4 @@\n+     * @param str     the Java string to be converted into a C string.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @return a new native segment containing the converted C string.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n@@ -93,2 +115,7 @@\n-     * into a new memory segment obtained by calling {@code this.allocate(str.length() + 1)}.\n-     * @param str the Java string to be converted into a C string.\n+     * into a new memory segment obtained by calling {@code this.allocate(B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n@@ -96,1 +123,3 @@\n-    default MemorySegment allocateUtf8String(String str) {\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n@@ -98,1 +127,8 @@\n-        return Utils.toCString(str.getBytes(StandardCharsets.UTF_8), this);\n+        int termCharSize = StringSupport.CharsetKind.of(charset).terminatorCharSize();\n+        byte[] bytes = str.getBytes(charset);\n+        MemorySegment segment = allocateNoInit(bytes.length + termCharSize);\n+        MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        for (int i = 0 ; i < termCharSize ; i++) {\n+            segment.set(ValueLayout.JAVA_BYTE, bytes.length + i, (byte)0);\n+        }\n+        return segment;\n@@ -115,1 +151,1 @@\n-    default MemorySegment allocate(ValueLayout.OfByte layout, byte value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfByte layout, byte value) {\n@@ -117,3 +153,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -137,1 +172,1 @@\n-    default MemorySegment allocate(ValueLayout.OfChar layout, char value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfChar layout, char value) {\n@@ -139,3 +174,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -159,1 +193,1 @@\n-    default MemorySegment allocate(ValueLayout.OfShort layout, short value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfShort layout, short value) {\n@@ -161,3 +195,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -181,1 +214,1 @@\n-    default MemorySegment allocate(ValueLayout.OfInt layout, int value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfInt layout, int value) {\n@@ -183,3 +216,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -203,1 +235,1 @@\n-    default MemorySegment allocate(ValueLayout.OfFloat layout, float value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat layout, float value) {\n@@ -205,3 +237,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -225,1 +256,1 @@\n-    default MemorySegment allocate(ValueLayout.OfLong layout, long value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfLong layout, long value) {\n@@ -227,3 +258,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -247,1 +277,1 @@\n-    default MemorySegment allocate(ValueLayout.OfDouble layout, double value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble layout, double value) {\n@@ -249,3 +279,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -272,1 +301,1 @@\n-    default MemorySegment allocate(AddressLayout layout, MemorySegment value) {\n+    default MemorySegment allocateFrom(AddressLayout layout, MemorySegment value) {\n@@ -275,3 +304,38 @@\n-        MemorySegment seg = allocate(layout);\n-        layout.varHandle().set(seg, value);\n-        return seg;\n+        MemorySegment segment = allocateNoInit(layout);\n+        segment.set(layout, 0, value);\n+        return segment;\n+    }\n+\n+    \/**\n+     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n+     * {@code elementCount*elementLayout.byteSize()} initialized with the contents of the provided {@code source} segment\n+     * as specified by the provided {@code elementLayout} (i.e. byte ordering, alignment and size)}\n+     *\n+     * @implSpec the default implementation for this method calls {@code this.allocate(elementLayout, elementCount)}.\n+     * @param elementLayout the element layout of the allocated array.\n+     * @param source the source segment.\n+     * @param sourceElementLayout the element layout of the source segment.\n+     * @param sourceOffset the starting offset, in bytes, of the source segment.\n+     * @param elementCount the number of elements in the source segment to be copied.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() != sourceElementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if the source segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     * in the source element layout.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code sourceElementLayout.byteAlignment() > sourceElementLayout.byteSize()}.\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#scope() scope} associated with {@code source} is not\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code source.isAccessibleBy(T) == false}.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * sourceElementLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code sourceOffset > source.byteSize() - (elementCount * sourceElementLayout.byteSize())}.\n+     * @throws IndexOutOfBoundsException if either {@code sourceOffset} or {@code elementCount} are {@code < 0}.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source,\n+                                       ValueLayout sourceElementLayout, long sourceOffset, long elementCount) {\n+        Objects.requireNonNull(source);\n+        Objects.requireNonNull(sourceElementLayout);\n+        Objects.requireNonNull(elementLayout);\n+        MemorySegment dest = allocateNoInit(elementLayout, elementCount);\n+        MemorySegment.copy(source, sourceElementLayout, sourceOffset, dest, elementLayout, 0, elementCount);\n+        return dest;\n@@ -285,8 +349,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_BYTE, 0, array.length)\n+     *}\n@@ -294,1 +355,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the byte elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -296,2 +358,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfByte elementLayout, byte... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfByte elementLayout, byte... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_BYTE, 0, elements.length);\n@@ -305,8 +369,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_SHORT, 0, array.length)\n+     *}\n@@ -315,0 +376,1 @@\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -316,2 +378,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfShort elementLayout, short... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfShort elementLayout, short... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_SHORT, 0, elements.length);\n@@ -325,8 +389,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_CHAR, 0, array.length)\n+     *}\n@@ -334,1 +395,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the char elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -336,2 +398,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfChar elementLayout, char... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfChar elementLayout, char... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_CHAR, 0, elements.length);\n@@ -345,8 +409,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_INT, 0, array.length)\n+     *}\n@@ -354,1 +415,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the int elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -356,2 +418,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfInt elementLayout, int... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfInt elementLayout, int... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_INT, 0, elements.length);\n@@ -365,8 +429,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_FLOAT, 0, array.length)\n+     *}\n@@ -374,1 +435,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements the float elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -376,2 +438,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfFloat elementLayout, float... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat elementLayout, float... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_FLOAT, 0, elements.length);\n@@ -385,8 +449,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_LONG, 0, array.length)\n+     *}\n@@ -394,1 +455,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements the long elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -396,2 +458,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfLong elementLayout, long... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfLong elementLayout, long... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_LONG, 0, elements.length);\n@@ -405,8 +469,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_DOUBLE, 0, array.length)\n+     *}\n@@ -414,1 +475,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the double elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -416,13 +478,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfDouble elementLayout, double... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n-                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n-        int size = Array.getLength(Objects.requireNonNull(array));\n-        MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-        if (size > 0) {\n-            MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n-                    seg, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n-        }\n-        return seg;\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble elementLayout, double... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_DOUBLE, 0, elements.length);\n@@ -455,1 +508,1 @@\n-    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+    default MemorySegment allocate(MemoryLayout elementLayout, long count) {\n@@ -528,0 +581,21 @@\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(long byteSize) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(byteSize, 1) :\n+                allocate(byteSize);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize(), layout.byteAlignment()) :\n+                allocate(layout);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout, long size) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize() * size, layout.byteAlignment()) :\n+                allocate(layout, size);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":207,"deletions":133,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -53,1 +52,1 @@\n- * @since 19\n+ * @since 22\n@@ -55,1 +54,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -37,1 +36,1 @@\n- * @since 20\n+ * @since 22\n@@ -39,1 +38,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -122,1 +121,1 @@\n- * @since 19\n+ * @since 22\n@@ -124,1 +123,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -37,1 +36,1 @@\n- * @since 20\n+ * @since 22\n@@ -39,1 +38,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -31,1 +30,0 @@\n-\n@@ -33,1 +31,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -54,1 +51,1 @@\n- * @since 19\n+ * @since 22\n@@ -56,1 +53,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -79,60 +75,0 @@\n-    \/**\n-     * Creates a <em>strided<\/em> var handle that can be used to access a memory segment as multi-dimensional\n-     * array. This array has a notional sequence layout featuring {@code shape.length} nested sequence layouts. The element\n-     * layout of the innermost sequence layout in the notional sequence layout is this value layout. The resulting var handle\n-     * is obtained as if calling the {@link #varHandle(PathElement...)} method on the notional layout, with a layout\n-     * path containing exactly {@code shape.length + 1} {@linkplain PathElement#sequenceElement() open sequence layout path elements}.\n-     * <p>\n-     * For instance, the following method call:\n-     *\n-     * {@snippet lang=java :\n-     * VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n-     * }\n-     *\n-     * Is equivalent to the following code:\n-     *\n-     * {@snippet lang = java:\n-     * SequenceLayout notionalLayout = MemoryLayout.sequenceLayout(\n- *                                         MemoryLayout.sequenceLayout(10, MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n-     * VarHandle arrayHandle = notionalLayout.varHandle(PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement());\n-     *}\n-     *\n-     * The resulting var handle {@code arrayHandle} will feature 3 coordinates of type {@code long}; each coordinate\n-     * is interpreted as an index into the corresponding sequence layout. If we refer to the var handle coordinates, from left\n-     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset accessed by the var handle can be\n-     * computed with the following formula:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = (10 * 20 * 4 * x) + (20 * 4 * y) + (4 * z)\n-     * }<\/pre><\/blockquote>\n-     *\n-     * Additionally, the values of {@code x}, {@code y} and {@code z} are constrained as follows:\n-     * <ul>\n-     *     <li>{@code 0 <= x < notionalLayout.elementCount() }<\/li>\n-     *     <li>{@code 0 <= y < 10 }<\/li>\n-     *     <li>{@code 0 <= z < 20 }<\/li>\n-     * <\/ul>\n-     * <p>\n-     * Consider the following access expressions:\n-     * {@snippet lang=java :\n-     * int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-     * int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-     * }\n-     * In the first case, access is well-formed, as the values for {@code x}, {@code y} and {@code z} conform to\n-     * the bounds specified above. In the second case, access fails with {@link IndexOutOfBoundsException},\n-     * as the value for {@code z} is outside its specified bounds.\n-     *\n-     * @param shape the size of each nested array dimension.\n-     * @return a var handle which can be used to access a memory segment as a multi-dimensional array,\n-     * featuring {@code shape.length + 1}\n-     * {@code long} coordinates.\n-     * @throws IllegalArgumentException if {@code shape[i] < 0}, for at least one index {@code i}.\n-     * @throws UnsupportedOperationException if {@code byteAlignment() > byteSize()}.\n-     * @see MethodHandles#memorySegmentViewVarHandle\n-     * @see MemoryLayout#varHandle(PathElement...)\n-     * @see SequenceLayout\n-     *\/\n-    VarHandle arrayElementVarHandle(int... shape);\n-\n@@ -152,0 +88,1 @@\n+     *\n@@ -157,0 +94,21 @@\n+    \/**\n+     * {@return a var handle which can be used to access values described by this value layout, in a given memory segment.}\n+     * <p>\n+     * The returned var handle's {@linkplain VarHandle#varType() var type} is the {@linkplain ValueLayout#carrier() carrier type} of\n+     * this value layout, and the list of coordinate types is {@code (MemorySegment, long)}, where the memory segment coordinate\n+     * corresponds to the memory segment to be accessed, and the {@code long} coordinate corresponds to the byte offset\n+     * into the accessed memory segment at which the access occurs.\n+     * <p>\n+     * The returned var handle checks that accesses are aligned according to this value layout's\n+     * {@linkplain MemoryLayout#byteAlignment() alignment constraint}.\n+     *\n+     * @apiNote This method is similar, but more efficient, than calling {@code MemoryLayout#varHandle(PathElement...)}\n+     * with an empty path element array, as it avoids the creation of the var args array.\n+     *\n+     * @apiNote The returned var handle features certain <a href=\"MemoryLayout.html#access-mode-restrictions\">access mode\n+     * restrictions<\/a> common to all memory access var handles derived from memory layouts.\n+     *\n+     * @see MemoryLayout#varHandle(PathElement...)\n+     *\/\n+    VarHandle varHandle();\n+\n@@ -161,1 +119,1 @@\n-     * @since 19\n+     * @since 22\n@@ -163,2 +121,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n+        sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n@@ -197,1 +154,1 @@\n-     * @since 19\n+     * @since 22\n@@ -199,2 +156,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n+        sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n@@ -234,1 +190,1 @@\n-     * @since 19\n+     * @since 22\n@@ -236,2 +192,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n+        sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n@@ -271,1 +226,1 @@\n-     * @since 19\n+     * @since 22\n@@ -273,2 +228,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n+        sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n@@ -308,1 +262,1 @@\n-     * @since 19\n+     * @since 22\n@@ -310,2 +264,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n+        sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n@@ -345,1 +298,1 @@\n-     * @since 19\n+     * @since 22\n@@ -347,2 +300,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n+        sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n@@ -381,1 +333,1 @@\n-     * @since 19\n+     * @since 22\n@@ -383,2 +335,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n+        sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n@@ -418,1 +369,1 @@\n-     * @since 19\n+     * @since 22\n@@ -420,2 +371,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n+        sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":39,"deletions":89,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n- *     MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment cString = arena.allocateFrom(\"Hello\");\n@@ -112,1 +112,1 @@\n- * {@linkplain java.lang.foreign.SegmentAllocator#allocateUtf8String(java.lang.String) converting} Java strings into\n+ * {@linkplain java.lang.foreign.SegmentAllocator#allocateFrom(java.lang.String) converting} Java strings into\n@@ -150,1 +150,1 @@\n- * @since 19\n+ * @since 22\n@@ -152,1 +152,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -155,1 +154,0 @@\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-                    MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+                    MemorySegment s = slicingArena.allocateFrom(JAVA_INT, 1, 2, 3, 4, 5);\n@@ -151,1 +151,1 @@\n-                    sequenceLayout(ValueLayout.JAVA_BYTE));\n+                    sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n@@ -171,1 +171,1 @@\n-                MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment str = arena.allocateFrom(\"Hello\");\n@@ -200,1 +200,1 @@\n-                MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+                MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -291,1 +291,1 @@\n-                int res = (int) printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+                int res = (int) printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -316,1 +316,1 @@\n-                int errno = (int) errnoHandle.get(capturedState);\n+                int errno = (int) errnoHandle.get(capturedState, 0L);\n@@ -354,2 +354,2 @@\n-            long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n-            long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+            long offset1 = (long) offsetHandle.invokeExact(0L, 1L); \/\/ 8\n+            long offset2 = (long) offsetHandle.invokeExact(0L, 2L); \/\/ 16\n@@ -399,1 +399,1 @@\n-                VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+                VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -411,2 +411,7 @@\n-                VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-                int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+                MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_INT.withName(\"size\"),\n+                    MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+                );\n+                VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.groupElement(\"data\"),\n+                                                              MemoryLayout.PathElement.sequenceElement());\n+                int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -527,2 +532,0 @@\n-            var byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-                    .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -530,1 +533,1 @@\n-                byteHandle.set(segment.address(), l, value);\n+                segment.set(JAVA_BYTE, l, value);\n@@ -573,1 +576,1 @@\n-                MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment cString = arena.allocateFrom(\"Hello\");\n@@ -657,11 +660,0 @@\n-        void arrayElementVarHandle() {\n-            VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n-\n-            SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(\n-                    MemoryLayout.sequenceLayout(10,\n-                            MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n-\n-            int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-            int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.javac.PreviewFeature;\n@@ -48,4 +46,0 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n@@ -7954,79 +7948,0 @@\n-    \/**\n-     * Creates a var handle object, which can be used to dereference a {@linkplain java.lang.foreign.MemorySegment memory segment}\n-     * at a given byte offset, using the provided value layout.\n-     *\n-     * <p>The provided layout specifies the {@linkplain ValueLayout#carrier() carrier type},\n-     * the {@linkplain ValueLayout#byteSize() byte size},\n-     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n-     * associated with the returned var handle.\n-     *\n-     * <p>The list of coordinate types associated with the returned var handle is {@code (MemorySegment, long)},\n-     * where the {@code long} coordinate type corresponds to byte offset into the given memory segment coordinate.\n-     * Thus, the returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from\n-     * a value of the var handle type. Moreover, the access operation will honor the endianness and the\n-     * alignment constraints expressed in the provided layout.\n-     *\n-     * <p>As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n-     * {@snippet lang=\"java\" :\n-     *     GroupLayout seq = java.lang.foreign.MemoryLayout.structLayout(\n-     *             MemoryLayout.paddingLayout(4),\n-     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n-     *     );\n-     * }\n-     * To access the member layout named {@code value}, we can construct a memory segment view var handle as follows:\n-     * {@snippet lang=\"java\" :\n-     *     VarHandle handle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n-     *     handle = MethodHandles.insertCoordinates(handle, 1, 4); \/\/(MemorySegment) -> int\n-     * }\n-     *\n-     * @apiNote The resulting var handle features certain <i>access mode restrictions<\/i>,\n-     * which are common to all memory segment view var handles. A memory segment view var handle is associated\n-     * with an access size {@code S} and an alignment constraint {@code B}\n-     * (both expressed in bytes). We say that a memory access operation is <em>fully aligned<\/em> if it occurs\n-     * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.\n-     * If access is fully aligned then following access modes are supported and are\n-     * guaranteed to support atomic access:\n-     * <ul>\n-     * <li>read write access modes for all {@code T}, with the exception of\n-     *     access modes {@code get} and {@code set} for {@code long} and\n-     *     {@code double} on 32-bit platforms.\n-     * <li>atomic update access modes for {@code int}, {@code long},\n-     *     {@code float}, {@code double} or {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     types for certain currently unsupported access modes.)\n-     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <\/ul>\n-     *\n-     * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n-     * update access modes compare values using their bitwise representation\n-     * (see {@link Float#floatToRawIntBits},\n-     * {@link Double#doubleToRawLongBits} and {@link MemorySegment#address()}, respectively).\n-     * <p>\n-     * Alternatively, a memory access operation is <em>partially aligned<\/em> if it occurs at a memory address {@code A}\n-     * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the\n-     * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,\n-     * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.\n-     * <p>\n-     * In all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n-     * {@code IllegalStateException} is thrown, irrespective of the access mode being used.\n-     * <p>\n-     * Finally, if {@code T} is {@code MemorySegment} all write access modes throw {@link IllegalArgumentException}\n-     * unless the value to be written is a {@linkplain MemorySegment#isNative() native} memory segment.\n-     *\n-     * @param layout the value layout for which a memory access handle is to be obtained.\n-     * @return the new memory segment view var handle.\n-     * @throws NullPointerException if {@code layout} is {@code null}.\n-     * @see MemoryLayout#varHandle(MemoryLayout.PathElement...)\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static VarHandle memorySegmentViewVarHandle(ValueLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return Utils.makeSegmentViewVarHandle(layout);\n-    }\n-\n@@ -8063,1 +7978,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8065,1 +7980,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8099,1 +8013,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8101,1 +8015,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8131,1 +8044,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8133,1 +8046,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8174,1 +8086,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8176,1 +8088,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8218,1 +8129,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8220,1 +8131,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8244,1 +8154,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8246,1 +8156,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":97,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -59,0 +59,4 @@\n+\n+    static UnsupportedOperationException newUnsupportedAccessModeForAlignment(long alignment) {\n+        return new UnsupportedOperationException(\"Unsupported access mode for alignment: \" + alignment);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static final int VM_ALIGN = $BoxType$.BYTES - 1;\n+    static final int NON_PLAIN_ACCESS_MIN_ALIGN_MASK = $BoxType$.BYTES - 1;\n@@ -107,4 +107,3 @@\n-    static long offset(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);\n-        if ((address & VM_ALIGN) != 0) {\n-            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n+    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+        if ((alignmentMask & NON_PLAIN_ACCESS_MIN_ALIGN_MASK) != NON_PLAIN_ACCESS_MIN_ALIGN_MASK) {\n+            throw VarHandleSegmentViewBase.newUnsupportedAccessModeForAlignment(alignmentMask + 1);\n@@ -112,1 +111,1 @@\n-        return address;\n+        return offsetPlain(bb, offset, alignmentMask);\n@@ -116,1 +115,1 @@\n-    static long offsetNoVMAlignCheck(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n@@ -133,1 +132,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -140,1 +139,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));\n+                offsetPlain(bb, base, handle.alignmentMask));\n@@ -144,1 +143,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -157,1 +156,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -164,1 +163,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -169,1 +168,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -183,1 +182,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -192,1 +191,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -203,1 +202,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -212,1 +211,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -223,1 +222,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -232,1 +231,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -243,1 +242,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -254,1 +253,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -265,1 +264,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -276,1 +275,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -286,1 +285,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -296,1 +295,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -306,1 +305,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -316,1 +315,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -327,1 +326,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -338,1 +337,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -349,1 +348,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -362,1 +361,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -365,1 +364,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -376,1 +375,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -379,1 +378,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -390,1 +389,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -393,1 +392,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -418,1 +417,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -421,1 +420,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -432,1 +431,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -435,1 +434,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -446,1 +445,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -449,1 +448,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -472,1 +471,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -475,1 +474,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -486,1 +485,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -489,1 +488,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -500,1 +499,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -503,1 +502,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -527,1 +526,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -530,1 +529,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -541,1 +540,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -544,1 +543,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -555,1 +554,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -558,1 +557,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":53,"deletions":54,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -1091,1 +1091,1 @@\n-     * @since   19\n+     * @since   22\n@@ -1093,1 +1093,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-                long offsetToThat = this.segmentOffset(that);\n+                long offsetToThat = that.address() - this.address();\n@@ -275,9 +275,0 @@\n-    @Override\n-    public final long segmentOffset(MemorySegment other) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n-        if (unsafeGetBase() == that.unsafeGetBase()) {\n-            return that.unsafeGetOffset() - this.unsafeGetOffset();\n-        }\n-        throw new UnsupportedOperationException(\"Cannot compute offset from native to heap (or vice versa).\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.util.Objects;\n+\n+public final class ArenaImpl implements Arena {\n+\n+    private final MemorySessionImpl session;\n+    private final boolean shouldReserveMemory;\n+    ArenaImpl(MemorySessionImpl session) {\n+        this.session = session;\n+        shouldReserveMemory = session instanceof ImplicitSession;\n+    }\n+\n+    @Override\n+    public Scope scope() {\n+        return session;\n+    }\n+\n+    @Override\n+    public void close() {\n+        session.close();\n+    }\n+\n+    public MemorySegment allocateNoInit(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, session, shouldReserveMemory);\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        MemorySegment segment = allocateNoInit(byteSize, byteAlignment);\n+        return segment.fill((byte)0);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.List;\n@@ -44,0 +45,1 @@\n+import java.util.stream.IntStream;\n@@ -64,0 +66,1 @@\n+    private static final MethodHandle MH_ADD;\n@@ -75,1 +78,1 @@\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n+                    MethodType.methodType(void.class, MemorySegment.class, long.class, MemoryLayout.class));\n@@ -78,0 +81,2 @@\n+            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+                    MethodType.methodType(long.class, long.class, long.class));\n@@ -205,1 +210,1 @@\n-        VarHandle handle = Utils.makeSegmentViewVarHandle(accessedLayout);\n+        VarHandle handle = accessedLayout.varHandle();\n@@ -212,2 +217,6 @@\n-            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n-            handle = MethodHandles.filterCoordinates(handle, 0, checkHandle);\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n+            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n@@ -217,0 +226,4 @@\n+            if (derefAdapters.length > 0) {\n+                \/\/ plug up the base offset if we have at least 1 enclosing dereference\n+                handle = MethodHandles.insertCoordinates(handle, 1, 0);\n+            }\n@@ -218,1 +231,7 @@\n-                handle = MethodHandles.collectCoordinates(handle, 0, derefAdapters[i - 1]);\n+                MethodHandle adapter = derefAdapters[i - 1];\n+                \/\/ the first\/outermost adapter will have a base offset coordinate, the rest are constant 0\n+                if (i > 1) {\n+                    \/\/ plug in a constant 0 base offset for all but the outermost access in a deref chain\n+                    adapter = MethodHandles.insertArguments(adapter, 1, 0);\n+                }\n+                handle = MethodHandles.collectCoordinates(handle, 0, adapter);\n@@ -231,2 +250,2 @@\n-        MethodHandle mh = MethodHandles.identity(long.class);\n-        for (int i = strides.length - 1; i >=0; i--) {\n+        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        for (int i = strides.length - 1; i >= 0; i--) {\n@@ -238,1 +257,1 @@\n-        mh = MethodHandles.insertArguments(mh, 0, offset);\n+\n@@ -256,1 +275,1 @@\n-        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, ...) -> MS\n+        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, long, ...) -> MS\n@@ -259,2 +278,6 @@\n-            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n-            sliceHandle = MethodHandles.filterArguments(sliceHandle, 0, checkHandle);\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            MethodType oldType = sliceHandle.type();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            sliceHandle = MethodHandles.collectArguments(sliceHandle, 0, alignCheck); \/\/ (MS, long, MS, long) -> MS\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, oldType.parameterCount())).toArray();\n+            sliceHandle = MethodHandles.permuteArguments(sliceHandle, oldType, reorder); \/\/ (MS, long, ...) -> MS\n@@ -266,2 +289,2 @@\n-    private static MemorySegment checkAlign(MemorySegment segment, MemoryLayout constraint) {\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(0, constraint)) {\n+    private static void checkAlign(MemorySegment segment, long offset, MemoryLayout constraint) {\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, constraint)) {\n@@ -270,1 +293,0 @@\n-        return segment;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":36,"deletions":14,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -80,11 +80,1 @@\n-        return new Arena() {\n-            @Override\n-            public Scope scope() {\n-                return MemorySessionImpl.this;\n-            }\n-\n-            @Override\n-            public void close() {\n-                MemorySessionImpl.this.close();\n-            }\n-        };\n+        return new ArenaImpl(this);\n@@ -156,5 +146,0 @@\n-    public MemorySegment allocate(long byteSize, long byteAlignment) {\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, this);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -49,1 +48,0 @@\n-    private static final boolean SKIP_ZERO_MEMORY = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.skipZeroMemory\");\n@@ -118,1 +116,2 @@\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl) {\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                  boolean shouldReserve) {\n@@ -127,5 +126,2 @@\n-        NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n-\n-        long buf = UNSAFE.allocateMemory(alignedSize);\n-        if (!SKIP_ZERO_MEMORY) {\n-            UNSAFE.setMemory(buf, alignedSize, (byte)0);\n+        if (shouldReserve) {\n+            NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n@@ -133,0 +129,2 @@\n+\n+        long buf = allocateMemoryWrapper(alignedSize);\n@@ -140,1 +138,3 @@\n-                NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                if (shouldReserve) {\n+                    NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                }\n@@ -150,0 +150,8 @@\n+    private static long allocateMemoryWrapper(long size) {\n+        try {\n+            return UNSAFE.allocateMemory(size);\n+        } catch (IllegalArgumentException ex) {\n+            throw new OutOfMemoryError();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-    private final long maxAlign;\n@@ -40,1 +39,0 @@\n-        this.maxAlign = ((AbstractMemorySegmentImpl)segment).maxAlignMask();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+\/**\n+ * Miscellaneous functions to read and write strings, in various charsets.\n+ *\/\n+public class StringSupport {\n+    public static String read(MemorySegment segment, long offset, Charset charset) {\n+        return switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> readFast_byte(segment, offset, charset);\n+            case DOUBLE_BYTE -> readFast_short(segment, offset, charset);\n+            case QUAD_BYTE -> readFast_int(segment, offset, charset);\n+        };\n+    }\n+\n+    public static void write(MemorySegment segment, long offset, Charset charset, String string) {\n+        switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> writeFast_byte(segment, offset, charset, string);\n+            case DOUBLE_BYTE -> writeFast_short(segment, offset, charset, string);\n+            case QUAD_BYTE -> writeFast_int(segment, offset, charset, string);\n+        }\n+    }\n+    private static String readFast_byte(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_byte(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeFast_byte(MemorySegment segment, long offset, Charset charset, String string) {\n+        byte[] bytes = string.getBytes(charset);\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+        segment.set(JAVA_BYTE, offset + bytes.length, (byte)0);\n+    }\n+\n+    private static String readFast_short(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_short(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeFast_short(MemorySegment segment, long offset, Charset charset, String string) {\n+        byte[] bytes = string.getBytes(charset);\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+        segment.set(JAVA_SHORT, offset + bytes.length, (short)0);\n+    }\n+\n+    private static String readFast_int(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_int(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeFast_int(MemorySegment segment, long offset, Charset charset, String string) {\n+        byte[] bytes = string.getBytes(charset);\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+        segment.set(JAVA_INT, offset + bytes.length, 0);\n+    }\n+\n+    private static int strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int strlen_short(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 2) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int strlen_int(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 4) {\n+            int curr = segment.get(JAVA_INT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    public enum CharsetKind {\n+        SINGLE_BYTE(1),\n+        DOUBLE_BYTE(2),\n+        QUAD_BYTE(4);\n+\n+        final int terminatorCharSize;\n+\n+        CharsetKind(int terminatorCharSize) {\n+            this.terminatorCharSize = terminatorCharSize;\n+        }\n+\n+        public int terminatorCharSize() {\n+            return terminatorCharSize;\n+        }\n+\n+        public static CharsetKind of(Charset charset) {\n+            if (charset == StandardCharsets.UTF_8 || charset == StandardCharsets.ISO_8859_1 || charset == StandardCharsets.US_ASCII) {\n+                return CharsetKind.SINGLE_BYTE;\n+            } else if (charset == StandardCharsets.UTF_16LE || charset == StandardCharsets.UTF_16BE || charset == StandardCharsets.UTF_16) {\n+                return CharsetKind.DOUBLE_BYTE;\n+            } else if (charset == StandardCharsets.UTF_32LE || charset == StandardCharsets.UTF_32BE || charset == StandardCharsets.UTF_32) {\n+                return CharsetKind.QUAD_BYTE;\n+            } else {\n+                throw new UnsupportedOperationException(\"Unsupported charset: \" + charset);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentAllocator;\n@@ -50,1 +49,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -101,0 +99,4 @@\n+\n+            static VarHandle get(ValueLayout layout) {\n+                return HANDLE_MAP.get(layout);\n+            }\n@@ -102,0 +104,8 @@\n+        layout = layout.withoutName(); \/\/ name doesn't matter\n+        \/\/ keep the addressee layout as it's used below\n+\n+        VarHandle handle = VarHandleCache.get(layout);\n+        if (handle != null) {\n+            return handle;\n+        }\n+\n@@ -113,1 +123,1 @@\n-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n+        handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n@@ -152,12 +162,0 @@\n-    public static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n-    }\n-\n-    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1);\n-        copy(addr, bytes);\n-        return addr;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.util.HashSet;\n@@ -76,0 +77,1 @@\n+    private final Set<MemoryLayout> CANONICAL_LAYOUTS_CACHE = new HashSet<>(canonicalLayouts().values());\n@@ -216,1 +218,1 @@\n-    private static void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n+    private void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n@@ -226,1 +228,1 @@\n-    private static void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n+    private void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n@@ -235,1 +237,1 @@\n-    private static void checkSupported(ValueLayout valueLayout) {\n+    private void checkSupported(ValueLayout valueLayout) {\n@@ -240,1 +242,1 @@\n-        if (!SUPPORTED_LAYOUTS.contains(valueLayout.withoutName())) {\n+        if (!CANONICAL_LAYOUTS_CACHE.contains(valueLayout.withoutName())) {\n@@ -245,1 +247,1 @@\n-    private static void checkHasNaturalAlignment(MemoryLayout layout) {\n+    private void checkHasNaturalAlignment(MemoryLayout layout) {\n@@ -276,12 +278,0 @@\n-\n-    private static final Set<MemoryLayout> SUPPORTED_LAYOUTS = Set.of(\n-            ValueLayout.JAVA_BOOLEAN,\n-            ValueLayout.JAVA_BYTE,\n-            ValueLayout.JAVA_CHAR,\n-            ValueLayout.JAVA_SHORT,\n-            ValueLayout.JAVA_INT,\n-            ValueLayout.JAVA_FLOAT,\n-            ValueLayout.JAVA_LONG,\n-            ValueLayout.JAVA_DOUBLE,\n-            ValueLayout.ADDRESS\n-    );\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-        return !linkerOptions.isTrivial();\n+        return !linkerOptions.isCritical();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,5 @@\n-        return new LinkerOptions(optionMap);\n+        LinkerOptions linkerOptions = new LinkerOptions(optionMap);\n+        if (linkerOptions.hasCapturedCallState() && linkerOptions.isCritical()) {\n+            throw new IllegalArgumentException(\"Incompatible linker options: captureCallState, critical\");\n+        }\n+        return linkerOptions;\n@@ -100,3 +104,3 @@\n-    public boolean isTrivial() {\n-        IsTrivial it = getOption(IsTrivial.class);\n-        return it != null;\n+    public boolean isCritical() {\n+        Critical c = getOption(Critical.class);\n+        return c != null;\n@@ -118,1 +122,1 @@\n-            permits CaptureCallState, FirstVariadicArg, IsTrivial {\n+            permits CaptureCallState, FirstVariadicArg, Critical {\n@@ -144,2 +148,2 @@\n-    public record IsTrivial() implements LinkerOptionImpl {\n-        public static IsTrivial INSTANCE = new IsTrivial();\n+    public record Critical() implements LinkerOptionImpl {\n+        public static Critical INSTANCE = new Critical();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n@@ -95,1 +95,1 @@\n-        public MemorySegment allocate(long byteSize) {\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n@@ -254,18 +254,0 @@\n-    public static String toJavaStringInternal(MemorySegment segment, long start) {\n-        int len = strlen(segment, start);\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, start, bytes, 0, len);\n-        return new String(bytes, StandardCharsets.UTF_8);\n-    }\n-\n-    private static int strlen(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"String too large\");\n-    }\n-\n@@ -437,14 +419,0 @@\n-    public static final class SimpleVaArg {\n-        public final MemoryLayout layout;\n-        public final Object value;\n-\n-        public SimpleVaArg(MemoryLayout layout, Object value) {\n-            this.layout = layout;\n-            this.value = value;\n-        }\n-\n-        public VarHandle varHandle() {\n-            return layout.varHandle();\n-        }\n-    }\n-\n@@ -518,0 +486,31 @@\n+\n+    public static Map<String, MemoryLayout> canonicalLayouts(ValueLayout longLayout, ValueLayout sizetLayout, ValueLayout wchartLayout) {\n+        return Map.ofEntries(\n+                \/\/ specified canonical layouts\n+                Map.entry(\"bool\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"char\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"short\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int\", ValueLayout.JAVA_INT),\n+                Map.entry(\"float\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"long\", longLayout),\n+                Map.entry(\"long long\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"double\", ValueLayout.JAVA_DOUBLE),\n+                Map.entry(\"void*\", ValueLayout.ADDRESS),\n+                Map.entry(\"size_t\", sizetLayout),\n+                Map.entry(\"wchar_t\", wchartLayout),\n+                \/\/ unspecified size-dependent layouts\n+                Map.entry(\"int8_t\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"int16_t\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int32_t\", ValueLayout.JAVA_INT),\n+                Map.entry(\"int64_t\", ValueLayout.JAVA_LONG),\n+                \/\/ unspecified JNI layouts\n+                Map.entry(\"jboolean\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"jchar\", ValueLayout.JAVA_CHAR),\n+                Map.entry(\"jbyte\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"jshort\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"jint\", ValueLayout.JAVA_INT),\n+                Map.entry(\"jlong\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"jfloat\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"jdouble\", ValueLayout.JAVA_DOUBLE)\n+        );\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":33,"deletions":34,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -34,0 +35,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -37,0 +40,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n@@ -66,0 +73,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.util.Comparator;\n@@ -47,0 +46,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -61,5 +61,1 @@\n-    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.byteSize()) {\n-            case 8 -> JAVA_LONG;\n-            case 4 -> JAVA_INT;\n-            default -> throw new IllegalStateException(\"Address size not supported: \" + ADDRESS.byteSize());\n-        };\n+    static final ValueLayout SIZE_T = layoutFor((int)ADDRESS.byteSize());\n@@ -72,1 +68,1 @@\n-    private static final VarHandle VH_SIZE_T_ARRAY = SIZE_T.arrayElementVarHandle();\n+    private static final VarHandle VH_SIZE_T = SIZE_T.varHandle();\n@@ -86,2 +82,2 @@\n-        VH_TYPE.set(ffiType, LibFallback.structTag());\n-        VH_ELEMENTS.set(ffiType, elementsSeg);\n+        VH_TYPE.set(ffiType, 0L, LibFallback.structTag());\n+        VH_ELEMENTS.set(ffiType, 0L, elementsSeg);\n@@ -135,1 +131,1 @@\n-                    long ffiOffset = (long) VH_SIZE_T_ARRAY.get(offsetsOut, offsetIdx++);\n+                    long ffiOffset = sizeTAtIndex(offsetsOut, offsetIdx++);\n@@ -146,0 +142,19 @@\n+\n+    static ValueLayout layoutFor(int byteSize) {\n+        return switch (byteSize) {\n+            case 1 -> JAVA_BYTE;\n+            case 2 -> JAVA_SHORT;\n+            case 4 -> JAVA_INT;\n+            case 8 -> JAVA_LONG;\n+            default -> throw new IllegalStateException(\"Unsupported size: \" + byteSize);\n+        };\n+    }\n+\n+    private static long sizeTAtIndex(MemorySegment segment, int index) {\n+        long offset = SIZE_T.scale(0, index);\n+        if (VH_SIZE_T.varType() == long.class) {\n+            return (long) VH_SIZE_T.get(segment, offset);\n+        } else {\n+            return (int) VH_SIZE_T.get(segment, offset); \/\/ 'erase' to long\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.HashMap;\n@@ -49,0 +50,1 @@\n+import java.util.Map;\n@@ -52,0 +54,8 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -286,0 +296,40 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n+\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS;\n+\n+    static {\n+        int wchar_size = LibFallback.wcharSize();\n+        MemoryLayout wchartLayout = switch(wchar_size) {\n+            case 2 -> JAVA_CHAR; \/\/ prefer JAVA_CHAR\n+            default -> FFIType.layoutFor(wchar_size);\n+        };\n+\n+        CANONICAL_LAYOUTS = Map.ofEntries(\n+                \/\/ specified canonical layouts\n+                Map.entry(\"bool\", JAVA_BOOLEAN),\n+                Map.entry(\"char\", JAVA_BYTE),\n+                Map.entry(\"float\", JAVA_FLOAT),\n+                Map.entry(\"long long\", JAVA_LONG),\n+                Map.entry(\"double\", JAVA_DOUBLE),\n+                Map.entry(\"void*\", ADDRESS),\n+                \/\/ platform-dependent sizes\n+                Map.entry(\"size_t\", FFIType.SIZE_T),\n+                Map.entry(\"short\", FFIType.layoutFor(LibFallback.shortSize())),\n+                Map.entry(\"int\", FFIType.layoutFor(LibFallback.intSize())),\n+                Map.entry(\"long\", FFIType.layoutFor(LibFallback.longSize())),\n+                Map.entry(\"wchar_t\", wchartLayout),\n+                \/\/ JNI types\n+                Map.entry(\"jboolean\", JAVA_BOOLEAN),\n+                Map.entry(\"jchar\", JAVA_CHAR),\n+                Map.entry(\"jbyte\", JAVA_BYTE),\n+                Map.entry(\"jshort\", JAVA_SHORT),\n+                Map.entry(\"jint\", JAVA_INT),\n+                Map.entry(\"jlong\", JAVA_LONG),\n+                Map.entry(\"jfloat\", JAVA_FLOAT),\n+                Map.entry(\"jdouble\", JAVA_DOUBLE)\n+        );\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -62,0 +62,6 @@\n+    \/\/ platform-dependent types\n+    static int shortSize() { return NativeConstants.SIZEOF_SHORT; }\n+    static int intSize() { return NativeConstants.SIZEOF_INT; }\n+    static int longSize() {return NativeConstants.SIZEOF_LONG; }\n+    static int wcharSize() {return NativeConstants.SIZEOF_WCHAR; }\n+\n@@ -219,0 +225,4 @@\n+    private static native int ffi_sizeof_short();\n+    private static native int ffi_sizeof_int();\n+    private static native int ffi_sizeof_long();\n+    private static native int ffi_sizeof_wchar();\n@@ -236,0 +246,5 @@\n+        static final int SIZEOF_SHORT = ffi_sizeof_short();\n+        static final int SIZEOF_INT = ffi_sizeof_int();\n+        static final int SIZEOF_LONG = ffi_sizeof_long();\n+        static final int SIZEOF_WCHAR = ffi_sizeof_wchar();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+        SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -35,0 +36,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -38,0 +41,1 @@\n+import java.util.Map;\n@@ -41,0 +45,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -67,0 +74,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -32,0 +33,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,0 +38,1 @@\n+import java.util.Map;\n@@ -38,0 +42,3 @@\n+    private static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -64,0 +71,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -32,0 +33,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,0 +38,1 @@\n+import java.util.Map;\n@@ -41,0 +45,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -67,0 +74,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -31,0 +32,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -34,0 +37,1 @@\n+import java.util.Map;\n@@ -40,0 +44,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n+\n@@ -66,0 +73,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n- *\n- * @since 19\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -57,1 +58,1 @@\n-        return dup(byteAlignment(), Optional.empty());\n+        return name.isPresent() ? dup(byteAlignment(), Optional.empty()) : (L) this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -36,0 +35,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -38,1 +38,0 @@\n-import java.lang.foreign.AddressLayout;\n@@ -42,2 +41,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -118,18 +115,0 @@\n-        public final VarHandle arrayElementVarHandle(int... shape) {\n-            Objects.requireNonNull(shape);\n-            if (!Utils.isElementAligned((ValueLayout) this)) {\n-                throw new UnsupportedOperationException(\"Layout alignment greater than its size\");\n-            }\n-            MemoryLayout layout = self();\n-            List<MemoryLayout.PathElement> path = new ArrayList<>();\n-            for (int i = shape.length; i > 0; i--) {\n-                int size = shape[i - 1];\n-                if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n-                layout = MemoryLayout.sequenceLayout(size, layout);\n-                path.add(MemoryLayout.PathElement.sequenceElement());\n-            }\n-            layout = MemoryLayout.sequenceLayout(layout);\n-            path.add(MemoryLayout.PathElement.sequenceElement());\n-            return layout.varHandle(path.toArray(new MemoryLayout.PathElement[0]));\n-        }\n-\n@@ -180,1 +159,1 @@\n-        public final VarHandle accessHandle() {\n+        public final VarHandle varHandle() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \/\/ not used\n+        \/\/ not used, but required for interim javac to not warn.\n@@ -69,1 +69,0 @@\n-        @JEP(number=442, title=\"Foreign Function & Memory API\", status=\"Third Preview\")\n@@ -71,0 +70,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.access.JavaLangAccess;\n@@ -118,1 +119,4 @@\n-        SharedSecrets.getJavaLangAccess().ensureNativeAccess(module, owner, methodName);\n+        class Holder {\n+            static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+        }\n+        Holder.JLA.ensureNativeAccess(module, owner, methodName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <wchar.h>\n@@ -209,0 +210,20 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1short(JNIEnv* env, jclass cls) {\n+  return sizeof(short);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1int(JNIEnv* env, jclass cls) {\n+  return sizeof(int);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1long(JNIEnv* env, jclass cls) {\n+  return sizeof(long);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1wchar(JNIEnv* env, jclass cls) {\n+  return sizeof(wchar_t);\n+}\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * @compile --enable-preview -source ${jdk.version} TestRangeCheckHoistingScaledIV.java\n- * @run main\/othervm --enable-preview compiler.rangechecks.TestRangeCheckHoistingScaledIV\n+ * @compile -source ${jdk.version} TestRangeCheckHoistingScaledIV.java\n+ * @run main\/othervm compiler.rangechecks.TestRangeCheckHoistingScaledIV\n@@ -86,1 +86,1 @@\n-                \"--enable-preview\", \"--add-modules\", \"jdk.incubator.vector\",\n+                \"--add-modules\", \"jdk.incubator.vector\",\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestIntrinsicBailOut.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                                    \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -46,1 +46,1 @@\n-                                    \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -51,1 +51,1 @@\n-                                    \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -57,1 +57,1 @@\n-                                    \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -62,1 +62,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\")\n@@ -69,1 +69,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -76,1 +76,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorErgonomics.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n- * @enablePreview\n@@ -51,1 +50,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRebracket128Test.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX1.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX2.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512BW.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512DQ.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastNeon.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastSVE.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorReinterpret.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        test.addFlags(\"--add-modules=jdk.incubator.vector\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\", \"--enable-preview\");\n+        test.addFlags(\"--add-modules=jdk.incubator.vector\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private static final Class<?> PREVIEW_API = java.lang.foreign.MemorySegment.class;\n+    private static final Class<?> PREVIEW_API = java.lang.ScopedValue.class;\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassFileVersionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/CompositeLookupTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+    public static final Linker LINKER = Linker.nativeLinker();\n+\n@@ -94,1 +96,1 @@\n-    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) LINKER.canonicalLayouts().get(\"bool\");\n@@ -98,1 +100,1 @@\n-    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfByte C_CHAR = (ValueLayout.OfByte) LINKER.canonicalLayouts().get(\"char\");\n@@ -102,1 +104,1 @@\n-    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) LINKER.canonicalLayouts().get(\"short\");\n@@ -106,1 +108,1 @@\n-    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) LINKER.canonicalLayouts().get(\"int\");\n@@ -111,1 +113,1 @@\n-    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) LINKER.canonicalLayouts().get(\"long long\");\n@@ -115,1 +117,1 @@\n-    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) LINKER.canonicalLayouts().get(\"float\");\n@@ -119,1 +121,1 @@\n-    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) LINKER.canonicalLayouts().get(\"double\");\n@@ -123,4 +125,21 @@\n-    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n-            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n-\n-    public static final Linker LINKER = Linker.nativeLinker();\n+    public static final AddressLayout C_POINTER = ((AddressLayout) LINKER.canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n+    \/**\n+     * The layout for the {@code size_t} C type\n+     *\/\n+    public static final ValueLayout C_SIZE_T = (ValueLayout) LINKER.canonicalLayouts().get(\"size_t\");\n+\n+    \/\/ Common layout shared by some tests\n+    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n+    public static final MemoryLayout S_PDI_LAYOUT = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n+        case 8 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"),\n+            MemoryLayout.paddingLayout(4));\n+        case 4 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"));\n+        default -> throw new UnsupportedOperationException(\"Unsupported address size\");\n+    };\n@@ -251,2 +270,2 @@\n-            accessor.set(container, fieldValue.value());\n-            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual));\n+            accessor.set(container, 0L, fieldValue.value());\n+            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual, 0L));\n@@ -260,1 +279,1 @@\n-                return (MemorySegment) slicer.invokeExact(container);\n+                return (MemorySegment) slicer.invokeExact(container, 0L);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -54,1 +52,0 @@\n-@Test\n@@ -124,2 +121,5 @@\n-        String formatArgs = args.stream()\n-                .map(a -> a.format)\n+        String javaFormatArgs = args.stream()\n+                .map(a -> a.javaFormat)\n+                .collect(Collectors.joining(\",\"));\n+        String nativeFormatArgs = args.stream()\n+                .map(a -> a.nativeFormat)\n@@ -128,1 +128,2 @@\n-        String formatString = \"hello(\" + formatArgs + \")\\n\";\n+        String javaFormatString = \"hello(\" + javaFormatArgs + \")\\n\";\n+        String nativeFormatString = \"hello(\" + nativeFormatArgs + \")\\n\";\n@@ -130,1 +131,1 @@\n-        String expected = String.format(formatString, args.stream()\n+        String expected = String.format(javaFormatString, args.stream()\n@@ -133,1 +134,1 @@\n-        int found = stdLibHelper.printf(formatString, args);\n+        int found = stdLibHelper.printf(nativeFormatString, args);\n@@ -159,0 +160,1 @@\n+        \/\/ void qsort( void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *) );\n@@ -160,1 +162,1 @@\n-                FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER));\n+                FunctionDescriptor.ofVoid(C_POINTER, C_SIZE_T, C_SIZE_T, C_POINTER));\n@@ -190,3 +192,3 @@\n-                buf.setUtf8String(0, s1);\n-                MemorySegment other = arena.allocateUtf8String(s2);\n-                return ((MemorySegment)strcat.invokeExact(buf, other)).getUtf8String(0);\n+                buf.setString(0, s1);\n+                MemorySegment other = arena.allocateFrom(s2);\n+                return ((MemorySegment)strcat.invokeExact(buf, other)).getString(0);\n@@ -198,2 +200,2 @@\n-                MemorySegment ns1 = arena.allocateUtf8String(s1);\n-                MemorySegment ns2 = arena.allocateUtf8String(s2);\n+                MemorySegment ns1 = arena.allocateFrom(s1);\n+                MemorySegment ns2 = arena.allocateFrom(s2);\n@@ -206,1 +208,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateFrom(msg);\n@@ -213,1 +215,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateFrom(msg);\n@@ -280,1 +282,1 @@\n-                MemorySegment nativeArr = arena.allocateArray(C_INT, arr);\n+                MemorySegment nativeArr = arena.allocateFrom(C_INT, arr);\n@@ -285,1 +287,5 @@\n-                qsort.invokeExact(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                \/\/ both of these fit in an int\n+                \/\/ automatically widen them to long on x64\n+                int count = arr.length;\n+                int size = (int) C_INT.byteSize();\n+                qsort.invoke(nativeArr, count, size, qsortUpcallStub);\n@@ -303,1 +309,1 @@\n-                MemorySegment formatStr = arena.allocateUtf8String(format);\n+                MemorySegment formatStr = arena.allocateFrom(format);\n@@ -381,4 +387,4 @@\n-        INT(int.class, C_INT, \"%d\", arena -> 42, 42),\n-        LONG(long.class, C_LONG_LONG, \"%d\", arena -> 84L, 84L),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena -> 1.2345d, 1.2345d),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateUtf8String(\"str\"), \"str\");\n+        INT(int.class, C_INT, \"%d\", \"%d\", arena -> 42, 42),\n+        LONG(long.class, C_LONG_LONG, \"%lld\", \"%d\", arena -> 84L, 84L),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", \"%.4f\", arena -> 1.2345d, 1.2345d),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", \"%s\", arena -> arena.allocateFrom(\"str\"), \"str\");\n@@ -388,1 +394,2 @@\n-        final String format;\n+        final String nativeFormat;\n+        final String javaFormat;\n@@ -392,1 +399,2 @@\n-        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String nativeFormat, String javaFormat,\n+                                             Function<Arena, Z> nativeValueFactory, Object javaValue) {\n@@ -395,1 +403,2 @@\n-            this.format = format;\n+            this.nativeFormat = nativeFormat;\n+            this.javaFormat = javaFormat;\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":35,"deletions":26,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ *\/\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.VarHandle.AccessMode;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+public class TestAccessModes {\n+\n+    @Test(dataProvider = \"segmentsAndLayoutsAndModes\")\n+    public void testAccessModes(MemorySegment segment, ValueLayout layout, AccessMode mode) throws Throwable {\n+        VarHandle varHandle = layout.varHandle();\n+        MethodHandle methodHandle = varHandle.toMethodHandle(mode);\n+        boolean compatible = AccessModeKind.supportedModes(layout).contains(AccessModeKind.of(mode));\n+        try {\n+            Object o = methodHandle.invokeWithArguments(makeArgs(segment, varHandle.accessModeType(mode)));\n+            assertTrue(compatible);\n+        } catch (UnsupportedOperationException ex) {\n+            assertFalse(compatible);\n+        } catch (IllegalArgumentException ex) {\n+            \/\/ access is unaligned, but access mode is supported\n+            assertTrue(compatible);\n+        }\n+    }\n+\n+    Object[] makeArgs(MemorySegment segment, MethodType type) throws Throwable {\n+        List<Object> args = new ArrayList<>();\n+        args.add(segment);\n+        for (Class argType : type.dropParameterTypes(0, 1).parameterList()) {\n+            args.add(defaultValue(argType));\n+        }\n+        return args.toArray();\n+    }\n+\n+    Object defaultValue(Class<?> clazz) throws Throwable {\n+        if (clazz == MemorySegment.class) {\n+            return MemorySegment.NULL;\n+        } else if (clazz.isPrimitive()) {\n+            return MethodHandles.zero(clazz).invoke();\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/*\n+     * See the javadoc of MemoryLayout::varHandle.\n+     *\/\n+    enum AccessModeKind {\n+        PLAIN,\n+        READ_WRITE,\n+        ATOMIC_UPDATE,\n+        ATOMIC_NUMERIC_UPDATE,\n+        ATOMIC_BITWISE_UPDATE;\n+\n+        static AccessModeKind of(AccessMode mode) {\n+            return switch (mode) {\n+                case GET, SET -> PLAIN;\n+                case GET_ACQUIRE, GET_OPAQUE, GET_VOLATILE, SET_VOLATILE,\n+                        SET_OPAQUE, SET_RELEASE -> READ_WRITE;\n+                case GET_AND_SET, GET_AND_SET_ACQUIRE, GET_AND_SET_RELEASE,\n+                        WEAK_COMPARE_AND_SET, WEAK_COMPARE_AND_SET_RELEASE,\n+                        WEAK_COMPARE_AND_SET_ACQUIRE, WEAK_COMPARE_AND_SET_PLAIN,\n+                        COMPARE_AND_EXCHANGE, COMPARE_AND_EXCHANGE_ACQUIRE,\n+                        COMPARE_AND_EXCHANGE_RELEASE, COMPARE_AND_SET -> ATOMIC_UPDATE;\n+                case GET_AND_ADD, GET_AND_ADD_ACQUIRE, GET_AND_ADD_RELEASE -> ATOMIC_NUMERIC_UPDATE;\n+                default -> ATOMIC_BITWISE_UPDATE;\n+            };\n+        }\n+\n+        static Set<AccessModeKind> supportedModes(ValueLayout layout) {\n+            Set<AccessModeKind> supportedModes = EnumSet.noneOf(AccessModeKind.class);\n+            supportedModes.add(PLAIN);\n+            if (layout.byteAlignment() >= layout.byteSize()) {\n+                supportedModes.add(READ_WRITE);\n+                if (layout instanceof ValueLayout.OfInt || layout instanceof ValueLayout.OfLong ||\n+                        layout instanceof ValueLayout.OfFloat || layout instanceof ValueLayout.OfDouble ||\n+                        layout instanceof AddressLayout) {\n+                    supportedModes.add(ATOMIC_UPDATE);\n+                }\n+                if (layout instanceof ValueLayout.OfInt || layout instanceof ValueLayout.OfLong ||\n+                        layout instanceof AddressLayout) {\n+                    supportedModes.add(ATOMIC_NUMERIC_UPDATE);\n+                    supportedModes.add(ATOMIC_BITWISE_UPDATE);\n+                }\n+            }\n+            return supportedModes;\n+        }\n+    }\n+\n+    static MemoryLayout[] layouts() {\n+        MemoryLayout[] valueLayouts = {\n+                ValueLayout.JAVA_BOOLEAN,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_SHORT,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_FLOAT,\n+                ValueLayout.JAVA_LONG,\n+                ValueLayout.JAVA_DOUBLE,\n+                ValueLayout.ADDRESS\n+        };\n+        List<MemoryLayout> layouts = new ArrayList<>();\n+        for (MemoryLayout layout : valueLayouts) {\n+            for (int align : new int[] { 1, 2, 4, 8 }) {\n+                layouts.add(layout.withByteAlignment(align));\n+            }\n+        }\n+        return layouts.toArray(new MemoryLayout[0]);\n+    }\n+\n+    static MemorySegment[] segments() {\n+        return new MemorySegment[]{\n+                Arena.ofAuto().allocate(8),\n+                MemorySegment.ofArray(new byte[8]),\n+                MemorySegment.ofArray(new char[4]),\n+                MemorySegment.ofArray(new short[4]),\n+                MemorySegment.ofArray(new int[2]),\n+                MemorySegment.ofArray(new float[2]),\n+                MemorySegment.ofArray(new long[1]),\n+                MemorySegment.ofArray(new double[1])\n+        };\n+    }\n+\n+    @DataProvider(name = \"segmentsAndLayoutsAndModes\")\n+    static Object[][] segmentsAndLayoutsAndModes() {\n+        List<Object[]> segmentsAndLayouts = new ArrayList<>();\n+        for (MemorySegment segment : segments()) {\n+            for (MemoryLayout layout : layouts()) {\n+                for (AccessMode mode : AccessMode.values()) {\n+                    segmentsAndLayouts.add(new Object[]{segment, layout, mode});\n+                }\n+            }\n+        }\n+        return segmentsAndLayouts.toArray(new Object[0][]);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -86,1 +85,2 @@\n-    static final VarHandle intHandleIndexed = ValueLayout.JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle intHandleIndexed = MethodHandles.collectCoordinates(ValueLayout.JAVA_INT.varHandle(),\n+            1, MethodHandles.insertArguments(ValueLayout.JAVA_INT.scaleHandle(), 0, 0L));\n@@ -88,1 +88,1 @@\n-    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n+    static final VarHandle intHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_INT.varHandle(), 1, 0L);\n@@ -90,1 +90,1 @@\n-    static final VarHandle floatHandle = ValueLayout.JAVA_FLOAT.varHandle();\n+    static final VarHandle floatHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_FLOAT.varHandle(), 1, 0L);\n@@ -99,2 +99,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -102,1 +102,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -104,1 +104,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -106,1 +106,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -108,1 +108,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -120,3 +120,3 @@\n-        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 1, \"a\", \"b\");\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 2, \"a\", \"b\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -124,1 +124,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -126,1 +126,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -128,1 +128,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -130,1 +130,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -141,2 +141,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -144,1 +144,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -146,1 +146,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -148,1 +148,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -150,1 +150,1 @@\n-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -197,2 +197,2 @@\n-            vh.set(seg, \"42\");\n-            String x = (String) vh.get(seg); \/\/ should throw\n+            vh.set(seg, 0L, \"42\");\n+            String x = (String) vh.get(seg, 0L); \/\/ should throw\n@@ -208,1 +208,1 @@\n-            vh.set(seg, \"42\"); \/\/ should throw\n+            vh.set(seg, 0L, \"42\"); \/\/ should throw\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -43,0 +41,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -187,0 +187,2 @@\n+        private static final Pattern LAYOUT_PATTERN = Pattern.compile(\"^(?<align>\\\\d+%)?(?<char>[azcsifjdAZCSIFJD])\\\\d+$\");\n+\n@@ -188,11 +190,14 @@\n-            return switch (layoutString.charAt(0)) {\n-                case 'A','a' -> ADDRESS;\n-                case 'z','Z' -> BOOL;\n-                case 'c','C' -> CHAR;\n-                case 's','S' -> SHORT;\n-                case 'i','I' -> INT;\n-                case 'f','F' -> FLOAT;\n-                case 'j','J' -> LONG;\n-                case 'd','D' -> DOUBLE;\n-                default -> throw new AssertionError(\"Invalid layout string: \" + layoutString);\n-            };\n+            Matcher matcher = LAYOUT_PATTERN.matcher(layoutString);\n+            if (matcher.matches()) {\n+                switch (matcher.group(\"char\")) {\n+                    case \"A\",\"a\": return ADDRESS;\n+                    case \"z\",\"Z\": return BOOL;\n+                    case \"c\",\"C\": return CHAR;\n+                    case \"s\",\"S\": return SHORT;\n+                    case \"i\",\"I\": return INT;\n+                    case \"f\",\"F\": return FLOAT;\n+                    case \"j\",\"J\": return LONG;\n+                    case \"d\",\"D\": return DOUBLE;\n+                };\n+            }\n+            throw new AssertionError(\"Invalid layout string: \" + layoutString);\n","filename":"test\/jdk\/java\/foreign\/TestAddressDereference.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -30,0 +29,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -32,0 +32,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -291,0 +294,5 @@\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.collectCoordinates(layout.varHandle(),\n+                1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+    }\n+\n@@ -292,2 +300,2 @@\n-        VarHandle indexedHandleNO = helper.elementLayout.withOrder(NATIVE_ORDER).arrayElementVarHandle();\n-        VarHandle indexedHandleNNO = helper.elementLayout.withOrder(NON_NATIVE_ORDER).arrayElementVarHandle();\n+        VarHandle indexedHandleNO = arrayVarHandle(helper.elementLayout.withOrder(NATIVE_ORDER));\n+        VarHandle indexedHandleNNO = arrayVarHandle(helper.elementLayout.withOrder(NON_NATIVE_ORDER));\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -34,0 +33,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -147,1 +149,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -149,1 +151,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -151,1 +153,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -153,1 +155,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -155,1 +157,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -157,1 +159,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -159,1 +161,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -162,1 +164,1 @@\n-                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, 0L, pos));\n@@ -164,1 +166,1 @@\n-                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, 0L, pos));\n@@ -166,1 +168,1 @@\n-                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, 0L, pos));\n@@ -168,1 +170,1 @@\n-                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, 0L, pos));\n@@ -170,1 +172,1 @@\n-                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, 0L, pos));\n@@ -172,1 +174,1 @@\n-                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, 0L, pos));\n@@ -174,1 +176,1 @@\n-                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, 0L, pos));\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -125,2 +124,2 @@\n-            indexHandle.set(base, i, (int)i);\n-            valueHandle.set(base, i, (float)(i \/ 500f));\n+            indexHandle.set(base, 0L, i, (int)i);\n+            valueHandle.set(base, 0L, i, (float)(i \/ 500f));\n@@ -134,2 +133,2 @@\n-            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, i));\n-            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, i));\n+            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, 0L, i));\n+            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, 0L, i));\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -76,1 +75,1 @@\n-            int val = (int) abcx.get(a);\n+            int val = (int) abcx.get(a, 0L);\n@@ -101,2 +100,2 @@\n-            MemorySegment b = arena.allocateArray(B, 2);\n-            MemorySegment c = arena.allocateArray(C, 4);\n+            MemorySegment b = arena.allocate(B, 2);\n+            MemorySegment c = arena.allocate(C, 4);\n@@ -112,1 +111,1 @@\n-            int val00 = (int) abcx_multi.get(a, 0, 0); \/\/ a->b[0]->c[0] = 1\n+            int val00 = (int) abcx_multi.get(a, 0L, 0, 0); \/\/ a->b[0]->c[0] = 1\n@@ -114,1 +113,1 @@\n-            int val10 = (int) abcx_multi.get(a, 1, 0); \/\/ a->b[1]->c[0] = 3\n+            int val10 = (int) abcx_multi.get(a, 0L, 1, 0); \/\/ a->b[1]->c[0] = 3\n@@ -116,1 +115,1 @@\n-            int val01 = (int) abcx_multi.get(a, 0, 1); \/\/ a->b[0]->c[1] = 2\n+            int val01 = (int) abcx_multi.get(a, 0L, 0, 1); \/\/ a->b[0]->c[1] = 2\n@@ -118,1 +117,1 @@\n-            int val11 = (int) abcx_multi.get(a, 1, 1); \/\/ a->b[1]->c[1] = 4\n+            int val11 = (int) abcx_multi.get(a, 0L, 1, 1); \/\/ a->b[1]->c[1] = 4\n@@ -155,1 +154,1 @@\n-            vhX.set(segment, 42); \/\/ should throw\n+            vhX.set(segment, 0L, 42); \/\/ should throw\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestFallbackLookup.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -42,1 +41,1 @@\n-        assertEquals(str, addr.getUtf8String(0));\n+        assertEquals(str, addr.getString(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestHFA.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -48,2 +46,2 @@\n-        assertAligned(align, layout, () -> layout.varHandle().get(segment));\n-        assertAligned(align, layout, () -> layout.varHandle().set(segment, val));\n+        assertAligned(align, layout, () -> layout.varHandle().get(segment, 0L));\n+        assertAligned(align, layout, () -> layout.varHandle().set(segment, 0L, val));\n@@ -51,2 +49,2 @@\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L));\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, val));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L, 0L));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, 0L, val));\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -50,0 +48,2 @@\n+import static java.lang.foreign.ValueLayout.*;\n+\n@@ -105,1 +105,1 @@\n-            { Linker.Option.isTrivial() },\n+            { Linker.Option.critical() },\n@@ -131,1 +131,1 @@\n-                    IS_LE ? \"Unsupported layout: 2%a8\" : \"Unsupported layout: 2%A8\"\n+                    (IS_LE ? \"Unsupported layout: 2%a\" : \"Unsupported layout: 2%A\")  + ADDRESS.byteSize()\n@@ -159,1 +159,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(1,\n@@ -184,1 +184,1 @@\n-                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(C_INT.withOrder(nonNativeOrder())))),\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(1, C_INT.withOrder(nonNativeOrder())))),\n@@ -188,7 +188,0 @@\n-            {\n-                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n-                            ValueLayout.JAVA_LONG,\n-                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n-                    NO_OPTIONS,\n-                    \"has unexpected size\"\n-            },\n@@ -202,0 +195,5 @@\n+            {\n+                    FunctionDescriptor.ofVoid(),\n+                    new Linker.Option[]{Linker.Option.critical(), Linker.Option.captureCallState(\"errno\")},\n+                    \"Incompatible linker options: captureCallState, critical\"\n+            },\n@@ -215,1 +213,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ C_INT.byteSize(),\n@@ -222,0 +220,9 @@\n+        if (ValueLayout.JAVA_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_LONG,\n+                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                    NO_OPTIONS,\n+                    \"has unexpected size\"\n+            });\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -45,0 +44,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -154,1 +154,1 @@\n-                vhX.set(seg, (short) 42);\n+                vhX.set(seg, 0L, (short) 42);\n@@ -160,1 +160,1 @@\n-                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg);\n+                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg, 0L);\n@@ -274,1 +274,1 @@\n-        long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n+        long actualByteOffset = (long) byteOffsetHandle.invokeExact(0L, indexes);\n@@ -363,1 +363,1 @@\n-            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, indexes);\n+            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, 0L, indexes);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -101,1 +100,1 @@\n-                indexHandle.set(segment, (long)i, i);\n+                indexHandle.set(segment, 0L, (long)i, i);\n@@ -106,2 +105,2 @@\n-                int expected = (int)indexHandle.get(segment, (long)i);\n-                int found = (int)preindexHandle.get(segment);\n+                int expected = (int)indexHandle.get(segment, 0L, (long)i);\n+                int found = (int)preindexHandle.get(segment, 0L);\n@@ -204,6 +203,1 @@\n-    @Test(dataProvider = \"basicLayouts\")\n-    public void testSequenceInferredCount(MemoryLayout layout) {\n-        assertEquals(MemoryLayout.sequenceLayout(layout),\n-                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.byteSize(), layout));\n-    }\n-\n+    @Test\n@@ -303,1 +297,1 @@\n-        MemoryLayout.sequenceLayout(layout);\n+        MemoryLayout.sequenceLayout(1, layout);\n@@ -310,1 +304,1 @@\n-            MemoryLayout.sequenceLayout(layout);\n+            MemoryLayout.sequenceLayout(1, layout);\n@@ -341,8 +335,0 @@\n-    @Test(dataProvider=\"layoutsAndAlignments\")\n-    public void testArrayElementVarHandleBadAlignment(MemoryLayout layout, long byteAlign) {\n-        if (layout instanceof ValueLayout) {\n-            assertThrows(UnsupportedOperationException.class, () ->\n-                    ((ValueLayout) layout).withByteAlignment(byteAlign * 2).arrayElementVarHandle());\n-        }\n-    }\n-\n@@ -362,0 +348,31 @@\n+    @Test\n+    public void testVarHandleCaching() {\n+        assertSame(JAVA_INT.varHandle(), JAVA_INT.varHandle());\n+        assertSame(JAVA_INT.withName(\"foo\").varHandle(), JAVA_INT.varHandle());\n+\n+        assertNotSame(JAVA_INT_UNALIGNED.varHandle(), JAVA_INT.varHandle());\n+        assertNotSame(ADDRESS.withTargetLayout(JAVA_INT).varHandle(), ADDRESS.varHandle());\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative offset.*\")\n+    public void testScaleNegativeOffset() {\n+        JAVA_INT.scale(-1, 0);\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative index.*\")\n+    public void testScaleNegativeIndex() {\n+        JAVA_INT.scale(0, -1);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleAddOverflow() {\n+        JAVA_INT.scale(Long.MAX_VALUE, 1);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleMultiplyOverflow() {\n+        JAVA_INT.scale(0, Long.MAX_VALUE);\n+    }\n+\n@@ -499,1 +516,0 @@\n-                MemoryLayout.sequenceLayout(JAVA_INT),\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":37,"deletions":21,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -38,0 +36,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -46,0 +46,1 @@\n+import static org.testng.Assert.assertNotNull;\n@@ -48,0 +49,1 @@\n+import static org.testng.Assert.assertTrue;\n@@ -92,4 +94,0 @@\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) },\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) },\n@@ -114,0 +112,6 @@\n+        if (C_LONG_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) });\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) });\n+        }\n@@ -141,0 +145,28 @@\n+    @Test(dataProvider = \"canonicalTypeNames\")\n+    public void testCanonicalLayouts(String typeName) {\n+        MemoryLayout layout = LINKER.canonicalLayouts().get(typeName);\n+        assertNotNull(layout);\n+        assertTrue(layout instanceof ValueLayout);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] canonicalTypeNames() {\n+        return new Object[][]{\n+                { \"bool\" },\n+                { \"char\" },\n+                { \"short\" },\n+                { \"int\" },\n+                { \"long\" },\n+                { \"long long\" },\n+                { \"float\" },\n+                { \"double\" },\n+                { \"void*\" },\n+                { \"size_t\" },\n+                { \"wchar_t\" },\n+        };\n+    }\n+\n+    @Test(expectedExceptions=UnsupportedOperationException.class)\n+    public void testCanonicalLayoutsUnmodifiable() {\n+        LINKER.canonicalLayouts().put(\"asdf\", C_INT);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -48,2 +46,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -61,2 +57,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -74,2 +68,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -87,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -99,2 +89,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -111,2 +99,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -123,2 +109,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -135,2 +119,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -148,2 +130,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -161,2 +141,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -174,2 +152,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -187,2 +163,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -200,2 +174,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -213,2 +185,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -226,2 +196,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -239,2 +207,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -252,2 +218,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -265,2 +229,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -278,2 +240,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -292,2 +252,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -69,6 +68,0 @@\n-    @Test(dataProvider = \"arrayElements\")\n-    public void testArrayAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, ArrayChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\"));\n-        testArrayAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(), checker);\n-    }\n-\n@@ -161,7 +154,0 @@\n-    @Test(dataProvider = \"matrixElements\")\n-    public void testMatrixAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, MatrixChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(20,\n-                MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\")));\n-        testMatrixAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(10), checker);\n-    }\n-\n@@ -270,2 +256,2 @@\n-            handle.set(segment, (byte)42);\n-            assertEquals(42, (byte)handle.get(segment));\n+            handle.set(segment, 0L, (byte)42);\n+            assertEquals(42, (byte)handle.get(segment, 0L));\n@@ -275,2 +261,2 @@\n-            handle.set(segment, (short)42);\n-            assertEquals(42, (short)handle.get(segment));\n+            handle.set(segment, 0L, (short)42);\n+            assertEquals(42, (short)handle.get(segment, 0L));\n@@ -280,2 +266,2 @@\n-            handle.set(segment, (char)42);\n-            assertEquals(42, (char)handle.get(segment));\n+            handle.set(segment, 0L, (char)42);\n+            assertEquals(42, (char)handle.get(segment, 0L));\n@@ -285,2 +271,2 @@\n-            handle.set(segment, 42);\n-            assertEquals(42, (int)handle.get(segment));\n+            handle.set(segment, 0L, 42);\n+            assertEquals(42, (int)handle.get(segment, 0L));\n@@ -290,2 +276,2 @@\n-            handle.set(segment, (long)42);\n-            assertEquals(42, (long)handle.get(segment));\n+            handle.set(segment, 0L, (long)42);\n+            assertEquals(42, (long)handle.get(segment, 0L));\n@@ -295,2 +281,2 @@\n-            handle.set(segment, (float)42);\n-            assertEquals((float)42, (float)handle.get(segment));\n+            handle.set(segment, 0L, (float)42);\n+            assertEquals((float)42, (float)handle.get(segment, 0L));\n@@ -300,2 +286,2 @@\n-            handle.set(segment, (double)42);\n-            assertEquals((double)42, (double)handle.get(segment));\n+            handle.set(segment, 0L, (double)42);\n+            assertEquals((double)42, (double)handle.get(segment, 0L));\n@@ -347,2 +333,2 @@\n-            handle.set(segment, i, (byte)i);\n-            assertEquals(i, (byte)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (byte)i);\n+            assertEquals(i, (byte)handle.get(segment, 0L, i));\n@@ -352,2 +338,2 @@\n-            handle.set(segment, i, (short)i);\n-            assertEquals(i, (short)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (short)i);\n+            assertEquals(i, (short)handle.get(segment, 0L, i));\n@@ -357,2 +343,2 @@\n-            handle.set(segment, i, (char)i);\n-            assertEquals(i, (char)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (char)i);\n+            assertEquals(i, (char)handle.get(segment, 0L, i));\n@@ -362,2 +348,2 @@\n-            handle.set(segment, i, (int)i);\n-            assertEquals(i, (int)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (int)i);\n+            assertEquals(i, (int)handle.get(segment, 0L, i));\n@@ -367,2 +353,2 @@\n-            handle.set(segment, i, (long)i);\n-            assertEquals(i, (long)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (long)i);\n+            assertEquals(i, (long)handle.get(segment, 0L, i));\n@@ -372,2 +358,2 @@\n-            handle.set(segment, i, (float)i);\n-            assertEquals((float)i, (float)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (float)i);\n+            assertEquals((float)i, (float)handle.get(segment, 0L, i));\n@@ -377,2 +363,2 @@\n-            handle.set(segment, i, (double)i);\n-            assertEquals((double)i, (double)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (double)i);\n+            assertEquals((double)i, (double)handle.get(segment, 0L, i));\n@@ -432,2 +418,2 @@\n-            handle.set(segment, r, c, (byte)(r + c));\n-            assertEquals(r + c, (byte)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (byte)(r + c));\n+            assertEquals(r + c, (byte)handle.get(segment, 0L, r, c));\n@@ -437,2 +423,2 @@\n-            handle.set(segment, r, c, (r + c) != 0);\n-            assertEquals((r + c) != 0, (boolean)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (r + c) != 0);\n+            assertEquals((r + c) != 0, (boolean)handle.get(segment, 0L, r, c));\n@@ -442,2 +428,2 @@\n-            handle.set(segment, r, c, (short)(r + c));\n-            assertEquals(r + c, (short)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (short)(r + c));\n+            assertEquals(r + c, (short)handle.get(segment, 0L, r, c));\n@@ -447,2 +433,2 @@\n-            handle.set(segment, r, c, (char)(r + c));\n-            assertEquals(r + c, (char)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (char)(r + c));\n+            assertEquals(r + c, (char)handle.get(segment, 0L, r, c));\n@@ -452,2 +438,2 @@\n-            handle.set(segment, r, c, (int)(r + c));\n-            assertEquals(r + c, (int)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (int)(r + c));\n+            assertEquals(r + c, (int)handle.get(segment, 0L, r, c));\n@@ -457,2 +443,2 @@\n-            handle.set(segment, r, c, r + c);\n-            assertEquals(r + c, (long)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, r + c);\n+            assertEquals(r + c, (long)handle.get(segment, 0L, r, c));\n@@ -462,2 +448,2 @@\n-            handle.set(segment, r, c, MemorySegment.ofAddress(r + c));\n-            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, MemorySegment.ofAddress(r + c));\n+            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, 0L, r, c));\n@@ -467,2 +453,2 @@\n-            handle.set(segment, r, c, (float)(r + c));\n-            assertEquals((float)(r + c), (float)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (float)(r + c));\n+            assertEquals((float)(r + c), (float)handle.get(segment, 0L, r, c));\n@@ -472,2 +458,2 @@\n-            handle.set(segment, r, c, (double)(r + c));\n-            assertEquals((double)(r + c), (double)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (double)(r + c));\n+            assertEquals((double)(r + c), (double)handle.get(segment, 0L, r, c));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":46,"deletions":60,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -51,2 +50,2 @@\n-            vh.set(segment, -42);\n-            int val = (int)vh.get(segment);\n+            vh.set(segment, 0L, -42);\n+            int val = (int)vh.get(segment, 0L);\n@@ -68,1 +67,1 @@\n-            vh.set(segment.asSlice(1L), -42);\n+            vh.set(segment.asSlice(1L), 0L, -42);\n@@ -96,1 +95,1 @@\n-                    vh.set(segment, i, -42);\n+                    vh.set(segment, 0L, i, -42);\n@@ -119,6 +118,6 @@\n-            vh_c.set(segment, Byte.MIN_VALUE);\n-            assertEquals(vh_c.get(segment), Byte.MIN_VALUE);\n-            vh_s.set(segment, Short.MIN_VALUE);\n-            assertEquals(vh_s.get(segment), Short.MIN_VALUE);\n-            vh_i.set(segment, Integer.MIN_VALUE);\n-            assertEquals(vh_i.get(segment), Integer.MIN_VALUE);\n+            vh_c.set(segment, 0L, Byte.MIN_VALUE);\n+            assertEquals(vh_c.get(segment, 0L), Byte.MIN_VALUE);\n+            vh_s.set(segment, 0L, Short.MIN_VALUE);\n+            assertEquals(vh_s.get(segment, 0L), Short.MIN_VALUE);\n+            vh_i.set(segment, 0L, Integer.MIN_VALUE);\n+            assertEquals(vh_i.get(segment, 0L), Integer.MIN_VALUE);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -211,1 +209,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -213,1 +211,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -215,1 +213,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -217,1 +215,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -219,1 +217,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -221,1 +219,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -223,1 +221,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -226,1 +224,1 @@\n-                (base) -> checkBytes(base, bytes, byteHandle::get, bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n+                (base) -> checkBytes(base, bytes, (addr, pos) -> byteHandle.get(addr, 0L, pos), bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n@@ -228,1 +226,1 @@\n-                (base) -> checkBytes(base, chars, charHandle::get, ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n+                (base) -> checkBytes(base, chars, (addr, pos) -> charHandle.get(addr, 0L, pos), ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n@@ -230,1 +228,1 @@\n-                (base) -> checkBytes(base, shorts, shortHandle::get, ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n+                (base) -> checkBytes(base, shorts, (addr, pos) -> shortHandle.get(addr, 0L, pos), ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n@@ -232,1 +230,1 @@\n-                (base) -> checkBytes(base, ints, intHandle::get, ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n+                (base) -> checkBytes(base, ints, (addr, pos) -> intHandle.get(addr, 0L, pos), ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n@@ -234,1 +232,1 @@\n-                (base) -> checkBytes(base, floats, floatHandle::get, ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n+                (base) -> checkBytes(base, floats, (addr, pos) -> floatHandle.get(addr, 0L, pos), ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n@@ -236,1 +234,1 @@\n-                (base) -> checkBytes(base, longs, longHandle::get, ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n+                (base) -> checkBytes(base, longs, (addr, pos) -> longHandle.get(addr, 0L, pos), ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n@@ -238,1 +236,1 @@\n-                (base) -> checkBytes(base, doubles, doubleHandle::get, ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n+                (base) -> checkBytes(base, doubles, (addr, pos) -> doubleHandle.get(addr, 0L, pos), ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -147,1 +145,1 @@\n-        addDefaultMapping(VarHandle.class, MethodHandles.memorySegmentViewVarHandle(JAVA_INT));\n+        addDefaultMapping(VarHandle.class, JAVA_INT.varHandle());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestOfBufferIssue.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -125,15 +123,15 @@\n-        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, 1L), \"Arena::allocateArray\/size\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"Arena::allocateArray\/byte\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateArray\/char\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateArray\/short\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateArray\/int\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateArray\/float\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateArray\/long\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateArray\/double\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n+        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, 1L), \"Arena::allocate\/size\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(JAVA_BYTE, new byte[]{0}), \"Arena::allocateFrom\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateFrom\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateFrom\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateFrom\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateFrom\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateFrom\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateFrom\/double\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -34,1 +33,0 @@\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n@@ -85,1 +83,1 @@\n-                        assertEquals(value, handle.get(address));\n+                        assertEquals(value, handle.get(address, 0L));\n@@ -151,1 +149,1 @@\n-        allocator.allocateArray(ValueLayout.JAVA_BYTE, -1);\n+        allocator.allocate(ValueLayout.JAVA_BYTE, -1);\n@@ -156,1 +154,1 @@\n-        allocator.allocateArray(ValueLayout.JAVA_LONG,  Long.MAX_VALUE);\n+        allocator.allocate(ValueLayout.JAVA_LONG,  Long.MAX_VALUE);\n@@ -172,1 +170,1 @@\n-                return null;\n+                return MemorySegment.NULL;\n@@ -176,1 +174,1 @@\n-            public MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+            public MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source, ValueLayout sourceElementLayout, long sourceOffset, long elementCount) {\n@@ -178,2 +176,2 @@\n-                return null;\n-            };\n+                return MemorySegment.NULL;\n+            }\n@@ -181,7 +179,7 @@\n-        allocator.allocateArray(ValueLayout.JAVA_BYTE);\n-        allocator.allocateArray(ValueLayout.JAVA_SHORT);\n-        allocator.allocateArray(ValueLayout.JAVA_CHAR);\n-        allocator.allocateArray(ValueLayout.JAVA_INT);\n-        allocator.allocateArray(ValueLayout.JAVA_FLOAT);\n-        allocator.allocateArray(ValueLayout.JAVA_LONG);\n-        allocator.allocateArray(ValueLayout.JAVA_DOUBLE);\n+        allocator.allocateFrom(ValueLayout.JAVA_BYTE);\n+        allocator.allocateFrom(ValueLayout.JAVA_SHORT);\n+        allocator.allocateFrom(ValueLayout.JAVA_CHAR);\n+        allocator.allocateFrom(ValueLayout.JAVA_INT);\n+        allocator.allocateFrom(ValueLayout.JAVA_FLOAT);\n+        allocator.allocateFrom(ValueLayout.JAVA_LONG);\n+        allocator.allocateFrom(ValueLayout.JAVA_DOUBLE);\n@@ -196,1 +194,0 @@\n-\n@@ -207,1 +204,1 @@\n-        allocator.allocateUtf8String(\"Hello\");\n+        allocator.allocateFrom(\"Hello\");\n@@ -255,1 +252,1 @@\n-                    (AllocationFunction.OfByte) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfByte) SegmentAllocator::allocateFrom,\n@@ -258,1 +255,1 @@\n-                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocateFrom,\n@@ -261,1 +258,1 @@\n-                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocateFrom,\n@@ -265,1 +262,1 @@\n-                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocateFrom,\n@@ -268,1 +265,1 @@\n-                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocateFrom,\n@@ -271,1 +268,1 @@\n-                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocateFrom,\n@@ -274,1 +271,1 @@\n-                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocateFrom,\n@@ -277,1 +274,1 @@\n-                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocateFrom,\n@@ -281,1 +278,1 @@\n-                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocateFrom,\n@@ -284,1 +281,1 @@\n-                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocateFrom,\n@@ -288,1 +285,1 @@\n-                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocateFrom,\n@@ -291,1 +288,1 @@\n-                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocateFrom,\n@@ -294,1 +291,1 @@\n-                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocateFrom,\n@@ -297,1 +294,1 @@\n-                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocateFrom,\n@@ -300,1 +297,1 @@\n-                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocateFrom,\n@@ -311,1 +308,1 @@\n-                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateFrom,\n@@ -314,1 +311,1 @@\n-                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateFrom,\n@@ -317,1 +314,1 @@\n-                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateFrom,\n@@ -321,1 +318,1 @@\n-                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateFrom,\n@@ -324,1 +321,1 @@\n-                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateFrom,\n@@ -327,1 +324,1 @@\n-                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateFrom,\n@@ -330,1 +327,1 @@\n-                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateFrom,\n@@ -334,1 +331,1 @@\n-                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateFrom,\n@@ -337,1 +334,1 @@\n-                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateFrom,\n@@ -341,1 +338,1 @@\n-                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateFrom,\n@@ -344,1 +341,1 @@\n-                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateFrom,\n@@ -347,1 +344,1 @@\n-                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateFrom,\n@@ -350,1 +347,1 @@\n-                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateFrom,\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":43,"deletions":46,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -174,1 +173,1 @@\n-            return MethodHandles.memorySegmentViewVarHandle(layout);\n+            return layout.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -33,0 +32,1 @@\n+import org.testng.SkipException;\n@@ -47,0 +47,3 @@\n+        if (s1.kind != s2.kind) {\n+            throw new SkipException(\"Slices of different segment kinds\");\n+        }\n@@ -49,1 +52,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -56,9 +59,0 @@\n-        } else if (s1.kind != s2.kind) {\n-            \/\/ check that offset from s1 to s2 fails\n-            try {\n-                long offset = s1.segment.segmentOffset(s2.segment);\n-                out.format(\"testOffset s1:%s, s2:%s, offset:%d\\n\", s1, s2, offset);\n-                fail(\"offset unexpectedly passed!\");\n-            } catch (UnsupportedOperationException ex) {\n-                assertTrue(ex.getMessage().contains(\"Cannot compute offset from native to heap (or vice versa).\"));\n-            }\n@@ -67,1 +61,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -119,0 +113,4 @@\n+\n+        long offset(SegmentSlice that) {\n+            return that.segment.address() - segment.address();\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @requires vm.bits == 64\n@@ -87,1 +86,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -98,1 +97,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -251,1 +250,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -154,1 +153,1 @@\n-        return (int)intHandle.getVolatile(base);\n+        return (int)intHandle.getVolatile(base, 0L);\n@@ -158,1 +157,1 @@\n-        intHandle.setVolatile(base, value);\n+        intHandle.setVolatile(base, 0L, value);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n- * @enablePreview\n@@ -56,1 +55,1 @@\n-                    VH_ALL.set(segment, i, j, (int)j + 1 + ((int)i * 5));\n+                    VH_ALL.set(segment, 0L, i, j, (int)j + 1 + ((int)i * 5));\n@@ -68,2 +67,2 @@\n-            assertThrows(() -> handle.get(segment, lo, 0));\n-            assertThrows(() -> handle.get(segment, 0, hi));\n+            assertThrows(() -> handle.get(segment, 0L, lo, 0));\n+            assertThrows(() -> handle.get(segment, 0L, 0, hi));\n@@ -77,1 +76,1 @@\n-                int x = (int) handle.get(segment, i, j);\n+                int x = (int) handle.get(segment, 0L, i, j);\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -47,2 +46,0 @@\n-    static final VarHandle INT_HANDLE = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-\n@@ -59,1 +56,1 @@\n-                INT_HANDLE.set(segment, (long) i, i);\n+                segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -86,1 +83,1 @@\n-            INT_HANDLE.set(segment, (long) i, i);\n+            segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -163,1 +160,1 @@\n-        return acc + (int)INT_HANDLE.get(segment, 0L);\n+        return acc + segment.getAtIndex(ValueLayout.JAVA_INT, 0);\n@@ -170,1 +167,1 @@\n-            sum += (int)INT_HANDLE.get(segment, (long)i);\n+            sum += segment.getAtIndex(ValueLayout.JAVA_INT, i);\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.lang.reflect.Field;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n@@ -33,2 +36,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -41,3 +42,5 @@\n-    public void testStrings(String testString, int expectedByteLength) {\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment text = arena.allocateUtf8String(testString);\n+    public void testStrings(String testString) throws ReflectiveOperationException {\n+        for (Charset charset : Charset.availableCharsets().values()) {\n+            if (isStandard(charset)) {\n+                try (Arena arena = Arena.ofConfined()) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset);\n@@ -45,1 +48,7 @@\n-            assertEquals(text.byteSize(), expectedByteLength);\n+                    int terminatorSize = \"\\0\".getBytes(charset).length;\n+                    if (charset == StandardCharsets.UTF_16) {\n+                        terminatorSize -= 2; \/\/ drop BOM\n+                    }\n+                    \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                    \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                    \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n@@ -47,2 +56,14 @@\n-            String roundTrip = text.getUtf8String(0);\n-            assertEquals(roundTrip, testString);\n+                    int expectedByteLength =\n+                            testString.getBytes(charset).length +\n+                            terminatorSize;\n+\n+                    assertEquals(text.byteSize(), expectedByteLength);\n+\n+                    String roundTrip = text.getString(0, charset);\n+                    if (charset.newEncoder().canEncode(testString)) {\n+                        assertEquals(roundTrip, testString);\n+                    }\n+                }\n+            } else {\n+                assertThrows(UnsupportedOperationException.class, () -> Arena.global().allocateFrom(testString, charset));\n+            }\n@@ -55,7 +76,7 @@\n-            { \"testing\",               8 },\n-            { \"\",                      1 },\n-            { \"X\",                     2 },\n-            { \"12345\",                 6 },\n-            { \"yen \\u00A5\",            7 }, \/\/ in UTF-8 2 bytes: 0xC2 0xA5\n-            { \"snowman \\u26C4\",       12 }, \/\/ in UTF-8 three bytes: 0xE2 0x9B 0x84\n-            { \"rainbow \\uD83C\\uDF08\", 13 }  \/\/ in UTF-8 four bytes: 0xF0 0x9F 0x8C 0x88\n+            { \"testing\" },\n+            { \"\" },\n+            { \"X\" },\n+            { \"12345\" },\n+            { \"yen \\u00A5\" },\n+            { \"snowman \\u26C4\" },\n+            { \"rainbow \\uD83C\\uDF08\" }\n@@ -64,0 +85,9 @@\n+\n+    boolean isStandard(Charset charset) throws ReflectiveOperationException {\n+        for (Field standardCharset : StandardCharsets.class.getDeclaredFields()) {\n+            if (standardCharset.get(null) == charset) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":45,"deletions":15,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -46,1 +45,1 @@\n-        int v = (int)INT_HANDLE.get(\"string\");\n+        int v = (int)INT_HANDLE.get(\"string\", 0L);\n@@ -57,2 +56,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            String address = (String)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            String address = (String)ADDR_HANDLE.get(s, 0L);\n@@ -66,1 +65,1 @@\n-            ADDR_HANDLE.set(s, \"string\");\n+            ADDR_HANDLE.set(s, 0L, \"string\");\n@@ -73,2 +72,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            int address = (int)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            int address = (int)ADDR_HANDLE.get(s, 0L);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- *\n- * @run testng\/othervm -Djdk.internal.foreign.CABI=UNSUPPORTED --enable-native-access=ALL-UNNAMED TestUnsupportedLinker\n- *\/\n-\n-import java.lang.foreign.Linker;\n-\n-import org.testng.annotations.Test;\n-\n-public class TestUnsupportedLinker {\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testLinker() {\n-        Linker.nativeLinker();\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -51,9 +49,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n-\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -54,1 +52,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n@@ -57,8 +54,0 @@\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n-\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -43,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -54,1 +53,0 @@\n-    static final VarHandle VH_IntArray = C_INT.arrayElementVarHandle();\n@@ -85,1 +83,1 @@\n-                VH_IntArray.set(argIDs, (long) i, args.get(i).id.ordinal());\n+                argIDs.setAtIndex(ValueLayout.JAVA_INT, i, args.get(i).id.ordinal());\n@@ -200,1 +198,1 @@\n-            VH_writeback.set(seg, addr);\n+            VH_writeback.set(seg, 0L, addr);\n@@ -203,1 +201,1 @@\n-            VH_argIDs.set(seg, addr);\n+            VH_argIDs.set(seg, 0L, addr);\n@@ -222,1 +220,3 @@\n-            return new Arg(id, layout, value, layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET));\n+            MethodHandle getterHandle = layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET);\n+            getterHandle = MethodHandles.insertArguments(getterHandle, 1, 0L); \/\/ align signature with getter for structs\n+            return new Arg(id, layout, value, getterHandle);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -47,1 +46,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE);\n+        VarHandle vh = ValueLayout.JAVA_BYTE.varHandle();\n@@ -56,1 +55,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(4));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(4).varHandle();\n@@ -66,1 +65,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(2));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(2).varHandle();\n@@ -76,2 +75,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.LITTLE_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN).varHandle();\n@@ -87,2 +85,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.BIG_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN).varHandle();\n@@ -103,1 +100,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+        VarHandle vh = ValueLayout.JAVA_INT.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-            \"--enable-preview\",\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,1 +38,0 @@\n- * @enablePreview\n@@ -42,1 +39,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/arraystructs\/TestArrayStructs.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLayoutEquality.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestMacOsAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -66,1 +64,1 @@\n-    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, boolean trivial, String threadLocalName, Consumer<Object> resultCheck) {}\n+    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n@@ -70,6 +68,2 @@\n-        List<Linker.Option> options = new ArrayList<>();\n-        options.add(Linker.Option.captureCallState(testCase.threadLocalName()));\n-        if (testCase.trivial()) {\n-            options.add(Linker.Option.isTrivial());\n-        }\n-        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), options.toArray(Linker.Option[]::new));\n+        Linker.Option stl = Linker.Option.captureCallState(testCase.threadLocalName());\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n@@ -88,1 +82,1 @@\n-            int savedErrno = (int) errnoHandle.get(saveSeg);\n+            int savedErrno = (int) errnoHandle.get(saveSeg, 0L);\n@@ -108,4 +102,0 @@\n-    interface CaseAdder {\n-      void addCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck);\n-    }\n-\n@@ -115,4 +105,0 @@\n-        CaseAdder adder = (nativeTarget, nativeDesc, threadLocalName, resultCheck) -> {\n-          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, false, threadLocalName, resultCheck));\n-          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, true, threadLocalName, resultCheck));\n-        };\n@@ -120,16 +106,16 @@\n-        adder.addCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {});\n-        adder.addCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42));\n-        adder.addCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0));\n-\n-        structCase(adder, \"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L));\n-        structCase(adder, \"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                         JAVA_LONG.withName(\"y\"), 42L));\n-        structCase(adder, \"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                         JAVA_LONG.withName(\"y\"), 42L,\n-                                         JAVA_LONG.withName(\"z\"), 42L));\n-        structCase(adder, \"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D));\n-        structCase(adder, \"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"y\"), 42D));\n-        structCase(adder, \"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"y\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"z\"), 42D));\n+        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n+        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n+        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n+\n+        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n+        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                           JAVA_LONG.withName(\"y\"), 42L)));\n+        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                            JAVA_LONG.withName(\"y\"), 42L,\n+                                            JAVA_LONG.withName(\"z\"), 42L)));\n+        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n+        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n+        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n@@ -138,2 +124,2 @@\n-            adder.addCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {});\n-            adder.addCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {});\n+            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n+            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n@@ -145,1 +131,1 @@\n-    static void structCase(CaseAdder adder, String name, Map<MemoryLayout, Object> fields) {\n+    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n@@ -153,1 +139,1 @@\n-            check = check.andThen(o -> assertEquals(fieldHandle.get(o), value));\n+            check = check.andThen(o -> assertEquals(fieldHandle.get(o, 0L), value));\n@@ -156,1 +142,1 @@\n-        adder.addCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":25,"deletions":39,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -29,1 +28,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -179,2 +177,2 @@\n-        Stream<String> s2 = cls.equals(UNNAMED) ? Stream.of(\"--enable-preview\", \"-p\", MODULE_PATH, cls, action)\n-                : Stream.of(\"--enable-preview\", \"-p\", MODULE_PATH, \"-m\", cls, action);\n+        Stream<String> s2 = cls.equals(UNNAMED) ? Stream.of(\"-p\", MODULE_PATH, cls, action)\n+                : Stream.of(\"-p\", MODULE_PATH, \"-m\", cls, action);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccess.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -158,1 +156,0 @@\n-        list.add(\"--enable-preview\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/largestub\/TestLargeStub.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookupJNI.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/nested\/TestNested.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/TestPassHeapSegment.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -45,2 +43,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -65,2 +61,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -85,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestReentrantUpcalls.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -45,2 +43,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -65,2 +61,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -85,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCritical\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestCritical extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"Critical\");\n+    }\n+\n+    @Test\n+    public void testEmpty() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.critical());\n+        handle.invokeExact();\n+    }\n+\n+    @Test\n+    public void testIdentity() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.critical());\n+        int result = (int) handle.invokeExact(42);\n+        assertEquals(result, 42);\n+    }\n+\n+    @Test\n+    public void testWithReturnBuffer() throws Throwable {\n+        StructLayout bigLayout = MemoryLayout.structLayout(\n+                C_LONG_LONG.withName(\"x\"),\n+                C_LONG_LONG.withName(\"y\"));\n+\n+        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.critical());\n+        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n+            long x = (long) vhX.get(result, 0L);\n+            assertEquals(x, 10);\n+            long y = (long) vhY.get(result, 0L);\n+            assertEquals(y, 11);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestCritical.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ * @requires jdk.foreign.linker != \"FALLBACK\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCriticalUpcall\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+\n+import static org.testng.Assert.fail;\n+\n+public class TestCriticalUpcall extends UpcallTestHelper {\n+\n+    @Test\n+    public void testUpcallFailure() throws IOException, InterruptedException {\n+        \/\/ test to see if we catch a trivial downcall doing an upcall\n+        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n+    }\n+\n+    public static class Runner extends NativeTestHelper {\n+        public static void main(String[] args) throws Throwable {\n+            System.loadLibrary(\"Critical\");\n+\n+            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.critical());\n+            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n+            mh.invokeExact(stub);\n+        }\n+\n+        public static void target() {\n+            fail(\"Should not get here\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestCriticalUpcall.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/ \/test\/lib\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivial\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestTrivial extends NativeTestHelper {\n-\n-    static {\n-        System.loadLibrary(\"Trivial\");\n-    }\n-\n-    @Test\n-    public void testEmpty() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.isTrivial());\n-        handle.invokeExact();\n-    }\n-\n-    @Test\n-    public void testIdentity() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.isTrivial());\n-        int result = (int) handle.invokeExact(42);\n-        assertEquals(result, 42);\n-    }\n-\n-    @Test\n-    public void testWithReturnBuffer() throws Throwable {\n-        StructLayout bigLayout = MemoryLayout.structLayout(\n-                C_LONG_LONG.withName(\"x\"),\n-                C_LONG_LONG.withName(\"y\"));\n-\n-        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.isTrivial());\n-        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n-        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n-            long x = (long) vhX.get(result);\n-            assertEquals(x, 10);\n-            long y = (long) vhY.get(result);\n-            assertEquals(y, 11);\n-        }\n-    }\n-\n-    @Test\n-    public void testCaptureErrno() throws Throwable {\n-        Linker.Option ccs = Linker.Option.captureCallState(\"errno\");\n-        MethodHandle handle = downcallHandle(\"capture_errno\", FunctionDescriptor.ofVoid(C_INT), Linker.Option.isTrivial(), ccs);\n-        StructLayout capturedStateLayout = Linker.Option.captureStateLayout();\n-        VarHandle errnoHandle = capturedStateLayout.varHandle(MemoryLayout.PathElement.groupElement(\"errno\"));\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment captureSeg = arena.allocate(capturedStateLayout);\n-            handle.invokeExact(captureSeg, 42);\n-            int capturedErrno = (int) errnoHandle.get(captureSeg);\n-            assertEquals(capturedErrno, 42);\n-        }\n-    }\n-\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivial.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/ \/test\/lib\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @requires jdk.foreign.linker != \"FALLBACK\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivialUpcall\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandle;\n-\n-import static org.testng.Assert.fail;\n-\n-public class TestTrivialUpcall extends UpcallTestHelper {\n-\n-    @Test\n-    public void testUpcallFailure() throws IOException, InterruptedException {\n-        \/\/ test to see if we catch a trivial downcall doing an upcall\n-        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n-    }\n-\n-    public static class Runner extends NativeTestHelper {\n-        public static void main(String[] args) throws Throwable {\n-            System.loadLibrary(\"Trivial\");\n-\n-            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.isTrivial());\n-            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n-            mh.invokeExact(stub);\n-        }\n-\n-        public static void target() {\n-            fail(\"Should not get here\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivialUpcall.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -51,4 +51,0 @@\n-EXPORT void capture_errno(int value) {\n-    errno = value;\n-}\n-\n","filename":"test\/jdk\/java\/foreign\/trivial\/libCritical.c","additions":0,"deletions":4,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/foreign\/trivial\/libTrivial.c","status":"renamed"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,4 +41,4 @@\n- * @compile --enable-preview -source ${jdk.version} ImplicitAttach.java\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 1\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 2\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 4\n+ * @compile -source ${jdk.version} ImplicitAttach.java\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 1\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 2\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 4\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/AttachTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -174,1 +173,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()));\n+        VarHandle vh = ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()).varHandle();\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeMapTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/MapToMemorySegmentTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -9,3 +9,0 @@\n-\n-# To compile and run tests that use the foreign memory access API\n-enablePreview=true\n","filename":"test\/jdk\/java\/util\/stream\/test\/TEST.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorReshapeTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromSliceTest extends CLayouts {\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public int start;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[1024];\n+        Random random = new Random(0);\n+        random.nextBytes(arr);\n+        start = random.nextInt(1024 - size);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        MemorySegment.copy(arr, start, segment, C_CHAR, 0, size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined_slice() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(C_CHAR, MemorySegment.ofArray(arr), C_CHAR, start, size);\n+        arena.close();\n+        return segment;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromSliceTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    SlicingPool pool = new SlicingPool();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[size];\n+        Random random = new Random(0);\n+        random.nextBytes(arr);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_malloc_arena() {\n+        MallocArena arena = new MallocArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_pool_arena() {\n+        Arena arena = pool.acquire();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    static class SlicingPool {\n+        final MemorySegment pool = Arena.ofAuto().allocate(1024);\n+        boolean isAcquired = false;\n+\n+        public Arena acquire() {\n+            if (isAcquired) {\n+                throw new IllegalStateException(\"An allocator is already in use\");\n+            }\n+            isAcquired = true;\n+            return new SlicingPoolAllocator();\n+        }\n+\n+        class SlicingPoolAllocator implements Arena {\n+\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicing = SegmentAllocator.slicingAllocator(pool);\n+\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicing.allocate(byteSize, byteAlignment)\n+                        .reinterpret(arena, null);\n+            }\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            public void close() {\n+                isAcquired = false;\n+                arena.close();\n+            }\n+        }\n+    }\n+\n+    public static class MallocArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return CLayouts.allocateMemory(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize))\n+                    .reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(ms.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -58,2 +58,2 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n+    public void panama_blank_critical() throws Throwable {\n+        func_critical.invokeExact();\n@@ -73,2 +73,2 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n+    public int panama_identity_critical() throws Throwable {\n+        return (int) identity_critical.invokeExact(10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadConstant.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    static final MethodHandle func_trivial;\n+    static final MethodHandle func_critical;\n@@ -39,1 +39,1 @@\n-    static final MethodHandle func_trivial_v;\n+    static final MethodHandle func_critical_v;\n@@ -42,1 +42,1 @@\n-    static final MethodHandle identity_trivial;\n+    static final MethodHandle identity_critical;\n@@ -44,1 +44,1 @@\n-    static final MethodHandle identity_trivial_v;\n+    static final MethodHandle identity_critical_v;\n@@ -116,1 +116,1 @@\n-            func_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n+            func_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n@@ -118,1 +118,1 @@\n-            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n+            func_critical = insertArguments(func_critical_v, 0, func_addr);\n@@ -124,1 +124,1 @@\n-            identity_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n+            identity_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n@@ -126,1 +126,1 @@\n-            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n+            identity_critical = insertArguments(identity_critical_v, 0, identity_addr);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -58,2 +58,2 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial_v.invokeExact(func_addr);\n+    public void panama_blank_critical() throws Throwable {\n+        func_critical_v.invokeExact(func_addr);\n@@ -112,2 +112,2 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    public int panama_identity_critical() throws Throwable {\n+        return (int) identity_critical_v.invokeExact(identity_addr, 10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadVirtual.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,4 @@\n-import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG_UNALIGNED;\n@@ -32,1 +36,1 @@\n- * Some useful Java {@link ValueLayout} and associated {@link ValueLayout#arrayElementVarHandle(int...)} var handles.\n+ * Some useful Java {@link ValueLayout} and associated array var handles.\n@@ -36,1 +40,2 @@\n-    static final VarHandle VH_INT_UNALIGNED = JAVA_INT_UNALIGNED.arrayElementVarHandle();\n+    static final VarHandle VH_INT_UNALIGNED = arrayVarHandle(JAVA_INT_UNALIGNED);\n+    static final VarHandle VH_INT = arrayVarHandle(JAVA_INT);\n@@ -38,1 +43,7 @@\n-    static final VarHandle VH_INT = JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle VH_LONG_UNALIGNED = arrayVarHandle(JAVA_LONG_UNALIGNED);\n+    static final VarHandle VH_LONG = arrayVarHandle(JAVA_LONG);\n+\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.collectCoordinates(layout.varHandle(),\n+            1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNewHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentCopyUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+\n+    long src;\n+    long dst;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        src = Arena.global().allocate(JAVA_INT).address();\n+        dst = Arena.global().allocate(JAVA_INT).address();\n+    }\n+\n+    @Benchmark\n+    public void panama() {\n+        MemorySegment srcSeg = MemorySegment.ofAddress(src).reinterpret(JAVA_INT.byteSize());\n+        MemorySegment dstSeg = MemorySegment.ofAddress(dst).reinterpret(JAVA_INT.byteSize());\n+        dstSeg.copyFrom(srcSeg);\n+    }\n+\n+    @Benchmark\n+    public void unsafe() {\n+        UNSAFE.copyMemory(src, dst, JAVA_INT.byteSize());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentCopyUnsafe.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentGetUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+    static final MethodHandle OF_ADDRESS_UNSAFE;\n+\n+    static {\n+        try {\n+            OF_ADDRESS_UNSAFE = MethodHandles.lookup().findStatic(MemorySegmentGetUnsafe.class,\n+                    \"ofAddressUnsafe\", MethodType.methodType(MemorySegment.class, long.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    static final VarHandle INT_HANDLE = adaptSegmentHandle(JAVA_INT.varHandle());\n+\n+    static VarHandle adaptSegmentHandle(VarHandle handle) {\n+        handle = MethodHandles.insertCoordinates(handle, 1, 0L);\n+        handle = MethodHandles.filterCoordinates(handle, 0, OF_ADDRESS_UNSAFE);\n+        return handle;\n+    }\n+\n+    static MemorySegment ofAddressUnsafe(long address) {\n+        return MemorySegment.ofAddress(address).reinterpret(JAVA_INT.byteSize());\n+    }\n+\n+    long addr;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        addr = Arena.global().allocate(JAVA_INT).address();\n+    }\n+\n+    @Benchmark\n+    public int panama() {\n+        return (int) INT_HANDLE.get(addr);\n+    }\n+\n+    @Benchmark\n+    public int unsafe() {\n+        return UNSAFE.getInt(addr);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentGetUnsafe.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -63,1 +63,1 @@\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentVsBits.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -97,1 +97,1 @@\n-            MemorySegment segment = arena.allocateUtf8String(str);\n+            MemorySegment segment = arena.allocateFrom(str);\n@@ -104,1 +104,1 @@\n-        return (int)STRLEN.invokeExact(arenaAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(arenaAllocator.allocateFrom(str));\n@@ -110,1 +110,1 @@\n-        int l = (int) STRLEN.invokeExact(arena.allocateUtf8String(str));\n+        int l = (int) STRLEN.invokeExact(arena.allocateFrom(str));\n@@ -117,1 +117,1 @@\n-        return (int)STRLEN.invokeExact(segmentAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(segmentAllocator.allocateFrom(str));\n@@ -167,1 +167,1 @@\n-            long lastOffset = segment.segmentOffset(res) + res.byteSize();\n+            long lastOffset = res.address() - segment.address() + res.byteSize();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestAdaptVarHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,2 +53,1 @@\n-        \"--enable-native-access\", \"ALL-UNNAMED\",\n-        \"--enable-preview\"})\n+        \"--enable-native-access\", \"ALL-UNNAMED\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -48,4 +48,0 @@\n-    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle();\n-\n-    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle();\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n@@ -57,1 +57,1 @@\n-        generic = MethodHandles.memorySegmentViewVarHandle(JAVA_INT);\n+        generic = JAVA_INT.varHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/NativeType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        MemorySegment segment = allocator.allocateArray(type.layout(), size);\n+        MemorySegment segment = allocator.allocate(type.layout(), size);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Pointer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n@@ -63,1 +63,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        VH_x.set(segment, x);\n+        VH_x.set(segment, 0L, x);\n@@ -75,1 +75,1 @@\n-        return (int) VH_x.get(segment);\n+        return (int) VH_x.get(segment, 0L);\n@@ -79,1 +79,1 @@\n-        VH_y.set(segment, y);\n+        VH_y.set(segment, 0L, y);\n@@ -83,1 +83,1 @@\n-        return (int) VH_y.get(segment);\n+        return (int) VH_y.get(segment, 0L);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}