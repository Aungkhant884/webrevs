{"files":[{"patch":"@@ -44,0 +44,1 @@\n+#include \"jfr\/utilities\/jfrThreadIterator.hpp\"\n@@ -124,0 +125,24 @@\n+\/\/ Reset thread local state used for object allocation sampling.\n+class ClearObjectAllocationSampling : public ThreadClosure {\n+ public:\n+  void do_thread(Thread* t) {\n+    assert(t != nullptr, \"invariant\");\n+    t->jfr_thread_local()->clear_last_allocated_bytes();\n+  }\n+};\n+\n+template <typename Iterator>\n+static inline void iterate(Iterator& it, ClearObjectAllocationSampling& robs) {\n+  while (it.has_next()) {\n+    robs.do_thread(it.next());\n+  }\n+}\n+\n+static void clear_object_allocation_sampling() {\n+  ClearObjectAllocationSampling robs;\n+  JfrJavaThreadIterator jit;\n+  iterate(jit, robs);\n+  JfrNonJavaThreadIterator njit;\n+  iterate(njit, robs);\n+}\n+\n@@ -438,0 +463,1 @@\n+  clear_object_allocation_sampling();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"jfr\/support\/jfrThreadLocal.hpp\"\n@@ -32,4 +33,1 @@\n-static THREAD_LOCAL int64_t _last_allocated_bytes = 0;\n-\n-inline void send_allocation_sample(const Klass* klass, int64_t allocated_bytes) {\n-  assert(allocated_bytes > 0, \"invariant\");\n+inline bool send_allocation_sample(const Klass* klass, int64_t allocated_bytes, JfrThreadLocal* tl) {\n@@ -38,1 +36,1 @@\n-    const int64_t weight = allocated_bytes - _last_allocated_bytes;\n+    const int64_t weight = allocated_bytes - tl->last_allocated_bytes();\n@@ -43,14 +41,1 @@\n-    _last_allocated_bytes = allocated_bytes;\n-  }\n-}\n-\n-inline bool send_allocation_sample_with_result(const Klass* klass, int64_t allocated_bytes) {\n-  assert(allocated_bytes > 0, \"invariant\");\n-  EventObjectAllocationSample event;\n-  if (event.should_commit()) {\n-    const int64_t weight = allocated_bytes - _last_allocated_bytes;\n-    assert(weight > 0, \"invariant\");\n-    event.set_objectClass(klass);\n-    event.set_weight(weight);\n-    event.commit();\n-    _last_allocated_bytes = allocated_bytes;\n+    tl->set_last_allocated_bytes(allocated_bytes);\n@@ -69,2 +54,1 @@\n-inline int64_t load_allocated_bytes(Thread* thread) {\n-  assert(thread != nullptr, \"invariant\");\n+inline int64_t load_allocated_bytes(JfrThreadLocal* tl, Thread* thread) {\n@@ -72,8 +56,1 @@\n-  if (allocated_bytes < _last_allocated_bytes) {\n-    \/\/ A hw thread can detach and reattach to the VM, and when it does,\n-    \/\/ it gets a new JavaThread representation. The thread local variable\n-    \/\/ tracking _last_allocated_bytes is mapped to the existing hw thread,\n-    \/\/ so it needs to be reset.\n-    _last_allocated_bytes = 0;\n-  }\n-  return allocated_bytes == _last_allocated_bytes ? 0 : allocated_bytes;\n+  return allocated_bytes == tl->last_allocated_bytes() ? 0 : allocated_bytes;\n@@ -84,2 +61,2 @@\n-static void normalize_as_tlab_and_send_allocation_samples(const Klass* klass, int64_t obj_alloc_size_bytes, Thread* thread) {\n-  const int64_t allocated_bytes = load_allocated_bytes(thread);\n+static void normalize_as_tlab_and_send_allocation_samples(const Klass* klass, int64_t obj_alloc_size_bytes, JfrThreadLocal* tl, Thread* thread) {\n+  const int64_t allocated_bytes = load_allocated_bytes(tl, thread);\n@@ -88,1 +65,1 @@\n-    send_allocation_sample(klass, allocated_bytes);\n+    send_allocation_sample(klass, allocated_bytes, tl);\n@@ -92,1 +69,1 @@\n-  if (allocated_bytes - _last_allocated_bytes < tlab_size_bytes) {\n+  if (allocated_bytes - tl->last_allocated_bytes() < tlab_size_bytes) {\n@@ -97,1 +74,1 @@\n-    if (send_allocation_sample_with_result(klass, allocated_bytes)) {\n+    if (send_allocation_sample(klass, allocated_bytes, tl)) {\n@@ -105,0 +82,3 @@\n+  assert(thread != nullptr, \"invariant\");\n+  JfrThreadLocal* const tl = thread->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n@@ -106,1 +86,1 @@\n-    normalize_as_tlab_and_send_allocation_samples(klass, static_cast<int64_t>(alloc_size), thread);\n+    normalize_as_tlab_and_send_allocation_samples(klass, static_cast<int64_t>(alloc_size), tl, thread);\n@@ -109,1 +89,1 @@\n-  const int64_t allocated_bytes = load_allocated_bytes(thread);\n+  const int64_t allocated_bytes = load_allocated_bytes(tl, thread);\n@@ -113,1 +93,1 @@\n-  send_allocation_sample(klass, allocated_bytes);\n+  send_allocation_sample(klass, allocated_bytes, tl);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrObjectAllocationSample.cpp","additions":17,"deletions":37,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  _last_allocated_bytes(0),\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  int64_t _last_allocated_bytes;\n@@ -152,0 +153,12 @@\n+  int64_t last_allocated_bytes() const {\n+    return _last_allocated_bytes;\n+  }\n+\n+  void set_last_allocated_bytes(int64_t allocated_bytes) {\n+    _last_allocated_bytes = allocated_bytes;\n+  }\n+\n+  void clear_last_allocated_bytes() {\n+    set_last_allocated_bytes(0);\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}