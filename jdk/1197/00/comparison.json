{"files":[{"patch":"@@ -70,2 +70,2 @@\n-        RSA_SIGN            ((byte)0x01, \"rsa_sign\", \"RSA\", true),\n-        DSS_SIGN            ((byte)0x02, \"dss_sign\", \"DSA\", true),\n+        RSA_SIGN            ((byte)0x01, \"rsa_sign\", List.of(\"RSA\"), true),\n+        DSS_SIGN            ((byte)0x02, \"dss_sign\", List.of(\"DSA\"), true),\n@@ -82,1 +82,2 @@\n-                                             \"EC\", JsseJce.isEcAvailable()),\n+                                            List.of(\"EC\", \"EdDSA\"),\n+                                            JsseJce.isEcAvailable()),\n@@ -98,1 +99,1 @@\n-        final String keyAlgorithm;\n+        final List<String> keyAlgorithm;\n@@ -106,1 +107,1 @@\n-                String keyAlgorithm, boolean isAvailable) {\n+                List<String> keyAlgorithm, boolean isAvailable) {\n@@ -137,1 +138,5 @@\n-                    keyTypes.add(cct.keyAlgorithm);\n+                    cct.keyAlgorithm.forEach(key -> {\n+                        if (!keyTypes.contains(key)) {\n+                            keyTypes.add(key);\n+                        }\n+                    });\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -462,0 +462,3 @@\n+                case \"EdDSA\":\n+                    signer = Signature.getInstance(JsseJce.SIGNATURE_EDDSA);\n+                    break;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateVerify.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -427,0 +427,3 @@\n+                case \"EdDSA\":\n+                    signer = Signature.getInstance(JsseJce.SIGNATURE_EDDSA);\n+                    break;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHServerKeyExchange.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,0 +93,5 @@\n+    \/**\n+     * JCA identifier for EdDSA signatures.\n+     *\/\n+    static final String SIGNATURE_EDDSA = \"EdDSA\";\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/JsseJce.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-    CLIENT_CERT_TYPE        (0x0013, \"padding\"),\n+    CLIENT_CERT_TYPE        (0x0013, \"client_certificate_type\"),\n@@ -281,1 +281,1 @@\n-    PADDING                 (0x0015, \"client_certificate_type\"),\n+    PADDING                 (0x0015, \"padding\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLExtension.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -32,0 +33,2 @@\n+import java.util.List;\n+import java.util.ListIterator;\n@@ -38,1 +41,1 @@\n-    private final SSLAuthentication authentication;\n+    private final List<SSLAuthentication> authentication;\n@@ -41,1 +44,1 @@\n-    SSLKeyExchange(X509Authentication authentication,\n+    SSLKeyExchange(List<X509Authentication> authentication,\n@@ -43,1 +46,6 @@\n-        this.authentication = authentication;\n+        if (authentication != null) {\n+            this.authentication = new ArrayList<>();\n+            this.authentication.addAll(authentication);\n+        } else {\n+            this.authentication = null;\n+        }\n@@ -51,1 +59,8 @@\n-            authPossession = authentication.createPossession(context);\n+            \/\/ Loop through potential authentication types and end at\n+            \/\/ the first non-null possession.\n+            ListIterator<SSLAuthentication> li = authentication.listIterator();\n+            while (li.hasNext() && authPossession == null) {\n+                SSLAuthentication authType = li.next();\n+                authPossession = authType.createPossession(context);\n+            }\n+\n@@ -112,1 +127,1 @@\n-        SSLHandshake[] auHandshakes;\n+        SSLHandshake[] auHandshakes = null;\n@@ -114,4 +129,6 @@\n-            auHandshakes =\n-                authentication.getRelatedHandshakers(handshakeContext);\n-        } else {\n-            auHandshakes = null;\n+            ListIterator<SSLAuthentication> li = authentication.listIterator();\n+            while (li.hasNext() &&\n+                    (auHandshakes == null || auHandshakes.length == 0)) {\n+                SSLAuthentication authType = li.next();\n+                auHandshakes = authType.getRelatedHandshakers(handshakeContext);\n+            }\n@@ -139,1 +156,1 @@\n-        Map.Entry<Byte, HandshakeProducer>[] auProducers;\n+        Map.Entry<Byte, HandshakeProducer>[] auProducers = null;\n@@ -141,4 +158,6 @@\n-            auProducers =\n-                authentication.getHandshakeProducers(handshakeContext);\n-        } else {\n-            auProducers = null;\n+            ListIterator<SSLAuthentication> li = authentication.listIterator();\n+            while (li.hasNext() &&\n+                    (auProducers == null || auProducers.length == 0)) {\n+                SSLAuthentication authType = li.next();\n+                auProducers = authType.getHandshakeProducers(handshakeContext);\n+            }\n@@ -166,1 +185,1 @@\n-        Map.Entry<Byte, SSLConsumer>[] auConsumers;\n+        Map.Entry<Byte, SSLConsumer>[] auConsumers = null;\n@@ -168,4 +187,6 @@\n-            auConsumers =\n-                authentication.getHandshakeConsumers(handshakeContext);\n-        } else {\n-            auConsumers = null;\n+            ListIterator<SSLAuthentication> li = authentication.listIterator();\n+            while (li.hasNext() &&\n+                    (auConsumers == null || auConsumers.length == 0)) {\n+                SSLAuthentication authType = li.next();\n+                auConsumers = authType.getHandshakeConsumers(handshakeContext);\n+            }\n@@ -250,1 +271,1 @@\n-                X509Authentication.RSA, T12KeyAgreement.RSA);\n+                List.of(X509Authentication.RSA), T12KeyAgreement.RSA);\n@@ -255,1 +276,1 @@\n-                X509Authentication.RSA, T12KeyAgreement.RSA_EXPORT);\n+                List.of(X509Authentication.RSA), T12KeyAgreement.RSA_EXPORT);\n@@ -260,1 +281,1 @@\n-                X509Authentication.DSA, T12KeyAgreement.DHE);\n+                List.of(X509Authentication.DSA), T12KeyAgreement.DHE);\n@@ -265,1 +286,1 @@\n-                X509Authentication.DSA, T12KeyAgreement.DHE_EXPORT);\n+                List.of(X509Authentication.DSA), T12KeyAgreement.DHE_EXPORT);\n@@ -270,1 +291,1 @@\n-                X509Authentication.RSA, T12KeyAgreement.DHE);\n+                List.of(X509Authentication.RSA), T12KeyAgreement.DHE);\n@@ -275,1 +296,1 @@\n-                X509Authentication.RSA_OR_PSS, T12KeyAgreement.DHE);\n+                List.of(X509Authentication.RSA_OR_PSS), T12KeyAgreement.DHE);\n@@ -280,1 +301,1 @@\n-                X509Authentication.RSA, T12KeyAgreement.DHE_EXPORT);\n+                List.of(X509Authentication.RSA), T12KeyAgreement.DHE_EXPORT);\n@@ -295,1 +316,1 @@\n-                X509Authentication.EC, T12KeyAgreement.ECDH);\n+                List.of(X509Authentication.EC), T12KeyAgreement.ECDH);\n@@ -300,1 +321,1 @@\n-                X509Authentication.EC, T12KeyAgreement.ECDH);\n+                List.of(X509Authentication.EC), T12KeyAgreement.ECDH);\n@@ -305,1 +326,2 @@\n-                X509Authentication.EC, T12KeyAgreement.ECDHE);\n+                List.of(X509Authentication.EC, X509Authentication.EDDSA),\n+                T12KeyAgreement.ECDHE);\n@@ -310,1 +332,1 @@\n-                X509Authentication.RSA, T12KeyAgreement.ECDHE);\n+                List.of(X509Authentication.RSA), T12KeyAgreement.ECDHE);\n@@ -315,1 +337,1 @@\n-                X509Authentication.RSA_OR_PSS, T12KeyAgreement.ECDHE);\n+                List.of(X509Authentication.RSA_OR_PSS), T12KeyAgreement.ECDHE);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLKeyExchange.java","additions":54,"deletions":32,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -50,8 +50,0 @@\n-    \/\/ EdDSA algorithms\n-    ED25519                 (0x0807, \"ed25519\", \"ed25519\",\n-                                    \"ed25519\",\n-                                    ProtocolVersion.PROTOCOLS_OF_13),\n-    ED448                   (0x0808, \"ed448\", \"ed448\",\n-                                    \"ed448\",\n-                                    ProtocolVersion.PROTOCOLS_OF_13),\n-\n@@ -75,0 +67,8 @@\n+    \/\/ EdDSA algorithms\n+    ED25519                 (0x0807, \"ed25519\", \"Ed25519\",\n+                                    \"EdDSA\",\n+                                    ProtocolVersion.PROTOCOLS_12_13),\n+    ED448                   (0x0808, \"ed448\", \"Ed448\",\n+                                    \"EdDSA\",\n+                                    ProtocolVersion.PROTOCOLS_12_13),\n+\n@@ -278,10 +278,0 @@\n-        \/\/ Disable EdDSA algorithms for TLS.  Remove this when support is added.\n-        if (id == 0x0807 || id == 0x0808) {\n-            mediator = false;\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                SSLLogger.warning(\n-                    \"Signature algorithm, \" + algorithm +\n-                        \", not supported by JSSE\");\n-            }\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -67,1 +67,4 @@\n-                                    new String[] {\"EC\"}));\n+                                    new String[] {\"EC\"})),\n+    \/\/ Edwards-Curve key\n+    EDDSA       (\"EdDSA\",       new X509PossessionGenerator(\n+                                    new String[] {\"EdDSA\"}));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,734 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8166596\n+ * @summary TLS support for the EdDSA signature algorithm\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm TLSWithEdDSA\n+ *\/\n+\n+\/*\n+ *     SunJSSE does not support dynamic system properties, no way to re-use\n+ *     system properties in samevm\/agentvm mode.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.nio.charset.Charset;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.PKIXBuilderParameters;\n+import java.security.cert.X509CertSelector;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.ECKey;\n+import java.security.interfaces.EdECKey;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.*;\n+import javax.net.ssl.CertPathTrustManagerParameters;\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import javax.net.ssl.X509KeyManager;\n+\n+public class TLSWithEdDSA extends SSLSocketTemplate {\n+    static final boolean DEBUG = false;\n+    static final String PASSWD = \"passphrase\";\n+    static final String DEF_TRUST_ANCHORS = \"CA_DSA_1024:CA_DSA_2048:\" +\n+            \"CA_ECDSA_SECP256R1:CA_ECDSA_SECP384R1:CA_ECDSA_SECP521R1:\" +\n+            \"CA_ED25519:CA_ED448:CA_RSA_2048\";\n+    static final String DEF_ALL_EE = \"EE_ECDSA_SECP256R1:EE_ECDSA_SECP384R1:\" +\n+            \"EE_ECDSA_SECP521R1:EE_RSA_2048:EE_EC_RSA_SECP256R1:\" +\n+            \"EE_DSA_2048:EE_DSA_1024:EE_ED25519:EE_ED448\";\n+    static final List<String> TEST_PROTOS = List.of(\"TLSv1.3\", \"TLSv1.2\",\n+            \"TLSv1.1\", \"TLSv1\");\n+\n+    static CertificateFactory certFac;\n+    static final Map<ParamType, String> clientParameters = new HashMap<>();\n+    static final Map<ParamType, String> serverParameters = new HashMap<>();\n+\n+    final SessionChecker clientChecker;\n+    final SessionChecker serverChecker;\n+    final Class<? extends Throwable> clientException;\n+    final Class<? extends Throwable> serverException;\n+\n+    interface SessionChecker {\n+        public void check(SSLSocket socket);\n+    }\n+\n+    \/**\n+     * Checks to make sure the end-entity certificate presented by the\n+     * peer uses and Ed25519 key.\n+     *\/\n+    final static SessionChecker isPeerEd25519 = new SessionChecker() {\n+        @Override\n+        public void check(SSLSocket sock) {\n+            try {\n+                SSLSession session = sock.getSession();\n+                System.out.println(\"Peer certificate check for Ed25519:\\n\" +\n+                        sessionDump(session));\n+                Certificate[] serverCertChain = session.getPeerCertificates();\n+                X509Certificate tlsCert = (X509Certificate)serverCertChain[0];\n+                keyCheck(tlsCert.getPublicKey(), \"EdDSA\", \"Ed25519\");\n+            } catch (SSLPeerUnverifiedException sslpe) {\n+                throw new RuntimeException(sslpe);\n+            }\n+        }\n+    };\n+\n+    \/**\n+     * Checks to make sure the end-entity certificate presented by the\n+     * peer uses and Ed448 key.\n+     *\/\n+    final static SessionChecker isPeerEd448 = new SessionChecker() {\n+        @Override\n+        public void check(SSLSocket sock) {\n+            try {\n+                SSLSession session = sock.getSession();\n+                System.out.println(\"Peer certificate check for Ed448:\\n\" +\n+                        sessionDump(session));\n+                Certificate[] serverCertChain = session.getPeerCertificates();\n+                X509Certificate tlsCert = (X509Certificate)serverCertChain[0];\n+                keyCheck(tlsCert.getPublicKey(), \"EdDSA\", \"Ed448\");\n+            } catch (SSLPeerUnverifiedException sslpe) {\n+                throw new RuntimeException(sslpe);\n+            }\n+        }\n+    };\n+\n+    \/**\n+     * Checks to make sure the end-entity certificate presented by the\n+     * peer uses an EC secp521r1 key.\n+     *\/\n+    final static SessionChecker isPeerP521 = new SessionChecker() {\n+        @Override\n+        public void check(SSLSocket sock) {\n+            try {\n+                SSLSession session = sock.getSession();\n+                System.out.println(\"Peer certificate check for secp521r1:\\n\" +\n+                        sessionDump(session));\n+                Certificate[] serverCertChain = session.getPeerCertificates();\n+                X509Certificate tlsCert = (X509Certificate)serverCertChain[0];\n+                keyCheck(tlsCert.getPublicKey(), \"EC\", \"secp521r1\");\n+            } catch (SSLPeerUnverifiedException sslpe) {\n+                throw new RuntimeException(sslpe);\n+            }\n+        }\n+    };\n+\n+    \/**\n+     * Returns a String summary of an SSLSession object\n+     *\n+     * @param sess the SSLSession object to be dumped\n+     *\n+     * @return a String representation of the test-relevant portions of the\n+     *      SSLSession object.\n+     *\/\n+    private static String sessionDump(SSLSession sess) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"----- Session Info -----\\n\");\n+        sb.append(\"Protocol: \").append(sess.getProtocol()).append(\"\\n\");\n+        sb.append(\"Cipher Suite: \").append(sess.getCipherSuite());\n+        Certificate[] localCerts = sess.getLocalCertificates();\n+        if (localCerts != null) {\n+            sb.append(\"\\nLocal Certs:\");\n+            int i = 0;\n+            for (Certificate cert : localCerts) {\n+                sb.append(String.format(\"\\n   [%d]: %s\", i++,\n+                        ((X509Certificate)cert).getSubjectX500Principal()));\n+            }\n+        }\n+        try {\n+            Certificate[] peerCerts = sess.getPeerCertificates();\n+            if (peerCerts != null) {\n+                sb.append(\"\\nPeer Certs:\");\n+                int i = 0;\n+                for (Certificate cert : peerCerts) {\n+                    sb.append(String.format(\"\\n   [%d]: %s\", i++,\n+                            ((X509Certificate)cert).getSubjectX500Principal()));\n+                }\n+            }\n+        } catch (SSLPeerUnverifiedException sslex) {\n+            throw new RuntimeException(sslex);\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Checks to make sure the public key conforms to the expected key type\n+     * and (where applicable) curve.\n+     *\n+     * @param pubKey the public key to be checked\n+     * @param expPkType the expected key type (RSA\/DSA\/EC\/EdDSA)\n+     * @param expCurveName if an EC\/EdDSA key, the expected curve\n+     *\/\n+    private static void keyCheck(PublicKey pubKey, String expPkType,\n+            String expCurveName) {\n+        String curveName = null;\n+        String pubKeyAlg = pubKey.getAlgorithm();\n+        if (!expPkType.equalsIgnoreCase(pubKeyAlg)) {\n+            throw new RuntimeException(\"Expected \" + expPkType + \" key, got \" +\n+                    pubKeyAlg);\n+        }\n+\n+        \/\/ Check the curve type\n+        if (expCurveName != null) {\n+            switch (pubKeyAlg) {\n+                case \"EdDSA\":\n+                    curveName = ((EdECKey)pubKey).getParams().getName().\n+                            toLowerCase();\n+                    if (!expCurveName.equalsIgnoreCase(curveName)) {\n+                        throw new RuntimeException(\"Expected \" + expCurveName +\n+                                \" curve, \" + \"got \" + curveName);\n+                    }\n+                    break;\n+                case \"EC\":\n+                    curveName = ((ECKey)pubKey).getParams().toString().\n+                            toLowerCase();\n+                    if (!curveName.contains(expCurveName.toLowerCase())) {\n+                        throw new RuntimeException(\"Expected \" + expCurveName +\n+                                \" curve, \" + \"got \" + curveName);\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\n+                            \"Unsupported key type: \" + pubKeyAlg);\n+            }\n+        }\n+        System.out.format(\"Found key: %s \/ %s\\n\", pubKeyAlg,\n+                curveName != null ? curveName : \"\");\n+    }\n+\n+    TLSWithEdDSA(SessionChecker cliChk, Class<? extends Throwable> cliExpExc,\n+            SessionChecker servChk, Class<? extends Throwable> servExpExc) {\n+        super();\n+        clientChecker = cliChk;\n+        clientException = cliExpExc;\n+        serverChecker = servChk;\n+        serverException = servExpExc;\n+    }\n+\n+    \/**\n+     * Creates an SSLContext for use with the client side of this test.  This\n+     * uses parameters held in the static client parameters map.\n+     *\n+     * @return an initialized SSLContext for use with the client.\n+     *\n+     * @throws Exception if any downstream errors occur during key store\n+     *      creation, key\/trust manager factory creation or context\n+     *      initialization.\n+     *\/\n+    @Override\n+    protected SSLContext createClientSSLContext() throws Exception {\n+        KeyStore clientKeyStore = createKeyStore(\n+                clientParameters.getOrDefault(ParamType.KSENTRIES, \"\"),\n+                PASSWD.toCharArray());\n+        KeyStore clientTrustStore = createTrustStore(\n+                clientParameters.getOrDefault(ParamType.TSENTRIES,\n+                        DEF_TRUST_ANCHORS));\n+        return createCtxCommon(clientKeyStore,\n+                clientParameters.get(ParamType.CERTALIAS), PASSWD.toCharArray(),\n+                clientTrustStore, \"jdk.tls.client.SignatureSchemes\",\n+                clientParameters.get(ParamType.SIGALGS));\n+    }\n+\n+    \/**\n+     * Creates an SSLContext for use with the server side of this test.  This\n+     * uses parameters held in the static server parameters map.\n+     *\n+     * @return an initialized SSLContext for use with the server.\n+     *\n+     * @throws Exception if any downstream errors occur during key store\n+     *      creation, key\/trust manager factory creation or context\n+     *      initialization.\n+     *\/\n+    @Override\n+    protected SSLContext createServerSSLContext() throws Exception {\n+        KeyStore serverKeyStore = createKeyStore(\n+                serverParameters.getOrDefault(ParamType.KSENTRIES, \"\"),\n+                PASSWD.toCharArray());\n+        KeyStore serverTrustStore = createTrustStore(\n+                serverParameters.getOrDefault(ParamType.TSENTRIES,\n+                        DEF_TRUST_ANCHORS));\n+        return createCtxCommon(serverKeyStore,\n+                serverParameters.get(ParamType.CERTALIAS), PASSWD.toCharArray(),\n+                serverTrustStore, \"jdk.tls.server.SignatureSchemes\",\n+                serverParameters.get(ParamType.SIGALGS));\n+    }\n+\n+    \/**\n+     * Create a trust store containing any CA certificates designated as\n+     * trust anchors.\n+     *\n+     * @return the trust store populated with the root CA certificate.\n+     *\n+     * @throws GeneralSecurityException if any certificates cannot be added to\n+     *      the key store.\n+     *\/\n+    private static KeyStore createTrustStore(String certEnumNames)\n+            throws GeneralSecurityException {\n+        KeyStore.Builder keyStoreBuilder =\n+                KeyStore.Builder.newInstance(\"PKCS12\", null,\n+                        new KeyStore.PasswordProtection(PASSWD.toCharArray()));\n+        KeyStore ks = keyStoreBuilder.getKeyStore();\n+        for (String certName : certEnumNames.split(\":\")) {\n+            try {\n+                SSLSocketTemplate.Cert cert =\n+                        SSLSocketTemplate.Cert.valueOf(certName);\n+                ks.setCertificateEntry(certName, pem2Cert(cert.certStr));\n+            } catch (IllegalArgumentException iae) {\n+                System.out.println(\"Unable to find Cert enum entry for \" +\n+                        certName + \", skipping\");\n+            }\n+        }\n+        return ks;\n+    }\n+\n+    \/**\n+     * Create a key store containing any end-entity private keys\/certs\n+     * specified in the parameters.\n+     *\n+     * @param certEnumNames a colon-delimited list of String values that are\n+     *      the names of the SSLSocketTemplate.Cert enumeration entries.\n+     * @param pass the desired password for the resulting KeyStore object.\n+     *\n+     * @return a populated, loaded KeyStore ready for use.\n+     *\n+     * @throws GeneralSecurityException if any issues occur while setting\n+     *      the private key or certificate entries.\n+     *\/\n+    private static KeyStore createKeyStore(String certEnumNames, char[] pass)\n+            throws GeneralSecurityException {\n+        KeyStore.Builder keyStoreBuilder =\n+                KeyStore.Builder.newInstance(\"PKCS12\", null,\n+                        new KeyStore.PasswordProtection(pass));\n+        KeyStore ks = keyStoreBuilder.getKeyStore();\n+        if (certEnumNames != null && !certEnumNames.isEmpty()) {\n+            for (String certName : certEnumNames.split(\":\")) {\n+                try {\n+                    SSLSocketTemplate.Cert cert =\n+                            SSLSocketTemplate.Cert.valueOf(certName);\n+                    ks.setKeyEntry(certName,\n+                            pem2PrivKey(cert.privKeyStr, cert.keyAlgo), pass,\n+                            new Certificate[] { pem2Cert(cert.certStr) });\n+                } catch (IllegalArgumentException iae) {\n+                    System.out.println(\"Unable to find Cert enum entry for \" +\n+                            certName + \", skipping\");\n+                }\n+            }\n+        }\n+\n+        return ks;\n+    }\n+\n+    \/**\n+     * Covert a PEM-encoded certificate into a X509Certificate object.\n+     *\n+     * @param certPem the PEM encoding for the certificate.\n+     *\n+     * @return the corresponding X509Certificate object for the provided PEM.\n+     *\n+     * @throws CertificateException if any decoding errors occur.\n+     *\/\n+    private static X509Certificate pem2Cert(String certPem)\n+            throws CertificateException {\n+        return (X509Certificate)certFac.generateCertificate(\n+                new ByteArrayInputStream(certPem.getBytes(\n+                        Charset.forName(\"UTF-8\"))));\n+    }\n+\n+    \/**\n+     * Covert a PEM-encoded PKCS8 private key into a PrivateKey object.\n+     *\n+     * @param keyPem the PEM encoding for the certificate.\n+     * @param keyAlg the algorithm for the private key contained in the PKCS8\n+     *  `   encoding.\n+     *\n+     * @return the corresponding PrivateKey object for the provided PEM.\n+     *\n+     * @throws GeneralSecurityException if any decoding errors occur.\n+     *\/\n+    private static PrivateKey pem2PrivKey(String keyPem, String keyAlg)\n+            throws GeneralSecurityException {\n+        PKCS8EncodedKeySpec p8Spec = new PKCS8EncodedKeySpec(\n+                Base64.getMimeDecoder().decode(keyPem));\n+        KeyFactory keyFac = KeyFactory.getInstance(keyAlg);\n+        return keyFac.generatePrivate(p8Spec);\n+    }\n+\n+    \/**\n+     * Create an SSLContext for use with the client or server sides of this\n+     * test.\n+     *\n+     * @param keys the key store object for this SSLContext.\n+     * @param alias optional alias specifier to exclusively use that alias for\n+     *      TLS connections.\n+     * @param pass the key store password\n+     * @param trust the trust store object\n+     * @param sigAlgProp the signature algorithm property name to set\n+     *      (reserved for future use pending the fix for JDK-8255867)\n+     * @param sigAlgVal the property value to be applied.\n+     *\n+     * @return an initialized SSLContext object.\n+     *\n+     * @throws IOException if any IOExceptions during manager factory creation\n+     *      take place\n+     * @throws GeneralSecurityException any other failure during SSLContext\n+     *      creation\/initialization\n+     *\/\n+    private static SSLContext createCtxCommon(KeyStore keys, String alias,\n+            char[] pass, KeyStore trust, String sigAlgProp, String sigAlgVal)\n+            throws IOException, GeneralSecurityException {\n+        SSLContext ctx;\n+        if (sigAlgVal != null && !sigAlgVal.isEmpty()) {\n+            System.setProperty(sigAlgProp, sigAlgVal);\n+        }\n+\n+        \/\/ If an alias is specified use our local AliasKeyManager\n+        KeyManager[] kms = (alias != null && !alias.isEmpty()) ?\n+                new KeyManager[] { new AliasKeyManager(keys, pass, alias) } :\n+                createKeyManagerFactory(keys, pass).getKeyManagers();\n+\n+        ctx = SSLContext.getInstance(\"TLS\");\n+        ctx.init(kms, createTrustManagerFactory(trust).getTrustManagers(),\n+                null);\n+        return ctx;\n+    }\n+\n+    \/**\n+     * Creates a KeyManagerFactory for use during SSLContext initialization.\n+     *\n+     * @param ks the KeyStore forming the base of the KeyManagerFactory\n+     * @param passwd the password to use for the key store\n+     *\n+     * @return the initialized KeyManagerFactory\n+     *\n+     * @throws IOException any IOExceptions during key manager factory\n+     *      initialization.\n+     * @throws GeneralSecurityException if any failures during instantiation\n+     *      take place.\n+     *\/\n+    private static KeyManagerFactory createKeyManagerFactory(KeyStore ks,\n+            char[] passwd) throws IOException, GeneralSecurityException {\n+        KeyManagerFactory kmf;\n+        kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passwd);\n+\n+        KeyManager[] kmgrs = kmf.getKeyManagers();\n+        X509ExtendedKeyManager xkm = (X509ExtendedKeyManager)kmgrs[0];\n+        return kmf;\n+    }\n+\n+    \/**\n+     * Creates a TrustManagerFactory for use during SSLContext initialization.\n+     *\n+     * @param trustStrore the KeyStore forming the base of the\n+     *      TrustManagerFactory\n+     *\n+     * @return the initialized TrustManagerFactory\n+     *\n+     * @throws IOException any IOExceptions during trust manager factory\n+     *      initialization.\n+     * @throws GeneralSecurityException if any failures during instantiation\n+     *      take place.\n+     *\/\n+    private static TrustManagerFactory createTrustManagerFactory(\n+            KeyStore trustStore) throws IOException, GeneralSecurityException {\n+        TrustManagerFactory tmf;\n+        PKIXBuilderParameters pkixParams =\n+                new PKIXBuilderParameters(trustStore, new X509CertSelector());\n+        pkixParams.setRevocationEnabled(false);\n+        tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(new CertPathTrustManagerParameters(pkixParams));\n+        return tmf;\n+    }\n+\n+    \/*\n+     * Configure the client side socket.\n+     *\/\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        String pVal;\n+        if ((pVal = clientParameters.get(ParamType.PROTOS)) != null) {\n+            socket.setEnabledProtocols(pVal.split(\":\"));\n+        }\n+\n+        if ((pVal = clientParameters.get(ParamType.CIPHERS)) != null) {\n+            socket.setEnabledCipherSuites(pVal.split(\":\"));\n+        }\n+    }\n+\n+    \/*\n+     * Configure the server side socket.\n+     *\/\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        String pVal;\n+        try {\n+            socket.setReuseAddress(true);\n+            if ((pVal = serverParameters.get(ParamType.PROTOS)) != null) {\n+                socket.setEnabledProtocols(pVal.split(\":\"));\n+            }\n+\n+            if ((pVal = serverParameters.get(ParamType.CIPHERS)) != null) {\n+                socket.setEnabledCipherSuites(pVal.split(\":\"));\n+            }\n+\n+            pVal = serverParameters.get(ParamType.CLIAUTH);\n+            socket.setWantClientAuth(\"WANT\".equalsIgnoreCase(pVal));\n+            socket.setNeedClientAuth(\"NEED\".equalsIgnoreCase(pVal));\n+        } catch (SocketException se) {\n+            throw new RuntimeException(se);\n+        }\n+    }\n+\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        InputStream sslIS = socket.getInputStream();\n+        OutputStream sslOS = socket.getOutputStream();\n+\n+        sslIS.read();\n+        sslOS.write(85);\n+        sslOS.flush();\n+\n+        if (serverChecker != null) {\n+            serverChecker.check(socket);\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(SSLSocket socket) throws Exception {\n+        InputStream sslIS = socket.getInputStream();\n+        OutputStream sslOS = socket.getOutputStream();\n+\n+        sslOS.write(280);\n+        sslOS.flush();\n+        sslIS.read();\n+\n+        if (clientChecker != null) {\n+            clientChecker.check(socket);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (DEBUG) {\n+            System.setProperty(\"javax.net.debug\", \"ssl:handshake\");\n+        }\n+        certFac = CertificateFactory.getInstance(\"X.509\");\n+        String testFormat;\n+\n+        System.out.println(\"===== Test KeyManager alias retrieval =====\");\n+        keyManagerTests(DEF_ALL_EE, \"EdDSA\",\n+                new String[] {\"ee_ed25519\", \"ee_ed448\"});\n+\n+        testFormat =\n+                \"===== Basic Ed25519 Server-side Authentication: %s =====\\n\";\n+        serverParameters.put(ParamType.KSENTRIES, \"EE_ED25519:EE_RSA_2048\");\n+        runtest(testFormat, isPeerEd25519, null, null, null);\n+\n+        testFormat =\n+                \"===== Basic Ed448 Server-side Authentication: %s =====\\n\";\n+        serverParameters.put(ParamType.KSENTRIES, \"EE_ED448:EE_RSA_2048\");\n+        runtest(testFormat, isPeerEd448, null, null, null);\n+\n+        testFormat = \"===== EC favored over EdDSA by default: %s =====\\n\";\n+        serverParameters.put(ParamType.KSENTRIES,\n+                \"EE_ED25519:EE_ECDSA_SECP521R1\");\n+        runtest(testFormat, isPeerP521, null, null, null);\n+\n+        testFormat = \"===== Override EC favoring by alias: %s =====\\n\";\n+        serverParameters.put(ParamType.CERTALIAS, \"EE_ED25519\");\n+        runtest(testFormat, isPeerEd25519, null, null, null);\n+        serverParameters.remove(ParamType.CERTALIAS);\n+\n+        testFormat = \"===== EdDSA Client Authentication: %s =====\\n\";\n+        serverParameters.put(ParamType.KSENTRIES, \"EE_RSA_2048\");\n+        serverParameters.put(ParamType.CLIAUTH, \"NEED\");\n+        clientParameters.put(ParamType.KSENTRIES, \"EE_ED25519\");\n+        runtest(testFormat, null, null, isPeerEd25519, null);\n+    }\n+\n+    private static void keyManagerTests(String keyStoreSpec, String keyType,\n+            String[] expAliases)\n+            throws GeneralSecurityException, IOException {\n+        char[] passChar = PASSWD.toCharArray();\n+\n+        \/\/ Create the KeyManager factory and resulting KeyManager\n+        KeyManagerFactory kmf = createKeyManagerFactory(\n+                createKeyStore(keyStoreSpec, passChar), passChar);\n+        KeyManager[] kMgrs = kmf.getKeyManagers();\n+        X509KeyManager xkm = (X509KeyManager)kMgrs[0];\n+\n+        String[] cliEdDSAAlises = xkm.getClientAliases(keyType, null);\n+        System.out.format(\"Client Aliases (%s): \", keyType);\n+        for (String alias : cliEdDSAAlises) {\n+            System.out.print(alias + \" \");\n+        }\n+        System.out.println();\n+\n+        String[] servEdDSAAliases = xkm.getServerAliases(keyType, null);\n+        System.out.format(\"Server Aliases (%s): \", keyType);\n+            for (String alias : servEdDSAAliases) {\n+            System.out.print(alias + \" \");\n+        }\n+        System.out.println();\n+\n+        if (!Arrays.equals(cliEdDSAAlises, expAliases)) {\n+            throw new RuntimeException(\"Client alias mismatch\");\n+        } else if (!Arrays.equals(servEdDSAAliases, expAliases)) {\n+            throw new RuntimeException(\"Server alias mismatch\");\n+        }\n+    }\n+\n+    private static void runtest(String testNameFmt, SessionChecker cliChk,\n+            Class<? extends Throwable> cliExpExc, SessionChecker servChk,\n+            Class<? extends Throwable> servExpExc) {\n+        TEST_PROTOS.forEach(protocol -> {\n+            clientParameters.put(ParamType.PROTOS, protocol);\n+            TLSWithEdDSA testObj = new TLSWithEdDSA(cliChk, cliExpExc, servChk,\n+                        servExpExc);\n+            System.out.format(testNameFmt, protocol);\n+            try {\n+                testObj.run();\n+                if (testObj.clientException != null ||\n+                        testObj.serverException != null) {\n+                    throw new RuntimeException(\"Expected exception from \" +\n+                            \"either client or server but was missed\");\n+                }\n+            } catch (Exception exc) {\n+                if (testObj.clientException == null &&\n+                        testObj.serverException == null) {\n+                    throw new RuntimeException(\n+                            \"Expected test failure did not occur\");\n+                } else if (testObj.clientException != null &&\n+                        !testObj.clientException.isAssignableFrom(exc.getClass())) {\n+                    throw new RuntimeException(\"Unexpected client exception \" +\n+                            \"detected: Expected \" +\n+                            testObj.clientException.getName() +\n+                            \", got \" + exc.getClass().getName());\n+\n+                }  else if (testObj.serverException != null &&\n+                        !testObj.serverException.isAssignableFrom(exc.getClass())) {\n+                    throw new RuntimeException(\"Unexpected client exception \" +\n+                            \"detected: Expected \" +\n+                            testObj.serverException.getName() +\n+                            \", got \" + exc.getClass().getName());\n+                }\n+            }\n+            System.out.println();\n+        });\n+    }\n+\n+    \/**\n+     * A Custom KeyManager that allows the user to specify a key\/certificate\n+     * by alias to be used for any TLS authentication actions.\n+     *\/\n+    static class AliasKeyManager implements X509KeyManager {\n+        private final String alias;\n+        private final KeyStore keystore;\n+        private final char[] pass;\n+\n+        public AliasKeyManager(KeyStore keystore, char[] pass, String alias) {\n+            this.keystore = Objects.requireNonNull(keystore);\n+            this.alias = Objects.requireNonNull(alias);\n+            this.pass = Objects.requireNonNull(pass);\n+        }\n+\n+        @Override\n+        public PrivateKey getPrivateKey(String alias) {\n+            try {\n+                return (PrivateKey)keystore.getKey(alias, pass);\n+            } catch (GeneralSecurityException exc) {\n+                throw new RuntimeException(exc);\n+            }\n+        }\n+\n+        @Override\n+        public X509Certificate[] getCertificateChain(String alias) {\n+            try {\n+                Certificate[] certAr = keystore.getCertificateChain(alias);\n+                return (certAr != null) ? Arrays.copyOf(certAr, certAr.length,\n+                        X509Certificate[].class) : null;\n+            } catch (KeyStoreException ke) {\n+                throw new RuntimeException(ke);\n+            }\n+        }\n+\n+        @Override\n+        public String chooseClientAlias(String[] keyType, Principal[] issuers,\n+                Socket socket) {\n+            \/\/ Blindly return the one selected alias.\n+            return alias;\n+        }\n+\n+        @Override\n+        public String chooseServerAlias(String keyType, Principal[] issuers,\n+                Socket socket) {\n+            \/\/ Blindly return the one selected alias.\n+            return alias;\n+        }\n+\n+        @Override\n+        public String[] getClientAliases(String keyType, Principal[] issuers) {\n+            \/\/ There can be only one!\n+            return new String[] { alias };\n+        }\n+\n+        @Override\n+        public String[] getServerAliases(String keyType, Principal[] issuers) {\n+            \/\/ There can be only one!\n+            return new String[] { alias };\n+        }\n+    }\n+\n+    static enum ParamType {\n+        PROTOS,\n+        CIPHERS,\n+        SIGALGS,\n+        CLIAUTH,\n+        KSENTRIES,\n+        TSENTRIES,\n+        CERTALIAS\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/TLSWithEdDSA.java","additions":734,"deletions":0,"binary":false,"changes":734,"status":"added"}]}