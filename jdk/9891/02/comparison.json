{"files":[{"patch":"@@ -4407,0 +4407,75 @@\n+\n+bool Arguments::parse_malloc_limit_size(const char* s, size_t* out) {\n+  julong limit = 0;\n+  Arguments::ArgsRange range = parse_memory_size(s, &limit, 1, SIZE_MAX);\n+  switch (range) {\n+  case ArgsRange::arg_in_range:\n+    *out = (size_t)limit;\n+    return true;\n+  case ArgsRange::arg_too_big: \/\/ only possible on 32-bit\n+    vm_exit_during_initialization(\"MallocLimit: too large\", s);\n+    break;\n+  case ArgsRange::arg_too_small:\n+    vm_exit_during_initialization(\"MallocLimit: limit must be > 0\");\n+    break;\n+  default:\n+    break;\n+  }\n+  return false;\n+}\n+\n+\/\/ Helper for parse_malloc_limits\n+void Arguments::parse_single_category_limit(char* expression, size_t limits[mt_number_of_types]) {\n+  \/\/ <category>:<limit>\n+  char* colon = ::strchr(expression, ':');\n+  if (colon == nullptr) {\n+    vm_exit_during_initialization(\"MallocLimit: colon missing\", expression);\n+  }\n+  *colon = '\\0';\n+  MEMFLAGS f = NMTUtil::string_to_flag(expression);\n+  if (f == mtNone) {\n+    vm_exit_during_initialization(\"MallocLimit: invalid nmt category\", expression);\n+  }\n+  if (parse_malloc_limit_size(colon + 1, limits + (int)f) == false) {\n+    vm_exit_during_initialization(\"Invalid MallocLimit size\", colon + 1);\n+  }\n+}\n+\n+void Arguments::parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]) {\n+\n+  \/\/ Reset output to 0\n+  *total_limit = 0;\n+  for (int i = 0; i < mt_number_of_types; i ++) {\n+    limits[i] = 0;\n+  }\n+\n+  \/\/ We are done if the option is not given.\n+  if (MallocLimit == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ Global form?\n+  if (parse_malloc_limit_size(MallocLimit, total_limit)) {\n+    return;\n+  }\n+\n+  \/\/ No. So it must be in category-specific form: MallocLimit=<nmt category>:<size>[,<nmt category>:<size> ..]\n+  char* copy = os::strdup(MallocLimit);\n+  if (copy == nullptr) {\n+    vm_exit_out_of_memory(strlen(MallocLimit), OOM_MALLOC_ERROR, \"MallocLimit\");\n+  }\n+\n+  char* p = copy, *q;\n+  do {\n+    q = p;\n+    p = ::strchr(q, ',');\n+    if (p != nullptr) {\n+      *p = '\\0';\n+      p ++;\n+    }\n+    parse_single_category_limit(q, limits);\n+  } while (p != nullptr);\n+\n+  os::free(copy);\n+\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -482,0 +482,4 @@\n+  \/\/ Helpers for parse_malloc_limits\n+  static bool parse_malloc_limit_size(const char* s, size_t* out);\n+  static void parse_single_category_limit(char* expression, size_t limits[mt_number_of_types]);\n+\n@@ -656,0 +660,10 @@\n+  \/\/ Parse diagnostic NMT switch \"MallocLimit\" and return the found limits.\n+  \/\/ 1) If option is not given, it will set all limits to 0 (aka \"no limit\").\n+  \/\/ 2) If option is given in the global form (-XX:MallocLimit=<size>), it\n+  \/\/    will return the size in *total_limit.\n+  \/\/ 3) If option is given in its per-NMT-category form (-XX:MallocLimit=<category>:<size>[,<category>:<size>]),\n+  \/\/    it will return all found limits in the limits array.\n+  \/\/ 4) If option is malformed, it will exit the VM.\n+  \/\/ For (2) and (3), limits not affected by the switch will be set to 0.\n+  static void parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1368,0 +1368,10 @@\n+  product(ccstr, MallocLimit, nullptr, DIAGNOSTIC,                          \\\n+          \"Limit malloc allocation size from VM. Reaching the limit will \"  \\\n+          \"trigger a fatal error. This feature requires \"                   \\\n+          \"NativeMemoryTracking=summary or NativeMemoryTracking=detail.\"    \\\n+          \"Usage:\"                                                          \\\n+          \"- MallocLimit=<size> to set a total limit. \"                     \\\n+          \"- MallocLimit=<NMT category>:<size>[,<NMT category>:<size>...] \" \\\n+          \"  to set one or more category-specific limits.\"                  \\\n+          \"Example: -XX:MallocLimit=compiler:500m\")                         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n@@ -26,0 +27,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/arguments.hpp\"\n@@ -34,0 +37,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -38,0 +42,2 @@\n+size_t MallocMemorySummary::_limits_per_category[mt_number_of_types] = { 0 };\n+size_t MallocMemorySummary::_total_limit = 0;\n@@ -91,0 +97,53 @@\n+  initialize_limit_handling();\n+}\n+\n+void MallocMemorySummary::initialize_limit_handling() {\n+  \/\/ Initialize limit handling.\n+  Arguments::parse_malloc_limits(&_total_limit, _limits_per_category);\n+\n+  if (_total_limit > 0) {\n+    log_info(nmt)(\"MallocLimit: total limit: \" SIZE_FORMAT \"%s\",\n+                  byte_size_in_proper_unit(_total_limit),\n+                  proper_unit_for_byte_size(_total_limit));\n+  } else {\n+    for (int i = 0; i < mt_number_of_types; i ++) {\n+      size_t catlim = _limits_per_category[i];\n+      if (catlim > 0) {\n+        log_info(nmt)(\"MallocLimit: category \\\"%s\\\" limit: \" SIZE_FORMAT \"%s\",\n+                      NMTUtil::flag_to_name((MEMFLAGS)i),\n+                      byte_size_in_proper_unit(catlim),\n+                      proper_unit_for_byte_size(catlim));\n+      }\n+    }\n+  }\n+}\n+\n+void MallocMemorySummary::total_limit_reached(size_t size, size_t limit) {\n+  \/\/ Assert in both debug and release, but allow error reporting to malloc beyond limits.\n+  if (!VMError::is_error_reported()) {\n+    fatal(\"MallocLimit: reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n+          size, limit);\n+  }\n+}\n+\n+void MallocMemorySummary::category_limit_reached(size_t size, size_t limit, MEMFLAGS flag) {\n+  \/\/ Assert in both debug and release, but allow error reporting to malloc beyond limits.\n+  if (!VMError::is_error_reported()) {\n+    fatal(\"MallocLimit: category \\\"%s\\\" reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n+          NMTUtil::flag_to_name(flag), size, limit);\n+  }\n+}\n+\n+void MallocMemorySummary::print_limits(outputStream* st) {\n+  if (_total_limit != 0) {\n+    st->print(\"MallocLimit: \" SIZE_FORMAT, _total_limit);\n+  } else {\n+    bool first = true;\n+    for (int i = 0; i < mt_number_of_types; i ++) {\n+      if (_limits_per_category[i] > 0) {\n+        st->print(\"%s%s:\" SIZE_FORMAT, (first ? \"MallocLimit: \" : \", \"),\n+                  NMTUtil::flag_to_name((MEMFLAGS)i), _limits_per_category[i]);\n+        first = false;\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n@@ -199,0 +200,28 @@\n+  \/\/ Malloc Limit handling (-XX:MallocLimit)\n+  static size_t _limits_per_category[mt_number_of_types];\n+  static size_t _total_limit;\n+\n+  static void initialize_limit_handling();\n+  static void total_limit_reached(size_t size, size_t limit);\n+  static void category_limit_reached(size_t size, size_t limit, MEMFLAGS flag);\n+\n+  static void check_limits_after_allocation(MEMFLAGS flag) {\n+    \/\/ We can only either have a total limit or category specific limits,\n+    \/\/ not both.\n+    if (_total_limit != 0) {\n+      size_t s = as_snapshot()->total();\n+      if (s > _total_limit) {\n+        total_limit_reached(s, _total_limit);\n+      }\n+    } else {\n+      size_t per_cat_limit = _limits_per_category[(int)flag];\n+      if (per_cat_limit > 0) {\n+        const MallocMemory* mm = as_snapshot()->by_type(flag);\n+        size_t s = mm->malloc_size() + mm->arena_size();\n+        if (s > per_cat_limit) {\n+          category_limit_reached(s, per_cat_limit, flag);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -205,0 +234,1 @@\n+     check_limits_after_allocation(flag);\n@@ -222,0 +252,1 @@\n+     check_limits_after_allocation(flag);\n@@ -237,0 +268,2 @@\n+\n+  static void print_limits(outputStream* st);\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2028, 2022 SAP SE. All rights reserved.\n@@ -76,0 +77,4 @@\n+  } else {\n+    if (MallocLimit != nullptr) {\n+      warning(\"MallocLimit will be ignored since NMT is disabled.\");\n+    }\n@@ -113,0 +118,1 @@\n+    MallocMemorySummary::print_limits(output);\n@@ -157,0 +163,1 @@\n+  MallocMemorySummary::print_limits(out);\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#define MEMORY_TYPE_DECLARE_NAME(type, human_readable) \\\n-  human_readable,\n-\n@@ -35,1 +32,4 @@\n-const char* NMTUtil::_memory_type_names[] = {\n+#define MEMORY_TYPE_DECLARE_NAME(type, human_readable) \\\n+  { #type, human_readable },\n+\n+NMTUtil::S NMTUtil::_strings[] = {\n@@ -89,0 +89,13 @@\n+\n+MEMFLAGS NMTUtil::string_to_flag(const char* s) {\n+  for (int i = 0; i < mt_number_of_types; i ++) {\n+    assert(::strlen(_strings[i].enum_s) > 2, \"Sanity\"); \/\/ should always start with \"mt\"\n+    if (::strcasecmp(_strings[i].human_readable, s) == 0 ||\n+        ::strcasecmp(_strings[i].enum_s, s) == 0 ||\n+        ::strcasecmp(_strings[i].enum_s + 2, s) == 0) \/\/ \"mtXXX\" -> match also \"XXX\" or \"xxx\"\n+    {\n+      return (MEMFLAGS)i;\n+    }\n+  }\n+  return mtNone;\n+}\n","filename":"src\/hotspot\/share\/services\/nmtCommon.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    return _memory_type_names[flag_to_index(flag)];\n+    return _strings[flag_to_index(flag)].human_readable;\n@@ -118,0 +118,5 @@\n+  \/\/ Given a string, return associated flag. mtNone if name is invalid.\n+  \/\/ String can be either the human readable name or the\n+  \/\/ stringified enum (with or without leading \"mt\". In all cases, case is ignored.\n+  static MEMFLAGS string_to_flag(const char* name);\n+\n@@ -122,1 +127,5 @@\n-  static const char* _memory_type_names[mt_number_of_types];\n+  struct S {\n+    const char* enum_s; \/\/ e.g. \"mtNMT\"\n+    const char* human_readable; \/\/ e.g. \"Native Memory Tracking\"\n+  };\n+  static S _strings[mt_number_of_types];\n","filename":"src\/hotspot\/share\/services\/nmtCommon.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=global-limit\n+ * @summary Verify -XX:MallocLimit with a global limit\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest global-limit\n+ *\/\n+\n+\/*\n+ * @test id=compiler-limit\n+ * @summary Verify -XX:MallocLimit with a compiler-specific limit (for \"mtCompiler\" category)\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest compiler-limit\n+ *\/\n+\n+\/*\n+ * @test id=multi-limit\n+ * @summary Verify -XX:MallocLimit with multiple limits\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest multi-limit\n+ *\/\n+\n+\/*\n+ * @test id=valid-settings\n+ * @summary Verify -XX:MallocLimit rejects invalid settings\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest valid-settings\n+ *\/\n+\n+\/*\n+ * @test id=invalid-settings\n+ * @summary Verify -XX:MallocLimit rejects invalid settings\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest invalid-settings\n+ *\/\n+\n+\/*\n+ * @test id=limit-without-nmt\n+ * @summary Verify that the VM warns if -XX:MallocLimit is given but NMT is disabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest limit-without-nmt\n+ *\/\n+\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class MallocLimitTest {\n+\n+    private static ProcessBuilder processBuilderWithSetting(String... extraSettings) {\n+        List<String> args = new ArrayList<>();\n+        args.add(\"-XX:+UnlockDiagnosticVMOptions\"); \/\/ MallocLimit is diagnostic\n+        args.add(\"-Xmx64m\");\n+        args.add(\"-XX:-CreateCoredumpOnCrash\");\n+        args.add(\"-Xlog:nmt\");\n+        args.add(\"-XX:NativeMemoryTracking=summary\");\n+        args.addAll(Arrays.asList(extraSettings));\n+        args.add(\"-version\");\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(args);\n+        return pb;\n+    }\n+\n+    private static void testGlobalLimit() throws IOException {\n+        long smallMemorySize = 1024*1024; \/\/ 1m\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + smallMemorySize);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"[nmt] MallocLimit: total limit: 1024K\"); \/\/ printed by byte_size_in_proper_unit()\n+        String s = output.firstMatch(\".*MallocLimit: reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n+        Asserts.assertNotNull(s);\n+        long size = Long.parseLong(s);\n+        Asserts.assertGreaterThan(size, smallMemorySize);\n+    }\n+\n+    private static void testCompilerLimit() throws IOException {\n+        \/\/ Here, we count on the VM, running with -Xcomp and with 1m of arena space allowed, will start a compilation\n+        \/\/ and then trip over the limit.\n+        \/\/ If limit is too small, Compiler stops too early and we won't get a Retry file (see below, we check that).\n+        \/\/ If limit is too large, we may not trigger it for java -version.\n+        \/\/ 1m seems to work out fine.\n+        long smallMemorySize = 1024*1024; \/\/ 1m\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=compiler:\" + smallMemorySize,\n+                \"-Xcomp\" \/\/ make sure we hit the compiler category limit\n+        );\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Compiler\\\" limit: 1024K\"); \/\/ printed by byte_size_in_proper_unit\n+        String s = output.firstMatch(\".*MallocLimit: category \\\"Compiler\\\" reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n+        Asserts.assertNotNull(s);\n+        long size = Long.parseLong(s);\n+        output.shouldContain(\"Compiler replay data is saved as\");\n+        Asserts.assertGreaterThan(size, smallMemorySize);\n+    }\n+\n+    private static void testMultiLimit() throws IOException {\n+        long smallMemorySize = 1024; \/\/ 1k\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=mtOther:2g,compiler:1g,internal:\" + smallMemorySize);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Compiler\\\" limit: 1024M\");\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Internal\\\" limit: 1024B\");\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Other\\\" limit: 2048M\");\n+        String s = output.firstMatch(\".*MallocLimit: category \\\"Internal\\\" reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n+        long size = Long.parseLong(s);\n+        Asserts.assertGreaterThan(size, smallMemorySize);\n+    }\n+\n+    private static void testValidSetting(String setting, String... expected_output) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + setting);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        for (String expected : expected_output) {\n+            output.shouldContain(expected);\n+        }\n+    }\n+\n+    private static void testValidSettings() throws IOException {\n+        \/\/ Test a number of valid settings.\n+        testValidSetting(\n+                \"2097152k\",\n+                \"[nmt] MallocLimit: total limit: 2048M\",\n+                \"[nmt] NMT initialized: summary\"\n+        );\n+        testValidSetting(\n+                \"gc:1234567891,mtInternal:987654321,Object Monitors:1g\",\n+                \"[nmt] MallocLimit: category \\\"GC\\\" limit: 1177M\",\n+                \"[nmt] MallocLimit: category \\\"Internal\\\" limit: 941M\",\n+                \"[nmt] MallocLimit: category \\\"Object Monitors\\\" limit: 1024M\",\n+                \"[nmt] NMT initialized: summary\"\n+        );\n+        \/\/ Set all categories individually:\n+        testValidSetting(\n+                \"JavaHeap:1024m,Class:1025m,Thread:1026m,ThreadStack:1027m,Code:1028m,GC:1029m,GCCardSet:1030m,Compiler:1031m,JVMCI:1032m,\" +\n+                        \"Internal:1033m,Other:1034m,Symbol:1035m,NMT:1036m,ClassShared:1037m,Chunk:1038m,Test:1039m,Tracing:1040m,Logging:1041m,\" +\n+                        \"Statistics:1042m,Arguments:1043m,Module:1044m,Safepoint:1045m,Synchronizer:1046m,Serviceability:1047m,Metaspace:1048m,StringDedup:1049m,ObjectMonitor:1050m\",\n+                \"[nmt] MallocLimit: category \\\"Java Heap\\\" limit: 1024M\",\n+                \"[nmt] MallocLimit: category \\\"Class\\\" limit: 1025M\",\n+                \"[nmt] MallocLimit: category \\\"Thread\\\" limit: 1026M\",\n+                \"[nmt] MallocLimit: category \\\"Thread Stack\\\" limit: 1027M\",\n+                \"[nmt] MallocLimit: category \\\"Code\\\" limit: 1028M\",\n+                \"[nmt] MallocLimit: category \\\"GC\\\" limit: 1029M\",\n+                \"[nmt] MallocLimit: category \\\"GCCardSet\\\" limit: 1030M\",\n+                \"[nmt] MallocLimit: category \\\"Compiler\\\" limit: 1031M\",\n+                \"[nmt] MallocLimit: category \\\"JVMCI\\\" limit: 1032M\",\n+                \"[nmt] MallocLimit: category \\\"Internal\\\" limit: 1033M\",\n+                \"[nmt] MallocLimit: category \\\"Other\\\" limit: 1034M\",\n+                \"[nmt] MallocLimit: category \\\"Symbol\\\" limit: 1035M\",\n+                \"[nmt] MallocLimit: category \\\"Native Memory Tracking\\\" limit: 1036M\",\n+                \"[nmt] MallocLimit: category \\\"Shared class space\\\" limit: 1037M\",\n+                \"[nmt] MallocLimit: category \\\"Arena Chunk\\\" limit: 1038M\",\n+                \"[nmt] MallocLimit: category \\\"Test\\\" limit: 1039M\",\n+                \"[nmt] MallocLimit: category \\\"Tracing\\\" limit: 1040M\",\n+                \"[nmt] MallocLimit: category \\\"Logging\\\" limit: 1041M\",\n+                \"[nmt] MallocLimit: category \\\"Statistics\\\" limit: 1042M\",\n+                \"[nmt] MallocLimit: category \\\"Arguments\\\" limit: 1043M\",\n+                \"[nmt] MallocLimit: category \\\"Module\\\" limit: 1044M\",\n+                \"[nmt] MallocLimit: category \\\"Safepoint\\\" limit: 1045M\",\n+                \"[nmt] MallocLimit: category \\\"Synchronization\\\" limit: 1046M\",\n+                \"[nmt] MallocLimit: category \\\"Serviceability\\\" limit: 1047M\",\n+                \"[nmt] MallocLimit: category \\\"Metaspace\\\" limit: 1048M\",\n+                \"[nmt] MallocLimit: category \\\"String Deduplication\\\" limit: 1049M\",\n+                \"[nmt] MallocLimit: category \\\"Object Monitors\\\" limit: 1050M\",\n+                \"[nmt] NMT initialized: summary\"\n+        );\n+    }\n+\n+    private static void testInvalidSetting(String setting, String expected_error) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + setting);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(expected_error);\n+    }\n+\n+    private static void testInvalidSettings() throws IOException {\n+        \/\/ Test a number of invalid settings the parser should catch. VM should abort in initialization.\n+        testInvalidSetting(\"gc\", \"MallocLimit: colon missing: gc\");\n+        testInvalidSetting(\"gc:abc\", \"Invalid MallocLimit size: abc\");\n+        testInvalidSetting(\"abcd:10m\", \"MallocLimit: invalid nmt category: abcd\");\n+        testInvalidSetting(\"nmt:100m,abcd:10m\", \"MallocLimit: invalid nmt category: abcd\");\n+        testInvalidSetting(\"0\", \"MallocLimit: limit must be > 0\");\n+        testInvalidSetting(\"GC:0\", \"MallocLimit: limit must be > 0\");\n+    }\n+\n+    private static void testLimitWithoutNmt() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:NativeMemoryTracking=off\", \/\/ overrides \"summary\" from processBuilderWithSetting()\n+                \"-XX:MallocLimit=3g\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0); \/\/ Not a fatal error, just a warning\n+        output.shouldContain(\"MallocLimit will be ignored since NMT is disabled\");\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args[0].equals(\"global-limit\")) {\n+            testGlobalLimit();\n+        } else if (args[0].equals(\"compiler-limit\")) {\n+            testCompilerLimit();\n+        } else if (args[0].equals(\"multi-limit\")) {\n+            testMultiLimit();\n+        } else if (args[0].equals(\"valid-settings\")) {\n+            testValidSettings();\n+        } else if (args[0].equals(\"invalid-settings\")) {\n+            testInvalidSettings();\n+        } else if (args[0].equals(\"limit-without-nmt\")) {\n+            testLimitWithoutNmt();\n+        } else {\n+            throw new RuntimeException(\"invalid test: \" + args[0]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocLimitTest.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"}]}