{"files":[{"patch":"@@ -112,2 +112,2 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n+  const Type *t1 = phase->type(in(1));\n+  const Type *t2 = phase->type(in(2));\n@@ -118,1 +118,1 @@\n-  if( commute(this,con_left,con_right) ) return this;\n+  if (commute(this, con_left, con_right)) return this;\n@@ -129,2 +129,2 @@\n-  if( con_right && t2 != Type::TOP && \/\/ Right input is a constant?\n-      add1_op == this_op ) { \/\/ Left input is an Add?\n+  if (con_right && t2 != Type::TOP && \/\/ Right input is a constant?\n+      add1_op == this_op) { \/\/ Left input is an Add?\n@@ -133,2 +133,2 @@\n-    const Type *t12 = phase->type( add1->in(2) );\n-    if( t12->singleton() && t12 != Type::TOP ) { \/\/ Left input is an add of a constant?\n+    const Type *t12 = phase->type(add1->in(2));\n+    if (t12->singleton() && t12 != Type::TOP) { \/\/ Left input is an add of a constant?\n@@ -140,2 +140,2 @@\n-      if( (add1 == add1->in(1))\n-         || (add11_op == this_op && add11->in(1) == add1) ) {\n+      if ((add1 == add1->in(1))\n+          || (add11_op == this_op && add11->in(1) == add1)) {\n@@ -147,1 +147,1 @@\n-      Node *x2 = phase->makecon( add1->as_Add()->add_ring( t2, t12 ));\n+      Node *x2 = phase->makecon(add1->as_Add()->add_ring(t2, t12));\n@@ -149,1 +149,1 @@\n-      if( igvn ) {\n+      if (igvn) {\n@@ -163,1 +163,1 @@\n-  if( add1_op == this_op && !con_right ) {\n+  if (add1_op == this_op && !con_right) {\n@@ -166,2 +166,2 @@\n-    if( t12->singleton() && t12 != Type::TOP && (add1 != add1->in(1)) &&\n-       !(add1->in(1)->is_Phi() && add1->in(1)->as_Phi()->is_tripcount()) ) {\n+    if (t12->singleton() && t12 != Type::TOP && (add1 != add1->in(1)) &&\n+        !(add1->in(1)->is_Phi() && (add1->in(1)->as_Phi()->is_tripcount(T_INT) || add1->in(1)->as_Phi()->is_tripcount(T_LONG)))) {\n@@ -181,1 +181,1 @@\n-  if( add2_op == this_op && !con_left ) {\n+  if (add2_op == this_op && !con_left) {\n@@ -184,2 +184,2 @@\n-    if( t22->singleton() && t22 != Type::TOP && (add2 != add2->in(1)) &&\n-       !(add2->in(1)->is_Phi() && add2->in(1)->as_Phi()->is_tripcount()) ) {\n+    if (t22->singleton() && t22 != Type::TOP && (add2 != add2->in(1)) &&\n+        !(add2->in(1)->is_Phi() && (add2->in(1)->as_Phi()->is_tripcount(T_INT) || add2->in(1)->as_Phi()->is_tripcount(T_LONG)))) {\n@@ -238,0 +238,11 @@\n+AddNode* AddNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new AddINode(in1, in2);\n+    case T_LONG:\n+      return new AddLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n@@ -910,0 +921,8 @@\n+  Node* hook = NULL;\n+  if (gvn.is_IterGVN()) {\n+    \/\/ Make sure a and b are not destroyed\n+    hook = new Node(2);\n+    hook->init_req(0, a);\n+    hook->init_req(1, b);\n+  }\n+  Node* res = NULL;\n@@ -913,1 +932,1 @@\n-        Node* res =  gvn.transform(new MaxINode(a, b));\n+        res =  gvn.transform(new MaxINode(a, b));\n@@ -915,1 +934,0 @@\n-        return res;\n@@ -919,1 +937,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -925,1 +943,0 @@\n-        return res;\n@@ -929,1 +946,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -937,1 +954,1 @@\n-        return gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n+        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n@@ -941,1 +958,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -947,1 +964,1 @@\n-        return gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n+        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n@@ -951,1 +968,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -955,0 +972,4 @@\n+  if (hook != NULL) {\n+    hook->destruct(&gvn);\n+  }\n+  return res;\n@@ -967,0 +988,8 @@\n+  Node* hook = NULL;\n+  if (gvn.is_IterGVN()) {\n+    \/\/ Make sure a and b are not destroyed\n+    hook = new Node(2);\n+    hook->init_req(0, a);\n+    hook->init_req(1, b);\n+  }\n+  Node* res = NULL;\n@@ -972,1 +1001,1 @@\n-      return gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n+      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n@@ -977,1 +1006,1 @@\n-      return gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n+      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n@@ -984,1 +1013,1 @@\n-      return gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n+      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n@@ -989,1 +1018,1 @@\n-      return gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n+      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n@@ -992,0 +1021,4 @@\n+  if (hook != NULL) {\n+    hook->destruct(&gvn);\n+  }\n+  return res;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":63,"deletions":30,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -71,0 +71,5 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+  static AddNode* make(Node* in1, Node* in2, BasicType bt);\n@@ -84,0 +89,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -98,0 +107,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n@@ -90,0 +94,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -102,0 +110,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1087,1 +1087,1 @@\n-  CountedLoopNode* l = r->is_CountedLoop() ? r->as_CountedLoop() : NULL;\n+  BaseCountedLoopNode* l = r->is_BaseCountedLoop() ? r->as_BaseCountedLoop() : NULL;\n@@ -1091,2 +1091,2 @@\n-      const Node *init   = l->init_trip();\n-      const Node *limit  = l->limit();\n+      const Node* init = l->init_trip();\n+      const Node* limit = l->limit();\n@@ -1095,3 +1095,3 @@\n-        const TypeInt* lo = phase->type(init)->isa_int();\n-        const TypeInt* hi = phase->type(limit)->isa_int();\n-        const TypeInt* stride_t = phase->type(stride)->isa_int();\n+        const TypeInteger* lo = phase->type(init)->isa_integer(l->bt());\n+        const TypeInteger* hi = phase->type(limit)->isa_integer(l->bt());\n+        const TypeInteger* stride_t = phase->type(stride)->isa_integer(l->bt());\n@@ -1099,1 +1099,1 @@\n-          assert(stride_t->_hi >= stride_t->_lo, \"bad stride type\");\n+          assert(stride_t->hi_as_long() >= stride_t->lo_as_long(), \"bad stride type\");\n@@ -1106,1 +1106,1 @@\n-            if (stride_t->_hi < 0) {          \/\/ Down-counter loop\n+            if (stride_t->hi_as_long() < 0) {          \/\/ Down-counter loop\n@@ -1108,3 +1108,5 @@\n-              return TypeInt::make(MIN2(lo->_lo, hi->_lo) , hi->_hi, 3)->filter_speculative(_type);\n-            } else if (stride_t->_lo >= 0) {\n-              return TypeInt::make(lo->_lo, MAX2(lo->_hi, hi->_hi), 3)->filter_speculative(_type);\n+              return TypeInteger::make(MIN2(lo->lo_as_long(), hi->lo_as_long()), hi->hi_as_long(), 3,\n+                                       l->bt())->filter_speculative(_type);\n+            } else if (stride_t->lo_as_long() >= 0) {\n+              return TypeInteger::make(lo->lo_as_long(), MAX2(lo->hi_as_long(), hi->hi_as_long()), 3,\n+                                       l->bt())->filter_speculative(_type);\n@@ -2449,3 +2451,4 @@\n-bool PhiNode::is_tripcount() const {\n-  return (in(0) != NULL && in(0)->is_CountedLoop() &&\n-          in(0)->as_CountedLoop()->phi() == this);\n+bool PhiNode::is_tripcount(BasicType bt) const {\n+  return (in(0) != NULL && in(0)->is_BaseCountedLoop() &&\n+          in(0)->as_BaseCountedLoop()->operates_on(bt, true) &&\n+          in(0)->as_BaseCountedLoop()->phi() == this);\n@@ -2478,1 +2481,1 @@\n-  if (is_tripcount()) {\n+  if (is_tripcount(T_INT) || is_tripcount(T_LONG)) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  bool is_tripcount() const;\n+  bool is_tripcount(BasicType bt) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,0 +146,2 @@\n+macro(LongCountedLoop)\n+macro(LongCountedLoopEnd)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3388,0 +3388,1 @@\n+  case Op_LongCountedLoop:\n@@ -3706,1 +3707,1 @@\n-    if (n->is_OuterStripMinedLoopEnd()) {\n+    if (n->is_OuterStripMinedLoopEnd() || n->is_LongCountedLoopEnd()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+  const TypeInt* ti = TypeInt::INT;\n@@ -464,2 +465,4 @@\n-  \/\/ Easy case.\n-  return TypeInt::make((jint)tl->get_con());\n+    \/\/ Easy case.\n+    ti = TypeInt::make((jint)tl->get_con());\n+  } else if (tl->_lo >= min_jint && tl->_hi <= max_jint) {\n+    ti = TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen);\n@@ -467,4 +470,1 @@\n-  if (tl->_lo >= min_jint && tl->_hi <= max_jint) {\n-    return TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen);\n-  }\n-  return bottom_type();\n+  return ti->filter(_type);\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-class ConvL2INode : public Node {\n+class ConvL2INode : public TypeNode {\n@@ -183,1 +183,4 @@\n-  ConvL2INode( Node *in1 ) : Node(0,in1) {}\n+  ConvL2INode(Node *in1, const TypeInt* t = TypeInt::INT)\n+  : TypeNode(t, 2) {\n+    init_req(1, in1);\n+  }\n@@ -185,1 +188,0 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1715,1 +1715,1 @@\n-  if (iff->is_CountedLoopEnd())  return NULL;\n+  if (iff->is_BaseCountedLoopEnd())  return NULL;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1280,1 +1280,1 @@\n-  if (head->is_valid_counted_loop()) {\n+  if (head->is_valid_counted_loop(T_INT)) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  if (!_head->as_Loop()->is_valid_counted_loop()) {\n+  if (!_head->as_Loop()->is_valid_counted_loop(T_INT)) {\n@@ -487,0 +487,1 @@\n+             test->Opcode() == Op_LongCountedLoopEnd ||\n@@ -771,1 +772,1 @@\n-  if (!cl->is_valid_counted_loop()) {\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n@@ -850,1 +851,1 @@\n-  if (!cl->is_valid_counted_loop()) {\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n@@ -3134,1 +3135,1 @@\n-  if (!cl->is_valid_counted_loop()) {\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n@@ -3247,1 +3248,1 @@\n-  if (!_head->as_Loop()->is_valid_counted_loop()) {\n+  if (!_head->as_Loop()->is_valid_counted_loop(T_INT)) {\n@@ -3263,1 +3264,0 @@\n-#ifdef ASSERT\n@@ -3265,2 +3265,2 @@\n-  assert(init_n->get_int() + cl->stride_con() >= cl->limit()->get_int(), \"should be one iteration\");\n-#endif\n+  assert((cl->stride_con() > 0 && init_n->get_int() + cl->stride_con() >= cl->limit()->get_int()) ||\n+         (cl->stride_con() < 0 && init_n->get_int() + cl->stride_con() <= cl->limit()->get_int()), \"should be one iteration\");\n@@ -3309,1 +3309,1 @@\n-  if (!cl->is_valid_counted_loop()) return true; \/\/ Ignore various kinds of broken loops\n+  if (!cl->is_valid_counted_loop(T_INT)) return true; \/\/ Ignore various kinds of broken loops\n@@ -3724,1 +3724,1 @@\n-  if (!head->is_valid_counted_loop() || !head->is_normal_loop()) {\n+  if (!head->is_valid_counted_loop(T_INT) || !head->is_normal_loop()) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-  if (!cl->is_valid_counted_loop()) {\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -72,4 +73,4 @@\n-bool LoopNode::is_valid_counted_loop() const {\n-  if (is_CountedLoop()) {\n-    CountedLoopNode*    l  = as_CountedLoop();\n-    CountedLoopEndNode* le = l->loopexit_or_null();\n+bool LoopNode::is_valid_counted_loop(BasicType bt) const {\n+  if (is_BaseCountedLoop() && operates_on(bt, false)) {\n+    BaseCountedLoopNode*    l  = as_BaseCountedLoop();\n+    BaseCountedLoopEndNode* le = l->loopexit_or_null();\n@@ -245,1 +246,1 @@\n-void PhaseIdealLoop::set_early_ctrl( Node *n ) {\n+void PhaseIdealLoop::set_early_ctrl(Node* n, bool update_body) {\n@@ -250,0 +251,4 @@\n+  IdealLoopTree *loop = get_loop(early);\n+  if (update_body && loop->_child == NULL) {\n+    loop->_body.push(n);\n+  }\n@@ -254,1 +259,1 @@\n-void PhaseIdealLoop::set_subtree_ctrl( Node *n ) {\n+void PhaseIdealLoop::set_subtree_ctrl(Node* n, bool update_body) {\n@@ -256,1 +261,1 @@\n-  if( _nodes[n->_idx] ) return;\n+  if (_nodes[n->_idx]) return;\n@@ -259,1 +264,1 @@\n-  for( i = 0; i < n->req(); ++i ) {\n+  for (i = 0; i < n->req(); ++i) {\n@@ -261,2 +266,3 @@\n-    if( m && m != C->root() )\n-      set_subtree_ctrl( m );\n+    if (m && m != C->root()) {\n+      set_subtree_ctrl(m, update_body);\n+    }\n@@ -266,1 +272,1 @@\n-  set_early_ctrl( n );\n+  set_early_ctrl(n, update_body);\n@@ -348,1 +354,1 @@\n-  set_subtree_ctrl(bol);\n+  set_subtree_ctrl(bol, false);\n@@ -487,21 +493,1 @@\n-\/\/ Return 0 if it won't overflow, -1 if it must overflow, and 1 otherwise.\n-static int check_stride_overflow(jint stride_con, const TypeInt* limit_t) {\n-  if (stride_con > 0) {\n-    if (limit_t->_lo > (max_jint - stride_con)) {\n-      return -1;\n-    }\n-    if (limit_t->_hi > (max_jint - stride_con)) {\n-      return 1;\n-    }\n-  } else {\n-    if (limit_t->_hi < (min_jint - stride_con)) {\n-      return -1;\n-    }\n-    if (limit_t->_lo < (min_jint - stride_con)) {\n-      return 1;\n-    }\n-  }\n-  return 0;\n-}\n-\n-static int check_stride_overflow(jlong stride_con, const TypeLong* limit_t) {\n+static int check_stride_overflow(jlong stride_con, const TypeInteger* limit_t, BasicType bt) {\n@@ -509,1 +495,1 @@\n-    if (limit_t->_lo > (max_jlong - stride_con)) {\n+    if (limit_t->lo_as_long() > (max_signed_integer(bt) - stride_con)) {\n@@ -512,1 +498,1 @@\n-    if (limit_t->_hi > (max_jlong - stride_con)) {\n+    if (limit_t->hi_as_long() > (max_signed_integer(bt) - stride_con)) {\n@@ -516,1 +502,1 @@\n-    if (limit_t->_hi < (min_jlong - stride_con)) {\n+    if (limit_t->hi_as_long() < (min_signed_integer(bt) - stride_con)) {\n@@ -519,1 +505,1 @@\n-    if (limit_t->_lo < (min_jlong - stride_con)) {\n+    if (limit_t->lo_as_long() < (min_signed_integer(bt) - stride_con)) {\n@@ -571,1 +557,1 @@\n-    set_subtree_ctrl(bol);\n+    set_subtree_ctrl(bol, false);\n@@ -612,1 +598,1 @@\n-      set_subtree_ctrl(unc->in(i));\n+      set_subtree_ctrl(unc->in(i), false);\n@@ -630,0 +616,48 @@\n+static bool no_side_effect_since_safepoint(Compile* C, Node* x, Node* mem, MergeMemNode* mm) {\n+  SafePointNode* safepoint = NULL;\n+  for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n+    Node* u = x->fast_out(i);\n+    if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n+      Node* m = u->in(LoopNode::LoopBackControl);\n+      if (u->adr_type() == TypePtr::BOTTOM) {\n+        if (m->is_MergeMem() && mem->is_MergeMem()) {\n+          if (m != mem DEBUG_ONLY(|| true)) {\n+            for (MergeMemStream mms(m->as_MergeMem(), mem->as_MergeMem()); mms.next_non_empty2(); ) {\n+              if (!mms.is_empty()) {\n+                if (mms.memory() != mms.memory2()) {\n+                  return false;\n+                }\n+#ifdef ASSERT\n+                if (mms.alias_idx() != Compile::AliasIdxBot) {\n+                  mm->set_memory_at(mms.alias_idx(), mem->as_MergeMem()->base_memory());\n+                }\n+#endif\n+              }\n+            }\n+          }\n+        } else if (mem->is_MergeMem()) {\n+          if (m != mem->as_MergeMem()->base_memory()) {\n+            return false;\n+          }\n+        } else {\n+          return false;\n+        }\n+      } else {\n+        if (mem->is_MergeMem()) {\n+          if (m != mem->as_MergeMem()->memory_at(C->get_alias_index(u->adr_type()))) {\n+            return false;\n+          }\n+#ifdef ASSERT\n+          mm->set_memory_at(C->get_alias_index(u->adr_type()), mem->as_MergeMem()->base_memory());\n+#endif\n+        } else {\n+          if (m != mem) {\n+            return false;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -654,1 +688,0 @@\n-#ifdef ASSERT\n@@ -657,0 +690,1 @@\n+#ifdef ASSERT\n@@ -667,42 +701,4 @@\n-    for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n-      Node* u = x->fast_out(i);\n-      if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n-        Node* m = u->in(LoopNode::LoopBackControl);\n-        if (u->adr_type() == TypePtr::BOTTOM) {\n-          if (m->is_MergeMem() && mem->is_MergeMem()) {\n-            if (m != mem DEBUG_ONLY(|| true)) {\n-              for (MergeMemStream mms(m->as_MergeMem(), mem->as_MergeMem()); mms.next_non_empty2(); ) {\n-                if (!mms.is_empty()) {\n-                  if (mms.memory() != mms.memory2()) {\n-                    return NULL;\n-                  }\n-#ifdef ASSERT\n-                  if (mms.alias_idx() != Compile::AliasIdxBot) {\n-                    mm->set_memory_at(mms.alias_idx(), mem->as_MergeMem()->base_memory());\n-                  }\n-#endif\n-                }\n-              }\n-            }\n-          } else if (mem->is_MergeMem()) {\n-            if (m != mem->as_MergeMem()->base_memory()) {\n-              return NULL;\n-            }\n-          } else {\n-            return NULL;\n-          }\n-        } else {\n-          if (mem->is_MergeMem()) {\n-            if (m != mem->as_MergeMem()->memory_at(C->get_alias_index(u->adr_type()))) {\n-              return NULL;\n-            }\n-#ifdef ASSERT\n-            mm->set_memory_at(C->get_alias_index(u->adr_type()), mem->as_MergeMem()->base_memory());\n-#endif\n-          } else {\n-            if (m != mem) {\n-              return NULL;\n-            }\n-          }\n-        }\n-      }\n+    if (!no_side_effect_since_safepoint(C, x, mem, mm)) {\n+      safepoint = NULL;\n+    } else {\n+      assert(mm == NULL|| _igvn.transform(mm) == mem->as_MergeMem()->base_memory(), \"all memory state should have been processed\");\n@@ -712,1 +708,0 @@\n-      assert (_igvn.transform(mm) == mem->as_MergeMem()->base_memory(), \"all memory state should have been processed\");\n@@ -730,1 +725,0 @@\n-\/\/   \/\/ phi_incr := phi (test happens before increment)\n@@ -740,1 +734,0 @@\n-\/\/   \/\/ phi_incr := NULL (test happens after increment)\n@@ -770,1 +763,2 @@\n-bool PhaseIdealLoop::is_long_counted_loop(Node* x, IdealLoopTree* loop, Node_List &old_new) {\n+bool PhaseIdealLoop::transform_long_counted_loop(IdealLoopTree* loop, Node_List &old_new) {\n+  Node* x = loop->_head;\n@@ -772,23 +766,1 @@\n-  if (loop->_child != NULL) {\n-    return false;\n-  }\n-\n-  \/\/ Checks whether the loop has the shape of a counted loop\n-  Node* back_control = loop_exit_control(x, loop);\n-  if (back_control == NULL) {\n-    return false;\n-  }\n-\n-  BoolTest::mask bt = BoolTest::illegal;\n-  float cl_prob = 0;\n-  Node* incr = NULL;\n-  Node* limit = NULL;\n-\n-  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n-  if (cmp == NULL || cmp->Opcode() != Op_CmpL) {\n-    return false; \/\/ Avoid pointer & float & 32-bit compares\n-  }\n-\n-  Node* phi_incr = NULL;\n-  incr = loop_iv_incr(incr, x, loop, phi_incr);\n-  if (incr == NULL || incr->Opcode() != Op_AddL) {\n+  if (loop->_child != NULL || !x->is_LongCountedLoop()) {\n@@ -798,2 +770,1 @@\n-  Node* xphi = NULL;\n-  Node* stride = loop_iv_stride(incr, loop, xphi);\n+  check_long_counted_loop(loop, x);\n@@ -801,3 +772,1 @@\n-  if (stride == NULL) {\n-    return false;\n-  }\n+  LongCountedLoopNode* head = x->as_LongCountedLoop();\n@@ -809,1 +778,1 @@\n-  jlong stride_con = stride->get_long();\n+  jlong stride_con = head->stride_con();\n@@ -829,5 +798,2 @@\n-  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n-\n-  if (phi == NULL || phi->in(LoopNode::LoopBackControl) != incr) {\n-    return false;\n-  }\n+  PhiNode* phi = head->phi()->as_Phi();\n+  Node* incr = head->incr();\n@@ -840,0 +806,2 @@\n+  Node* back_control = head->in(LoopNode::LoopBackControl);\n+\n@@ -845,4 +813,1 @@\n-  if (!condition_stride_ok(bt, stride_con)) {\n-    return false;\n-  }\n-\n+  Node* limit = head->limit();\n@@ -854,1 +819,6 @@\n-  IfNode* exit_test = back_control->in(0)->as_If();\n+  const TypeLong* phi_t = _igvn.type(phi)->is_long();\n+  assert(phi_t->_hi >= phi_t->_lo, \"dead phi?\");\n+  iters_limit = (int)MIN2((julong)iters_limit, (julong)(phi_t->_hi - phi_t->_lo));\n+\n+  LongCountedLoopEndNode* exit_test = head->loopexit();\n+  BoolTest::mask bt = exit_test->test_trip();\n@@ -858,12 +828,0 @@\n-  if (safepoint == NULL) {\n-    \/\/ If exit condition is ne, then a loop limit check is likely needed\n-    if (bt == BoolTest::ne) {\n-      return false;\n-    }\n-  } else if (C->too_many_traps(safepoint->jvms()->method(),\n-                        safepoint->jvms()->bci(),\n-                        Deoptimization::Reason_loop_limit_check)) {\n-    \/\/ We must have transformed the loop already and a loop limit\n-    \/\/ check must have failed.\n-    return false;\n-  }\n@@ -871,1 +829,2 @@\n-  Node* exit_branch = exit_test->proj_out(back_control->Opcode() == Op_IfFalse);\n+  assert(back_control->Opcode() == Op_IfTrue, \"wrong projection for back edge\");\n+  Node* exit_branch = exit_test->proj_out(false);\n@@ -873,20 +832,1 @@\n-\n-  \/\/ if the loop exit test is on the IV before it is incremented: i <\n-  \/\/ limit, we transform the exit test so it is performed on the exit\n-  \/\/ test after it is incremented: i + stride < limit + stride.  We\n-  \/\/ need limit + stride to not overflow. See adjusted_limit below.\n-  bool limit_check_required = false;\n-  if (phi_incr != NULL) {\n-    const TypeLong* limit_t = _igvn.type(limit)->is_long();\n-    int sov = check_stride_overflow(stride_con, limit_t);\n-    if (sov != 0) {\n-      if (sov < 0) {\n-        return false;  \/\/ Bailout: integer overflow is certain.\n-      }\n-      \/\/ Check that inserting a predicate is indeed possible\n-      if (find_predicate_insertion_point(x->in(LoopNode::EntryControl), Deoptimization::Reason_loop_limit_check) == NULL) {\n-        return false;\n-      }\n-      limit_check_required = true;\n-    }\n-  }\n+  Node* cmp = exit_test->cmp_node();\n@@ -896,1 +836,1 @@\n-  Node* outer_exit_test = exit_test->clone();\n+  Node* outer_exit_test = new IfNode(exit_test->in(0), exit_test->in(1), exit_test->_prob, exit_test->_fcnt);\n@@ -927,9 +867,0 @@\n-  Node* adjusted_limit = limit;\n-  if (phi_incr != NULL) {\n-    \/\/ If compare points directly to the phi we need to adjust the\n-    \/\/ compare so that it points to the incr.\n-    Node* long_stride = _igvn.longcon(stride_con);\n-    set_ctrl(long_stride, C->root());\n-    adjusted_limit = new AddLNode(limit, long_stride);\n-    _igvn.register_new_node_with_optimizer(adjusted_limit);\n-  }\n@@ -938,1 +869,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(adjusted_limit, outer_phi, TypeLong::LONG, _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(limit, outer_phi, TypeLong::LONG, _igvn);\n@@ -940,1 +871,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, adjusted_limit, TypeLong::LONG, _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, limit, TypeLong::LONG, _igvn);\n@@ -965,6 +896,1 @@\n-  if (cmp->in(1) == incr || cmp->in(1) == phi) {\n-    inner_cmp = new CmpINode(inner_incr, inner_iters_actual_int);\n-  }  else {\n-    assert(cmp->in(2) == incr || cmp->in(2) == phi, \"bad iv shape\");\n-    inner_cmp = new CmpINode(inner_iters_actual_int, inner_incr);\n-  }\n+  inner_cmp = new CmpINode(inner_incr, inner_iters_actual_int);\n@@ -981,34 +907,0 @@\n-  \/\/ Add a predicate to guarantee limit adjustment doesn't overflow\n-  if (limit_check_required) {\n-    assert(phi_incr != NULL, \"only when exit test must be transformed\");\n-    ProjNode *limit_check_proj = find_predicate_insertion_point(outer_head->in(LoopNode::EntryControl), Deoptimization::Reason_loop_limit_check);\n-    assert(limit_check_proj != NULL, \"was tested before\");\n-    IfNode* check_iff = limit_check_proj->in(0)->as_If();\n-    Node* cmp_limit;\n-    Node* bol;\n-\n-    if (stride_con > 0) {\n-      cmp_limit = new CmpLNode(limit, _igvn.longcon(max_jlong - stride_con));\n-      bol = new BoolNode(cmp_limit, BoolTest::le);\n-    } else {\n-      cmp_limit = new CmpLNode(limit, _igvn.longcon(min_jlong - stride_con));\n-      bol = new BoolNode(cmp_limit, BoolTest::ge);\n-    }\n-\n-    insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n-    Node* new_predicate = limit_check_proj->in(0)->in(0);\n-    Node* above_predicate = new_predicate->in(0)->in(0);\n-    Node* entry = outer_head->in(LoopNode::EntryControl);\n-    _igvn.replace_input_of(limit_check_proj->in(0), 0, above_predicate);\n-    _igvn.replace_input_of(new_predicate->in(0), 0, entry);\n-    _igvn.replace_input_of(outer_head, LoopNode::EntryControl, new_predicate);\n-    set_idom(new_predicate->in(0), entry, dom_depth(entry));\n-    set_idom(new_predicate, new_predicate->in(0), dom_depth(entry));\n-    Node* region = new_predicate->in(0)->as_If()->proj_out(new_predicate->Opcode() == Op_IfFalse)->unique_ctrl_out();\n-    assert(region->is_Region(), \"should be region merging predicates\");\n-    set_idom(region, entry, dom_depth(entry));\n-    set_idom(limit_check_proj->in(0), above_predicate, dom_depth(above_predicate));\n-  }\n-\n-  LoopNode* inner_head = x->as_Loop();\n-\n@@ -1016,2 +908,2 @@\n-  for (uint i = 0; i < inner_head->outcnt(); i++) {\n-    Node* u = inner_head->raw_out(i);\n+  for (uint i = 0; i < head->outcnt(); i++) {\n+    Node* u = head->raw_out(i);\n@@ -1019,1 +911,1 @@\n-      assert(u->in(0) == inner_head, \"inconsistent\");\n+      assert(u->in(0) == head, \"inconsistent\");\n@@ -1029,1 +921,1 @@\n-  long_loop_replace_long_iv(phi, inner_phi, outer_phi, inner_head);\n+  long_loop_replace_long_iv(phi, inner_phi, outer_phi, head);\n@@ -1033,1 +925,3 @@\n-  long_loop_replace_long_iv(incr, inner_incr, outer_phi, inner_head);\n+  long_loop_replace_long_iv(incr, inner_incr, outer_phi, head);\n+\n+  set_subtree_ctrl(inner_iters_actual_int, body_populated);\n@@ -1035,1 +929,1 @@\n-  set_subtree_ctrl(inner_iters_actual_int);\n+  LoopNode* inner_head = create_inner_head(loop, head, exit_test);\n@@ -1051,1 +945,0 @@\n-  \/\/   \/\/ test happens before increment => phi == phi_incr != NULL\n@@ -1099,0 +992,2 @@\n+  } else {\n+    C->set_major_progress();\n@@ -1122,0 +1017,56 @@\n+LoopNode* PhaseIdealLoop::create_inner_head(IdealLoopTree* loop, LongCountedLoopNode* head,\n+                                            LongCountedLoopEndNode* exit_test) {\n+  LoopNode* new_inner_head = new LoopNode(head->in(1), head->in(2));\n+  IfNode* new_inner_exit = new IfNode(exit_test->in(0), exit_test->in(1), exit_test->_prob, exit_test->_fcnt);\n+  _igvn.register_new_node_with_optimizer(new_inner_head);\n+  _igvn.register_new_node_with_optimizer(new_inner_exit);\n+  loop->_body.push(new_inner_head);\n+  loop->_body.push(new_inner_exit);\n+  loop->_body.yank(head);\n+  loop->_body.yank(exit_test);\n+  set_loop(new_inner_head, loop);\n+  set_loop(new_inner_exit, loop);\n+  set_idom(new_inner_head, idom(head), dom_depth(head));\n+  set_idom(new_inner_exit, idom(exit_test), dom_depth(exit_test));\n+  lazy_replace(head, new_inner_head);\n+  lazy_replace(exit_test, new_inner_exit);\n+  loop->_head = new_inner_head;\n+  return new_inner_head;\n+}\n+\n+#ifdef ASSERT\n+void PhaseIdealLoop::check_long_counted_loop(IdealLoopTree* loop, Node* x) {\n+  Node* back_control = loop_exit_control(x, loop);\n+  assert(back_control != NULL, \"no back control\");\n+\n+  BoolTest::mask bt = BoolTest::illegal;\n+  float cl_prob = 0;\n+  Node* incr = NULL;\n+  Node* limit = NULL;\n+\n+  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n+  assert(cmp != NULL && cmp->Opcode() == Op_CmpL, \"no exit test\");\n+\n+  Node* phi_incr = NULL;\n+  incr = loop_iv_incr(incr, x, loop, phi_incr);\n+  assert(incr != NULL && incr->Opcode() == Op_AddL, \"no incr\");\n+\n+  Node* xphi = NULL;\n+  Node* stride = loop_iv_stride(incr, loop, xphi);\n+\n+  assert(stride != NULL, \"no stride\");\n+\n+  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n+\n+  assert(phi != NULL && phi->in(LoopNode::LoopBackControl) == incr, \"No phi\");\n+\n+  jlong stride_con = stride->get_long();\n+\n+  assert(condition_stride_ok(bt, stride_con), \"illegal condition\");\n+\n+  assert(bt != BoolTest::ne, \"unexpected condition\");\n+  assert(phi_incr == NULL, \"bad loop shape\");\n+  assert(cmp->in(1) == incr, \"bad exit test shape\");\n+}\n+#endif\n+\n@@ -1193,1 +1144,1 @@\n-        set_subtree_ctrl(in_clone);\n+        set_subtree_ctrl(in_clone, false);\n@@ -1210,1 +1161,1 @@\n-    set_subtree_ctrl(clone);\n+    set_subtree_ctrl(clone, false);\n@@ -1220,1 +1171,1 @@\n-        set_subtree_ctrl(m);\n+        set_subtree_ctrl(m, false);\n@@ -1232,1 +1183,1 @@\n-bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*& loop) {\n+bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt) {\n@@ -1245,1 +1196,1 @@\n-  if (cmp == NULL || cmp->Opcode() != Op_CmpI) {\n+  if (cmp == NULL || !(cmp->is_Cmp() && cmp->operates_on(iv_bt, true))) {\n@@ -1250,1 +1201,1 @@\n-  if (incr->Opcode() == Op_CastII) {\n+  if (incr->is_ConstraintCast() && incr->operates_on(iv_bt, false)) {\n@@ -1262,1 +1213,1 @@\n-  const TypeInt* iv_trunc_t = NULL;\n+  const TypeInteger* iv_trunc_t = NULL;\n@@ -1264,1 +1215,1 @@\n-  if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &trunc1, &trunc2, &iv_trunc_t))) {\n+  if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &trunc1, &trunc2, &iv_trunc_t, iv_bt))) {\n@@ -1267,1 +1218,1 @@\n-  assert(incr->Opcode() == Op_AddI, \"wrong increment code\");\n+  assert(incr->is_Add() && incr->operates_on(iv_bt, false), \"wrong increment code\");\n@@ -1276,1 +1227,1 @@\n-  if (xphi->Opcode() == Op_CastII) {\n+  if (xphi->is_ConstraintCast() && xphi->operates_on(iv_bt, false)) {\n@@ -1281,1 +1232,1 @@\n-  int stride_con = stride->get_int();\n+  jlong stride_con = stride->get_integer_as_long(iv_bt);\n@@ -1292,1 +1243,2 @@\n-  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint &&\n+  if (iv_bt == T_INT &&\n+      x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint &&\n@@ -1306,1 +1258,1 @@\n-  const TypeInt* limit_t = gvn->type(limit)->is_int();\n+  const TypeInteger* limit_t = gvn->type(limit)->is_integer(iv_bt);\n@@ -1325,2 +1277,2 @@\n-    const TypeInt* incr_t = gvn->type(orig_incr)->is_int();\n-    if (limit_t->_hi > incr_t->_hi) {\n+    const TypeInteger* incr_t = gvn->type(orig_incr)->is_integer(iv_bt);\n+    if (limit_t->hi_as_long() > incr_t->hi_as_long()) {\n@@ -1335,1 +1287,1 @@\n-  if (!TypeInt::INT->higher_equal(iv_trunc_t)) {\n+  if (!TypeInteger::bottom(iv_bt)->higher_equal(iv_trunc_t)) {\n@@ -1339,1 +1291,1 @@\n-    const TypeInt* phi_ft = filtered_type(phi);\n+    const TypeInteger* phi_ft = filtered_type(phi);\n@@ -1353,2 +1305,2 @@\n-      if (iv_trunc_t->_hi - phi_ft->_hi < stride_con ||\n-          iv_trunc_t->_lo > phi_ft->_lo) {\n+      if (iv_trunc_t->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n+          iv_trunc_t->lo_as_long() > phi_ft->lo_as_long()) {\n@@ -1358,2 +1310,2 @@\n-      if (iv_trunc_t->_lo - phi_ft->_lo > stride_con ||\n-          iv_trunc_t->_hi < phi_ft->_hi) {\n+      if (iv_trunc_t->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n+          iv_trunc_t->hi_as_long() < phi_ft->hi_as_long()) {\n@@ -1373,1 +1325,1 @@\n-  const TypeInt* init_t = gvn->type(init_trip)->is_int();\n+  const TypeInteger* init_t = gvn->type(init_trip)->is_integer(iv_bt);\n@@ -1376,3 +1328,3 @@\n-    jlong init_p = (jlong)init_t->_lo + stride_con;\n-    if (init_p > (jlong)max_jint || init_p > (jlong)limit_t->_hi)\n-      return false; \/\/ cyclic loop or this loop trips only once\n+    if (init_t->lo_as_long() > max_signed_integer(iv_bt) - stride_con) {\n+      return false; \/\/ cyclic loop\n+    }\n@@ -1380,3 +1332,3 @@\n-    jlong init_p = (jlong)init_t->_hi + stride_con;\n-    if (init_p < (jlong)min_jint || init_p < (jlong)limit_t->_lo)\n-      return false; \/\/ cyclic loop or this loop trips only once\n+    if (init_t->hi_as_long() < min_signed_integer(iv_bt) - stride_con) {\n+      return false; \/\/ cyclic loop\n+    }\n@@ -1388,1 +1340,1 @@\n-      if (init_t->_hi > max_jint - stride_con) {\n+      if (init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) {\n@@ -1392,1 +1344,1 @@\n-      if (init_t->_lo < min_jint - stride_con) {\n+      if (init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con) {\n@@ -1401,1 +1353,1 @@\n-  assert(x->Opcode() == Op_Loop, \"regular loops only\");\n+  assert(x->Opcode() == Op_Loop || x->Opcode() == Op_LongCountedLoop, \"regular loops only\");\n@@ -1421,1 +1373,1 @@\n-  int stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n+  jlong stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n@@ -1434,1 +1386,1 @@\n-  int sov = check_stride_overflow(stride_m, limit_t);\n+  int sov = check_stride_overflow(stride_m, limit_t, iv_bt);\n@@ -1467,1 +1419,1 @@\n-      cmp_limit = new CmpINode(limit, _igvn.intcon(max_jint - stride_m));\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_jint - stride_m, iv_bt), iv_bt);\n@@ -1470,1 +1422,1 @@\n-      cmp_limit = new CmpINode(limit, _igvn.intcon(min_jint - stride_m));\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_jint - stride_m, iv_bt), iv_bt);\n@@ -1480,1 +1432,1 @@\n-    if (stride_con > 0 && init_t->_hi < limit_t->_lo) {\n+    if (stride_con > 0 && init_t->hi_as_long() < limit_t->lo_as_long()) {\n@@ -1483,1 +1435,1 @@\n-    } else if (stride_con < 0 && init_t->_lo > limit_t->_hi) {\n+    } else if (stride_con < 0 && init_t->lo_as_long() > limit_t->hi_as_long()) {\n@@ -1510,1 +1462,1 @@\n-        cmp_limit = new CmpINode(init_trip, limit);\n+        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n@@ -1513,1 +1465,1 @@\n-        cmp_limit = new CmpINode(init_trip, limit);\n+        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n@@ -1530,1 +1482,5 @@\n-  if (!x->as_Loop()->is_transformed_long_loop() && StressLongCountedLoop > 0 && trunc1 == NULL && convert_to_long_loop(cmp, phi, loop)) {\n+  if (iv_bt == T_INT &&\n+      !x->as_Loop()->is_transformed_long_loop() &&\n+      StressLongCountedLoop > 0 &&\n+      trunc1 == NULL &&\n+      convert_to_long_loop(cmp, phi, loop)) {\n@@ -1545,1 +1501,1 @@\n-    adjusted_limit = gvn->transform(new AddINode(limit, stride));\n+    adjusted_limit = gvn->transform(AddNode::make(limit, stride, iv_bt));\n@@ -1552,2 +1508,2 @@\n-    Node* one = (stride_con > 0) ? gvn->intcon( 1) : gvn->intcon(-1);\n-    adjusted_limit = gvn->transform(new AddINode(adjusted_limit, one));\n+    Node* one = (stride_con > 0) ? gvn->integercon( 1, iv_bt) : gvn->integercon(-1, iv_bt);\n+    adjusted_limit = gvn->transform(AddNode::make(adjusted_limit, one, iv_bt));\n@@ -1561,1 +1517,1 @@\n-  set_subtree_ctrl(adjusted_limit);\n+  set_subtree_ctrl(adjusted_limit, false);\n@@ -1563,1 +1519,1 @@\n-  if (LoopStripMiningIter == 0) {\n+  if (iv_bt == T_INT && LoopStripMiningIter == 0) {\n@@ -1581,1 +1537,1 @@\n-  set_early_ctrl( incr );\n+  set_early_ctrl(incr, false);\n@@ -1588,2 +1544,2 @@\n-  if (!TypeInt::INT->higher_equal(phi->bottom_type())) {\n-    Node* nphi = PhiNode::make(phi->in(0), phi->in(LoopNode::EntryControl), TypeInt::INT);\n+  if (!TypeInteger::bottom(iv_bt)->higher_equal(phi->bottom_type())) {\n+    Node* nphi = PhiNode::make(phi->in(0), phi->in(LoopNode::EntryControl), TypeInteger::bottom(iv_bt));\n@@ -1609,1 +1565,1 @@\n-  Node *lex = _igvn.register_new_node_with_optimizer(new CountedLoopEndNode( iff->in(0), test, cl_prob, iff->as_If()->_fcnt ));\n+  Node *lex = _igvn.register_new_node_with_optimizer(BaseCountedLoopEndNode::make(iff->in(0), test, cl_prob, iff->as_If()->_fcnt, iv_bt));\n@@ -1649,2 +1605,5 @@\n-  bool strip_mine_loop = LoopStripMiningIter > 1 && loop->_child == NULL &&\n-    sfpt2->Opcode() == Op_SafePoint && !loop->_has_call;\n+  bool strip_mine_loop = iv_bt == T_INT &&\n+                         LoopStripMiningIter > 1 &&\n+                         loop->_child == NULL &&\n+                         sfpt2->Opcode() == Op_SafePoint &&\n+                         !loop->_has_call;\n@@ -1659,1 +1618,1 @@\n-  CountedLoopNode *l = new CountedLoopNode(entry_control, back_control);\n+  BaseCountedLoopNode *l = BaseCountedLoopNode::make(entry_control, back_control, iv_bt);\n@@ -1670,0 +1629,3 @@\n+  \/\/ Prevent a safepoint on the backedge from becoming dead\n+  Node* hook = new Node(1);\n+  hook->init_req(0, x->in(LoopNode::LoopBackControl));\n@@ -1671,0 +1633,1 @@\n+  hook->destruct(&_igvn);\n@@ -1673,1 +1636,1 @@\n-  if (LoopStripMiningIter == 0 || strip_mine_loop) {\n+  if (iv_bt == T_INT && (LoopStripMiningIter == 0 || strip_mine_loop)) {\n@@ -1694,1 +1657,1 @@\n-  assert(l->is_valid_counted_loop(), \"counted loop shape is messed up\");\n+  assert(l->is_valid_counted_loop(iv_bt), \"counted loop shape is messed up\");\n@@ -1731,1 +1694,1 @@\n-  assert(cl->is_valid_counted_loop(), \"\");\n+  assert(cl->is_valid_counted_loop(T_INT), \"\");\n@@ -1781,1 +1744,1 @@\n-    if (!is_valid_counted_loop()) {\n+    if (!is_valid_counted_loop(T_INT)) {\n@@ -1790,1 +1753,1 @@\n-    assert(inner->is_valid_counted_loop() && inner->is_strip_mined(), \"OuterStripMinedLoop should have been removed\");\n+    assert(inner->is_valid_counted_loop(T_INT) && inner->is_strip_mined(), \"OuterStripMinedLoop should have been removed\");\n@@ -1887,2 +1850,11 @@\n-int CountedLoopEndNode::stride_con() const {\n-  return stride()->bottom_type()->is_int()->get_con();\n+jlong BaseCountedLoopEndNode::stride_con() const {\n+  return stride()->bottom_type()->is_integer(bt())->get_con_as_long(bt());\n+}\n+\n+\n+BaseCountedLoopEndNode* BaseCountedLoopEndNode::make(Node* control, Node* test, float prob, float cnt, BasicType bt) {\n+  if (bt == T_INT) {\n+    return new CountedLoopEndNode(control, test, prob, cnt);\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return new LongCountedLoopEndNode(control, test, prob, cnt);\n@@ -2019,2 +1991,3 @@\n-Node* CountedLoopNode::match_incr_with_optional_truncation(\n-                      Node* expr, Node** trunc1, Node** trunc2, const TypeInt** trunc_type) {\n+Node* CountedLoopNode::match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2,\n+                                                           const TypeInteger** trunc_type,\n+                                                           BasicType bt) {\n@@ -2026,1 +1999,0 @@\n-  const TypeInt* trunc_t = TypeInt::INT;\n@@ -2029,18 +2001,8 @@\n-\n-  \/\/ Try to strip (n1 & M) or (n1 << N >> N) from n1.\n-  if (n1op == Op_AndI &&\n-      n1->in(2)->is_Con() &&\n-      n1->in(2)->bottom_type()->is_int()->get_con() == 0x7fff) {\n-    \/\/ %%% This check should match any mask of 2**K-1.\n-    t1 = n1;\n-    n1 = t1->in(1);\n-    n1op = n1->Opcode();\n-    trunc_t = TypeInt::CHAR;\n-  } else if (n1op == Op_RShiftI &&\n-             n1->in(1) != NULL &&\n-             n1->in(1)->Opcode() == Op_LShiftI &&\n-             n1->in(2) == n1->in(1)->in(2) &&\n-             n1->in(2)->is_Con()) {\n-    jint shift = n1->in(2)->bottom_type()->is_int()->get_con();\n-    \/\/ %%% This check should match any shift in [1..31].\n-    if (shift == 16 || shift == 8) {\n+  const TypeInteger* trunc_t = TypeInteger::bottom(bt);\n+\n+  if (bt == T_INT) {\n+    \/\/ Try to strip (n1 & M) or (n1 << N >> N) from n1.\n+    if (n1op == Op_AndI &&\n+        n1->in(2)->is_Con() &&\n+        n1->in(2)->bottom_type()->is_int()->get_con() == 0x7fff) {\n+      \/\/ %%% This check should match any mask of 2**K-1.\n@@ -2048,2 +2010,1 @@\n-      t2 = t1->in(1);\n-      n1 = t2->in(1);\n+      n1 = t1->in(1);\n@@ -2051,4 +2012,18 @@\n-      if (shift == 16) {\n-        trunc_t = TypeInt::SHORT;\n-      } else if (shift == 8) {\n-        trunc_t = TypeInt::BYTE;\n+      trunc_t = TypeInt::CHAR;\n+    } else if (n1op == Op_RShiftI &&\n+               n1->in(1) != NULL &&\n+               n1->in(1)->Opcode() == Op_LShiftI &&\n+               n1->in(2) == n1->in(1)->in(2) &&\n+               n1->in(2)->is_Con()) {\n+      jint shift = n1->in(2)->bottom_type()->is_int()->get_con();\n+      \/\/ %%% This check should match any shift in [1..31].\n+      if (shift == 16 || shift == 8) {\n+        t1 = n1;\n+        t2 = t1->in(1);\n+        n1 = t2->in(1);\n+        n1op = n1->Opcode();\n+        if (shift == 16) {\n+          trunc_t = TypeInt::SHORT;\n+        } else if (shift == 8) {\n+          trunc_t = TypeInt::BYTE;\n+        }\n@@ -2060,1 +2035,1 @@\n-  if (n1op == Op_AddI) {\n+  if (n1->is_Add() && n1->operates_on(bt, true)) {\n@@ -2072,1 +2047,1 @@\n-  if (is_strip_mined() && is_valid_counted_loop()) {\n+  if (is_strip_mined() && is_valid_counted_loop(T_INT)) {\n@@ -2184,0 +2159,20 @@\n+\n+int CountedLoopNode::stride_con() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->stride_con() : 0;\n+}\n+\n+jlong LongCountedLoopNode::stride_con() const {\n+  LongCountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->stride_con() : 0;\n+}\n+\n+BaseCountedLoopNode* BaseCountedLoopNode::make(Node* entry, Node* backedge, BasicType bt) {\n+  if (bt == T_INT) {\n+    return new CountedLoopNode(entry, backedge);\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return new LongCountedLoopNode(entry, backedge);\n+}\n+\n+\n@@ -2413,1 +2408,1 @@\n-    \/\/ If limit < init for stride > 0 (or limit > init for stride 0),\n+    \/\/ If limit < init for stride > 0 (or limit > init for stride < 0),\n@@ -3162,1 +3157,1 @@\n-  if (!cl->is_valid_counted_loop())\n+  if (!cl->is_valid_counted_loop(T_INT))\n@@ -3226,1 +3221,1 @@\n-      set_early_ctrl(ratio_init);\n+      set_early_ctrl(ratio_init, false);\n@@ -3229,1 +3224,1 @@\n-      set_early_ctrl(diff);\n+      set_early_ctrl(diff, false);\n@@ -3289,1 +3284,1 @@\n-      phase->is_counted_loop(_head, loop)) {\n+      phase->is_counted_loop(_head, loop, T_INT)) {\n@@ -3302,1 +3297,3 @@\n-\n+  } else if (_head->is_LongCountedLoop() ||\n+             phase->is_counted_loop(_head, loop, T_LONG)) {\n+    remove_safepoints(phase, true);\n@@ -3306,4 +3303,4 @@\n-    \/\/ Not a counted loop. Keep one safepoint.\n-    bool keep_one_sfpt = true;\n-    remove_safepoints(phase, keep_one_sfpt);\n-  }\n+      \/\/ Not a counted loop. Keep one safepoint.\n+      bool keep_one_sfpt = true;\n+      remove_safepoints(phase, keep_one_sfpt);\n+    }\n@@ -3942,5 +3939,0 @@\n-  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n-    IdealLoopTree* lpt = iter.current();\n-    is_long_counted_loop(lpt->_head, lpt, worklist);\n-  }\n-\n@@ -4013,0 +4005,7 @@\n+  if (C->has_loops() && !C->major_progress()) {\n+    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+      IdealLoopTree *lpt = iter.current();\n+      transform_long_counted_loop(lpt, worklist);\n+    }\n+  }\n+\n@@ -4773,1 +4772,1 @@\n-          set_early_ctrl( n );\n+          set_early_ctrl(n, false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":320,"deletions":321,"binary":false,"changes":641,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class CountedLoopEndNode;\n+class BaseCountedLoopEndNode;\n@@ -153,1 +153,1 @@\n-  bool is_valid_counted_loop() const;\n+  bool is_valid_counted_loop(BasicType bt) const;\n@@ -195,1 +195,30 @@\n-class CountedLoopNode : public LoopNode {\n+class BaseCountedLoopNode : public LoopNode {\n+public:\n+  BaseCountedLoopNode(Node *entry, Node *backedge)\n+    : LoopNode(entry, backedge) {\n+  }\n+\n+  Node *init_control() const { return in(EntryControl); }\n+  Node *back_control() const { return in(LoopBackControl); }\n+\n+  Node* init_trip() const;\n+  Node* stride() const;\n+  bool stride_is_con() const;\n+  Node* limit() const;\n+  Node* incr() const;\n+  Node* phi() const;\n+\n+  BaseCountedLoopEndNode* loopexit_or_null() const;\n+  BaseCountedLoopEndNode* loopexit() const;\n+\n+  virtual BasicType bt() const = 0;\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+\n+  static BaseCountedLoopNode* make(Node* entry, Node* backedge, BasicType bt);\n+};\n+\n+\n+class CountedLoopNode : public BaseCountedLoopNode {\n@@ -219,2 +248,2 @@\n-  CountedLoopNode( Node *entry, Node *backedge )\n-    : LoopNode(entry, backedge), _main_idx(0), _trip_count(max_juint),\n+  CountedLoopNode(Node *entry, Node *backedge)\n+    : BaseCountedLoopNode(entry, backedge), _main_idx(0), _trip_count(max_juint),\n@@ -231,6 +260,2 @@\n-  Node *init_control() const { return in(EntryControl); }\n-  Node *back_control() const { return in(LoopBackControl); }\n-  CountedLoopEndNode *loopexit_or_null() const;\n-  CountedLoopEndNode *loopexit() const;\n-  Node *init_trip() const;\n-  Node *stride() const;\n+  CountedLoopEndNode* loopexit_or_null() const { return (CountedLoopEndNode*) BaseCountedLoopNode::loopexit_or_null(); }\n+  CountedLoopEndNode* loopexit() const { return (CountedLoopEndNode*) BaseCountedLoopNode::loopexit(); }\n@@ -238,4 +263,0 @@\n-  bool  stride_is_con() const;\n-  Node *limit() const;\n-  Node *incr() const;\n-  Node *phi() const;\n@@ -244,1 +265,3 @@\n-  static Node* match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2, const TypeInt** trunc_type);\n+  static Node*\n+  match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2, const TypeInteger** trunc_type,\n+                                      BasicType bt);\n@@ -319,0 +342,8 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n+  virtual BasicType bt() const {\n+    return T_INT;\n+  }\n+\n@@ -324,0 +355,24 @@\n+class LongCountedLoopNode : public BaseCountedLoopNode {\n+public:\n+  LongCountedLoopNode(Node *entry, Node *backedge)\n+    : BaseCountedLoopNode(entry, backedge) {\n+    init_class_id(Class_LongCountedLoop);\n+  }\n+\n+  virtual int Opcode() const;\n+\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n+\n+  virtual BasicType bt() const {\n+    return T_LONG;\n+  }\n+\n+  LongCountedLoopEndNode* loopexit_or_null() const { return (LongCountedLoopEndNode*) BaseCountedLoopNode::loopexit_or_null(); }\n+  LongCountedLoopEndNode* loopexit() const { return (LongCountedLoopEndNode*) BaseCountedLoopNode::loopexit(); }\n+  jlong   stride_con() const;\n+};\n+\n+\n@@ -327,1 +382,2 @@\n-class CountedLoopEndNode : public IfNode {\n+\n+class BaseCountedLoopEndNode : public IfNode {\n@@ -330,4 +386,3 @@\n-\n-  CountedLoopEndNode( Node *control, Node *test, float prob, float cnt )\n-    : IfNode( control, test, prob, cnt) {\n-    init_class_id(Class_CountedLoopEnd);\n+  BaseCountedLoopEndNode(Node *control, Node *test, float prob, float cnt)\n+    : IfNode(control, test, prob, cnt) {\n+    init_class_id(Class_BaseCountedLoopEnd);\n@@ -335,1 +390,0 @@\n-  virtual int Opcode() const;\n@@ -338,9 +392,8 @@\n-  Node *incr() const                { Node *tmp = cmp_node(); return (tmp && tmp->req()==3) ? tmp->in(1) : NULL; }\n-  Node *limit() const               { Node *tmp = cmp_node(); return (tmp && tmp->req()==3) ? tmp->in(2) : NULL; }\n-  Node *stride() const              { Node *tmp = incr    (); return (tmp && tmp->req()==3) ? tmp->in(2) : NULL; }\n-  Node *init_trip() const           { Node *tmp = phi     (); return (tmp && tmp->req()==3) ? tmp->in(1) : NULL; }\n-  int stride_con() const;\n-  bool stride_is_con() const        { Node *tmp = stride  (); return (tmp != NULL && tmp->is_Con()); }\n-  BoolTest::mask test_trip() const  { return in(TestValue)->as_Bool()->_test._test; }\n-  PhiNode *phi() const {\n-    Node *tmp = incr();\n+  Node* incr() const                { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n+  Node* limit() const               { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n+  Node* stride() const              { Node* tmp = incr(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n+  Node* init_trip() const           { Node* tmp = phi(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n+  bool stride_is_con() const        { Node *tmp = stride(); return (tmp != NULL && tmp->is_Con()); }\n+\n+  PhiNode* phi() const {\n+    Node* tmp = incr();\n@@ -355,1 +408,2 @@\n-  CountedLoopNode *loopnode() const {\n+\n+  BaseCountedLoopNode* loopnode() const {\n@@ -363,3 +417,6 @@\n-    Node *ln = iv_phi->in(0);\n-    if (ln->is_CountedLoop() && ln->as_CountedLoop()->loopexit_or_null() == this) {\n-      return (CountedLoopNode*)ln;\n+    Node* ln = iv_phi->in(0);\n+    if (!ln->is_BaseCountedLoop() || ln->as_BaseCountedLoop()->loopexit_or_null() != this) {\n+      return NULL;\n+    }\n+    if (!ln->operates_on(bt(), true)) {\n+      return NULL;\n@@ -367,1 +424,34 @@\n-    return NULL;\n+    return ln->as_BaseCountedLoop();\n+  }\n+\n+  BoolTest::mask test_trip() const  { return in(TestValue)->as_Bool()->_test._test; }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+\n+  jlong stride_con() const;\n+  virtual BasicType bt() const = 0;\n+\n+  static BaseCountedLoopEndNode* make(Node* control, Node* test, float prob, float cnt, BasicType bt);\n+};\n+\n+class CountedLoopEndNode : public BaseCountedLoopEndNode {\n+public:\n+\n+  CountedLoopEndNode(Node *control, Node *test, float prob, float cnt)\n+    : BaseCountedLoopEndNode(control, test, prob, cnt) {\n+    init_class_id(Class_CountedLoopEnd);\n+  }\n+  virtual int Opcode() const;\n+\n+  CountedLoopNode* loopnode() const {\n+    return (CountedLoopNode*) BaseCountedLoopEndNode::loopnode();\n+  }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n+\n+  virtual BasicType bt() const {\n+    return T_INT;\n@@ -375,0 +465,21 @@\n+class LongCountedLoopEndNode : public BaseCountedLoopEndNode {\n+public:\n+  LongCountedLoopEndNode(Node *control, Node *test, float prob, float cnt)\n+    : BaseCountedLoopEndNode(control, test, prob, cnt) {\n+    init_class_id(Class_LongCountedLoopEnd);\n+  }\n+\n+  LongCountedLoopNode* loopnode() const {\n+    return (LongCountedLoopNode*) BaseCountedLoopEndNode::loopnode();\n+  }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n+  virtual int Opcode() const;\n+\n+  virtual BasicType bt() const {\n+    return T_LONG;\n+  }\n+};\n+\n@@ -376,1 +487,1 @@\n-inline CountedLoopEndNode* CountedLoopNode::loopexit_or_null() const {\n+inline BaseCountedLoopEndNode* BaseCountedLoopNode::loopexit_or_null() const {\n@@ -381,2 +492,8 @@\n-  return (CountedLoopEndNode*)\n-      (lexit->Opcode() == Op_CountedLoopEnd ? lexit : NULL);\n+  if (!lexit->is_BaseCountedLoopEnd()) {\n+    return NULL;\n+  }\n+  BaseCountedLoopEndNode* result = lexit->as_BaseCountedLoopEnd();\n+  if (!result->operates_on(bt(), true)) {\n+    return NULL;\n+  }\n+  return result;\n@@ -385,2 +502,2 @@\n-inline CountedLoopEndNode* CountedLoopNode::loopexit() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline BaseCountedLoopEndNode* BaseCountedLoopNode::loopexit() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -391,2 +508,2 @@\n-inline Node* CountedLoopNode::init_trip() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::init_trip() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -395,2 +512,2 @@\n-inline Node* CountedLoopNode::stride() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::stride() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -399,6 +516,3 @@\n-inline int CountedLoopNode::stride_con() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n-  return cle != NULL ? cle->stride_con() : 0;\n-}\n-inline bool CountedLoopNode::stride_is_con() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+\n+inline bool BaseCountedLoopNode::stride_is_con() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -407,2 +521,2 @@\n-inline Node* CountedLoopNode::limit() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::limit() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -411,2 +525,2 @@\n-inline Node* CountedLoopNode::incr() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::incr() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -415,2 +529,2 @@\n-inline Node* CountedLoopNode::phi() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::phi() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -824,2 +938,2 @@\n-  void set_early_ctrl( Node *n );\n-  void set_subtree_ctrl( Node *root );\n+  void set_early_ctrl(Node* n, bool update_body);\n+  void set_subtree_ctrl(Node* n, bool update_body);\n@@ -1057,1 +1171,2 @@\n-  bool is_counted_loop(Node* n, IdealLoopTree* &loop);\n+  bool is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt);\n+\n@@ -1059,1 +1174,1 @@\n-  bool is_long_counted_loop(Node* x, IdealLoopTree* loop, Node_List &old_new);\n+  bool transform_long_counted_loop(IdealLoopTree* loop, Node_List &old_new);\n@@ -1493,0 +1608,4 @@\n+\n+  void check_long_counted_loop(IdealLoopTree* loop, Node* x) NOT_DEBUG_RETURN;\n+\n+  LoopNode* create_inner_head(IdealLoopTree* loop, LongCountedLoopNode* head, LongCountedLoopEndNode* exit_test);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":180,"deletions":61,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-      set_early_ctrl(cd);\n+      set_early_ctrl(cd, false);\n@@ -518,1 +518,1 @@\n-        loop_n->_head->as_Loop()->is_valid_counted_loop() &&\n+        loop_n->_head->as_Loop()->is_valid_counted_loop(T_INT) &&\n@@ -1041,1 +1041,2 @@\n-  if ((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_loop())) && n->Opcode() == Op_AddI) {\n+  if (((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_loop())) && n->Opcode() == Op_AddI) ||\n+      (n_blk->is_LongCountedLoop() && n->Opcode() == Op_AddL)) {\n@@ -2295,1 +2296,1 @@\n-  const TypeInt* ttype = NULL;\n+  const TypeInteger* ttype = NULL;\n@@ -2316,1 +2317,1 @@\n-                                &trunc1, &trunc2, &ttype);\n+                                &trunc1, &trunc2, &ttype, T_INT);\n@@ -2326,1 +2327,1 @@\n-                                &trunc1, &trunc2, &ttype);\n+                                &trunc1, &trunc2, &ttype, T_INT);\n@@ -3496,1 +3497,1 @@\n-  if (!loop->_head->as_Loop()->is_valid_counted_loop())\n+  if (!loop->_head->as_Loop()->is_valid_counted_loop(T_INT))\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1510,0 +1510,10 @@\n+const TypeInteger* Node::find_integer_type(BasicType bt) const {\n+  if (this->is_Type()) {\n+    return this->as_Type()->type()->isa_integer(bt);\n+  } else if (this->is_Con()) {\n+    assert(is_Mach(), \"should be ConNode(TypeNode) or else a MachNode\");\n+    return this->bottom_type()->isa_integer(bt);\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+class BaseCountedLoopNode;\n+class BaseCountedLoopEndNode;\n@@ -89,0 +91,2 @@\n+class LongCountedLoopNode;\n+class LongCountedLoopEndNode;\n@@ -636,1 +640,3 @@\n-          DEFINE_CLASS_ID(CountedLoopEnd,         If, 0)\n+          DEFINE_CLASS_ID(BaseCountedLoopEnd,     If, 0)\n+            DEFINE_CLASS_ID(CountedLoopEnd,       BaseCountedLoopEnd, 0)\n+            DEFINE_CLASS_ID(LongCountedLoopEnd,   BaseCountedLoopEnd, 1)\n@@ -705,1 +711,3 @@\n-        DEFINE_CLASS_ID(CountedLoop,         Loop, 1)\n+        DEFINE_CLASS_ID(BaseCountedLoop,     Loop, 1)\n+          DEFINE_CLASS_ID(CountedLoop,       BaseCountedLoop, 0)\n+          DEFINE_CLASS_ID(LongCountedLoop,   BaseCountedLoop, 1)\n@@ -808,0 +816,2 @@\n+  DEFINE_CLASS_QUERY(BaseCountedLoop)\n+  DEFINE_CLASS_QUERY(BaseCountedLoopEnd)\n@@ -844,0 +854,2 @@\n+  DEFINE_CLASS_QUERY(LongCountedLoop)\n+  DEFINE_CLASS_QUERY(LongCountedLoopEnd)\n@@ -1084,0 +1096,1 @@\n+  const TypeInteger* find_integer_type(BasicType bt) const;\n@@ -1097,0 +1110,5 @@\n+  jlong get_integer_as_long(BasicType bt) const {\n+    const TypeInteger* t = find_integer_type(bt);\n+    guarantee(t != NULL, \"must be con\");\n+    return t->get_con_as_long(bt);\n+  }\n@@ -1206,0 +1224,6 @@\n+public:\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    Unimplemented();\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -789,0 +789,10 @@\n+ConNode* PhaseTransform::integercon(jlong l, BasicType bt) {\n+  if (bt == T_INT) {\n+    jint int_con = (jint)l;\n+    assert(((long)int_con) == l, \"not an int\");\n+    return intcon(int_con);\n+  }\n+  assert(bt == T_LONG, \"not an integer\");\n+  return longcon(l);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,0 +118,12 @@\n+SubNode* SubNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new SubINode(in1, in2);\n+    case T_LONG:\n+      return new SubLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+\n+  static SubNode* make(Node* in1, Node* in2, BasicType bt);\n@@ -151,0 +153,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n@@ -161,0 +167,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT && signed_int;\n+  }\n@@ -172,0 +182,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT && !signed_int;\n+  }\n@@ -202,0 +216,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG && signed_int;\n+  }\n@@ -211,0 +229,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG && !signed_int;\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  if (!cl->is_valid_counted_loop()) return; \/\/ skip malformed counted loop\n+  if (!cl->is_valid_counted_loop(T_INT)) return; \/\/ skip malformed counted loop\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1349,0 +1349,16 @@\n+jlong TypeInteger::get_con_as_long(BasicType bt) const {\n+  if (bt == T_INT) {\n+    return is_int()->get_con();\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return is_long()->get_con();\n+}\n+\n+const TypeInteger* TypeInteger::bottom(BasicType bt) {\n+  if (bt == T_INT) {\n+    return TypeInt::INT;\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return TypeLong::LONG;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -287,1 +287,0 @@\n-  const TypeInteger* isa_integer() const;\n@@ -542,0 +541,2 @@\n+\n+  static const TypeInteger* bottom(BasicType type);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -721,0 +721,16 @@\n+inline jlong max_signed_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return max_jint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return max_jlong;\n+}\n+\n+inline jlong min_signed_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return min_jint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return min_jlong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}