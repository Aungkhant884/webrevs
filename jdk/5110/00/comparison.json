{"files":[{"patch":"@@ -655,0 +655,4 @@\n+            if (session != null) {\n+                chc.handshakeSession = session;\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8270344\n+ * @library \/test\/lib\n+ * @summary Session resumption errors\n+ * @run main\/othervm InvalidateSession\n+ *\/\n+\n+import javax.net.*;\n+import javax.net.ssl.*;\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+\n+import jdk.test.lib.security.SecurityUtils;\n+\n+public class InvalidateSession {\n+    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n+    static String keyStoreFile = \"keystore\";\n+    static String trustStoreFile = \"truststore\";\n+    static String passwd = \"passphrase\";\n+    static Server server;\n+    static SSLSession cacheSession;\n+    static final String[] CLIENT_VERSIONS = {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"};\n+\n+    public static void main(String args[]) throws Exception {\n+        String keyFilename =\n+                System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+                        \"\/\" + keyStoreFile;\n+        String trustFilename =\n+                System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+                        \"\/\" + trustStoreFile;\n+\n+        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n+        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n+        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n+        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n+\n+        \/\/ drop the supported_versions extension to force test to use the legacy\n+        \/\/ TLS protocol version field during handshakes\n+        System.setProperty(\"jdk.tls.client.disableExtensions\", \"supported_versions\");\n+\n+        SecurityUtils.removeFromDisabledTlsAlgs(\"TLSv1\", \"TLSv1.1\");\n+        server = startServer();\n+        while (!server.started) {\n+            Thread.yield();\n+        }\n+\n+        InvalidateSession test = new InvalidateSession();\n+        test.clientTest();\n+        server.go = false;\n+    }\n+\n+    \/**\n+     * 4 test iterations\n+     * 1) Server configured with TLSv1, client with TLSv1, v1.1, v1.2\n+     * - Handshake should succeed\n+     * - Session \"A\" established\n+     * 2) 2nd iteration, server configured with TLSv1.2 only\n+     * - Session resumption should fail (Attempted to resume with TLSv1)\n+     * - Session \"A\" should be invalidated\n+     * 3) 3rd iteration, same server\/client config\n+     * - Session \"A\" should now be invalidated and no longer attempted\n+     * - Handshake should succeed\n+     * = Session \"B\" established\n+     * 4) 4th iteration, same server\/client config\n+     * - Session \"B\" should resume without issue\n+     *\/\n+    private void clientTest() throws Exception {\n+        for (int i = 1; i <= 4; i++) {\n+            clientConnect(i);\n+            Thread.sleep(1000);\n+        }\n+    }\n+\n+    public void clientConnect(int testIterationCount) throws Exception {\n+        System.out.printf(\"Connecting to: localhost: %s, iteration count %d%n\",\n+                \"localhost:\" + server.port, testIterationCount);\n+        SSLSocketFactory ssf = (SSLSocketFactory) SSLSocketFactory.getDefault();\n+        SSLSocket sslSocket = (SSLSocket) ssf.createSocket(\"localhost\", server.port);\n+        sslSocket.setEnabledProtocols(CLIENT_VERSIONS);\n+\n+        try {\n+            sslSocket.startHandshake();\n+        } catch (Exception e) {\n+\n+            if (testIterationCount != 2) {\n+                \/\/ only the 2nd handshake should fail (in which case we continue)\n+                throw new RuntimeException(\"Unexpected exception\", e);\n+            }\n+            return;\n+        }\n+        if (testIterationCount == 1) {\n+            \/\/ capture the session ID\n+            cacheSession = sslSocket.getSession();\n+        } else {\n+            \/\/ should be on 3rd or 4th iteration\n+            \/\/ new session ID should be in use (check in 4th iteration)\n+            if (Objects.equals(cacheSession, sslSocket.getSession()) && testIterationCount != 4) {\n+                throw new RuntimeException(\"Same session should not be resumed\");\n+            }\n+            cacheSession = sslSocket.getSession();\n+        }\n+\n+        System.out.println(\"Got session: \" + sslSocket.getSession());\n+        try (\n+        ObjectOutputStream oos = new ObjectOutputStream(sslSocket.getOutputStream());\n+        ObjectInputStream ois = new ObjectInputStream(sslSocket.getInputStream())) {\n+            oos.writeObject(\"Hello\");\n+            String serverMsg = (String) ois.readObject();\n+            System.out.println(\"Server message : \" + serverMsg);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        } finally {\n+            sslSocket.close();\n+        }\n+    }\n+\n+    private static Server startServer() {\n+        Server server = new Server();\n+        new Thread(server).start();\n+        return server;\n+    }\n+\n+    private static class Server implements Runnable {\n+        public volatile boolean go = true;\n+        public volatile int port = 0;\n+        public volatile boolean started = false;\n+\n+        @Override\n+        public void run() {\n+            try {\n+                SSLContext sc = SSLContext.getDefault();\n+                ServerSocketFactory fac = sc.getServerSocketFactory();\n+                SSLServerSocket ssock = (SSLServerSocket)\n+                        fac.createServerSocket(0);\n+                this.port = ssock.getLocalPort();\n+                ssock.setEnabledProtocols(new String[]{\"TLSv1\"});\n+                started = true;\n+                while (go) {\n+                    try {\n+                        System.out.println(\"Waiting for connection\");\n+                        Socket sock = ssock.accept();\n+                        \/\/ now flip server to TLSv1.2 mode for successive connections\n+                        ssock.setEnabledProtocols(new String[]{\"TLSv1.2\"});\n+                        try (\n+                        ObjectInputStream ois = new ObjectInputStream(sock.getInputStream());\n+                        ObjectOutputStream oos = new ObjectOutputStream(sock.getOutputStream())) {\n+                            String recv = (String) ois.readObject();\n+                            oos.writeObject(\"Received: \" + recv);\n+                        } catch (SSLHandshakeException she) {\n+                            System.out.println(\"Server caught :\" + she);\n+                        } finally {\n+                            sock.close();\n+                        }\n+                    } catch (Exception ex) {\n+                        throw new RuntimeException(ex);\n+                    }\n+                }\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/InvalidateSession.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"}]}