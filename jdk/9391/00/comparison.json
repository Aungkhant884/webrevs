{"files":[{"patch":"@@ -1452,0 +1452,6 @@\n+  \/\/ Do not use superword for non-primitives\n+  BasicType bt1 = velt_basic_type(s);\n+  BasicType bt2 = velt_basic_type(t);\n+  if (!is_java_primitive(bt1) || !is_java_primitive(bt2)) {\n+    return align;\n+  }\n@@ -3414,26 +3420,17 @@\n-  int opcode = n->Opcode();\n-  switch (opcode) {\n-    case Op_ConvD2I:\n-    case Op_ConvI2D:\n-    case Op_ConvF2D:\n-    case Op_ConvD2F: return T_DOUBLE;\n-    case Op_ConvF2L:\n-    case Op_ConvL2F:\n-    case Op_ConvL2I:\n-    case Op_ConvI2L: return T_LONG;\n-    case Op_ConvI2F: {\n-      BasicType src_t = velt_basic_type(n->in(1));\n-      if (src_t == T_BYTE || src_t == T_SHORT) {\n-        return T_FLOAT;\n-      }\n-      return T_ILLEGAL;\n-    }\n-    case Op_ConvF2I: {\n-      BasicType dst_t = velt_basic_type(n);\n-      if (dst_t == T_BYTE || dst_t == T_SHORT) {\n-        return T_FLOAT;\n-      }\n-      return T_ILLEGAL;\n-    }\n-  }\n-  return T_ILLEGAL;\n+  if (!VectorNode::is_convert_opcode(n->Opcode()) ||\n+      !in_bb(n->in(1))) {\n+    return T_ILLEGAL;\n+  }\n+  assert(in_bb(n), \"must be in the bb\");\n+  BasicType src_t = velt_basic_type(n->in(1));\n+  BasicType dst_t = velt_basic_type(n);\n+  \/\/ Do not use superword for non-primitives.\n+  \/\/ Superword does not support casting involving unsigned types.\n+  if (!is_java_primitive(src_t) || is_unsigned_subword_type(src_t) ||\n+      !is_java_primitive(dst_t) || is_unsigned_subword_type(dst_t)) {\n+    return T_ILLEGAL;\n+  }\n+  int src_size = type2aelembytes(src_t);\n+  int dst_size = type2aelembytes(dst_t);\n+  return src_size == dst_size ? T_ILLEGAL\n+                              : (src_size > dst_size ? src_t : dst_t);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-  \/\/ Return the longer type for type-conversion node and return illegal type for other nodes.\n+  \/\/ Return the longer type for vectorizable type-conversion node or illegal type for other nodes.\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1273,0 +1273,1 @@\n+      is_java_primitive(src_type) &&\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -741,0 +741,4 @@\n+inline bool is_unsigned_subword_type(BasicType t) {\n+  return (t == T_BOOLEAN || t == T_CHAR);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8288883\n+ * @summary Tests auto-vectorization of type conversion with unsafe.\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -Xbatch compiler.loopopts.superword.TestVectorizeTypeConversionWithUnsafe\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestVectorizeTypeConversionWithUnsafe {\n+    private static final int LENGTH = 1024;\n+    private static final int BUFFER_SIZE = LENGTH * 4;\n+    private static final int WARMUP = 10_000;\n+    private static final Unsafe unsafe;\n+    private static final long address;\n+    private static final long base_offset_ints;\n+    private static int[] srcptrs = new int[LENGTH];\n+\n+    static {\n+        unsafe = Unsafe.getUnsafe();\n+        address = unsafe.allocateMemory(BUFFER_SIZE);\n+        base_offset_ints = unsafe.arrayBaseOffset(int[].class);\n+    }\n+\n+    public static long conv(){\n+        long res = 0;\n+        int ecur;\n+        for (int i = 0; i < LENGTH; i++) {\n+            ecur = srcptrs[i];\n+            res += unsafe.getInt(address + ecur);\n+        }\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < WARMUP; i++) {\n+            conv();\n+        }\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            srcptrs[i] = i * 4;\n+        }\n+        unsafe.copyMemory(srcptrs, base_offset_ints, null, address, BUFFER_SIZE);\n+        long res = conv();\n+        unsafe.freeMemory(address);\n+\n+        if (res != 2095104) {\n+            throw new RuntimeException(\"Wrong result.\");\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestVectorizeTypeConversionWithUnsafe.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}