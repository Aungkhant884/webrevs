{"files":[{"patch":"@@ -114,1 +114,1 @@\n-  virtual bool should_enqueue_buffer(SATBMarkQueue& queue);\n+  bool should_enqueue_buffer(SATBMarkQueue& queue);\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/satbMarkQueue.hpp\"\n@@ -235,0 +236,13 @@\n+class ShenandoahFlushSATBHandshakeClosure : public HandshakeClosure {\n+private:\n+  SATBMarkQueueSet& _qset;\n+public:\n+  ShenandoahFlushSATBHandshakeClosure(SATBMarkQueueSet& qset) :\n+    HandshakeClosure(\"Shenandoah Flush SATB Handshake\"),\n+    _qset(qset) {}\n+\n+  void do_thread(Thread* thread) {\n+    _qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n+  }\n+};\n+\n@@ -241,1 +255,3 @@\n-  {\n+  ShenandoahSATBMarkQueueSet& qset = ShenandoahBarrierSet::satb_mark_queue_set();\n+  ShenandoahFlushSATBHandshakeClosure flush_satb(qset);\n+  for (uint flushes = 0; flushes < ShenandoahMaxSATBBufferFlushes; flushes++) {\n@@ -245,1 +261,0 @@\n-  }\n@@ -247,0 +262,14 @@\n+    if (heap->cancelled_gc()) {\n+      \/\/ GC is cancelled, break out.\n+      break;\n+    }\n+\n+    size_t before = qset.completed_buffers_num();\n+    Handshake::execute(&flush_satb);\n+    size_t after = qset.completed_buffers_num();\n+\n+    if (before == after) {\n+      \/\/ No more retries needed, break out.\n+      break;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  _periodic_satb_flush_task.enroll();\n@@ -74,4 +73,0 @@\n-void ShenandoahPeriodicSATBFlushTask::task() {\n-  ShenandoahHeap::heap()->force_satb_flush_all_threads();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,7 +49,0 @@\n-\/\/ Periodic task to flush SATB buffers periodically.\n-class ShenandoahPeriodicSATBFlushTask : public PeriodicTask {\n-public:\n-  ShenandoahPeriodicSATBFlushTask() : PeriodicTask(ShenandoahSATBBufferFlushInterval) {}\n-  virtual void task();\n-};\n-\n@@ -80,1 +73,0 @@\n-  ShenandoahPeriodicSATBFlushTask _periodic_satb_flush_task;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1687,14 +1687,0 @@\n-void ShenandoahHeap::force_satb_flush_all_threads() {\n-  if (!is_concurrent_mark_in_progress()) {\n-    \/\/ No need to flush SATBs\n-    return;\n-  }\n-\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n-    ShenandoahThreadLocalData::set_force_satb_flush(t, true);\n-  }\n-  \/\/ The threads are not \"acquiring\" their thread-local data, but it does not\n-  \/\/ hurt to \"release\" the updates here anyway.\n-  OrderAccess::fence();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -583,1 +583,0 @@\n-  void force_satb_flush_all_threads();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,17 +56,0 @@\n-\n-bool ShenandoahSATBMarkQueueSet::should_enqueue_buffer(SATBMarkQueue& queue) {\n-  if (SATBMarkQueueSet::should_enqueue_buffer(queue)) {\n-    return true;\n-  } else if (queue.index() < buffer_size()) { \/\/ Is buffer not empty?\n-    Thread* t = Thread::current();\n-    if (ShenandoahThreadLocalData::is_force_satb_flush(t)) {\n-      \/\/ Non-empty buffer is compacted, and we decided not to enqueue it.\n-      \/\/ We still want to know about leftover work in that buffer eventually.\n-      \/\/ This avoid dealing with these leftovers during the final-mark, after\n-      \/\/ the buffers are drained completely. See JDK-8205353 for more discussion.\n-      ShenandoahThreadLocalData::set_force_satb_flush(t, false);\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-protected:\n-  virtual bool should_enqueue_buffer(SATBMarkQueue& queue);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  bool _force_satb_flush;\n@@ -63,1 +62,0 @@\n-    _force_satb_flush(false),\n@@ -118,8 +116,0 @@\n-  static void set_force_satb_flush(Thread* thread, bool v) {\n-    data(thread)->_force_satb_flush = v;\n-  }\n-\n-  static bool is_force_satb_flush(Thread* thread) {\n-    return data(thread)->_force_satb_flush;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -333,3 +333,3 @@\n-  product(uintx, ShenandoahSATBBufferFlushInterval, 100, EXPERIMENTAL,      \\\n-          \"Forcefully flush non-empty SATB buffers at this interval. \"      \\\n-          \"Time is in milliseconds.\")                                       \\\n+  product(uintx, ShenandoahMaxSATBBufferFlushes, 5, EXPERIMENTAL,           \\\n+          \"How many times to maximum attempt to flush SATB buffers at the \" \\\n+          \"end of concurrent marking.\")                                     \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}