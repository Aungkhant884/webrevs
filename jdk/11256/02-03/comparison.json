{"files":[{"patch":"@@ -1503,1 +1503,1 @@\n-  CDS_JAVA_HEAP_ONLY(Universe::update_archived_mirrors());\n+  CDS_JAVA_HEAP_ONLY(Universe::update_archived_basic_type_mirrors());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1125,2 +1125,3 @@\n-    oop m = Universe::_mirrors[t].resolve();\n-    if (m != NULL) {\n+    if (!is_reference_type(bt)) {\n+      oop m = Universe::java_mirror(bt);\n+      assert(m != NULL, \"sanity\");\n@@ -1141,1 +1142,1 @@\n-      Universe::set_archived_mirror_index(bt, HeapShared::append_root(archived_m));\n+      Universe::set_archived_basic_type_mirror_index(bt, HeapShared::append_root(archived_m));\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-OopHandle Universe::_mirrors[T_VOID+1];\n+OopHandle Universe::_basic_type_mirrors[T_VOID+1];\n@@ -93,1 +93,1 @@\n-int Universe::_archived_mirror_indices[T_VOID+1];\n+int Universe::_archived_basic_type_mirror_indices[T_VOID+1];\n@@ -186,9 +186,9 @@\n-oop Universe::int_mirror()                        { return check_mirror(_mirrors[T_INT].resolve()); }\n-oop Universe::float_mirror()                      { return check_mirror(_mirrors[T_FLOAT].resolve()); }\n-oop Universe::double_mirror()                     { return check_mirror(_mirrors[T_DOUBLE].resolve()); }\n-oop Universe::byte_mirror()                       { return check_mirror(_mirrors[T_BYTE].resolve()); }\n-oop Universe::bool_mirror()                       { return check_mirror(_mirrors[T_BOOLEAN].resolve()); }\n-oop Universe::char_mirror()                       { return check_mirror(_mirrors[T_CHAR].resolve()); }\n-oop Universe::long_mirror()                       { return check_mirror(_mirrors[T_LONG].resolve()); }\n-oop Universe::short_mirror()                      { return check_mirror(_mirrors[T_SHORT].resolve()); }\n-oop Universe::void_mirror()                       { return check_mirror(_mirrors[T_VOID].resolve()); }\n+oop Universe::int_mirror()                        { return check_mirror(_basic_type_mirrors[T_INT].resolve()); }\n+oop Universe::float_mirror()                      { return check_mirror(_basic_type_mirrors[T_FLOAT].resolve()); }\n+oop Universe::double_mirror()                     { return check_mirror(_basic_type_mirrors[T_DOUBLE].resolve()); }\n+oop Universe::byte_mirror()                       { return check_mirror(_basic_type_mirrors[T_BYTE].resolve()); }\n+oop Universe::bool_mirror()                       { return check_mirror(_basic_type_mirrors[T_BOOLEAN].resolve()); }\n+oop Universe::char_mirror()                       { return check_mirror(_basic_type_mirrors[T_CHAR].resolve()); }\n+oop Universe::long_mirror()                       { return check_mirror(_basic_type_mirrors[T_LONG].resolve()); }\n+oop Universe::short_mirror()                      { return check_mirror(_basic_type_mirrors[T_SHORT].resolve()); }\n+oop Universe::void_mirror()                       { return check_mirror(_basic_type_mirrors[T_VOID].resolve()); }\n@@ -198,1 +198,2 @@\n-  return check_mirror(_mirrors[t].resolve());\n+  assert(!is_reference_type(t), \"sanity\");\n+  return check_mirror(_basic_type_mirrors[t].resolve());\n@@ -238,1 +239,1 @@\n-void Universe::set_archived_mirror_index(BasicType t, int index) {\n+void Universe::set_archived_basic_type_mirror_index(BasicType t, int index) {\n@@ -240,1 +241,2 @@\n-  _archived_mirror_indices[t] = index;\n+  assert(!is_reference_type(t), \"sanity\");\n+  _archived_basic_type_mirror_indices[t] = index;\n@@ -243,1 +245,1 @@\n-void Universe::update_archived_mirrors() {\n+void Universe::update_archived_basic_type_mirrors() {\n@@ -246,2 +248,2 @@\n-      int index = _archived_mirror_indices[i];\n-      if (index >= 0) {\n+      int index = _archived_basic_type_mirror_indices[i];\n+      if (!is_reference_type((BasicType)i) && index >= 0) {\n@@ -250,1 +252,1 @@\n-        _mirrors[i] = OopHandle(vm_global(), mirror_oop);\n+        _basic_type_mirrors[i] = OopHandle(vm_global(), mirror_oop);\n@@ -257,2 +259,0 @@\n-\n-\/\/ Serialize metadata and pointers to primitive type mirrors in and out of CDS archive\n@@ -263,7 +263,4 @@\n-    if (f->writing() && !HeapShared::can_write()) {\n-      _archived_mirror_indices[i] = -1;\n-    }\n-\n-    f->do_u4((u4*)&_archived_mirror_indices[i]);\n-    \/\/ Can't call HeapShared::get_root() yet, as the heap contents may need to be\n-    \/\/ relocated. _mirrors[i] will be updated later in Universe::update_archived_mirrors().\n+    f->do_u4((u4*)&_archived_basic_type_mirror_indices[i]);\n+    \/\/ if f->reading(): We can't call HeapShared::get_root() yet, as the heap\n+    \/\/ contents may need to be relocated. _basic_type_mirrors[i] will be\n+    \/\/ updated later in Universe::update_archived_basic_type_mirrors().\n@@ -461,1 +458,1 @@\n-        _mirrors[T_INT].resolve() != NULL) {\n+        _basic_type_mirrors[T_INT].resolve() != NULL) {\n@@ -464,1 +461,1 @@\n-      \/\/ check that all mirrors are mapped also\n+      \/\/ check that all basic type mirrors are mapped also\n@@ -467,1 +464,1 @@\n-          oop m = _mirrors[i].resolve();\n+          oop m = _basic_type_mirrors[i].resolve();\n@@ -472,1 +469,1 @@\n-      \/\/ _mirror[T_INT} could be NULL if archived heap is not mapped.\n+      \/\/ _basic_type_mirrors[T_INT], etc, are NULL if archived heap is not mapped.\n@@ -479,1 +476,1 @@\n-          _mirrors[i] = OopHandle(vm_global(), m);\n+          _basic_type_mirrors[i] = OopHandle(vm_global(), m);\n@@ -481,0 +478,1 @@\n+        CDS_JAVA_HEAP_ONLY(_archived_basic_type_mirror_indices[i] = -1);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":30,"deletions":32,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -199,0 +199,4 @@\n+  \/\/ Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY\n+  \/\/ but including T_VOID, hence the index including T_VOID\n+  static OopHandle _basic_type_mirrors[T_VOID+1];\n+\n@@ -200,1 +204,3 @@\n-  static int _archived_mirror_indices[T_VOID+1];\n+  \/\/ Each slot i stores an index that can be used to restore _basic_type_mirrors[i]\n+  \/\/ from the archive heap using HeapShared::get_root(int)\n+  static int _archived_basic_type_mirror_indices[T_VOID+1];\n@@ -238,4 +244,0 @@\n-  \/\/ Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY\n-  \/\/ but including T_VOID, hence the index including T_VOID\n-  static OopHandle _mirrors[T_VOID+1];\n-\n@@ -245,2 +247,2 @@\n-  static void set_archived_mirror_index(BasicType t, int index);\n-  static void update_archived_mirrors();\n+  static void set_archived_basic_type_mirror_index(BasicType t, int index);\n+  static void update_archived_basic_type_mirrors();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"}]}