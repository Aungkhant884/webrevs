{"files":[{"patch":"@@ -836,1 +836,1 @@\n-void HeapShared::serialize(SerializeClosure* soc) {\n+void HeapShared::serialize_root(SerializeClosure* soc) {\n@@ -852,0 +852,3 @@\n+}\n+\n+void HeapShared::serialize_tables(SerializeClosure* soc) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -413,1 +413,2 @@\n-  static void serialize(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void serialize_root(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void serialize_tables(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -378,0 +378,1 @@\n+  HeapShared::serialize_root(soc);\n@@ -388,1 +389,1 @@\n-  HeapShared::serialize(soc);\n+  HeapShared::serialize_tables(soc);\n@@ -1502,0 +1503,2 @@\n+  CDS_JAVA_HEAP_ONLY(Universe::update_archived_basic_type_mirrors());\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1125,2 +1125,3 @@\n-    oop m = Universe::_mirrors[t].resolve();\n-    if (m != NULL) {\n+    if (!is_reference_type(bt)) {\n+      oop m = Universe::java_mirror(bt);\n+      assert(m != NULL, \"sanity\");\n@@ -1141,1 +1142,1 @@\n-      Universe::replace_mirror(bt, archived_m);\n+      Universe::set_archived_basic_type_mirror_index(bt, HeapShared::append_root(archived_m));\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -91,1 +91,4 @@\n-OopHandle Universe::_mirrors[T_VOID+1];\n+OopHandle Universe::_basic_type_mirrors[T_VOID+1];\n+#if INCLUDE_CDS_JAVA_HEAP\n+int Universe::_archived_basic_type_mirror_indices[T_VOID+1];\n+#endif\n@@ -183,9 +186,9 @@\n-oop Universe::int_mirror()                        { return check_mirror(_mirrors[T_INT].resolve()); }\n-oop Universe::float_mirror()                      { return check_mirror(_mirrors[T_FLOAT].resolve()); }\n-oop Universe::double_mirror()                     { return check_mirror(_mirrors[T_DOUBLE].resolve()); }\n-oop Universe::byte_mirror()                       { return check_mirror(_mirrors[T_BYTE].resolve()); }\n-oop Universe::bool_mirror()                       { return check_mirror(_mirrors[T_BOOLEAN].resolve()); }\n-oop Universe::char_mirror()                       { return check_mirror(_mirrors[T_CHAR].resolve()); }\n-oop Universe::long_mirror()                       { return check_mirror(_mirrors[T_LONG].resolve()); }\n-oop Universe::short_mirror()                      { return check_mirror(_mirrors[T_SHORT].resolve()); }\n-oop Universe::void_mirror()                       { return check_mirror(_mirrors[T_VOID].resolve()); }\n+oop Universe::int_mirror()                        { return check_mirror(_basic_type_mirrors[T_INT].resolve()); }\n+oop Universe::float_mirror()                      { return check_mirror(_basic_type_mirrors[T_FLOAT].resolve()); }\n+oop Universe::double_mirror()                     { return check_mirror(_basic_type_mirrors[T_DOUBLE].resolve()); }\n+oop Universe::byte_mirror()                       { return check_mirror(_basic_type_mirrors[T_BYTE].resolve()); }\n+oop Universe::bool_mirror()                       { return check_mirror(_basic_type_mirrors[T_BOOLEAN].resolve()); }\n+oop Universe::char_mirror()                       { return check_mirror(_basic_type_mirrors[T_CHAR].resolve()); }\n+oop Universe::long_mirror()                       { return check_mirror(_basic_type_mirrors[T_LONG].resolve()); }\n+oop Universe::short_mirror()                      { return check_mirror(_basic_type_mirrors[T_SHORT].resolve()); }\n+oop Universe::void_mirror()                       { return check_mirror(_basic_type_mirrors[T_VOID].resolve()); }\n@@ -195,6 +198,2 @@\n-  return check_mirror(_mirrors[t].resolve());\n-}\n-\n-\/\/ Used by CDS dumping\n-void Universe::replace_mirror(BasicType t, oop new_mirror) {\n-  Universe::_mirrors[t].replace(new_mirror);\n+  assert(!is_reference_type(t), \"sanity\");\n+  return check_mirror(_basic_type_mirrors[t].resolve());\n@@ -239,3 +238,0 @@\n-\/\/ Serialize metadata and pointers to primitive type mirrors in and out of CDS archive\n-void Universe::serialize(SerializeClosure* f) {\n-\n@@ -243,2 +239,8 @@\n-  {\n-    oop mirror_oop;\n+void Universe::set_archived_basic_type_mirror_index(BasicType t, int index) {\n+  assert(DumpSharedSpaces, \"dump-time only\");\n+  assert(!is_reference_type(t), \"sanity\");\n+  _archived_basic_type_mirror_indices[t] = index;\n+}\n+\n+void Universe::update_archived_basic_type_mirrors() {\n+  if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n@@ -246,14 +248,5 @@\n-      if (f->reading()) {\n-        f->do_oop(&mirror_oop); \/\/ read from archive\n-        assert(oopDesc::is_oop_or_null(mirror_oop), \"is oop\");\n-        \/\/ Only create an OopHandle for non-null mirrors\n-        if (mirror_oop != NULL) {\n-          _mirrors[i] = OopHandle(vm_global(), mirror_oop);\n-        }\n-      } else {\n-        if (HeapShared::can_write()) {\n-          mirror_oop = _mirrors[i].resolve();\n-        } else {\n-          mirror_oop = NULL;\n-        }\n-        f->do_oop(&mirror_oop); \/\/ write to archive\n+      int index = _archived_basic_type_mirror_indices[i];\n+      if (!is_reference_type((BasicType)i) && index >= 0) {\n+        oop mirror_oop = HeapShared::get_root(index);\n+        assert(mirror_oop != NULL, \"must be\");\n+        _basic_type_mirrors[i] = OopHandle(vm_global(), mirror_oop);\n@@ -263,0 +256,12 @@\n+}\n+#endif\n+\n+void Universe::serialize(SerializeClosure* f) {\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    f->do_u4((u4*)&_archived_basic_type_mirror_indices[i]);\n+    \/\/ if f->reading(): We can't call HeapShared::get_root() yet, as the heap\n+    \/\/ contents may need to be relocated. _basic_type_mirrors[i] will be\n+    \/\/ updated later in Universe::update_archived_basic_type_mirrors().\n+  }\n@@ -453,1 +458,1 @@\n-        _mirrors[T_INT].resolve() != NULL) {\n+        _basic_type_mirrors[T_INT].resolve() != NULL) {\n@@ -456,1 +461,1 @@\n-      \/\/ check that all mirrors are mapped also\n+      \/\/ check that all basic type mirrors are mapped also\n@@ -459,1 +464,1 @@\n-          oop m = _mirrors[i].resolve();\n+          oop m = _basic_type_mirrors[i].resolve();\n@@ -464,1 +469,1 @@\n-      \/\/ _mirror[T_INT} could be NULL if archived heap is not mapped.\n+      \/\/ _basic_type_mirrors[T_INT], etc, are NULL if archived heap is not mapped.\n@@ -471,1 +476,1 @@\n-          _mirrors[i] = OopHandle(vm_global(), m);\n+          _basic_type_mirrors[i] = OopHandle(vm_global(), m);\n@@ -473,0 +478,1 @@\n+        CDS_JAVA_HEAP_ONLY(_archived_basic_type_mirror_indices[i] = -1);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":46,"deletions":40,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -199,0 +199,10 @@\n+  \/\/ Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY\n+  \/\/ but including T_VOID, hence the index including T_VOID\n+  static OopHandle _basic_type_mirrors[T_VOID+1];\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ Each slot i stores an index that can be used to restore _basic_type_mirrors[i]\n+  \/\/ from the archive heap using HeapShared::get_root(int)\n+  static int _archived_basic_type_mirror_indices[T_VOID+1];\n+#endif\n+\n@@ -234,4 +244,0 @@\n-  \/\/ Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY\n-  \/\/ but including T_VOID, hence the index including T_VOID\n-  static OopHandle _mirrors[T_VOID+1];\n-\n@@ -239,1 +245,5 @@\n-  static void replace_mirror(BasicType t, oop obj);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static void set_archived_basic_type_mirror_index(BasicType t, int index);\n+  static void update_archived_basic_type_mirrors();\n+#endif\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}