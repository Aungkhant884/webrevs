{"files":[{"patch":"@@ -294,0 +294,9 @@\n+oop ZCollectedHeap::pin_object(JavaThread* thr, oop o) {\n+  _heap.pin_object(o);\n+  return o;\n+}\n+\n+void ZCollectedHeap::unpin_object(JavaThread* thr, oop o) {\n+  _heap.unpin_object(o);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -116,0 +116,5 @@\n+  \/\/ Pinning hooks\n+  virtual oop pin_object(JavaThread* thread, oop obj);\n+  virtual void unpin_object(JavaThread* thread, oop obj);\n+  virtual bool supports_object_pinning() const { return true; }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  bool       _gc_locked;\n@@ -88,1 +87,0 @@\n-      _gc_locked(false),\n@@ -91,7 +89,0 @@\n-  virtual bool needs_inactive_gc_locker() const {\n-    \/\/ An inactive GC locker is needed in operations where we change the bad\n-    \/\/ mask or move objects. Changing the bad mask will invalidate all oops,\n-    \/\/ which makes it conceptually the same thing as moving all objects.\n-    return false;\n-  }\n-\n@@ -110,6 +101,0 @@\n-    \/\/ Abort if GC locker state is incompatible\n-    if (needs_inactive_gc_locker() && GCLocker::check_active_before_gc()) {\n-      _gc_locked = true;\n-      return;\n-    }\n-\n@@ -134,4 +119,0 @@\n-  bool gc_locked() const {\n-    return _gc_locked;\n-  }\n-\n@@ -149,4 +130,0 @@\n-  virtual bool needs_inactive_gc_locker() const {\n-    return true;\n-  }\n-\n@@ -183,4 +160,0 @@\n-  virtual bool needs_inactive_gc_locker() const {\n-    return true;\n-  }\n-\n@@ -211,2 +184,1 @@\n-    _gc_cycle_port(),\n-    _gc_locker_port() {\n+    _gc_cycle_port() {\n@@ -247,5 +219,0 @@\n-  case GCCause::_gc_locker:\n-    \/\/ Restart VM operation previously blocked by the GC locker\n-    _gc_locker_port.signal();\n-    break;\n-\n@@ -266,15 +233,3 @@\n-  for (;;) {\n-    T op;\n-    VMThread::execute(&op);\n-    if (op.gc_locked()) {\n-      \/\/ Wait for GC to become unlocked and restart the VM operation\n-      ZStatTimer timer(ZCriticalPhaseGCLockerStall);\n-      _gc_locker_port.wait();\n-      continue;\n-    }\n-\n-    \/\/ Notify VM operation completed\n-    _gc_locker_port.ack();\n-\n-    return op.success();\n-  }\n+  T op;\n+  VMThread::execute(&op);\n+  return op.success();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":4,"deletions":49,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  ZRendezvousPort              _gc_locker_port;\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  ZPage* get_page() const { return _page; }\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -355,1 +355,0 @@\n-  ZRelocationSetSelector selector;\n@@ -365,1 +364,1 @@\n-      selector.register_live_page(page);\n+      _selector.register_live_page(page);\n@@ -368,1 +367,1 @@\n-      selector.register_empty_page(page);\n+      _selector.register_empty_page(page);\n@@ -371,1 +370,1 @@\n-      free_empty_pages(&selector, 64 \/* bulk *\/);\n+      free_empty_pages(&_selector, 64 \/* bulk *\/);\n@@ -376,1 +375,1 @@\n-  free_empty_pages(&selector, 0 \/* bulk *\/);\n+  free_empty_pages(&_selector, 0 \/* bulk *\/);\n@@ -382,14 +381,1 @@\n-  selector.select();\n-\n-  \/\/ Install relocation set\n-  _relocation_set.install(&selector);\n-\n-  \/\/ Setup forwarding table\n-  ZRelocationSetIterator rs_iter(&_relocation_set);\n-  for (ZForwarding* forwarding; rs_iter.next(&forwarding);) {\n-    _forwarding_table.insert(forwarding);\n-  }\n-\n-  \/\/ Update statistics\n-  ZStatRelocation::set_at_select_relocation_set(selector.stats());\n-  ZStatHeap::set_at_select_relocation_set(selector.stats());\n+  _selector.select();\n@@ -412,0 +398,16 @@\n+  \/\/ Install relocation set\n+  _relocation_set.install(&_selector);\n+\n+  \/\/ Setup forwarding table\n+  ZRelocationSetIterator rs_iter(&_relocation_set);\n+  for (ZForwarding* forwarding; rs_iter.next(&forwarding);) {\n+    _forwarding_table.insert(forwarding);\n+  }\n+\n+  \/\/ Update statistics\n+  ZStatRelocation::set_at_select_relocation_set(_selector.stats());\n+  ZStatHeap::set_at_select_relocation_set(_selector.stats());\n+\n+  \/\/ Reset relocation set selector\n+  _selector.reset();\n+\n@@ -436,0 +438,9 @@\n+oop ZHeap::pin_object(oop o) {\n+  _page_table.get(ZOop::to_address(o))->record_pin();\n+  return o;\n+}\n+\n+void ZHeap::unpin_object(oop o) {\n+  _page_table.get(ZOop::to_address(o))->record_unpin();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/z\/zRelocationSetSelector.hpp\"\n@@ -62,0 +63,1 @@\n+  ZRelocationSetSelector _selector;\n@@ -142,0 +144,4 @@\n+  \/\/ Pinning hooks\n+  oop pin_object(oop obj);\n+  void unpin_object(oop obj);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-    _node() {\n+    _node(),\n+    _critical_pins(0) {\n@@ -121,0 +122,14 @@\n+void ZPage::record_pin() {\n+  Atomic::add(&_critical_pins, (size_t)1);\n+}\n+\n+void ZPage::record_unpin() {\n+  \/\/ assert(pin_count() > 0, \"Region \" SIZE_FORMAT \" should have non-zero pins\", _seqnum);\n+  assert(pin_count() > 0, \"Region \" UINT32_FORMAT \" should have non-zero pins\", _seqnum);\n+  Atomic::sub(&_critical_pins, (size_t)1);\n+}\n+\n+size_t ZPage::pin_count() const {\n+  return Atomic::load(&_critical_pins);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  volatile size_t    _critical_pins;\n@@ -112,0 +113,4 @@\n+  void record_pin();\n+  void record_unpin();\n+  size_t pin_count() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  const size_t                   _nforwardings;\n+  size_t                         _nforwardings;\n@@ -82,4 +82,0 @@\n-  ~ZRelocationSetInstallTask() {\n-    assert(_allocator->is_full(), \"Should be full\");\n-  }\n-\n@@ -89,0 +85,4 @@\n+      if (page->pin_count() > 0) {\n+        _nforwardings--;\n+        continue;\n+      }\n@@ -95,0 +95,4 @@\n+      if (page->pin_count() > 0) {\n+        _nforwardings--;\n+        continue;\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,0 +56,6 @@\n+void ZRelocationSetSelectorGroup::reset() {\n+  _live_pages.clear_and_deallocate();\n+  _forwarding_entries = 0;\n+  _stats.reset();\n+}\n+\n@@ -185,0 +191,7 @@\n+void ZRelocationSetSelector::reset() {\n+  _small.reset();\n+  _medium.reset();\n+  _large.reset();\n+  _empty_pages.clear_and_deallocate();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  void reset();\n@@ -88,0 +89,2 @@\n+  void reset();\n+\n@@ -112,0 +115,2 @@\n+  void reset();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -149,0 +149,8 @@\n+inline void ZRelocationSetSelectorGroupStats::reset() {\n+  _npages = 0;\n+  _total = 0;\n+  _live = 0;\n+  _empty = 0;\n+  _relocate = 0;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}