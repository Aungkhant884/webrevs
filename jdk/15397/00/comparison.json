{"files":[{"patch":"@@ -891,1 +891,1 @@\n-        \/\/ where the previous element is not a link.\n+        \/\/ where the previous element is neither a link nor \"..\"\n@@ -893,0 +893,1 @@\n+        boolean parentIsDotDot = false;\n@@ -901,1 +902,1 @@\n-            \/\/ cannot eliminate \"..\" if previous element is a link\n+            \/\/ cannot eliminate \"..\" if previous element is a link or \"..\"\n@@ -912,1 +913,1 @@\n-                if (!attrs.isSymbolicLink()) {\n+                if (!attrs.isSymbolicLink() && !parentIsDotDot) {\n@@ -919,0 +920,3 @@\n+                parentIsDotDot = true;\n+            } else {\n+                parentIsDotDot = false;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,0 +193,1 @@\n+        WindowsPath absolute = null;\n@@ -195,1 +196,2 @@\n-            path = input.toAbsolutePath().toString();\n+            absolute = input.toAbsolutePath();\n+            path = absolute.toString();\n@@ -202,4 +204,63 @@\n-            try {\n-                path = GetFullPathName(path);\n-            } catch (WindowsException x) {\n-                x.rethrowAsIOException(input);\n+            \/\/ The Windows function GetFullPathName() does not access the\n+            \/\/ file system, hence is susceptible to removing symbolic links\n+            \/\/ which are followed by the special name \"..\" whether or not\n+            \/\/ links are being followed. Examine the path element-by-element\n+            \/\/ to determine whether this would occur, and if so use the\n+            \/\/ full path manually derived in the process.\n+            String fullpath = null;\n+            if (path.contains(\"..\")) {\n+                WindowsPath p = absolute.getRoot();\n+                WindowsPath res = p;\n+                boolean parentIsLink = false;\n+                boolean parentIsDots = false;\n+                boolean wouldCollapseLink = false;\n+\n+                for (int i = 0; i < absolute.getNameCount(); i++) {\n+                    WindowsPath element = absolute.getName(i);\n+                    String s = element.toString();\n+                    if (s.equals(\".\"))\n+                        continue;\n+\n+                    if (s.equals(\"..\")) {\n+                        res = res.getParent();\n+                        if (res == null)\n+                            res = absolute.getRoot();\n+\n+                        if (parentIsLink)\n+                            wouldCollapseLink = true;\n+\n+                        if (!parentIsLink && !parentIsDots) {\n+                            p = p.getParent();\n+                            if (p == null) {\n+                                p = absolute.getRoot();\n+                            }\n+                        } else {\n+                            p = p.resolve(element);\n+                            parentIsDots = true;\n+                            parentIsLink = false;\n+                        }\n+                        continue;\n+                    } else {\n+                        parentIsDots = false;\n+                    }\n+\n+                    res = res.resolve(element);\n+                    WindowsFileAttributes attrs = null;\n+                    try {\n+                        attrs = WindowsFileAttributes.get(res, false);\n+                    } catch (WindowsException x) {\n+                        x.rethrowAsIOException(res);\n+                    }\n+\n+                    if (attrs.isSymbolicLink()) {\n+                        parentIsLink = true;\n+                        res = resolveAllLinks(res);\n+                    } else {\n+                        parentIsLink = false;\n+                    }\n+\n+                    p = p.resolve(element);\n+                }\n+\n+                if (wouldCollapseLink)\n+                    fullpath = p.toString();\n@@ -207,0 +268,11 @@\n+\n+            \/\/ Use GetFullPathName() if it would not collapse links\n+            if (fullpath == null) {\n+                try {\n+                    fullpath = GetFullPathName(path);\n+                } catch (WindowsException x) {\n+                    x.rethrowAsIOException(input);\n+                }\n+            }\n+\n+            path = fullpath;\n@@ -218,1 +290,1 @@\n-            \/\/ Driver specifier\n+            \/\/ Drive specifier\n@@ -255,23 +327,34 @@\n-        \/\/ iterate through each component to get its actual name in the\n-        \/\/ directory\n-        int curr = start;\n-        while (curr < path.length()) {\n-            int next = path.indexOf('\\\\', curr);\n-            int end = (next == -1) ? path.length() : next;\n-            String search = sb.toString() + path.substring(curr, end);\n-            try {\n-                FirstFile fileData = FindFirstFile(WindowsPath.addPrefixIfNeeded(search));\n-                FindClose(fileData.handle());\n-\n-                \/\/ if a reparse point is encountered then we must return the\n-                \/\/ final path.\n-                if (resolveLinks &&\n-                    WindowsFileAttributes.isReparsePoint(fileData.attributes()))\n-                {\n-                    String result = getFinalPath(input);\n-                    if (result == null) {\n-                        \/\/ Fallback to slow path, usually because there is a sym\n-                        \/\/ link to a file system that doesn't support sym links.\n-                        WindowsPath resolved = resolveAllLinks(\n-                            WindowsPath.createFromNormalizedPath(fs, path));\n-                        result = getRealPath(resolved, false);\n+        \/\/ FindFirstFile() and getFinalPath() do not work if there are\n+        \/\/ any uncollapsed occurrences of \"..\" in the path\n+        if (!path.contains(\"..\")) {\n+            \/\/ iterate through each component to get its actual name in the\n+            \/\/ directory\n+            int curr = start;\n+            while (curr < path.length()) {\n+                int next = path.indexOf('\\\\', curr);\n+                int end = (next == -1) ? path.length() : next;\n+                String search = sb.toString() + path.substring(curr, end);\n+                try {\n+                    FirstFile fileData = FindFirstFile(WindowsPath.addPrefixIfNeeded(search));\n+                    FindClose(fileData.handle());\n+\n+                    \/\/ if a reparse point is encountered then we must return the\n+                    \/\/ final path.\n+                    if (resolveLinks &&\n+                        WindowsFileAttributes.isReparsePoint(fileData.attributes()))\n+                        {\n+                            String result = getFinalPath(input);\n+                            if (result == null) {\n+                                \/\/ Fallback to slow path, usually because there is a sym\n+                                \/\/ link to a file system that doesn't support sym links.\n+                                WindowsPath resolved = resolveAllLinks(\n+                                                                       WindowsPath.createFromNormalizedPath(fs, path));\n+                                result = getRealPath(resolved, false);\n+                            }\n+                            return result;\n+                        }\n+\n+                    \/\/ add the name to the result\n+                    sb.append(fileData.name());\n+                    if (next != -1) {\n+                        sb.append('\\\\');\n@@ -279,1 +362,2 @@\n-                    return result;\n+                } catch (WindowsException e) {\n+                    e.rethrowAsIOException(path);\n@@ -281,0 +365,2 @@\n+                curr = end + 1;\n+            }\n@@ -282,5 +368,10 @@\n-                \/\/ add the name to the result\n-                sb.append(fileData.name());\n-                if (next != -1) {\n-                    sb.append('\\\\');\n-                }\n+            return sb.toString();\n+        }\n+\n+        \/\/ path contains \"..\"\n+        \/\/ if resolving links then do so, otherwise we are done\n+        if (resolveLinks) {\n+            WindowsPath wp = WindowsPath.createFromNormalizedPath(fs, path);\n+            WindowsPath resolved = resolveAllLinks(wp);\n+            try {\n+                path = GetFullPathName(resolved.toString());\n@@ -290,1 +381,1 @@\n-            curr = end + 1;\n+            return getRealPath(resolved, false);\n@@ -292,2 +383,1 @@\n-\n-        return sb.toString();\n+        return path;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":129,"deletions":39,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 7029979 8295753\n+ * @bug 4313887 6838333 7029979 8295753 8306882\n@@ -154,0 +154,36 @@\n+        \/**\n+         * Test: toRealPath(NOFOLLOW_LINKS) should not collapse successive \"..\"\n+         *\/\n+        if (supportsLinks) {\n+            Path subPath = dir.resolve(Path.of(\"dir\", \"subdir\"));\n+            Path sub = Files.createDirectories(subPath);\n+            System.out.println(\"sub: \" + sub);\n+            Files.createSymbolicLink(link, sub);\n+            System.out.println(\"link: \" + link + \" -> \" + sub);\n+            Path p = Path.of(\"..\", \"..\", file.getFileName().toString());\n+            System.out.println(\"p: \" + p);\n+            Path path = link.resolve(p);\n+            System.out.println(\"path:      \" + path);\n+            System.out.println(\"no follow: \" + path.toRealPath(NOFOLLOW_LINKS));\n+            assertTrue(path.toRealPath(NOFOLLOW_LINKS).equals(path));\n+            Files.delete(link);\n+\n+            Path out = Files.createFile(dir.resolve(Path.of(\"out.txt\")));\n+            Path aaa = dir.resolve(Path.of(\"aaa\"));\n+            Files.createSymbolicLink(aaa, sub);\n+            System.out.println(\"aaa: \" + aaa + \" -> \" + sub);\n+            Path bbb = dir.resolve(Path.of(\"bbb\"));\n+            Files.createSymbolicLink(bbb, sub);\n+            System.out.println(\"bbb: \" + bbb + \" -> \" + sub);\n+            p = Path.of(\"aaa\", \"..\", \"..\", \"bbb\", \"..\", \"..\", \"out.txt\");\n+            path = dir.resolve(p);\n+            System.out.println(\"path:      \" + path);\n+            System.out.println(\"no follow: \" + path.toRealPath(NOFOLLOW_LINKS));\n+            assertTrue(path.toRealPath(NOFOLLOW_LINKS).equals(path));\n+            System.out.println(path.toRealPath());\n+            Files.delete(sub);\n+            Files.delete(out);\n+            Files.delete(aaa);\n+            Files.delete(bbb);\n+        }\n+\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Misc.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"}]}