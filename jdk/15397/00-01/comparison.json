{"files":[{"patch":"@@ -891,1 +891,7 @@\n-        \/\/ where the previous element is neither a link nor \"..\"\n+        \/\/ where the previous element is neither a link nor \"..\".\n+        \/\/ if there is a preceding \"..\", then it might have followed\n+        \/\/ a link or a link followed by a sequence of two or more \"..\".\n+        \/\/ if for example one has the path \"link\/..\/..\/file\",\n+        \/\/ then if a preceding \"..\" were eliminated, then the result\n+        \/\/ would be \"<root>\/link\/file\" instead of the correct\n+        \/\/ \"<root>\/link\/..\/..\/file\".\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,0 @@\n-        WindowsPath absolute = null;\n@@ -196,2 +195,1 @@\n-            absolute = input.toAbsolutePath();\n-            path = absolute.toString();\n+            path = input.toAbsolutePath().toString();\n@@ -204,72 +202,4 @@\n-            \/\/ The Windows function GetFullPathName() does not access the\n-            \/\/ file system, hence is susceptible to removing symbolic links\n-            \/\/ which are followed by the special name \"..\" whether or not\n-            \/\/ links are being followed. Examine the path element-by-element\n-            \/\/ to determine whether this would occur, and if so use the\n-            \/\/ full path manually derived in the process.\n-            String fullpath = null;\n-            if (path.contains(\"..\")) {\n-                WindowsPath p = absolute.getRoot();\n-                WindowsPath res = p;\n-                boolean parentIsLink = false;\n-                boolean parentIsDots = false;\n-                boolean wouldCollapseLink = false;\n-\n-                for (int i = 0; i < absolute.getNameCount(); i++) {\n-                    WindowsPath element = absolute.getName(i);\n-                    String s = element.toString();\n-                    if (s.equals(\".\"))\n-                        continue;\n-\n-                    if (s.equals(\"..\")) {\n-                        res = res.getParent();\n-                        if (res == null)\n-                            res = absolute.getRoot();\n-\n-                        if (parentIsLink)\n-                            wouldCollapseLink = true;\n-\n-                        if (!parentIsLink && !parentIsDots) {\n-                            p = p.getParent();\n-                            if (p == null) {\n-                                p = absolute.getRoot();\n-                            }\n-                        } else {\n-                            p = p.resolve(element);\n-                            parentIsDots = true;\n-                            parentIsLink = false;\n-                        }\n-                        continue;\n-                    } else {\n-                        parentIsDots = false;\n-                    }\n-\n-                    res = res.resolve(element);\n-                    WindowsFileAttributes attrs = null;\n-                    try {\n-                        attrs = WindowsFileAttributes.get(res, false);\n-                    } catch (WindowsException x) {\n-                        x.rethrowAsIOException(res);\n-                    }\n-\n-                    if (attrs.isSymbolicLink()) {\n-                        parentIsLink = true;\n-                        res = resolveAllLinks(res);\n-                    } else {\n-                        parentIsLink = false;\n-                    }\n-\n-                    p = p.resolve(element);\n-                }\n-\n-                if (wouldCollapseLink)\n-                    fullpath = p.toString();\n-            }\n-\n-            \/\/ Use GetFullPathName() if it would not collapse links\n-            if (fullpath == null) {\n-                try {\n-                    fullpath = GetFullPathName(path);\n-                } catch (WindowsException x) {\n-                    x.rethrowAsIOException(input);\n-                }\n+            try {\n+                path = GetFullPathName(path);\n+            } catch (WindowsException x) {\n+                x.rethrowAsIOException(input);\n@@ -277,2 +207,0 @@\n-\n-            path = fullpath;\n@@ -290,1 +218,1 @@\n-            \/\/ Drive specifier\n+            \/\/ Driver specifier\n@@ -327,34 +255,23 @@\n-        \/\/ FindFirstFile() and getFinalPath() do not work if there are\n-        \/\/ any uncollapsed occurrences of \"..\" in the path\n-        if (!path.contains(\"..\")) {\n-            \/\/ iterate through each component to get its actual name in the\n-            \/\/ directory\n-            int curr = start;\n-            while (curr < path.length()) {\n-                int next = path.indexOf('\\\\', curr);\n-                int end = (next == -1) ? path.length() : next;\n-                String search = sb.toString() + path.substring(curr, end);\n-                try {\n-                    FirstFile fileData = FindFirstFile(WindowsPath.addPrefixIfNeeded(search));\n-                    FindClose(fileData.handle());\n-\n-                    \/\/ if a reparse point is encountered then we must return the\n-                    \/\/ final path.\n-                    if (resolveLinks &&\n-                        WindowsFileAttributes.isReparsePoint(fileData.attributes()))\n-                        {\n-                            String result = getFinalPath(input);\n-                            if (result == null) {\n-                                \/\/ Fallback to slow path, usually because there is a sym\n-                                \/\/ link to a file system that doesn't support sym links.\n-                                WindowsPath resolved = resolveAllLinks(\n-                                                                       WindowsPath.createFromNormalizedPath(fs, path));\n-                                result = getRealPath(resolved, false);\n-                            }\n-                            return result;\n-                        }\n-\n-                    \/\/ add the name to the result\n-                    sb.append(fileData.name());\n-                    if (next != -1) {\n-                        sb.append('\\\\');\n+        \/\/ iterate through each component to get its actual name in the\n+        \/\/ directory\n+        int curr = start;\n+        while (curr < path.length()) {\n+            int next = path.indexOf('\\\\', curr);\n+            int end = (next == -1) ? path.length() : next;\n+            String search = sb.toString() + path.substring(curr, end);\n+            try {\n+                FirstFile fileData = FindFirstFile(WindowsPath.addPrefixIfNeeded(search));\n+                FindClose(fileData.handle());\n+\n+                \/\/ if a reparse point is encountered then we must return the\n+                \/\/ final path.\n+                if (resolveLinks &&\n+                    WindowsFileAttributes.isReparsePoint(fileData.attributes()))\n+                {\n+                    String result = getFinalPath(input);\n+                    if (result == null) {\n+                        \/\/ Fallback to slow path, usually because there is a sym\n+                        \/\/ link to a file system that doesn't support sym links.\n+                        WindowsPath resolved = resolveAllLinks(\n+                            WindowsPath.createFromNormalizedPath(fs, path));\n+                        result = getRealPath(resolved, false);\n@@ -362,2 +279,1 @@\n-                } catch (WindowsException e) {\n-                    e.rethrowAsIOException(path);\n+                    return result;\n@@ -365,5 +281,0 @@\n-                curr = end + 1;\n-            }\n-\n-            return sb.toString();\n-        }\n@@ -371,7 +282,5 @@\n-        \/\/ path contains \"..\"\n-        \/\/ if resolving links then do so, otherwise we are done\n-        if (resolveLinks) {\n-            WindowsPath wp = WindowsPath.createFromNormalizedPath(fs, path);\n-            WindowsPath resolved = resolveAllLinks(wp);\n-            try {\n-                path = GetFullPathName(resolved.toString());\n+                \/\/ add the name to the result\n+                sb.append(fileData.name());\n+                if (next != -1) {\n+                    sb.append('\\\\');\n+                }\n@@ -381,1 +290,1 @@\n-            return getRealPath(resolved, false);\n+            curr = end + 1;\n@@ -383,1 +292,2 @@\n-        return path;\n+\n+        return sb.toString();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":39,"deletions":129,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 7029979 8295753 8306882\n+ * @bug 4313887 6838333 7029979 8295753\n@@ -154,36 +154,0 @@\n-        \/**\n-         * Test: toRealPath(NOFOLLOW_LINKS) should not collapse successive \"..\"\n-         *\/\n-        if (supportsLinks) {\n-            Path subPath = dir.resolve(Path.of(\"dir\", \"subdir\"));\n-            Path sub = Files.createDirectories(subPath);\n-            System.out.println(\"sub: \" + sub);\n-            Files.createSymbolicLink(link, sub);\n-            System.out.println(\"link: \" + link + \" -> \" + sub);\n-            Path p = Path.of(\"..\", \"..\", file.getFileName().toString());\n-            System.out.println(\"p: \" + p);\n-            Path path = link.resolve(p);\n-            System.out.println(\"path:      \" + path);\n-            System.out.println(\"no follow: \" + path.toRealPath(NOFOLLOW_LINKS));\n-            assertTrue(path.toRealPath(NOFOLLOW_LINKS).equals(path));\n-            Files.delete(link);\n-\n-            Path out = Files.createFile(dir.resolve(Path.of(\"out.txt\")));\n-            Path aaa = dir.resolve(Path.of(\"aaa\"));\n-            Files.createSymbolicLink(aaa, sub);\n-            System.out.println(\"aaa: \" + aaa + \" -> \" + sub);\n-            Path bbb = dir.resolve(Path.of(\"bbb\"));\n-            Files.createSymbolicLink(bbb, sub);\n-            System.out.println(\"bbb: \" + bbb + \" -> \" + sub);\n-            p = Path.of(\"aaa\", \"..\", \"..\", \"bbb\", \"..\", \"..\", \"out.txt\");\n-            path = dir.resolve(p);\n-            System.out.println(\"path:      \" + path);\n-            System.out.println(\"no follow: \" + path.toRealPath(NOFOLLOW_LINKS));\n-            assertTrue(path.toRealPath(NOFOLLOW_LINKS).equals(path));\n-            System.out.println(path.toRealPath());\n-            Files.delete(sub);\n-            Files.delete(out);\n-            Files.delete(aaa);\n-            Files.delete(bbb);\n-        }\n-\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Misc.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"}]}