{"files":[{"patch":"@@ -114,0 +114,25 @@\n+\/\/                                                current_timestamp\n+\/\/                       GC events               \/  pause_time\n+\/\/                 \/     |     \\     \\          | \/  \/\n+\/\/ -------------[----]-[---]--[--]---[---]------|[--]-----> Time\n+\/\/              |         |                     |\n+\/\/              |         |                     |\n+\/\/              |<- limit |                     |\n+\/\/              |         |<- balance_timestamp |\n+\/\/              |         ^                     |\n+\/\/              |                               |\n+\/\/              |<--------  _time_slice  ------>|\n+\/\/\n+\/\/ The MMU constraint requires that we can spend up to `max_gc_time()` on GC\n+\/\/ pauses inside a window of `_time_slice` length. Therefore, we have a GC\n+\/\/ budget of `max_gc_time() - pause_time`, which is to be accounted for by past\n+\/\/ GC events.\n+\/\/\n+\/\/ Focusing on GC events that are inside [limit, current_timestamp], we iterate\n+\/\/ over them from the newest to the oldest (right-to-left in the diagram) and\n+\/\/ try to locate the timestamp annotated with ^, so that the accumulated GC\n+\/\/ time inside [balance_timestamp, current_timestamp] is equal to the budget.\n+\/\/ Next, return `balance_timestamp - limit`.\n+\/\/\n+\/\/ When there are no enough GC events, i.e. we have a surplus buget, a new GC\n+\/\/ pause can start right away, so return 0.\n@@ -115,0 +140,2 @@\n+  assert(pause_time > 0.0, \"precondition\");\n+\n@@ -116,2 +143,1 @@\n-  double adjusted_pause_time =\n-    (pause_time > max_gc_time()) ? max_gc_time() : pause_time;\n+  pause_time = MIN2(pause_time, max_gc_time());\n@@ -119,3 +145,1 @@\n-  \/\/ Earliest end time of a hypothetical pause starting now, taking pause_time.\n-  double earliest_end_time = current_timestamp + adjusted_pause_time;\n-  double gc_time_in_recent_time_slice = calculate_gc_time(earliest_end_time) + adjusted_pause_time;\n+  double gc_budget = max_gc_time() - pause_time;\n@@ -123,2 +147,9 @@\n-  \/\/ How much gc time is needed to pass within the MMU window to fit the given pause into the MMU.\n-  double gc_time_to_pass = gc_time_in_recent_time_slice - max_gc_time();\n+  double limit = current_timestamp + pause_time - _time_slice;\n+  \/\/ Iterate from newest to oldest.\n+  for (int i = 0; i < _no_entries; ++i) {\n+    int index = trim_index(_head_index + i);\n+    G1MMUTrackerElem *elem = &_array[index];\n+    \/\/ Outside the window.\n+    if (elem->end_time() <= limit) {\n+      break;\n+    }\n@@ -126,4 +157,8 @@\n-  \/\/ If that time to pass is zero or negative we could start the pause immediately.\n-  if (is_double_leq_0(gc_time_to_pass)) {\n-    return 0.0;\n-  }\n+    double duration = (elem->end_time() - MAX2(elem->start_time(), limit));\n+    \/\/ This duration would exceed (strictly greater than) the budget.\n+    if (duration > gc_budget) {\n+      \/\/ This timestamp captures the instant the budget is balanced (or used up).\n+      double balance_timestamp = elem->end_time() - gc_budget;\n+      assert(balance_timestamp >= limit, \"inv\");\n+      return balance_timestamp - limit;\n+    }\n@@ -131,5 +166,1 @@\n-  \/\/ Trivially, if the pause is of maximum pause time, the required delay is what the MMU dictates by\n-  \/\/ the time slice and maximum gc pause, counted from the end of the last pause.\n-  if (adjusted_pause_time == max_gc_time()) {\n-    G1MMUTrackerElem *elem = &_array[_head_index];\n-    return (elem->end_time() + (_time_slice - max_gc_time())) - current_timestamp;\n+    gc_budget -= duration;\n@@ -138,18 +169,2 @@\n-  \/\/ Now go through the recent pause time events,\n-  double limit = earliest_end_time - _time_slice;\n-  int index = _tail_index;\n-  while ( 1 ) {\n-    G1MMUTrackerElem *elem = &_array[index];\n-    if (elem->end_time() > limit) {\n-      if (elem->start_time() > limit) {\n-        gc_time_to_pass -= elem->duration();\n-      } else {\n-        gc_time_to_pass -= elem->end_time() - limit;\n-      }\n-      if (is_double_leq_0(gc_time_to_pass)) {\n-        return elem->end_time() + (_time_slice + gc_time_to_pass) - earliest_end_time;\n-      }\n-    }\n-    index = trim_index(index+1);\n-    guarantee(index != trim_index(_head_index + 1), \"should not go past head\");\n-  }\n+  \/\/ Not enough gc time spent inside the window, we have a budget surplus.\n+  return 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.cpp","additions":49,"deletions":34,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}