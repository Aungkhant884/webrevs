{"files":[{"patch":"@@ -114,0 +114,19 @@\n+\/\/                                          current_timestamp\n+\/\/                   GC events             \/  pause_time\n+\/\/                 \/     |     \\          | \/  \/\n+\/\/ -------------[----]-[---]--[--]--------|[--]-----> Time\n+\/\/              |         |                   |\n+\/\/              |         |                   |\n+\/\/              |<- limit |                   |\n+\/\/              |         |<- deficit         |\n+\/\/              |         ^                   |\n+\/\/              |                             |\n+\/\/              |<------- _time_slice   ----->|\n+\/\/\n+\/\/ Focusing on GC events that are inside [limit, current_timestamp], we iterate\n+\/\/ over them from the newest to the oldest (right-to-left in the diagram) and\n+\/\/ try to locate the timestamp annotated with ^, so that the accumulated GC\n+\/\/ time inside [deficit, current_timestamp], is equal to gc_budget. Next,\n+\/\/ return `deficit - limit`.\n+\/\/\n+\/\/ When there are no enough GC events, i.e. gc_budget has a surplus, return 0.\n@@ -115,3 +134,1 @@\n-  \/\/ If the pause is over the maximum, just assume that it's the maximum.\n-  double adjusted_pause_time =\n-    (pause_time > max_gc_time()) ? max_gc_time() : pause_time;\n+  assert(pause_time > 0.0, \"precondition\");\n@@ -119,3 +136,2 @@\n-  \/\/ Earliest end time of a hypothetical pause starting now, taking pause_time.\n-  double earliest_end_time = current_timestamp + adjusted_pause_time;\n-  double gc_time_in_recent_time_slice = calculate_gc_time(earliest_end_time) + adjusted_pause_time;\n+  \/\/ Clamp it by max\n+  pause_time = MIN2(pause_time, max_gc_time());\n@@ -123,2 +139,1 @@\n-  \/\/ How much gc time is needed to pass within the MMU window to fit the given pause into the MMU.\n-  double gc_time_to_pass = gc_time_in_recent_time_slice - max_gc_time();\n+  double gc_budget = max_gc_time() - pause_time;\n@@ -126,16 +141,4 @@\n-  \/\/ If that time to pass is zero or negative we could start the pause immediately.\n-  if (is_double_leq_0(gc_time_to_pass)) {\n-    return 0.0;\n-  }\n-\n-  \/\/ Trivially, if the pause is of maximum pause time, the required delay is what the MMU dictates by\n-  \/\/ the time slice and maximum gc pause, counted from the end of the last pause.\n-  if (adjusted_pause_time == max_gc_time()) {\n-    G1MMUTrackerElem *elem = &_array[_head_index];\n-    return (elem->end_time() + (_time_slice - max_gc_time())) - current_timestamp;\n-  }\n-\n-  \/\/ Now go through the recent pause time events,\n-  double limit = earliest_end_time - _time_slice;\n-  int index = _tail_index;\n-  while ( 1 ) {\n+  double limit = current_timestamp + pause_time - _time_slice;\n+  \/\/ Iterate from newest to oldest\n+  for (int i = 0; i < _no_entries; ++i) {\n+    int index = trim_index(_head_index + i);\n@@ -143,9 +146,12 @@\n-    if (elem->end_time() > limit) {\n-      if (elem->start_time() > limit) {\n-        gc_time_to_pass -= elem->duration();\n-      } else {\n-        gc_time_to_pass -= elem->end_time() - limit;\n-      }\n-      if (is_double_leq_0(gc_time_to_pass)) {\n-        return elem->end_time() + (_time_slice + gc_time_to_pass) - earliest_end_time;\n-      }\n+    \/\/ Outside the window\n+    if (elem->end_time() <= limit) {\n+      break;\n+    }\n+\n+    double duration = (elem->end_time() - MAX2(elem->start_time(), limit));\n+    \/\/ Would exceed the budget; strictly greater than\n+    if (duration > gc_budget) {\n+      \/\/ The timestamp where a budget deficit occurs.\n+      double deficit_timestamp = elem->end_time() - gc_budget;\n+      assert(deficit_timestamp >= limit, \"inv\");\n+      return deficit_timestamp - limit;\n@@ -153,2 +159,2 @@\n-    index = trim_index(index+1);\n-    guarantee(index != trim_index(_head_index + 1), \"should not go past head\");\n+\n+    gc_budget -= duration;\n@@ -156,0 +162,3 @@\n+\n+  \/\/ No enough gc time inside the window; a budget surplus\n+  return 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.cpp","additions":44,"deletions":35,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}