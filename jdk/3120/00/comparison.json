{"files":[{"patch":"@@ -33,1 +33,0 @@\n-#include \"classfile\/dictionary.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/dictionary.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classFileStream.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -36,0 +38,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -40,0 +43,2 @@\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n@@ -288,1 +293,1 @@\n-    if (entry->hash() == hash && entry->equals(class_name)) {\n+    if (entry->hash() == hash && entry->instance_klass()->name() == class_name) {\n@@ -323,2 +328,1 @@\n-                                       Handle protection_domain,\n-                                       TRAPS) {\n+                                       Handle protection_domain) {\n@@ -344,1 +348,1 @@\n-bool Dictionary::is_valid_protection_domain(unsigned int hash,\n+inline bool Dictionary::is_valid_protection_domain(unsigned int hash,\n@@ -352,0 +356,68 @@\n+void Dictionary::validate_protection_domain(unsigned int name_hash,\n+                                            InstanceKlass* klass,\n+                                            Handle class_loader,\n+                                            Handle protection_domain,\n+                                            TRAPS) {\n+\n+  \/\/ Now we have to call back to java to check if the initating class has access\n+  assert(class_loader() != NULL, \"Should not call this\");\n+  assert(protection_domain() != NULL, \"Should not call this\");\n+\n+  if (!java_lang_System::allow_security_manager() ||\n+      is_valid_protection_domain(name_hash, klass->name(), protection_domain)) {\n+    return;\n+  }\n+\n+  \/\/ We only have to call checkPackageAccess if there's a security manager installed.\n+  if (java_lang_System::has_security_manager()) {\n+\n+    \/\/ This handle and the class_loader handle passed in keeps this class from\n+    \/\/ being unloaded through several GC points.\n+    \/\/ The class_loader handle passed in is the initiating loader.\n+    Handle mirror(THREAD, klass->java_mirror());\n+\n+    InstanceKlass* system_loader = vmClasses::ClassLoader_klass();\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_special(&result,\n+                           class_loader,\n+                           system_loader,\n+                           vmSymbols::checkPackageAccess_name(),\n+                           vmSymbols::class_protectiondomain_signature(),\n+                           mirror,\n+                           protection_domain,\n+                           THREAD);\n+\n+    LogTarget(Debug, protectiondomain) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm(THREAD);\n+      \/\/ Print out trace information\n+      LogStream ls(lt);\n+      ls.print_cr(\"Checking package access\");\n+      ls.print(\"class loader: \");\n+      class_loader()->print_value_on(&ls);\n+      ls.print(\" protection domain: \");\n+      protection_domain()->print_value_on(&ls);\n+      ls.print(\" loading: \"); klass->print_value_on(&ls);\n+      if (HAS_PENDING_EXCEPTION) {\n+        ls.print_cr(\" DENIED !!!!!!!!!!!!!!!!!!!!!\");\n+      } else {\n+        ls.print_cr(\" granted\");\n+      }\n+    }\n+\n+    if (HAS_PENDING_EXCEPTION) return;\n+  }\n+\n+  \/\/ If no exception has been thrown, we have validated the protection domain\n+  \/\/ Insert the protection domain of the initiating class into the set.\n+  \/\/ We still have to add the protection_domain to the dictionary in case a new\n+  \/\/ security manager is installed later. Calls to load the same class with class loader\n+  \/\/ and protection domain are expected to succeed.\n+  {\n+    MutexLocker mu(THREAD, SystemDictionary_lock);\n+    int d_index = hash_to_index(name_hash);\n+    add_protection_domain(d_index, name_hash, klass,\n+                          protection_domain);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":76,"deletions":4,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -74,6 +74,5 @@\n-  bool is_valid_protection_domain(unsigned int hash,\n-                                  Symbol* name,\n-                                  Handle protection_domain);\n-  void add_protection_domain(int index, unsigned int hash,\n-                             InstanceKlass* klass,\n-                             Handle protection_domain, TRAPS);\n+  void validate_protection_domain(unsigned int name_hash,\n+                                  InstanceKlass* klass,\n+                                  Handle class_loader,\n+                                  Handle protection_domain,\n+                                  TRAPS);\n@@ -105,0 +104,7 @@\n+\n+  bool is_valid_protection_domain(unsigned int hash,\n+                                  Symbol* name,\n+                                  Handle protection_domain);\n+  void add_protection_domain(int index, unsigned int hash,\n+                             InstanceKlass* klass,\n+                             Handle protection_domain);\n@@ -159,5 +165,0 @@\n-  bool equals(const Symbol* class_name) const {\n-    InstanceKlass* klass = (InstanceKlass*)literal();\n-    return (klass->name() == class_name);\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/dictionary.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -458,67 +458,0 @@\n-void SystemDictionary::validate_protection_domain(InstanceKlass* klass,\n-                                                  Handle class_loader,\n-                                                  Handle protection_domain,\n-                                                  TRAPS) {\n-  \/\/ Now we have to call back to java to check if the initating class has access\n-  assert(class_loader() != NULL, \"Should not call this\");\n-  assert(protection_domain() != NULL, \"Should not call this\");\n-\n-  \/\/ We only have to call checkPackageAccess if there's a security manager installed.\n-  if (java_lang_System::has_security_manager()) {\n-\n-    \/\/ This handle and the class_loader handle passed in keeps this class from\n-    \/\/ being unloaded through several GC points.\n-    \/\/ The class_loader handle passed in is the initiating loader.\n-    Handle mirror(THREAD, klass->java_mirror());\n-\n-    InstanceKlass* system_loader = vmClasses::ClassLoader_klass();\n-    JavaValue result(T_VOID);\n-    JavaCalls::call_special(&result,\n-                           class_loader,\n-                           system_loader,\n-                           vmSymbols::checkPackageAccess_name(),\n-                           vmSymbols::class_protectiondomain_signature(),\n-                           mirror,\n-                           protection_domain,\n-                           THREAD);\n-\n-    LogTarget(Debug, protectiondomain) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm(THREAD);\n-      \/\/ Print out trace information\n-      LogStream ls(lt);\n-      ls.print_cr(\"Checking package access\");\n-      ls.print(\"class loader: \");\n-      class_loader()->print_value_on(&ls);\n-      ls.print(\" protection domain: \");\n-      protection_domain()->print_value_on(&ls);\n-      ls.print(\" loading: \"); klass->print_value_on(&ls);\n-      if (HAS_PENDING_EXCEPTION) {\n-        ls.print_cr(\" DENIED !!!!!!!!!!!!!!!!!!!!!\");\n-      } else {\n-        ls.print_cr(\" granted\");\n-      }\n-    }\n-\n-    if (HAS_PENDING_EXCEPTION) return;\n-  }\n-\n-  \/\/ If no exception has been thrown, we have validated the protection domain\n-  \/\/ Insert the protection domain of the initiating class into the set.\n-  \/\/ We still have to add the protection_domain to the dictionary in case a new\n-  \/\/ security manager is installed later. Calls to load the same class with class loader\n-  \/\/ and protection domain are expected to succeed.\n-  {\n-    ClassLoaderData* loader_data = class_loader_data(class_loader);\n-    Dictionary* dictionary = loader_data->dictionary();\n-\n-    Symbol*  kn = klass->name();\n-    unsigned int name_hash = dictionary->compute_hash(kn);\n-\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    int d_index = dictionary->hash_to_index(name_hash);\n-    dictionary->add_protection_domain(d_index, name_hash, klass,\n-                                      protection_domain, THREAD);\n-  }\n-}\n-\n@@ -879,4 +812,1 @@\n-  if (protection_domain() != NULL &&\n-     java_lang_System::allow_security_manager() &&\n-     !dictionary->is_valid_protection_domain(name_hash, name,\n-                                             protection_domain)) {\n+  if (protection_domain() != NULL) {\n@@ -884,1 +814,1 @@\n-    validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n+    dictionary->validate_protection_domain(name_hash, loaded_class, class_loader, protection_domain, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":72,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -318,4 +318,0 @@\n-  static void validate_protection_domain(InstanceKlass* klass,\n-                                         Handle class_loader,\n-                                         Handle protection_domain, TRAPS);\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"classfile\/dictionary.hpp\"\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}