{"files":[{"patch":"@@ -47,1 +47,1 @@\n-  our_watermark->link_watermark(their_watermark);\n+  our_watermark->push_linked_watermark(their_watermark);\n@@ -55,1 +55,1 @@\n-  our_watermark->link_watermark(NULL);\n+  our_watermark->pop_linked_watermark();\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-class StackWatermarkFramesIterator : public CHeapObj<mtInternal> {\n+class StackWatermarkFramesIterator : public CHeapObj<mtThread> {\n@@ -169,1 +169,1 @@\n-    _linked_watermark(NULL) {\n+    _linked_watermarks() {\n@@ -253,3 +253,9 @@\n-void StackWatermark::link_watermark(StackWatermark* watermark) {\n-  assert(watermark == NULL || _linked_watermark == NULL, \"nesting not supported\");\n-  _linked_watermark = watermark;\n+void StackWatermark::push_linked_watermark(StackWatermark* watermark) {\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  _linked_watermarks.push(watermark);\n+}\n+\n+void StackWatermark::pop_linked_watermark() {\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_linked_watermarks.length() > 0, \"Mismatched push and pop?\");\n+  _linked_watermarks.pop();\n@@ -291,0 +297,21 @@\n+void StackWatermark::process_linked_watermarks() {\n+  _lock.lock_without_safepoint_check();\n+  if (_linked_watermarks.is_empty()) {\n+    _lock.unlock();\n+    return;\n+  }\n+  ResourceMark rm;\n+  GrowableArray<StackWatermark*> watermarks(_linked_watermarks.length());\n+  for (StackWatermark* watermark : _linked_watermarks) {\n+    watermarks.push(watermark);\n+  }\n+  _lock.unlock();\n+\n+  \/\/ finish_processing must be called without the lock held, so we\n+  \/\/ copy the growable array to a temporary snapshot of the list, so\n+  \/\/ we can poke said watermarks without holding the lock\n+  for (StackWatermark* watermark : watermarks) {\n+    watermark->finish_processing(NULL \/* context *\/);\n+  }\n+}\n+\n@@ -293,4 +320,5 @@\n-  StackWatermark* linked_watermark = _linked_watermark;\n-  if (linked_watermark != NULL) {\n-    linked_watermark->finish_processing(NULL \/* context *\/);\n-  }\n+\n+  \/\/ If the thread waking up from a safepoint expected certain other\n+  \/\/ stack watermarks (potentially from different threads) are processed,\n+  \/\/ then we have to perform processing of said linked watermarks here.\n+  process_linked_watermarks();\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -86,1 +87,1 @@\n-class StackWatermark : public CHeapObj<mtInternal> {\n+class StackWatermark : public CHeapObj<mtThread> {\n@@ -96,1 +97,1 @@\n-  StackWatermark* _linked_watermark;\n+  GrowableArrayCHeap<StackWatermark*, mtThread> _linked_watermarks;\n@@ -119,0 +120,2 @@\n+  void process_linked_watermarks();\n+\n@@ -132,1 +135,2 @@\n-  void link_watermark(StackWatermark* watermark);\n+  void push_linked_watermark(StackWatermark* watermark);\n+  void pop_linked_watermark();\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -86,3 +86,0 @@\n-\n-vmTestbase\/nsk\/jdi\/ExceptionRequest\/addInstanceFilter\/instancefilter001\/TestDescription.java 8298059 generic-x64\n-vmTestbase\/nsk\/jdi\/ExceptionRequest\/addInstanceFilter\/instancefilter004\/TestDescription.java 8298059 generic-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}