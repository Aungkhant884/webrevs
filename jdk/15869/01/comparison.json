{"files":[{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n@@ -1388,1 +1389,0 @@\n-\n@@ -1454,0 +1454,305 @@\n+\/\/ Support class used to generate HPROF_GC_ROOT_JAVA_FRAME records.\n+\n+class JavaStackRefDumper : public StackObj {\n+private:\n+  AbstractDumpWriter* _writer;\n+  u4 _thread_serial_num;\n+  int _frame_num;\n+  AbstractDumpWriter* writer() const { return _writer; }\n+public:\n+  JavaStackRefDumper(AbstractDumpWriter* writer, u4 thread_serial_num)\n+      : _writer(writer), _thread_serial_num(thread_serial_num), _frame_num(-1) \/\/ default - empty stack\n+  {\n+  }\n+\n+  void set_frame_number(int n) { _frame_num = n; }\n+\n+  void dump_java_stack_refs(StackValueCollection* values);\n+};\n+\n+void JavaStackRefDumper::dump_java_stack_refs(StackValueCollection* values) {\n+  for (int index = 0; index < values->size(); index++) {\n+    if (values->at(index)->type() == T_OBJECT) {\n+      oop o = values->obj_at(index)();\n+      if (o != nullptr) {\n+        u4 size = 1 + sizeof(address) + 4 + 4;\n+        writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n+        writer()->write_objectID(o);\n+        writer()->write_u4(_thread_serial_num);\n+        writer()->write_u4((u4)_frame_num);\n+        writer()->end_sub_record();\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Class to collect, store and dump thread-related data:\n+\/\/ - HPROF_TRACE and HPROF_FRAME records;\n+\/\/ - HPROF_GC_ROOT_THREAD_OBJ\/HPROF_GC_ROOT_JAVA_FRAME\/HPROF_GC_ROOT_JNI_LOCAL subrecords.\n+class ThreadDumper : public CHeapObj<mtInternal> {\n+public:\n+  enum class ThreadType {Platform, MountedVirtual, UnmountedVirtual};\n+\n+private:\n+  ThreadType _thread_type;\n+  JavaThread* _java_thread;\n+  oop _thread_oop;\n+\n+  GrowableArray<StackFrameInfo*>* _frames;\n+  \/\/ non-null if the thread is OOM thread\n+  Method* _oome_constructor;\n+  int _thread_serial_num;\n+  int _start_frame_serial_num;\n+\n+  vframe* get_top_frame() const;\n+\n+public:\n+  static bool should_dump_pthread(JavaThread* thread) {\n+    return thread->threadObj() != nullptr && !thread->is_exiting() && !thread->is_hidden_from_external_view();\n+  }\n+\n+  static bool should_dump_vthread(oop vt) {\n+    return java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::NEW\n+        && java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::TERMINATED;\n+  }\n+\n+  ThreadDumper(ThreadType thread_type, JavaThread* java_thread, oop thread_oop);\n+\n+  \/\/ affects frame_count\n+  void add_oom_frame(Method* oome_constructor) {\n+    assert(_start_frame_serial_num == 0, \"add_oom_frame cannot be called after init_serial_nums\");\n+    _oome_constructor = oome_constructor;\n+  }\n+\n+  void init_serial_nums(volatile int* thread_counter, volatile int* frame_counter) {\n+    assert(_start_frame_serial_num == 0, \"already initialized\");\n+    _thread_serial_num = Atomic::fetch_then_add(thread_counter, 1);\n+    _start_frame_serial_num = Atomic::fetch_then_add(frame_counter, frame_count());\n+  }\n+\n+  bool oom_thread() const {\n+    return _oome_constructor != nullptr;\n+  }\n+\n+  int frame_count() const {\n+    return _frames->length() + (oom_thread() ? 1 : 0);\n+  }\n+\n+  u4 thread_serial_num() const {\n+    return (u4)_thread_serial_num;\n+  }\n+\n+  u4 stack_trace_serial_num() const {\n+    return (u4)(_thread_serial_num + STACK_TRACE_ID);\n+  }\n+\n+  \/\/ writes HPROF_TRACE and HPROF_FRAME records\n+  \/\/ returns number of dumped frames\n+  void dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map);\n+\n+  \/\/ writes HPROF_GC_ROOT_THREAD_OBJ subrecord\n+  void dump_thread_obj(AbstractDumpWriter* writer);\n+\n+  \/\/ Walk the stack of the thread.\n+  \/\/ Dumps a HPROF_GC_ROOT_JAVA_FRAME subrecord for each local\n+  \/\/ Dumps a HPROF_GC_ROOT_JNI_LOCAL subrecord for each JNI local\n+  \/\/ Returns the number of Java frames in this thread stack\n+  void dump_stack_refs(AbstractDumpWriter* writer);\n+\n+};\n+\n+ThreadDumper::ThreadDumper(ThreadType thread_type, JavaThread* java_thread, oop thread_oop)\n+    : _thread_type(thread_type), _java_thread(java_thread), _thread_oop(thread_oop),\n+      _oome_constructor(nullptr),\n+      _thread_serial_num(0), _start_frame_serial_num(0)\n+{\n+  \/\/ sanity checks\n+  if (_thread_type == ThreadType::UnmountedVirtual) {\n+    assert(_java_thread == nullptr, \"sanity\");\n+    assert(_thread_oop != nullptr, \"sanity\");\n+  } else {\n+    assert(_java_thread != nullptr, \"sanity\");\n+    assert(_thread_oop != nullptr, \"sanity\");\n+  }\n+\n+  _frames = new (mtServiceability) GrowableArray<StackFrameInfo*>(10, mtServiceability);\n+  bool stopAtVthreadEntry = _thread_type == ThreadType::MountedVirtual;\n+\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  for (vframe* vf = get_top_frame(); vf != nullptr; vf = vf->sender()) {\n+    if (stopAtVthreadEntry && vf->is_vthread_entry()) {\n+      break;\n+    }\n+    if (vf->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(vf);\n+      _frames->append(new StackFrameInfo(jvf, false));\n+    } else {\n+      \/\/ ignore non-Java frames\n+    }\n+  }\n+}\n+\n+void ThreadDumper::dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_nums are not initialized\");\n+\n+  \/\/ write HPROF_FRAME records for this thread's stack trace\n+  int depth = _frames->length();\n+  int frame_serial_num = _start_frame_serial_num;\n+\n+  if (oom_thread()) {\n+    \/\/ OOM thread\n+    \/\/ write fake frame that makes it look like the thread, which caused OOME,\n+    \/\/ is in the OutOfMemoryError zero-parameter constructor\n+    int oome_serial_num = klass_map->find(_oome_constructor->method_holder());\n+    \/\/ the class serial number starts from 1\n+    assert(oome_serial_num > 0, \"OutOfMemoryError class not found\");\n+    DumperSupport::dump_stack_frame(writer, ++frame_serial_num, oome_serial_num, _oome_constructor, 0);\n+    depth++;\n+  }\n+\n+  for (int j = 0; j < _frames->length(); j++) {\n+    StackFrameInfo* frame = _frames->at(j);\n+    Method* m = frame->method();\n+    int class_serial_num = klass_map->find(m->method_holder());\n+    \/\/ the class serial number starts from 1\n+    assert(class_serial_num > 0, \"class not found\");\n+    DumperSupport::dump_stack_frame(writer, ++frame_serial_num, class_serial_num, m, frame->bci());\n+  }\n+\n+  \/\/ write HPROF_TRACE record for the thread\n+  DumperSupport::write_header(writer, HPROF_TRACE, checked_cast<u4>(3 * sizeof(u4) + depth * oopSize));\n+  writer->write_u4(stack_trace_serial_num());   \/\/ stack trace serial number\n+  writer->write_u4(thread_serial_num());        \/\/ thread serial number\n+  writer->write_u4((u4)depth);                  \/\/ frame count (including oom frame)\n+  for (int j = 1; j <= depth; j++) {\n+    writer->write_id(_start_frame_serial_num + j);\n+  }\n+}\n+\n+void ThreadDumper::dump_thread_obj(AbstractDumpWriter * writer) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_num is not initialized\");\n+\n+  u4 size = 1 + sizeof(address) + 4 + 4;\n+  writer->start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);\n+  writer->write_objectID(_thread_oop);\n+  writer->write_u4(thread_serial_num());      \/\/ thread serial number\n+  writer->write_u4(stack_trace_serial_num()); \/\/ stack trace serial number\n+  writer->end_sub_record();\n+}\n+\n+void ThreadDumper::dump_stack_refs(AbstractDumpWriter * writer) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_num is not initialized\");\n+\n+  JNILocalsDumper blk(writer, thread_serial_num());\n+  if (_thread_type == ThreadType::Platform) {\n+    if (!_java_thread->has_last_Java_frame()) {\n+      \/\/ no last java frame but there may be JNI locals\n+      _java_thread->active_handles()->oops_do(&blk);\n+      return;\n+    }\n+  }\n+\n+  JavaStackRefDumper java_ref_dumper(writer, thread_serial_num());\n+\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  bool stopAtVthreadEntry = _thread_type == ThreadType::MountedVirtual;\n+  frame* last_entry_frame = nullptr;\n+  bool is_top_frame = true;\n+  int depth = 0;\n+  if (oom_thread()) {\n+    depth++;\n+  }\n+\n+  for (vframe* vf = get_top_frame(); vf != nullptr; vf = vf->sender()) {\n+    if (stopAtVthreadEntry && vf->is_vthread_entry()) {\n+      break;\n+    }\n+\n+    if (vf->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(vf);\n+      if (!(jvf->method()->is_native())) {\n+        java_ref_dumper.set_frame_number(depth);\n+        java_ref_dumper.dump_java_stack_refs(jvf->locals());\n+        java_ref_dumper.dump_java_stack_refs(jvf->expressions());\n+      } else {\n+        \/\/ native frame\n+        blk.set_frame_number(depth);\n+        if (is_top_frame) {\n+          \/\/ JNI locals for the top frame.\n+          assert(_java_thread != nullptr, \"impossible for unmounted vthread\");\n+          _java_thread->active_handles()->oops_do(&blk);\n+        } else {\n+          if (last_entry_frame != nullptr) {\n+            \/\/ JNI locals for the entry frame\n+            assert(last_entry_frame->is_entry_frame(), \"checking\");\n+            last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(&blk);\n+          }\n+        }\n+      }\n+      last_entry_frame = nullptr;\n+      \/\/ increment only for Java frames\n+      depth++;\n+    } else {\n+      \/\/ externalVFrame - for an entry frame then we report the JNI locals\n+      \/\/ when we find the corresponding javaVFrame\n+      frame* fr = vf->frame_pointer();\n+      assert(fr != nullptr, \"sanity check\");\n+      if (fr->is_entry_frame()) {\n+        last_entry_frame = fr;\n+      }\n+    }\n+  is_top_frame = false;\n+  }\n+  assert(depth == frame_count(), \"total number of Java frames not matched\");\n+}\n+\n+vframe* ThreadDumper::get_top_frame() const {\n+  if (_thread_type == ThreadType::UnmountedVirtual) {\n+    ContinuationWrapper cont(java_lang_VirtualThread::continuation(_thread_oop));\n+    if (cont.is_empty()) {\n+      return nullptr;\n+    }\n+    assert(!cont.is_mounted(), \"sanity check\");\n+    stackChunkOop chunk = cont.last_nonempty_chunk();\n+    if (chunk == nullptr || chunk->is_empty()) {\n+      return nullptr;\n+    }\n+\n+    RegisterMap reg_map(cont.continuation(), RegisterMap::UpdateMap::include);\n+    frame fr = chunk->top_frame(&reg_map);\n+    vframe* vf = vframe::new_vframe(&fr, &reg_map, nullptr); \/\/ don't need JavaThread\n+    return vf;\n+  }\n+\n+  RegisterMap reg_map(_java_thread,\n+      RegisterMap::UpdateMap::include,\n+      RegisterMap::ProcessFrames::include,\n+      RegisterMap::WalkContinuation::skip);\n+  switch (_thread_type) {\n+  case ThreadType::Platform:\n+    if (!_java_thread->has_last_Java_frame()) {\n+      return nullptr;\n+    }\n+    return _java_thread->is_vthread_mounted()\n+        ? _java_thread->carrier_last_java_vframe(&reg_map)\n+        : _java_thread->platform_thread_last_java_vframe(&reg_map);\n+\n+  case ThreadType::MountedVirtual:\n+    return _java_thread->last_java_vframe(&reg_map);\n+\n+  default: \/\/ make compilers happy\n+      break;\n+  }\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+\n@@ -1686,2 +1991,6 @@\n-  ThreadStackTrace**      _stack_traces;\n-  int                     _num_threads;\n+\n+  ThreadDumper**          _thread_dumpers; \/\/ platform, carrier and mounted virtual threads\n+  int                     _thread_dumpers_count;\n+  volatile int            _thread_serial_num;\n+  volatile int            _frame_serial_num;\n+\n@@ -1724,3 +2033,2 @@\n-  \/\/ HPROF_GC_ROOT_THREAD_OBJ records\n-  int do_thread(JavaThread* thread, u4 thread_serial_num);\n-  void do_threads();\n+  \/\/ HPROF_GC_ROOT_THREAD_OBJ records for platform and mounted virtual threads\n+  void dump_platform_threads();\n@@ -1732,2 +2040,6 @@\n-  \/\/ HPROF_TRACE and HPROF_FRAME records\n-  void dump_stack_traces();\n+  bool is_oom_thread(JavaThread* thread) const {\n+    return thread == _oome_thread && _oome_constructor != nullptr;\n+  }\n+\n+  \/\/ HPROF_TRACE and HPROF_FRAME records for platform and mounted virtual threads\n+  void dump_platform_stack_traces();\n@@ -1745,2 +2057,6 @@\n-    _stack_traces = nullptr;\n-    _num_threads = 0;\n+\n+    _thread_dumpers = nullptr;\n+    _thread_dumpers_count = 0;\n+    _thread_serial_num = 1;\n+    _frame_serial_num = 1;\n+\n@@ -1766,3 +2082,3 @@\n-    if (_stack_traces != nullptr) {\n-      for (int i=0; i < _num_threads; i++) {\n-        delete _stack_traces[i];\n+    if (_thread_dumpers != nullptr) {\n+      for (int i = 0; i < _thread_dumpers_count; i++) {\n+        delete _thread_dumpers[i];\n@@ -1770,1 +2086,1 @@\n-      FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);\n+      FREE_C_HEAP_ARRAY(ThreadDumper*, _thread_dumpers);\n@@ -1772,0 +2088,1 @@\n+\n@@ -1838,94 +2155,6 @@\n-\/\/ Walk the stack of the given thread.\n-\/\/ Dumps a HPROF_GC_ROOT_JAVA_FRAME record for each local\n-\/\/ Dumps a HPROF_GC_ROOT_JNI_LOCAL record for each JNI local\n-\/\/\n-\/\/ It returns the number of Java frames in this thread stack\n-int VM_HeapDumper::do_thread(JavaThread* java_thread, u4 thread_serial_num) {\n-  JNILocalsDumper blk(writer(), thread_serial_num);\n-\n-  oop threadObj = java_thread->threadObj();\n-  assert(threadObj != nullptr, \"sanity check\");\n-\n-  int stack_depth = 0;\n-  if (java_thread->has_last_Java_frame()) {\n-\n-    \/\/ vframes are resource allocated\n-    Thread* current_thread = Thread::current();\n-    ResourceMark rm(current_thread);\n-    HandleMark hm(current_thread);\n-\n-    RegisterMap reg_map(java_thread,\n-                        RegisterMap::UpdateMap::include,\n-                        RegisterMap::ProcessFrames::include,\n-                        RegisterMap::WalkContinuation::skip);\n-    frame f = java_thread->last_frame();\n-    vframe* vf = vframe::new_vframe(&f, &reg_map, java_thread);\n-    frame* last_entry_frame = nullptr;\n-    int extra_frames = 0;\n-\n-    if (java_thread == _oome_thread && _oome_constructor != nullptr) {\n-      extra_frames++;\n-    }\n-    while (vf != nullptr) {\n-      blk.set_frame_number(stack_depth);\n-      if (vf->is_java_frame()) {\n-\n-        \/\/ java frame (interpreted, compiled, ...)\n-        javaVFrame *jvf = javaVFrame::cast(vf);\n-        if (!(jvf->method()->is_native())) {\n-          StackValueCollection* locals = jvf->locals();\n-          for (int slot=0; slot<locals->size(); slot++) {\n-            if (locals->at(slot)->type() == T_OBJECT) {\n-              oop o = locals->obj_at(slot)();\n-\n-              if (o != nullptr) {\n-                u4 size = 1 + sizeof(address) + 4 + 4;\n-                writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n-                writer()->write_objectID(o);\n-                writer()->write_u4(thread_serial_num);\n-                writer()->write_u4((u4) (stack_depth + extra_frames));\n-                writer()->end_sub_record();\n-              }\n-            }\n-          }\n-          StackValueCollection *exprs = jvf->expressions();\n-          for(int index = 0; index < exprs->size(); index++) {\n-            if (exprs->at(index)->type() == T_OBJECT) {\n-               oop o = exprs->obj_at(index)();\n-               if (o != nullptr) {\n-                 u4 size = 1 + sizeof(address) + 4 + 4;\n-                 writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n-                 writer()->write_objectID(o);\n-                 writer()->write_u4(thread_serial_num);\n-                 writer()->write_u4((u4) (stack_depth + extra_frames));\n-                 writer()->end_sub_record();\n-               }\n-             }\n-          }\n-        } else {\n-          \/\/ native frame\n-          if (stack_depth == 0) {\n-            \/\/ JNI locals for the top frame.\n-            java_thread->active_handles()->oops_do(&blk);\n-          } else {\n-            if (last_entry_frame != nullptr) {\n-              \/\/ JNI locals for the entry frame\n-              assert(last_entry_frame->is_entry_frame(), \"checking\");\n-              last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(&blk);\n-            }\n-          }\n-        }\n-        \/\/ increment only for Java frames\n-        stack_depth++;\n-        last_entry_frame = nullptr;\n-\n-      } else {\n-        \/\/ externalVFrame - if it's an entry frame then report any JNI locals\n-        \/\/ as roots when we find the corresponding native javaVFrame\n-        frame* fr = vf->frame_pointer();\n-        assert(fr != nullptr, \"sanity check\");\n-        if (fr->is_entry_frame()) {\n-          last_entry_frame = fr;\n-        }\n-      }\n-      vf = vf->sender();\n+\/\/ Write a HPROF_GC_ROOT_THREAD_OBJ record for platform\/carrier and mounted virtual threads.\n+\/\/ Then walk the stack so that locals and JNI locals are dumped.\n+void VM_HeapDumper::dump_platform_threads() {\n+    for (int i = 0; i < _thread_dumpers_count; i++) {\n+        _thread_dumpers[i]->dump_thread_obj(writer());\n+        _thread_dumpers[i]->dump_stack_refs(writer());\n@@ -1933,26 +2162,0 @@\n-  } else {\n-    \/\/ no last java frame but there may be JNI locals\n-    java_thread->active_handles()->oops_do(&blk);\n-  }\n-  return stack_depth;\n-}\n-\n-\n-\/\/ write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk\n-\/\/ the stack so that locals and JNI locals are dumped.\n-void VM_HeapDumper::do_threads() {\n-  for (int i=0; i < _num_threads; i++) {\n-    JavaThread* thread = _stack_traces[i]->thread();\n-    oop threadObj = thread->threadObj();\n-    u4 thread_serial_num = i+1;\n-    u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;\n-    u4 size = 1 + sizeof(address) + 4 + 4;\n-    writer()->start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);\n-    writer()->write_objectID(threadObj);\n-    writer()->write_u4(thread_serial_num);  \/\/ thread number\n-    writer()->write_u4(stack_serial_num);   \/\/ stack trace serial number\n-    writer()->end_sub_record();\n-    int num_frames = do_thread(thread, thread_serial_num);\n-    assert(num_frames == _stack_traces[i]->get_stack_depth(),\n-           \"total number of Java frames not matched\");\n-  }\n@@ -2101,1 +2304,3 @@\n-    dump_stack_traces();\n+    dump_platform_stack_traces();\n+\n+    \/\/ HPROF_HEAP_DUMP\/HPROF_HEAP_DUMP_SEGMENT starts here\n@@ -2110,1 +2315,1 @@\n-    do_threads();\n+    dump_platform_threads();\n@@ -2164,1 +2369,1 @@\n-void VM_HeapDumper::dump_stack_traces() {\n+void VM_HeapDumper::dump_platform_stack_traces() {\n@@ -2166,2 +2371,2 @@\n-  DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));\n-  writer()->write_u4((u4) STACK_TRACE_ID);\n+  DumperSupport::write_header(writer(), HPROF_TRACE, 3 * sizeof(u4));\n+  writer()->write_u4((u4)STACK_TRACE_ID);\n@@ -2171,27 +2376,10 @@\n-  _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);\n-  int frame_serial_num = 0;\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n-    oop threadObj = thread->threadObj();\n-    if (threadObj != nullptr && !thread->is_exiting() && !thread->is_hidden_from_external_view()) {\n-      \/\/ dump thread stack trace\n-      Thread* current_thread = Thread::current();\n-      ResourceMark rm(current_thread);\n-      HandleMark hm(current_thread);\n-\n-      ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);\n-      stack_trace->dump_stack_at_safepoint(-1, \/* ObjectMonitorsHashtable is not needed here *\/ nullptr, true);\n-      _stack_traces[_num_threads++] = stack_trace;\n-\n-      \/\/ write HPROF_FRAME records for this thread's stack trace\n-      int depth = stack_trace->get_stack_depth();\n-      int thread_frame_start = frame_serial_num;\n-      int extra_frames = 0;\n-      \/\/ write fake frame that makes it look like the thread, which caused OOME,\n-      \/\/ is in the OutOfMemoryError zero-parameter constructor\n-      if (thread == _oome_thread && _oome_constructor != nullptr) {\n-        int oome_serial_num = _klass_map->find(_oome_constructor->method_holder());\n-        \/\/ the class serial number starts from 1\n-        assert(oome_serial_num > 0, \"OutOfMemoryError class not found\");\n-        DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,\n-                                        _oome_constructor, 0);\n-        extra_frames++;\n+  \/\/ max number if every platform thread is carrier with mounted virtual thread\n+  _thread_dumpers = NEW_C_HEAP_ARRAY(ThreadDumper*, Threads::number_of_threads() * 2, mtInternal);\n+\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread * thread = jtiwh.next(); ) {\n+    if (ThreadDumper::should_dump_pthread(thread)) {\n+      bool add_oom_frame = is_oom_thread(thread);\n+\n+      oop mounted_vt = thread->is_vthread_mounted() ? thread->vthread() : nullptr;\n+      if (mounted_vt != nullptr && !ThreadDumper::should_dump_vthread(mounted_vt)) {\n+        mounted_vt = nullptr;\n@@ -2199,7 +2387,12 @@\n-      for (int j=0; j < depth; j++) {\n-        StackFrameInfo* frame = stack_trace->stack_frame_at(j);\n-        Method* m = frame->method();\n-        int class_serial_num = _klass_map->find(m->method_holder());\n-        \/\/ the class serial number starts from 1\n-        assert(class_serial_num > 0, \"class not found\");\n-        DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame->bci());\n+\n+      \/\/ mounted vthread (if any)\n+      if (mounted_vt != nullptr) {\n+        ThreadDumper* thread_dumper = new ThreadDumper(ThreadDumper::ThreadType::MountedVirtual, thread, mounted_vt);\n+        _thread_dumpers[_thread_dumpers_count++] = thread_dumper;\n+        if (add_oom_frame) {\n+          thread_dumper->add_oom_frame(_oome_constructor);\n+          \/\/ we add oom frame to the VT stack, don't add it to the carrier thread stack\n+          add_oom_frame = false;\n+        }\n+        thread_dumper->init_serial_nums(&_thread_serial_num, &_frame_serial_num);\n+        thread_dumper->dump_stack_traces(writer(), _klass_map);\n@@ -2207,10 +2400,6 @@\n-      depth += extra_frames;\n-\n-      \/\/ write HPROF_TRACE record for one thread\n-      DumperSupport::write_header(writer(), HPROF_TRACE, checked_cast<u4>(3*sizeof(u4) + depth*oopSize));\n-      int stack_serial_num = _num_threads + STACK_TRACE_ID;\n-      writer()->write_u4(stack_serial_num);      \/\/ stack trace serial number\n-      writer()->write_u4((u4) _num_threads);     \/\/ thread serial number\n-      writer()->write_u4(depth);                 \/\/ frame count\n-      for (int j=1; j <= depth; j++) {\n-        writer()->write_id(thread_frame_start + j);\n+\n+      \/\/ platform or carrier thread\n+      ThreadDumper* thread_dumper = new ThreadDumper(ThreadDumper::ThreadType::Platform, thread, thread->threadObj());\n+      _thread_dumpers[_thread_dumpers_count++] = thread_dumper;\n+      if (add_oom_frame) {\n+        thread_dumper->add_oom_frame(_oome_constructor);\n@@ -2218,0 +2407,2 @@\n+      thread_dumper->init_serial_nums(&_thread_serial_num, &_frame_serial_num);\n+      thread_dumper->dump_stack_traces(writer(), _klass_map);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":374,"deletions":183,"binary":false,"changes":557,"status":"modified"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.lang.ref.Reference;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.lib.hprof.model.JavaClass;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.Root;\n+import jdk.test.lib.hprof.model.Snapshot;\n+import jdk.test.lib.hprof.model.StackFrame;\n+import jdk.test.lib.hprof.model.StackTrace;\n+import jdk.test.lib.hprof.model.ThreadObject;\n+import jdk.test.lib.hprof.parser.Reader;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @run main\/othervm\n+ *      -Djdk.virtualThreadScheduler.parallelism=1\n+ *      VThreadInHeapDump\n+ *\/\n+\n+class VThreadInHeapDumpTarg extends LingeredApp {\n+\n+    public static class VThreadUnmountedReferenced {\n+    }\n+    public static class VThreadMountedReferenced {\n+    }\n+    public static class PThreadReferenced {\n+    }\n+\n+    public class ThreadBase {\n+        private volatile boolean threadReady = false;\n+\n+        protected void ready() {\n+            threadReady = true;\n+        }\n+\n+        public void waitReady() {\n+            while (!threadReady) {\n+                try {\n+                    Thread.sleep(10);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+        }\n+    }\n+\n+    public class VthreadUnmounted extends ThreadBase implements Runnable {\n+        public void run() {\n+            Object referenced = new VThreadUnmountedReferenced();\n+            ready();\n+            \/\/ The thread will be unmounted in awaitToStop().\n+            awaitToStop();\n+            Reference.reachabilityFence(referenced);\n+        }\n+    }\n+\n+    public class VthreadMounted extends ThreadBase implements Runnable {\n+        int dummy = -1;\n+\n+        public void run() {\n+            Object referenced = new VThreadMountedReferenced();\n+            ready();\n+            \/\/ Don't give a chance for the thread to unmount.\n+            while (!timeToStop) {\n+                if (++dummy == 10000) {\n+                    dummy = 0;\n+                }\n+            }\n+            Reference.reachabilityFence(referenced);\n+        }\n+    }\n+\n+    public class Pthread extends ThreadBase implements Runnable {\n+        public void run() {\n+            Object referenced = new PThreadReferenced();\n+            ready();\n+            awaitToStop();\n+            Reference.reachabilityFence(referenced);\n+        }\n+    }\n+\n+    CountDownLatch timeToStopLatch = new CountDownLatch(1);\n+    volatile boolean timeToStop = false;\n+\n+    void awaitToStop() {\n+        try {\n+            timeToStopLatch.await();\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void runTest(String[] args) {\n+        try {\n+            \/\/ Unmounted virtual thread.\n+            VthreadUnmounted vthreadUnmounted = new VthreadUnmounted();\n+            Thread.ofVirtual().start(vthreadUnmounted);\n+            vthreadUnmounted.waitReady();\n+\n+            \/\/ Mounted virtual thread.\n+            VthreadMounted vthreadMounted = new VthreadMounted();\n+            Thread.ofVirtual().start(vthreadMounted);\n+            vthreadMounted.waitReady();\n+\n+            \/\/ Platform thread.\n+            Pthread pthread = new Pthread();\n+            Thread.ofPlatform().start(pthread);\n+            pthread.waitReady();\n+\n+            \/\/ We are ready.\n+            LingeredApp.main(args);\n+\n+        } finally {\n+            \/\/ Signal all threads to finish.\n+            timeToStop = true;\n+            timeToStopLatch.countDown();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        VThreadInHeapDumpTarg test = new VThreadInHeapDumpTarg();\n+        test.runTest(args);\n+    }\n+\n+}\n+\n+\n+public class VThreadInHeapDump {\n+\n+    public static void main(String[] args) throws Exception {\n+        File dumpFile = new File(\"Myheapdump.hprof\");\n+        createDump(dumpFile);\n+        verifyDump(dumpFile);\n+    }\n+\n+    private static void createDump(File dumpFile) throws Exception {\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new VThreadInHeapDumpTarg();\n+\n+            LingeredApp.startApp(theApp, \"-Djdk.virtualThreadScheduler.parallelism=1\");\n+\n+            \/\/jcmd <pid> GC.heap_dump <file_path>\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                    .createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(theApp.getPid()))\n+                    .addToolArg(\"GC.heap_dump\")\n+                    .addToolArg(dumpFile.getAbsolutePath());\n+            Process p = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(launcher.getCommand()));\n+            \/\/ If something goes wrong with heap dumping most likely we'll get crash of the target VM.\n+            while (!p.waitFor(5, TimeUnit.SECONDS)) {\n+                if (!theApp.getProcess().isAlive()) {\n+                    log(\"ERROR: target VM died, killing jcmd...\");\n+                    p.destroyForcibly();\n+                    throw new Exception(\"Target VM died\");\n+                }\n+            }\n+\n+            if (p.exitValue() != 0) {\n+                throw new Exception(\"Jcmd exited with code \" + p.exitValue());\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+    }\n+\n+    private static void verifyDump(File dumpFile) throws Exception {\n+        Asserts.assertTrue(dumpFile.exists(), \"Heap dump file not found.\");\n+\n+        log(\"Reading \" + dumpFile + \"...\");\n+        try (Snapshot snapshot = Reader.readFile(dumpFile.getPath(), true, 0)) {\n+            log(\"Resolving snapshot...\");\n+            snapshot.resolve(true);\n+            log(\"Snapshot resolved.\");\n+\n+            \/\/ Log all threads with stack traces and stack references.\n+            List<ThreadObject> threads = snapshot.getThreads();\n+            List<Root> roots = Collections.list(snapshot.getRoots());\n+            log(\"Threads:\");\n+            for (ThreadObject thread: threads) {\n+                StackTrace st = thread.getStackTrace();\n+                StackFrame[] frames = st.getFrames();\n+                log(\"thread \" + thread.getIdString() + \", \" + frames.length + \" frames\");\n+\n+                List<Root> stackRoots = findStackRoot(roots, thread);\n+                for (int i = 0; i < frames.length; i++) {\n+                    log(\"  - [\" + i + \"] \"\n+                        + frames[i].getClassName() + \".\" + frames[i].getMethodName()\n+                        + frames[i].getMethodSignature()\n+                        + \" (\" + frames[i].getSourceFileName()\n+                        + \":\" + frames[i].getLineNumber() + \")\");\n+\n+                    for (Root r: stackRoots) {\n+                        StackFrame[] rootFrames = r.getStackTrace().getFrames();\n+                        \/\/ the frame this local belongs to\n+                        StackFrame frame = rootFrames[rootFrames.length - 1];\n+                        if (frame == frames[i]) {\n+                            JavaHeapObject obj = snapshot.findThing(r.getId());\n+                            JavaClass objClass = obj.getClazz();\n+                            log(\"      \" + r.getDescription() + \": \" + objClass.getName());\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ Verify objects from thread stacks are dumped.\n+            test(snapshot, VThreadInHeapDumpTarg.VThreadMountedReferenced.class);\n+            test(snapshot, VThreadInHeapDumpTarg.PThreadReferenced.class);\n+            \/\/test(snapshot, VThreadInHeapDumpTarg.VThreadUnmountedReferenced.class);\n+        }\n+\n+    }\n+\n+    private static List<Root> findStackRoot(List<Root> roots, ThreadObject thread) {\n+        List<Root> result = new ArrayList<>();\n+        for (Root root: roots) {\n+            if (root.getReferrerId() == thread.getId()) {\n+                result.add(root);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private static void test(Snapshot snapshot, String className) {\n+        log(\"Testing \" + className + \"...\");\n+        JavaClass jClass = snapshot.findClass(className);\n+        if (jClass == null) {\n+            throw new RuntimeException(\"'\" + className + \"' not found\");\n+        }\n+        int instanceCount = jClass.getInstancesCount(false);\n+        if (instanceCount != 1) {\n+            throw new RuntimeException(\"Expected 1 instance, \" + instanceCount + \" instances found\");\n+        }\n+        \/\/ There is the only instance.\n+        JavaHeapObject heapObj = jClass.getInstances(false).nextElement();\n+\n+        Root root = heapObj.getRoot();\n+        if (root == null) {\n+            throw new RuntimeException(\"No root for \" + className + \" instance\");\n+        }\n+        log(\"  root: \" + root.getDescription());\n+        JavaHeapObject referrer = root.getReferer();\n+        log(\"  referrer: \" + referrer);\n+    }\n+\n+    private static void test(Snapshot snapshot, Class cls) {\n+        test(snapshot, cls.getName());\n+    }\n+\n+    private static void log(Object s) {\n+        System.out.println(s);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/HeapDump\/VThreadInHeapDump.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,0 +144,4 @@\n+    public long getReferrerId() {\n+        return refererId;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Root.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,3 @@\n+    \/\/ threads\n+    private ArrayList<ThreadObject> threads = new ArrayList<>();\n+\n@@ -178,0 +181,4 @@\n+    public void addThreadObject(ThreadObject thread) {\n+        threads.add(thread);\n+    }\n+\n@@ -436,0 +443,4 @@\n+    public List<ThreadObject> getThreads() {\n+        return Collections.unmodifiableList(threads);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Snapshot.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hprof.model;\n+\n+import jdk.test.lib.hprof.util.Misc;\n+\n+public class ThreadObject {\n+\n+    private final long id;            \/\/ ID of the JavaThing we refer to\n+    private final StackTrace stackTrace;\n+\n+    public ThreadObject(long id, StackTrace stackTrace) {\n+        this.id = id;\n+        this.stackTrace = stackTrace;\n+    }\n+\n+    public long getId() {\n+        return id;\n+    }\n+\n+    public String getIdString() {\n+        return Misc.toHex(id);\n+    }\n+\n+    public StackTrace getStackTrace() {\n+        return stackTrace;\n+    }\n+\n+    void resolve(Snapshot ss) {\n+        if (stackTrace != null) {\n+            stackTrace.resolve(ss);\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/ThreadObject.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,2 +439,4 @@\n-                    threadObjects.put(threadSeq,\n-                                      new ThreadObject(id, stackSeq));\n+                    StackTrace st = getStackTraceFromSerial(stackSeq);\n+                    ThreadObject threadObj = new ThreadObject(id, st);\n+                    threadObjects.put(threadSeq, threadObj);\n+                    snapshot.addThreadObject(threadObj);\n@@ -456,1 +458,1 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n+                    StackTrace st = to.getStackTrace();\n@@ -460,1 +462,1 @@\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -470,1 +472,1 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n+                    StackTrace st = to.getStackTrace();;\n@@ -474,1 +476,1 @@\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -483,2 +485,2 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    StackTrace st = to.getStackTrace();;\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -499,2 +501,2 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    StackTrace st = to.getStackTrace();\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -916,14 +918,0 @@\n-    \/\/\n-    \/\/ A trivial data-holder class for HPROF_GC_ROOT_THREAD_OBJ.\n-    \/\/\n-    private class ThreadObject {\n-\n-        long threadId;\n-        int stackSeq;\n-\n-        ThreadObject(long threadId, int stackSeq) {\n-            this.threadId = threadId;\n-            this.stackSeq = stackSeq;\n-        }\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/HprofReader.java","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"}]}