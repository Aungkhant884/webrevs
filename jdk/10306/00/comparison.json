{"files":[{"patch":"@@ -4103,1 +4103,14 @@\n-\/\/ register move)\n+\/\/ register move):\n+\/\/\n+\/\/     iv Phi            iv Phi\n+\/\/       |                 |\n+\/\/       |                AddI (+stride)\n+\/\/       |                 |\n+\/\/       |              Opaque2  # Blocks IGVN from folding these nodes until loop opts are over.\n+\/\/       |     ====>       |\n+\/\/       |                AddI (-stride)\n+\/\/       |                 |\n+\/\/       |               CastII  # Preserve type of iv Phi\n+\/\/       |                 |\n+\/\/   Outside Use       Outside Use\n+\/\/\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\/\/ Do NOT remove the opaque Node until no more loop ops can happen.\n+\/\/ Do NOT remove the opaque node until no more loop opts can happen.\n@@ -57,0 +57,12 @@\n+\/\/ Do NOT remove the opaque node until no more loop opts can happen. Opaque1\n+\/\/ and Opaque2 nodes are removed together in order to optimize loops away\n+\/\/ before macro expansion.\n+Node* Opaque2Node::Identity(PhaseGVN* phase) {\n+  if (phase->C->post_loop_opts_phase()) {\n+    return in(1);\n+  } else {\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8292088\n+ * @requires vm.compiler2.enabled\n+ * @summary Test that OuterStripMinedLoop and its CountedLoop are both removed after the removal of Opaque1 and 2 nodes\n+            which allows the loop backedge to be optimized out.\n+ * @run main\/othervm -XX:LoopMaxUnroll=0 -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.c2.TestRemoveSingleIterationLoop::test*\n+ *                   -XX:CompileCommand=dontinline,compiler.c2.TestRemoveSingleIterationLoop::dontInline\n+ *                   compiler.c2.TestRemoveSingleIterationLoop\n+ * @run main\/othervm -XX:LoopMaxUnroll=2 -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.c2.TestRemoveSingleIterationLoop::test*\n+ *                   -XX:CompileCommand=dontinline,compiler.c2.TestRemoveSingleIterationLoop::dontInline\n+ *                   compiler.c2.TestRemoveSingleIterationLoop\n+ *\/\n+package compiler.c2;\n+\n+public class TestRemoveSingleIterationLoop {\n+    static int N = 400;\n+    static int x = 3;\n+    static int y = 3;\n+    static volatile int[] iArr = new int[N];\n+\n+    public static void main(String[] args) {\n+        testKnownLimit();\n+        testUnknownLimit();\n+        testKnownLimit2();\n+        testFuzzer();\n+    }\n+\n+    \/\/ Upper limit is known (i.e. type of iv phi for i is [-9999..499]). Unroll = 0 to trigger.\n+    private static void testKnownLimit() {\n+        int i = -10000;\n+        int limit = 500;\n+\n+        \/\/ These two loops are only required to make sure that we only know that 'i' is 5 after the second loop after CCP.\n+        int a = 2;\n+        for (; a < 4; a *= 2);\n+        for (int b = 2; b < a; b++) {\n+            i = 5;\n+        }\n+\n+        if (i < limit + 1) { \/\/ Required such that C2 knows that we are always entering the first loop.\n+            \/\/ Loop L1\n+            for (; i < limit; i++) {\n+                \/\/ IV_PHI_i = iv phi of i for this loop with type:\n+                \/\/ - Before CPP: [-10000..499]\n+                \/\/ - After CPP:  [5..499]\n+                y = 3;\n+            }\n+\n+            int j = 6;\n+            \/\/ C2 parses the following loop as:\n+            \/\/ Loop head\n+            \/\/ body (where we do j--)\n+            \/\/ Loop exit check where we already applied j--: j > i - 1\n+            while (j > i - 1) {\n+                \/\/ IV_PHI_j = iv phi of j for this loop with type:\n+                \/\/ - Before CPP: [-9998..7]\n+                j--;\n+                iArr[23] = 3;\n+                \/\/ At this point i = IV_PHI_i + 1 because i was incremented once more before exiting loop L1.\n+                \/\/ In PhaseIdealLoop::reorg_offsets(), we identify such direct (pre-incremented) usages of an iv phi and\n+                \/\/ add an Opaque2 node to prevent loop-fallout uses. This lowers the register pressure. We replace the\n+                \/\/ direct phi usage in CmpI (annotated with types before CCP):\n+                \/\/\n+                \/\/      Phi               Phi (IV_PHI_i)   # [-10000..499]\n+                \/\/       |                  |\n+                \/\/       |                AddI (+1)        # [-9999..500]\n+                \/\/       |                 |\n+                \/\/       |              Opaque2            # int\n+                \/\/       |      ====>      |\n+                \/\/       |                AddI (-1)        # int\n+                \/\/       |                 |\n+                \/\/       |               CastII            # [-10000..499]\n+                \/\/       |                 |\n+                \/\/      CmpI              CmpI             # j > i - 1 = IV_PHI_j - 1 > CastII (actually IV_PHI_i) = [-10000..5] > [-10000..499]\n+                \/\/\n+                \/\/\n+                \/\/ After CCP, the type of the iv phi IV_PHI_i improves to [5..499] while the type of the CastII does not\n+                \/\/ because the Opaque2 node blocks the type update. When removing the Opaque2 node, we find that the\n+                \/\/ loop only runs for a single time and does not take the backedge:\n+                \/\/\n+                \/\/     [-10000..5] > [5..499] is false\n+                \/\/\n+                \/\/ However, we only remove Opaque2 nodes in macro expansion where we also adjust the strip mined loop:\n+                \/\/ We copy the bool node from the CountedLoopEnd to the OuterStripMinedLoopEnd node and adjust the\n+                \/\/ loop exit check of the CountedLoopEnd in such a way that C2 is not able to prove that the loop\n+                \/\/ is only run once. But the OuterStripMinedLoop can now be removed due to the removed Opaque2 nodes\n+                \/\/ and we end up with a CountedLoop node that is strip mined but has no OuterStripMined loop. This\n+                \/\/ results in an assertion failure later when reshaping the graph.\n+            }\n+        }\n+    }\n+\n+    \/\/ Upper limit is not known (i.e. type of iv phi for i is [-9999..max-1]). Unroll = 0 to trigger.\n+    private static void testUnknownLimit() {\n+        int i = -10000;\n+        int limit = x;\n+\n+        \/\/ These two loops are required to make sure that we only know after CCP that 'i' is 1 after the second loop.\n+        int a = 2;\n+        for (; a < 4; a *= 2);\n+        for (int b = 2; b < a; b++) {\n+            i = 0;\n+        }\n+        if (i + 1 < limit) {\n+            i++;\n+            for (; i < limit; i++) {\n+                y = 3;\n+            }\n+            int t = 2;\n+            while (t > i - 1) {\n+                t--;\n+                iArr[23] = 3;\n+            }\n+        }\n+    }\n+\n+    \/\/ Upper limit is known. Unroll = 2 to trigger.\n+    static int testKnownLimit2() {\n+        int i = -10000, j;\n+        int[][] iArr1 = new int[N][N];\n+\n+        \/\/ These two loops are required to make sure that we only know after CCP that 'i' is 1 after the second loop.\n+        int a = 2;\n+        for (; a < 4; a *= 2);\n+        for (int b = 2; b < a; b++) {\n+            i = 1;\n+        }\n+\n+        while (++i < 318) {\n+            dontInline();\n+        }\n+\n+        for (j = 6; j > i; j--) {\n+            \/\/ Type of i before CCP: -9999..317\n+            \/\/ Type of i after CCP: 2..317\n+            iArr[1] = 25327;\n+        }\n+\n+        \/\/ This loop is required to trigger the assertion failure.\n+        for (int y = 0; y < iArr1.length; y++) {\n+            dontInline(iArr1[2]);\n+        }\n+        return i;\n+    }\n+\n+    \/\/ Reduced original fuzzer test. Unroll = 2 to trigger.\n+    static int testFuzzer() {\n+        int i = 1, j, iArr1[][] = new int[N][N];\n+        while (++i < 318) {\n+            dontInline();\n+            for (j = 5; j > i; j--) {\n+                iArr[1] = 25327;\n+            }\n+        }\n+\n+        \/\/ Some more code that is required to trigger the assertion failure.\n+        for (int y = 0; y < iArr1.length; y++) {\n+            dontInline(iArr1[2]);\n+        }\n+        return i;\n+    }\n+\n+    static void dontInline() {}\n+\n+    static void dontInline(int[] iArr) {}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestRemoveSingleIterationLoop.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"}]}