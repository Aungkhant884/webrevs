{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.ArrayList;\n@@ -30,0 +31,3 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n@@ -33,0 +37,1 @@\n+import java.util.Map;\n@@ -34,0 +39,1 @@\n+import java.util.function.Function;\n@@ -35,0 +41,1 @@\n+import java.util.stream.Collectors;\n@@ -36,0 +43,2 @@\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n@@ -40,0 +49,2 @@\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n@@ -43,1 +54,0 @@\n-import javax.tools.Diagnostic.Kind;\n@@ -109,0 +119,1 @@\n+    TypeMirror java_lang_SuppressWarnings;\n@@ -128,0 +139,3 @@\n+    \/** A map containing the info derived from {@code @SuppressWarnings} for an element. *\/\n+    Map<Element, Set<Messages.Group>> suppressWarnings = new HashMap<>();\n+\n@@ -148,0 +162,1 @@\n+        java_lang_SuppressWarnings = elements.getTypeElement(\"java.lang.SuppressWarnings\").asType();\n@@ -250,0 +265,83 @@\n+    \/**\n+     * {@return whether or not warnings in a group are suppressed for the current element}\n+     * @param g the group\n+     *\/\n+    boolean suppressWarnings(Messages.Group g) {\n+        return suppressWarnings(currElement, g);\n+    }\n+\n+    \/**\n+     * {@return whether or not warnings in a group are suppressed for a given element}\n+     * @param e the element\n+     * @param g the group\n+     *\/\n+    boolean suppressWarnings(Element e, Messages.Group g) {\n+        \/\/ check if warnings are suppressed in any enclosing classes\n+        Element encl = e.getEnclosingElement();\n+        if (encl != null && encl.asType().getKind() == TypeKind.DECLARED) {\n+            if (suppressWarnings(encl, g)) {\n+                return true;\n+            }\n+        }\n+\n+        \/\/ check the local @SuppressWarnings annotation, caching the results;\n+        \/\/ the supported strings are: \"doclint\" and \"doclint:GROUP,...\" for each GROUP\n+        Set<Messages.Group> set = suppressWarnings.get(e);\n+        if (set == null) {\n+            var gMap = Arrays.stream(Messages.Group.values())\n+                    .collect(Collectors.toMap(Messages.Group::optName, Function.identity()));\n+            set = EnumSet.noneOf(Messages.Group.class);\n+            for (String arg : getSuppressWarningsValue(e)) {\n+                if (arg.equals(\"doclint\")) {\n+                    set = EnumSet.allOf(Messages.Group.class);\n+                    break;\n+                } else if (arg.startsWith(\"doclint:\")){\n+                    final int len = \"doclint:\".length();\n+                    for (String a: arg.substring(len).split(\",\")) {\n+                        Messages.Group argGroup = gMap.get(a);\n+                        if (argGroup != null) {\n+                            set.add(argGroup);\n+                        }\n+                    }\n+                }\n+            }\n+            suppressWarnings.put(e, set);\n+        }\n+        return set.contains(g);\n+    }\n+\n+    \/**\n+     * Returns the list of values given to an instance of {@code @SuppressWarnings} for an element,\n+     * or an empty list if there is no annotation.\n+     *\n+     * @param e the element\n+     * @return the list\n+     *\/\n+    private List<String> getSuppressWarningsValue(Element e) {\n+        for (AnnotationMirror am : e.getAnnotationMirrors()) {\n+            DeclaredType dt = am.getAnnotationType();\n+            if (types.isSameType(dt, java_lang_SuppressWarnings)) {\n+                var values = am.getElementValues();\n+                for (var entry : values.entrySet()) {\n+                    if (entry.getKey().getSimpleName().contentEquals(\"value\")) {\n+                        AnnotationValue av = entry.getValue();\n+                        if (av.getValue() instanceof List<?> list) {\n+                            List<String> result = new ArrayList<>();\n+                            for (var item : list) {\n+                                if (item instanceof AnnotationValue avItem) {\n+                                    if (avItem.getValue() instanceof String s) {\n+                                        result.add(s);\n+                                    }\n+                                }\n+                            }\n+                            return result;\n+                        }\n+                    }\n+                }\n+\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Env.java","additions":100,"deletions":2,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,3 @@\n+            if (dkind == Diagnostic.Kind.WARNING && env.suppressWarnings(group)) {\n+                return;\n+            }\n@@ -128,0 +131,3 @@\n+            if (dkind == Diagnostic.Kind.WARNING && env.suppressWarnings(group)) {\n+                return;\n+            }\n@@ -318,1 +324,1 @@\n-            private static final Comparator<Integer> DECREASING = (o1, o2) -> o2.compareTo(o1);\n+            private static final Comparator<Integer> DECREASING = Comparator.reverseOrder();\n@@ -325,5 +331,1 @@\n-                Set<String> labels = map.get(n);\n-                if (labels == null) {\n-                    map.put(n, labels = new TreeSet<>());\n-                }\n-                labels.add(label);\n+                map.computeIfAbsent(n, k -> new TreeSet<>()).add(label);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Messages.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-                \"warning\",\n+                \": warning:\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFX.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8189591\n+ * @summary No way to locally suppress doclint warnings\n+ * @library \/tools\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.doclint\n+ * @build toolbox.ToolBox SuppressWarningsTest\n+ * @run main SuppressWarningsTest\n+ *\/\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import jdk.javadoc.internal.doclint.DocLint;\n+import toolbox.ToolBox;\n+\n+public class SuppressWarningsTest {\n+    public static void main(String... args) throws Exception {\n+        new SuppressWarningsTest().run();\n+    }\n+\n+    enum Kind {\n+        NONE(\"\/\/ no annotation\"),\n+        MISSING(\"@SuppressWarnings(\\\"doclint:missing\\\")\"),\n+        OTHER(\"@SuppressWarnings(\\\"doclint:html\\\")\"),\n+        ALL(\"@SuppressWarnings(\\\"doclint\\\")\");\n+        final String anno;\n+        Kind(String anno) {\n+            this.anno = anno;\n+        }\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+    PrintStream log = System.err;\n+\n+    void run() throws Exception {\n+        for (Kind ok : Kind.values()) {\n+            for (Kind ik : Kind.values()) {\n+                for (Kind mk : Kind.values()) {\n+                    test(ok, ik, mk);\n+                }\n+            }\n+        }\n+\n+        if (errorCount == 0) {\n+            log.println(\"No errors\");\n+        } else {\n+            log.println(errorCount + \" errors\");\n+            throw new Exception(errorCount + \" errors\");\n+        }\n+    }\n+\n+    void test(Kind outerKind, Kind innerKind, Kind memberKind) throws Exception {\n+        log.println(\"Test: outer:\" + outerKind + \" inner: \" + innerKind + \" member:\" + memberKind);\n+        Path base = Path.of(outerKind + \"-\" + innerKind + \"-\" + memberKind);\n+        Files.createDirectories(base);\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                \/** . *\/\n+                ##OUTER##\n+                public class Outer {\n+                    \/** . *\/\n+                    private Outer() { }\n+                    \/** . *\/\n+                    ##INNER##\n+                    public class Inner {\n+                        \/** . *\/\n+                        private Inner() { }\n+                        ##MEMBER##\n+                        public void m() { }\n+                    }\n+                }\n+                \"\"\"\n+                .replace(\"##OUTER##\", outerKind.anno)\n+                .replace(\"##INNER##\", innerKind.anno)\n+                .replace(\"##MEMBER##\", memberKind.anno));\n+\n+        DocLint dl = new DocLint();\n+        StringWriter sw = new StringWriter();\n+        try (PrintWriter pw = new PrintWriter(sw)) {\n+            dl.run(pw, src.resolve(\"Outer.java\").toString());\n+        }\n+        String out = sw.toString();\n+        out.lines().forEach(System.err::println);\n+\n+        boolean expectSuppressed = false;\n+        for (Kind k : List.of(outerKind, innerKind, memberKind)) {\n+            expectSuppressed |= k == Kind.ALL || k == Kind.MISSING;\n+        }\n+        boolean foundWarning = out.contains(\"warning: no comment\");\n+        if (expectSuppressed) {\n+            if (foundWarning) {\n+                error(\"found unexpected warning\");\n+            } else {\n+                log.println(\"Passed: no warning, as expected\");\n+            }\n+        } else {\n+            if (foundWarning) {\n+                log.println(\"Passed: found warning, as expected\");\n+            } else {\n+                error(\"no warning\");\n+            }\n+        }\n+        log.println();\n+    }\n+\n+    int errorCount;\n+\n+    void error(String message) {\n+        log.println(\"Error: \" + message);\n+        errorCount++;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/SuppressWarningsTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}