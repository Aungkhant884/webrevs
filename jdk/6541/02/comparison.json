{"files":[{"patch":"@@ -410,1 +410,5 @@\n-    note_trap(current, Deoptimization::Reason_class_check);\n+    if (s == vmSymbols::java_lang_ArrayStoreException()) {\n+      note_trap(current, Deoptimization::Reason_array_check);\n+    } else {\n+      note_trap(current, Deoptimization::Reason_class_check);\n+    }\n@@ -828,1 +832,12 @@\n-                                 CHECK);\n+                                 THREAD);\n+\n+    if (HAS_PENDING_EXCEPTION) {\n+      if (ProfileTraps && PENDING_EXCEPTION->klass()->name() == vmSymbols::java_lang_NullPointerException()) {\n+        \/\/ Preserve the original exception across the call to note_trap()\n+        PreserveExceptionMark pm(current);\n+        \/\/ Recording the trap will help the compiler to potentially recognize this exception as \"hot\"\n+        note_trap(current, Deoptimization::Reason_null_check);\n+      }\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -583,5 +583,4 @@\n-      if (java_bc() == Bytecodes::_aastore) {\n-        ex_obj = env()->ArrayStoreException_instance();\n-      } else {\n-        ex_obj = env()->ClassCastException_instance();\n-      }\n+      ex_obj = env()->ClassCastException_instance();\n+      break;\n+    case Deoptimization::Reason_array_check:\n+      ex_obj = env()->ArrayStoreException_instance();\n@@ -3343,1 +3342,4 @@\n-          builtin_throw(Deoptimization::Reason_class_check, makecon(TypeKlassPtr::make(objtp->klass())));\n+          bool is_aastore = (java_bc() == Bytecodes::_aastore);\n+          Deoptimization::DeoptReason reason = is_aastore ?\n+            Deoptimization::Reason_array_check : Deoptimization::Reason_class_check;\n+          builtin_throw(reason, makecon(TypeKlassPtr::make(objtp->klass())));\n@@ -3425,1 +3427,4 @@\n-        builtin_throw(Deoptimization::Reason_class_check, load_object_klass(not_null_obj));\n+        bool is_aastore = (java_bc() == Bytecodes::_aastore);\n+        Deoptimization::DeoptReason reason = is_aastore ?\n+          Deoptimization::Reason_array_check : Deoptimization::Reason_class_check;\n+        builtin_throw(reason, load_object_klass(not_null_obj));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -958,0 +958,66 @@\n+WB_ENTRY(jint, WB_GetMethodDecompileCount(JNIEnv* env, jobject o, jobject method))\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  uint cnt = 0;\n+  MethodData* mdo = mh->method_data();\n+  if (mdo != NULL) {\n+    cnt = mdo->decompile_count();\n+  }\n+  return cnt;\n+WB_END\n+\n+\/\/ Get the trap count of a method for a specific reason. If the trap count for\n+\/\/ that reason did overflow, this includes the overflow trap count of the method.\n+\/\/ If 'reason' is NULL, the sum of the traps for all reasons will be returned.\n+\/\/ This number includes the overflow trap count if the trap count for any reason\n+\/\/ did overflow.\n+WB_ENTRY(jint, WB_GetMethodTrapCount(JNIEnv* env, jobject o, jobject method, jstring reason_obj))\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  uint cnt = 0;\n+  MethodData* mdo = mh->method_data();\n+  if (mdo != NULL) {\n+    ResourceMark rm(THREAD);\n+    char* reason_str = (reason_obj == NULL) ?\n+      NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n+    bool overflow = false;\n+    for (uint reason = 0; reason < mdo->trap_reason_limit(); reason++) {\n+      if (reason_str != NULL && !strcmp(reason_str, Deoptimization::trap_reason_name(reason))) {\n+        cnt = mdo->trap_count(reason);\n+        \/\/ Count in the overflow trap count on overflow\n+        if (cnt == (uint)-1) {\n+          cnt = mdo->trap_count_limit() + mdo->overflow_trap_count();\n+        }\n+        break;\n+      } else if (reason_str == NULL) {\n+        uint c = mdo->trap_count(reason);\n+        if (c == (uint)-1) {\n+          c = mdo->trap_count_limit();\n+          if (!overflow) {\n+            \/\/ Count overflow trap count just once\n+            overflow = true;\n+            c += mdo->overflow_trap_count();\n+          }\n+        }\n+        cnt += c;\n+      }\n+    }\n+  }\n+  return cnt;\n+WB_END\n+\n+WB_ENTRY(jint, WB_GetDeoptCount(JNIEnv* env, jobject o, jstring reason_obj, jstring action_obj))\n+  if (reason_obj == NULL && action_obj == NULL) {\n+    return Deoptimization::total_deoptimization_count();\n+  }\n+  ResourceMark rm(THREAD);\n+  const char *reason_str = (reason_obj == NULL) ?\n+    NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n+  const char *action_str = (action_obj == NULL) ?\n+    NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(action_obj));\n+\n+  return Deoptimization::deoptimization_count(reason_str, action_str);\n+WB_END\n+\n@@ -2530,0 +2596,7 @@\n+  {CC\"getMethodDecompileCount0\",\n+      CC\"(Ljava\/lang\/reflect\/Executable;)I\",          (void*)&WB_GetMethodDecompileCount},\n+  {CC\"getMethodTrapCount0\",\n+      CC\"(Ljava\/lang\/reflect\/Executable;Ljava\/lang\/String;)I\",\n+                                                      (void*)&WB_GetMethodTrapCount},\n+  {CC\"getDeoptCount0\",\n+      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;)I\",    (void*)&WB_GetDeoptCount},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2611,0 +2611,24 @@\n+\/\/ Get the deopt count for a specific reason and a specific action. If either\n+\/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n+\/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n+\/\/ If both arguments are null, the method returns the total deopt count.\n+jint Deoptimization::deoptimization_count(const char *reason_str, const char *action_str) {\n+  if (reason_str == NULL && action_str == NULL) {\n+    return total_deoptimization_count();\n+  }\n+  juint counter = 0;\n+  for (int reason = 0; reason < Reason_LIMIT; reason++) {\n+    if (reason_str == NULL || !strcmp(reason_str, trap_reason_name(reason))) {\n+      for (int action = 0; action < Action_LIMIT; action++) {\n+        if (action_str == NULL || !strcmp(action_str, trap_action_name(action))) {\n+          juint* cases = _deoptimization_hist[reason][1+action];\n+          for (int bc_case = 0; bc_case < BC_CASE_LIMIT; bc_case++) {\n+            counter += cases[bc_case] >> LSB_BITS;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return counter;\n+}\n+\n@@ -2664,0 +2688,8 @@\n+jint Deoptimization::total_deoptimization_count() {\n+  return 0;\n+}\n+\n+jint Deoptimization::deoptimization_count(const char *reason_str, const char *action_str) {\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -436,0 +436,1 @@\n+  static jint deoptimization_count(const char* reason_str, const char* action_str);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8275908\n+ * @summary Record null_check traps for calls and array_check traps in the interpreter\n+ *\n+ * @requires vm.compiler2.enabled & vm.compMode != \"Xcomp\"\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseSerialGC -Xbatch -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.exceptions.OptimizeImplicitExceptions::throwImplicitException\n+ *                   compiler.exceptions.OptimizeImplicitExceptions\n+ *\/\n+\n+package compiler.exceptions;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class OptimizeImplicitExceptions {\n+    \/\/ ImplicitException represents the various implicit (aka. 'built-in') exceptions\n+    \/\/ which can be thrown implicitely by the JVM when executing bytecodes.\n+    public enum ImplicitException {\n+        \/\/ NullPointerException during field access\n+        NULL_POINTER_EXCEPTION(\"null_check\"),\n+        \/\/ NullPointerException during invoke\n+        INVOKE_NULL_POINTER_EXCEPTION(\"null_check\"),\n+        ARITHMETIC_EXCEPTION(\"div0_check\"),\n+        ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION(\"range_check\"),\n+        ARRAY_STORE_EXCEPTION(\"array_check\"),\n+        CLASS_CAST_EXCEPTION(\"class_check\");\n+        private final String reason;\n+        ImplicitException(String reason) {\n+            this.reason = reason;\n+        }\n+        public String getReason() {\n+            return reason;\n+        }\n+    }\n+    \/\/ TestMode represents a specific combination of the OmitStackTraceInFastThrow command line options.\n+    \/\/ They will be set up in 'setFlags(TestMode testMode)' before a new test run starts.\n+    public enum TestMode {\n+        OMIT_STACKTRACES_IN_FASTTHROW,\n+        STACKTRACES_IN_FASTTHROW\n+    }\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    \/\/ The number of deoptimizations after which a method will be made not-entrant\n+    private static final int PerBytecodeTrapLimit = WB.getIntxVMFlag(\"PerBytecodeTrapLimit\").intValue();\n+    \/\/ The number of interpreter invocations after which a decompiled method will be re-compiled.\n+    private static final int Tier0InvokeNotifyFreq = (int)Math.pow(2, WB.getIntxVMFlag(\"Tier0InvokeNotifyFreqLog\"));\n+    \/\/ The following variables are used to track the value of the global deopt counters between the various test phases.\n+    private static int oldDeoptCount = 0;\n+    private static HashMap<String, Integer> oldDeoptCountReason = new HashMap<String, Integer>(ImplicitException.values().length);\n+    \/\/ The following two objects are declared statically to simplify the test method.\n+    private static String[] string_a = new String[1];\n+    private static final Object o = new Object();\n+\n+    \/\/ This is the main test method. It will repeatedly called with the same ImplicitException 'type' to\n+    \/\/ JIT-compile it, deoptimized it, re-compile it again and do various checks on the way.\n+    \/\/ This process will be repeated then for each kind of ImplicitException 'type'.\n+    public static Object throwImplicitException(ImplicitException type, Object[] object_a) {\n+        switch (type) {\n+            case NULL_POINTER_EXCEPTION: {\n+                return object_a.length;\n+            }\n+            case INVOKE_NULL_POINTER_EXCEPTION: {\n+                return object_a.hashCode();\n+            }\n+            case ARITHMETIC_EXCEPTION: {\n+                return ((42 \/ (object_a.length - 1)) > 2) ? null : object_a[0];\n+            }\n+            case ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION: {\n+                return object_a[5];\n+            }\n+            case ARRAY_STORE_EXCEPTION: {\n+                return (object_a[0] = o);\n+            }\n+            case CLASS_CAST_EXCEPTION: {\n+                return (ImplicitException[])object_a;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Completely unload (i.e. make \"not-entrant\"->\"zombie\"->\"unload\/free\") a JIT-compiled\n+    \/\/ version of a method and clear the method's profiling counters.\n+    private static void unloadAndClean(Method m) {\n+        WB.deoptimizeMethod(m);  \/\/ Makes the nmethod \"not entrant\".\n+        WB.forceNMethodSweep();  \/\/ Makes all \"not entrant\" nmethods \"zombie\". This requires\n+        WB.forceNMethodSweep();  \/\/ two sweeps, see 'nmethod::can_convert_to_zombie()' for why.\n+        WB.forceNMethodSweep();  \/\/ Need third sweep to actually unload\/free all \"zombie\" nmethods.\n+        System.gc();\n+        WB.clearMethodState(m);\n+    }\n+\n+    \/\/ Set '-XX' flags according to 'TestMode'\n+    private static void setFlags(TestMode testMode) {\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW) {\n+            WB.setBooleanVMFlag(\"OmitStackTraceInFastThrow\", true);\n+        } else {\n+            WB.setBooleanVMFlag(\"OmitStackTraceInFastThrow\", false);\n+        }\n+\n+        System.out.println(\"==========================================================\");\n+        System.out.println(\"testMode=\" + testMode +\n+                           \" OmitStackTraceInFastThrow=\" + WB.getBooleanVMFlag(\"OmitStackTraceInFastThrow\"));\n+        System.out.println(\"==========================================================\");\n+    }\n+\n+    private static void printCounters(TestMode testMode, ImplicitException impExcp, Method throwImplicitException_m, int invocations) {\n+        System.out.println(\"testMode=\" + testMode + \" exception=\" + impExcp + \" invocations=\" + invocations + \"\\n\" +\n+                           \"decompilecount=\" + WB.getMethodDecompileCount(throwImplicitException_m) + \" \" +\n+                           \"trapCount=\" + WB.getMethodTrapCount(throwImplicitException_m) + \" \" +\n+                           \"trapCount(\" + impExcp.getReason() + \")=\" +\n+                           WB.getMethodTrapCount(throwImplicitException_m, impExcp.getReason()) + \" \" +\n+                           \"globalDeoptCount=\" + WB.getDeoptCount() + \" \" +\n+                           \"globalDeoptCount(\" + impExcp.getReason() + \")=\" + WB.getDeoptCount(impExcp.getReason(), null));\n+        System.out.println(\"method compiled=\" + WB.isMethodCompiled(throwImplicitException_m));\n+    }\n+\n+    \/\/ Checks after the test method has been JIT-compiled but before the compiled version has been invoked.\n+    private static void checkSimple(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n+\n+        printCounters(testMode, impExcp, throwImplicitException_m, invocations);\n+        \/\/ At this point, throwImplicitException() has been compiled but the compiled version has not been invoked yet.\n+        Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n+\n+        int trapCount = WB.getMethodTrapCount(throwImplicitException_m);\n+        int trapCountSpecific = WB.getMethodTrapCount(throwImplicitException_m, impExcp.getReason());\n+        Asserts.assertEQ(trapCount, invocations, \"Trap count must much invocation count.\");\n+        Asserts.assertEQ(trapCountSpecific, invocations, \"Trap count must much invocation count.\");\n+        Asserts.assertNotNull(ex.getMessage(), \"Exceptions thrown in the interpreter should have a message.\");\n+    }\n+\n+    \/\/ Checks after the JIT-compiled test method has been invoked 'invocations' times.\n+    private static void check(TestMode testMode, ImplicitException impExcp, Exception ex,\n+                              Method throwImplicitException_m, int invocations, int totalInvocations) {\n+\n+        printCounters(testMode, impExcp, throwImplicitException_m, totalInvocations);\n+        \/\/ At this point, the compiled version of 'throwImplicitException()' has been invoked 'invocations' times.\n+        Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n+        int deoptCount = WB.getDeoptCount();\n+        int deoptCountReason = WB.getDeoptCount(impExcp.getReason(), null\/*action*\/);\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW) {\n+            \/\/ No deoptimizations for '-XX:+OmitStackTraceInFastThrow'\n+            Asserts.assertEQ(oldDeoptCount, deoptCount, \"Wrong number of deoptimizations.\");\n+            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()), deoptCountReason, \"Wrong number of deoptimizations.\");\n+            \/\/ '-XX:+OmitStackTraceInFastThrow' never has message because it is using a global singleton exception.\n+            Asserts.assertNull(ex.getMessage(), \"Optimized exceptions have no message.\");\n+        } else if (testMode == TestMode.STACKTRACES_IN_FASTTHROW) {\n+            \/\/ We always deoptimize for '-XX:-OmitStackTraceInFastThrow\n+            Asserts.assertEQ(oldDeoptCount + invocations, deoptCount, \"Wrong number of deoptimizations.\");\n+            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + invocations, deoptCountReason, \"Wrong number of deoptimizations.\");\n+            Asserts.assertNotNull(ex.getMessage(), \"Exceptions thrown in the interpreter should have a message.\");\n+        } else {\n+            Asserts.fail(\"Unknown test mode.\");\n+        }\n+        oldDeoptCount = deoptCount;\n+        oldDeoptCountReason.put(impExcp.getReason(), deoptCountReason);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!WB.getBooleanVMFlag(\"ProfileTraps\")) {\n+            \/\/ The fast-throw optimzation only works if we're running with -XX:+ProfileTraps\n+            return;\n+        }\n+\n+        \/\/ Initialize global deopt counts to zero.\n+        for (ImplicitException impExcp : ImplicitException.values()) {\n+            oldDeoptCountReason.put(impExcp.getReason(), 0);\n+        }\n+        \/\/ Get a handle of the test method for usage with the WhiteBox API.\n+        Method throwImplicitException_m = OptimizeImplicitExceptions.class\n+            .getDeclaredMethod(\"throwImplicitException\", new Class[] { ImplicitException.class, Object[].class});\n+\n+        for (TestMode testMode : TestMode.values()) {\n+            setFlags(testMode);\n+            for (ImplicitException impExcp : ImplicitException.values()) {\n+                int invocations = 0;\n+                Exception lastException = null;\n+\n+                \/\/ Warmup and compile, but don't invoke compiled code.\n+                while(!WB.isMethodCompiled(throwImplicitException_m)) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                checkSimple(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+\n+                \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times.\n+                for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                check(testMode, impExcp, lastException, throwImplicitException_m, PerBytecodeTrapLimit, invocations);\n+\n+                \/\/ Invoke compiled code 'Tier0InvokeNotifyFreq' times.\n+                \/\/ If the method was de-compiled before, this will re-compile it again.\n+                for (int i = 0; i < Tier0InvokeNotifyFreq; i++) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                check(testMode, impExcp, lastException, throwImplicitException_m, Tier0InvokeNotifyFreq, invocations);\n+\n+                \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times.\n+                for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                check(testMode, impExcp, lastException, throwImplicitException_m, PerBytecodeTrapLimit, invocations);\n+\n+                System.out.println(\"------------------------------------------------------------------\");\n+\n+                unloadAndClean(throwImplicitException_m);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/OptimizeImplicitExceptions.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8275908\n+ * @summary Quick test for the new WhiteBox methods of JDK-8275908\n+ *\n+ * @requires vm.compiler2.enabled & vm.compMode != \"Xcomp\"\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseSerialGC -Xbatch -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.uncommontrap.Decompile::uncommonTrap\n+ *                   -XX:CompileCommand=inline,compiler.uncommontrap.Decompile*::foo\n+ *                   compiler.uncommontrap.Decompile\n+ *\/\n+\n+package compiler.uncommontrap;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class Decompile {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    \/\/ The number of deoptimizations after which a method will be made not-entrant\n+    private static final int PerBytecodeTrapLimit = WB.getIntxVMFlag(\"PerBytecodeTrapLimit\").intValue();\n+    \/\/ The number of interpreter invocations after which a decompiled method will be re-compiled.\n+    private static final int Tier0InvokeNotifyFreq = (int)Math.pow(2, WB.getIntxVMFlag(\"Tier0InvokeNotifyFreqLog\"));\n+    \/\/ VM builds without JVMCI like x86_32 call the bimorphic inlining trap just 'bimorphic'\n+    \/\/ while all the other builds with JVMCI call it 'bimorphic_or_optimized_type_check'.\n+    private static final boolean isJVMCISupported = WhiteBox.getWhiteBox().isJVMCISupportedByGC();\n+    private static final String bimorphicTrapName = isJVMCISupported ? \"bimorphic_or_optimized_type_check\" : \"bimorphic\";\n+\n+    static class Base {\n+        void foo() {}\n+    }\n+    static class X extends Base {\n+        void foo() {}\n+    }\n+    static class Y extends Base {\n+        void foo() {}\n+    }\n+\n+    static void uncommonTrap(Base t) {\n+        t.foo();\n+    }\n+\n+    private static void printCounters(Method uncommonTrap_m, int invocations) {\n+        System.out.println(\"-----------------------------------------------------------------\");\n+        System.out.println(\"invocations=\" + invocations + \" \" +\n+                           \"method compiled=\" + WB.isMethodCompiled(uncommonTrap_m) + \" \" +\n+                           \"decompileCount=\" + WB.getMethodDecompileCount(uncommonTrap_m) + \"\\n\" +\n+                           \"trapCount=\" + WB.getMethodTrapCount(uncommonTrap_m) + \" \" +\n+                           \"trapCount(class_check)=\" + WB.getMethodTrapCount(uncommonTrap_m, \"class_check\") + \" \" +\n+                           \"trapCount(\" + bimorphicTrapName + \")=\" +\n+                           WB.getMethodTrapCount(uncommonTrap_m, bimorphicTrapName) + \"\\n\" +\n+                           \"globalDeoptCount=\" + WB.getDeoptCount() + \" \" +\n+                           \"globalDeoptCount(class_check)=\" + WB.getDeoptCount(\"class_check\", null) + \" \" +\n+                           \"globalDeoptCount(\" + bimorphicTrapName + \")=\" +\n+                           WB.getDeoptCount(bimorphicTrapName, null));\n+        System.out.println(\"-----------------------------------------------------------------\");\n+    }\n+\n+    private static void check(Method uncommonTrap_m, int invocations, boolean isCompiled, int decompileCount,\n+                              int trapCount, int trapCountClassCheck, int trapCountBimorphic,\n+                              int deoptCount, int deoptCountClassCheck, int deoptCountBimorphic) {\n+\n+        printCounters(uncommonTrap_m, invocations);\n+\n+        Asserts.assertEQ(isCompiled, WB.isMethodCompiled(uncommonTrap_m),\n+                         \"Wrong compilation status.\");\n+        Asserts.assertEQ(decompileCount, WB.getMethodDecompileCount(uncommonTrap_m),\n+                         \"Wrong number of decompilations.\");\n+        Asserts.assertEQ(trapCount, WB.getMethodTrapCount(uncommonTrap_m),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(trapCountClassCheck, WB.getMethodTrapCount(uncommonTrap_m, \"class_check\"),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(trapCountBimorphic, WB.getMethodTrapCount(uncommonTrap_m, bimorphicTrapName),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(deoptCount, WB.getDeoptCount(),\n+                         \"Wrong number of deoptimizations.\");\n+        Asserts.assertEQ(deoptCountClassCheck, WB.getDeoptCount(\"class_check\", null),\n+                         \"Wrong number of class_check deoptimizations.\");\n+        Asserts.assertEQ(deoptCountBimorphic, WB.getDeoptCount(bimorphicTrapName, null),\n+                         \"Wrong number of \" + bimorphicTrapName + \"deoptimizations.\");\n+    }\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Get a handle of the test method for usage with the WhiteBox API.\n+        Method uncommonTrap_m = Decompile.class\n+            .getDeclaredMethod(\"uncommonTrap\", new Class[] { Base.class });\n+\n+        int invocations = 0;\n+        Base b = new Base();\n+        \/\/ This is a little tricky :) We have to define 'x' already here otherwise\n+        \/\/ the class 'X' won't be loaded and 'uncommonTrap()' will be compiled without\n+        \/\/ a class check but a CHA dependency that class 'B' has no subtypes.\n+        X x = new X();\n+        Y y = new Y();\n+\n+        \/\/ Warmup and compile with an object of type 'Base' as receiver, but don't invoke compiled code.\n+        while(!WB.isMethodCompiled(uncommonTrap_m)) {\n+            invocations++;\n+            uncommonTrap(b);\n+        }\n+        check(uncommonTrap_m, invocations, true \/* is_compiled *\/, 0 \/* decompileCount *\/,\n+              0 \/* trapCount  *\/, 0 \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              0 \/* deoptCount *\/, 0 \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times with an receiver object of type 'X'.\n+        \/\/ This should deoptimize 'PerBytecodeTrapLimit' times and finally decompile the method.\n+        for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+            invocations++;\n+            uncommonTrap(x);\n+        }\n+        check(uncommonTrap_m, invocations, false \/* is_compiled *\/, 1 \/* decompileCount *\/,\n+              PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke the method 'Tier0InvokeNotifyFreq' more times with an receiver object of type 'X'.\n+        \/\/ This should re-compile the method again with bimorphic inlining for receiver types 'Base' and 'X'.\n+        for (int i = 0; i < Tier0InvokeNotifyFreq; i++) {\n+            invocations++;\n+            uncommonTrap(x);\n+        }\n+        check(uncommonTrap_m, invocations, true \/* is_compiled *\/, 1 \/* decompileCount *\/,\n+              PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times with an receiver object of type 'Y'.\n+        \/\/ This should deoptimize 'PerBytecodeTrapLimit' times and finally decompile the method.\n+        for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+            invocations++;\n+            uncommonTrap(y);\n+        }\n+        check(uncommonTrap_m, invocations, false \/* is_compiled *\/, 2 \/* decompileCount *\/,\n+              2*PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, PerBytecodeTrapLimit \/* trapCountBimorphic  *\/,\n+              2*PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, PerBytecodeTrapLimit \/* deoptCountBimorphic *\/);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/Decompile.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -320,0 +320,30 @@\n+  public         int     getMethodDecompileCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodDecompileCount0(method);\n+  }\n+  private native int     getMethodDecompileCount0(Executable method);\n+  \/\/ Get the total trap count of a method. If the trap count for a specific reason\n+  \/\/ did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, null);\n+  }\n+  \/\/ Get the trap count of a method for a specific reason. If the trap count for\n+  \/\/ that reason did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method, String reason) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, reason);\n+  }\n+  private native int     getMethodTrapCount0(Executable method, String reason);\n+  \/\/ Get the total deopt count.\n+  public         int     getDeoptCount() {\n+    return getDeoptCount0(null, null);\n+  }\n+  \/\/ Get the deopt count for a specific reason and a specific action. If either\n+  \/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n+  \/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n+  \/\/ If both arguments are null, the method returns the total deopt count.\n+  public         int     getDeoptCount(String reason, String action) {\n+    return getDeoptCount0(reason, action);\n+  }\n+  private native int     getDeoptCount0(String reason, String action);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -321,0 +321,30 @@\n+  public         int     getMethodDecompileCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodDecompileCount0(method);\n+  }\n+  private native int     getMethodDecompileCount0(Executable method);\n+  \/\/ Get the total trap count of a method. If the trap count for a specific reason\n+  \/\/ did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, null);\n+  }\n+  \/\/ Get the trap count of a method for a specific reason. If the trap count for\n+  \/\/ that reason did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method, String reason) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, reason);\n+  }\n+  private native int     getMethodTrapCount0(Executable method, String reason);\n+  \/\/ Get the total deopt count.\n+  public         int     getDeoptCount() {\n+    return getDeoptCount0(null, null);\n+  }\n+  \/\/ Get the deopt count for a specific reason and a specific action. If either\n+  \/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n+  \/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n+  \/\/ If both arguments are null, the method returns the total deopt count.\n+  public         int     getDeoptCount(String reason, String action) {\n+    return getDeoptCount0(reason, action);\n+  }\n+  private native int     getDeoptCount0(String reason, String action);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}