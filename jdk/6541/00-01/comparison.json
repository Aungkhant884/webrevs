{"files":[{"patch":"@@ -834,1 +834,1 @@\n-    if(HAS_PENDING_EXCEPTION) {\n+    if (HAS_PENDING_EXCEPTION) {\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3342,2 +3342,2 @@\n-          bool aastore = (java_bc() == Bytecodes::_aastore);\n-          Deoptimization::DeoptReason reason = aastore ?\n+          bool is_aastore = (java_bc() == Bytecodes::_aastore);\n+          Deoptimization::DeoptReason reason = is_aastore ?\n@@ -3427,2 +3427,2 @@\n-        bool aastore = (java_bc() == Bytecodes::_aastore);\n-        Deoptimization::DeoptReason reason = aastore ?\n+        bool is_aastore = (java_bc() == Bytecodes::_aastore);\n+        Deoptimization::DeoptReason reason = is_aastore ?\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -301,0 +301,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -436,1 +436,1 @@\n-  static jint deoptimization_count(const char *reason_str, const char *action_str);\n+  static jint deoptimization_count(const char* reason_str, const char* action_str);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-    private static void checkOne(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n+    private static void checkSimple(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n@@ -164,2 +164,3 @@\n-    \/\/ Checks after the JIT-compiled test method has been invoked 'PerBytecodeTrapLimit' times.\n-    private static void checkTwo(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n+    \/\/ Checks after the JIT-compiled test method has been invoked 'invocations' times.\n+    private static void check(TestMode testMode, ImplicitException impExcp, Exception ex,\n+                              Method throwImplicitException_m, int invocations, int totalInvocations) {\n@@ -167,2 +168,2 @@\n-        printCounters(testMode, impExcp, throwImplicitException_m, invocations);\n-        \/\/ At this point, the compiled version of 'throwImplicitException()' has been invoked 'PerBytecodeTrapLimit' times.\n+        printCounters(testMode, impExcp, throwImplicitException_m, totalInvocations);\n+        \/\/ At this point, the compiled version of 'throwImplicitException()' has been invoked 'invocations' times.\n@@ -180,25 +181,2 @@\n-            Asserts.assertEQ(oldDeoptCount + PerBytecodeTrapLimit, deoptCount, \"Wrong number of deoptimizations.\");\n-            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + PerBytecodeTrapLimit, deoptCountReason, \"Wrong number of deoptimizations.\");\n-            Asserts.assertNotNull(ex.getMessage(), \"Exceptions thrown in the interpreter should have a message.\");\n-        } else {\n-            Asserts.fail(\"Unknown test mode.\");\n-        }\n-        oldDeoptCount = deoptCount;\n-        oldDeoptCountReason.put(impExcp.getReason(), deoptCountReason);\n-    }\n-\n-    \/\/ Checks after the test method has been invoked 'Tier0InvokeNotifyFreq' more times.\n-    private static void checkThree(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n-\n-        printCounters(testMode, impExcp, throwImplicitException_m, invocations);\n-        \/\/ At this point, throwImplicitException() has been invoked 'Tier0InvokeNotifyFreq' more times.\n-        Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n-        int deoptCount = WB.getDeoptCount();\n-        int deoptCountReason = WB.getDeoptCount(impExcp.getReason(), null\/*action*\/);\n-        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW) {\n-            \/\/ No deoptimizations for '-XX:+OmitStackTraceInFastThrow'\n-            Asserts.assertEQ(oldDeoptCount, deoptCount, \"Wrong number of deoptimizations.\");\n-            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()), deoptCountReason, \"Wrong number of deoptimizations.\");\n-        } else if (testMode == TestMode.STACKTRACES_IN_FASTTHROW) {\n-            Asserts.assertEQ(oldDeoptCount + Tier0InvokeNotifyFreq, deoptCount, \"Wrong number of deoptimizations.\");\n-            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + Tier0InvokeNotifyFreq, deoptCountReason, \"Wrong number of deoptimizations.\");\n+            Asserts.assertEQ(oldDeoptCount + invocations, deoptCount, \"Wrong number of deoptimizations.\");\n+            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + invocations, deoptCountReason, \"Wrong number of deoptimizations.\");\n@@ -213,25 +191,0 @@\n-    \/\/ Checks after the test method has been invoked 'PerBytecodeTrapLimit' more times.\n-    private static void checkFour(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n-\n-        printCounters(testMode, impExcp, throwImplicitException_m, invocations);\n-        \/\/ At this point, the compiled (or re-compiled) version of throwImplicitException() has been invoked 'PerBytecodeTrapLimit' more times.\n-        Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n-        int deoptCount = WB.getDeoptCount();\n-        int deoptCountReason = WB.getDeoptCount(impExcp.getReason(), null\/*action*\/);\n-        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW) {\n-            \/\/ No deoptimizations for '-XX:+OmitStackTraceInFastThrow'\n-            Asserts.assertEQ(oldDeoptCount, deoptCount, \"Wrong number of deoptimizations.\");\n-            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()), deoptCountReason, \"Wrong number of deoptimizations.\");\n-            \/\/ '-XX:+OmitStackTraceInFastThrow' never has message because it is using a global singleton exception.\n-            Asserts.assertNull(ex.getMessage(), \"Optimized exceptions have no message.\");\n-        } else if (testMode == TestMode.STACKTRACES_IN_FASTTHROW) {\n-            \/\/ We always deoptimize for '-XX:-OmitStackTraceInFastThrow'\n-            Asserts.assertEQ(oldDeoptCount + PerBytecodeTrapLimit, deoptCount, \"Wrong number of deoptimizations.\");\n-            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + PerBytecodeTrapLimit, deoptCountReason, \"Wrong number of deoptimizations.\");\n-        } else {\n-            Asserts.fail(\"Unknown test mode.\");\n-        }\n-        oldDeoptCount = deoptCount;\n-        oldDeoptCountReason.put(impExcp.getReason(), deoptCountReason);\n-    }\n-\n@@ -271,1 +224,1 @@\n-                checkOne(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+                checkSimple(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n@@ -285,1 +238,1 @@\n-                checkTwo(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+                check(testMode, impExcp, lastException, throwImplicitException_m, PerBytecodeTrapLimit, invocations);\n@@ -287,1 +240,1 @@\n-                \/\/ Invoke compiled (or interpreted if JDK-8275908 isn't fixed) code 'Tier0InvokeNotifyFreq' times.\n+                \/\/ Invoke compiled code 'Tier0InvokeNotifyFreq' times.\n@@ -300,1 +253,1 @@\n-                checkThree(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+                check(testMode, impExcp, lastException, throwImplicitException_m, Tier0InvokeNotifyFreq, invocations);\n@@ -314,1 +267,1 @@\n-                checkFour(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+                check(testMode, impExcp, lastException, throwImplicitException_m, PerBytecodeTrapLimit, invocations);\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/OptimizeImplicitExceptions.java","additions":13,"deletions":60,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8275908\n+ * @summary Quick test for the new WhiteBox methods of JDK-8275908\n+ *\n+ * @requires vm.compiler2.enabled & vm.compMode != \"Xcomp\"\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseSerialGC -Xbatch -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.uncommontrap.Decompile::uncommonTrap\n+ *                   -XX:CompileCommand=inline,compiler.uncommontrap.Decompile*::foo\n+ *                   compiler.uncommontrap.Decompile\n+ *\/\n+\n+package compiler.uncommontrap;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class Decompile {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    \/\/ The number of deoptimizations after which a method will be made not-entrant\n+    private static final int PerBytecodeTrapLimit = WB.getIntxVMFlag(\"PerBytecodeTrapLimit\").intValue();\n+    \/\/ The number of interpreter invocations after which a decompiled method will be re-compiled.\n+    private static final int Tier0InvokeNotifyFreq = (int)Math.pow(2, WB.getIntxVMFlag(\"Tier0InvokeNotifyFreqLog\"));\n+\n+    static class Base {\n+        void foo() {}\n+    }\n+    static class X extends Base {\n+        void foo() {}\n+    }\n+    static class Y extends Base {\n+        void foo() {}\n+    }\n+\n+    static void uncommonTrap(Base t) {\n+        t.foo();\n+    }\n+\n+    private static void printCounters(Method uncommonTrap_m, int invocations) {\n+        System.out.println(\"-----------------------------------------------------------------\");\n+        System.out.println(\"invocations=\" + invocations + \" \" +\n+                           \"method compiled=\" + WB.isMethodCompiled(uncommonTrap_m) + \" \" +\n+                           \"decompileCount=\" + WB.getMethodDecompileCount(uncommonTrap_m) + \"\\n\" +\n+                           \"trapCount=\" + WB.getMethodTrapCount(uncommonTrap_m) + \" \" +\n+                           \"trapCount(class_check)=\" + WB.getMethodTrapCount(uncommonTrap_m, \"class_check\") + \" \" +\n+                           \"trapCount(bimorphic_or_optimized_type_check)=\" +\n+                           WB.getMethodTrapCount(uncommonTrap_m, \"bimorphic_or_optimized_type_check\") + \"\\n\" +\n+                           \"globalDeoptCount=\" + WB.getDeoptCount() + \" \" +\n+                           \"globalDeoptCount(class_check)=\" + WB.getDeoptCount(\"class_check\", null) + \" \" +\n+                           \"globalDeoptCount(bimorphic_or_optimized_type_check)=\" +\n+                           WB.getDeoptCount(\"bimorphic_or_optimized_type_check\", null));\n+        System.out.println(\"-----------------------------------------------------------------\");\n+    }\n+\n+    private static void check(Method uncommonTrap_m, int invocations, boolean isCompiled, int decompileCount,\n+                              int trapCount, int trapCountClassCheck, int trapCountBimorphic,\n+                              int deoptCount, int deoptCountClassCheck, int deoptCountBimorphic) {\n+\n+        printCounters(uncommonTrap_m, invocations);\n+\n+        Asserts.assertEQ(isCompiled, WB.isMethodCompiled(uncommonTrap_m),\n+                         \"Wrong compilation status.\");\n+        Asserts.assertEQ(decompileCount, WB.getMethodDecompileCount(uncommonTrap_m),\n+                         \"Wrong number of decompilations.\");\n+        Asserts.assertEQ(trapCount, WB.getMethodTrapCount(uncommonTrap_m),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(trapCountClassCheck, WB.getMethodTrapCount(uncommonTrap_m, \"class_check\"),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(trapCountBimorphic, WB.getMethodTrapCount(uncommonTrap_m, \"bimorphic_or_optimized_type_check\"),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(deoptCount, WB.getDeoptCount(),\n+                         \"Wrong number of deoptimizations.\");\n+        Asserts.assertEQ(deoptCountClassCheck, WB.getDeoptCount(\"class_check\", null),\n+                         \"Wrong number of class_check deoptimizations.\");\n+        Asserts.assertEQ(deoptCountBimorphic, WB.getDeoptCount(\"bimorphic_or_optimized_type_check\", null),\n+                         \"Wrong number of bimorphic_or_optimized_type_checkdeoptimizations.\");\n+    }\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Get a handle of the test method for usage with the WhiteBox API.\n+        Method uncommonTrap_m = Decompile.class\n+            .getDeclaredMethod(\"uncommonTrap\", new Class[] { Base.class });\n+\n+        int invocations = 0;\n+        Base b = new Base();\n+        \/\/ This is a little tricky :) We have to define 'x' already here otherwise\n+        \/\/ the class 'X' won't be loaded and 'uncommonTrap()' will be compiled without\n+        \/\/ a class check but a CHA dependency that class 'B' has no subtypes.\n+        X x = new X();\n+        Y y = new Y();\n+\n+        \/\/ Warmup and compile with an object of type 'Base' as receiver, but don't invoke compiled code.\n+        while(!WB.isMethodCompiled(uncommonTrap_m)) {\n+            invocations++;\n+            uncommonTrap(b);\n+        }\n+        check(uncommonTrap_m, invocations, true \/* is_compiled *\/, 0 \/* decompileCount *\/,\n+              0 \/* trapCount  *\/, 0 \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              0 \/* deoptCount *\/, 0 \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times with an receiver object of type 'X'.\n+        \/\/ This should deoptimize 'PerBytecodeTrapLimit' times and finally decompile the method.\n+        for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+            invocations++;\n+            uncommonTrap(x);\n+        }\n+        check(uncommonTrap_m, invocations, false \/* is_compiled *\/, 1 \/* decompileCount *\/,\n+              PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke the method 'Tier0InvokeNotifyFreq' more times with an receiver object of type 'X'.\n+        \/\/ This should re-compile the method again with bimorphic inlining for receiver types 'Base' and 'X'.\n+        for (int i = 0; i < Tier0InvokeNotifyFreq; i++) {\n+            invocations++;\n+            uncommonTrap(x);\n+        }\n+        check(uncommonTrap_m, invocations, true \/* is_compiled *\/, 1 \/* decompileCount *\/,\n+              PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times with an receiver object of type 'Y'.\n+        \/\/ This should deoptimize 'PerBytecodeTrapLimit' times and finally decompile the method.\n+        for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+            invocations++;\n+            uncommonTrap(y);\n+        }\n+        check(uncommonTrap_m, invocations, false \/* is_compiled *\/, 2 \/* decompileCount *\/,\n+              2*PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, PerBytecodeTrapLimit \/* trapCountBimorphic  *\/,\n+              2*PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, PerBytecodeTrapLimit \/* deoptCountBimorphic *\/);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/Decompile.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"}]}