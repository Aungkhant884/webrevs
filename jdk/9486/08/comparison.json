{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import static sun.nio.fs.UnixConstants.*;\n@@ -124,2 +125,0 @@\n-\n-\n@@ -130,0 +129,53 @@\n+\n+    @Override\n+    protected void bufferedCopy(int dst, int src, long address,\n+                                int size, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+        posix_fadvise(src, 0, 0, advice);\n+\n+        super.bufferedCopy(dst, src, address, size, addressToPollForCancel);\n+    }\n+\n+    @Override\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+        posix_fadvise(src, 0, 0, advice);\n+\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n+    \/\/ -- native methods --\n+\n+    private static native void init();\n+\n+    static {\n+        jdk.internal.loader.BootLoader.loadLibrary(\"nio\");\n+        init();\n+    }\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, UNAVAILABLE if the platform function would block,\n+     *         UNSUPPORTED_CASE if the call does not work with the given\n+     *         parameters, or UNSUPPORTED if direct copying is not supported\n+     *         on this platform\n+     *\/\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n+        throws UnixException;\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":55,"deletions":3,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -65,0 +65,6 @@\n+    \/**\n+     * int posix_fadvise(int fd, off_t offset, off_t len, int advice);\n+     *\/\n+    static native int posix_fadvise(int fd, long offset, long len, int advice)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+#include <sys\/sendfile.h>\n+#include <fcntl.h>\n+#include <dlfcn.h>\n+\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_LinuxFileSystem_init\n+    (JNIEnv* env, jclass this)\n+{\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+}\n+\n+\/\/ Copy all bytes from src to dst, within the kernel if possible (Linux),\n+\/\/ and return zero, otherwise return the appropriate status code.\n+\/\/\n+\/\/ Return value\n+\/\/   0 on success\n+\/\/   IOS_UNAVAILABLE if the platform function would block\n+\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n+\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n+\/\/   IOS_THROWN if a Java exception is thrown\n+\/\/\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxFileSystem_directCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n+{\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    \/\/ Transfer within the kernel\n+    const size_t count = cancel != NULL ?\n+        1048576 :   \/\/ 1 MB to give cancellation a chance\n+        0x7ffff000; \/\/ maximum number of bytes that sendfile() can transfer\n+    ssize_t bytes_sent;\n+\n+    if (my_copy_file_range_func != NULL) {\n+        do {\n+            RESTARTABLE(my_copy_file_range_func(src, NULL, dst, NULL, count, 0),\n+                                                bytes_sent);\n+            if (bytes_sent < 0) {\n+                switch (errno) {\n+                    case EINVAL:\n+                    case EXDEV:\n+                        \/\/ ignore and try sendfile()\n+                        break;\n+                    default:\n+                        JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                        return IOS_THROWN;\n+                }\n+            }\n+            if (cancel != NULL && *cancel != 0) {\n+                throwUnixException(env, ECANCELED);\n+                return IOS_THROWN;\n+            }\n+        } while (bytes_sent > 0);\n+\n+        if (bytes_sent == 0)\n+            return 0;\n+    }\n+\n+    do {\n+        RESTARTABLE(sendfile64(dst, src, NULL, count), bytes_sent);\n+        if (bytes_sent < 0) {\n+            if (errno == EAGAIN)\n+                return IOS_UNAVAILABLE;\n+            if (errno == EINVAL || errno == ENOSYS)\n+                return IOS_UNSUPPORTED_CASE;\n+            throwUnixException(env, errno);\n+            return IOS_THROWN;\n+        }\n+        if (cancel != NULL && *cancel != 0) {\n+            throwUnixException(env, ECANCELED);\n+            return IOS_THROWN;\n+        }\n+    } while (bytes_sent > 0);\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxFileSystem.c","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include <fcntl.h>\n@@ -142,1 +143,1 @@\n-    \/* FIXME - man page doesn't explain how errors are returned *\/\n+    \/\/ The endmntent() function always returns 1.\n@@ -145,0 +146,7 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxNativeDispatcher_posix_1fadvise(JNIEnv* env, jclass this,\n+    jint fd, jlong offset, jlong len, jint advice)\n+{\n+    return posix_fadvise((int)fd, (off_t)offset, (off_t)len, (int)advice);\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.internal.misc.Blocker;\n@@ -33,0 +34,1 @@\n+import static sun.nio.fs.UnixNativeDispatcher.copyToNativeBuffer;\n@@ -117,0 +119,14 @@\n+    boolean supportsCloning() throws IOException {\n+        try (NativeBuffer fileBuffer = copyToNativeBuffer(file())) {\n+            long comp = Blocker.begin();\n+            try {\n+                return supportsCloning0(fileBuffer.address());\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+\n+    }\n+\n+    private static native boolean supportsCloning0(long fileAddress);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import sun.nio.ch.IOStatus;\n@@ -34,0 +35,3 @@\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n+\n@@ -70,0 +74,85 @@\n+    \/\/ whether file cloning is supported on this platform\n+    private static volatile boolean cloneFileNotSupported;\n+\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using the {@code clonefile} system call.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the destination file (clone)\n+     * @param followLinks whether to follow links\n+     * @param mode the permissions to assign to the destination\n+     *\n+     * @return 0 on success, IOStatus.UNSUPPORTED_CASE if the call does not work\n+     *         with the given parameters, or IOStatus.UNSUPPORTED if cloning is\n+     *         not supported on this platform\n+     *\/\n+    private int clone(UnixPath src, UnixPath dst, boolean followLinks, int mode)\n+        throws IOException\n+    {\n+        BsdFileStore bfs = (BsdFileStore)provider().getFileStore(src);\n+        if (!bfs.equals(provider().getFileStore(dst.getParent())) ||\n+            !bfs.supportsCloning())\n+            return IOStatus.UNSUPPORTED_CASE;\n+\n+        int flags = followLinks ? 0 : CLONE_NOFOLLOW;\n+        int result = 0;\n+        try {\n+            result = BsdNativeDispatcher.clonefile(src, dst, flags);\n+        } catch (UnixException x) {\n+            switch (x.errno()) {\n+                case ENOTSUP: \/\/ cloning not supported by filesystem\n+                    return IOStatus.UNSUPPORTED;\n+                case EXDEV:   \/\/ src and dst on different filesystems\n+                case ENOTDIR: \/\/ problematic path parameter(s)\n+                    return IOStatus.UNSUPPORTED_CASE;\n+                default:\n+                    x.rethrowAsIOException(src, dst);\n+                    return IOStatus.THROWN;\n+            }\n+        }\n+        try {\n+            UnixNativeDispatcher.chmod(dst, mode);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(src, dst);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n+    @Override\n+    protected void copyFile(UnixPath source,\n+                            UnixFileAttributes attrs,\n+                            UnixPath  target,\n+                            UnixCopyFile.Flags flags,\n+                            long addressToPollForCancel)\n+        throws IOException\n+    {\n+        if (addressToPollForCancel == 0 && flags.copyPosixAttributes &&\n+            !cloneFileNotSupported) {\n+            int res = clone(source, target, flags.followLinks, attrs.mode());\n+            if (res == 0) {\n+                \/\/ copy owner\n+                try {\n+                    chown(target, attrs.uid(), attrs.gid());\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyPosix)\n+                        x.rethrowAsIOException(target);\n+                }\n+                return;\n+            }\n+            if (res == IOStatus.UNSUPPORTED) {\n+                cloneFileNotSupported = true;\n+            }\n+            \/\/ fall through to superclass method\n+        }\n+\n+        super.copyFile(source, attrs, target, flags, addressToPollForCancel);\n+    }\n+\n@@ -107,0 +196,6 @@\n+\n+    \/\/ -- native methods --\n+\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n+        throws UnixException;\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":96,"deletions":1,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -64,0 +64,20 @@\n+    \/**\n+     * int clonefile(const char * src, const char * dst, int flags);\n+     *\/\n+    static int clonefile(UnixPath src, UnixPath dst, int flags)\n+        throws UnixException\n+    {\n+        try (NativeBuffer srcBuffer = copyToNativeBuffer(src);\n+            NativeBuffer dstBuffer = copyToNativeBuffer(dst)) {\n+            long comp = Blocker.begin();\n+            try {\n+                return clonefile0(srcBuffer.address(), dstBuffer.address(),\n+                                  flags);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+    }\n+    private static native int clonefile0(long srcAddress, long dstAddress,\n+                                         int flags);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <strings.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <sys\/attr.h>\n+\n+#include \"sun_nio_fs_BsdFileStore.h\"\n+\n+#define CAPABILITY(vinfo, cap) \\\n+        (((vinfo).valid[VOL_CAPABILITIES_INTERFACES]        & (cap)) && \\\n+         ((vinfo).capabilities[VOL_CAPABILITIES_INTERFACES] & (cap)))\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_fs_BsdFileStore_supportsCloning0(JNIEnv* env, jclass this,\n+    jlong fileAddress)\n+{\n+    const char* file = (const char*)jlong_to_ptr(fileAddress);\n+\n+    struct attrlist alist;\n+    bzero(&alist, sizeof(alist));\n+    alist.bitmapcount = ATTR_BIT_MAP_COUNT;\n+    alist.volattr     = ATTR_VOL_INFO | ATTR_VOL_CAPABILITIES;\n+\n+    struct volAttrsBuf {\n+        u_int32_t length;\n+        vol_capabilities_attr_t capabilities;\n+    } __attribute__((aligned(4), packed));\n+    struct volAttrsBuf volAttrs;\n+    bzero(&volAttrs, sizeof(volAttrs));\n+\n+    \/\/ ignore any error in getattrlist\n+    if (getattrlist(file, &alist, &volAttrs, sizeof(volAttrs), 0) == 0) {\n+        vol_capabilities_attr_t volCaps = volAttrs.capabilities;\n+        int supportsAttrList = CAPABILITY(volCaps, VOL_CAP_INT_ATTRLIST);\n+        if (supportsAttrList) {\n+            return CAPABILITY(volCaps, VOL_CAP_INT_CLONE) != 0 ?\n+                JNI_TRUE : JNI_FALSE;\n+        }\n+    }\n+\n+    \/\/ return false if getattrlist fails\n+    return JNI_FALSE;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdFileStore.c","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+#include <copyfile.h>\n+#include \"sun_nio_fs_BsdFileSystem.h\"\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+int fcopyfile_callback(int what, int stage, copyfile_state_t state,\n+    const char* src, const char* dst, void* cancel)\n+{\n+    if (what == COPYFILE_COPY_DATA) {\n+        if (stage == COPYFILE_ERR\n+                || (stage == COPYFILE_PROGRESS && *((int*)cancel) != 0)) {\n+            \/\/ errno will be set to ECANCELED if the operation is cancelled,\n+            \/\/ or to the appropriate error number if there is an error,\n+            \/\/ but in either case we need to quit.\n+            return COPYFILE_QUIT;\n+        }\n+    }\n+    return COPYFILE_CONTINUE;\n+}\n+\n+\/\/ Copy all bytes from src to dst, within the kernel if possible (Linux),\n+\/\/ and return zero, otherwise return the appropriate status code.\n+\/\/\n+\/\/ Return value\n+\/\/   0 on success\n+\/\/   IOS_UNAVAILABLE if the platform function would block\n+\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n+\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n+\/\/   IOS_THROWN if a Java exception is thrown\n+\/\/\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdFileSystem_directCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n+{\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    copyfile_state_t state;\n+    if (cancel != NULL) {\n+        state = copyfile_state_alloc();\n+        copyfile_state_set(state, COPYFILE_STATE_STATUS_CB, fcopyfile_callback);\n+        copyfile_state_set(state, COPYFILE_STATE_STATUS_CTX, (void*)cancel);\n+    } else {\n+        state = NULL;\n+    }\n+    if (fcopyfile(src, dst, state, COPYFILE_DATA) < 0) {\n+        int errno_fcopyfile = errno;\n+        if (state != NULL)\n+            copyfile_state_free(state);\n+        throwUnixException(env, errno_fcopyfile);\n+        return IOS_THROWN;\n+    }\n+    if (state != NULL)\n+        copyfile_state_free(state);\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdFileSystem.c","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -45,0 +45,2 @@\n+#include <sys\/attr.h>\n+#include <sys\/clonefile.h>\n@@ -228,0 +230,16 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_clonefile0(JNIEnv* env, jclass this,\n+    jlong srcAddress, jlong dstAddress, jint flags)\n+{\n+    const char* src = (const char*)jlong_to_ptr(srcAddress);\n+    const char* dst = (const char*)jlong_to_ptr(dstAddress);\n+\n+    int ret = clonefile(src, dst, flags);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include <sys\/clonefile.h>\n@@ -136,0 +137,4 @@\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_ENOTSUP = ENOTSUP;\n+#endif\n+\n@@ -146,1 +151,0 @@\n-    \/\/ flags used with setattrlist\n@@ -148,0 +152,5 @@\n+    \/\/ flags used with clonefile(2)\n+    static final int PREFIX_CLONE_NOFOLLOW = CLONE_NOFOLLOW;\n+    static final int PREFIX_CLONE_NOOWNERCOPY = CLONE_NOOWNERCOPY;\n+\n+    \/\/ flags used with setattrlist\n@@ -159,0 +168,7 @@\n+\n+#ifdef __linux__\n+    \/\/ advice flags used with posix_fadvise(2)\n+    static final int PREFIX_POSIX_FADV_SEQUENTIAL = POSIX_FADV_SEQUENTIAL;\n+    static final int PREFIX_POSIX_FADV_NOREUSE    = POSIX_FADV_NOREUSE;\n+    static final int PREFIX_POSIX_FADV_WILLNEED   = POSIX_FADV_WILLNEED;\n+#endif\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,4 +39,0 @@\n-import jdk.internal.misc.Blocker;\n-import sun.nio.ch.DirectBuffer;\n-import sun.nio.ch.IOStatus;\n-import sun.nio.ch.Util;\n@@ -51,3 +47,0 @@\n-    \/\/ minimum size of a temporary direct buffer\n-    private static final int MIN_BUFFER_SIZE = 16384;\n-\n@@ -57,1 +50,1 @@\n-    private static class Flags {\n+    static class Flags {\n@@ -227,156 +220,0 @@\n-    \/\/ calculate the least common multiple of two values;\n-    \/\/ the parameters in general will be powers of two likely in the\n-    \/\/ range [4096, 65536] so this algorithm is expected to converge\n-    \/\/ when it is rarely called\n-    private static long lcm(long x, long y) {\n-        assert x > 0 && y > 0 : \"Non-positive parameter\";\n-\n-        long u = x;\n-        long v = y;\n-\n-        while (u != v) {\n-            if (u < v)\n-                u += x;\n-            else \/\/ u > v\n-                v += y;\n-        }\n-\n-        return u;\n-    }\n-\n-    \/\/ calculate temporary direct buffer size\n-    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n-        int bufferSize = MIN_BUFFER_SIZE;\n-        try {\n-            long bss = UnixFileStoreAttributes.get(source).blockSize();\n-            long bst = UnixFileStoreAttributes.get(target).blockSize();\n-            if (bss > 0 && bst > 0) {\n-                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n-            }\n-            if (bufferSize < MIN_BUFFER_SIZE) {\n-                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n-                bufferSize *= factor;\n-            }\n-        } catch (UnixException ignored) {\n-        }\n-        return bufferSize;\n-    }\n-\n-    \/\/ whether direct copying is supported on this platform\n-    private static volatile boolean directCopyNotSupported;\n-\n-    \/\/ copy regular file from source to target\n-    private static void copyFile(UnixPath source,\n-                                 UnixFileAttributes attrs,\n-                                 UnixPath  target,\n-                                 Flags flags,\n-                                 long addressToPollForCancel)\n-        throws IOException\n-    {\n-        int fi = -1;\n-        try {\n-            fi = open(source, O_RDONLY, 0);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(source);\n-        }\n-\n-        try {\n-            \/\/ open new file\n-            int fo = -1;\n-            try {\n-                fo = open(target,\n-                           (O_WRONLY |\n-                            O_CREAT |\n-                            O_EXCL),\n-                           attrs.mode());\n-            } catch (UnixException x) {\n-                x.rethrowAsIOException(target);\n-            }\n-\n-            \/\/ set to true when file and attributes copied\n-            boolean complete = false;\n-            try {\n-                boolean copied = false;\n-                if (!directCopyNotSupported) {\n-                    \/\/ copy bytes to target using platform function\n-                    long comp = Blocker.begin();\n-                    try {\n-                        int res = directCopy0(fo, fi, addressToPollForCancel);\n-                        if (res == 0) {\n-                            copied = true;\n-                        } else if (res == IOStatus.UNSUPPORTED) {\n-                            directCopyNotSupported = true;\n-                        }\n-                    } catch (UnixException x) {\n-                        x.rethrowAsIOException(source, target);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n-                }\n-\n-                if (!copied) {\n-                    \/\/ copy bytes to target via a temporary direct buffer\n-                    int bufferSize = temporaryBufferSize(source, target);\n-                    ByteBuffer buf = Util.getTemporaryDirectBuffer(bufferSize);\n-                    try {\n-                        long comp = Blocker.begin();\n-                        try {\n-                            bufferedCopy0(fo, fi, ((DirectBuffer)buf).address(),\n-                                          bufferSize, addressToPollForCancel);\n-                        } catch (UnixException x) {\n-                            x.rethrowAsIOException(source, target);\n-                        } finally {\n-                            Blocker.end(comp);\n-                        }\n-                    } finally {\n-                        Util.releaseTemporaryDirectBuffer(buf);\n-                    }\n-                }\n-\n-                \/\/ copy owner\/permissions\n-                if (flags.copyPosixAttributes) {\n-                    try {\n-                        fchown(fo, attrs.uid(), attrs.gid());\n-                        fchmod(fo, attrs.mode());\n-                    } catch (UnixException x) {\n-                        if (flags.failIfUnableToCopyPosix)\n-                            x.rethrowAsIOException(target);\n-                    }\n-                }\n-                \/\/ copy non POSIX attributes (depends on file system)\n-                if (flags.copyNonPosixAttributes) {\n-                    source.getFileSystem().copyNonPosixAttributes(fi, fo);\n-                }\n-                \/\/ copy time attributes\n-                if (flags.copyBasicAttributes) {\n-                    try {\n-                        if (futimesSupported()) {\n-                            futimes(fo,\n-                                    attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                    attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                        } else {\n-                            utimes(target,\n-                                   attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                   attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                        }\n-                    } catch (UnixException x) {\n-                        if (flags.failIfUnableToCopyBasic)\n-                            x.rethrowAsIOException(target);\n-                    }\n-                }\n-                complete = true;\n-            } finally {\n-                close(fo, e -> null);\n-\n-                \/\/ copy of file or attributes failed so rollback\n-                if (!complete) {\n-                    try {\n-                        unlink(target);\n-                    } catch (UnixException ignore) { }\n-                }\n-            }\n-        } finally {\n-            close(fi, e -> null);\n-        }\n-    }\n-\n@@ -570,1 +407,2 @@\n-                    copyFile(source, sourceAttrs, target, flags, 0L);\n+                    source.getFileSystem().copyFile(source, sourceAttrs,\n+                                                    target, flags, 0L);\n@@ -681,1 +519,1 @@\n-            copyFile(source, sourceAttrs, target, flags, 0L);\n+            source.getFileSystem().copyFile(source, sourceAttrs, target, flags, 0L);\n@@ -689,2 +527,2 @@\n-                copyFile(source, attrsToCopy, target, flags,\n-                    addressToPollForCancel());\n+                source.getFileSystem().copyFile(source, attrsToCopy, target,\n+                                                flags, addressToPollForCancel());\n@@ -702,41 +540,0 @@\n-\n-    \/\/ -- native methods --\n-\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * a platform-specific function or system call possibly having kernel\n-     * support.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\n-     * @return 0 on success, UNAVAILABLE if the platform function would block,\n-     *         UNSUPPORTED_CASE if the call does not work with the given\n-     *         parameters, or UNSUPPORTED if direct copying is not supported\n-     *         on this platform\n-     *\/\n-    private static native int directCopy0(int dst, int src,\n-                                          long addressToPollForCancel)\n-        throws UnixException;\n-\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * an intermediate temporary direct buffer.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param address the address of the temporary direct buffer's array\n-     * @param size the size of the temporary direct buffer's array\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\/\n-    private static native void bufferedCopy0(int dst, int src, long address,\n-                                             int size, long addressToPollForCancel)\n-        throws UnixException;\n-\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"nio\");\n-    }\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":6,"deletions":209,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -33,0 +34,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -34,0 +36,3 @@\n+import jdk.internal.misc.Blocker;\n+import sun.nio.ch.DirectBuffer;\n+import sun.nio.ch.IOStatus;\n@@ -35,0 +40,2 @@\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n@@ -43,0 +50,6 @@\n+    \/\/ minimum size of a temporary direct buffer\n+    private static final int MIN_BUFFER_SIZE = 16384;\n+\n+    \/\/ whether direct copying is supported on this platform\n+    private static volatile boolean directCopyNotSupported;\n+\n@@ -124,0 +137,154 @@\n+    \/\/ calculate the least common multiple of two values;\n+    \/\/ the parameters in general will be powers of two likely in the\n+    \/\/ range [4096, 65536] so this algorithm is expected to converge\n+    \/\/ when it is rarely called\n+    private static long lcm(long x, long y) {\n+        assert x > 0 && y > 0 : \"Non-positive parameter\";\n+\n+        long u = x;\n+        long v = y;\n+\n+        while (u != v) {\n+            if (u < v)\n+                u += x;\n+            else \/\/ u > v\n+                v += y;\n+        }\n+\n+        return u;\n+    }\n+\n+    \/\/ calculate temporary direct buffer size\n+    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n+        int bufferSize = MIN_BUFFER_SIZE;\n+        try {\n+            long bss = UnixFileStoreAttributes.get(source).blockSize();\n+            long bst = UnixFileStoreAttributes.get(target).blockSize();\n+            if (bss > 0 && bst > 0) {\n+                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n+            }\n+            if (bufferSize < MIN_BUFFER_SIZE) {\n+                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n+                bufferSize *= factor;\n+            }\n+        } catch (UnixException ignored) {\n+        }\n+        return bufferSize;\n+    }\n+\n+    \/\/ copy regular file from source to target\n+    protected void copyFile(UnixPath source,\n+                            UnixFileAttributes attrs,\n+                            UnixPath  target,\n+                            UnixCopyFile.Flags flags,\n+                            long addressToPollForCancel)\n+        throws IOException\n+    {\n+        int fi = -1;\n+        try {\n+            fi = open(source, O_RDONLY, 0);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(source);\n+        }\n+\n+        try {\n+            \/\/ open new file\n+            int fo = -1;\n+            try {\n+                fo = open(target,\n+                           (O_WRONLY |\n+                            O_CREAT |\n+                            O_EXCL),\n+                           attrs.mode());\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(target);\n+            }\n+\n+            \/\/ set to true when file and attributes copied\n+            boolean complete = false;\n+            try {\n+                boolean copied = false;\n+                if (!directCopyNotSupported) {\n+                    \/\/ copy bytes to target using platform function\n+                    long comp = Blocker.begin();\n+                    try {\n+                        int res = directCopy(fo, fi, addressToPollForCancel);\n+                        if (res == 0) {\n+                            copied = true;\n+                        } else if (res == IOStatus.UNSUPPORTED) {\n+                            directCopyNotSupported = true;\n+                        }\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(source, target);\n+                    } finally {\n+                        Blocker.end(comp);\n+                    }\n+                }\n+\n+                if (!copied) {\n+                    \/\/ copy bytes to target via a temporary direct buffer\n+                    int bufferSize = temporaryBufferSize(source, target);\n+                    ByteBuffer buf =\n+                        sun.nio.ch.Util.getTemporaryDirectBuffer(bufferSize);\n+                    try {\n+                        long comp = Blocker.begin();\n+                        try {\n+                            bufferedCopy(fo, fi, ((DirectBuffer)buf).address(),\n+                                          bufferSize, addressToPollForCancel);\n+                        } catch (UnixException x) {\n+                            x.rethrowAsIOException(source, target);\n+                        } finally {\n+                            Blocker.end(comp);\n+                        }\n+                    } finally {\n+                        sun.nio.ch.Util.releaseTemporaryDirectBuffer(buf);\n+                    }\n+                }\n+\n+                \/\/ copy owner\/permissions\n+                if (flags.copyPosixAttributes) {\n+                    try {\n+                        fchown(fo, attrs.uid(), attrs.gid());\n+                        fchmod(fo, attrs.mode());\n+                    } catch (UnixException x) {\n+                        if (flags.failIfUnableToCopyPosix)\n+                            x.rethrowAsIOException(target);\n+                    }\n+                }\n+                \/\/ copy non POSIX attributes (depends on file system)\n+                if (flags.copyNonPosixAttributes) {\n+                    source.getFileSystem().copyNonPosixAttributes(fi, fo);\n+                }\n+                \/\/ copy time attributes\n+                if (flags.copyBasicAttributes) {\n+                    try {\n+                        if (futimesSupported()) {\n+                            futimes(fo,\n+                                    attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                                    attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                        } else {\n+                            utimes(target,\n+                                   attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                                   attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                        }\n+                    } catch (UnixException x) {\n+                        if (flags.failIfUnableToCopyBasic)\n+                            x.rethrowAsIOException(target);\n+                    }\n+                }\n+                complete = true;\n+            } finally {\n+                UnixNativeDispatcher.close(fo, e -> null);\n+\n+                \/\/ copy of file or attributes failed so rollback\n+                if (!complete) {\n+                    try {\n+                        unlink(target);\n+                    } catch (UnixException ignore) { }\n+                }\n+            }\n+        } finally {\n+            UnixNativeDispatcher.close(fi, e -> null);\n+        }\n+    }\n+\n@@ -358,0 +525,45 @@\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, IOStatus.UNAVAILABLE if the platform function\n+     *         would block, IOStatus.UNSUPPORTED_CASE if the call does not\n+     *         work with the given parameters, or IOStatus.UNSUPPORTED if\n+     *         direct copying is not supported on this platform\n+     *\/\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * an intermediate temporary direct buffer.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param address the address of the temporary direct buffer's array\n+     * @param size the size of the temporary direct buffer's array\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\/\n+    protected void bufferedCopy(int dst, int src, long address,\n+                                int size, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        bufferedCopy0(dst, src, address, size, addressToPollForCancel);\n+    }\n+\n+    \/\/ -- native methods --\n+\n+    private static native void bufferedCopy0(int dst, int src, long address,\n+                                             int size, long addressToPollForCancel)\n+        throws UnixException;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jlong.h\"\n-\n-#include \"nio.h\"\n-\n-#include <stdlib.h>\n-#include <unistd.h>\n-#include <errno.h>\n-\n-#if defined(__linux__)\n-#include <sys\/sendfile.h>\n-#include <fcntl.h>\n-#elif defined(_ALLBSD_SOURCE)\n-#include <copyfile.h>\n-#endif\n-#include \"sun_nio_fs_UnixCopyFile.h\"\n-\n-#define RESTARTABLE(_cmd, _result) do { \\\n-  do { \\\n-    _result = _cmd; \\\n-  } while((_result == -1) && (errno == EINTR)); \\\n-} while(0)\n-\n-static void throwUnixException(JNIEnv* env, int errnum) {\n-    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n-        \"(I)V\", errnum);\n-    if (x != NULL) {\n-        (*env)->Throw(env, x);\n-    }\n-}\n-\n-#if defined(_ALLBSD_SOURCE)\n-int fcopyfile_callback(int what, int stage, copyfile_state_t state,\n-    const char* src, const char* dst, void* cancel)\n-{\n-    if (what == COPYFILE_COPY_DATA) {\n-        if (stage == COPYFILE_ERR\n-                || (stage == COPYFILE_PROGRESS && *((int*)cancel) != 0)) {\n-            \/\/ errno will be set to ECANCELED if the operation is cancelled,\n-            \/\/ or to the appropriate error number if there is an error,\n-            \/\/ but in either case we need to quit.\n-            return COPYFILE_QUIT;\n-        }\n-    }\n-    return COPYFILE_CONTINUE;\n-}\n-#endif\n-\n-\/\/ Copy via an intermediate temporary direct buffer\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_UnixCopyFile_bufferedCopy0\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong address,\n-    jint transferSize, jlong cancelAddress)\n-{\n-    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n-\n-    char* buf = (char*)jlong_to_ptr(address);\n-\n-#if defined(__linux__)\n-    int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n-                 POSIX_FADV_NOREUSE    | \/\/ will access only once\n-                 POSIX_FADV_WILLNEED;    \/\/ will access in near future\n-\n-    \/\/ ignore the return value hence any failure\n-    posix_fadvise(src, 0, 0, advice);\n-#endif\n-\n-    for (;;) {\n-        ssize_t n, pos, len;\n-        RESTARTABLE(read((int)src, buf, transferSize), n);\n-        if (n <= 0) {\n-            if (n < 0)\n-                throwUnixException(env, errno);\n-            return;\n-        }\n-        if (cancel != NULL && *cancel != 0) {\n-            throwUnixException(env, ECANCELED);\n-            return;\n-        }\n-        pos = 0;\n-        len = n;\n-        do {\n-            char* bufp = buf;\n-            bufp += pos;\n-            RESTARTABLE(write((int)dst, bufp, len), n);\n-            if (n == -1) {\n-                throwUnixException(env, errno);\n-                return;\n-            }\n-            pos += n;\n-            len -= n;\n-        } while (len > 0);\n-    }\n-}\n-\n-\/\/ Copy all bytes from src to dst, within the kernel if possible (Linux),\n-\/\/ and return zero, otherwise return the appropriate status code.\n-\/\/\n-\/\/ Return value\n-\/\/   0 on success\n-\/\/   IOS_UNAVAILABLE if the platform function would block\n-\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n-\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n-\/\/   IOS_THROWN if a Java exception is thrown\n-\/\/\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_UnixCopyFile_directCopy0\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n-{\n-    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n-\n-#if defined(__linux__)\n-    \/\/ Transfer within the kernel\n-    const size_t count = cancel != NULL ?\n-        1048576 :   \/\/ 1 MB to give cancellation a chance\n-        0x7ffff000; \/\/ maximum number of bytes that sendfile() can transfer\n-    ssize_t bytes_sent;\n-    do {\n-        RESTARTABLE(sendfile64(dst, src, NULL, count), bytes_sent);\n-        if (bytes_sent < 0) {\n-            if (errno == EAGAIN)\n-                return IOS_UNAVAILABLE;\n-            if (errno == EINVAL || errno == ENOSYS)\n-                return IOS_UNSUPPORTED_CASE;\n-            throwUnixException(env, errno);\n-            return IOS_THROWN;\n-        }\n-        if (cancel != NULL && *cancel != 0) {\n-            throwUnixException(env, ECANCELED);\n-            return IOS_THROWN;\n-        }\n-    } while (bytes_sent > 0);\n-\n-    return 0;\n-#elif defined(_ALLBSD_SOURCE)\n-    copyfile_state_t state;\n-    if (cancel != NULL) {\n-        state = copyfile_state_alloc();\n-        copyfile_state_set(state, COPYFILE_STATE_STATUS_CB, fcopyfile_callback);\n-        copyfile_state_set(state, COPYFILE_STATE_STATUS_CTX, (void*)cancel);\n-    } else {\n-        state = NULL;\n-    }\n-    if (fcopyfile(src, dst, state, COPYFILE_DATA) < 0) {\n-        int errno_fcopyfile = errno;\n-        if (state != NULL)\n-            copyfile_state_free(state);\n-        throwUnixException(env, errno_fcopyfile);\n-        return IOS_THROWN;\n-    }\n-    if (state != NULL)\n-        copyfile_state_free(state);\n-\n-    return 0;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+\/\/ Copy via an intermediate temporary direct buffer\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixFileSystem_bufferedCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong address,\n+     jint transferSize, jlong cancelAddress)\n+{\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    char* buf = (char*)jlong_to_ptr(address);\n+\n+    for (;;) {\n+        ssize_t n, pos, len;\n+        RESTARTABLE(read((int)src, buf, transferSize), n);\n+        if (n <= 0) {\n+            if (n < 0)\n+                throwUnixException(env, errno);\n+            return;\n+        }\n+        if (cancel != NULL && *cancel != 0) {\n+            throwUnixException(env, ECANCELED);\n+            return;\n+        }\n+        pos = 0;\n+        len = n;\n+        do {\n+            char* bufp = buf;\n+            bufp += pos;\n+            RESTARTABLE(write((int)dst, bufp, len), n);\n+            if (n == -1) {\n+                throwUnixException(env, errno);\n+                return;\n+            }\n+            pos += n;\n+            len -= n;\n+        } while (len > 0);\n+    }\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixFileSystem.c","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8267820\n+ * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8264744 8267820\n@@ -43,0 +43,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -47,0 +49,5 @@\n+    \/\/ File system types that support copy-on-write (CoW)\n+    \/\/ for testing cloning \/ reflink on Linux\n+    private static final Set<String> COW_TYPES =\n+        Set.of(\"bcachefs\", \"btrfs\", \"ocfs2\", \"xfs\");\n+\n@@ -48,1 +55,0 @@\n-    static boolean heads() { return rand.nextBoolean(); }\n@@ -51,0 +57,44 @@\n+    static boolean heads() { return rand.nextBoolean(); }\n+\n+    \/**\n+     * Returns the secondary test directory as a path name string.\n+     * If the system property \"test.dir\" is definied it is returned.\n+     * Otherwise, if the platform is not Linux, the current directory\n+     * \".\" is returned. If the platform is Linux, then the first\n+     * located top level directory which supports CoW is returned. If\n+     * there is no such directory then \".\" is returned.\n+     *\n+     * @return the path string of the secondary test directory\n+     *\/\n+    private static final String getTestDir() {\n+        final String dot = \".\";\n+        if (!Platform.isLinux()) {\n+            return System.getProperty(\"test.dir\", dot);\n+        }\n+\n+        String testDir = System.getProperty(\"test.dir\");\n+        if (testDir != null) {\n+            return testDir;\n+        }\n+\n+        final Path dotPath = Path.of(dot);\n+        try {\n+            if (COW_TYPES.contains(getFileStore(dotPath).type().toLowerCase())) {\n+                return dot;\n+            }\n+        } catch (IOException ignored) {\n+        }\n+\n+        Spliterator<FileStore> spfs =\n+            FileSystems.getDefault().getFileStores().spliterator();\n+        Stream<FileStore> sfs = StreamSupport.stream(spfs, false);\n+        return sfs.filter(fs -> !fs.isReadOnly() &&\n+                                COW_TYPES.contains(fs.type().toLowerCase()))\n+                  .map(fs -> fs.toString().split(\" \")[0])\n+                  .map(s -> Path.of(s))\n+                  .filter(d -> Files.exists(d) && Files.isDirectory(d))\n+                  .findFirst()\n+                  .orElse(dotPath)\n+                  .toString();\n+    }\n+\n@@ -62,3 +112,3 @@\n-            \/\/ Different directories. Use test.dir if possible as it might be\n-            \/\/ a different volume\/file system and so improve test coverage.\n-            String testDir = System.getProperty(\"test.dir\", \".\");\n+            \/\/ Use test.dir to define second directory if possible as it might\n+            \/\/ be a different volume\/file system and so improve test coverage.\n+            String testDir = getTestDir();\n@@ -66,0 +116,16 @@\n+            FileStore fileStore2 = getFileStore(dir2);\n+\n+            \/\/ If different type (format) from dir1, re-do same directory tests\n+            if (!fileStore1.type().equals(fileStore2.type())) {\n+                try {\n+                    printDirInfo(\"dir2\", dir2, fileStore2);\n+                    testPosixAttributes =\n+                        fileStore2.supportsFileAttributeView(\"posix\");\n+                    testCopyFileToFile(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                    testMove(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                } finally {\n+                    TestUtil.removeAll(dir2);\n+                }\n+            }\n+\n+            \/\/ Different directories.\n@@ -67,0 +133,4 @@\n+                \/\/ Recreate dir2 if it was removed above\n+                if (notExists(dir2)) {\n+                    dir2 = TestUtil.createTemporaryDirectory(testDir);\n+                }\n@@ -69,1 +139,0 @@\n-                FileStore fileStore2 = getFileStore(dir2);\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":75,"deletions":6,"binary":false,"changes":81,"status":"modified"}]}