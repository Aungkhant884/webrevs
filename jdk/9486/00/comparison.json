{"files":[{"patch":"@@ -265,0 +265,3 @@\n+    \/\/ whether file cloning is supported on this platform\n+    private static volatile boolean cloneFileNotSupported;\n+\n@@ -276,0 +279,26 @@\n+        boolean copied = false;\n+        if (addressToPollForCancel == 0 &&\n+            source.getFileSystem() == target.getFileSystem() &&\n+            !cloneFileNotSupported) {\n+            try (NativeBuffer sourceBuffer = copyToNativeBuffer(source);\n+                NativeBuffer targetBuffer = copyToNativeBuffer(target)) {\n+                long comp = Blocker.begin();\n+                try {\n+                    int res = cloneFile0(sourceBuffer.address(),\n+                                         targetBuffer.address(),\n+                                         flags.followLinks);\n+                    if (res == 0) {\n+                        copied = true;\n+                    }\n+                    if (res == IOStatus.UNSUPPORTED) {\n+                        cloneFileNotSupported = true;\n+                    }\n+                    \/\/ other IOStatus values: fall through\n+                } catch (UnixException x) {\n+                    x.rethrowAsIOException(source, target);\n+                } finally {\n+                    Blocker.end(comp);\n+                }\n+            }\n+        }\n+\n@@ -288,0 +317,2 @@\n+                           copied ? \/\/ copied == true => target already exists\n+                           O_WRONLY :\n@@ -299,2 +330,1 @@\n-                boolean copied = false;\n-                if (!directCopyNotSupported) {\n+                if (!copied && !directCopyNotSupported) {\n@@ -705,0 +735,16 @@\n+    \/**\n+     * Clones the file whose path name address is {@code src} to that whose\n+     * path name address is {@code dst} using a platform-specific system call.\n+     *\n+     * @param sourceAddress the path address of the source file\n+     * @param targetAddres the path address of the target file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, UNSUPPORTED_CASE if the call does not work with\n+     *         the given parameters, or UNSUPPORTED if cloning is not supported\n+     *         on this platform\n+     *\/\n+    private static native int cloneFile0(long sourceAddress, long targetAddres,\n+                                         boolean followLinks)\n+        throws UnixException;\n+\n@@ -739,0 +785,2 @@\n+    private static native void init();\n+\n@@ -741,0 +789,1 @@\n+        init();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -179,1 +179,21 @@\n-    jlong n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+\n+    jlong n;\n+    if (my_copy_file_range_func != NULL) {\n+        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, count, 0);\n+        if (n < 0) {\n+            switch (errno) {\n+                case EINTR:\n+                case EINVAL:\n+                case EXDEV:\n+                    \/\/ ignore and try sendfile()\n+                    break;\n+                default:\n+                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                    return IOS_THROWN;\n+            }\n+        }\n+        if (n >= 0)\n+            return n;\n+    }\n+\n+    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#include <dlfcn.h>\n+#include <linux\/fs.h>\n+#include <sys\/ioctl.h>\n@@ -41,0 +44,2 @@\n+#include <sys\/attr.h>\n+#include <sys\/clonefile.h>\n@@ -44,0 +49,10 @@\n+#ifndef FICLONE\n+#define FICLONE      1074041865\n+#endif\n+\n+#if defined(__linux__)\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+#endif\n+\n@@ -58,0 +73,10 @@\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixCopyFile_init\n+    (JNIEnv* env, jclass this)\n+{\n+#if defined(__linux__)\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+#endif\n+}\n+\n@@ -75,0 +100,87 @@\n+\/\/ Copy via file cloning\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_UnixCopyFile_cloneFile0\n+    (JNIEnv* env, jclass this, jlong sourceAddress, jlong targetAddress,\n+     jboolean followLinks)\n+{\n+    const char* src = (const char*)jlong_to_ptr(sourceAddress);\n+    const char* dst = (const char*)jlong_to_ptr(targetAddress);\n+\n+#if defined(_ALLBSD_SOURCE)\n+    int flags = followLinks == JNI_FALSE ? CLONE_NOFOLLOW : 0;\n+    int res = clonefile(src, dst, flags);\n+    if (res < 0) {\n+        if (errno == ENOTSUP) { \/\/ cloning not supported by filesystem\n+            \/\/ disable further attempts to clone in this instance\n+            return IOS_UNSUPPORTED;\n+        } else if (errno == EXDEV   || \/\/ src and dst on different filesystems\n+                   errno == ENOTDIR) { \/\/ problematic path parameter(s)\n+            \/\/ cannot clone: fall back to direct or buffered copy\n+            return IOS_UNSUPPORTED_CASE;\n+        } else {\n+            \/\/ unrecoverable errors\n+            throwUnixException(env, errno);\n+            return IOS_THROWN;\n+        }\n+    }\n+    return 0;\n+#elif defined(__linux__)\n+    \/\/ disable ioctl_ficlone if copy_file_range() is available\n+    if (my_copy_file_range_func != NULL) {\n+        return IOS_UNSUPPORTED;\n+    }\n+\n+    int srcFD = open(src, O_RDONLY);\n+    if (srcFD < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Open src failed\");\n+        return IOS_THROWN;\n+    }\n+    int dstFD = open(dst, O_CREAT | O_WRONLY, 0666);\n+    if (dstFD < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Open dst failed\");\n+        close(srcFD);\n+        return IOS_THROWN;\n+    }\n+\n+    int res = ioctl(dstFD, FICLONE, srcFD);\n+    const int errno_ioctl = errno;\n+\n+    \/\/ ignore close errors\n+    close(srcFD);\n+    close(dstFD);\n+\n+    if (res != -1) {\n+        return 0;\n+    }\n+\n+    if (errno_ioctl == EPERM) {\n+        \/\/ dst is immutable\n+        throwUnixException(env, errno_ioctl);\n+        return IOS_THROWN;\n+    }\n+\n+    \/\/ delete dst to avoid later exception when re-creating in Java layer\n+    if (access(dst, F_OK) == 0) {\n+        if (unlink(dst) != 0) {\n+            const int errno_unlink = errno;\n+            if (access(dst, F_OK) == 0) {\n+                throwUnixException(env, errno_unlink);\n+                return IOS_THROWN;\n+            }\n+        }\n+    }\n+\n+    if (errno_ioctl == EINVAL) {\n+        \/\/ interpret EINVAL as indicating that FICLONE is an invalid\n+        \/\/ ioctl request code hence unsupported on this platform;\n+        \/\/ disable ioctl_ficlone\n+        return IOS_UNSUPPORTED;\n+    }\n+\n+    \/\/ cannot clone: fall back to direct or buffered copy\n+    return IOS_UNSUPPORTED_CASE;\n+#else\n+    return IOS_UNSUPPORTED;\n+#endif\n+}\n+\n@@ -144,0 +256,26 @@\n+\n+    if (my_copy_file_range_func != NULL) {\n+        do {\n+            RESTARTABLE(my_copy_file_range_func(src, NULL, dst, NULL, count, 0),\n+                                                bytes_sent);\n+            if (bytes_sent < 0) {\n+                switch (errno) {\n+                    case EINVAL:\n+                    case EXDEV:\n+                        \/\/ ignore and try sendfile()\n+                        break;\n+                    default:\n+                        JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                        return IOS_THROWN;\n+                }\n+            }\n+            if (cancel != NULL && *cancel != 0) {\n+                throwUnixException(env, ECANCELED);\n+                return IOS_THROWN;\n+            }\n+        } while (bytes_sent > 0);\n+\n+        if (bytes_sent == 0)\n+            return 0;\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":138,"deletions":0,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8267820\n+ * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8264744 8267820\n@@ -43,0 +43,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -47,0 +49,5 @@\n+    \/\/ File system types that support copy-on-write (CoW)\n+    \/\/ for testing cloning \/ reflink on Linux\n+    private static final Set<String> COW_TYPES =\n+        Set.of(\"bcachefs\", \"btrfs\", \"ocfs2\", \"xfs\");\n+\n@@ -48,1 +55,0 @@\n-    static boolean heads() { return rand.nextBoolean(); }\n@@ -51,0 +57,44 @@\n+    static boolean heads() { return rand.nextBoolean(); }\n+\n+    \/**\n+     * Returns the secondary test directory as a path name string.\n+     * If the system property \"test.dir\" is definied it is returned.\n+     * Otherwise, if the platform is not Linux, the current directory\n+     * \".\" is returned. If the platform is Linux, then the first\n+     * located top level directory which supports CoW is returned. If\n+     * there is no such directory then \".\" is returned.\n+     *\n+     * @return the path string of the secondary test directory\n+     *\/\n+    private static final String getTestDir() {\n+        final String dot = \".\";\n+        if (!Platform.isLinux()) {\n+            return System.getProperty(\"test.dir\", dot);\n+        }\n+\n+        String testDir = System.getProperty(\"test.dir\");\n+        if (testDir != null) {\n+            return testDir;\n+        }\n+\n+        final Path dotPath = Path.of(dot);\n+        try {\n+            if (COW_TYPES.contains(getFileStore(dotPath).type().toLowerCase())) {\n+                return dot;\n+            }\n+        } catch (IOException ignored) {\n+        }\n+\n+        Spliterator<FileStore> spfs =\n+            FileSystems.getDefault().getFileStores().spliterator();\n+        Stream<FileStore> sfs = StreamSupport.stream(spfs, false);\n+        return sfs.filter(fs -> !fs.isReadOnly() &&\n+                                COW_TYPES.contains(fs.type().toLowerCase()))\n+                  .map(fs -> fs.toString().split(\" \")[0])\n+                  .map(s -> Path.of(s))\n+                  .filter(d -> Files.exists(d) && Files.isDirectory(d))\n+                  .findFirst()\n+                  .orElse(dotPath)\n+                  .toString();\n+    }\n+\n@@ -62,3 +112,3 @@\n-            \/\/ Different directories. Use test.dir if possible as it might be\n-            \/\/ a different volume\/file system and so improve test coverage.\n-            String testDir = System.getProperty(\"test.dir\", \".\");\n+            \/\/ Use test.dir to define second directory if possible as it might\n+            \/\/ be a different volume\/file system and so improve test coverage.\n+            String testDir = getTestDir();\n@@ -66,0 +116,16 @@\n+            FileStore fileStore2 = getFileStore(dir2);\n+\n+            \/\/ If different type (format) from dir1, re-do same directory tests\n+            if (!fileStore1.type().equals(fileStore2.type())) {\n+                try {\n+                    printDirInfo(\"dir2\", dir2, fileStore2);\n+                    testPosixAttributes =\n+                        fileStore2.supportsFileAttributeView(\"posix\");\n+                    testCopyFileToFile(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                    testMove(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                } finally {\n+                    TestUtil.removeAll(dir2);\n+                }\n+            }\n+\n+            \/\/ Different directories.\n@@ -67,0 +133,4 @@\n+                \/\/ Recreate dir2 if it was removed above\n+                if (notExists(dir2)) {\n+                    dir2 = TestUtil.createTemporaryDirectory(testDir);\n+                }\n@@ -69,1 +139,0 @@\n-                FileStore fileStore2 = getFileStore(dir2);\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":75,"deletions":6,"binary":false,"changes":81,"status":"modified"}]}