{"files":[{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import java.io.IOException;\n+import sun.nio.ch.IOStatus;\n+\n+\/**\n+ * Implements a {@code clone) method for use by {@code UnixCopyFile} on AIX.\n+ *\/\n+final class CloneFile {\n+    private CloneFile() { }\n+\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using a platform-specific system call.\n+     *\n+     * @implSpec\n+     * The implementation in this class always returns\n+     * {@code IOStatus.UNSUPPORTED}.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the desintation file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, IOStatus.UNSUPPORTED_CASE if the call does not work\n+     *         with the given parameters, or IOStatus.UNSUPPORTED if cloning is\n+     *         not supported on this platform\n+     *\/\n+    static int clone(UnixPath src, UnixPath dst, boolean followLinks)\n+        throws IOException {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+}\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/fs\/CloneFile.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import java.io.IOException;\n+import sun.nio.ch.IOStatus;\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n+\n+\/**\n+ * Implements a {@code clone) method for use by {@code UnixCopyFile} on Linux.\n+ *\/\n+final class CloneFile {\n+    private CloneFile() { }\n+\n+    private static UnixException catEx(UnixException x, UnixException y) {\n+        assert x != null || y != null;\n+        UnixException ue = y;\n+        if (x != null) {\n+            ue = x;\n+            if (y != null) {\n+                ue.addSuppressed(y);\n+            }\n+        }\n+        return ue;\n+    }\n+\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using the {@code ioctl} system call with the\n+     * {@code FICLONE} request code.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the desintation file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, IOStatus.UNSUPPORTED_CASE if the call does not work\n+     *         with the given parameters, or IOStatus.UNSUPPORTED if cloning is\n+     *         not supported on this platform\n+     *\/\n+    static int clone(UnixPath src, UnixPath dst, boolean followLinks)\n+        throws IOException {\n+        int srcFD = 0;\n+        try {\n+            srcFD = open(src, O_RDONLY, 0);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(src);\n+            return IOStatus.THROWN;\n+        }\n+\n+        int dstFD = 0;\n+        try {\n+            dstFD = open(dst, O_CREAT | O_WRONLY, 0666);\n+        } catch (UnixException x) {\n+            try {\n+                close(srcFD);\n+            } catch (UnixException y) {\n+                catEx(x, y).rethrowAsIOException(src, dst);\n+                return IOStatus.THROWN;\n+            }\n+            x.rethrowAsIOException(dst);\n+            return IOStatus.THROWN;\n+        }\n+\n+        UnixException ioctlEx = null;\n+        int result;\n+        try {\n+            result = LinuxNativeDispatcher.ioctl_ficlone(dstFD, srcFD);\n+        } catch (UnixException x) {\n+            switch (x.errno()) {\n+                case EINVAL:\n+                    result = IOStatus.UNSUPPORTED;\n+                    break;\n+                case EPERM:\n+                    ioctlEx = x;\n+                    result = IOStatus.THROWN;\n+                    break;\n+                default:\n+                    result = IOStatus.UNSUPPORTED_CASE;\n+                    break;\n+            }\n+        }\n+\n+        UnixException ue = ioctlEx;\n+        UnixPath s = null;\n+        UnixPath d = null;\n+\n+        try {\n+            close(dstFD);\n+        } catch (UnixException x) {\n+            ue = catEx(ue, x);\n+            d = dst;\n+        }\n+\n+        \/\/ delete dst to avoid later exception in Java layer\n+        if (result != 0) {\n+            try {\n+                unlink(dst);\n+            } catch (UnixException x) {\n+                ue = catEx(ue, x);\n+                d = dst;\n+            }\n+        }\n+\n+        try {\n+            close(srcFD);\n+        } catch (UnixException x) {\n+            ue = catEx(ue, x);\n+            s = src;\n+        }\n+\n+        if (ue != null) {\n+            if (ioctlEx != null)\n+                throw new IOException(ioctlEx.errorString(), ioctlEx);\n+            else if (s != null && d != null)\n+                ue.rethrowAsIOException(s, d);\n+            else\n+                ue.rethrowAsIOException(s != null ? s : d);\n+            return IOStatus.THROWN;\n+        }\n+\n+        return result;\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/CloneFile.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.misc.Blocker;\n+\n@@ -72,0 +74,14 @@\n+    \/**\n+     * int ioctl(int dest_fd, FICLONE, int src_fd);\n+     *\/\n+    static int ioctl_ficlone(int dst, int src) throws UnixException {\n+        long comp = Blocker.begin();\n+        try {\n+            return ioctl_ficlone0(dst, src);\n+        } finally {\n+            Blocker.end(comp);\n+        }\n+    }\n+    private static native int ioctl_ficlone0(int dst, int src)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include <linux\/fs.h>\n+#include <sys\/ioctl.h>\n@@ -39,0 +41,4 @@\n+#ifndef FICLONE\n+#define FICLONE      1074041865\n+#endif\n+\n@@ -145,0 +151,14 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxNativeDispatcher_ioctl_1ficlone0(JNIEnv* env, jclass this,\n+    jint dst, jint src)\n+{\n+    int ret = ioctl(dst, FICLONE, src);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.misc.Blocker;\n+\n@@ -65,0 +67,24 @@\n+    \/**\n+     * int clonefile(const char * src, const char * dst, int flags);\n+     *\/\n+    static int clonefile(UnixPath src, UnixPath dst, int flags)\n+        throws UnixException {\n+        if (src.getFileSystem() == dst.getFileSystem()) {\n+            try (NativeBuffer srcBuffer = copyToNativeBuffer(src);\n+                NativeBuffer dstBuffer = copyToNativeBuffer(dst)) {\n+                long comp = Blocker.begin();\n+                try {\n+                    return clonefile0(srcBuffer.address(), dstBuffer.address(),\n+                                      flags);\n+                } finally {\n+                    Blocker.end(comp);\n+                }\n+            }\n+        }\n+\n+        return -1;\n+    }\n+    private static native int clonefile0(long srcAddress, long dstAddress,\n+                                         int flags)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import java.io.IOException;\n+import sun.nio.ch.IOStatus;\n+import static sun.nio.fs.UnixConstants.*;\n+\n+\/**\n+ * Implements a {@code clone) method for use by {@code UnixCopyFile} on macOS.\n+ *\/\n+final class CloneFile {\n+    private CloneFile() { }\n+\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using the {@code clonefile} system call.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the desintation file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, IOStatus.UNSUPPORTED_CASE if the call does not work\n+     *         with the given parameters, or IOStatus.UNSUPPORTED if cloning is\n+     *         not supported on this platform\n+     *\/\n+    static int clone(UnixPath src, UnixPath dst, boolean followLinks)\n+        throws IOException {\n+        int flags = followLinks ? 0 : CLONE_NOFOLLOW;\n+        try {\n+            return BsdNativeDispatcher.clonefile(src, dst, flags);\n+        } catch (UnixException x) {\n+            switch (x.errno()) {\n+                case ENOTSUP: \/\/ cloning not supported by filesystem\n+                    return IOStatus.UNSUPPORTED;\n+                case EXDEV:   \/\/ src and dst on different filesystems\n+                case ENOTDIR: \/\/ problematic path parameter(s)\n+                    return IOStatus.UNSUPPORTED_CASE;\n+                default:\n+                    x.rethrowAsIOException(src, dst);\n+                    return IOStatus.THROWN;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/CloneFile.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -44,0 +44,2 @@\n+#include <sys\/attr.h>\n+#include <sys\/clonefile.h>\n@@ -226,0 +228,16 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_clonefile0(JNIEnv* env, jclass this,\n+    jlong srcAddress, jlong dstAddress, int flags)\n+{\n+    const char* src = (const char*)jlong_to_ptr(srcAddress);\n+    const char* dst = (const char*)jlong_to_ptr(dstAddress);\n+\n+    int ret = clonefile(src, dst, flags);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+#ifdef _ALLBSD_SOURCE\n+#include <sys\/clonefile.h>\n+#endif\n@@ -133,0 +136,8 @@\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_ENOTSUP = ENOTSUP;\n+#endif\n+\n+#ifdef __linux__\n+    static final int PREFIX_EPERM = EPERM;\n+#endif\n+\n@@ -143,0 +154,5 @@\n+#ifdef _ALLBSD_SOURCE\n+    \/\/ flags used with clonefile(2)\n+    static final int PREFIX_CLONE_NOFOLLOW = CLONE_NOFOLLOW;\n+    static final int PREFIX_CLONE_NOOWNERCOPY = CLONE_NOOWNERCOPY;\n+#endif\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -265,0 +265,3 @@\n+    \/\/ whether file cloning is supported on this platform\n+    private static volatile boolean cloneFileNotSupported;\n+\n@@ -276,0 +279,11 @@\n+        boolean copied = false;\n+        if (addressToPollForCancel == 0 && !cloneFileNotSupported) {\n+            int res = CloneFile.clone(source, target, flags.followLinks);\n+            if (res == 0) {\n+                copied = true;\n+            }\n+            if (res == IOStatus.UNSUPPORTED) {\n+                cloneFileNotSupported = true;\n+            }\n+        }\n+\n@@ -288,0 +302,2 @@\n+                           copied ? \/\/ copied == true => target already exists\n+                           O_WRONLY :\n@@ -299,2 +315,1 @@\n-                boolean copied = false;\n-                if (!directCopyNotSupported) {\n+                if (!copied && !directCopyNotSupported) {\n@@ -715,4 +730,4 @@\n-     * @return 0 on success, UNAVAILABLE if the platform function would block,\n-     *         UNSUPPORTED_CASE if the call does not work with the given\n-     *         parameters, or UNSUPPORTED if direct copying is not supported\n-     *         on this platform\n+     * @return 0 on success, IOStatus.UNAVAILABLE if the platform function\n+     *         would block, IOStatus.UNSUPPORTED_CASE if the call does not\n+     *         work with the given parameters, or IOStatus.UNSUPPORTED if\n+     *         direct copying is not supported on this platform\n@@ -739,0 +754,2 @@\n+    private static native void init();\n+\n@@ -741,0 +758,1 @@\n+        init();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -179,1 +179,21 @@\n-    jlong n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+\n+    jlong n;\n+    if (my_copy_file_range_func != NULL) {\n+        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, count, 0);\n+        if (n < 0) {\n+            switch (errno) {\n+                case EINTR:\n+                case EINVAL:\n+                case EXDEV:\n+                    \/\/ ignore and try sendfile()\n+                    break;\n+                default:\n+                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                    return IOS_THROWN;\n+            }\n+        }\n+        if (n >= 0)\n+            return n;\n+    }\n+\n+    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include <dlfcn.h>\n@@ -44,0 +45,6 @@\n+#if defined(__linux__)\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+#endif\n+\n@@ -58,0 +65,10 @@\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixCopyFile_init\n+    (JNIEnv* env, jclass this)\n+{\n+#if defined(__linux__)\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+#endif\n+}\n+\n@@ -144,0 +161,26 @@\n+\n+    if (my_copy_file_range_func != NULL) {\n+        do {\n+            RESTARTABLE(my_copy_file_range_func(src, NULL, dst, NULL, count, 0),\n+                                                bytes_sent);\n+            if (bytes_sent < 0) {\n+                switch (errno) {\n+                    case EINVAL:\n+                    case EXDEV:\n+                        \/\/ ignore and try sendfile()\n+                        break;\n+                    default:\n+                        JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                        return IOS_THROWN;\n+                }\n+            }\n+            if (cancel != NULL && *cancel != 0) {\n+                throwUnixException(env, ECANCELED);\n+                return IOS_THROWN;\n+            }\n+        } while (bytes_sent > 0);\n+\n+        if (bytes_sent == 0)\n+            return 0;\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8267820\n+ * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8264744 8267820\n@@ -43,0 +43,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -47,0 +49,5 @@\n+    \/\/ File system types that support copy-on-write (CoW)\n+    \/\/ for testing cloning \/ reflink on Linux\n+    private static final Set<String> COW_TYPES =\n+        Set.of(\"bcachefs\", \"btrfs\", \"ocfs2\", \"xfs\");\n+\n@@ -48,1 +55,0 @@\n-    static boolean heads() { return rand.nextBoolean(); }\n@@ -51,0 +57,44 @@\n+    static boolean heads() { return rand.nextBoolean(); }\n+\n+    \/**\n+     * Returns the secondary test directory as a path name string.\n+     * If the system property \"test.dir\" is definied it is returned.\n+     * Otherwise, if the platform is not Linux, the current directory\n+     * \".\" is returned. If the platform is Linux, then the first\n+     * located top level directory which supports CoW is returned. If\n+     * there is no such directory then \".\" is returned.\n+     *\n+     * @return the path string of the secondary test directory\n+     *\/\n+    private static final String getTestDir() {\n+        final String dot = \".\";\n+        if (!Platform.isLinux()) {\n+            return System.getProperty(\"test.dir\", dot);\n+        }\n+\n+        String testDir = System.getProperty(\"test.dir\");\n+        if (testDir != null) {\n+            return testDir;\n+        }\n+\n+        final Path dotPath = Path.of(dot);\n+        try {\n+            if (COW_TYPES.contains(getFileStore(dotPath).type().toLowerCase())) {\n+                return dot;\n+            }\n+        } catch (IOException ignored) {\n+        }\n+\n+        Spliterator<FileStore> spfs =\n+            FileSystems.getDefault().getFileStores().spliterator();\n+        Stream<FileStore> sfs = StreamSupport.stream(spfs, false);\n+        return sfs.filter(fs -> !fs.isReadOnly() &&\n+                                COW_TYPES.contains(fs.type().toLowerCase()))\n+                  .map(fs -> fs.toString().split(\" \")[0])\n+                  .map(s -> Path.of(s))\n+                  .filter(d -> Files.exists(d) && Files.isDirectory(d))\n+                  .findFirst()\n+                  .orElse(dotPath)\n+                  .toString();\n+    }\n+\n@@ -62,3 +112,3 @@\n-            \/\/ Different directories. Use test.dir if possible as it might be\n-            \/\/ a different volume\/file system and so improve test coverage.\n-            String testDir = System.getProperty(\"test.dir\", \".\");\n+            \/\/ Use test.dir to define second directory if possible as it might\n+            \/\/ be a different volume\/file system and so improve test coverage.\n+            String testDir = getTestDir();\n@@ -66,0 +116,16 @@\n+            FileStore fileStore2 = getFileStore(dir2);\n+\n+            \/\/ If different type (format) from dir1, re-do same directory tests\n+            if (!fileStore1.type().equals(fileStore2.type())) {\n+                try {\n+                    printDirInfo(\"dir2\", dir2, fileStore2);\n+                    testPosixAttributes =\n+                        fileStore2.supportsFileAttributeView(\"posix\");\n+                    testCopyFileToFile(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                    testMove(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                } finally {\n+                    TestUtil.removeAll(dir2);\n+                }\n+            }\n+\n+            \/\/ Different directories.\n@@ -67,0 +133,4 @@\n+                \/\/ Recreate dir2 if it was removed above\n+                if (notExists(dir2)) {\n+                    dir2 = TestUtil.createTemporaryDirectory(testDir);\n+                }\n@@ -69,1 +139,0 @@\n-                FileStore fileStore2 = getFileStore(dir2);\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":75,"deletions":6,"binary":false,"changes":81,"status":"modified"}]}