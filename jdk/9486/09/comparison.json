{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.internal.misc.Blocker;\n@@ -33,0 +34,1 @@\n+import static sun.nio.fs.UnixNativeDispatcher.copyToNativeBuffer;\n@@ -117,0 +119,14 @@\n+    boolean supportsCloning() throws IOException {\n+        try (NativeBuffer fileBuffer = copyToNativeBuffer(file())) {\n+            long comp = Blocker.begin();\n+            try {\n+                return supportsCloning0(fileBuffer.address());\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+\n+    }\n+\n+    private static native boolean supportsCloning0(long fileAddress);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import sun.nio.ch.IOStatus;\n@@ -38,0 +39,3 @@\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n+\n@@ -74,0 +78,7 @@\n+    @Override\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n@@ -105,2 +116,0 @@\n-\n-\n@@ -112,9 +121,0 @@\n-    \/\/ --- file copying ---\n-\n-    @Override\n-    int directCopy(int dst, int src, long addressToPollForCancel)\n-        throws UnixException\n-    {\n-        return directCopy0(dst, src, addressToPollForCancel);\n-    }\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -64,0 +64,20 @@\n+    \/**\n+     * int clonefile(const char * src, const char * dst, int flags);\n+     *\/\n+    static int clonefile(UnixPath src, UnixPath dst, int flags)\n+        throws UnixException\n+    {\n+        try (NativeBuffer srcBuffer = copyToNativeBuffer(src);\n+            NativeBuffer dstBuffer = copyToNativeBuffer(dst)) {\n+            long comp = Blocker.begin();\n+            try {\n+                return clonefile0(srcBuffer.address(), dstBuffer.address(),\n+                                  flags);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+    }\n+    private static native int clonefile0(long srcAddress, long dstAddress,\n+                                         int flags);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <strings.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <sys\/attr.h>\n+\n+#include \"sun_nio_fs_BsdFileStore.h\"\n+\n+#define CAPABILITY(vinfo, cap) \\\n+        (((vinfo).valid[VOL_CAPABILITIES_INTERFACES]        & (cap)) && \\\n+         ((vinfo).capabilities[VOL_CAPABILITIES_INTERFACES] & (cap)))\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_fs_BsdFileStore_supportsCloning0(JNIEnv* env, jclass this,\n+    jlong fileAddress)\n+{\n+    const char* file = (const char*)jlong_to_ptr(fileAddress);\n+\n+    struct attrlist alist;\n+    bzero(&alist, sizeof(alist));\n+    alist.bitmapcount = ATTR_BIT_MAP_COUNT;\n+    alist.volattr     = ATTR_VOL_INFO | ATTR_VOL_CAPABILITIES;\n+\n+    struct volAttrsBuf {\n+        u_int32_t length;\n+        vol_capabilities_attr_t capabilities;\n+    } __attribute__((aligned(4), packed));\n+    struct volAttrsBuf volAttrs;\n+    bzero(&volAttrs, sizeof(volAttrs));\n+\n+    \/\/ ignore any error in getattrlist\n+    if (getattrlist(file, &alist, &volAttrs, sizeof(volAttrs), 0) == 0) {\n+        vol_capabilities_attr_t volCaps = volAttrs.capabilities;\n+        int supportsAttrList = CAPABILITY(volCaps, VOL_CAP_INT_ATTRLIST);\n+        if (supportsAttrList) {\n+            return CAPABILITY(volCaps, VOL_CAP_INT_CLONE) != 0 ?\n+                JNI_TRUE : JNI_FALSE;\n+        }\n+    }\n+\n+    \/\/ return false if getattrlist fails\n+    return JNI_FALSE;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdFileStore.c","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -45,0 +45,2 @@\n+#include <sys\/attr.h>\n+#include <sys\/clonefile.h>\n@@ -228,0 +230,16 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_clonefile0(JNIEnv* env, jclass this,\n+    jlong srcAddress, jlong dstAddress, jint flags)\n+{\n+    const char* src = (const char*)jlong_to_ptr(srcAddress);\n+    const char* dst = (const char*)jlong_to_ptr(dstAddress);\n+\n+    int ret = clonefile(src, dst, flags);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include <sys\/clonefile.h>\n@@ -136,0 +137,4 @@\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_ENOTSUP = ENOTSUP;\n+#endif\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1076,1 +1076,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixFileSystem.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8267820\n+ * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8264744 8267820\n@@ -43,0 +43,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -47,0 +49,5 @@\n+    \/\/ File system types that support copy-on-write (CoW)\n+    \/\/ for testing cloning \/ reflink on Linux\n+    private static final Set<String> COW_TYPES =\n+        Set.of(\"bcachefs\", \"btrfs\", \"ocfs2\", \"xfs\");\n+\n@@ -48,1 +55,0 @@\n-    static boolean heads() { return rand.nextBoolean(); }\n@@ -51,0 +57,44 @@\n+    static boolean heads() { return rand.nextBoolean(); }\n+\n+    \/**\n+     * Returns the secondary test directory as a path name string.\n+     * If the system property \"test.dir\" is definied it is returned.\n+     * Otherwise, if the platform is not Linux, the current directory\n+     * \".\" is returned. If the platform is Linux, then the first\n+     * located top level directory which supports CoW is returned. If\n+     * there is no such directory then \".\" is returned.\n+     *\n+     * @return the path string of the secondary test directory\n+     *\/\n+    private static final String getTestDir() {\n+        final String dot = \".\";\n+        if (!Platform.isLinux()) {\n+            return System.getProperty(\"test.dir\", dot);\n+        }\n+\n+        String testDir = System.getProperty(\"test.dir\");\n+        if (testDir != null) {\n+            return testDir;\n+        }\n+\n+        final Path dotPath = Path.of(dot);\n+        try {\n+            if (COW_TYPES.contains(getFileStore(dotPath).type().toLowerCase())) {\n+                return dot;\n+            }\n+        } catch (IOException ignored) {\n+        }\n+\n+        Spliterator<FileStore> spfs =\n+            FileSystems.getDefault().getFileStores().spliterator();\n+        Stream<FileStore> sfs = StreamSupport.stream(spfs, false);\n+        return sfs.filter(fs -> !fs.isReadOnly() &&\n+                                COW_TYPES.contains(fs.type().toLowerCase()))\n+                  .map(fs -> fs.toString().split(\" \")[0])\n+                  .map(s -> Path.of(s))\n+                  .filter(d -> Files.exists(d) && Files.isDirectory(d))\n+                  .findFirst()\n+                  .orElse(dotPath)\n+                  .toString();\n+    }\n+\n@@ -62,3 +112,3 @@\n-            \/\/ Different directories. Use test.dir if possible as it might be\n-            \/\/ a different volume\/file system and so improve test coverage.\n-            String testDir = System.getProperty(\"test.dir\", \".\");\n+            \/\/ Use test.dir to define second directory if possible as it might\n+            \/\/ be a different volume\/file system and so improve test coverage.\n+            String testDir = getTestDir();\n@@ -66,0 +116,16 @@\n+            FileStore fileStore2 = getFileStore(dir2);\n+\n+            \/\/ If different type (format) from dir1, re-do same directory tests\n+            if (!fileStore1.type().equals(fileStore2.type())) {\n+                try {\n+                    printDirInfo(\"dir2\", dir2, fileStore2);\n+                    testPosixAttributes =\n+                        fileStore2.supportsFileAttributeView(\"posix\");\n+                    testCopyFileToFile(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                    testMove(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                } finally {\n+                    TestUtil.removeAll(dir2);\n+                }\n+            }\n+\n+            \/\/ Different directories.\n@@ -67,0 +133,4 @@\n+                \/\/ Recreate dir2 if it was removed above\n+                if (notExists(dir2)) {\n+                    dir2 = TestUtil.createTemporaryDirectory(testDir);\n+                }\n@@ -69,1 +139,0 @@\n-                FileStore fileStore2 = getFileStore(dir2);\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":75,"deletions":6,"binary":false,"changes":81,"status":"modified"}]}