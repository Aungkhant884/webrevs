{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -31,2 +32,1 @@\n-import java.io.IOException;\n-\n+import jdk.internal.misc.Blocker;\n@@ -34,0 +34,4 @@\n+import sun.nio.ch.IOStatus;\n+\n+import static sun.nio.fs.LinuxNativeDispatcher.*;\n+import static sun.nio.fs.UnixConstants.*;\n@@ -112,0 +116,59 @@\n+\n+    @Override\n+    public int clone(Path source, Path target, boolean noFollowLinks)\n+        throws IOException {\n+        UnixPath src = UnixPath.toUnixPath(source);\n+        UnixPath dst = UnixPath.toUnixPath(target);\n+        int srcFD = 0;\n+        int dstFD = 0;\n+        try {\n+            srcFD = open(src, O_RDONLY, 0);\n+            dstFD = open(dst, O_CREAT | O_WRONLY, 0666);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(src, dst);\n+            return IOStatus.THROWN;\n+        }\n+\n+        try {\n+            return ioctl_ficlone(dstFD, srcFD);\n+        } catch (UnixException x) {\n+            \/\/ delete dst to avoid later exception in Java layer\n+            if (exists(dst)) {\n+                try {\n+                    close(dstFD);\n+                    dstFD = 0;\n+                } catch (UnixException ignore) {\n+                }\n+                try {\n+                    unlink(dst);\n+                } catch (UnixException y) {\n+                    y.rethrowAsIOException(dst);\n+                    return IOStatus.THROWN;\n+                }\n+            }\n+            switch (x.errno()) {\n+                case EINVAL:\n+                    return IOStatus.UNSUPPORTED;\n+                case EPERM:\n+                    x.rethrowAsIOException(src, dst);\n+                    return IOStatus.THROWN;\n+                default:\n+                    return IOStatus.UNSUPPORTED_CASE;\n+            }\n+        } finally {\n+            if (dstFD != 0) {\n+                try {\n+                    close(dstFD);\n+                } catch (UnixException x) {\n+                    x.rethrowAsIOException(dst);\n+                    return IOStatus.THROWN;\n+                }\n+            }\n+            try {\n+                close(srcFD);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(src);\n+                return IOStatus.THROWN;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystemProvider.java","additions":66,"deletions":3,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.misc.Blocker;\n+\n@@ -72,0 +74,14 @@\n+    \/**\n+     * int ioctl(int dest_fd, FICLONE, int src_fd);\n+     *\/\n+    static int ioctl_ficlone(int dst, int src) throws UnixException {\n+        long comp = Blocker.begin();\n+        try {\n+            return ioctl_ficlone0(dst, src);\n+        } finally {\n+            Blocker.end(comp);\n+        }\n+    }\n+    private static native int ioctl_ficlone0(int dst, int src)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include <linux\/fs.h>\n+#include <sys\/ioctl.h>\n@@ -39,0 +41,4 @@\n+#ifndef FICLONE\n+#define FICLONE      1074041865\n+#endif\n+\n@@ -145,0 +151,14 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxNativeDispatcher_ioctl_1ficlone0(JNIEnv* env, jclass this,\n+    jint dst, jint src)\n+{\n+    int ret = ioctl(dst, FICLONE, src);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import sun.nio.ch.IOStatus;\n+import static sun.nio.fs.UnixConstants.*;\n@@ -75,0 +77,21 @@\n+\n+    @Override\n+    public int clone(Path source, Path target, boolean noFollowLinks)\n+        throws IOException {\n+        UnixPath src = UnixPath.toUnixPath(source);\n+        UnixPath dst = UnixPath.toUnixPath(target);\n+        try {\n+            return BsdNativeDispatcher.clonefile(src, dst, noFollowLinks);\n+        } catch (UnixException x) {\n+            switch (x.errno()) {\n+                case ENOTSUP: \/\/ cloning not supported by filesystem\n+                    return IOStatus.UNSUPPORTED;\n+                case EXDEV:   \/\/ src and dst on different filesystems\n+                case ENOTDIR: \/\/ problematic path parameter(s)\n+                    return IOStatus.UNSUPPORTED_CASE;\n+                default:\n+                    x.rethrowAsIOException(src, dst);\n+                    return IOStatus.THROWN;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystemProvider.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.misc.Blocker;\n+\n@@ -65,0 +67,27 @@\n+    \/**\n+     * int clonefile(const char * src, const char * dst, int flags);\n+     *\n+     * int flags = noFollowLinks ? CLONE_NOFOLLOW : 0;\n+     *\/\n+    static int clonefile(UnixPath src, UnixPath dst, boolean noFollowLinks)\n+        throws UnixException {\n+        if (src.getFileSystem() == dst.getFileSystem()) {\n+            try (NativeBuffer srcBuffer = copyToNativeBuffer(src);\n+                NativeBuffer dstBuffer = copyToNativeBuffer(dst)) {\n+                long comp = Blocker.begin();\n+                try {\n+                    return clonefile0(srcBuffer.address(),\n+                                      dstBuffer.address(),\n+                                      noFollowLinks);\n+                } finally {\n+                    Blocker.end(comp);\n+                }\n+            }\n+        }\n+\n+        return -1;\n+    }\n+    private static native int clonefile0(long srcAddress, long dstAddres,\n+                                         boolean noFollowLinks)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+#include <sys\/attr.h>\n+#include <sys\/clonefile.h>\n@@ -226,0 +228,18 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_clonefile0(JNIEnv* env, jclass this,\n+    jlong srcAddress, jlong dstAddress, jboolean noFollowLinks)\n+{\n+    const char* src = (const char*)jlong_to_ptr(srcAddress);\n+    const char* dst = (const char*)jlong_to_ptr(dstAddress);\n+\n+    int flags = noFollowLinks == JNI_TRUE ? CLONE_NOFOLLOW : 0;\n+\n+    int ret = clonefile(src, dst, flags);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,8 @@\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_ENOTSUP = ENOTSUP;\n+#endif\n+\n+#ifdef __linux__\n+    static final int PREFIX_EPERM = EPERM;\n+#endif\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -280,22 +280,9 @@\n-        if (addressToPollForCancel == 0 &&\n-            source.getFileSystem() == target.getFileSystem() &&\n-            !cloneFileNotSupported) {\n-            try (NativeBuffer sourceBuffer = copyToNativeBuffer(source);\n-                NativeBuffer targetBuffer = copyToNativeBuffer(target)) {\n-                long comp = Blocker.begin();\n-                try {\n-                    int res = cloneFile0(sourceBuffer.address(),\n-                                         targetBuffer.address(),\n-                                         flags.followLinks);\n-                    if (res == 0) {\n-                        copied = true;\n-                    }\n-                    if (res == IOStatus.UNSUPPORTED) {\n-                        cloneFileNotSupported = true;\n-                    }\n-                    \/\/ other IOStatus values: fall through\n-                } catch (UnixException x) {\n-                    x.rethrowAsIOException(source, target);\n-                } finally {\n-                    Blocker.end(comp);\n-                }\n+        if (addressToPollForCancel == 0 && !cloneFileNotSupported) {\n+            UnixFileSystemProvider provider =\n+               (UnixFileSystemProvider)source.getFileSystem().provider();\n+            int res = provider.clone(source, target, !flags.followLinks);\n+            if (res == 0) {\n+                copied = true;\n+            }\n+            if (res == IOStatus.UNSUPPORTED) {\n+                cloneFileNotSupported = true;\n@@ -735,16 +722,0 @@\n-    \/**\n-     * Clones the file whose path name address is {@code src} to that whose\n-     * path name address is {@code dst} using a platform-specific system call.\n-     *\n-     * @param sourceAddress the path address of the source file\n-     * @param targetAddres the path address of the target file (clone)\n-     * @param followLinks whether to follow links\n-     *\n-     * @return 0 on success, UNSUPPORTED_CASE if the call does not work with\n-     *         the given parameters, or UNSUPPORTED if cloning is not supported\n-     *         on this platform\n-     *\/\n-    private static native int cloneFile0(long sourceAddress, long targetAddres,\n-                                         boolean followLinks)\n-        throws UnixException;\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":9,"deletions":38,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -291,0 +291,15 @@\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using a platform-specific system call.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the desintation file (clone)\n+     * @param noFollowLinks whether to follow links\n+     *\n+     * @return 0 on success, UNSUPPORTED_CASE if the call does not work with\n+     *         the given parameters, or UNSUPPORTED if cloning is not supported\n+     *         on this platform\n+     *\/\n+    public abstract int clone(Path source, Path target, boolean noFollowLinks)\n+        throws IOException;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-#include <linux\/fs.h>\n-#include <sys\/ioctl.h>\n@@ -44,2 +42,0 @@\n-#include <sys\/attr.h>\n-#include <sys\/clonefile.h>\n@@ -49,4 +45,0 @@\n-#ifndef FICLONE\n-#define FICLONE      1074041865\n-#endif\n-\n@@ -100,87 +92,0 @@\n-\/\/ Copy via file cloning\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_UnixCopyFile_cloneFile0\n-    (JNIEnv* env, jclass this, jlong sourceAddress, jlong targetAddress,\n-     jboolean followLinks)\n-{\n-    const char* src = (const char*)jlong_to_ptr(sourceAddress);\n-    const char* dst = (const char*)jlong_to_ptr(targetAddress);\n-\n-#if defined(_ALLBSD_SOURCE)\n-    int flags = followLinks == JNI_FALSE ? CLONE_NOFOLLOW : 0;\n-    int res = clonefile(src, dst, flags);\n-    if (res < 0) {\n-        if (errno == ENOTSUP) { \/\/ cloning not supported by filesystem\n-            \/\/ disable further attempts to clone in this instance\n-            return IOS_UNSUPPORTED;\n-        } else if (errno == EXDEV   || \/\/ src and dst on different filesystems\n-                   errno == ENOTDIR) { \/\/ problematic path parameter(s)\n-            \/\/ cannot clone: fall back to direct or buffered copy\n-            return IOS_UNSUPPORTED_CASE;\n-        } else {\n-            \/\/ unrecoverable errors\n-            throwUnixException(env, errno);\n-            return IOS_THROWN;\n-        }\n-    }\n-    return 0;\n-#elif defined(__linux__)\n-    \/\/ disable ioctl_ficlone if copy_file_range() is available\n-    if (my_copy_file_range_func != NULL) {\n-        return IOS_UNSUPPORTED;\n-    }\n-\n-    int srcFD = open(src, O_RDONLY);\n-    if (srcFD < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Open src failed\");\n-        return IOS_THROWN;\n-    }\n-    int dstFD = open(dst, O_CREAT | O_WRONLY, 0666);\n-    if (dstFD < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Open dst failed\");\n-        close(srcFD);\n-        return IOS_THROWN;\n-    }\n-\n-    int res = ioctl(dstFD, FICLONE, srcFD);\n-    const int errno_ioctl = errno;\n-\n-    \/\/ ignore close errors\n-    close(srcFD);\n-    close(dstFD);\n-\n-    if (res != -1) {\n-        return 0;\n-    }\n-\n-    if (errno_ioctl == EPERM) {\n-        \/\/ dst is immutable\n-        throwUnixException(env, errno_ioctl);\n-        return IOS_THROWN;\n-    }\n-\n-    \/\/ delete dst to avoid later exception when re-creating in Java layer\n-    if (access(dst, F_OK) == 0) {\n-        if (unlink(dst) != 0) {\n-            const int errno_unlink = errno;\n-            if (access(dst, F_OK) == 0) {\n-                throwUnixException(env, errno_unlink);\n-                return IOS_THROWN;\n-            }\n-        }\n-    }\n-\n-    if (errno_ioctl == EINVAL) {\n-        \/\/ interpret EINVAL as indicating that FICLONE is an invalid\n-        \/\/ ioctl request code hence unsupported on this platform;\n-        \/\/ disable ioctl_ficlone\n-        return IOS_UNSUPPORTED;\n-    }\n-\n-    \/\/ cannot clone: fall back to direct or buffered copy\n-    return IOS_UNSUPPORTED_CASE;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":0,"deletions":95,"binary":false,"changes":95,"status":"modified"}]}