{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import jdk.jfr.internal.SecuritySupport;\n@@ -42,1 +43,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n@@ -117,1 +118,1 @@\n-        Utils.checkRegisterPermission();\n+        SecuritySupport.checkRegisterPermission();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/AnnotationElement.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import jdk.jfr.internal.SecuritySupport;\n@@ -41,1 +42,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n@@ -104,1 +105,1 @@\n-        Utils.checkRegisterPermission();\n+        SecuritySupport.checkRegisterPermission();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventFactory.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,2 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.SecuritySupport;\n+import jdk.jfr.internal.util.Utils;\n@@ -167,1 +168,1 @@\n-            Utils.checkAccessFlightRecorder();\n+            SecuritySupport.checkAccessFlightRecorder();\n@@ -225,1 +226,1 @@\n-        Utils.checkRegisterPermission();\n+        SecuritySupport.checkRegisterPermission();\n@@ -241,1 +242,1 @@\n-        Utils.checkRegisterPermission();\n+        SecuritySupport.checkRegisterPermission();\n@@ -278,1 +279,1 @@\n-        Utils.checkAccessFlightRecorder();\n+        SecuritySupport.checkAccessFlightRecorder();\n@@ -302,1 +303,1 @@\n-        Utils.checkAccessFlightRecorder();\n+        SecuritySupport.checkAccessFlightRecorder();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorder.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.jfr.internal.SecuritySupport;\n@@ -38,1 +39,0 @@\n-import jdk.jfr.internal.Utils;\n@@ -224,1 +224,1 @@\n-        if (!name.equals(Utils.ACCESS_FLIGHT_RECORDER) && !name.equals(Utils.REGISTER_EVENT)) {\n+        if (!name.equals(SecuritySupport.ACCESS_FLIGHT_RECORDER) && !name.equals(SecuritySupport.REGISTER_EVENT)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorderPermission.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Recording.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.SecuritySupport;\n@@ -35,1 +36,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n@@ -152,1 +153,1 @@\n-        Utils.checkRegisterPermission();\n+        SecuritySupport.checkRegisterPermission();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/ValueDescriptor.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import jdk.jfr.internal.Utils;\n@@ -123,1 +122,1 @@\n-        Utils.checkAccessFlightRecorder();\n+        SecuritySupport.checkAccessFlightRecorder();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n@@ -105,1 +105,1 @@\n-        Utils.checkAccessFlightRecorder();\n+        SecuritySupport.checkAccessFlightRecorder();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.JVMSupport;\n@@ -31,7 +31,7 @@\n-    public static final EventConfiguration SOCKET_READ = Utils.getConfiguration(SocketReadEvent.class);\n-    public static final EventConfiguration SOCKET_WRITE = Utils.getConfiguration(SocketWriteEvent.class);\n-    public static final EventConfiguration FILE_READ = Utils.getConfiguration(FileReadEvent.class);\n-    public static final EventConfiguration FILE_WRITE = Utils.getConfiguration(FileWriteEvent.class);\n-    public static final EventConfiguration FILE_FORCE = Utils.getConfiguration(FileForceEvent.class);\n-    public static final EventConfiguration ERROR_THROWN = Utils.getConfiguration(ErrorThrownEvent.class);\n-    public static final EventConfiguration EXCEPTION_THROWN = Utils.getConfiguration(ExceptionThrownEvent.class);\n+    public static final EventConfiguration SOCKET_READ = JVMSupport.getConfiguration(SocketReadEvent.class);\n+    public static final EventConfiguration SOCKET_WRITE = JVMSupport.getConfiguration(SocketWriteEvent.class);\n+    public static final EventConfiguration FILE_READ = JVMSupport.getConfiguration(FileReadEvent.class);\n+    public static final EventConfiguration FILE_WRITE = JVMSupport.getConfiguration(FileWriteEvent.class);\n+    public static final EventConfiguration FILE_FORCE = JVMSupport.getConfiguration(FileForceEvent.class);\n+    public static final EventConfiguration ERROR_THROWN = JVMSupport.getConfiguration(ErrorThrownEvent.class);\n+    public static final EventConfiguration EXCEPTION_THROWN = JVMSupport.getConfiguration(ExceptionThrownEvent.class);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/EventConfigurations.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import jdk.jfr.internal.settings.PeriodSetting;\n+import jdk.jfr.internal.settings.StackTraceSetting;\n+import jdk.jfr.internal.settings.ThresholdSetting;\n@@ -179,0 +182,13 @@\n+\n+    boolean isVisible(boolean hasEventHook) {\n+        if (isType(ThresholdSetting.class)) {\n+            return !hasEventHook;\n+        }\n+        if (isType(PeriodSetting.class)) {\n+            return hasEventHook;\n+        }\n+        if (isType(StackTraceSetting.class)) {\n+            return !hasEventHook;\n+        }\n+        return true;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Control.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+import jdk.jfr.internal.util.Utils;\n@@ -285,1 +286,1 @@\n-            if (Utils.isSettingVisible(nc.control, type.hasEventHook()) && type.isVisible()) {\n+            if (nc.control.isVisible(type.hasEventHook()) && type.isVisible()) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.internal.util.Utils;\n+import jdk.jfr.internal.util.ValueFormatter;\n@@ -39,1 +46,0 @@\n-\n@@ -42,0 +48,5 @@\n+    \/*\n+     * This field will be lazily initialized and the access is not synchronized.\n+     * The possible data race is benign and is worth of not introducing any contention here.\n+     *\/\n+    private static Instant lastTimestamp;\n@@ -87,0 +98,64 @@\n+\n+    static long nanosToTicks(long nanos) {\n+        return (long) (nanos * JVM.getJVM().getTimeConversionFactor());\n+    }\n+\n+    static long getChunkStartNanos() {\n+        long nanos = JVM.getJVM().getChunkStartNanos();\n+        \/\/ JVM::getChunkStartNanos() may return a bumped timestamp, +1 ns or +2 ns.\n+        \/\/ Spin here to give Instant.now() a chance to catch up.\n+        awaitUniqueTimestamp();\n+        return nanos;\n+    }\n+\n+    private static void awaitUniqueTimestamp() {\n+        if (lastTimestamp == null) {\n+            lastTimestamp = Instant.now(); \/\/ lazy initialization\n+        }\n+        while (true) {\n+            Instant time = Instant.now();\n+            if (!time.equals(lastTimestamp)) {\n+                lastTimestamp = time;\n+                return;\n+            }\n+            try {\n+                Thread.sleep(0, 100);\n+            } catch (InterruptedException iex) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    public static synchronized EventConfiguration getConfiguration(Class<? extends jdk.internal.event.Event> eventClass) {\n+        Utils.ensureValidEventSubclass(eventClass);\n+        Object configuration = JVM.getJVM().getConfiguration(eventClass);\n+        if (configuration == null || configuration instanceof EventConfiguration) {\n+            return (EventConfiguration) configuration;\n+        }\n+        throw new InternalError(\"Could not get configuration object on event class \" + eventClass.getName());\n+    }\n+\n+    public static synchronized void setConfiguration(Class<? extends jdk.internal.event.Event> eventClass, EventConfiguration configuration) {\n+        Utils.ensureValidEventSubclass(eventClass);\n+        if (!JVM.getJVM().setConfiguration(eventClass, configuration)) {\n+            throw new InternalError(\"Could not set configuration object on event class \" + eventClass.getName());\n+        }\n+    }\n+\n+    static boolean shouldInstrument(boolean isJDK, String name) {\n+        if (!isJDK) {\n+            return true;\n+        }\n+        if (!name.contains(\".Container\")) {\n+            \/\/ Didn't match @Name(\"jdk.jfr.Container*\") or class name \"jdk.jfr.events.Container*\"\n+            return true;\n+        }\n+        return JVM.getJVM().isContainerized();\n+    }\n+\n+    public static String makeFilename(Recording recording) {\n+        String pid = JVM.getJVM().getPid();\n+        String date = ValueFormatter.formatDateTime(LocalDateTime.now());\n+        String idText = recording == null ? \"\" :  \"-id-\" + Long.toString(recording.getId());\n+        return \"hotspot-\" + \"pid-\" + pid + idText + \"-\" + date + \".jfr\";\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":77,"deletions":2,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.jfr.internal.util.Utils;\n@@ -62,1 +63,1 @@\n-                if (!Utils.shouldInstrument(clazz.getClassLoader() == null, clazz.getName())) {\n+                if (!JVMSupport.shouldInstrument(clazz.getClassLoader() == null, clazz.getName())) {\n@@ -67,1 +68,1 @@\n-                EventConfiguration configuration = Utils.getConfiguration(clazz.asSubclass(jdk.internal.event.Event.class));\n+                EventConfiguration configuration = JVMSupport.getConfiguration(clazz.asSubclass(jdk.internal.event.Event.class));\n@@ -110,1 +111,1 @@\n-            if (!Utils.shouldInstrument(bootClassLoader,  ei.getEventName())) {\n+            if (!JVMSupport.shouldInstrument(bootClassLoader,  ei.getEventName())) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataLoader.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataReader.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+import jdk.jfr.internal.util.Utils;\n@@ -124,1 +125,1 @@\n-        Utils.checkRegisterPermission();\n+        SecuritySupport.checkRegisterPermission();\n@@ -136,1 +137,1 @@\n-        Utils.checkRegisterPermission();\n+        SecuritySupport.checkRegisterPermission();\n@@ -184,1 +185,1 @@\n-        return Utils.getConfiguration(eventClass);\n+        return JVMSupport.getConfiguration(eventClass);\n@@ -212,1 +213,1 @@\n-        if (jvm.isInstrumented(eventClass) || !Utils.shouldInstrument(pe.isJDK(), pe.getName())) {\n+        if (jvm.isInstrumented(eventClass) || !JVMSupport.shouldInstrument(pe.isJDK(), pe.getName())) {\n@@ -215,1 +216,1 @@\n-        Utils.setConfiguration(eventClass, configuration);\n+        JVMSupport.setConfiguration(eventClass, configuration);\n@@ -234,1 +235,1 @@\n-            EventConfiguration eh = Utils.getConfiguration(clazz);\n+            EventConfiguration eh = JVMSupport.getConfiguration(clazz);\n@@ -251,1 +252,1 @@\n-            EventConfiguration ec = Utils.getConfiguration(clazz);\n+            EventConfiguration ec = JVMSupport.getConfiguration(clazz);\n@@ -300,1 +301,1 @@\n-        long chunkStart = Utils.getChunkStartNanos();\n+        long chunkStart = JVMSupport.getChunkStartNanos();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.jfr.internal.util.Utils;\n@@ -56,1 +57,1 @@\n-            long ticks = Utils.nanosToTicks(nanos);\n+            long ticks = JVMSupport.nanosToTicks(nanos);\n@@ -77,1 +78,1 @@\n-            long ticks = Utils.nanosToTicks(cutoffNanos);\n+            long ticks = JVMSupport.nanosToTicks(cutoffNanos);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/OldObjectSample.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.util.Utils;\n@@ -151,1 +152,1 @@\n-            long cutoffTicks = Utils.nanosToTicks(cutoffNanos);\n+            long cutoffTicks = JVMSupport.nanosToTicks(cutoffNanos);\n@@ -241,1 +242,1 @@\n-        this.thresholdTicks = Utils.nanosToTicks(thresholdNanos);\n+        this.thresholdTicks = JVMSupport.nanosToTicks(thresholdNanos);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import jdk.jfr.internal.util.Utils;\n@@ -247,1 +248,1 @@\n-            startNanos = Utils.getChunkStartNanos();\n+            startNanos = JVMSupport.getChunkStartNanos();\n@@ -269,1 +270,1 @@\n-            startNanos = Utils.getChunkStartNanos();\n+            startNanos = JVMSupport.getChunkStartNanos();\n@@ -316,1 +317,1 @@\n-        recording.setFinalStartnanos(Utils.getChunkStartNanos());\n+        recording.setFinalStartnanos(JVMSupport.getChunkStartNanos());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+import jdk.jfr.internal.util.Utils;\n+import jdk.jfr.internal.util.ValueFormatter;\n@@ -129,1 +131,1 @@\n-                    options.add(\"maxage=\" + Utils.formatTimespan(maxAge, \"\"));\n+                    options.add(\"maxage=\" + ValueFormatter.formatTimespan(maxAge, \"\"));\n@@ -132,1 +134,1 @@\n-                    options.add(\"maxsize=\" + Utils.formatBytesCompact(maxSize));\n+                    options.add(\"maxsize=\" + ValueFormatter.formatBytesCompact(maxSize));\n@@ -138,1 +140,1 @@\n-                    options.add(\"duration=\" + Utils.formatTimespan(duration, \"\"));\n+                    options.add(\"duration=\" + ValueFormatter.formatTimespan(duration, \"\"));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-            new FlightRecorderPermission(Utils.REGISTER_EVENT);\n+            new FlightRecorderPermission(SecuritySupport.REGISTER_EVENT);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PrivateAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.jfr.internal.util.ValueFormatter;\n@@ -110,1 +111,1 @@\n-        String basename = Utils.formatDateTime(LocalDateTime.now()) + \"_\" + JVM.getJVM().getPid();\n+        String basename = ValueFormatter.formatDateTime(LocalDateTime.now()) + \"_\" + JVM.getJVM().getPid();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,6 @@\n+    private static final String EVENTS_PACKAGE_NAME = \"jdk.jfr.events\";\n+    private static final String INSTRUMENT_PACKAGE_NAME = \"jdk.jfr.internal.instrument\";\n+    private static final String EVENT_PACKAGE_NAME = \"jdk.jfr.internal.event\";\n+\n+    public static final String REGISTER_EVENT = \"registerEvent\";\n+    public static final String ACCESS_FLIGHT_RECORDER = \"accessFlightRecorder\";\n@@ -209,0 +215,16 @@\n+    public static void checkAccessFlightRecorder() throws SecurityException {\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new FlightRecorderPermission(ACCESS_FLIGHT_RECORDER));\n+        }\n+    }\n+\n+    public static void checkRegisterPermission() throws SecurityException {\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new FlightRecorderPermission(REGISTER_EVENT));\n+        }\n+    }\n+\n@@ -296,1 +318,1 @@\n-        Modules.addExports(JFR_MODULE, Utils.EVENT_PACKAGE_NAME, clazz.getModule());\n+        Modules.addExports(JFR_MODULE, EVENT_PACKAGE_NAME, clazz.getModule());\n@@ -300,1 +322,1 @@\n-        Modules.addExports(JFR_MODULE, Utils.EVENTS_PACKAGE_NAME, clazz.getModule());\n+        Modules.addExports(JFR_MODULE, EVENTS_PACKAGE_NAME, clazz.getModule());\n@@ -304,1 +326,1 @@\n-        Modules.addExports(JFR_MODULE, Utils.INSTRUMENT_PACKAGE_NAME, clazz.getModule());\n+        Modules.addExports(JFR_MODULE, INSTRUMENT_PACKAGE_NAME, clazz.getModule());\n@@ -312,1 +334,1 @@\n-        doPrivileged(() ->  MetadataRepository.getInstance().register(eventClass), new FlightRecorderPermission(Utils.REGISTER_EVENT));\n+        doPrivileged(() ->  MetadataRepository.getInstance().register(eventClass), new FlightRecorderPermission(REGISTER_EVENT));\n@@ -316,1 +338,1 @@\n-        doPrivileged(() ->  MetadataRepository.getInstance().registerMirror(eventClass), new FlightRecorderPermission(Utils.REGISTER_EVENT));\n+        doPrivileged(() ->  MetadataRepository.getInstance().registerMirror(eventClass), new FlightRecorderPermission(REGISTER_EVENT));\n@@ -422,1 +444,1 @@\n-    static void ensureClassIsInitialized(Class<?> clazz) {\n+    public static void ensureClassIsInitialized(Class<?> clazz) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.jfr.internal.util.Utils;\n@@ -158,1 +159,1 @@\n-            EventConfiguration ec = Utils.getConfiguration(eventClass);\n+            EventConfiguration ec = JVMSupport.getConfiguration(eventClass);\n@@ -232,1 +233,1 @@\n-                    if (Utils.isSettingVisible(control, ec.getEventType().hasEventHook())) {\n+                    if (control.isVisible(ec.getEventType().hasEventHook())) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SettingsManager.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.jfr.internal.util.Utils;\n@@ -83,1 +84,1 @@\n-            String name = Utils.makeFilename(recording.getRecording());\n+            String name = JVMSupport.makeFilename(recording.getRecording());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ShutdownHook.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    static final Type STACK_TRACE = createKnownType(TYPES_PREFIX + \"StackTrace\", null);\n+    public static final Type STACK_TRACE = createKnownType(TYPES_PREFIX + \"StackTrace\", null);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,873 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal;\n-\n-import static java.util.concurrent.TimeUnit.DAYS;\n-import static java.util.concurrent.TimeUnit.HOURS;\n-import static java.util.concurrent.TimeUnit.MICROSECONDS;\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-import static java.util.concurrent.TimeUnit.MINUTES;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.lang.annotation.Annotation;\n-import java.lang.annotation.Repeatable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.nio.file.Path;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.LocalDateTime;\n-import java.time.temporal.ChronoUnit;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import jdk.internal.module.Checks;\n-import jdk.jfr.Event;\n-import jdk.jfr.EventType;\n-import jdk.jfr.FlightRecorderPermission;\n-import jdk.jfr.Recording;\n-import jdk.jfr.RecordingState;\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.internal.settings.PeriodSetting;\n-import jdk.jfr.internal.settings.StackTraceSetting;\n-import jdk.jfr.internal.settings.ThresholdSetting;\n-\n-public final class Utils {\n-\n-    private static final Object flushObject = new Object();\n-    private static final String INFINITY = \"infinity\";\n-    private static final String OFF = \"off\";\n-    public static final String EVENTS_PACKAGE_NAME = \"jdk.jfr.events\";\n-    public static final String INSTRUMENT_PACKAGE_NAME = \"jdk.jfr.internal.instrument\";\n-    public static final String EVENT_PACKAGE_NAME = \"jdk.jfr.internal.event\";\n-    public static final String REGISTER_EVENT = \"registerEvent\";\n-    public static final String ACCESS_FLIGHT_RECORDER = \"accessFlightRecorder\";\n-    private static final String LEGACY_EVENT_NAME_PREFIX = \"com.oracle.jdk.\";\n-\n-    private static final Duration MICRO_SECOND = Duration.ofNanos(1_000);\n-    private static final Duration SECOND = Duration.ofSeconds(1);\n-    private static final Duration MINUTE = Duration.ofMinutes(1);\n-    private static final Duration HOUR = Duration.ofHours(1);\n-    private static final Duration DAY = Duration.ofDays(1);\n-    private static final int NANO_SIGNIFICANT_FIGURES = 9;\n-    private static final int MILL_SIGNIFICANT_FIGURES = 3;\n-    private static final int DISPLAY_NANO_DIGIT = 3;\n-    private static final int BASE = 10;\n-    private static long THROTTLE_OFF = -2;\n-\n-    \/*\n-     * This field will be lazily initialized and the access is not synchronized.\n-     * The possible data race is benign and is worth of not introducing any contention here.\n-     *\/\n-    private static Instant lastTimestamp;\n-\n-    public static void checkAccessFlightRecorder() throws SecurityException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new FlightRecorderPermission(ACCESS_FLIGHT_RECORDER));\n-        }\n-    }\n-\n-    public static void checkRegisterPermission() throws SecurityException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new FlightRecorderPermission(REGISTER_EVENT));\n-        }\n-    }\n-\n-    private static enum TimespanUnit {\n-        NANOSECONDS(\"ns\", 1000), MICROSECONDS(\"us\", 1000), MILLISECONDS(\"ms\", 1000), SECONDS(\"s\", 60), MINUTES(\"m\", 60), HOURS(\"h\", 24), DAYS(\"d\", 7);\n-\n-        final String text;\n-        final long amount;\n-\n-        TimespanUnit(String unit, long amount) {\n-            this.text = unit;\n-            this.amount = amount;\n-        }\n-    }\n-\n-    private static String formatDataAmount(String formatter, long amount) {\n-        if (amount == Long.MIN_VALUE) {\n-            return \"N\/A\";\n-        }\n-        int exp = (int) (Math.log(Math.abs(amount)) \/ Math.log(1024));\n-        char unit = \"kMGTPE\".charAt(exp - 1);\n-        return String.format(formatter, amount \/ Math.pow(1024, exp), unit);\n-    }\n-\n-    public static String formatBytesCompact(long bytes) {\n-        if (bytes < 1024) {\n-            return String.valueOf(bytes);\n-        }\n-        return formatDataAmount(\"%.1f%cB\", bytes);\n-    }\n-\n-    public static String formatBits(long bits) {\n-        if (bits == 1 || bits == -1) {\n-            return bits + \" bit\";\n-        }\n-        if (bits < 1024 && bits > -1024) {\n-            return bits + \" bits\";\n-        }\n-        return formatDataAmount(\"%.1f %cbit\", bits);\n-    }\n-\n-    public static String formatBytes(long bytes) {\n-        if (bytes == 1 || bytes == -1) {\n-            return bytes + \" byte\";\n-        }\n-        if (bytes < 1024 && bytes > -1024) {\n-            return bytes + \" bytes\";\n-        }\n-        return formatDataAmount(\"%.1f %cB\", bytes);\n-    }\n-\n-    public static String formatBytesPerSecond(long bytes) {\n-        if (bytes < 1024 && bytes > -1024) {\n-            return bytes + \" byte\/s\";\n-        }\n-        return formatDataAmount(\"%.1f %cB\/s\", bytes);\n-    }\n-\n-    public static String formatBitsPerSecond(long bits) {\n-        if (bits < 1024 && bits > -1024) {\n-            return bits + \" bps\";\n-        }\n-        return formatDataAmount(\"%.1f %cbps\", bits);\n-    }\n-    public static String formatTimespan(Duration dValue, String separation) {\n-        if (dValue == null) {\n-            return \"0\";\n-        }\n-        long value = dValue.toNanos();\n-        TimespanUnit result = TimespanUnit.NANOSECONDS;\n-        for (TimespanUnit unit : TimespanUnit.values()) {\n-            result = unit;\n-            long amount = unit.amount;\n-            if (result == TimespanUnit.DAYS || value < amount || value % amount != 0) {\n-                break;\n-            }\n-            value \/= amount;\n-        }\n-        return String.format(\"%d%s%s\", value, separation, result.text);\n-    }\n-\n-    \/\/ This method reduces the number of loaded classes\n-    \/\/ compared to DateTimeFormatter\n-    public static String formatDateTime(LocalDateTime time) {\n-        StringBuilder sb = new StringBuilder(19);\n-        sb.append(time.getYear() \/ 100);\n-        appendPadded(sb, time.getYear() % 100, true);\n-        appendPadded(sb, time.getMonth().getValue(), true);\n-        appendPadded(sb, time.getDayOfMonth(), true);\n-        appendPadded(sb, time.getHour(), true);\n-        appendPadded(sb, time.getMinute(), true);\n-        appendPadded(sb, time.getSecond(), false);\n-        return sb.toString();\n-    }\n-\n-    private static void appendPadded(StringBuilder text, int number, boolean separator) {\n-        if (number < 10) {\n-            text.append('0');\n-        }\n-        text.append(number);\n-        if (separator) {\n-            text.append('_');\n-        }\n-    }\n-\n-    enum ThrottleUnit {\n-        NANOSECONDS(\"ns\", TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toMillis(1)),\n-        MICROSECONDS(\"us\", TimeUnit.SECONDS.toNanos(1) \/ 1000, TimeUnit.SECONDS.toMillis(1)),\n-        MILLISECONDS(\"ms\", TimeUnit.SECONDS.toMillis(1), TimeUnit.SECONDS.toMillis(1)),\n-        SECONDS(\"s\", 1, TimeUnit.SECONDS.toMillis(1)),\n-        MINUTES(\"m\", 1, TimeUnit.MINUTES.toMillis(1)),\n-        HOUR(\"h\", 1, TimeUnit.HOURS.toMillis(1)),\n-        DAY(\"d\", 1, TimeUnit.DAYS.toMillis(1));\n-\n-        private final String text;\n-        private final long factor;\n-        private final long millis;\n-\n-        ThrottleUnit(String t, long factor, long millis) {\n-            this.text = t;\n-            this.factor = factor;\n-            this.millis = millis;\n-        }\n-\n-        private static ThrottleUnit parse(String s) {\n-            if (s.equals(OFF)) {\n-                return MILLISECONDS;\n-            }\n-            return unit(parseThrottleString(s, false));\n-        }\n-\n-        private static ThrottleUnit unit(String s) {\n-            if (s.endsWith(\"ns\") || s.endsWith(\"us\") || s.endsWith(\"ms\")) {\n-                return value(s.substring(s.length() - 2));\n-            }\n-            if (s.endsWith(\"s\") || s.endsWith(\"m\") || s.endsWith(\"h\") || s.endsWith(\"d\")) {\n-                return value(s.substring(s.length() - 1));\n-            }\n-            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n-        }\n-\n-        private static ThrottleUnit value(String s) {\n-            for (ThrottleUnit t : values()) {\n-                if (t.text.equals(s)) {\n-                    return t;\n-                }\n-            }\n-            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n-        }\n-\n-        static long asMillis(String s) {\n-            return parse(s).millis;\n-        }\n-\n-        static long normalizeValueAsMillis(long value, String s) {\n-            return value * parse(s).factor;\n-        }\n-    }\n-\n-    private static void throwThrottleNumberFormatException(String s) {\n-        throw new NumberFormatException(\"'\" + s + \"' is not valid. Should be a non-negative numeric value followed by a delimiter. i.e. '\/', and then followed by a unit e.g. 100\/s.\");\n-    }\n-\n-    \/\/ Expected input format is \"x\/y\" where x is a non-negative long\n-    \/\/ and y is a time unit. Split the string at the delimiter.\n-    private static String parseThrottleString(String s, boolean value) {\n-        String[] split = s.split(\"\/\");\n-        if (split.length != 2) {\n-            throwThrottleNumberFormatException(s);\n-        }\n-        return value ? split[0].trim() : split[1].trim();\n-    }\n-\n-    public static long parseThrottleValue(String s) {\n-        if (s.equals(OFF)) {\n-            return THROTTLE_OFF;\n-        }\n-        String parsedValue = parseThrottleString(s, true);\n-        long normalizedValue = 0;\n-        try {\n-            normalizedValue = ThrottleUnit.normalizeValueAsMillis(Long.parseLong(parsedValue), s);\n-        } catch (NumberFormatException nfe) {\n-            throwThrottleNumberFormatException(s);\n-        }\n-        return normalizedValue;\n-    }\n-\n-    public static long parseThrottleTimeUnit(String s) {\n-        return ThrottleUnit.asMillis(s);\n-    }\n-\n-    public static long parseTimespanWithInfinity(String s) {\n-        if (INFINITY.equals(s)) {\n-            return Long.MAX_VALUE;\n-        }\n-        return parseTimespan(s);\n-    }\n-\n-    public static long parseTimespan(String s) {\n-        if (s.endsWith(\"ns\")) {\n-            return Long.parseLong(s.substring(0, s.length() - 2).trim());\n-        }\n-        if (s.endsWith(\"us\")) {\n-            return MICROSECONDS.toNanos(Long.parseLong(s.substring(0, s.length() - 2).trim()));\n-        }\n-        if (s.endsWith(\"ms\")) {\n-            return MILLISECONDS.toNanos(Long.parseLong(s.substring(0, s.length() - 2).trim()));\n-        }\n-        if (s.endsWith(\"s\")) {\n-            return SECONDS.toNanos(Long.parseLong(s.substring(0, s.length() - 1).trim()));\n-        }\n-        if (s.endsWith(\"m\")) {\n-            return MINUTES.toNanos(Long.parseLong(s.substring(0, s.length() - 1).trim()));\n-        }\n-        if (s.endsWith(\"h\")) {\n-            return HOURS.toNanos(Long.parseLong(s.substring(0, s.length() - 1).trim()));\n-        }\n-        if (s.endsWith(\"d\")) {\n-            return DAYS.toNanos(Long.parseLong(s.substring(0, s.length() - 1).trim()));\n-        }\n-\n-        try {\n-            Long.parseLong(s);\n-        } catch (NumberFormatException nfe) {\n-            throw new NumberFormatException(\"'\" + s + \"' is not a valid timespan. Should be numeric value followed by a unit, i.e. 20 ms. Valid units are ns, us, s, m, h and d.\");\n-        }\n-        \/\/ Only accept values with units\n-        throw new NumberFormatException(\"Timespan + '\" + s + \"' is missing unit. Valid units are ns, us, s, m, h and d.\");\n-    }\n-\n-    \/**\n-     * Return all annotations as they are visible in the source code\n-     *\n-     * @param clazz class to return annotations from\n-     *\n-     * @return list of annotation\n-     *\n-     *\/\n-    static List<Annotation> getAnnotations(Class<?> clazz) {\n-        List<Annotation> annos = new ArrayList<>();\n-        for (Annotation a : clazz.getAnnotations()) {\n-            annos.addAll(getAnnotation(a));\n-        }\n-        return annos;\n-    }\n-\n-    private static List<? extends Annotation> getAnnotation(Annotation a) {\n-        Class<?> annotated = a.annotationType();\n-        Method valueMethod = getValueMethod(annotated);\n-        if (valueMethod != null) {\n-            Class<?> returnType = valueMethod.getReturnType();\n-            if (returnType.isArray()) {\n-                Class<?> candidate = returnType.getComponentType();\n-                Repeatable r = candidate.getAnnotation(Repeatable.class);\n-                if (r != null) {\n-                    Class<?> repeatClass = r.value();\n-                    if (annotated == repeatClass) {\n-                        return getAnnotationValues(a, valueMethod);\n-                    }\n-                }\n-            }\n-        }\n-        return List.of(a);\n-    }\n-\n-    static boolean isAfter(RecordingState stateToTest, RecordingState b) {\n-        return stateToTest.ordinal() > b.ordinal();\n-    }\n-\n-    static boolean isBefore(RecordingState stateToTest, RecordingState b) {\n-        return stateToTest.ordinal() < b.ordinal();\n-    }\n-\n-    static boolean isState(RecordingState stateToTest, RecordingState... states) {\n-        for (RecordingState s : states) {\n-            if (s == stateToTest) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static List<Annotation> getAnnotationValues(Annotation a, Method valueMethod) {\n-        try {\n-            return Arrays.asList((Annotation[]) valueMethod.invoke(a, new Object[0]));\n-        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n-            return new ArrayList<>();\n-        }\n-    }\n-\n-    private static Method getValueMethod(Class<?> annotated) {\n-        try {\n-            return annotated.getMethod(\"value\", new Class<?>[0]);\n-        } catch (NoSuchMethodException e) {\n-            return null;\n-        }\n-    }\n-\n-    public static void touch(Path dumpFile) throws IOException {\n-        RandomAccessFile raf = new RandomAccessFile(dumpFile.toFile(), \"rw\");\n-        raf.close();\n-    }\n-\n-    public static Class<?> unboxType(Class<?> t) {\n-        if (t == Integer.class) {\n-            return int.class;\n-        }\n-        if (t == Long.class) {\n-            return long.class;\n-        }\n-        if (t == Float.class) {\n-            return float.class;\n-        }\n-        if (t == Double.class) {\n-            return double.class;\n-        }\n-        if (t == Byte.class) {\n-            return byte.class;\n-        }\n-        if (t == Short.class) {\n-            return short.class;\n-        }\n-        if (t == Boolean.class) {\n-            return boolean.class;\n-        }\n-        if (t == Character.class) {\n-            return char.class;\n-        }\n-        return t;\n-    }\n-\n-    static long nanosToTicks(long nanos) {\n-        return (long) (nanos * JVM.getJVM().getTimeConversionFactor());\n-    }\n-\n-    public static synchronized EventConfiguration getConfiguration(Class<? extends jdk.internal.event.Event> eventClass) {\n-        Utils.ensureValidEventSubclass(eventClass);\n-        Object configuration = JVM.getJVM().getConfiguration(eventClass);\n-        if (configuration == null || configuration instanceof EventConfiguration) {\n-            return (EventConfiguration) configuration;\n-        }\n-        throw new InternalError(\"Could not get configuration object on event class \" + eventClass.getName());\n-    }\n-\n-    static synchronized void setConfiguration(Class<? extends jdk.internal.event.Event> eventClass, EventConfiguration configuration) {\n-        Utils.ensureValidEventSubclass(eventClass);\n-        if (!JVM.getJVM().setConfiguration(eventClass, configuration)) {\n-            throw new InternalError(\"Could not set configuration object on event class \" + eventClass.getName());\n-        }\n-    }\n-\n-    public static Map<String, String> sanitizeNullFreeStringMap(Map<String, String> settings) {\n-        HashMap<String, String> map = HashMap.newHashMap(settings.size());\n-        for (Map.Entry<String, String> e : settings.entrySet()) {\n-            String key = e.getKey();\n-            if (key == null) {\n-                throw new NullPointerException(\"Null key is not allowed in map\");\n-            }\n-            String value = e.getValue();\n-            if (value == null) {\n-                throw new NullPointerException(\"Null value is not allowed in map\");\n-            }\n-            map.put(key, value);\n-        }\n-        return map;\n-    }\n-\n-    public static <T> List<T> sanitizeNullFreeList(List<T> elements, Class<T> clazz) {\n-        List<T> sanitized = new ArrayList<>(elements.size());\n-        for (T element : elements) {\n-            if (element == null) {\n-                throw new NullPointerException(\"Null is not an allowed element in list\");\n-            }\n-            if (element.getClass() != clazz) {\n-                throw new ClassCastException();\n-            }\n-            sanitized.add(element);\n-        }\n-        return sanitized;\n-    }\n-\n-    static List<Field> getVisibleEventFields(Class<?> clazz) {\n-        Utils.ensureValidEventSubclass(clazz);\n-        List<Field> fields = new ArrayList<>();\n-        for (Class<?> c = clazz; c != jdk.internal.event.Event.class; c = c.getSuperclass()) {\n-            for (Field field : c.getDeclaredFields()) {\n-                \/\/ skip private field in base classes\n-                if (c == clazz || !Modifier.isPrivate(field.getModifiers())) {\n-                    fields.add(field);\n-                }\n-            }\n-        }\n-        return fields;\n-    }\n-\n-    public static void ensureValidEventSubclass(Class<?> eventClass) {\n-        if (jdk.internal.event.Event.class.isAssignableFrom(eventClass) && Modifier.isAbstract(eventClass.getModifiers())) {\n-            throw new IllegalArgumentException(\"Abstract event classes are not allowed\");\n-        }\n-        if (eventClass == Event.class || eventClass == jdk.internal.event.Event.class || !jdk.internal.event.Event.class.isAssignableFrom(eventClass)) {\n-            throw new IllegalArgumentException(\"Must be a subclass to \" + Event.class.getName());\n-        }\n-    }\n-\n-    public static void ensureInitialized(Class<? extends jdk.internal.event.Event> eventClass) {\n-        SecuritySupport.ensureClassIsInitialized(eventClass);\n-    }\n-\n-    public static Object makePrimitiveArray(String typeName, List<Object> values) {\n-        int length = values.size();\n-        switch (typeName) {\n-        case \"int\":\n-            int[] ints = new int[length];\n-            for (int i = 0; i < length; i++) {\n-                ints[i] = (int) values.get(i);\n-            }\n-            return ints;\n-        case \"long\":\n-            long[] longs = new long[length];\n-            for (int i = 0; i < length; i++) {\n-                longs[i] = (long) values.get(i);\n-            }\n-            return longs;\n-\n-        case \"float\":\n-            float[] floats = new float[length];\n-            for (int i = 0; i < length; i++) {\n-                floats[i] = (float) values.get(i);\n-            }\n-            return floats;\n-\n-        case \"double\":\n-            double[] doubles = new double[length];\n-            for (int i = 0; i < length; i++) {\n-                doubles[i] = (double) values.get(i);\n-            }\n-            return doubles;\n-\n-        case \"short\":\n-            short[] shorts = new short[length];\n-            for (int i = 0; i < length; i++) {\n-                shorts[i] = (short) values.get(i);\n-            }\n-            return shorts;\n-        case \"char\":\n-            char[] chars = new char[length];\n-            for (int i = 0; i < length; i++) {\n-                chars[i] = (char) values.get(i);\n-            }\n-            return chars;\n-        case \"byte\":\n-            byte[] bytes = new byte[length];\n-            for (int i = 0; i < length; i++) {\n-                bytes[i] = (byte) values.get(i);\n-            }\n-            return bytes;\n-        case \"boolean\":\n-            boolean[] booleans = new boolean[length];\n-            for (int i = 0; i < length; i++) {\n-                booleans[i] = (boolean) values.get(i);\n-            }\n-            return booleans;\n-        case \"java.lang.String\":\n-            String[] strings = new String[length];\n-            for (int i = 0; i < length; i++) {\n-                strings[i] = (String) values.get(i);\n-            }\n-            return strings;\n-        }\n-        return null;\n-    }\n-\n-    public static boolean isSettingVisible(Control c, boolean hasEventHook) {\n-        if (c.isType(ThresholdSetting.class)) {\n-            return !hasEventHook;\n-        }\n-        if (c.isType(PeriodSetting.class)) {\n-            return hasEventHook;\n-        }\n-        if (c.isType(StackTraceSetting.class)) {\n-            return !hasEventHook;\n-        }\n-        return true;\n-    }\n-\n-    public static boolean isSettingVisible(long typeId, boolean hasEventHook) {\n-        if (ThresholdSetting.isType(typeId)) {\n-            return !hasEventHook;\n-        }\n-        if (PeriodSetting.isType(typeId)) {\n-            return hasEventHook;\n-        }\n-        if (StackTraceSetting.isType(typeId)) {\n-            return !hasEventHook;\n-        }\n-        return true;\n-    }\n-\n-    public static Type getValidType(Class<?> type, String name) {\n-        Objects.requireNonNull(type, \"Null is not a valid type for value descriptor \" + name);\n-        if (type.isArray()) {\n-            type = type.getComponentType();\n-            if (type != String.class && !type.isPrimitive()) {\n-                throw new IllegalArgumentException(\"Only arrays of primitives and Strings are allowed\");\n-            }\n-        }\n-\n-        Type knownType = Type.getKnownType(type);\n-        if (knownType == null || knownType == Type.STACK_TRACE) {\n-            throw new IllegalArgumentException(\"Only primitive types, java.lang.Thread, java.lang.String and java.lang.Class are allowed for value descriptors. \" + type.getName());\n-        }\n-        return knownType;\n-    }\n-\n-    public static String upgradeLegacyJDKEvent(String eventName) {\n-        if (eventName.length() <= LEGACY_EVENT_NAME_PREFIX.length()) {\n-            return eventName;\n-        }\n-        if (eventName.startsWith(LEGACY_EVENT_NAME_PREFIX)) {\n-            int index = eventName.lastIndexOf(\".\");\n-            if (index == LEGACY_EVENT_NAME_PREFIX.length() - 1) {\n-                return Type.EVENT_NAME_PREFIX + eventName.substring(index + 1);\n-            }\n-        }\n-        return eventName;\n-    }\n-\n-    public static void verifyMirror(Class<?> mirror, Class<?> real) {\n-        Class<?> cMirror = Objects.requireNonNull(mirror);\n-        Class<?> cReal = Objects.requireNonNull(real);\n-\n-        Map<String, Field> mirrorFields = new HashMap<>();\n-        while (cMirror != null) {\n-            for (Field f : cMirror.getDeclaredFields()) {\n-                if (isSupportedType(f.getType())) {\n-                    mirrorFields.put(f.getName(), f);\n-                }\n-            }\n-            cMirror = cMirror.getSuperclass();\n-        }\n-        while (cReal != null) {\n-            for (Field realField : cReal.getDeclaredFields()) {\n-                if (isSupportedType(realField.getType())) {\n-                    String fieldName = realField.getName();\n-                    Field mirrorField = mirrorFields.get(fieldName);\n-                    if (mirrorField == null) {\n-                        throw new InternalError(\"Missing mirror field for \" + cReal.getName() + \"#\" + fieldName);\n-                    }\n-                    if (realField.getType() != mirrorField.getType()) {\n-                        throw new InternalError(\"Incorrect type for mirror field \" + fieldName);\n-                    }\n-                    if (realField.getModifiers() != mirrorField.getModifiers()) {\n-                        throw new InternalError(\"Incorrect modifier for mirror field \" + fieldName);\n-                    }\n-                    mirrorFields.remove(fieldName);\n-                }\n-            }\n-            cReal = cReal.getSuperclass();\n-        }\n-\n-        if (!mirrorFields.isEmpty()) {\n-            throw new InternalError(\"Found additional fields in mirror class \" + mirrorFields.keySet());\n-        }\n-    }\n-\n-    private static boolean isSupportedType(Class<?> type) {\n-        if (Modifier.isTransient(type.getModifiers()) || Modifier.isStatic(type.getModifiers())) {\n-            return false;\n-        }\n-        return Type.isValidJavaFieldType(type.getName());\n-    }\n-\n-    public static String makeFilename(Recording recording) {\n-        String pid = JVM.getJVM().getPid();\n-        String date = formatDateTime(LocalDateTime.now());\n-        String idText = recording == null ? \"\" :  \"-id-\" + Long.toString(recording.getId());\n-        return \"hotspot-\" + \"pid-\" + pid + idText + \"-\" + date + \".jfr\";\n-    }\n-\n-    public static String formatDuration(Duration d) {\n-        Duration roundedDuration = roundDuration(d);\n-        if (roundedDuration.equals(Duration.ZERO)) {\n-            return \"0 s\";\n-        } else if(roundedDuration.isNegative()){\n-            return \"-\" + formatPositiveDuration(roundedDuration.abs());\n-        } else {\n-            return formatPositiveDuration(roundedDuration);\n-        }\n-    }\n-\n-    public static boolean shouldInstrument(boolean isJDK, String name) {\n-        if (!isJDK) {\n-            return true;\n-        }\n-        if (!name.contains(\".Container\")) {\n-            \/\/ Didn't match @Name(\"jdk.jfr.Container*\") or class name \"jdk.jfr.events.Container*\"\n-            return true;\n-        }\n-        return JVM.getJVM().isContainerized();\n-    }\n-\n-    private static String formatPositiveDuration(Duration d){\n-        if (d.compareTo(MICRO_SECOND) < 0) {\n-            \/\/ 0.000001 ms - 0.000999 ms\n-            double outputMs = (double) d.toNanosPart() \/ 1_000_000;\n-            return String.format(\"%.6f ms\",  outputMs);\n-        } else if (d.compareTo(SECOND) < 0) {\n-            \/\/ 0.001 ms - 999 ms\n-            int valueLength = countLength(d.toNanosPart());\n-            int outputDigit = NANO_SIGNIFICANT_FIGURES - valueLength;\n-            double outputMs = (double) d.toNanosPart() \/ 1_000_000;\n-            return String.format(\"%.\" + outputDigit + \"f ms\",  outputMs);\n-        } else if (d.compareTo(MINUTE) < 0) {\n-            \/\/ 1.00 s - 59.9 s\n-            int valueLength = countLength(d.toSecondsPart());\n-            int outputDigit = MILL_SIGNIFICANT_FIGURES - valueLength;\n-            double outputSecond = d.toSecondsPart() + (double) d.toMillisPart() \/ 1_000;\n-            return String.format(\"%.\" + outputDigit + \"f s\",  outputSecond);\n-        } else if (d.compareTo(HOUR) < 0) {\n-            \/\/ 1 m 0 s - 59 m 59 s\n-            return String.format(\"%d m %d s\",  d.toMinutesPart(), d.toSecondsPart());\n-        } else if (d.compareTo(DAY) < 0) {\n-            \/\/ 1 h 0 m - 23 h 59 m\n-            return String.format(\"%d h %d m\",  d.toHoursPart(), d.toMinutesPart());\n-        } else {\n-            \/\/ 1 d 0 h -\n-            return String.format(\"%d d %d h\",  d.toDaysPart(), d.toHoursPart());\n-        }\n-    }\n-\n-    private static int countLength(long value){\n-        return (int) Math.log10(value) + 1;\n-    }\n-\n-    private static Duration roundDuration(Duration d) {\n-        if (d.equals(Duration.ZERO)) {\n-            return d;\n-        } else if(d.isNegative()){\n-            Duration roundedPositiveDuration = roundPositiveDuration(d.abs());\n-            return roundedPositiveDuration.negated();\n-        } else {\n-            return roundPositiveDuration(d);\n-        }\n-    }\n-\n-    private static Duration roundPositiveDuration(Duration d){\n-        if (d.compareTo(MICRO_SECOND) < 0) {\n-            \/\/ No round\n-            return d;\n-        } else if (d.compareTo(SECOND) < 0) {\n-            \/\/ Round significant figures to three digits\n-            int valueLength = countLength(d.toNanosPart());\n-            int roundValue = (int) Math.pow(BASE, valueLength - DISPLAY_NANO_DIGIT);\n-            long roundedNanos = Math.round((double) d.toNanosPart() \/ roundValue) * roundValue;\n-            return d.truncatedTo(ChronoUnit.SECONDS).plusNanos(roundedNanos);\n-        } else if (d.compareTo(MINUTE) < 0) {\n-            \/\/ Round significant figures to three digits\n-            int valueLength = countLength(d.toSecondsPart());\n-            int roundValue = (int) Math.pow(BASE, valueLength);\n-            long roundedMills = Math.round((double) d.toMillisPart() \/ roundValue) * roundValue;\n-            return d.truncatedTo(ChronoUnit.SECONDS).plusMillis(roundedMills);\n-        } else if (d.compareTo(HOUR) < 0) {\n-            \/\/ Round for more than 500 ms or less\n-            return d.plusMillis(SECOND.dividedBy(2).toMillisPart()).truncatedTo(ChronoUnit.SECONDS);\n-        } else if (d.compareTo(DAY) < 0) {\n-            \/\/ Round for more than 30 seconds or less\n-            return d.plusSeconds(MINUTE.dividedBy(2).toSecondsPart()).truncatedTo(ChronoUnit.MINUTES);\n-        } else {\n-            \/\/ Round for more than 30 minutes or less\n-            return d.plusMinutes(HOUR.dividedBy(2).toMinutesPart()).truncatedTo(ChronoUnit.HOURS);\n-        }\n-    }\n-\n-\n-    public static void takeNap(long millis) {\n-        try {\n-            Thread.sleep(millis);\n-        } catch (InterruptedException e) {\n-            \/\/ ok\n-        }\n-    }\n-\n-    public static void notifyFlush() {\n-        synchronized (flushObject) {\n-            flushObject.notifyAll();\n-        }\n-    }\n-\n-    public static void waitFlush(long timeOut) {\n-        synchronized (flushObject) {\n-            try {\n-                flushObject.wait(timeOut);\n-            } catch (InterruptedException e) {\n-                \/\/ OK\n-            }\n-        }\n-\n-    }\n-\n-    public static Instant epochNanosToInstant(long epochNanos) {\n-        return Instant.ofEpochSecond(0, epochNanos);\n-    }\n-\n-    public static long timeToNanos(Instant timestamp) {\n-        return timestamp.getEpochSecond() * 1_000_000_000L + timestamp.getNano();\n-    }\n-\n-    public static String validTypeName(String typeName, String defaultTypeName) {\n-        if (Checks.isClassName(typeName)) {\n-            return typeName;\n-        } else {\n-            Logger.log(LogTag.JFR, LogLevel.WARN, \"@Name ignored, not a valid Java type name.\");\n-            return defaultTypeName;\n-        }\n-    }\n-\n-    public static String validJavaIdentifier(String identifier, String defaultIdentifier) {\n-        if (Checks.isJavaIdentifier(identifier)) {\n-            return identifier;\n-        } else {\n-            Logger.log(LogTag.JFR, LogLevel.WARN, \"@Name ignored, not a valid Java identifier.\");\n-            return defaultIdentifier;\n-        }\n-    }\n-\n-    public static void ensureJavaIdentifier(String name) {\n-        if (!Checks.isJavaIdentifier(name)) {\n-            throw new IllegalArgumentException(\"'\" + name + \"' is not a valid Java identifier\");\n-        }\n-    }\n-\n-    public static long getChunkStartNanos() {\n-        long nanos = JVM.getJVM().getChunkStartNanos();\n-        \/\/ JVM::getChunkStartNanos() may return a bumped timestamp, +1 ns or +2 ns.\n-        \/\/ Spin here to give Instant.now() a chance to catch up.\n-        awaitUniqueTimestamp();\n-        return nanos;\n-    }\n-\n-    private static void awaitUniqueTimestamp() {\n-        if (lastTimestamp == null) {\n-            lastTimestamp = Instant.now(); \/\/ lazy initialization\n-        }\n-        while (true) {\n-            Instant time = Instant.now();\n-            if (!time.equals(lastTimestamp)) {\n-                lastTimestamp = time;\n-                return;\n-            }\n-            try {\n-                Thread.sleep(0, 100);\n-            } catch (InterruptedException iex) {\n-                \/\/ ignore\n-            }\n-        }\n-    }\n-\n-    public static String makeSimpleName(EventType type) {\n-      return makeSimpleName(type.getName());\n-    }\n-\n-    public static String makeSimpleName(String qualified) {\n-        return qualified.substring(qualified.lastIndexOf(\".\") + 1);\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":0,"deletions":873,"binary":false,"changes":873,"status":"deleted"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RecordingInput.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/StreamConfiguration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.jfr.internal.JVMSupport;\n@@ -48,1 +49,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.ValueFormatter;\n@@ -137,1 +138,1 @@\n-        return new SafePath(directory.toAbsolutePath().resolve(Utils.makeFilename(recording)).normalize());\n+        return new SafePath(directory.toAbsolutePath().resolve(JVMSupport.makeFilename(recording)).normalize());\n@@ -203,1 +204,1 @@\n-        print(Utils.formatBytes(bytes));\n+        print(ValueFormatter.formatBytes(bytes));\n@@ -207,1 +208,1 @@\n-        print(Utils.formatTimespan(timespan, separator));\n+        print(ValueFormatter.formatTimespan(timespan, separator));\n@@ -302,1 +303,1 @@\n-                        time = Utils.formatDateTime(LocalDateTime.now());\n+                        time = ValueFormatter.formatDateTime(LocalDateTime.now());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.util.SpellChecker;\n@@ -354,0 +355,4 @@\n+        List<String> alternatives = new ArrayList<>();\n+        for (Argument a : arguments) {\n+            alternatives.add(a.name());\n+        }\n@@ -356,20 +361,3 @@\n-                checkSpellingError(name);\n-            }\n-        }\n-    }\n-\n-    private void checkSpellingError(String name) {\n-        for (Argument a : arguments) {\n-            String expected = a.name();\n-            String s = name.toLowerCase();\n-            int lengthDifference = expected.length() - s.length();\n-            boolean spellingError = false;\n-            if (lengthDifference == 0) {\n-                if (expected.equals(s)) {\n-                    spellingError = true; \/\/ incorrect case, or we wouldn't be here\n-                } else {\n-                    if (s.length() < 6) {\n-                        spellingError = diff(expected, s) < 2; \/\/ one incorrect letter\n-                    } else {\n-                        spellingError = diff(expected, s) < 3; \/\/ two incorrect letter\n-                    }\n+                String suggestion = SpellChecker.check(name, alternatives);\n+                if (suggestion != null) {\n+                    throw new IllegalArgumentException(\"Error! Did you mean '\" + suggestion + \"' instead of '\" + name + \"'?\");\n@@ -378,30 +366,0 @@\n-            if (lengthDifference == 1) {\n-                spellingError = inSequence(expected, s); \/\/ missing letter\n-            }\n-            if (lengthDifference == -1) {\n-                spellingError = inSequence(s, expected); \/\/ additional letter\n-            }\n-            if (spellingError) {\n-                throw new IllegalArgumentException(\"Error! Did you mean '\" + expected + \"' instead of '\" + name + \"'?\");\n-            }\n-        }\n-    }\n-\n-    private int diff(String a, String b) {\n-        int count = a.length();\n-        for (int i = 0; i < a.length(); i++) {\n-            if (a.charAt(i) == b.charAt(i)) {\n-                count--;\n-            }\n-        }\n-        return count;\n-    }\n-\n-    private boolean inSequence(String longer, String shorter) {\n-        int l = 0;\n-        int s = 0;\n-        while (l < longer.length() && s < shorter.length()) {\n-            if (longer.charAt(l) == shorter.charAt(s)) {\n-                s++;\n-            }\n-            l++;\n@@ -409,1 +367,0 @@\n-        return shorter.length() == s; \/\/ if 0, all letters in longer found in shorter\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/ArgumentParser.java","additions":8,"deletions":51,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.ValueFormatter;\n@@ -102,1 +102,1 @@\n-            print(Utils.formatBytesCompact(maxSize));\n+            print(ValueFormatter.formatBytesCompact(maxSize));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdCheck.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.ValueParser;\n@@ -174,1 +174,1 @@\n-                long durationNanos = Utils.parseTimespan(time.substring(1));\n+                long durationNanos = ValueParser.parseTimespan(time.substring(1));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n@@ -35,1 +35,0 @@\n-import jdk.jfr.internal.query.QueryPrinter;\n@@ -37,1 +36,0 @@\n-import jdk.jfr.internal.util.Columnizer;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdView.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.ValueFormatter;\n@@ -63,1 +63,1 @@\n-       String filename = Utils.formatDateTime(time);\n+       String filename = ValueFormatter.formatDateTime(time);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ChunkFilename.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import jdk.jfr.internal.SecuritySupport;\n@@ -52,1 +53,3 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n+import jdk.jfr.internal.util.ValueFormatter;\n+import jdk.jfr.internal.util.ValueParser;\n@@ -84,1 +87,1 @@\n-        Utils.checkAccessFlightRecorder();\n+        SecuritySupport.checkAccessFlightRecorder();\n@@ -94,1 +97,1 @@\n-        return Utils.parseTimespan(s);\n+        return ValueParser.parseTimespan(s);\n@@ -104,1 +107,1 @@\n-        return Utils.formatTimespan(dValue, separation);\n+        return ValueFormatter.formatTimespan(dValue, separation);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/FlushTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FilteredType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.ValueParser;\n@@ -59,1 +59,1 @@\n-            long l =  Utils.parseTimespanWithInfinity(value);\n+            long l =  ValueParser.parseTimespanWithInfinity(value);\n@@ -70,1 +70,1 @@\n-        long l =  Utils.parseTimespanWithInfinity(value);\n+        long l =  ValueParser.parseTimespanWithInfinity(value);\n@@ -85,1 +85,1 @@\n-            return Utils.parseTimespanWithInfinity(value);\n+            return ValueParser.parseTimespanWithInfinity(value);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CutoffSetting.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.ValueParser;\n@@ -77,1 +77,1 @@\n-                long l = Utils.parseTimespanWithInfinity(value);\n+                long l = ValueParser.parseTimespanWithInfinity(value);\n@@ -116,1 +116,1 @@\n-            long nanos = Utils.parseTimespanWithInfinity(value);\n+            long nanos = ValueParser.parseTimespanWithInfinity(value);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/PeriodSetting.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.ValueParser;\n@@ -58,1 +58,1 @@\n-            long l = Utils.parseTimespanWithInfinity(value);\n+            long l = ValueParser.parseTimespanWithInfinity(value);\n@@ -75,1 +75,1 @@\n-        long l = Utils.parseTimespanWithInfinity(value);\n+        long l = ValueParser.parseTimespanWithInfinity(value);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThresholdSetting.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import jdk.jfr.internal.Utils;\n@@ -45,0 +44,1 @@\n+    static final String OFF_TEXT = \"off\";\n@@ -70,1 +70,1 @@\n-            value = Utils.parseThrottleValue(s);\n+            value = parseThrottleValue(s);\n@@ -81,2 +81,2 @@\n-            size = Utils.parseThrottleValue(s);\n-            millis = Utils.parseThrottleTimeUnit(s);\n+            size = parseThrottleValue(s);\n+            millis = parseThrottleTimeUnit(s);\n@@ -93,0 +93,32 @@\n+\n+    private static long parseThrottleValue(String s) {\n+        if (s.equals(OFF_TEXT)) {\n+            return OFF;\n+        }\n+        String parsedValue = parseThrottleString(s, true);\n+        long normalizedValue = 0;\n+        try {\n+            normalizedValue = ThrottleUnit.normalizeValueAsMillis(Long.parseLong(parsedValue), s);\n+        } catch (NumberFormatException nfe) {\n+            throwThrottleNumberFormatException(s);\n+        }\n+        return normalizedValue;\n+    }\n+\n+    private static long parseThrottleTimeUnit(String s) {\n+        return ThrottleUnit.asMillis(s);\n+    }\n+\n+    \/\/ Expected input format is \"x\/y\" where x is a non-negative long\n+    \/\/ and y is a time unit. Split the string at the delimiter.\n+    static String parseThrottleString(String s, boolean value) {\n+        String[] split = s.split(\"\/\");\n+        if (split.length != 2) {\n+            throwThrottleNumberFormatException(s);\n+        }\n+        return value ? split[0].trim() : split[1].trim();\n+    }\n+\n+    private static void throwThrottleNumberFormatException(String s) {\n+        throw new NumberFormatException(\"'\" + s + \"' is not valid. Should be a non-negative numeric value followed by a delimiter. i.e. '\/', and then followed by a unit e.g. 100\/s.\");\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleSetting.java","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.settings;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+enum ThrottleUnit {\n+        NANOSECONDS(\"ns\", TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toMillis(1)),\n+        MICROSECONDS(\"us\", TimeUnit.SECONDS.toNanos(1) \/ 1000, TimeUnit.SECONDS.toMillis(1)),\n+        MILLISECONDS(\"ms\", TimeUnit.SECONDS.toMillis(1), TimeUnit.SECONDS.toMillis(1)),\n+        SECONDS(\"s\", 1, TimeUnit.SECONDS.toMillis(1)),\n+        MINUTES(\"m\", 1, TimeUnit.MINUTES.toMillis(1)),\n+        HOUR(\"h\", 1, TimeUnit.HOURS.toMillis(1)),\n+        DAY(\"d\", 1, TimeUnit.DAYS.toMillis(1));\n+\n+        private final String text;\n+        private final long factor;\n+        private final long millis;\n+\n+        ThrottleUnit(String t, long factor, long millis) {\n+            this.text = t;\n+            this.factor = factor;\n+            this.millis = millis;\n+        }\n+\n+        private static ThrottleUnit parse(String s) {\n+            if (s.equals(ThrottleSetting.OFF_TEXT)) {\n+                return MILLISECONDS;\n+            }\n+            return unit(ThrottleSetting.parseThrottleString(s, false));\n+        }\n+\n+        private static ThrottleUnit unit(String s) {\n+            if (s.endsWith(\"ns\") || s.endsWith(\"us\") || s.endsWith(\"ms\")) {\n+                return value(s.substring(s.length() - 2));\n+            }\n+            if (s.endsWith(\"s\") || s.endsWith(\"m\") || s.endsWith(\"h\") || s.endsWith(\"d\")) {\n+                return value(s.substring(s.length() - 1));\n+            }\n+            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n+        }\n+\n+        private static ThrottleUnit value(String s) {\n+            for (ThrottleUnit t : values()) {\n+                if (t.text.equals(s)) {\n+                    return t;\n+                }\n+            }\n+            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n+        }\n+\n+        static long asMillis(String s) {\n+            return parse(s).millis;\n+        }\n+\n+        static long normalizeValueAsMillis(long value, String s) {\n+            return value * parse(s).factor;\n+        }\n+    }\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleUnit.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.jfr.internal.util.Matcher;\n@@ -49,1 +50,1 @@\n-                    if (match(category, filter)) {\n+                    if (Matcher.match(category, filter)) {\n@@ -70,1 +71,1 @@\n-                if (match(fullEventName, filter)) {\n+                if (Matcher.match(fullEventName, filter)) {\n@@ -74,1 +75,1 @@\n-                if (match(eventName, filter)) {\n+                if (Matcher.match(eventName, filter)) {\n@@ -130,1 +131,1 @@\n-                if (match(threadName, filter)) {\n+                if (Matcher.match(threadName, filter)) {\n@@ -157,24 +158,0 @@\n-    private static boolean match(String text, String filter) {\n-        if (filter.length() == 0) {\n-            \/\/ empty filter string matches if string is empty\n-            return text.length() == 0;\n-        }\n-        if (filter.charAt(0) == '*') { \/\/ recursive check\n-            filter = filter.substring(1);\n-            for (int n = 0; n <= text.length(); n++) {\n-                if (match(text.substring(n), filter))\n-                    return true;\n-            }\n-        } else if (text.length() == 0) {\n-            \/\/ empty string and non-empty filter does not match\n-            return false;\n-        } else if (filter.charAt(0) == '?') {\n-            \/\/ eat any char and move on\n-            return match(text.substring(1), filter.substring(1));\n-        } else if (filter.charAt(0) == text.charAt(0)) {\n-            \/\/ eat chars and move on\n-            return match(text.substring(1), filter.substring(1));\n-        }\n-        return false;\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Filters.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.ValueFormatter;\n@@ -561,1 +561,1 @@\n-            println(Utils.formatDuration(d));\n+            println(ValueFormatter.formatDuration(d));\n@@ -586,1 +586,1 @@\n-                        println(Utils.formatBytesPerSecond(amount));\n+                        println(ValueFormatter.formatBytesPerSecond(amount));\n@@ -590,1 +590,1 @@\n-                        println(Utils.formatBitsPerSecond(amount));\n+                        println(ValueFormatter.formatBitsPerSecond(amount));\n@@ -595,1 +595,1 @@\n-                        println(Utils.formatBytes(amount));\n+                        println(ValueFormatter.formatBytes(amount));\n@@ -599,1 +599,1 @@\n-                        println(Utils.formatBits(amount));\n+                        println(ValueFormatter.formatBits(amount));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,434 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.util;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Repeatable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import jdk.internal.module.Checks;\n+import jdk.jfr.Event;\n+import jdk.jfr.EventType;\n+import jdk.jfr.RecordingState;\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+import jdk.jfr.internal.SecuritySupport;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.settings.PeriodSetting;\n+import jdk.jfr.internal.settings.StackTraceSetting;\n+import jdk.jfr.internal.settings.ThresholdSetting;\n+\n+public final class Utils {\n+    private static final Object flushObject = new Object();\n+    private static final String LEGACY_EVENT_NAME_PREFIX = \"com.oracle.jdk.\";\n+\n+    \/**\n+     * Return all annotations as they are visible in the source code\n+     *\n+     * @param clazz class to return annotations from\n+     *\n+     * @return list of annotation\n+     *\n+     *\/\n+    public static List<Annotation> getAnnotations(Class<?> clazz) {\n+        List<Annotation> annos = new ArrayList<>();\n+        for (Annotation a : clazz.getAnnotations()) {\n+            annos.addAll(getAnnotation(a));\n+        }\n+        return annos;\n+    }\n+\n+    private static List<? extends Annotation> getAnnotation(Annotation a) {\n+        Class<?> annotated = a.annotationType();\n+        Method valueMethod = getValueMethod(annotated);\n+        if (valueMethod != null) {\n+            Class<?> returnType = valueMethod.getReturnType();\n+            if (returnType.isArray()) {\n+                Class<?> candidate = returnType.getComponentType();\n+                Repeatable r = candidate.getAnnotation(Repeatable.class);\n+                if (r != null) {\n+                    Class<?> repeatClass = r.value();\n+                    if (annotated == repeatClass) {\n+                        return getAnnotationValues(a, valueMethod);\n+                    }\n+                }\n+            }\n+        }\n+        return List.of(a);\n+    }\n+\n+    public static boolean isAfter(RecordingState stateToTest, RecordingState b) {\n+        return stateToTest.ordinal() > b.ordinal();\n+    }\n+\n+    public static boolean isBefore(RecordingState stateToTest, RecordingState b) {\n+        return stateToTest.ordinal() < b.ordinal();\n+    }\n+\n+    public static boolean isState(RecordingState stateToTest, RecordingState... states) {\n+        for (RecordingState s : states) {\n+            if (s == stateToTest) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static List<Annotation> getAnnotationValues(Annotation a, Method valueMethod) {\n+        try {\n+            return Arrays.asList((Annotation[]) valueMethod.invoke(a, new Object[0]));\n+        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+            return new ArrayList<>();\n+        }\n+    }\n+\n+    private static Method getValueMethod(Class<?> annotated) {\n+        try {\n+            return annotated.getMethod(\"value\", new Class<?>[0]);\n+        } catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+    }\n+\n+    public static void touch(Path dumpFile) throws IOException {\n+        RandomAccessFile raf = new RandomAccessFile(dumpFile.toFile(), \"rw\");\n+        raf.close();\n+    }\n+\n+    public static Class<?> unboxType(Class<?> t) {\n+        if (t == Integer.class) {\n+            return int.class;\n+        }\n+        if (t == Long.class) {\n+            return long.class;\n+        }\n+        if (t == Float.class) {\n+            return float.class;\n+        }\n+        if (t == Double.class) {\n+            return double.class;\n+        }\n+        if (t == Byte.class) {\n+            return byte.class;\n+        }\n+        if (t == Short.class) {\n+            return short.class;\n+        }\n+        if (t == Boolean.class) {\n+            return boolean.class;\n+        }\n+        if (t == Character.class) {\n+            return char.class;\n+        }\n+        return t;\n+    }\n+\n+    public static Map<String, String> sanitizeNullFreeStringMap(Map<String, String> settings) {\n+        HashMap<String, String> map = HashMap.newHashMap(settings.size());\n+        for (Map.Entry<String, String> e : settings.entrySet()) {\n+            String key = e.getKey();\n+            if (key == null) {\n+                throw new NullPointerException(\"Null key is not allowed in map\");\n+            }\n+            String value = e.getValue();\n+            if (value == null) {\n+                throw new NullPointerException(\"Null value is not allowed in map\");\n+            }\n+            map.put(key, value);\n+        }\n+        return map;\n+    }\n+\n+    public static <T> List<T> sanitizeNullFreeList(List<T> elements, Class<T> clazz) {\n+        List<T> sanitized = new ArrayList<>(elements.size());\n+        for (T element : elements) {\n+            if (element == null) {\n+                throw new NullPointerException(\"Null is not an allowed element in list\");\n+            }\n+            if (element.getClass() != clazz) {\n+                throw new ClassCastException();\n+            }\n+            sanitized.add(element);\n+        }\n+        return sanitized;\n+    }\n+\n+    public static List<Field> getVisibleEventFields(Class<?> clazz) {\n+        Utils.ensureValidEventSubclass(clazz);\n+        List<Field> fields = new ArrayList<>();\n+        for (Class<?> c = clazz; c != jdk.internal.event.Event.class; c = c.getSuperclass()) {\n+            for (Field field : c.getDeclaredFields()) {\n+                \/\/ skip private field in base classes\n+                if (c == clazz || !Modifier.isPrivate(field.getModifiers())) {\n+                    fields.add(field);\n+                }\n+            }\n+        }\n+        return fields;\n+    }\n+\n+    public static void ensureValidEventSubclass(Class<?> eventClass) {\n+        if (jdk.internal.event.Event.class.isAssignableFrom(eventClass) && Modifier.isAbstract(eventClass.getModifiers())) {\n+            throw new IllegalArgumentException(\"Abstract event classes are not allowed\");\n+        }\n+        if (eventClass == Event.class || eventClass == jdk.internal.event.Event.class || !jdk.internal.event.Event.class.isAssignableFrom(eventClass)) {\n+            throw new IllegalArgumentException(\"Must be a subclass to \" + Event.class.getName());\n+        }\n+    }\n+\n+    public static void ensureInitialized(Class<? extends jdk.internal.event.Event> eventClass) {\n+        SecuritySupport.ensureClassIsInitialized(eventClass);\n+    }\n+\n+    public static Object makePrimitiveArray(String typeName, List<Object> values) {\n+        int length = values.size();\n+        switch (typeName) {\n+        case \"int\":\n+            int[] ints = new int[length];\n+            for (int i = 0; i < length; i++) {\n+                ints[i] = (int) values.get(i);\n+            }\n+            return ints;\n+        case \"long\":\n+            long[] longs = new long[length];\n+            for (int i = 0; i < length; i++) {\n+                longs[i] = (long) values.get(i);\n+            }\n+            return longs;\n+\n+        case \"float\":\n+            float[] floats = new float[length];\n+            for (int i = 0; i < length; i++) {\n+                floats[i] = (float) values.get(i);\n+            }\n+            return floats;\n+\n+        case \"double\":\n+            double[] doubles = new double[length];\n+            for (int i = 0; i < length; i++) {\n+                doubles[i] = (double) values.get(i);\n+            }\n+            return doubles;\n+\n+        case \"short\":\n+            short[] shorts = new short[length];\n+            for (int i = 0; i < length; i++) {\n+                shorts[i] = (short) values.get(i);\n+            }\n+            return shorts;\n+        case \"char\":\n+            char[] chars = new char[length];\n+            for (int i = 0; i < length; i++) {\n+                chars[i] = (char) values.get(i);\n+            }\n+            return chars;\n+        case \"byte\":\n+            byte[] bytes = new byte[length];\n+            for (int i = 0; i < length; i++) {\n+                bytes[i] = (byte) values.get(i);\n+            }\n+            return bytes;\n+        case \"boolean\":\n+            boolean[] booleans = new boolean[length];\n+            for (int i = 0; i < length; i++) {\n+                booleans[i] = (boolean) values.get(i);\n+            }\n+            return booleans;\n+        case \"java.lang.String\":\n+            String[] strings = new String[length];\n+            for (int i = 0; i < length; i++) {\n+                strings[i] = (String) values.get(i);\n+            }\n+            return strings;\n+        }\n+        return null;\n+    }\n+\n+    public static boolean isSettingVisible(long typeId, boolean hasEventHook) {\n+        if (ThresholdSetting.isType(typeId)) {\n+            return !hasEventHook;\n+        }\n+        if (PeriodSetting.isType(typeId)) {\n+            return hasEventHook;\n+        }\n+        if (StackTraceSetting.isType(typeId)) {\n+            return !hasEventHook;\n+        }\n+        return true;\n+    }\n+\n+    public static Type getValidType(Class<?> type, String name) {\n+        Objects.requireNonNull(type, \"Null is not a valid type for value descriptor \" + name);\n+        if (type.isArray()) {\n+            type = type.getComponentType();\n+            if (type != String.class && !type.isPrimitive()) {\n+                throw new IllegalArgumentException(\"Only arrays of primitives and Strings are allowed\");\n+            }\n+        }\n+\n+        Type knownType = Type.getKnownType(type);\n+        if (knownType == null || knownType == Type.STACK_TRACE) {\n+            throw new IllegalArgumentException(\"Only primitive types, java.lang.Thread, java.lang.String and java.lang.Class are allowed for value descriptors. \" + type.getName());\n+        }\n+        return knownType;\n+    }\n+\n+    public static String upgradeLegacyJDKEvent(String eventName) {\n+        if (eventName.length() <= LEGACY_EVENT_NAME_PREFIX.length()) {\n+            return eventName;\n+        }\n+        if (eventName.startsWith(LEGACY_EVENT_NAME_PREFIX)) {\n+            int index = eventName.lastIndexOf(\".\");\n+            if (index == LEGACY_EVENT_NAME_PREFIX.length() - 1) {\n+                return Type.EVENT_NAME_PREFIX + eventName.substring(index + 1);\n+            }\n+        }\n+        return eventName;\n+    }\n+\n+    public static void verifyMirror(Class<?> mirror, Class<?> real) {\n+        Class<?> cMirror = Objects.requireNonNull(mirror);\n+        Class<?> cReal = Objects.requireNonNull(real);\n+\n+        Map<String, Field> mirrorFields = new HashMap<>();\n+        while (cMirror != null) {\n+            for (Field f : cMirror.getDeclaredFields()) {\n+                if (isSupportedType(f.getType())) {\n+                    mirrorFields.put(f.getName(), f);\n+                }\n+            }\n+            cMirror = cMirror.getSuperclass();\n+        }\n+        while (cReal != null) {\n+            for (Field realField : cReal.getDeclaredFields()) {\n+                if (isSupportedType(realField.getType())) {\n+                    String fieldName = realField.getName();\n+                    Field mirrorField = mirrorFields.get(fieldName);\n+                    if (mirrorField == null) {\n+                        throw new InternalError(\"Missing mirror field for \" + cReal.getName() + \"#\" + fieldName);\n+                    }\n+                    if (realField.getType() != mirrorField.getType()) {\n+                        throw new InternalError(\"Incorrect type for mirror field \" + fieldName);\n+                    }\n+                    if (realField.getModifiers() != mirrorField.getModifiers()) {\n+                        throw new InternalError(\"Incorrect modifier for mirror field \" + fieldName);\n+                    }\n+                    mirrorFields.remove(fieldName);\n+                }\n+            }\n+            cReal = cReal.getSuperclass();\n+        }\n+\n+        if (!mirrorFields.isEmpty()) {\n+            throw new InternalError(\"Found additional fields in mirror class \" + mirrorFields.keySet());\n+        }\n+    }\n+\n+    private static boolean isSupportedType(Class<?> type) {\n+        if (Modifier.isTransient(type.getModifiers()) || Modifier.isStatic(type.getModifiers())) {\n+            return false;\n+        }\n+        return Type.isValidJavaFieldType(type.getName());\n+    }\n+\n+    public static void takeNap(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+            \/\/ ok\n+        }\n+    }\n+\n+    public static void notifyFlush() {\n+        synchronized (flushObject) {\n+            flushObject.notifyAll();\n+        }\n+    }\n+\n+    public static void waitFlush(long timeOut) {\n+        synchronized (flushObject) {\n+            try {\n+                flushObject.wait(timeOut);\n+            } catch (InterruptedException e) {\n+                \/\/ OK\n+            }\n+        }\n+    }\n+\n+    public static Instant epochNanosToInstant(long epochNanos) {\n+        return Instant.ofEpochSecond(0, epochNanos);\n+    }\n+\n+    public static long timeToNanos(Instant timestamp) {\n+        return timestamp.getEpochSecond() * 1_000_000_000L + timestamp.getNano();\n+    }\n+\n+    public static String validTypeName(String typeName, String defaultTypeName) {\n+        if (Checks.isClassName(typeName)) {\n+            return typeName;\n+        } else {\n+            Logger.log(LogTag.JFR, LogLevel.WARN, \"@Name ignored, not a valid Java type name.\");\n+            return defaultTypeName;\n+        }\n+    }\n+\n+    public static String validJavaIdentifier(String identifier, String defaultIdentifier) {\n+        if (Checks.isJavaIdentifier(identifier)) {\n+            return identifier;\n+        } else {\n+            Logger.log(LogTag.JFR, LogLevel.WARN, \"@Name ignored, not a valid Java identifier.\");\n+            return defaultIdentifier;\n+        }\n+    }\n+\n+    public static void ensureJavaIdentifier(String name) {\n+        if (!Checks.isJavaIdentifier(name)) {\n+            throw new IllegalArgumentException(\"'\" + name + \"' is not a valid Java identifier\");\n+        }\n+    }\n+\n+    public static String makeSimpleName(EventType type) {\n+      return makeSimpleName(type.getName());\n+    }\n+\n+    public static String makeSimpleName(String qualified) {\n+        return qualified.substring(qualified.lastIndexOf(\".\") + 1);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":434,"deletions":0,"binary":false,"changes":434,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.time.LocalDateTime;\n@@ -42,0 +43,17 @@\n+    private static enum TimespanUnit {\n+        NANOSECONDS(\"ns\", 1000),\n+        MICROSECONDS(\"us\", 1000),\n+        MILLISECONDS(\"ms\", 1000),\n+        SECONDS(\"s\", 60), MINUTES(\"m\", 60),\n+        HOURS(\"h\", 24),\n+        DAYS(\"d\", 7);\n+\n+        private final String text;\n+        private final long amount;\n+\n+        TimespanUnit(String unit, long amount) {\n+            this.text = unit;\n+            this.amount = amount;\n+        }\n+    }\n+\n@@ -54,0 +72,41 @@\n+    public static String formatTimespan(Duration dValue, String separation) {\n+        if (dValue == null) {\n+            return \"0\";\n+        }\n+        long value = dValue.toNanos();\n+        TimespanUnit result = TimespanUnit.NANOSECONDS;\n+        for (TimespanUnit unit : TimespanUnit.values()) {\n+            result = unit;\n+            long amount = unit.amount;\n+            if (result == TimespanUnit.DAYS || value < amount || value % amount != 0) {\n+                break;\n+            }\n+            value \/= amount;\n+        }\n+        return String.format(\"%d%s%s\", value, separation, result.text);\n+    }\n+\n+    \/\/ This method reduces the number of loaded classes\n+    \/\/ compared to DateTimeFormatter\n+    public static String formatDateTime(LocalDateTime time) {\n+        StringBuilder sb = new StringBuilder(19);\n+        sb.append(time.getYear() \/ 100);\n+        appendPadded(sb, time.getYear() % 100, true);\n+        appendPadded(sb, time.getMonth().getValue(), true);\n+        appendPadded(sb, time.getDayOfMonth(), true);\n+        appendPadded(sb, time.getHour(), true);\n+        appendPadded(sb, time.getMinute(), true);\n+        appendPadded(sb, time.getSecond(), false);\n+        return sb.toString();\n+    }\n+\n+    private static void appendPadded(StringBuilder text, int number, boolean separator) {\n+        if (number < 10) {\n+            text.append('0');\n+        }\n+        text.append(number);\n+        if (separator) {\n+            text.append('_');\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.HOURS;\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class ValueParser {\n+    private static final String INFINITY = \"infinity\";\n+\n+    public static long parseTimespanWithInfinity(String s) {\n+        if (INFINITY.equals(s)) {\n+            return Long.MAX_VALUE;\n+        }\n+        return parseTimespan(s);\n+    }\n+\n+    public static long parseTimespan(String s) {\n+        if (s.endsWith(\"ns\")) {\n+            return Long.parseLong(s.substring(0, s.length() - 2).trim());\n+        }\n+        if (s.endsWith(\"us\")) {\n+            return MICROSECONDS.toNanos(Long.parseLong(s.substring(0, s.length() - 2).trim()));\n+        }\n+        if (s.endsWith(\"ms\")) {\n+            return MILLISECONDS.toNanos(Long.parseLong(s.substring(0, s.length() - 2).trim()));\n+        }\n+        if (s.endsWith(\"s\")) {\n+            return SECONDS.toNanos(Long.parseLong(s.substring(0, s.length() - 1).trim()));\n+        }\n+        if (s.endsWith(\"m\")) {\n+            return MINUTES.toNanos(Long.parseLong(s.substring(0, s.length() - 1).trim()));\n+        }\n+        if (s.endsWith(\"h\")) {\n+            return HOURS.toNanos(Long.parseLong(s.substring(0, s.length() - 1).trim()));\n+        }\n+        if (s.endsWith(\"d\")) {\n+            return DAYS.toNanos(Long.parseLong(s.substring(0, s.length() - 1).trim()));\n+        }\n+\n+        try {\n+            Long.parseLong(s);\n+        } catch (NumberFormatException nfe) {\n+            throw new NumberFormatException(\"'\" + s + \"' is not a valid timespan. Should be numeric value followed by a unit, i.e. 20 ms. Valid units are ns, us, s, m, h and d.\");\n+        }\n+        \/\/ Only accept values with units\n+        throw new NumberFormatException(\"Timespan + '\" + s + \"' is missing unit. Valid units are ns, us, s, m, h and d.\");\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueParser.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.util.ValueFormatter;\n@@ -36,1 +36,1 @@\n- * @modules jdk.jfr\/jdk.jfr.internal\n+ * @modules jdk.jfr\/jdk.jfr.internal.util\n@@ -136,1 +136,1 @@\n-        Asserts.assertEquals(Utils.formatDuration(Duration.ofNanos(nanos)), expected);\n+        Asserts.assertEquals(ValueFormatter.formatDuration(Duration.ofNanos(nanos)), expected);\n@@ -138,1 +138,1 @@\n-            Asserts.assertEquals(Utils.formatDuration(Duration.ofNanos(-nanos)), \"-\" + expected);\n+            Asserts.assertEquals(ValueFormatter.formatDuration(Duration.ofNanos(-nanos)), \"-\" + expected);\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestFormatDuration.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}