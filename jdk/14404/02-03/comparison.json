{"files":[{"patch":"@@ -53,0 +53,1 @@\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -61,1 +62,0 @@\n-import sun.util.locale.LocaleObjectCache;\n@@ -920,1 +920,1 @@\n-            return Cache.LOCALECACHE.get(baseloc);\n+            return LOCALE_CACHE.computeIfAbsent(baseloc, Locale::createLocale);\n@@ -923,1 +923,1 @@\n-            return Cache.LOCALECACHE.get(key);\n+            return LOCALE_CACHE.computeIfAbsent(key, Locale::createLocale);\n@@ -927,16 +927,7 @@\n-    private static class Cache extends LocaleObjectCache<Object, Locale> {\n-\n-        private static final Cache LOCALECACHE = new Cache();\n-\n-        private Cache() {\n-        }\n-\n-        @Override\n-        protected Locale createObject(Object key) {\n-            if (key instanceof BaseLocale) {\n-                return new Locale((BaseLocale)key, null);\n-            } else {\n-                LocaleKey lk = (LocaleKey)key;\n-                return new Locale(lk.base, lk.exts);\n-            }\n-        }\n+    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+    private static Locale createLocale(Object key) {\n+        return switch (key) {\n+            case BaseLocale base -> new Locale(base, null);\n+            case LocaleKey lk -> new Locale(lk.base, lk.exts);\n+            default -> throw new InternalError(\"should not happen\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -74,1 +75,0 @@\n-import sun.util.locale.LocaleObjectCache;\n@@ -2877,22 +2877,21 @@\n-            return new ArrayList<>(CANDIDATES_CACHE.get(locale.getBaseLocale()));\n-        }\n-\n-        private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();\n-\n-        private static class CandidateListCache extends LocaleObjectCache<BaseLocale, List<Locale>> {\n-            protected List<Locale> createObject(BaseLocale base) {\n-                String language = base.getLanguage();\n-                String script = base.getScript();\n-                String region = base.getRegion();\n-                String variant = base.getVariant();\n-\n-                \/\/ Special handling for Norwegian\n-                boolean isNorwegianBokmal = false;\n-                boolean isNorwegianNynorsk = false;\n-                if (language.equals(\"no\")) {\n-                    if (region.equals(\"NO\") && variant.equals(\"NY\")) {\n-                        variant = \"\";\n-                        isNorwegianNynorsk = true;\n-                    } else {\n-                        isNorwegianBokmal = true;\n-                    }\n+            return new ArrayList<>(CANDIDATES_CACHE.computeIfAbsent(locale.getBaseLocale(),\n+                    Control::createCandidateList));\n+        }\n+\n+        private static final ReferencedKeyMap<BaseLocale, List<Locale>> CANDIDATES_CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+\n+        private static List<Locale> createCandidateList(BaseLocale base) {\n+            String language = base.getLanguage();\n+            String script = base.getScript();\n+            String region = base.getRegion();\n+            String variant = base.getVariant();\n+\n+            \/\/ Special handling for Norwegian\n+            boolean isNorwegianBokmal = false;\n+            boolean isNorwegianNynorsk = false;\n+            if (language.equals(\"no\")) {\n+                if (region.equals(\"NO\") && variant.equals(\"NY\")) {\n+                    variant = \"\";\n+                    isNorwegianNynorsk = true;\n+                } else {\n+                    isNorwegianBokmal = true;\n@@ -2900,13 +2899,12 @@\n-                if (language.equals(\"nb\") || isNorwegianBokmal) {\n-                    List<Locale> tmpList = getDefaultList(\"nb\", script, region, variant);\n-                    \/\/ Insert a locale replacing \"nb\" with \"no\" for every list entry with precedence\n-                    List<Locale> bokmalList = new ArrayList<>();\n-                    for (Locale l_nb : tmpList) {\n-                        var isRoot = l_nb.getLanguage().isEmpty();\n-                        var l_no = Locale.getInstance(isRoot ? \"\" : \"no\",\n-                                l_nb.getScript(), l_nb.getCountry(), l_nb.getVariant(), null);\n-                        bokmalList.add(isNorwegianBokmal ? l_no : l_nb);\n-                        if (isRoot) {\n-                            break;\n-                        }\n-                        bokmalList.add(isNorwegianBokmal ? l_nb : l_no);\n+            }\n+            if (language.equals(\"nb\") || isNorwegianBokmal) {\n+                List<Locale> tmpList = getDefaultList(\"nb\", script, region, variant);\n+                \/\/ Insert a locale replacing \"nb\" with \"no\" for every list entry with precedence\n+                List<Locale> bokmalList = new ArrayList<>();\n+                for (Locale l_nb : tmpList) {\n+                    var isRoot = l_nb.getLanguage().isEmpty();\n+                    var l_no = Locale.getInstance(isRoot ? \"\" : \"no\",\n+                            l_nb.getScript(), l_nb.getCountry(), l_nb.getVariant(), null);\n+                    bokmalList.add(isNorwegianBokmal ? l_no : l_nb);\n+                    if (isRoot) {\n+                        break;\n@@ -2914,9 +2912,1 @@\n-                    return bokmalList;\n-                } else if (language.equals(\"nn\") || isNorwegianNynorsk) {\n-                    \/\/ Insert no_NO_NY, no_NO, no after nn\n-                    List<Locale> nynorskList = getDefaultList(\"nn\", script, region, variant);\n-                    int idx = nynorskList.size() - 1;\n-                    nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"NY\"));\n-                    nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"\"));\n-                    nynorskList.add(idx++, Locale.getInstance(\"no\", \"\", \"\"));\n-                    return nynorskList;\n+                    bokmalList.add(isNorwegianBokmal ? l_nb : l_no);\n@@ -2924,9 +2914,18 @@\n-                \/\/ Special handling for Chinese\n-                else if (language.equals(\"zh\")) {\n-                    if (script.isEmpty() && !region.isEmpty()) {\n-                        \/\/ Supply script for users who want to use zh_Hans\/zh_Hant\n-                        \/\/ as bundle names (recommended for Java7+)\n-                        switch (region) {\n-                            case \"TW\", \"HK\", \"MO\" -> script = \"Hant\";\n-                            case \"CN\", \"SG\"       -> script = \"Hans\";\n-                        }\n+                return bokmalList;\n+            } else if (language.equals(\"nn\") || isNorwegianNynorsk) {\n+                \/\/ Insert no_NO_NY, no_NO, no after nn\n+                List<Locale> nynorskList = getDefaultList(\"nn\", script, region, variant);\n+                int idx = nynorskList.size() - 1;\n+                nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"NY\"));\n+                nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"\"));\n+                nynorskList.add(idx++, Locale.getInstance(\"no\", \"\", \"\"));\n+                return nynorskList;\n+            }\n+            \/\/ Special handling for Chinese\n+            else if (language.equals(\"zh\")) {\n+                if (script.isEmpty() && !region.isEmpty()) {\n+                    \/\/ Supply script for users who want to use zh_Hans\/zh_Hant\n+                    \/\/ as bundle names (recommended for Java7+)\n+                    switch (region) {\n+                        case \"TW\", \"HK\", \"MO\" -> script = \"Hant\";\n+                        case \"CN\", \"SG\"       -> script = \"Hans\";\n@@ -2935,2 +2934,0 @@\n-\n-                return getDefaultList(language, script, region, variant);\n@@ -2939,2 +2936,2 @@\n-            private static List<Locale> getDefaultList(String language, String script, String region, String variant) {\n-                List<String> variants = null;\n+            return getDefaultList(language, script, region, variant);\n+        }\n@@ -2942,7 +2939,9 @@\n-                if (!variant.isEmpty()) {\n-                    variants = new ArrayList<>();\n-                    int idx = variant.length();\n-                    while (idx != -1) {\n-                        variants.add(variant.substring(0, idx));\n-                        idx = variant.lastIndexOf('_', --idx);\n-                    }\n+        private static List<Locale> getDefaultList(String language, String script, String region, String variant) {\n+            List<String> variants = null;\n+\n+            if (!variant.isEmpty()) {\n+                variants = new ArrayList<>();\n+                int idx = variant.length();\n+                while (idx != -1) {\n+                    variants.add(variant.substring(0, idx));\n+                    idx = variant.lastIndexOf('_', --idx);\n@@ -2950,0 +2949,1 @@\n+            }\n@@ -2951,1 +2951,1 @@\n-                List<Locale> list = new ArrayList<>();\n+            List<Locale> list = new ArrayList<>();\n@@ -2953,7 +2953,3 @@\n-                if (variants != null) {\n-                    for (String v : variants) {\n-                        list.add(Locale.getInstance(language, script, region, v, null));\n-                    }\n-                }\n-                if (!region.isEmpty()) {\n-                    list.add(Locale.getInstance(language, script, region, \"\", null));\n+            if (variants != null) {\n+                for (String v : variants) {\n+                    list.add(Locale.getInstance(language, script, region, v, null));\n@@ -2961,11 +2957,14 @@\n-                if (!script.isEmpty()) {\n-                    list.add(Locale.getInstance(language, script, \"\", \"\", null));\n-                    \/\/ Special handling for Chinese\n-                    if (language.equals(\"zh\")) {\n-                        if (region.isEmpty()) {\n-                            \/\/ Supply region(country) for users who still package Chinese\n-                            \/\/ bundles using old convention.\n-                            switch (script) {\n-                                case \"Hans\" -> region = \"CN\";\n-                                case \"Hant\" -> region = \"TW\";\n-                            }\n+            }\n+            if (!region.isEmpty()) {\n+                list.add(Locale.getInstance(language, script, region, \"\", null));\n+            }\n+            if (!script.isEmpty()) {\n+                list.add(Locale.getInstance(language, script, \"\", \"\", null));\n+                \/\/ Special handling for Chinese\n+                if (language.equals(\"zh\")) {\n+                    if (region.isEmpty()) {\n+                        \/\/ Supply region(country) for users who still package Chinese\n+                        \/\/ bundles using old convention.\n+                        switch (script) {\n+                            case \"Hans\" -> region = \"CN\";\n+                            case \"Hant\" -> region = \"TW\";\n@@ -2974,0 +2973,1 @@\n+                }\n@@ -2975,9 +2975,5 @@\n-                    \/\/ With script, after truncating variant, region and script,\n-                    \/\/ start over without script.\n-                    if (variants != null) {\n-                        for (String v : variants) {\n-                            list.add(Locale.getInstance(language, \"\", region, v, null));\n-                        }\n-                    }\n-                    if (!region.isEmpty()) {\n-                        list.add(Locale.getInstance(language, \"\", region, \"\", null));\n+                \/\/ With script, after truncating variant, region and script,\n+                \/\/ start over without script.\n+                if (variants != null) {\n+                    for (String v : variants) {\n+                        list.add(Locale.getInstance(language, \"\", region, v, null));\n@@ -2986,2 +2982,2 @@\n-                if (!language.isEmpty()) {\n-                    list.add(Locale.getInstance(language, \"\", \"\", \"\", null));\n+                if (!region.isEmpty()) {\n+                    list.add(Locale.getInstance(language, \"\", region, \"\", null));\n@@ -2989,4 +2985,0 @@\n-                \/\/ Add root locale at the end\n-                list.add(Locale.ROOT);\n-\n-                return list;\n@@ -2994,0 +2986,7 @@\n+            if (!language.isEmpty()) {\n+                list.add(Locale.getInstance(language, \"\", \"\", \"\", null));\n+            }\n+            \/\/ Add root locale at the end\n+            list.add(Locale.ROOT);\n+\n+            return list;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":98,"deletions":99,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -41,2 +42,1 @@\n-import java.util.WeakHashMap;\n-import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -96,3 +96,1 @@\n-    \/\/ WeakHashMap is not thread safe, thus accessed with the lock held\n-    private static final Map<BaseLocale, BaseLocale> CACHE = new WeakHashMap<>();\n-    private static final ReentrantLock LOCK = new ReentrantLock();\n+    private static final Map<BaseLocale, BaseLocale> CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n@@ -169,11 +167,6 @@\n-        LOCK.lock();\n-        try {\n-            return CACHE.computeIfAbsent(new BaseLocale(language, script, region, variant),\n-                    (b) -> new BaseLocale(\n-                            LocaleUtils.toLowerString(b.getLanguage()).intern(),\n-                            LocaleUtils.toTitleString(b.getScript()).intern(),\n-                            LocaleUtils.toUpperString(b.getRegion()).intern(),\n-                            b.getVariant().intern()));\n-        } finally {\n-            LOCK.unlock();\n-        }\n+        return CACHE.computeIfAbsent(new BaseLocale(language, script, region, variant),\n+                (b) -> new BaseLocale(\n+                        LocaleUtils.toLowerString(b.getLanguage()).intern(),\n+                        LocaleUtils.toTitleString(b.getScript()).intern(),\n+                        LocaleUtils.toUpperString(b.getRegion()).intern(),\n+                        b.getVariant().intern()));\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *******************************************************************************\n- * Copyright (C) 2009-2010, International Business Machines Corporation and    *\n- * others. All Rights Reserved.                                                *\n- *******************************************************************************\n- *\/\n-package sun.util.locale;\n-\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-public abstract class LocaleObjectCache<K, V> {\n-    private final ConcurrentMap<K, CacheEntry<K, V>> map;\n-    private final ReferenceQueue<V> queue = new ReferenceQueue<>();\n-\n-    public LocaleObjectCache() {\n-        this(16, 0.75f, 16);\n-    }\n-\n-    public LocaleObjectCache(int initialCapacity, float loadFactor, int concurrencyLevel) {\n-        map = new ConcurrentHashMap<>(initialCapacity, loadFactor, concurrencyLevel);\n-    }\n-\n-    public V get(K key) {\n-        V value = null;\n-\n-        cleanStaleEntries();\n-        CacheEntry<K, V> entry = map.get(key);\n-        if (entry != null) {\n-            value = entry.get();\n-        }\n-        if (value == null) {\n-            key = normalizeKey(key);\n-            V newVal = createObject(key);\n-            if (key == null || newVal == null) {\n-                \/\/ subclass must return non-null key\/value object\n-                return null;\n-            }\n-\n-            CacheEntry<K, V> newEntry = new CacheEntry<>(key, newVal, queue);\n-            entry = map.putIfAbsent(key, newEntry);\n-            if (entry == null) {\n-                value = newVal;\n-            } else {\n-                value = entry.get();\n-                if (value == null) {\n-                    map.put(key, newEntry);\n-                    value = newVal;\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-\n-    protected V put(K key, V value) {\n-        CacheEntry<K, V> entry = new CacheEntry<>(key, value, queue);\n-        CacheEntry<K, V> oldEntry = map.put(key, entry);\n-        return (oldEntry == null) ? null : oldEntry.get();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void cleanStaleEntries() {\n-        CacheEntry<K, V> entry;\n-        while ((entry = (CacheEntry<K, V>)queue.poll()) != null) {\n-            map.remove(entry.getKey(), entry);\n-        }\n-    }\n-\n-    protected abstract V createObject(K key);\n-\n-    protected K normalizeKey(K key) {\n-        return key;\n-    }\n-\n-    private static class CacheEntry<K, V> extends SoftReference<V> {\n-        private K key;\n-\n-        CacheEntry(K key, V value, ReferenceQueue<V> queue) {\n-            super(value, queue);\n-            this.key = key;\n-        }\n-\n-        K getKey() {\n-            return key;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/LocaleObjectCache.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"}]}