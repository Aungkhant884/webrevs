{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-import java.lang.ref.SoftReference;\n+import java.util.Map;\n@@ -41,0 +41,1 @@\n+import java.util.WeakHashMap;\n@@ -45,19 +46,19 @@\n-    public static final byte ENGLISH = 0,\n-            FRENCH = 1,\n-            GERMAN = 2,\n-            ITALIAN = 3,\n-            JAPANESE = 4,\n-            KOREAN = 5,\n-            CHINESE = 6,\n-            SIMPLIFIED_CHINESE = 7,\n-            TRADITIONAL_CHINESE = 8,\n-            FRANCE = 9,\n-            GERMANY = 10,\n-            ITALY = 11,\n-            JAPAN = 12,\n-            KOREA = 13,\n-            UK = 14,\n-            US = 15,\n-            CANADA = 16,\n-            CANADA_FRENCH = 17,\n-            ROOT = 18,\n+    public static final byte ROOT = 0,\n+            ENGLISH = 1,\n+            US = 2,\n+            FRENCH = 3,\n+            GERMAN = 4,\n+            ITALIAN = 5,\n+            JAPANESE = 6,\n+            KOREAN = 7,\n+            CHINESE = 8,\n+            SIMPLIFIED_CHINESE = 9,\n+            TRADITIONAL_CHINESE = 10,\n+            FRANCE = 11,\n+            GERMANY = 12,\n+            ITALY = 13,\n+            JAPAN = 14,\n+            KOREA = 15,\n+            UK = 16,\n+            CANADA = 17,\n+            CANADA_FRENCH = 18,\n@@ -93,0 +94,3 @@\n+    \/\/ Non-normalized to normalized BaseLocale cache for saving costly normalizations\n+    private static final Map<BaseLocale, BaseLocale> CACHE = new WeakHashMap<>();\n+\n@@ -110,15 +114,5 @@\n-    \/\/ This method must be called with normalize = false only when creating the\n-    \/\/ Locale.* constants and non-normalized BaseLocale$Keys used for lookup.\n-    private BaseLocale(String language, String script, String region, String variant,\n-                       boolean normalize) {\n-        if (normalize) {\n-            this.language = LocaleUtils.toLowerString(language).intern();\n-            this.script = LocaleUtils.toTitleString(script).intern();\n-            this.region = LocaleUtils.toUpperString(region).intern();\n-            this.variant = variant.intern();\n-        } else {\n-            this.language = language;\n-            this.script = script;\n-            this.region = region;\n-            this.variant = variant;\n-        }\n+    private BaseLocale(String language, String script, String region, String variant) {\n+        this.language = language;\n+        this.script = script;\n+        this.region = region;\n+        this.variant = variant;\n@@ -130,1 +124,1 @@\n-        return new BaseLocale(language, \"\", region, \"\", false);\n+        return new BaseLocale(language, \"\", region, \"\");\n@@ -168,2 +162,12 @@\n-        Key key = new Key(language, script, region, variant, false);\n-        return Cache.CACHE.get(key);\n+        \/\/ Obtain the \"normalized\" BaseLocale, using un-normalized\n+        \/\/ BaseLocale as the key. The returned \"normalized\" instance\n+        \/\/ can subsequently be used by the Locale instance which\n+        \/\/ guarantees the locale components are properly cased\/interned.\n+        synchronized (BaseLocale.class) {\n+            return CACHE.computeIfAbsent(new BaseLocale(language, script, region, variant),\n+                    (b) -> new BaseLocale(\n+                            LocaleUtils.toLowerString(b.getLanguage()).intern(),\n+                            LocaleUtils.toTitleString(b.getScript()).intern(),\n+                            LocaleUtils.toUpperString(b.getRegion()).intern(),\n+                            b.getVariant().intern()));\n+        }\n@@ -202,2 +206,6 @@\n-        if (!(obj instanceof BaseLocale)) {\n-            return false;\n+        if (obj instanceof BaseLocale other) {\n+            return LocaleUtils.caseIgnoreMatch(other.getLanguage(), language)\n+                && LocaleUtils.caseIgnoreMatch(other.getScript(), script)\n+                && LocaleUtils.caseIgnoreMatch(other.getRegion(), region)\n+                \/\/ variant is case sensitive in JDK!\n+                && other.getVariant().equals(variant);\n@@ -205,5 +213,1 @@\n-        BaseLocale other = (BaseLocale)obj;\n-        return language == other.language\n-               && script == other.script\n-               && region == other.region\n-               && variant == other.variant;\n+        return false;\n@@ -234,49 +238,1 @@\n-            \/\/ Generating a hash value from language, script, region and variant\n-            h = language.hashCode();\n-            h = 31 * h + script.hashCode();\n-            h = 31 * h + region.hashCode();\n-            h = 31 * h + variant.hashCode();\n-            if (h != 0) {\n-                hash = h;\n-            }\n-        }\n-        return h;\n-    }\n-\n-    private static final class Key {\n-        \/**\n-         * Keep a SoftReference to the Key data if normalized (actually used\n-         * as a cache key) and not initialized via the constant creation path.\n-         *\n-         * This allows us to avoid creating SoftReferences on lookup Keys\n-         * (which are short-lived) and for Locales created via\n-         * Locale#createConstant.\n-         *\/\n-        private final SoftReference<BaseLocale> holderRef;\n-        private final BaseLocale holder;\n-\n-        private final boolean normalized;\n-        private final int hash;\n-\n-        private Key(String language, String script, String region,\n-                    String variant, boolean normalize) {\n-            BaseLocale locale = new BaseLocale(language, script, region, variant, normalize);\n-            this.normalized = normalize;\n-            if (normalized) {\n-                this.holderRef = new SoftReference<>(locale);\n-                this.holder = null;\n-            } else {\n-                this.holderRef = null;\n-                this.holder = locale;\n-            }\n-            this.hash = hashCode(locale);\n-        }\n-\n-        public int hashCode() {\n-            return hash;\n-        }\n-\n-        private int hashCode(BaseLocale locale) {\n-            int h = 0;\n-            String lang = locale.getLanguage();\n-            int len = lang.length();\n+            int len = language.length();\n@@ -284,1 +240,1 @@\n-                h = 31*h + LocaleUtils.toLower(lang.charAt(i));\n+                h = 31*h + LocaleUtils.toLower(language.charAt(i));\n@@ -286,2 +242,1 @@\n-            String scrt = locale.getScript();\n-            len = scrt.length();\n+            len = script.length();\n@@ -289,1 +244,1 @@\n-                h = 31*h + LocaleUtils.toLower(scrt.charAt(i));\n+                h = 31*h + LocaleUtils.toLower(script.charAt(i));\n@@ -291,2 +246,1 @@\n-            String regn = locale.getRegion();\n-            len = regn.length();\n+            len = region.length();\n@@ -294,1 +248,1 @@\n-                h = 31*h + LocaleUtils.toLower(regn.charAt(i));\n+                h = 31*h + LocaleUtils.toLower(region.charAt(i));\n@@ -296,2 +250,1 @@\n-            String vart = locale.getVariant();\n-            len = vart.length();\n+            len = variant.length();\n@@ -299,1 +252,1 @@\n-                h = 31*h + vart.charAt(i);\n+                h = 31*h + variant.charAt(i);\n@@ -301,30 +254,2 @@\n-            return h;\n-        }\n-\n-        private BaseLocale getBaseLocale() {\n-            return (holder == null) ? holderRef.get() : holder;\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n-            }\n-            if (obj instanceof Key && this.hash == ((Key)obj).hash) {\n-                BaseLocale other = ((Key) obj).getBaseLocale();\n-                BaseLocale locale = this.getBaseLocale();\n-                if (other != null && locale != null\n-                    && LocaleUtils.caseIgnoreMatch(other.getLanguage(), locale.getLanguage())\n-                    && LocaleUtils.caseIgnoreMatch(other.getScript(), locale.getScript())\n-                    && LocaleUtils.caseIgnoreMatch(other.getRegion(), locale.getRegion())\n-                    \/\/ variant is case sensitive in JDK!\n-                    && other.getVariant().equals(locale.getVariant())) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        public static Key normalize(Key key) {\n-            if (key.normalized) {\n-                return key;\n+            if (h != 0) {\n+                hash = h;\n@@ -332,24 +257,0 @@\n-\n-            \/\/ Only normalized keys may be softly referencing the data holder\n-            assert (key.holder != null && key.holderRef == null);\n-            BaseLocale locale = key.holder;\n-            return new Key(locale.getLanguage(), locale.getScript(),\n-                    locale.getRegion(), locale.getVariant(), true);\n-        }\n-    }\n-\n-    private static class Cache extends LocaleObjectCache<Key, BaseLocale> {\n-\n-        private static final Cache CACHE = new Cache();\n-\n-        public Cache() {\n-        }\n-\n-        @Override\n-        protected Key normalizeKey(Key key) {\n-            return Key.normalize(key);\n-        }\n-\n-        @Override\n-        protected BaseLocale createObject(Key key) {\n-            return Key.normalize(key).getBaseLocale();\n@@ -357,0 +258,1 @@\n+        return h;\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":61,"deletions":159,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -151,0 +151,14 @@\n+\/*\n+ * @test id=iu-aggressive-comp\n+ * @summary Make sure Shenandoah can recover from humongous allocation fragmentation\n+ * @key randomness\n+ * @bug 8289220 8309622\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g -XX:ShenandoahTargetNumRegions=2048\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n+ *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify -Xcomp\n+ *      TestAllocHumongousFragment\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocHumongousFragment.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.text.DateFormat;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark tests if caching of Locale objects works\n+ * correctly.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 5)\n+public class LocaleCache {\n+    @Benchmark\n+    public void testForLanguageTag() {\n+        Locale previous = null;\n+        for (int count = 100; count > 0; count--) {\n+            var l = Locale.forLanguageTag(\"foo\");\n+            if (previous != null && previous != l) {\n+                throw new RuntimeException(\"Different Locale was created\");\n+            }\n+            previous =  l;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLocaleOf() {\n+        Locale previous = null;\n+        for (int count = 100; count > 0; count--) {\n+            var l = Locale.of(\"foo\");\n+            if (previous != null && previous != l) {\n+                throw new RuntimeException(\"Different Locale was created\");\n+            }\n+            previous =  l;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/LocaleCache.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}