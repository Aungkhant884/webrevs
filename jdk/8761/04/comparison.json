{"files":[{"patch":"@@ -196,1 +196,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+  void do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -204,1 +204,0 @@\n-    return true; \/\/ keep on iterating\n@@ -212,1 +211,1 @@\n-  iterate(&counter);\n+  iterate_all_live_classes(&counter);\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -212,2 +211,3 @@\n-  \/\/ Overrides ResourceHashtable<>::iterate(ITER*)\n-  template<class ITER> void iterate(ITER* iter) const;\n+  template<class ITER> void iterate_all_live_classes(ITER* iter) const;\n+  template<typename Function> void iterate_all_live_classes(Function function) const;\n+\n@@ -215,1 +215,7 @@\n-  template<class ITER> class IterationHelper;\n+  \/\/ It's unsafe to iterate on classes whose loader is dead.\n+  \/\/ Declare these private and don't implement them. This forces users of\n+  \/\/ DumpTimeSharedClassTable to use the iterate_all_live_classes() methods\n+  \/\/ instead.\n+  template<class ITER> void iterate(ITER* iter) const;\n+  template<typename Function> void iterate(Function function) const;\n+  template<typename Function> void iterate_all(Function function) const;\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,2 @@\n-\/\/ For safety, only iterate over a class if it loader is alive.\n-\/\/ IterationHelper and DumpTimeSharedClassTable::iterate\n-\/\/ must be used only inside a safepoint, where the value of\n+\/\/ For safety, only iterate over a class if its loader is alive.\n+\/\/ This function must be called only inside a safepoint, where the value of\n@@ -42,8 +41,3 @@\n-template<class ITER>\n-class DumpTimeSharedClassTable::IterationHelper {\n-  ITER* _iter;\n-public:\n-  IterationHelper(ITER* iter) {\n-    _iter = iter;\n-  }\n-  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+template<typename Function>\n+void DumpTimeSharedClassTable::iterate_all_live_classes(Function function) const {\n+  auto wrapper = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -53,1 +47,1 @@\n-      bool result = _iter->do_entry(k, info);\n+      function(k, info);\n@@ -55,1 +49,0 @@\n-      return result;\n@@ -61,1 +54,0 @@\n-      return true;\n@@ -63,2 +55,4 @@\n-  }\n-};\n+  };\n+  DumpTimeSharedClassTableBaseType::iterate_all(wrapper);\n+}\n+\n@@ -67,3 +61,5 @@\n-void DumpTimeSharedClassTable::iterate(ITER* iter) const {\n-  IterationHelper<ITER> helper(iter);\n-  DumpTimeSharedClassTableBaseType::iterate(&helper);\n+void DumpTimeSharedClassTable::iterate_all_live_classes(ITER* iter) const {\n+  auto function = [&] (InstanceKlass* k, DumpTimeClassInfo& v) {\n+    iter->do_entry(k, v);\n+  };\n+  iterate_all_live_classes(function);\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.inline.hpp","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -620,1 +620,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+  void do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -624,1 +624,0 @@\n-    return true;  \/\/ keep on iterating\n@@ -656,8 +655,0 @@\n-class ExcludeDumpTimeSharedClasses : StackObj {\n-public:\n-  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n-    SystemDictionaryShared::check_for_exclusion(k, &info);\n-    return true; \/\/ keep on iterating\n-  }\n-};\n-\n@@ -670,1 +661,1 @@\n-    \/\/ all of its subclasses will also be excluded by ExcludeDumpTimeSharedClasses\n+    \/\/ all of its subclasses will also be excluded.\n@@ -673,1 +664,1 @@\n-    _dumptime_table->iterate(&dup_checker);\n+    _dumptime_table->iterate_all_live_classes(&dup_checker);\n@@ -677,2 +668,4 @@\n-  ExcludeDumpTimeSharedClasses excl;\n-  _dumptime_table->iterate(&excl);\n+  auto check_for_exclusion = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+    SystemDictionaryShared::check_for_exclusion(k, &info);\n+  };\n+  _dumptime_table->iterate_all_live_classes(check_for_exclusion);\n@@ -728,4 +721,2 @@\n-class IterateDumpTimeSharedClassTable : StackObj {\n-  MetaspaceClosure *_it;\n-public:\n-  IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}\n+void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {\n+  assert_lock_strong(DumpTimeTable_lock);\n@@ -733,2 +724,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n-    assert_lock_strong(DumpTimeTable_lock);\n+  auto do_klass = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -736,1 +726,1 @@\n-      info.metaspace_pointers_do(_it);\n+      info.metaspace_pointers_do(it);\n@@ -738,3 +728,2 @@\n-    return true; \/\/ keep on iterating\n-  }\n-};\n+  };\n+  _dumptime_table->iterate_all_live_classes(do_klass);\n@@ -742,19 +731,0 @@\n-class IterateDumpTimeLambdaProxyClassDictionary : StackObj {\n-  MetaspaceClosure *_it;\n-public:\n-  IterateDumpTimeLambdaProxyClassDictionary(MetaspaceClosure* it) : _it(it) {}\n-\n-  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    assert_lock_strong(DumpTimeTable_lock);\n-    if (key.caller_ik()->is_loader_alive()) {\n-      info.metaspace_pointers_do(_it);\n-      key.metaspace_pointers_do(_it);\n-    }\n-    return true; \/\/ keep on iterating\n-  }\n-};\n-\n-void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {\n-  assert_lock_strong(DumpTimeTable_lock);\n-  IterateDumpTimeSharedClassTable iter(it);\n-  _dumptime_table->iterate(&iter);\n@@ -762,2 +732,7 @@\n-    IterateDumpTimeLambdaProxyClassDictionary iter_lambda(it);\n-    _dumptime_lambda_proxy_class_dictionary->iterate(&iter_lambda);\n+    auto do_lambda = [&] (LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+      if (key.caller_ik()->is_loader_alive()) {\n+        info.metaspace_pointers_do(it);\n+        key.metaspace_pointers_do(it);\n+      }\n+    };\n+    _dumptime_lambda_proxy_class_dictionary->iterate_all(do_lambda);\n@@ -1175,1 +1150,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+  void do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1180,1 +1155,0 @@\n-    return true; \/\/ keep on iterating\n@@ -1190,1 +1164,1 @@\n-  _dumptime_table->iterate(&est);\n+  _dumptime_table->iterate_all_live_classes(&est);\n@@ -1284,1 +1258,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+  void do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1308,1 +1282,0 @@\n-    return true; \/\/ keep on iterating\n@@ -1328,1 +1301,1 @@\n-  _dumptime_table->iterate(&copy);\n+  _dumptime_table->iterate_all_live_classes(&copy);\n@@ -1561,1 +1534,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+  void do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1566,1 +1539,0 @@\n-    return true; \/\/ keep on iterating\n@@ -1599,1 +1571,1 @@\n-    _dumptime_table->iterate(&copy_classes);\n+    _dumptime_table->iterate_all_live_classes(&copy_classes);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":26,"deletions":54,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,0 +206,8 @@\n+    auto function = [&] (K& k, V& v) {\n+      return iter->do_entry(k, v);\n+    };\n+    iterate(function);\n+  }\n+\n+  template<typename Function>\n+  void iterate(Function function) const { \/\/ lambda enabled API\n@@ -211,1 +219,1 @@\n-        bool cont = iter->do_entry(node->_key, node->_value);\n+        bool cont = function(node->_key, node->_value);\n@@ -219,0 +227,10 @@\n+  \/\/ same as above, but unconditionally iterate all entries\n+  template<typename Function>\n+  void iterate_all(Function function) const { \/\/ lambda enabled API\n+    auto wrapper = [&] (K& k, V& v) {\n+      function(k, v);\n+      return true;\n+    };\n+    iterate(wrapper);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"}]}