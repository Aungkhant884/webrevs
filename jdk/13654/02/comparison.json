{"files":[{"patch":"@@ -87,2 +87,2 @@\n-  _uses_monitors      = h_m->access_flags().has_monitor_bytecodes();\n-  _balanced_monitors  = !_uses_monitors || h_m->access_flags().is_monitor_matching();\n+  _uses_monitors      = h_m->has_monitor_bytecodes();\n+  _balanced_monitors  = !_uses_monitors || h_m->guaranteed_monitor_matching();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1981,1 +1981,1 @@\n-    m->set_caller_sensitive(true);\n+    m->set_caller_sensitive();\n@@ -1983,1 +1983,1 @@\n-    m->set_force_inline(true);\n+    m->set_force_inline();\n@@ -1985,1 +1985,1 @@\n-    m->set_dont_inline(true);\n+    m->set_dont_inline();\n@@ -1987,1 +1987,1 @@\n-    m->set_changes_current_thread(true);\n+    m->set_changes_current_thread();\n@@ -1989,1 +1989,1 @@\n-    m->set_jvmti_mount_transition(true);\n+    m->set_jvmti_mount_transition();\n@@ -1991,1 +1991,1 @@\n-    m->set_has_injected_profile(true);\n+    m->set_has_injected_profile();\n@@ -1995,1 +1995,1 @@\n-    m->set_hidden(true);\n+    m->set_is_hidden();\n@@ -1997,1 +1997,1 @@\n-    m->set_scoped(true);\n+    m->set_scoped();\n@@ -1999,1 +1999,1 @@\n-    m->set_intrinsic_candidate(true);\n+    m->set_intrinsic_candidate();\n@@ -2001,1 +2001,1 @@\n-    m->set_has_reserved_stack_access(true);\n+    m->set_has_reserved_stack_access();\n@@ -2742,1 +2742,1 @@\n-    m->set_hidden(true);\n+    m->set_is_hidden();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -479,1 +479,1 @@\n-  if (const_method->has_exception_handler()) {\n+  if (const_method->has_exception_table()) {\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-  \/\/ Update access flags\n+  \/\/ Update flags\n@@ -485,2 +485,0 @@\n-    \/\/ Second pass will revisit this method.\n-    assert(method->has_jsrs(), \"didn't we just set this?\");\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -929,2 +929,2 @@\n-  method->set_not_c1_compilable();\n-  method->set_not_c2_compilable();\n+  method->set_is_not_c1_compilable();\n+  method->set_is_not_c2_compilable();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  nonstatic_field(ConstMethod,                 _flags,                                 u2)                                           \\\n+  nonstatic_field(ConstMethod,                 _flags._flags,                          u4)                                           \\\n@@ -231,1 +231,1 @@\n-  nonstatic_field(Method,                      _flags,                                        u2)                                    \\\n+  nonstatic_field(Method,                      _flags._status,                                u4)                                    \\\n@@ -419,2 +419,0 @@\n-  declare_constant(JVM_ACC_MONITOR_MATCH)                                 \\\n-  declare_constant(JVM_ACC_HAS_MONITOR_BYTECODES)                         \\\n@@ -585,5 +583,10 @@\n-  declare_constant(ConstMethod::_has_linenumber_table)                    \\\n-  declare_constant(ConstMethod::_has_localvariable_table)                 \\\n-  declare_constant(ConstMethod::_has_exception_table)                     \\\n-  declare_constant(ConstMethod::_has_method_annotations)                  \\\n-  declare_constant(ConstMethod::_has_parameter_annotations)               \\\n+  declare_constant(ConstMethodFlags::_misc_has_linenumber_table)          \\\n+  declare_constant(ConstMethodFlags::_misc_has_localvariable_table)       \\\n+  declare_constant(ConstMethodFlags::_misc_has_exception_table)           \\\n+  declare_constant(ConstMethodFlags::_misc_has_method_annotations)        \\\n+  declare_constant(ConstMethodFlags::_misc_has_parameter_annotations)     \\\n+  declare_constant(ConstMethodFlags::_misc_caller_sensitive)              \\\n+  declare_constant(ConstMethodFlags::_misc_is_hidden)                     \\\n+  declare_constant(ConstMethodFlags::_misc_intrinsic_candidate)           \\\n+  declare_constant(ConstMethodFlags::_misc_reserved_stack_access)         \\\n+  declare_constant(ConstMethodFlags::_misc_changes_current_thread)        \\\n@@ -686,7 +689,2 @@\n-  declare_constant(Method::_caller_sensitive)                             \\\n-  declare_constant(Method::_force_inline)                                 \\\n-  declare_constant(Method::_dont_inline)                                  \\\n-  declare_constant(Method::_hidden)                                       \\\n-  declare_constant(Method::_intrinsic_candidate)                          \\\n-  declare_constant(Method::_reserved_stack_access)                        \\\n-  declare_constant(Method::_changes_current_thread)                       \\\n+  declare_constant(MethodFlags::_misc_force_inline)                       \\\n+  declare_constant(MethodFlags::_misc_dont_inline)                        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-  assert(has_exception_handler(), \"called only if table is present\");\n+  assert(has_exception_table(), \"called only if table is present\");\n@@ -220,1 +220,1 @@\n-  if (has_exception_handler()) {\n+  if (has_exception_table()) {\n@@ -242,1 +242,0 @@\n-  _flags = 0;\n@@ -244,1 +243,1 @@\n-    _flags |= _has_linenumber_table;\n+    set_has_linenumber_table();\n@@ -246,1 +245,1 @@\n-    _flags |= _has_generic_signature;\n+    set_has_generic_signature();\n@@ -248,1 +247,1 @@\n-    _flags |= _has_method_parameters;\n+    set_has_method_parameters();\n@@ -250,1 +249,1 @@\n-    _flags |= _has_checked_exceptions;\n+    set_has_checked_exceptions();\n@@ -252,1 +251,1 @@\n-    _flags |= _has_exception_table;\n+    set_has_exception_table();\n@@ -254,1 +253,1 @@\n-    _flags |= _has_localvariable_table;\n+    set_has_localvariable_table();\n@@ -259,1 +258,1 @@\n-    _flags |= _has_method_annotations;\n+    set_has_method_annotations();\n@@ -261,1 +260,1 @@\n-    _flags |= _has_parameter_annotations;\n+    set_has_parameter_annotations();\n@@ -263,1 +262,1 @@\n-    _flags |= _has_type_annotations;\n+    set_has_type_annotations();\n@@ -265,1 +264,1 @@\n-    _flags |= _has_default_annotations;\n+    set_has_default_annotations();\n@@ -332,1 +331,1 @@\n-  return has_exception_handler() ? *(exception_table_length_addr()) : 0;\n+  return has_exception_table() ? *(exception_table_length_addr()) : 0;\n@@ -439,0 +438,1 @@\n+  st->print(\" - flags:             \"); _flags.print_on(st);               st->cr();\n@@ -487,1 +487,1 @@\n-  if (has_exception_handler()) {\n+  if (has_exception_table()) {\n@@ -499,1 +499,1 @@\n-  } else if (has_exception_handler()) {\n+  } else if (has_exception_table()) {\n","filename":"src\/hotspot\/share\/oops\/constMethod.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/constMethodFlags.hpp\"\n@@ -176,13 +177,0 @@\n-  enum {\n-    _has_linenumber_table = 0x0001,\n-    _has_checked_exceptions = 0x0002,\n-    _has_localvariable_table = 0x0004,\n-    _has_exception_table = 0x0008,\n-    _has_generic_signature = 0x0010,\n-    _has_method_parameters = 0x0020,\n-    _is_overpass = 0x0040,\n-    _has_method_annotations = 0x0080,\n-    _has_parameter_annotations = 0x0100,\n-    _has_type_annotations = 0x0200,\n-    _has_default_annotations = 0x0400\n-  };\n@@ -207,1 +195,1 @@\n-  u2                _flags;\n+  ConstMethodFlags  _flags;                       \/\/ for sizing\n@@ -239,17 +227,6 @@\n-  bool has_generic_signature() const\n-    { return (_flags & _has_generic_signature) != 0; }\n-\n-  bool has_linenumber_table() const\n-    { return (_flags & _has_linenumber_table) != 0; }\n-\n-  bool has_checked_exceptions() const\n-    { return (_flags & _has_checked_exceptions) != 0; }\n-\n-  bool has_localvariable_table() const\n-    { return (_flags & _has_localvariable_table) != 0; }\n-\n-  bool has_exception_handler() const\n-    { return (_flags & _has_exception_table) != 0; }\n-\n-  bool has_method_parameters() const\n-    { return (_flags & _has_method_parameters) != 0; }\n+  \/\/ Create getters and setters for the flag values.\n+#define CM_FLAGS_GET_SET(name, ignore)          \\\n+  bool name() const       { return _flags.name(); } \\\n+  void set_##name()       { _flags.set_##name(); }\n+  CM_FLAGS_DO(CM_FLAGS_GET_SET)\n+#undef CM_FLAGS_GET_SET\n@@ -258,1 +235,1 @@\n-    return ((_flags & _is_overpass) == 0) ? NORMAL : OVERPASS;\n+    return (_flags.is_overpass()) ? OVERPASS : NORMAL;\n@@ -262,4 +239,2 @@\n-    if (mt == NORMAL) {\n-      _flags &= ~(_is_overpass);\n-    } else {\n-      _flags |= _is_overpass;\n+    if (mt != NORMAL) {\n+      set_is_overpass();\n@@ -385,14 +360,0 @@\n-  \/\/ method annotations\n-  bool has_method_annotations() const\n-    { return (_flags & _has_method_annotations) != 0; }\n-\n-  bool has_parameter_annotations() const\n-    { return (_flags & _has_parameter_annotations) != 0; }\n-\n-  bool has_type_annotations() const\n-    { return (_flags & _has_type_annotations) != 0; }\n-\n-  bool has_default_annotations() const\n-    { return (_flags & _has_default_annotations) != 0; }\n-\n-\n","filename":"src\/hotspot\/share\/oops\/constMethod.hpp","additions":11,"deletions":50,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/constMethodFlags.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+void ConstMethodFlags::print_on(outputStream* st) const {\n+#define CM_PRINT(name, ignore)          \\\n+  if (name()) st->print(\" \" #name \" \");\n+  CM_FLAGS_DO(CM_PRINT)\n+#undef CM_PRINT\n+  st->cr();\n+}\n","filename":"src\/hotspot\/share\/oops\/constMethodFlags.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_CONSTMETHODFLAGS_HPP\n+#define SHARE_OOPS_CONSTMETHODFLAGS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class outputStream;\n+\n+\/\/ The ConstMethodFlags class contains the parse-time flags associated with\n+\/\/ a Method, and its associated accessors.\n+\/\/ These flags are JVM internal and not part of the AccessFlags classfile specification.\n+\n+class ConstMethodFlags {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+\n+#define CM_FLAGS_DO(flag)  \\\n+   flag(has_linenumber_table      , 1 << 0) \\\n+   flag(has_checked_exceptions    , 1 << 1) \\\n+   flag(has_localvariable_table   , 1 << 2) \\\n+   flag(has_exception_table       , 1 << 3) \\\n+   flag(has_generic_signature     , 1 << 4) \\\n+   flag(has_method_parameters     , 1 << 5) \\\n+   flag(is_overpass               , 1 << 6) \\\n+   flag(has_method_annotations    , 1 << 7) \\\n+   flag(has_parameter_annotations , 1 << 8) \\\n+   flag(has_type_annotations      , 1 << 9) \\\n+   flag(has_default_annotations   , 1 << 10) \\\n+   flag(caller_sensitive          , 1 << 11) \\\n+   flag(is_hidden                 , 1 << 12) \\\n+   flag(has_injected_profile      , 1 << 13) \\\n+   flag(intrinsic_candidate       , 1 << 14) \\\n+   flag(reserved_stack_access     , 1 << 15) \\\n+   flag(is_scoped                 , 1 << 16) \\\n+   flag(changes_current_thread    , 1 << 17) \\\n+   flag(jvmti_mount_transition    , 1 << 18) \\\n+   \/* end of list *\/\n+\n+#define CM_FLAGS_ENUM_NAME(name, value)    _misc_##name = value,\n+  enum {\n+    CM_FLAGS_DO(CM_FLAGS_ENUM_NAME)\n+  };\n+#undef CM_FLAGS_ENUM_NAME\n+\n+  \/\/ These flags are write-once before the class is published and then read-only so don't require atomic updates.\n+  u4 _flags;\n+\n+ public:\n+\n+  ConstMethodFlags() : _flags(0) {}\n+\n+  \/\/ Create getters and setters for the flag values.\n+#define CM_FLAGS_GET_SET(name, ignore)          \\\n+  bool name() const { return (_flags & _misc_##name) != 0; } \\\n+  void set_##name() {         \\\n+    _flags |= _misc_##name;  \\\n+  }\n+  CM_FLAGS_DO(CM_FLAGS_GET_SET)\n+#undef CM_FLAGS_GET_SET\n+\n+void print_on(outputStream* st) const;\n+};\n+\n+#endif \/\/ SHARE_OOPS_CONSTMETHODFLAGS_HPP\n","filename":"src\/hotspot\/share\/oops\/constMethodFlags.hpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -3480,0 +3480,1 @@\n+  st->print(BULLET\"flags:             \"); _misc_flags.print_on(st);               st->cr();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -54,0 +55,9 @@\n+void InstanceKlassFlags::print_on(outputStream* st) const {\n+#define IK_FLAGS_PRINT(name, ignore)          \\\n+  if (name()) st->print(\" ##name \");\n+  IK_FLAGS_DO(IK_FLAGS_PRINT)\n+  IK_STATUS_DO(IK_FLAGS_PRINT)\n+#undef IK_FLAGS_PRINT\n+  st->cr();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,2 @@\n-    status(is_marked_dependent               , 1 << 4) \/* class is the redefined scratch class *\/\n+    status(is_marked_dependent               , 1 << 4) \/* class is the redefined scratch class *\/ \\\n+    \/* end of list *\/\n@@ -92,6 +93,2 @@\n-#define IK_FLAGS_GET(name, ignore)          \\\n-  bool name() const { return (_flags & _misc_##name) != 0; }\n-  IK_FLAGS_DO(IK_FLAGS_GET)\n-#undef IK_FLAGS_GET\n-\n-#define IK_FLAGS_SET(name, ignore)   \\\n+#define IK_FLAGS_GET_SET(name, ignore)          \\\n+  bool name() const { return (_flags & _misc_##name) != 0; } \\\n@@ -102,2 +99,2 @@\n-  IK_FLAGS_DO(IK_FLAGS_SET)\n-#undef IK_FLAGS_SET\n+  IK_FLAGS_DO(IK_FLAGS_GET_SET)\n+#undef IK_FLAGS_GET_SET\n@@ -115,6 +112,2 @@\n-#define IK_STATUS_GET(name, ignore)          \\\n-  bool name() const { return (_status & _misc_##name) != 0; }\n-  IK_STATUS_DO(IK_STATUS_GET)\n-#undef IK_STATUS_GET\n-\n-#define IK_STATUS_SET(name, ignore)   \\\n+#define IK_STATUS_GET_SET(name, ignore)          \\\n+  bool name() const { return (_status & _misc_##name) != 0; } \\\n@@ -128,2 +121,2 @@\n-  IK_STATUS_DO(IK_STATUS_SET)\n-#undef IK_STATUS_SET\n+  IK_STATUS_DO(IK_STATUS_GET_SET)\n+#undef IK_STATUS_GET_SET\n@@ -133,0 +126,1 @@\n+  void print_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -105,5 +105,0 @@\n-  set_force_inline(false);\n-  set_hidden(false);\n-  set_dont_inline(false);\n-  set_changes_current_thread(false);\n-  set_has_injected_profile(false);\n@@ -739,1 +734,3 @@\n-        if (bcs.dest() < bcs.next_bci()) _access_flags.set_has_loops();\n+        if (bcs.dest() < bcs.next_bci()) {\n+          return set_has_loops();\n+        }\n@@ -744,1 +741,3 @@\n-        if (bcs.dest_w() < bcs.next_bci()) _access_flags.set_has_loops();\n+        if (bcs.dest_w() < bcs.next_bci()) {\n+          return set_has_loops();\n+        }\n@@ -750,1 +749,1 @@\n-          _access_flags.set_has_loops();\n+          return set_has_loops();\n@@ -755,2 +754,1 @@\n-              _access_flags.set_has_loops();\n-              break;\n+              return set_has_loops();\n@@ -765,1 +763,1 @@\n-          _access_flags.set_has_loops();\n+          return set_has_loops();\n@@ -769,1 +767,1 @@\n-              _access_flags.set_has_loops();\n+              return set_has_loops();\n@@ -779,2 +777,3 @@\n-  _access_flags.set_loops_flag_init();\n-  return _access_flags.has_loops();\n+\n+  _flags.set_has_loops_flag_init(true);\n+  return false;\n@@ -1111,2 +1110,2 @@\n-    set_not_c1_compilable();\n-    set_not_c2_compilable();\n+    set_is_not_c1_compilable();\n+    set_is_not_c2_compilable();\n@@ -1115,1 +1114,1 @@\n-      set_not_c1_compilable();\n+      set_is_not_c1_compilable();\n@@ -1117,1 +1116,1 @@\n-      set_not_c2_compilable();\n+      set_is_not_c2_compilable();\n@@ -1137,2 +1136,2 @@\n-    set_not_c1_osr_compilable();\n-    set_not_c2_osr_compilable();\n+    set_is_not_c1_osr_compilable();\n+    set_is_not_c2_osr_compilable();\n@@ -1141,1 +1140,1 @@\n-      set_not_c1_osr_compilable();\n+      set_is_not_c1_osr_compilable();\n@@ -1143,1 +1142,1 @@\n-      set_not_c2_osr_compilable();\n+      set_is_not_c2_osr_compilable();\n@@ -1666,1 +1665,1 @@\n-      set_force_inline(true);\n+      set_force_inline();\n@@ -2244,2 +2243,2 @@\n-  bool already_set = on_stack();\n-  _access_flags.set_on_stack(value);\n+  bool already_set = on_stack_flag();\n+  set_on_stack_flag(value);\n@@ -2307,0 +2306,1 @@\n+  st->print   (\" - flags:             0x%x  \", _flags.as_int()); _flags.print_on(st); st->cr();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/methodFlags.hpp\"\n@@ -82,2 +83,1 @@\n-                                                 \/\/ note: can have vtables with >2**16 elements (because of inheritance)\n-  u2                _intrinsic_id;               \/\/ vmSymbols::intrinsic_id (0 == _none)\n+  MethodFlags       _flags;\n@@ -85,14 +85,1 @@\n-  \/\/ Flags\n-  enum Flags {\n-    _caller_sensitive       = 1 << 0,\n-    _force_inline           = 1 << 1,\n-    _dont_inline            = 1 << 2,\n-    _hidden                 = 1 << 3,\n-    _has_injected_profile   = 1 << 4,\n-    _intrinsic_candidate    = 1 << 5,\n-    _reserved_stack_access  = 1 << 6,\n-    _scoped                 = 1 << 7,\n-    _changes_current_thread = 1 << 8,\n-    _jvmti_mount_transition = 1 << 9,\n-  };\n-  mutable u2 _flags;\n+  u2                _intrinsic_id;               \/\/ vmSymbols::intrinsic_id (0 == _none)\n@@ -335,1 +322,1 @@\n-                             { return constMethod()->has_exception_handler(); }\n+                             { return constMethod()->has_exception_table(); }\n@@ -605,0 +592,8 @@\n+  \/\/ Flags getting and setting.\n+#define M_STATUS_GET_SET(name, ignore)          \\\n+  bool name() const { return _flags.name(); }   \\\n+  void set_##name(bool x) { _flags.set_##name(x); } \\\n+  void set_##name() { _flags.set_##name(true); }\n+  M_STATUS_DO(M_STATUS_GET_SET)\n+#undef M_STATUS_GET_SET\n+\n@@ -607,1 +602,1 @@\n-    return access_flags().loops_flag_init() ? access_flags().has_loops() : compute_has_loops_flag();\n+    return has_loops_flag_init() ? has_loops_flag() : compute_has_loops_flag();\n@@ -611,7 +606,1 @@\n-\n-  bool has_jsrs() {\n-    return access_flags().has_jsrs();\n-  };\n-  void set_has_jsrs() {\n-    _access_flags.set_has_jsrs();\n-  }\n+  bool set_has_loops() { set_has_loops_flag(); set_has_loops_flag_init(); return true; }\n@@ -620,4 +609,1 @@\n-  bool has_monitors() const                      { return is_synchronized() || access_flags().has_monitor_bytecodes(); }\n-  bool has_monitor_bytecodes() const             { return access_flags().has_monitor_bytecodes(); }\n-\n-  void set_has_monitor_bytecodes()               { _access_flags.set_has_monitor_bytecodes(); }\n+  bool has_monitors() const                      { return is_synchronized() || has_monitor_bytecodes(); }\n@@ -626,1 +612,1 @@\n-  \/\/ propererly nest in the method. It might return false, even though they actually nest properly, since the info.\n+  \/\/ properly nest in the method. It might return false, even though they actually nest properly, since the info.\n@@ -628,2 +614,2 @@\n-  bool guaranteed_monitor_matching() const       { return access_flags().is_monitor_matching(); }\n-  void set_guaranteed_monitor_matching()         { _access_flags.set_monitor_matching(); }\n+  bool guaranteed_monitor_matching() const       { return monitor_matching(); }\n+  void set_guaranteed_monitor_matching()         { set_monitor_matching(); }\n@@ -748,8 +734,1 @@\n-  bool is_old() const                               { return access_flags().is_old(); }\n-  void set_is_old()                                 { _access_flags.set_is_old(); }\n-  bool is_obsolete() const                          { return access_flags().is_obsolete(); }\n-  void set_is_obsolete()                            { _access_flags.set_is_obsolete(); }\n-  bool is_deleted() const                           { return access_flags().is_deleted(); }\n-  void set_is_deleted()                             { _access_flags.set_is_deleted(); }\n-\n-  bool on_stack() const                             { return access_flags().on_stack(); }\n+  bool on_stack() const                             { return on_stack_flag(); }\n@@ -763,4 +742,0 @@\n-  \/\/ JVMTI Native method prefixing support:\n-  bool is_prefixed_native() const                   { return access_flags().is_prefixed_native(); }\n-  void set_is_prefixed_native()                     { _access_flags.set_is_prefixed_native(); }\n-\n@@ -823,27 +798,2 @@\n-  bool caller_sensitive() {\n-    return (_flags & _caller_sensitive) != 0;\n-  }\n-  void set_caller_sensitive(bool x) {\n-    _flags = x ? (_flags | _caller_sensitive) : (_flags & ~_caller_sensitive);\n-  }\n-\n-  bool force_inline() {\n-    return (_flags & _force_inline) != 0;\n-  }\n-  void set_force_inline(bool x) {\n-    _flags = x ? (_flags | _force_inline) : (_flags & ~_force_inline);\n-  }\n-\n-  bool dont_inline() {\n-    return (_flags & _dont_inline) != 0;\n-  }\n-  void set_dont_inline(bool x) {\n-    _flags = x ? (_flags | _dont_inline) : (_flags & ~_dont_inline);\n-  }\n-\n-  bool changes_current_thread() {\n-    return (_flags & _changes_current_thread) != 0;\n-  }\n-  void set_changes_current_thread(bool x) {\n-    _flags = x ? (_flags | _changes_current_thread) : (_flags & ~_changes_current_thread);\n-  }\n+  bool caller_sensitive() const     { return constMethod()->caller_sensitive(); }\n+  void set_caller_sensitive() { constMethod()->set_caller_sensitive(); }\n@@ -851,6 +801,2 @@\n-  bool jvmti_mount_transition() {\n-    return (_flags & _jvmti_mount_transition) != 0;\n-  }\n-  void set_jvmti_mount_transition(bool x) {\n-    _flags = x ? (_flags | _jvmti_mount_transition) : (_flags & ~_jvmti_mount_transition);\n-  }\n+  bool changes_current_thread() const { return constMethod()->changes_current_thread(); }\n+  void set_changes_current_thread() { constMethod()->set_changes_current_thread(); }\n@@ -858,3 +804,2 @@\n-  bool is_hidden() const {\n-    return (_flags & _hidden) != 0;\n-  }\n+  bool jvmti_mount_transition() const { return constMethod()->jvmti_mount_transition(); }\n+  void set_jvmti_mount_transition() { constMethod()->set_jvmti_mount_transition(); }\n@@ -862,3 +807,2 @@\n-  void set_hidden(bool x) {\n-    _flags = x ? (_flags | _hidden) : (_flags & ~_hidden);\n-  }\n+  bool is_hidden() const { return constMethod()->is_hidden(); }\n+  void set_is_hidden() { constMethod()->set_is_hidden(); }\n@@ -866,3 +810,2 @@\n-  bool is_scoped() const {\n-    return (_flags & _scoped) != 0;\n-  }\n+  bool is_scoped() const { return constMethod()->is_scoped(); }\n+  void set_scoped() { constMethod()->set_is_scoped(); }\n@@ -870,3 +813,2 @@\n-  void set_scoped(bool x) {\n-    _flags = x ? (_flags | _scoped) : (_flags & ~_scoped);\n-  }\n+  bool intrinsic_candidate() const { return constMethod()->intrinsic_candidate(); }\n+  void set_intrinsic_candidate() { constMethod()->set_intrinsic_candidate(); }\n@@ -874,17 +816,2 @@\n-  bool intrinsic_candidate() {\n-    return (_flags & _intrinsic_candidate) != 0;\n-  }\n-  void set_intrinsic_candidate(bool x) {\n-    _flags = x ? (_flags | _intrinsic_candidate) : (_flags & ~_intrinsic_candidate);\n-  }\n-\n-  bool has_injected_profile() {\n-    return (_flags & _has_injected_profile) != 0;\n-  }\n-  void set_has_injected_profile(bool x) {\n-    _flags = x ? (_flags | _has_injected_profile) : (_flags & ~_has_injected_profile);\n-  }\n-\n-  bool has_reserved_stack_access() {\n-    return (_flags & _reserved_stack_access) != 0;\n-  }\n+  bool has_injected_profile() const { return constMethod()->has_injected_profile(); }\n+  void set_has_injected_profile() { constMethod()->set_has_injected_profile(); }\n@@ -892,3 +819,2 @@\n-  void set_has_reserved_stack_access(bool x) {\n-    _flags = x ? (_flags | _reserved_stack_access) : (_flags & ~_reserved_stack_access);\n-  }\n+  bool has_reserved_stack_access() const { return constMethod()->reserved_stack_access(); }\n+  void set_has_reserved_stack_access() { constMethod()->set_reserved_stack_access(); }\n@@ -942,6 +868,3 @@\n-  bool   is_not_c1_compilable() const         { return access_flags().is_not_c1_compilable();  }\n-  void  set_not_c1_compilable()               {       _access_flags.set_not_c1_compilable();   }\n-  void clear_not_c1_compilable()              {       _access_flags.clear_not_c1_compilable(); }\n-  bool   is_not_c2_compilable() const         { return access_flags().is_not_c2_compilable();  }\n-  void  set_not_c2_compilable()               {       _access_flags.set_not_c2_compilable();   }\n-  void clear_not_c2_compilable()              {       _access_flags.clear_not_c2_compilable(); }\n+  void clear_is_not_c1_compilable()           { set_is_not_c1_compilable(false); }\n+  void clear_is_not_c2_compilable()           { set_is_not_c2_compilable(false); }\n+  void clear_is_not_c2_osr_compilable()       { set_is_not_c2_osr_compilable(false); }\n@@ -949,6 +872,4 @@\n-  bool    is_not_c1_osr_compilable() const    { return is_not_c1_compilable(); }  \/\/ don't waste an accessFlags bit\n-  void   set_not_c1_osr_compilable()          {       set_not_c1_compilable(); }  \/\/ don't waste an accessFlags bit\n-  void clear_not_c1_osr_compilable()          {     clear_not_c1_compilable(); }  \/\/ don't waste an accessFlags bit\n-  bool   is_not_c2_osr_compilable() const     { return access_flags().is_not_c2_osr_compilable();  }\n-  void  set_not_c2_osr_compilable()           {       _access_flags.set_not_c2_osr_compilable();   }\n-  void clear_not_c2_osr_compilable()          {       _access_flags.clear_not_c2_osr_compilable(); }\n+  \/\/ not_c1_osr_compilable == not_c1_compilable\n+  bool    is_not_c1_osr_compilable() const    { return is_not_c1_compilable(); }\n+  void   set_is_not_c1_osr_compilable()       {       set_is_not_c1_compilable(); }\n+  void clear_is_not_c1_osr_compilable()       {     clear_is_not_c1_compilable(); }\n@@ -957,3 +878,1 @@\n-  bool queued_for_compilation() const  { return access_flags().queued_for_compilation(); }\n-  void set_queued_for_compilation()    { _access_flags.set_queued_for_compilation();     }\n-  void clear_queued_for_compilation()  { _access_flags.clear_queued_for_compilation();   }\n+  void clear_queued_for_compilation()  { set_queued_for_compilation(false);   }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":43,"deletions":124,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/methodFlags.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ This can be removed for the atomic bitset functions, when available.\n+void MethodFlags::atomic_set_bits(u4 bits) {\n+  \/\/ Atomically update the status with the bits given\n+  u4 old_status, new_status, f;\n+  do {\n+    old_status = _status;\n+    new_status = old_status | bits;\n+    f = Atomic::cmpxchg(&_status, old_status, new_status);\n+  } while(f != old_status);\n+}\n+\n+void MethodFlags::atomic_clear_bits(u4 bits) {\n+  \/\/ Atomically update the status with the bits given\n+  u4 old_status, new_status, f;\n+  do {\n+    old_status = _status;\n+    new_status = old_status & ~bits;\n+    f = Atomic::cmpxchg(&_status, old_status, new_status);\n+  } while(f != old_status);\n+}\n+\n+void MethodFlags::print_on(outputStream* st) const {\n+#define M_PRINT(name, ignore)          \\\n+  if (name()) st->print(\" \" #name \" \");\n+  M_STATUS_DO(M_PRINT)\n+#undef M_PRINT\n+}\n","filename":"src\/hotspot\/share\/oops\/methodFlags.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_METHODFLAGS_HPP\n+#define SHARE_OOPS_METHODFLAGS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class outputStream;\n+\n+\/\/ The MethodFlags class contains the writeable flags aka. status associated with\n+\/\/ an Method, and their associated accessors.\n+\/\/ _status are set at runtime and require atomic access.\n+\/\/ These flags are JVM internal and not part of the AccessFlags classfile specification.\n+\n+class MethodFlags {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+   \/* end of list *\/\n+\n+#define M_STATUS_DO(status)  \\\n+   status(has_monitor_bytecodes       , 1 << 0)  \/* Method contains monitorenter\/monitorexit bytecodes *\/ \\\n+   status(has_jsrs                    , 1 << 1) \\\n+   status(is_old                      , 1 << 2) \/* RedefineClasses() has replaced this method *\/ \\\n+   status(is_obsolete                 , 1 << 3) \/* RedefineClasses() has made method obsolete *\/ \\\n+   status(is_deleted                  , 1 << 4) \/* RedefineClasses() has deleted this method *\/  \\\n+   status(is_prefixed_native          , 1 << 5) \/* JVMTI has prefixed this native method *\/ \\\n+   status(monitor_matching            , 1 << 6) \/* True if we know that monitorenter\/monitorexit bytecodes match *\/ \\\n+   status(queued_for_compilation      , 1 << 7) \\\n+   status(is_not_c2_compilable        , 1 << 8) \\\n+   status(is_not_c1_compilable        , 1 << 9) \\\n+   status(is_not_c2_osr_compilable    , 1 << 10) \\\n+   status(force_inline                , 1 << 11) \/* Annotations but also set\/reset at runtime *\/ \\\n+   status(dont_inline                 , 1 << 12) \\\n+   status(has_loops_flag              , 1 << 13) \/* Method has loops *\/ \\\n+   status(has_loops_flag_init         , 1 << 14) \/* The loop flag has been initialized *\/ \\\n+   status(on_stack_flag               , 1 << 15) \/* RedefineClasses support to keep Metadata from being cleaned *\/ \\\n+   \/* end of list *\/\n+\n+#define M_STATUS_ENUM_NAME(name, value)    _misc_##name = value,\n+  enum {\n+    M_STATUS_DO(M_STATUS_ENUM_NAME)\n+  };\n+#undef M_STATUS_ENUM_NAME\n+\n+  \/\/ These flags are written during execution so require atomic stores\n+  u4 _status;\n+\n+ public:\n+\n+  MethodFlags() : _status(0) {}\n+\n+  \/\/ Create getters and setters for the status values.\n+#define M_STATUS_GET_SET(name, ignore)          \\\n+  bool name() const { return (_status & _misc_##name) != 0; } \\\n+  void set_##name(bool b) {         \\\n+    if (b) { \\\n+      atomic_set_bits(_misc_##name); \\\n+    } else { \\\n+      atomic_clear_bits(_misc_##name); \\\n+    } \\\n+  }\n+  M_STATUS_DO(M_STATUS_GET_SET)\n+#undef M_STATUS_GET_SET\n+\n+  int as_int() const { return _status; }\n+  void atomic_set_bits(u4 bits);\n+  void atomic_clear_bits(u4 bits);\n+  void print_on(outputStream* st) const;\n+};\n+\n+#endif \/\/ SHARE_OOPS_METHODFLAGS_HPP\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -1209,3 +1209,3 @@\n-  mh->clear_not_c1_compilable();\n-  mh->clear_not_c2_compilable();\n-  mh->clear_not_c2_osr_compilable();\n+  mh->clear_is_not_c1_compilable();\n+  mh->clear_is_not_c2_compilable();\n+  mh->clear_is_not_c2_osr_compilable();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -301,1 +301,0 @@\n-  nonstatic_field(Method,                      _flags,                                        u2)                                    \\\n@@ -310,1 +309,1 @@\n-  nonstatic_field(ConstMethod,                 _flags,                                        u2)                                    \\\n+  nonstatic_field(ConstMethod,                 _flags._flags,                                 u4)                                    \\\n@@ -2086,10 +2085,0 @@\n-  declare_constant(JVM_ACC_MONITOR_MATCH)                                 \\\n-  declare_constant(JVM_ACC_HAS_MONITOR_BYTECODES)                         \\\n-  declare_constant(JVM_ACC_HAS_LOOPS)                                     \\\n-  declare_constant(JVM_ACC_LOOPS_FLAG_INIT)                               \\\n-  declare_constant(JVM_ACC_QUEUED)                                        \\\n-  declare_constant(JVM_ACC_NOT_C2_OSR_COMPILABLE)                         \\\n-  declare_constant(JVM_ACC_HAS_JSRS)                                      \\\n-  declare_constant(JVM_ACC_IS_OLD)                                        \\\n-  declare_constant(JVM_ACC_IS_OBSOLETE)                                   \\\n-  declare_constant(JVM_ACC_IS_PREFIXED_NATIVE)                            \\\n@@ -2179,0 +2168,3 @@\n+  declare_constant(Method::nonvirtual_vtable_index)                       \\\n+  declare_constant(Method::extra_stack_entries_for_jsr292)                \\\n+                                                                          \\\n@@ -2183,20 +2175,10 @@\n-  declare_constant(Method::_caller_sensitive)                             \\\n-  declare_constant(Method::_force_inline)                                 \\\n-  declare_constant(Method::_dont_inline)                                  \\\n-  declare_constant(Method::_hidden)                                       \\\n-  declare_constant(Method::_changes_current_thread)                       \\\n-                                                                          \\\n-  declare_constant(Method::nonvirtual_vtable_index)                       \\\n-                                                                          \\\n-  declare_constant(Method::extra_stack_entries_for_jsr292)                \\\n-                                                                          \\\n-  declare_constant(ConstMethod::_has_linenumber_table)                    \\\n-  declare_constant(ConstMethod::_has_checked_exceptions)                  \\\n-  declare_constant(ConstMethod::_has_localvariable_table)                 \\\n-  declare_constant(ConstMethod::_has_exception_table)                     \\\n-  declare_constant(ConstMethod::_has_generic_signature)                   \\\n-  declare_constant(ConstMethod::_has_method_parameters)                   \\\n-  declare_constant(ConstMethod::_has_method_annotations)                  \\\n-  declare_constant(ConstMethod::_has_parameter_annotations)               \\\n-  declare_constant(ConstMethod::_has_default_annotations)                 \\\n-  declare_constant(ConstMethod::_has_type_annotations)                    \\\n+  declare_constant(ConstMethodFlags::_misc_has_linenumber_table)          \\\n+  declare_constant(ConstMethodFlags::_misc_has_checked_exceptions)        \\\n+  declare_constant(ConstMethodFlags::_misc_has_localvariable_table)       \\\n+  declare_constant(ConstMethodFlags::_misc_has_exception_table)           \\\n+  declare_constant(ConstMethodFlags::_misc_has_generic_signature)         \\\n+  declare_constant(ConstMethodFlags::_misc_has_method_parameters)         \\\n+  declare_constant(ConstMethodFlags::_misc_has_method_annotations)        \\\n+  declare_constant(ConstMethodFlags::_misc_has_parameter_annotations)     \\\n+  declare_constant(ConstMethodFlags::_misc_has_default_annotations)       \\\n+  declare_constant(ConstMethodFlags::_misc_has_type_annotations)          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,21 +30,0 @@\n-void AccessFlags::atomic_set_bits(jint bits) {\n-  \/\/ Atomically update the flags with the bits given\n-  jint old_flags, new_flags, f;\n-  do {\n-    old_flags = _flags;\n-    new_flags = old_flags | bits;\n-    f = Atomic::cmpxchg(&_flags, old_flags, new_flags);\n-  } while(f != old_flags);\n-}\n-\n-void AccessFlags::atomic_clear_bits(jint bits) {\n-  \/\/ Atomically update the flags with the bits given\n-  jint old_flags, new_flags, f;\n-  do {\n-    old_flags = _flags;\n-    new_flags = old_flags & ~bits;\n-    f = Atomic::cmpxchg(&_flags, old_flags, new_flags);\n-  } while(f != old_flags);\n-}\n-\n-\n@@ -66,3 +45,0 @@\n-  if (is_old         ()) st->print(\"{old} \"       );\n-  if (is_obsolete    ()) st->print(\"{obsolete} \"  );\n-  if (on_stack       ()) st->print(\"{on_stack} \"  );\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -45,16 +45,0 @@\n-  \/\/ Method* flags\n-  JVM_ACC_MONITOR_MATCH           = 0x10000000,     \/\/ True if we know that monitorenter\/monitorexit bytecodes match\n-  JVM_ACC_HAS_MONITOR_BYTECODES   = 0x20000000,     \/\/ Method contains monitorenter\/monitorexit bytecodes\n-  JVM_ACC_HAS_LOOPS               = 0x40000000,     \/\/ Method has loops\n-  JVM_ACC_LOOPS_FLAG_INIT         = (int)0x80000000,\/\/ The loop flag has been initialized\n-  JVM_ACC_QUEUED                  = 0x01000000,     \/\/ Queued for compilation\n-  JVM_ACC_NOT_C2_COMPILABLE       = 0x02000000,\n-  JVM_ACC_NOT_C1_COMPILABLE       = 0x04000000,\n-  JVM_ACC_NOT_C2_OSR_COMPILABLE   = 0x08000000,\n-  JVM_ACC_HAS_JSRS                = 0x00800000,\n-  JVM_ACC_IS_OLD                  = 0x00010000,     \/\/ RedefineClasses() has replaced this method\n-  JVM_ACC_IS_OBSOLETE             = 0x00020000,     \/\/ RedefineClasses() has made method obsolete\n-  JVM_ACC_IS_PREFIXED_NATIVE      = 0x00040000,     \/\/ JVMTI has prefixed this native method\n-  JVM_ACC_ON_STACK                = 0x00080000,     \/\/ RedefineClasses() was used on the stack\n-  JVM_ACC_IS_DELETED              = 0x00008000,     \/\/ RedefineClasses() has deleted this method\n-\n@@ -95,15 +79,0 @@\n-  \/\/ Method* flags\n-  bool is_monitor_matching     () const { return (_flags & JVM_ACC_MONITOR_MATCH          ) != 0; }\n-  bool has_monitor_bytecodes   () const { return (_flags & JVM_ACC_HAS_MONITOR_BYTECODES  ) != 0; }\n-  bool has_loops               () const { return (_flags & JVM_ACC_HAS_LOOPS              ) != 0; }\n-  bool loops_flag_init         () const { return (_flags & JVM_ACC_LOOPS_FLAG_INIT        ) != 0; }\n-  bool queued_for_compilation  () const { return (_flags & JVM_ACC_QUEUED                 ) != 0; }\n-  bool is_not_c1_compilable    () const { return (_flags & JVM_ACC_NOT_C1_COMPILABLE      ) != 0; }\n-  bool is_not_c2_compilable    () const { return (_flags & JVM_ACC_NOT_C2_COMPILABLE      ) != 0; }\n-  bool is_not_c2_osr_compilable() const { return (_flags & JVM_ACC_NOT_C2_OSR_COMPILABLE  ) != 0; }\n-  bool has_jsrs                () const { return (_flags & JVM_ACC_HAS_JSRS               ) != 0; }\n-  bool is_old                  () const { return (_flags & JVM_ACC_IS_OLD                 ) != 0; }\n-  bool is_obsolete             () const { return (_flags & JVM_ACC_IS_OBSOLETE            ) != 0; }\n-  bool is_deleted              () const { return (_flags & JVM_ACC_IS_DELETED             ) != 0; }\n-  bool is_prefixed_native      () const { return (_flags & JVM_ACC_IS_PREFIXED_NATIVE     ) != 0; }\n-\n@@ -116,2 +85,0 @@\n-  bool on_stack() const                 { return (_flags & JVM_ACC_ON_STACK) != 0; }\n-\n@@ -128,7 +95,0 @@\n-  void set_queued_for_compilation()    { atomic_set_bits(JVM_ACC_QUEUED); }\n-  void clear_queued_for_compilation()  { atomic_clear_bits(JVM_ACC_QUEUED); }\n-\n-  \/\/ Atomic update of flags\n-  void atomic_set_bits(jint bits);\n-  void atomic_clear_bits(jint bits);\n-\n@@ -136,1 +96,0 @@\n-  friend class Method;\n@@ -143,19 +102,2 @@\n-  void set_is_synthetic()              { atomic_set_bits(JVM_ACC_SYNTHETIC);               }\n-\n-  \/\/ Method* flags\n-  void set_monitor_matching()          { atomic_set_bits(JVM_ACC_MONITOR_MATCH);           }\n-  void set_has_monitor_bytecodes()     { atomic_set_bits(JVM_ACC_HAS_MONITOR_BYTECODES);   }\n-  void set_has_loops()                 { atomic_set_bits(JVM_ACC_HAS_LOOPS);               }\n-  void set_loops_flag_init()           { atomic_set_bits(JVM_ACC_LOOPS_FLAG_INIT);         }\n-  void set_not_c1_compilable()         { atomic_set_bits(JVM_ACC_NOT_C1_COMPILABLE);       }\n-  void set_not_c2_compilable()         { atomic_set_bits(JVM_ACC_NOT_C2_COMPILABLE);       }\n-  void set_not_c2_osr_compilable()     { atomic_set_bits(JVM_ACC_NOT_C2_OSR_COMPILABLE);   }\n-  void set_has_jsrs()                  { atomic_set_bits(JVM_ACC_HAS_JSRS);                }\n-  void set_is_old()                    { atomic_set_bits(JVM_ACC_IS_OLD);                  }\n-  void set_is_obsolete()               { atomic_set_bits(JVM_ACC_IS_OBSOLETE);             }\n-  void set_is_deleted()                { atomic_set_bits(JVM_ACC_IS_DELETED);              }\n-  void set_is_prefixed_native()        { atomic_set_bits(JVM_ACC_IS_PREFIXED_NATIVE);      }\n-\n-  void clear_not_c1_compilable()       { atomic_clear_bits(JVM_ACC_NOT_C1_COMPILABLE);       }\n-  void clear_not_c2_compilable()       { atomic_clear_bits(JVM_ACC_NOT_C2_COMPILABLE);       }\n-  void clear_not_c2_osr_compilable()   { atomic_clear_bits(JVM_ACC_NOT_C2_OSR_COMPILABLE);   }\n+  void set_is_synthetic()              { _flags |= JVM_ACC_SYNTHETIC; }\n+\n@@ -163,4 +105,5 @@\n-  void set_has_finalizer()             { atomic_set_bits(JVM_ACC_HAS_FINALIZER);           }\n-  void set_is_cloneable_fast()         { atomic_set_bits(JVM_ACC_IS_CLONEABLE_FAST);       }\n-  void set_is_hidden_class()           { atomic_set_bits(JVM_ACC_IS_HIDDEN_CLASS);         }\n-  void set_is_value_based_class()      { atomic_set_bits(JVM_ACC_IS_VALUE_BASED_CLASS);    }\n+  \/\/ These are set at classfile parsing time so do not require atomic access.\n+  void set_has_finalizer()             { _flags |= JVM_ACC_HAS_FINALIZER; }\n+  void set_is_cloneable_fast()         { _flags |= JVM_ACC_IS_CLONEABLE_FAST; }\n+  void set_is_hidden_class()           { _flags |= JVM_ACC_IS_HIDDEN_CLASS; }\n+  void set_is_value_based_class()      { _flags |= JVM_ACC_IS_VALUE_BASED_CLASS; }\n@@ -169,8 +112,0 @@\n-  void set_on_stack(const bool value)\n-                                       {\n-                                         if (value) {\n-                                           atomic_set_bits(JVM_ACC_ON_STACK);\n-                                         } else {\n-                                           atomic_clear_bits(JVM_ACC_ON_STACK);\n-                                         }\n-                                       }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":7,"deletions":72,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -59,11 +59,0 @@\n-  \/\/ Hotspot internal flags\n-  \/\/ Method* flags\n-  public boolean isMonitorMatching   () { return (flags & JVM_ACC_MONITOR_MATCH          ) != 0; }\n-  public boolean hasMonitorBytecodes () { return (flags & JVM_ACC_HAS_MONITOR_BYTECODES  ) != 0; }\n-  public boolean hasLoops            () { return (flags & JVM_ACC_HAS_LOOPS              ) != 0; }\n-  public boolean loopsFlagInit       () { return (flags & JVM_ACC_LOOPS_FLAG_INIT        ) != 0; }\n-  public boolean queuedForCompilation() { return (flags & JVM_ACC_QUEUED                 ) != 0; }\n-  public boolean isNotOsrCompilable  () { return (flags & JVM_ACC_NOT_OSR_COMPILABLE     ) != 0; }\n-  public boolean hasJsrs             () { return (flags & JVM_ACC_HAS_JSRS               ) != 0; }\n-  public boolean isObsolete          () { return (flags & JVM_ACC_IS_OBSOLETE            ) != 0; }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/AccessFlags.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-    flags                      = new CIntField(type.getCIntegerField(\"_flags\"), 0);\n+    flags                      = new CIntField(type.getCIntegerField(\"_flags._flags\"), 0);\n@@ -69,10 +69,10 @@\n-    HAS_LINENUMBER_TABLE      = db.lookupIntConstant(\"ConstMethod::_has_linenumber_table\").intValue();\n-    HAS_CHECKED_EXCEPTIONS     = db.lookupIntConstant(\"ConstMethod::_has_checked_exceptions\").intValue();\n-    HAS_LOCALVARIABLE_TABLE   = db.lookupIntConstant(\"ConstMethod::_has_localvariable_table\").intValue();\n-    HAS_EXCEPTION_TABLE       = db.lookupIntConstant(\"ConstMethod::_has_exception_table\").intValue();\n-    HAS_GENERIC_SIGNATURE     = db.lookupIntConstant(\"ConstMethod::_has_generic_signature\").intValue();\n-    HAS_METHOD_ANNOTATIONS    = db.lookupIntConstant(\"ConstMethod::_has_method_annotations\").intValue();\n-    HAS_PARAMETER_ANNOTATIONS = db.lookupIntConstant(\"ConstMethod::_has_parameter_annotations\").intValue();\n-    HAS_METHOD_PARAMETERS = db.lookupIntConstant(\"ConstMethod::_has_method_parameters\").intValue();\n-    HAS_DEFAULT_ANNOTATIONS   = db.lookupIntConstant(\"ConstMethod::_has_default_annotations\").intValue();\n-    HAS_TYPE_ANNOTATIONS      = db.lookupIntConstant(\"ConstMethod::_has_type_annotations\").intValue();\n+    HAS_LINENUMBER_TABLE      = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_linenumber_table\").intValue();\n+    HAS_CHECKED_EXCEPTIONS    = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_checked_exceptions\").intValue();\n+    HAS_LOCALVARIABLE_TABLE   = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_localvariable_table\").intValue();\n+    HAS_EXCEPTION_TABLE       = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_exception_table\").intValue();\n+    HAS_GENERIC_SIGNATURE     = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_generic_signature\").intValue();\n+    HAS_METHOD_ANNOTATIONS    = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_method_annotations\").intValue();\n+    HAS_PARAMETER_ANNOTATIONS = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_parameter_annotations\").intValue();\n+    HAS_METHOD_PARAMETERS     = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_method_parameters\").intValue();\n+    HAS_DEFAULT_ANNOTATIONS   = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_default_annotations\").intValue();\n+    HAS_TYPE_ANNOTATIONS      = db.lookupIntConstant(\"ConstMethodFlags::_misc_has_type_annotations\").intValue();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstMethod.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,4 +255,0 @@\n-  public boolean isObsolete() {\n-     return getAccessFlagsObj().isObsolete();\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,19 +106,0 @@\n-    \/\/ Method* flags\n-    \/\/ monitorenter\/monitorexit bytecodes match\n-    public static final long JVM_ACC_MONITOR_MATCH = 0x10000000;\n-    \/\/ Method contains monitorenter\/monitorexit bytecodes\n-    public static final long JVM_ACC_HAS_MONITOR_BYTECODES = 0x20000000;\n-    \/\/ Method has loops\n-    public static final long JVM_ACC_HAS_LOOPS             = 0x40000000;\n-    \/\/ The loop flag has been initialized\n-    public static final long JVM_ACC_LOOPS_FLAG_INIT       = (int)0x80000000;\n-    \/\/ Queued for compilation\n-    public static final long JVM_ACC_QUEUED                = 0x01000000;\n-    \/\/ TEMPORARY: currently on stack replacement compilation is not built into the\n-    \/\/ invocation counter machinery.  Until it is, we will keep track of methods which\n-    \/\/ cannot be on stack replaced in the access flags.\n-    public static final long JVM_ACC_NOT_OSR_COMPILABLE     = 0x08000000;\n-    public static final long JVM_ACC_HAS_JSRS               = 0x00800000;\n-    \/\/ RedefineClasses() has made method obsolete\n-    public static final long JVM_ACC_IS_OBSOLETE            = 0x00010000;\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ClassConstants.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -320,1 +320,1 @@\n-        return (getFlags() & config().methodFlagsCallerSensitive) != 0;\n+        return (getConstMethodFlags() & config().constMethodFlagsCallerSensitive) != 0;\n@@ -340,1 +340,1 @@\n-        return (getFlags() & config().methodFlagsReservedStackAccess) != 0;\n+        return (getConstMethodFlags() & config().constMethodFlagsReservedStackAccess) != 0;\n@@ -740,1 +740,1 @@\n-        return (getFlags() & config().methodFlagsIntrinsicCandidate) != 0;\n+        return (getConstMethodFlags() & config().constMethodFlagsIntrinsicCandidate) != 0;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-    final int methodFlagsOffset = getFieldOffset(\"Method::_flags\", Integer.class, \"u2\");\n+    final int methodFlagsOffset = getFieldOffset(\"Method::_flags._status\", Integer.class, \"u4\");\n@@ -158,5 +158,2 @@\n-    final int methodFlagsCallerSensitive = getConstant(\"Method::_caller_sensitive\", Integer.class);\n-    final int methodFlagsForceInline = getConstant(\"Method::_force_inline\", Integer.class);\n-    final int methodFlagsIntrinsicCandidate = getConstant(\"Method::_intrinsic_candidate\", Integer.class);\n-    final int methodFlagsDontInline = getConstant(\"Method::_dont_inline\", Integer.class);\n-    final int methodFlagsReservedStackAccess = getConstant(\"Method::_reserved_stack_access\", Integer.class);\n+    final int methodFlagsForceInline = getConstant(\"MethodFlags::_misc_force_inline\", Integer.class);\n+    final int methodFlagsDontInline = getConstant(\"MethodFlags::_misc_dont_inline\", Integer.class);\n@@ -193,1 +190,1 @@\n-    final int constMethodFlagsOffset = getFieldOffset(\"ConstMethod::_flags\", Integer.class, \"u2\");\n+    final int constMethodFlagsOffset = getFieldOffset(\"ConstMethod::_flags._flags\", Integer.class, \"u4\");\n@@ -201,5 +198,8 @@\n-    final int constMethodHasLineNumberTable = getConstant(\"ConstMethod::_has_linenumber_table\", Integer.class);\n-    final int constMethodHasLocalVariableTable = getConstant(\"ConstMethod::_has_localvariable_table\", Integer.class);\n-    final int constMethodHasMethodAnnotations = getConstant(\"ConstMethod::_has_method_annotations\", Integer.class);\n-    final int constMethodHasParameterAnnotations = getConstant(\"ConstMethod::_has_parameter_annotations\", Integer.class);\n-    final int constMethodHasExceptionTable = getConstant(\"ConstMethod::_has_exception_table\", Integer.class);\n+    final int constMethodFlagsReservedStackAccess = getConstant(\"ConstMethodFlags::_misc_reserved_stack_access\", Integer.class);\n+    final int constMethodFlagsCallerSensitive = getConstant(\"ConstMethodFlags::_misc_caller_sensitive\", Integer.class);\n+    final int constMethodFlagsIntrinsicCandidate = getConstant(\"ConstMethodFlags::_misc_intrinsic_candidate\", Integer.class);\n+    final int constMethodHasLineNumberTable = getConstant(\"ConstMethodFlags::_misc_has_linenumber_table\", Integer.class);\n+    final int constMethodHasLocalVariableTable = getConstant(\"ConstMethodFlags::_misc_has_localvariable_table\", Integer.class);\n+    final int constMethodHasMethodAnnotations = getConstant(\"ConstMethodFlags::_misc_has_method_annotations\", Integer.class);\n+    final int constMethodHasParameterAnnotations = getConstant(\"ConstMethodFlags::_misc_has_parameter_annotations\", Integer.class);\n+    final int constMethodHasExceptionTable = getConstant(\"ConstMethodFlags::_misc_has_exception_table\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}