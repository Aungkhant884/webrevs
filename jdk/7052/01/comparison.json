{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -524,0 +524,12 @@\n+\n+            if (dispatcherThread == Thread.currentThread()) {\n+                try {\n+                    \/\/ call selector to process cancelled keys\n+                    selector.selectNow();\n+                } catch (IOException ioe) {\n+                    logger.log(Level.DEBUG, \"processing of cancelled keys failed: closing\");\n+                    closeConnection(connection);\n+                    return;\n+                }\n+            }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278398\n+ * @summary Tests the jwebserver's maximum request time\n+ * @modules jdk.httpserver\n+ * @library \/test\/lib\n+ * @run testng\/othervm MaxRequestTimeTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * This test confirms that the jwebserver does not wait indefinitely for\n+ * a request to arrive.\n+ *\n+ * The jwebserver has a maximum request time of 5 seconds, which is set with the\n+ * \"sun.net.httpserver.maxReqTime\" system property. If this threshold is\n+ * reached, for example in the case of an HTTPS request where the server keeps\n+ * waiting for a plaintext request, the server closes the connection. Subsequent\n+ * requests are expected to be handled as normal.\n+ *\n+ * The test checks in the following order that:\n+ *    1. an HTTP request is handled successfully,\n+ *    2. an HTTPS request fails due to the server closing the connection\n+ *    3. another HTTP request is handled successfully.\n+ *\/\n+public class MaxRequestTimeTest {\n+    static final Path JAVA_HOME = Path.of(System.getProperty(\"java.home\"));\n+    static final String JWEBSERVER = getJwebserver(JAVA_HOME);\n+    static final Path CWD = Path.of(\".\").toAbsolutePath().normalize();\n+    static final Path TEST_DIR = CWD.resolve(\"MaxRequestTimeTest\");\n+    static final String LOOPBACK_ADDR = InetAddress.getLoopbackAddress().getHostAddress();\n+    static final AtomicInteger PORT = new AtomicInteger();\n+\n+    static SSLContext sslContext;\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+        Files.createDirectories(TEST_DIR);\n+\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+    }\n+\n+    @Test\n+    public void testMaxRequestTime() throws Throwable {\n+        final var sb = new StringBuffer();  \/\/ stdout & stderr\n+        final var p = startProcess(\"jwebserver\", sb);\n+        try {\n+            sendHTTPSRequest();  \/\/ server expected to terminate connection\n+            sendHTTPRequest();   \/\/ server expected to respond successfully\n+            sendHTTPSRequest();  \/\/ server expected to terminate connection\n+            sendHTTPRequest();   \/\/ server expected to respond successfully\n+        } finally {\n+            p.destroy();\n+            int exitCode = p.waitFor();\n+            checkOutput(sb, exitCode);\n+        }\n+    }\n+\n+    static String expectedBody = \"\"\"\n+                <!DOCTYPE html>\n+                <html>\n+                <head>\n+                <meta charset=\"utf-8\"\/>\n+                <\/head>\n+                <body>\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <\/ul>\n+                <\/body>\n+                <\/html>\n+                \"\"\";\n+\n+    void sendHTTPRequest() throws IOException, InterruptedException {\n+        out.println(\"\\n--- sendHTTPRequest\");\n+        var client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .build();\n+        var request = HttpRequest.newBuilder(URI.create(\"http:\/\/localhost:\" + PORT.get() + \"\/\")).build();\n+        var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+        assertEquals(response.body(), expectedBody);\n+    }\n+\n+    void sendHTTPSRequest() throws IOException, InterruptedException {\n+        out.println(\"\\n--- sendHTTPSRequest\");\n+        var client = HttpClient.newBuilder()\n+                .sslContext(sslContext)\n+                .proxy(NO_PROXY)\n+                .build();\n+        var request = HttpRequest.newBuilder(URI.create(\"https:\/\/localhost:\" + PORT.get() + \"\/\")).build();\n+        try {\n+            client.send(request, HttpResponse.BodyHandlers.ofString());\n+            throw new RuntimeException(\"Expected SSLHandshakeException not thrown\");\n+        } catch (SSLHandshakeException expected) {  \/\/ server closes connection when max request time is reached\n+            expected.printStackTrace(System.out);\n+        }\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+    }\n+\n+    \/\/ --- infra ---\n+\n+    static String getJwebserver(Path image) {\n+        boolean isWindows = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+        Path jwebserver = image.resolve(\"bin\").resolve(isWindows ? \"jwebserver.exe\" : \"jwebserver\");\n+        if (Files.notExists(jwebserver))\n+            throw new RuntimeException(jwebserver + \" not found\");\n+        return jwebserver.toAbsolutePath().toString();\n+    }\n+\n+    \/\/ The stdout\/stderr output line to wait for when starting the jwebserver\n+    static final String REGULAR_STARTUP_LINE_STRING_1 = \"URL http:\/\/\";\n+    static final String REGULAR_STARTUP_LINE_STRING_2 = \"Serving \";\n+\n+    static void parseAndSetPort(String line) {\n+        PORT.set(Integer.parseInt(line.split(\" port \")[1]));\n+    }\n+\n+    static Process startProcess(String name, StringBuffer sb) throws Throwable {\n+        \/\/ starts the process, parses the port and awaits startup line before sending requests\n+        return ProcessTools.startProcess(name,\n+                new ProcessBuilder(JWEBSERVER, \"-p\", \"0\").directory(TEST_DIR.toFile()),\n+                line -> {\n+                    if (line.startsWith(REGULAR_STARTUP_LINE_STRING_2)) { parseAndSetPort(line); }\n+                    sb.append(line + \"\\n\");\n+                },\n+                line -> line.startsWith(REGULAR_STARTUP_LINE_STRING_1),\n+                30,  \/\/ suitably high default timeout, not expected to timeout\n+                TimeUnit.SECONDS);\n+    }\n+\n+    static final int SIGTERM = 15;\n+    static final int NORMAL_EXIT_CODE = normalExitCode();\n+\n+    static int normalExitCode() {\n+        if (Platform.isWindows()) {\n+            return 1; \/\/ expected process destroy exit code\n+        } else {\n+            \/\/ signal terminated exit code on Unix is 128 + signal value\n+            return 128 + SIGTERM;\n+        }\n+    }\n+\n+    static void checkOutput(StringBuffer sb, int exitCode) {\n+        out.println(\"\\n--- server output: \\n\" + sb);\n+        var outputAnalyser = new OutputAnalyzer(sb.toString(), \"\", exitCode);\n+            outputAnalyser.shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                          .shouldContain(\"Binding to loopback by default. For all interfaces use \\\"-b 0.0.0.0\\\" or \\\"-b ::\\\".\")\n+                          .shouldContain(\"Serving \" + TEST_DIR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port \" + PORT)\n+                          .shouldContain(\"URL http:\/\/\" + LOOPBACK_ADDR);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/jwebserver\/MaxRequestTimeTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"}]}