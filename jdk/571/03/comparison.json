{"files":[{"patch":"@@ -386,15 +386,15 @@\n-        AccessFlags           = PUBLIC | PROTECTED | PRIVATE,\n-        LocalClassFlags       = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC,\n-        StaticLocalFlags      = LocalClassFlags | STATIC | INTERFACE,\n-        MemberClassFlags      = LocalClassFlags | INTERFACE | AccessFlags,\n-        MemberRecordFlags     = MemberClassFlags | STATIC,\n-        ClassFlags            = LocalClassFlags | INTERFACE | PUBLIC | ANNOTATION,\n-        InterfaceVarFlags     = FINAL | STATIC | PUBLIC,\n-        VarFlags              = AccessFlags | FINAL | STATIC |\n-                                VOLATILE | TRANSIENT | ENUM,\n-        ConstructorFlags      = AccessFlags,\n-        InterfaceMethodFlags  = ABSTRACT | PUBLIC,\n-        MethodFlags           = AccessFlags | ABSTRACT | STATIC | NATIVE |\n-                                SYNCHRONIZED | FINAL | STRICTFP,\n-        RecordMethodFlags     = AccessFlags | ABSTRACT | STATIC |\n-                                SYNCHRONIZED | FINAL | STRICTFP;\n+        AccessFlags                       = PUBLIC | PROTECTED | PRIVATE,\n+        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC,\n+        StaticLocalFlags                  = LocalClassFlags | STATIC | INTERFACE,\n+        MemberClassFlags                  = LocalClassFlags | INTERFACE | AccessFlags,\n+        MemberStaticClassFlags            = MemberClassFlags | STATIC,\n+        ClassFlags                        = LocalClassFlags | INTERFACE | PUBLIC | ANNOTATION,\n+        InterfaceVarFlags                 = FINAL | STATIC | PUBLIC,\n+        VarFlags                          = AccessFlags | FINAL | STATIC |\n+                                            VOLATILE | TRANSIENT | ENUM,\n+        ConstructorFlags                  = AccessFlags,\n+        InterfaceMethodFlags              = ABSTRACT | PUBLIC,\n+        MethodFlags                       = AccessFlags | ABSTRACT | STATIC | NATIVE |\n+                                            SYNCHRONIZED | FINAL | STRICTFP,\n+        RecordMethodFlags                 = AccessFlags | ABSTRACT | STATIC |\n+                                            SYNCHRONIZED | FINAL | STRICTFP;\n@@ -402,8 +402,9 @@\n-        ExtendedStandardFlags       = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED,\n-        ExtendedMemberClassFlags    = (long)MemberClassFlags | SEALED | NON_SEALED,\n-        ExtendedClassFlags          = (long)ClassFlags | SEALED | NON_SEALED,\n-        ModifierFlags               = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED,\n-        InterfaceMethodMask         = ABSTRACT | PRIVATE | STATIC | PUBLIC | STRICTFP | DEFAULT,\n-        AnnotationTypeElementMask   = ABSTRACT | PUBLIC,\n-        LocalVarFlags               = FINAL | PARAMETER,\n-        ReceiverParamFlags          = PARAMETER;\n+        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED,\n+        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED,\n+        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED,\n+        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED,\n+        InterfaceMethodMask               = ABSTRACT | PRIVATE | STATIC | PUBLIC | STRICTFP | DEFAULT,\n+        AnnotationTypeElementMask         = ABSTRACT | PUBLIC,\n+        LocalVarFlags                     = FINAL | PARAMETER,\n+        ReceiverParamFlags                = PARAMETER;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -5304,12 +5304,0 @@\n-            \/\/ Check that declarations in inner classes are not static (JLS 8.1.2)\n-            \/\/ Make an exception for static constants.\n-            if (c.owner.kind != PCK &&\n-                ((c.flags() & STATIC) == 0 || c.name == names.empty) &&\n-                (TreeInfo.flags(l.head) & (STATIC | INTERFACE)) != 0) {\n-                Symbol sym = null;\n-                if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;\n-                if (sym == null ||\n-                    sym.kind != VAR ||\n-                    ((VarSymbol) sym).getConstValue() == null)\n-                    log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1220,1 +1220,1 @@\n-            if (sym.isLocal()) {\n+            if (sym.owner.kind.matches(KindSelector.VAL_MTH)) {\n@@ -1226,5 +1226,0 @@\n-                if (staticOrImplicitlyStatic) {\n-                    if (sym.owner.kind == TYP) {\n-                        log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);\n-                    }\n-                }\n@@ -1232,1 +1227,1 @@\n-                mask = (flags & RECORD) != 0 ? MemberRecordFlags : ExtendedMemberClassFlags;\n+                mask = ((flags & STATIC) != 0) && allowRecords ? ExtendedMemberStaticClassFlags : ExtendedMemberClassFlags;\n@@ -1237,1 +1232,1 @@\n-                    log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);\n+                    \/\/log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);\n@@ -1310,1 +1305,4 @@\n-                           FINAL | NON_SEALED)) {\n+                           FINAL | NON_SEALED)\n+                 && checkDisjoint(pos, flags,\n+                                RECORD,\n+                                SEALED | NON_SEALED)  ) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -582,5 +582,0 @@\n-# 0: symbol\n-compiler.err.icls.cant.have.static.decl=\\\n-    Illegal static declaration in inner class {0}\\n\\\n-    modifier \\''static\\'' is only allowed in constant variable declarations\n-\n@@ -3611,3 +3606,0 @@\n-compiler.err.static.declaration.not.allowed.in.inner.classes=\\\n-    static declarations not allowed in inner classes\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Verify that an anonymous class cannot contain a static field.\n+ * @summary Verify that an anonymous class can contain a static field.\n@@ -30,1 +30,1 @@\n- * @run compile\/fail AnonStaticMember_1.java\n+ * @compile AnonStaticMember_1.java\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Verify that an anonymous class cannot contain a static method.\n+ * @summary Verify that an anonymous class can contain a static method.\n@@ -7,1 +7,1 @@\n- * @run compile\/fail\/ref=AnonStaticMember_2.out -XDrawDiagnostics AnonStaticMember_2.java\n+ * @compile AnonStaticMember_2.java\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-AnonStaticMember_2.java:12:21: compiler.err.icls.cant.have.static.decl: compiler.misc.anonymous.class: AnonStaticMember_2$1\n-1 error\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_2.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-InnerNamedConstant_2.java:22:20: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n-InnerNamedConstant_2.java:23:29: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n@@ -4,2 +2,1 @@\n-InnerNamedConstant_2.java:34:26: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner3\n-4 errors\n+1 error\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2.out","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Interfaces may only be declared in top level classes.\n+ * @summary Interfaces can also be declared in inner classes.\n@@ -7,1 +7,1 @@\n- * @compile\/fail\/ref=InterfaceInInner.out -XDrawDiagnostics InterfaceInInner.java\n+ * @compile InterfaceInInner.java\n","filename":"test\/langtools\/tools\/javac\/InterfaceInInner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-InterfaceInInner.java:12:13: compiler.err.static.declaration.not.allowed.in.inner.classes\n-1 error\n","filename":"test\/langtools\/tools\/javac\/InterfaceInInner.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -5,2 +5,2 @@\n- * @compile\/fail\/ref=LocalInterface.out -XDrawDiagnostics LocalInterface.java\n- * @compile --enable-preview -source ${jdk.version} LocalInterface.java\n+ * @compile\/fail\/ref=LocalInterface.out -XDrawDiagnostics -source 15 LocalInterface.java\n+ * @compile LocalInterface.java\n","filename":"test\/langtools\/tools\/javac\/LocalInterface.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+- compiler.warn.source.no.system.modules.path: 15\n@@ -3,0 +4,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/LocalInterface.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile --enable-preview -source ${jdk.version} LocalRecord.java\n+ * @compile LocalRecord.java\n","filename":"test\/langtools\/tools\/javac\/LocalRecord.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-MinContextOpTest.java:38:25: compiler.err.mod.not.allowed.here: static\n-MinContextOpTest.java:44:25: compiler.err.mod.not.allowed.here: static\n@@ -4,1 +2,1 @@\n-3 errors\n+1 error\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest.out","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.static.declaration.not.allowed.in.inner.classes\n-\n-class EnumsMustBeStatic {\n-    class Nested {\n-        enum E { A, B, C }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/EnumsMustBeStatic.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -22,1 +22,0 @@\n- *\n@@ -25,1 +24,1 @@\n-package foo;\n+\/\/ key: compiler.err.expected4\n@@ -27,2 +26,1 @@\n-public class C3 {\n-}\n+int Expected4;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/Expected4.java","additions":2,"deletions":4,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/C3.java","status":"copied"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.icls.cant.have.static.decl\n-\n-class InnerClassCantHaveStatic {\n-    class Inner {\n-        static int i;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InnerClassCantHaveStatic.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.static.declaration.not.allowed.in.inner.classes\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n-\n-class Outer {\n-    class Inner {\n-        record R(int a) {}\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RecordsNotAllowedInInnerClasses.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary javac allows enum in an inner class\n+ * @summary javac should allow enum in an inner class\n@@ -7,1 +7,1 @@\n- * @compile\/fail\/ref=NestedEnum.out -XDrawDiagnostics  NestedEnum.java\n+ * @compile NestedEnum.java\n","filename":"test\/langtools\/tools\/javac\/enum\/NestedEnum.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-NestedEnum.java:12:9: compiler.err.static.declaration.not.allowed.in.inner.classes\n-1 error\n","filename":"test\/langtools\/tools\/javac\/enum\/NestedEnum.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Empty Enums allowed in non-static contexts\n+ * @summary enums should be allowed in non-static contexts\n@@ -6,1 +6,1 @@\n- * @compile\/fail\/ref=T5081785.out -XDrawDiagnostics  T5081785.java\n+ * @compile T5081785.java\n","filename":"test\/langtools\/tools\/javac\/enum\/T5081785.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,7 @@\n- * @compile --enable-preview -source ${jdk.version} LocalStaticDeclarations.java\n- * @run main\/othervm --enable-preview LocalStaticDeclarations\n+ * @run main LocalStaticDeclarations\n+ *\/\n+\n+\/** this test checks two thinks:\n+ *  1 - that static declarations are allowed inside inner classes\n+ *  2 - and in addtion that non-static variables can't be captured\n+ *      by static contexts\n@@ -61,1 +66,2 @@\n-                { int LOCAL_VARIABLE = 0;\n+                {\n+                    int LOCAL_VARIABLE = 0;\n@@ -65,0 +71,1 @@\n+                    int LOCAL_VARIABLE = 0;\n@@ -97,1 +104,1 @@\n-        ENUM(\"enum CE { #{STATIC_LOCAL} }\"),\n+        ENUM(\"enum CE { CE1; #{STATIC_LOCAL} }\"),\n@@ -128,1 +135,0 @@\n-        NONE(\"\"),\n@@ -144,4 +150,4 @@\n-         LITERAL(\"1\"),\n-         STATIC_FIELD(\"STATIC_FIELD\"),\n-         LOCAL_VARIABLE(\"LOCAL_VARIABLE\"),\n-         INSTANCE_FIELD(\"INSTANCE_FIELD\");\n+        LITERAL(\"1\"),\n+        STATIC_FIELD(\"STATIC_FIELD\"),\n+        LOCAL_VARIABLE(\"LOCAL_VARIABLE\"),\n+        INSTANCE_FIELD(\"INSTANCE_FIELD\");\n@@ -149,1 +155,1 @@\n-         String expr;\n+        String expr;\n@@ -151,1 +157,1 @@\n-         Expression(String expr) {\n+        Expression(String expr) {\n@@ -178,1 +184,0 @@\n-                .withOptions(new String[]{\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())})\n@@ -184,2 +189,2 @@\n-        return decl == StaticLocalDecl.INTERFACE && (member == Member.DEFAULT_METHOD || member == Member.NONE) ||\n-               decl != StaticLocalDecl.INTERFACE && (member == Member.METHOD || member == Member.NONE);\n+        return decl == StaticLocalDecl.INTERFACE && member == Member.DEFAULT_METHOD ||\n+               decl != StaticLocalDecl.INTERFACE && member == Member.METHOD;\n@@ -190,1 +195,1 @@\n-            Assert.check(result.hasErrors(), result.compilationInfo());\n+            Assert.check(result.hasErrors(), \"unexpected compilation\\n\" + result.compilationInfo());\n@@ -200,4 +205,1 @@\n-        return ((container != Container.NO_CONTAINER &&\n-                container != Container.LAMBDA &&\n-                container != Container.ANONYMOUS)) ||\n-                (member != Member.NONE && !acceptableExpr());\n+        return (expr == Expression.LOCAL_VARIABLE || expr == Expression.INSTANCE_FIELD);\n@@ -211,4 +213,1 @@\n-        if ((container == Container.NO_CONTAINER ||\n-                container == Container.LAMBDA ||\n-                container == Container.ANONYMOUS) &&\n-                !acceptableExpr()) {\n+        if (expr == Expression.LOCAL_VARIABLE || expr == Expression.INSTANCE_FIELD) {\n@@ -216,2 +215,0 @@\n-        } else if (container == Container.ENUM) {\n-            return result.containsKey(\"compiler.err.enum.constant.expected\" );\n@@ -219,1 +216,1 @@\n-        return result.containsKey(\"compiler.err.static.declaration.not.allowed.in.inner.classes\" );\n+        return false;\n","filename":"test\/langtools\/tools\/javac\/records\/LocalStaticDeclarations.java","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -488,118 +488,33 @@\n-    public void testStaticLocalTypes() {\n-        \/\/ local records can also be final\n-        assertOK(\"class R { \\n\" +\n-                \"    void m() { \\n\" +\n-                \"        final record RR(int x) { };\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        \/\/ Can't capture locals\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R { \\n\" +\n-                        \"    void m(int y) { \\n\" +\n-                        \"        record RR(int x) { public int x() { return y; }};\\n\" +\n-                        \"    }\\n\" +\n-                        \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R { \\n\" +\n-                        \"    void m() {\\n\" +\n-                        \"        int y;\\n\" +\n-                        \"        record RR(int x) { public int x() { return y; }};\\n\" +\n-                        \"    }\\n\" +\n-                        \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m() {\\n\" +\n-                \"        String hello = \\\"hello\\\";\\n\" +\n-                \"        interface I {\\n\" +\n-                \"            public default void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(hello);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m() {\\n\" +\n-                \"        String hello = \\\"hello\\\";\\n\" +\n-                \"        record R(int i) {\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(hello);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m() {\\n\" +\n-                \"        String hello = \\\"hello\\\";\\n\" +\n-                \"        enum E {\\n\" +\n-                \"            A;\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(hello);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        interface I {\\n\" +\n-                \"            public default void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(param);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        record R(int i) {\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(param);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        enum E {\\n\" +\n-                \"            A;\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(param);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+    public void testStaticLocals() {\n+        \/\/ static locals can't capture local variables, instance fields or type variables\n+        for (String s : List.of(\n+                \"record RR(int x) { public int x() { return y; }};\",\n+                \"record RR(int x) { public int x() { return z; }};\",\n+                \"record RR(int x) { public int x() { return instance; }};\",\n+                \"record RR(T t) {};\",\n+                \"record RR(U u) {};\",\n+\n+                \"interface I { default int x() { return y; }};\",\n+                \"interface I { default int x() { return z; }};\",\n+                \"interface I { default int x() { return instance; }};\",\n+                \"interface I { default int x(T t) { return 0; }};\",\n+                \"interface I { default int x(U u) { return 0; }};\",\n+\n+                \"enum E { A; int x() { return y; }};\",\n+                \"enum E { A; int x() { return z; }};\",\n+                \"enum E { A; int x() { return instance; }};\",\n+                \"enum E { A; int x(T t) { return 0; }};\",\n+                \"enum E { A; int x(U u) { return 0; }};\"\n+        )) {\n+            assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"\"\"\n+                class R<T> {\n+                    int instance = 0;\n+                    <U> U m(int y) {\n+                        int z;\n+                        #S\n+                        return null;\n+                    }\n+                }\n+                \"\"\".replaceFirst(\"#S\", s));\n+        }\n@@ -607,15 +522,32 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    String instanceField = \\\"instance\\\";\\n\" +\n-                \"    public static void m() {\\n\" +\n-                \"        interface I {\\n\" +\n-                \"            public default void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(instanceField);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+        \/\/ a similar example but a bit more complex\n+        for (String s : List.of(\n+                \"record R() { void test1() { class X { void test2() { System.err.println(localVar); } } } }\",\n+                \"record R() { void test1() { class X { void test2() { System.err.println(param); } } } }\",\n+                \"record R() {void test1() { class X { void test2() { System.err.println(instanceField); } } } }\",\n+                \"record R() { void test1() { class X { T t; } } }\",\n+                \"record R() { void test1() { class X { U u; } } }\",\n+\n+                \"interface I { default void test1() { class X { void test2() { System.err.println(localVar); } } } }\",\n+                \"interface I() { default void test1() { class X { void test2() {System.err.println(param);} } } }\",\n+                \"interface I { default void test1() { class X { void test2() { System.err.println(instanceField); } } } }\",\n+                \"interface I { default void test1() { class X { T t; } } }\",\n+                \"interface I() { default void test1() { class X {U u;} } }\",\n+\n+                \"enum E { A; void test1() { class X { void test2() { System.err.println(localVar); } } } }\",\n+                \"enum E { A; void test1() { class X { void test2() {System.err.println(param);} } } }\",\n+                \"enum E { A; void test1() { class X { void test2() { System.err.println(instanceField); } } } }\",\n+                \"enum E { A; void test1() { class X { T t; } } }\",\n+                \"enum E { A; void test1() { class X {U u;} } }\"\n+        )) {\n+            assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                    \"\"\"\n+                    class C<T> {\n+                        String instanceField = \"instance\";\n+                        static <U> U m(String param) {\n+                            String localVar = \"local\";\n+                            #S\n+                            return null;\n+                    }\n+                }\n+                \"\"\".replaceFirst(\"#S\", s));\n+        }\n@@ -623,15 +555,4 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    String instanceField = \\\"instance\\\";\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        record R(int i) {\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(instanceField);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+        \/\/ can't self-shadow\n+        for (String s : List.of(\"record R() {}\", \"interface R {}\", \"enum R { A }\")) {\n+            assertFail(\"compiler.err.already.defined\", \"class R { void m() { #S } }\".replaceFirst(\"#S\", s));\n+        }\n@@ -639,16 +560,4 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    String instanceField = \\\"instance\\\";\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        enum E {\\n\" +\n-                \"            A;\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(instanceField);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+        \/\/ can't be explicitly static\n+        for (String s : List.of(\"static record RR() { }\", \"static interface I {}\", \"static enum E { A }\")) {\n+            assertFail(\"compiler.err.illegal.start.of.expr\", \"class R { void m() { #S } }\".replaceFirst(\"#S\", s));\n+        }\n@@ -656,8 +565,8 @@\n-        \/\/ instance fields\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R { \\n\" +\n-                        \"    int z = 0;\\n\" +\n-                        \"    void m() { \\n\" +\n-                        \"        record RR(int x) { public int x() { return z; }};\\n\" +\n-                        \"    }\\n\" +\n-                        \"}\");\n+        \/\/ but static fields can be accessed\n+        for (String s : List.of(\n+                \"record RR() { public int x() { return z; } };\",\n+                \"interface I { default int x() { return z; } }\",\n+                \"enum E { A; int x() { return z; } }\"\n+        )) {\n+            assertOK(\"class R { static int z = 0; void m() { #S } }\".replaceFirst(\"#S\", s));\n+        }\n@@ -665,7 +574,3 @@\n-        \/\/ or type variables\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R<T> { \\n\" +\n-                        \"    void m() { \\n\" +\n-                        \"        record RR(T t) {};\\n\" +\n-                        \"    }\\n\" +\n-                        \"}\");\n+        \/\/ local records can also be final\n+        assertOK(\"class R { void m() { final record RR(int x) { }; } }\");\n+    }\n@@ -673,9 +578,29 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R {\\n\" +\n-                \"    static <U> U make(U u) { \/\/method is static\\n\" +\n-                \"        interface Checker {\\n\" +\n-                \"            void check(U u);\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+    public void testStaticDefinitionsInInnerClasses() {\n+        \/\/ static defs in inner classes can't capture instance fields or type variables\n+        for (String s : List.of(\n+                \"\"\"\n+                record R() {\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -683,20 +608,26 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class LocalEnum {\\n\" +\n-                \"    static <U> U getAndSet(U u) { \/\/method is static\\n\" +\n-                \"        enum X {\\n\" +\n-                \"            A;\\n\" +\n-                \"            U u;\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\\n\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R {\\n\" +\n-                \"    static <U> U make(U u) { \/\/method is static\\n\" +\n-                \"        record Checker() {\\n\" +\n-                \"            void check(U u);\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                interface I {\n+                    default void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -704,9 +635,30 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R {\\n\" +\n-                \"    <U> U make(U u) { \/\/ enclosing method is not static\\n\" +\n-                \"        interface Checker {\\n\" +\n-                \"            void check(U u);\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -714,20 +666,37 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class LocalEnum {\\n\" +\n-                \"    <U> U getAndSet(U u) { \/\/ enclosing method is not static\\n\" +\n-                \"        enum X {\\n\" +\n-                \"            A;\\n\" +\n-                \"            U u;\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\\n\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R {\\n\" +\n-                \"    <U> U make(U u) { \/\/ enclosing method is not static\\n\" +\n-                \"        record Checker() {\\n\" +\n-                \"            void check(U u);\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                static class SC {\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                    \"\"\"\n+                    class C<T> {\n+                        String field = \"field\";\n+                        class Inner {\n+                            #S\n+                        }\n+                    }\n+                    \"\"\".replaceFirst(\"#S\", s));\n+        }\n@@ -735,14 +704,51 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static <T> void main(String[] args) {\\n\" +\n-                \"        interface I {\\n\" +\n-                \"            public default void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        T t = null;\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+        \/\/ another, more complex, example\n+        \/\/ static defs in inner classes can't capture instance locals, fields or type variables\n+        for (String s : List.of(\n+                \"\"\"\n+                record R() {\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2() { System.err.println(field); } }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test() { System.err.println(param); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2() { System.err.println(param); } }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test() { System.err.println(local); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2() { System.err.println(local); } }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -750,14 +756,54 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static <T> void main(String[] args) {\\n\" +\n-                \"        record R(int i) {\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        T t = null;\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                interface I {\n+                    default void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test() { System.err.println(param); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X {\n+                            void test2() { System.err.println(param); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test() { System.err.println(local); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X {\n+                            void test2() { System.err.println(local); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -765,15 +811,62 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static <T> void main(String[] args) {\\n\" +\n-                \"        enum E {\\n\" +\n-                \"            A;\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        T t = null;\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test() { System.err.println(param); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(param); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test() { System.err.println(local); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(local); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -781,9 +874,0 @@\n-        \/\/ but static fields are OK\n-        assertOK(\"class R { \\n\" +\n-                \"    static int z = 0;\\n\" +\n-                \"    void m() { \\n\" +\n-                \"        record RR(int x) { public int x() { return z; }};\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-        \/\/ Can't self-shadow\n-        assertFail(\"compiler.err.already.defined\",\n@@ -791,3 +875,10 @@\n-                class R {\n-                    void m() {\n-                        record R(int x) { };\n+                static class SC {\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n@@ -796,0 +887,1 @@\n+                \"\"\",\n@@ -797,3 +889,4 @@\n-        );\n-        \/\/ can't be explicitly static\n-        assertFail(\"compiler.err.illegal.start.of.expr\",\n+                static class SC {\n+                    void test() { System.err.println(param); }\n+                }\n+                \"\"\",\n@@ -801,3 +894,5 @@\n-                class R {\n-                    void m() {\n-                        static record RR(int x) { };\n+                static class SC {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(param); }\n+                        }\n@@ -806,0 +901,1 @@\n+                \"\"\",\n@@ -807,1 +903,40 @@\n-        );\n+                static class SC {\n+                    void test() { System.err.println(local); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(local); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                    \"\"\"\n+                    class C<T> {\n+                        String field = \"field\";\n+                        <U> U m(String param) {\n+                            String local = \"local\";\n+                            class Local {\n+                                class Inner { #S }\n+                            }\n+                            return null;\n+                        }\n+                    }\n+                    \"\"\".replaceFirst(\"#S\", s));\n+        }\n@@ -809,1 +944,1 @@\n-        \/\/ positive cases\n+        \/\/ inner classes can contain static methods too\n@@ -812,11 +947,4 @@\n-                import java.security.*;\n-                class Test {\n-                    static Test newInstance(Object provider) {\n-                        return new Test() {\n-                            private final PrivilegedExceptionAction<KeyStore> action = new PrivilegedExceptionAction<KeyStore>() {\n-                                public KeyStore run() throws Exception {\n-                                    if (provider == null) {}\n-                                    return null;\n-                                }\n-                            };\n-                        };\n+                class C {\n+                    class Inner {\n+                        \/\/ static method inside inner class\n+                        static void m() {}\n@@ -830,17 +958,7 @@\n-                import java.security.*;\n-                class Test {\n-                    static Test newInstance(Object provider) {\n-                        return new Test() {\n-                            int m(PrivilegedExceptionAction<KeyStore> a) { return 0; }\n-                            {\n-                                m(\n-                                    new PrivilegedExceptionAction<KeyStore>() {\n-                                        public KeyStore run() throws Exception {\n-                                            if (provider == null) {}\n-                                            return null;\n-                                        }\n-                                    }\n-                                );\n-                            }\n-                        };\n-                    }\n+                class C {\n+                     void m() {\n+                         new Object() {\n+                            \/\/ static method inside inner class\n+                            static void m() {}\n+                         };\n+                     }\n@@ -880,1 +998,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n@@ -889,1 +1007,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n@@ -899,1 +1017,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n@@ -908,1 +1026,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":450,"deletions":332,"binary":false,"changes":782,"status":"modified"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test binary compatibility rules for record classes\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RecordsBinaryCompatibilityTests\n+ *\/\n+\n+import java.util.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.IntStream;\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavaTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+\n+public class RecordsBinaryCompatibilityTests extends TestRunner {\n+    ToolBox tb;\n+\n+    RecordsBinaryCompatibilityTests() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        RecordsBinaryCompatibilityTests t = new RecordsBinaryCompatibilityTests();\n+        t.runTests();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterAddingRecordComponent(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, int j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                        \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterDeletingRecordComponent(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, int j) {\n+                    public R(int j) {\n+                        this(0, j);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(2);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                        \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterChangingRecordComponent(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, int j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, String j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0, 1);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                        \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterReorderingRecordComponents(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, String j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(String j, int i) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0, \"\");\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                        \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterChangingRecordComponent2(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int j) {\n+                    public static int i() { return 0; }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int i) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                \"java.lang.IncompatibleClassChangeError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterChangingRecordComponent3(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i) {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    \/* 1- compiles the first version of the record class source code along with the client source code\n+     * 2- executes the client class just to make sure that it works\n+     * 3- compiles the second version of the record class\n+     * 4- executes the client class and makes sure that the VM throws the expected error or not\n+     *    depending on the shouldFail argument\n+     *\/\n+    private void testCompatibilityAfterModifyingRecord(\n+            Path base,\n+            String recordCode1,\n+            String recordCode2,\n+            String clientCode,\n+            boolean shouldFail,\n+            String expectedError) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path pkg = src.resolve(\"pkg\");\n+        Path recordSrc = pkg.resolve(\"R\");\n+        Path client = pkg.resolve(\"Client\");\n+\n+        tb.writeJavaFiles(recordSrc, recordCode1);\n+        tb.writeJavaFiles(client, clientCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        \/\/ let's execute to check that it's working\n+        String output = new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Client\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT);\n+\n+        \/\/ let's first check that it runs wo issues\n+        if (!output.contains(\"0\")) {\n+            throw new AssertionError(\"execution of Client didn't finish\");\n+        }\n+\n+        \/\/ now lets change the record class\n+        tb.writeJavaFiles(recordSrc, recordCode2);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(recordSrc))\n+                .run();\n+\n+        if (shouldFail) {\n+            \/\/ let's now check that we get the expected error\n+            output = new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"pkg.Client\")\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.STDERR);\n+            if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError)) {\n+                throw new AssertionError(expectedError + \" expected\");\n+            }\n+        } else {\n+            new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"pkg.Client\")\n+                    .run(Task.Expect.SUCCESS);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/RecordsBinaryCompatibilityTests.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"}]}