{"files":[{"patch":"@@ -174,0 +174,1 @@\n+        allowRecords = Feature.RECORDS.allowedInSource(source);\n@@ -210,0 +211,4 @@\n+    \/** Are records allowed\n+     *\/\n+    private final boolean allowRecords;\n+\n@@ -5304,0 +5309,13 @@\n+            \/\/ Check that declarations in inner classes are not static (JLS 8.1.2)\n+            \/\/ Make an exception for static constants.\n+            if (!allowRecords &&\n+                    c.owner.kind != PCK &&\n+                    ((c.flags() & STATIC) == 0 || c.name == names.empty) &&\n+                    (TreeInfo.flags(l.head) & (STATIC | INTERFACE)) != 0) {\n+                Symbol sym = null;\n+                if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;\n+                if (sym == null ||\n+                        sym.kind != VAR ||\n+                        ((VarSymbol) sym).getConstValue() == null)\n+                    log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1223,0 +1223,1 @@\n+                \/\/ local statics are allowed only if records are allowed too\n@@ -1226,0 +1227,1 @@\n+                \/\/ statics in inner classes are allowed only if records are allowed too\n@@ -1228,1 +1230,1 @@\n-                    (sym.owner.flags_field & STATIC) != 0)\n+                    (sym.owner.flags_field & STATIC) != 0) {\n@@ -1230,2 +1232,2 @@\n-                else if ((flags & ENUM) != 0 || (flags & RECORD) != 0) {\n-                    \/\/log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);\n+                } else if (!allowRecords && ((flags & ENUM) != 0 || (flags & RECORD) != 0)) {\n+                    log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);\n@@ -1304,4 +1306,1 @@\n-                           FINAL | NON_SEALED)\n-                 && checkDisjoint(pos, flags,\n-                                RECORD,\n-                                SEALED | NON_SEALED)  ) {\n+                           FINAL | NON_SEALED)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -582,0 +582,5 @@\n+# 0: symbol\n+compiler.err.icls.cant.have.static.decl=\\\n+    Illegal static declaration in inner class {0}\\n\\\n+    modifier \\''static\\'' is only allowed in constant variable declarations\n+\n@@ -3606,0 +3611,3 @@\n+compiler.err.static.declaration.not.allowed.in.inner.classes=\\\n+    static declarations not allowed in inner classes\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Verify that an anonymous class can contain a static field.\n+ * @summary Verify that an anonymous class can contain a static field only if source >= 16\n@@ -30,0 +30,1 @@\n+ * @compile\/fail\/ref=AnonStaticMember_1.out -source 15 -XDrawDiagnostics AnonStaticMember_1.java\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_1.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+- compiler.warn.source.no.system.modules.path: 15\n+AnonStaticMember_1.java:36:20: compiler.err.icls.cant.have.static.decl: compiler.misc.anonymous.class: AnonStaticMember_1$1\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_1.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Verify that an anonymous class can contain a static method.\n+ * @summary Verify that an anonymous class can contain a static method only if source >= 16\n@@ -7,0 +7,1 @@\n+ * @compile\/fail\/ref=AnonStaticMember_2.out -source 15 -XDrawDiagnostics AnonStaticMember_2.java\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_2.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+- compiler.warn.source.no.system.modules.path: 15\n+AnonStaticMember_2.java:13:21: compiler.err.icls.cant.have.static.decl: compiler.misc.anonymous.class: AnonStaticMember_2$1\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_2.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -7,1 +7,2 @@\n- * @compile\/fail\/ref=InnerNamedConstant_2.out -XDrawDiagnostics InnerNamedConstant_2.java\n+ * @compile\/fail\/ref=InnerNamedConstant_2_A.out -XDrawDiagnostics -source 15 InnerNamedConstant_2.java\n+ * @compile\/fail\/ref=InnerNamedConstant_2_B.out -XDrawDiagnostics InnerNamedConstant_2.java\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-InnerNamedConstant_2.java:25:13: compiler.err.cant.assign.val.to.final.var: z\n-1 error\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -0,0 +1,7 @@\n+- compiler.warn.source.no.system.modules.path: 15\n+InnerNamedConstant_2.java:23:20: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n+InnerNamedConstant_2.java:24:29: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n+InnerNamedConstant_2.java:26:13: compiler.err.cant.assign.val.to.final.var: z\n+InnerNamedConstant_2.java:35:26: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner3\n+4 errors\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2_A.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+InnerNamedConstant_2.java:26:13: compiler.err.cant.assign.val.to.final.var: z\n+1 error\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2_B.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Interfaces can also be declared in inner classes.\n+ * @summary Interfaces can be declared in inner classes only for source >= 16\n@@ -7,0 +7,1 @@\n+ * @compile\/fail\/ref=InterfaceInInner.out -XDrawDiagnostics -source 15 InterfaceInInner.java\n","filename":"test\/langtools\/tools\/javac\/InterfaceInInner.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+- compiler.warn.source.no.system.modules.path: 15\n+InterfaceInInner.java:13:13: compiler.err.icls.cant.have.static.decl: foo\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/InterfaceInInner.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -28,1 +28,2 @@\n- * @compile\/fail\/ref=MinContextOpTest.out -XDrawDiagnostics MinContextOpTest.java\n+ * @compile\/fail\/ref=MinContextOpTest_A.out -XDrawDiagnostics -source 15 MinContextOpTest.java\n+ * @compile\/fail\/ref=MinContextOpTest_B.out -XDrawDiagnostics MinContextOpTest.java\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-MinContextOpTest.java:50:34: compiler.err.prob.found.req: (compiler.misc.infer.no.conforming.assignment.exists: T,K,V,E, (compiler.misc.inconvertible.types: java.util.function.Function<MinContextOpTest.A.T,MinContextOpTest.A.T>, java.util.function.Function<? super MinContextOpTest.A.T,? extends MinContextOpTest.A.T<?>>))\n-1 error\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -0,0 +1,6 @@\n+- compiler.warn.source.no.system.modules.path: 15\n+MinContextOpTest.java:39:25: compiler.err.mod.not.allowed.here: static\n+MinContextOpTest.java:45:25: compiler.err.mod.not.allowed.here: static\n+MinContextOpTest.java:51:34: compiler.err.prob.found.req: (compiler.misc.infer.no.conforming.assignment.exists: T,K,V,E, (compiler.misc.inconvertible.types: java.util.function.Function<MinContextOpTest.A.T,MinContextOpTest.A.T>, java.util.function.Function<? super MinContextOpTest.A.T,? extends MinContextOpTest.A.T<?>>))\n+3 errors\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest_A.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+MinContextOpTest.java:51:34: compiler.err.prob.found.req: (compiler.misc.infer.no.conforming.assignment.exists: T,K,V,E, (compiler.misc.inconvertible.types: java.util.function.Function<MinContextOpTest.A.T,MinContextOpTest.A.T>, java.util.function.Function<? super MinContextOpTest.A.T,? extends MinContextOpTest.A.T<?>>))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest_B.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.static.declaration.not.allowed.in.inner.classes\n+\/\/ key: compiler.warn.source.no.system.modules.path\n+\/\/ options: -source 15\n+\n+class EnumsMustBeStatic {\n+    class Nested {\n+        enum E { A, B, C }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/EnumsMustBeStatic.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.expected4\n-\n-int Expected4;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/Expected4.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2010, 2020 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.icls.cant.have.static.decl\n+\/\/ key: compiler.warn.source.no.system.modules.path\n+\/\/ options: -source 15\n+\n+class InnerClassCantHaveStatic {\n+    class Inner {\n+        static int i;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InnerClassCantHaveStatic.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary javac should allow enum in an inner class\n+ * @summary javac allows enum in an inner class for source >= 16\n@@ -7,0 +7,1 @@\n+ * @compile\/fail\/ref=NestedEnum.out -XDrawDiagnostics -source 15 NestedEnum.java\n","filename":"test\/langtools\/tools\/javac\/enum\/NestedEnum.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+- compiler.warn.source.no.system.modules.path: 15\n+NestedEnum.java:13:9: compiler.err.static.declaration.not.allowed.in.inner.classes\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/enum\/NestedEnum.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -6,0 +6,1 @@\n+ * @compile\/fail\/ref=T5081785.out -XDrawDiagnostics -source 15 T5081785.java\n","filename":"test\/langtools\/tools\/javac\/enum\/T5081785.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,4 +1,5 @@\n-T5081785.java:29:9: compiler.err.static.declaration.not.allowed.in.inner.classes\n-T5081785.java:12:13: compiler.err.static.declaration.not.allowed.in.inner.classes\n-T5081785.java:19:27: compiler.err.static.declaration.not.allowed.in.inner.classes\n-T5081785.java:24:31: compiler.err.static.declaration.not.allowed.in.inner.classes\n+- compiler.warn.source.no.system.modules.path: 15\n+T5081785.java:30:9: compiler.err.static.declaration.not.allowed.in.inner.classes\n+T5081785.java:13:13: compiler.err.static.declaration.not.allowed.in.inner.classes\n+T5081785.java:20:27: compiler.err.static.declaration.not.allowed.in.inner.classes\n+T5081785.java:25:31: compiler.err.static.declaration.not.allowed.in.inner.classes\n@@ -6,0 +7,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/enum\/T5081785.out","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,307 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary test binary compatibility rules for record classes\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.javac.util\n- *          jdk.compiler\/com.sun.tools.javac.code\n- *          jdk.jdeps\/com.sun.tools.classfile\n- * @build toolbox.ToolBox toolbox.JavacTask\n- * @run main RecordsBinaryCompatibilityTests\n- *\/\n-\n-import java.util.*;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.stream.IntStream;\n-\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.javac.code.Flags;\n-import com.sun.tools.javac.util.Assert;\n-import toolbox.TestRunner;\n-import toolbox.ToolBox;\n-import toolbox.JavaTask;\n-import toolbox.JavacTask;\n-import toolbox.Task;\n-import toolbox.Task.OutputKind;\n-\n-public class RecordsBinaryCompatibilityTests extends TestRunner {\n-    ToolBox tb;\n-\n-    RecordsBinaryCompatibilityTests() {\n-        super(System.err);\n-        tb = new ToolBox();\n-    }\n-\n-    protected void runTests() throws Exception {\n-        runTests(m -> new Object[]{Paths.get(m.getName())});\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        RecordsBinaryCompatibilityTests t = new RecordsBinaryCompatibilityTests();\n-        t.runTests();\n-    }\n-\n-    Path[] findJavaFiles(Path... paths) throws IOException {\n-        return tb.findJavaFiles(paths);\n-    }\n-\n-    @Test\n-    public void testCompatibilityAfterAddingRecordComponent(Path base) throws Exception {\n-        testCompatibilityAfterModifyingRecord(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public record R(int i) {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public record R(int i, int j) {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public class Client {\n-                    public static void main(String... args) {\n-                        R r = new R(0);\n-                        System.out.println(r.i());\n-                    }\n-                }\n-                        \"\"\",\n-                true,\n-                \"java.lang.NoSuchMethodError\"\n-        );\n-    }\n-\n-    @Test\n-    public void testCompatibilityAfterDeletingRecordComponent(Path base) throws Exception {\n-        testCompatibilityAfterModifyingRecord(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public record R(int i, int j) {\n-                    public R(int j) {\n-                        this(0, j);\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public record R(int j) {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public class Client {\n-                    public static void main(String... args) {\n-                        R r = new R(2);\n-                        System.out.println(r.i());\n-                    }\n-                }\n-                        \"\"\",\n-                true,\n-                \"java.lang.NoSuchMethodError\"\n-        );\n-    }\n-\n-    @Test\n-    public void testCompatibilityAfterChangingRecordComponent(Path base) throws Exception {\n-        testCompatibilityAfterModifyingRecord(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public record R(int i, int j) {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public record R(int i, String j) {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public class Client {\n-                    public static void main(String... args) {\n-                        R r = new R(0, 1);\n-                        System.out.println(r.i());\n-                    }\n-                }\n-                        \"\"\",\n-                true,\n-                \"java.lang.NoSuchMethodError\"\n-        );\n-    }\n-\n-    @Test\n-    public void testCompatibilityAfterReorderingRecordComponents(Path base) throws Exception {\n-        testCompatibilityAfterModifyingRecord(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public record R(int i, String j) {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public record R(String j, int i) {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public class Client {\n-                    public static void main(String... args) {\n-                        R r = new R(0, \"\");\n-                        System.out.println(r.i());\n-                    }\n-                }\n-                        \"\"\",\n-                true,\n-                \"java.lang.NoSuchMethodError\"\n-        );\n-    }\n-\n-    @Test\n-    public void testCompatibilityAfterChangingRecordComponent2(Path base) throws Exception {\n-        testCompatibilityAfterModifyingRecord(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public record R(int j) {\n-                    public static int i() { return 0; }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public record R(int i) {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public class Client {\n-                    public static void main(String... args) {\n-                        R r = new R(0);\n-                        System.out.println(r.i());\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                \"java.lang.IncompatibleClassChangeError\"\n-        );\n-    }\n-\n-    @Test\n-    public void testCompatibilityAfterChangingRecordComponent3(Path base) throws Exception {\n-        testCompatibilityAfterModifyingRecord(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public record R(int i) {\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public record R(int j) {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public class Client {\n-                    public static void main(String... args) {\n-                        R r = new R(0);\n-                        System.out.println(r.i());\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                \"java.lang.NoSuchMethodError\"\n-        );\n-    }\n-\n-    \/* 1- compiles the first version of the record class source code along with the client source code\n-     * 2- executes the client class just to make sure that it works\n-     * 3- compiles the second version of the record class\n-     * 4- executes the client class and makes sure that the VM throws the expected error or not\n-     *    depending on the shouldFail argument\n-     *\/\n-    private void testCompatibilityAfterModifyingRecord(\n-            Path base,\n-            String recordCode1,\n-            String recordCode2,\n-            String clientCode,\n-            boolean shouldFail,\n-            String expectedError) throws Exception {\n-        Path src = base.resolve(\"src\");\n-        Path pkg = src.resolve(\"pkg\");\n-        Path recordSrc = pkg.resolve(\"R\");\n-        Path client = pkg.resolve(\"Client\");\n-\n-        tb.writeJavaFiles(recordSrc, recordCode1);\n-        tb.writeJavaFiles(client, clientCode);\n-\n-        Path out = base.resolve(\"out\");\n-        Files.createDirectories(out);\n-\n-        new JavacTask(tb)\n-                .outdir(out)\n-                .files(findJavaFiles(pkg))\n-                .run();\n-\n-        \/\/ let's execute to check that it's working\n-        String output = new JavaTask(tb)\n-                .classpath(out.toString())\n-                .classArgs(\"pkg.Client\")\n-                .run()\n-                .writeAll()\n-                .getOutput(Task.OutputKind.STDOUT);\n-\n-        \/\/ let's first check that it runs wo issues\n-        if (!output.contains(\"0\")) {\n-            throw new AssertionError(\"execution of Client didn't finish\");\n-        }\n-\n-        \/\/ now lets change the record class\n-        tb.writeJavaFiles(recordSrc, recordCode2);\n-\n-        new JavacTask(tb)\n-                .outdir(out)\n-                .files(findJavaFiles(recordSrc))\n-                .run();\n-\n-        if (shouldFail) {\n-            \/\/ let's now check that we get the expected error\n-            output = new JavaTask(tb)\n-                    .classpath(out.toString())\n-                    .classArgs(\"pkg.Client\")\n-                    .run(Task.Expect.FAIL)\n-                    .writeAll()\n-                    .getOutput(Task.OutputKind.STDERR);\n-            if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError)) {\n-                throw new AssertionError(expectedError + \" expected\");\n-            }\n-        } else {\n-            new JavaTask(tb)\n-                    .classpath(out.toString())\n-                    .classArgs(\"pkg.Client\")\n-                    .run(Task.Expect.SUCCESS);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/records\/RecordsBinaryCompatibilityTests.java","additions":0,"deletions":307,"binary":false,"changes":307,"status":"deleted"}]}