{"files":[{"patch":"@@ -386,15 +386,15 @@\n-        AccessFlags           = PUBLIC | PROTECTED | PRIVATE,\n-        LocalClassFlags       = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC,\n-        StaticLocalFlags      = LocalClassFlags | STATIC | INTERFACE,\n-        MemberClassFlags      = LocalClassFlags | INTERFACE | AccessFlags,\n-        MemberRecordFlags     = MemberClassFlags | STATIC,\n-        ClassFlags            = LocalClassFlags | INTERFACE | PUBLIC | ANNOTATION,\n-        InterfaceVarFlags     = FINAL | STATIC | PUBLIC,\n-        VarFlags              = AccessFlags | FINAL | STATIC |\n-                                VOLATILE | TRANSIENT | ENUM,\n-        ConstructorFlags      = AccessFlags,\n-        InterfaceMethodFlags  = ABSTRACT | PUBLIC,\n-        MethodFlags           = AccessFlags | ABSTRACT | STATIC | NATIVE |\n-                                SYNCHRONIZED | FINAL | STRICTFP,\n-        RecordMethodFlags     = AccessFlags | ABSTRACT | STATIC |\n-                                SYNCHRONIZED | FINAL | STRICTFP;\n+        AccessFlags                       = PUBLIC | PROTECTED | PRIVATE,\n+        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC,\n+        StaticLocalFlags                  = LocalClassFlags | STATIC | INTERFACE,\n+        MemberClassFlags                  = LocalClassFlags | INTERFACE | AccessFlags,\n+        MemberStaticClassFlags            = MemberClassFlags | STATIC,\n+        ClassFlags                        = LocalClassFlags | INTERFACE | PUBLIC | ANNOTATION,\n+        InterfaceVarFlags                 = FINAL | STATIC | PUBLIC,\n+        VarFlags                          = AccessFlags | FINAL | STATIC |\n+                                            VOLATILE | TRANSIENT | ENUM,\n+        ConstructorFlags                  = AccessFlags,\n+        InterfaceMethodFlags              = ABSTRACT | PUBLIC,\n+        MethodFlags                       = AccessFlags | ABSTRACT | STATIC | NATIVE |\n+                                            SYNCHRONIZED | FINAL | STRICTFP,\n+        RecordMethodFlags                 = AccessFlags | ABSTRACT | STATIC |\n+                                            SYNCHRONIZED | FINAL | STRICTFP;\n@@ -402,8 +402,9 @@\n-        ExtendedStandardFlags       = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED,\n-        ExtendedMemberClassFlags    = (long)MemberClassFlags | SEALED | NON_SEALED,\n-        ExtendedClassFlags          = (long)ClassFlags | SEALED | NON_SEALED,\n-        ModifierFlags               = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED,\n-        InterfaceMethodMask         = ABSTRACT | PRIVATE | STATIC | PUBLIC | STRICTFP | DEFAULT,\n-        AnnotationTypeElementMask   = ABSTRACT | PUBLIC,\n-        LocalVarFlags               = FINAL | PARAMETER,\n-        ReceiverParamFlags          = PARAMETER;\n+        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED,\n+        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED,\n+        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED,\n+        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED,\n+        InterfaceMethodMask               = ABSTRACT | PRIVATE | STATIC | PUBLIC | STRICTFP | DEFAULT,\n+        AnnotationTypeElementMask         = ABSTRACT | PUBLIC,\n+        LocalVarFlags                     = FINAL | PARAMETER,\n+        ReceiverParamFlags                = PARAMETER;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -5304,12 +5304,0 @@\n-            \/\/ Check that declarations in inner classes are not static (JLS 8.1.2)\n-            \/\/ Make an exception for static constants.\n-            if (c.owner.kind != PCK &&\n-                ((c.flags() & STATIC) == 0 || c.name == names.empty) &&\n-                (TreeInfo.flags(l.head) & (STATIC | INTERFACE)) != 0) {\n-                Symbol sym = null;\n-                if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;\n-                if (sym == null ||\n-                    sym.kind != VAR ||\n-                    ((VarSymbol) sym).getConstValue() == null)\n-                    log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1220,1 +1220,1 @@\n-            if (sym.isLocal()) {\n+            if (sym.owner.kind.matches(KindSelector.VAL_MTH)) {\n@@ -1226,5 +1226,0 @@\n-                if (staticOrImplicitlyStatic) {\n-                    if (sym.owner.kind == TYP) {\n-                        log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);\n-                    }\n-                }\n@@ -1232,1 +1227,1 @@\n-                mask = (flags & RECORD) != 0 ? MemberRecordFlags : ExtendedMemberClassFlags;\n+                mask = ((flags & STATIC) != 0) && allowRecords ? ExtendedMemberStaticClassFlags : ExtendedMemberClassFlags;\n@@ -1237,1 +1232,1 @@\n-                    log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);\n+                    \/\/log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);\n@@ -1310,1 +1305,4 @@\n-                           FINAL | NON_SEALED)) {\n+                           FINAL | NON_SEALED)\n+                 && checkDisjoint(pos, flags,\n+                                RECORD,\n+                                SEALED | NON_SEALED)  ) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -582,5 +582,0 @@\n-# 0: symbol\n-compiler.err.icls.cant.have.static.decl=\\\n-    Illegal static declaration in inner class {0}\\n\\\n-    modifier \\''static\\'' is only allowed in constant variable declarations\n-\n@@ -3611,3 +3606,0 @@\n-compiler.err.static.declaration.not.allowed.in.inner.classes=\\\n-    static declarations not allowed in inner classes\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Verify that an anonymous class cannot contain a static field.\n+ * @summary Verify that an anonymous class can contain a static field.\n@@ -30,1 +30,1 @@\n- * @run compile\/fail AnonStaticMember_1.java\n+ * @compile AnonStaticMember_1.java\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Verify that an anonymous class cannot contain a static method.\n+ * @summary Verify that an anonymous class can contain a static method.\n@@ -7,1 +7,1 @@\n- * @run compile\/fail\/ref=AnonStaticMember_2.out -XDrawDiagnostics AnonStaticMember_2.java\n+ * @compile AnonStaticMember_2.java\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-AnonStaticMember_2.java:12:21: compiler.err.icls.cant.have.static.decl: compiler.misc.anonymous.class: AnonStaticMember_2$1\n-1 error\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_2.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-InnerNamedConstant_2.java:22:20: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n-InnerNamedConstant_2.java:23:29: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n@@ -4,2 +2,1 @@\n-InnerNamedConstant_2.java:34:26: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner3\n-4 errors\n+1 error\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2.out","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Interfaces may only be declared in top level classes.\n+ * @summary Interfaces can also be declared in inner classes.\n@@ -7,1 +7,1 @@\n- * @compile\/fail\/ref=InterfaceInInner.out -XDrawDiagnostics InterfaceInInner.java\n+ * @compile InterfaceInInner.java\n","filename":"test\/langtools\/tools\/javac\/InterfaceInInner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-InterfaceInInner.java:12:13: compiler.err.static.declaration.not.allowed.in.inner.classes\n-1 error\n","filename":"test\/langtools\/tools\/javac\/InterfaceInInner.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -5,2 +5,2 @@\n- * @compile\/fail\/ref=LocalInterface.out -XDrawDiagnostics LocalInterface.java\n- * @compile --enable-preview -source ${jdk.version} LocalInterface.java\n+ * @compile\/fail\/ref=LocalInterface.out -XDrawDiagnostics -source 15 LocalInterface.java\n+ * @compile LocalInterface.java\n","filename":"test\/langtools\/tools\/javac\/LocalInterface.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+- compiler.warn.source.no.system.modules.path: 15\n@@ -3,0 +4,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/LocalInterface.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile --enable-preview -source ${jdk.version} LocalRecord.java\n+ * @compile LocalRecord.java\n","filename":"test\/langtools\/tools\/javac\/LocalRecord.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-MinContextOpTest.java:38:25: compiler.err.mod.not.allowed.here: static\n-MinContextOpTest.java:44:25: compiler.err.mod.not.allowed.here: static\n@@ -4,1 +2,1 @@\n-3 errors\n+1 error\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest.out","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.static.declaration.not.allowed.in.inner.classes\n-\n-class EnumsMustBeStatic {\n-    class Nested {\n-        enum E { A, B, C }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/EnumsMustBeStatic.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -22,1 +22,0 @@\n- *\n@@ -25,1 +24,1 @@\n-package foo;\n+\/\/ key: compiler.err.expected4\n@@ -27,2 +26,1 @@\n-public class C3 {\n-}\n+int Expected4;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/Expected4.java","additions":2,"deletions":4,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/C3.java","status":"copied"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.icls.cant.have.static.decl\n-\n-class InnerClassCantHaveStatic {\n-    class Inner {\n-        static int i;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InnerClassCantHaveStatic.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.static.declaration.not.allowed.in.inner.classes\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n-\n-class Outer {\n-    class Inner {\n-        record R(int a) {}\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RecordsNotAllowedInInnerClasses.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary javac allows enum in an inner class\n+ * @summary javac should allow enum in an inner class\n@@ -7,1 +7,1 @@\n- * @compile\/fail\/ref=NestedEnum.out -XDrawDiagnostics  NestedEnum.java\n+ * @compile NestedEnum.java\n","filename":"test\/langtools\/tools\/javac\/enum\/NestedEnum.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-NestedEnum.java:12:9: compiler.err.static.declaration.not.allowed.in.inner.classes\n-1 error\n","filename":"test\/langtools\/tools\/javac\/enum\/NestedEnum.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Empty Enums allowed in non-static contexts\n+ * @summary enums should be allowed in non-static contexts\n@@ -6,1 +6,1 @@\n- * @compile\/fail\/ref=T5081785.out -XDrawDiagnostics  T5081785.java\n+ * @compile T5081785.java\n","filename":"test\/langtools\/tools\/javac\/enum\/T5081785.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,7 @@\n- * @compile --enable-preview -source ${jdk.version} LocalStaticDeclarations.java\n- * @run main\/othervm --enable-preview LocalStaticDeclarations\n+ * @run main LocalStaticDeclarations\n+ *\/\n+\n+\/** this test checks two thinks:\n+ *  1 - that static declarations are allowed inside inner classes\n+ *  2 - and in addtion that non-static variables can't be captured\n+ *      by static contexts\n@@ -61,1 +66,2 @@\n-                { int LOCAL_VARIABLE = 0;\n+                {\n+                    int LOCAL_VARIABLE = 0;\n@@ -65,0 +71,1 @@\n+                    int LOCAL_VARIABLE = 0;\n@@ -97,1 +104,1 @@\n-        ENUM(\"enum CE { #{STATIC_LOCAL} }\"),\n+        ENUM(\"enum CE { CE1; #{STATIC_LOCAL} }\"),\n@@ -128,1 +135,0 @@\n-        NONE(\"\"),\n@@ -144,4 +150,4 @@\n-         LITERAL(\"1\"),\n-         STATIC_FIELD(\"STATIC_FIELD\"),\n-         LOCAL_VARIABLE(\"LOCAL_VARIABLE\"),\n-         INSTANCE_FIELD(\"INSTANCE_FIELD\");\n+        LITERAL(\"1\"),\n+        STATIC_FIELD(\"STATIC_FIELD\"),\n+        LOCAL_VARIABLE(\"LOCAL_VARIABLE\"),\n+        INSTANCE_FIELD(\"INSTANCE_FIELD\");\n@@ -149,1 +155,1 @@\n-         String expr;\n+        String expr;\n@@ -151,1 +157,1 @@\n-         Expression(String expr) {\n+        Expression(String expr) {\n@@ -178,1 +184,0 @@\n-                .withOptions(new String[]{\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())})\n@@ -184,2 +189,2 @@\n-        return decl == StaticLocalDecl.INTERFACE && (member == Member.DEFAULT_METHOD || member == Member.NONE) ||\n-               decl != StaticLocalDecl.INTERFACE && (member == Member.METHOD || member == Member.NONE);\n+        return decl == StaticLocalDecl.INTERFACE && member == Member.DEFAULT_METHOD ||\n+               decl != StaticLocalDecl.INTERFACE && member == Member.METHOD;\n@@ -190,1 +195,1 @@\n-            Assert.check(result.hasErrors(), result.compilationInfo());\n+            Assert.check(result.hasErrors(), \"unexpected compilation\\n\" + result.compilationInfo());\n@@ -200,4 +205,1 @@\n-        return ((container != Container.NO_CONTAINER &&\n-                container != Container.LAMBDA &&\n-                container != Container.ANONYMOUS)) ||\n-                (member != Member.NONE && !acceptableExpr());\n+        return (expr == Expression.LOCAL_VARIABLE || expr == Expression.INSTANCE_FIELD);\n@@ -211,4 +213,1 @@\n-        if ((container == Container.NO_CONTAINER ||\n-                container == Container.LAMBDA ||\n-                container == Container.ANONYMOUS) &&\n-                !acceptableExpr()) {\n+        if (expr == Expression.LOCAL_VARIABLE || expr == Expression.INSTANCE_FIELD) {\n@@ -216,2 +215,0 @@\n-        } else if (container == Container.ENUM) {\n-            return result.containsKey(\"compiler.err.enum.constant.expected\" );\n@@ -219,1 +216,1 @@\n-        return result.containsKey(\"compiler.err.static.declaration.not.allowed.in.inner.classes\" );\n+        return false;\n","filename":"test\/langtools\/tools\/javac\/records\/LocalStaticDeclarations.java","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -488,1 +488,1 @@\n-    public void testStaticLocalTypes() {\n+    public void testStaticDefinitionsInLocalandInner() {\n@@ -781,0 +781,114 @@\n+        assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"class C {\\n\" +\n+                \"    String hello = \\\"hello\\\";\\n\" +\n+                \"    class Inner {\\n\" +\n+                \"        enum E {\\n\" +\n+                \"            A;\\n\" +\n+                \"            public void test1() {\\n\" +\n+                \"                class X {\\n\" +\n+                \"                    public void test2() {\\n\" +\n+                \"                        System.err.println(hello);\\n\" +\n+                \"                    }\\n\" +\n+                \"                }\\n\" +\n+                \"            }\\n\" +\n+                \"        }\\n\" +\n+                \"    }\\n\" +\n+                \"}\");\n+\n+        assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"class C {\\n\" +\n+                \"    String hello = \\\"hello\\\";\\n\" +\n+                \"    class Inner {\\n\" +\n+                \"        enum E {\\n\" +\n+                \"            A;\\n\" +\n+                \"            public void test1() {\\n\" +\n+                \"                System.err.println(hello);\\n\" +\n+                \"            }\\n\" +\n+                \"        }\\n\" +\n+                \"    }\\n\" +\n+                \"}\");\n+\n+        assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"class C {\\n\" +\n+                \"    String hello = \\\"hello\\\";\\n\" +\n+                \"    class Inner {\\n\" +\n+                \"        record R() {\\n\" +\n+                \"            public void test1() {\\n\" +\n+                \"                class X {\\n\" +\n+                \"                    public void test2() {\\n\" +\n+                \"                        System.err.println(hello);\\n\" +\n+                \"                    }\\n\" +\n+                \"                }\\n\" +\n+                \"            }\\n\" +\n+                \"        }\\n\" +\n+                \"    }\\n\" +\n+                \"}\");\n+\n+        assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"class C {\\n\" +\n+                \"    String hello = \\\"hello\\\";\\n\" +\n+                \"    class Inner {\\n\" +\n+                \"        record R() {\\n\" +\n+                \"            public void test1() {\\n\" +\n+                \"                System.err.println(hello);\\n\" +\n+                \"            }\\n\" +\n+                \"        }\\n\" +\n+                \"    }\\n\" +\n+                \"}\");\n+\n+        assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"class C {\\n\" +\n+                \"    String hello = \\\"hello\\\";\\n\" +\n+                \"    class Inner {\\n\" +\n+                \"        interface I {\\n\" +\n+                \"            public default void test1() {\\n\" +\n+                \"                class X {\\n\" +\n+                \"                    public void test2() {\\n\" +\n+                \"                        System.err.println(hello);\\n\" +\n+                \"                    }\\n\" +\n+                \"                }\\n\" +\n+                \"            }\\n\" +\n+                \"        }\\n\" +\n+                \"    }\\n\" +\n+                \"}\");\n+\n+        assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"class C {\\n\" +\n+                \"    String hello = \\\"hello\\\";\\n\" +\n+                \"    class Inner {\\n\" +\n+                \"        interface I {\\n\" +\n+                \"            public default void test1() {\\n\" +\n+                \"                System.err.println(hello);\\n\" +\n+                \"            }\\n\" +\n+                \"        }\\n\" +\n+                \"    }\\n\" +\n+                \"}\");\n+\n+        assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"class C {\\n\" +\n+                \"    String hello = \\\"hello\\\";\\n\" +\n+                \"    class Inner {\\n\" +\n+                \"        static class SC {\\n\" +\n+                \"            public void test1() {\\n\" +\n+                \"                class X {\\n\" +\n+                \"                    public void test2() {\\n\" +\n+                \"                        System.err.println(hello);\\n\" +\n+                \"                    }\\n\" +\n+                \"                }\\n\" +\n+                \"            }\\n\" +\n+                \"        }\\n\" +\n+                \"    }\\n\" +\n+                \"}\");\n+\n+        assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"class C {\\n\" +\n+                \"    String hello = \\\"hello\\\";\\n\" +\n+                \"    class Inner {\\n\" +\n+                \"        static class SC {\\n\" +\n+                \"            public void test1() {\\n\" +\n+                \"                System.err.println(hello);\\n\" +\n+                \"            }\\n\" +\n+                \"        }\\n\" +\n+                \"    }\\n\" +\n+                \"}\");\n+\n@@ -850,0 +964,25 @@\n+\n+        \/\/ inner classes can contain static methods too\n+        assertOK(\n+                \"\"\"\n+                class C {\n+                    class Inner {\n+                        \/\/ static method inside inner class\n+                        static void m() {}\n+                    }\n+                }\n+                \"\"\"\n+        );\n+\n+        assertOK(\n+                \"\"\"\n+                class C {\n+                     void m() {\n+                         new Object() {\n+                            \/\/ static method inside inner class\n+                            static void m() {}\n+                         };\n+                     }\n+                }\n+                \"\"\"\n+        );\n@@ -880,1 +1019,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n@@ -889,1 +1028,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n@@ -899,1 +1038,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n@@ -908,1 +1047,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":144,"deletions":5,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test binary compatibility rules for record classes\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RecordsBinaryCompatibilityTests\n+ *\/\n+\n+import java.util.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.IntStream;\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavaTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+\n+public class RecordsBinaryCompatibilityTests extends TestRunner {\n+    ToolBox tb;\n+\n+    RecordsBinaryCompatibilityTests() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        RecordsBinaryCompatibilityTests t = new RecordsBinaryCompatibilityTests();\n+        t.runTests();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterAddingRecordComponent(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, int j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                        \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterDeletingRecordComponent(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, int j) {\n+                    public R(int j) {\n+                        this(0, j);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(2);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                        \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterChangingRecordComponent(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, int j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, String j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0, 1);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                        \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterReorderingRecordComponents(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i, String j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(String j, int i) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0, \"\");\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                        \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterChangingRecordComponent2(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int j) {\n+                    public static int i() { return 0; }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int i) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                \"java.lang.IncompatibleClassChangeError\"\n+        );\n+    }\n+\n+    @Test\n+    public void testCompatibilityAfterChangingRecordComponent3(Path base) throws Exception {\n+        testCompatibilityAfterModifyingRecord(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public record R(int i) {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public record R(int j) {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client {\n+                    public static void main(String... args) {\n+                        R r = new R(0);\n+                        System.out.println(r.i());\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                \"java.lang.NoSuchMethodError\"\n+        );\n+    }\n+\n+    \/* 1- compiles the first version of the record class source code along with the client source code\n+     * 2- executes the client class just to make sure that it works\n+     * 3- compiles the second version of the record class\n+     * 4- executes the client class and makes sure that the VM throws the expected error or not\n+     *    depending on the shouldFail argument\n+     *\/\n+    private void testCompatibilityAfterModifyingRecord(\n+            Path base,\n+            String recordCode1,\n+            String recordCode2,\n+            String clientCode,\n+            boolean shouldFail,\n+            String expectedError) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path pkg = src.resolve(\"pkg\");\n+        Path recordSrc = pkg.resolve(\"R\");\n+        Path client = pkg.resolve(\"Client\");\n+\n+        tb.writeJavaFiles(recordSrc, recordCode1);\n+        tb.writeJavaFiles(client, clientCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        \/\/ let's execute to check that it's working\n+        String output = new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Client\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT);\n+\n+        \/\/ let's first check that it runs wo issues\n+        if (!output.contains(\"0\")) {\n+            throw new AssertionError(\"execution of Client didn't finish\");\n+        }\n+\n+        \/\/ now lets change the record class\n+        tb.writeJavaFiles(recordSrc, recordCode2);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(recordSrc))\n+                .run();\n+\n+        if (shouldFail) {\n+            \/\/ let's now check that we get the expected error\n+            output = new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"pkg.Client\")\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.STDERR);\n+            if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError)) {\n+                throw new AssertionError(expectedError + \" expected\");\n+            }\n+        } else {\n+            new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"pkg.Client\")\n+                    .run(Task.Expect.SUCCESS);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/RecordsBinaryCompatibilityTests.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"}]}