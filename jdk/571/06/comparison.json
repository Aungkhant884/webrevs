{"files":[{"patch":"@@ -386,15 +386,15 @@\n-        AccessFlags           = PUBLIC | PROTECTED | PRIVATE,\n-        LocalClassFlags       = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC,\n-        StaticLocalFlags      = LocalClassFlags | STATIC | INTERFACE,\n-        MemberClassFlags      = LocalClassFlags | INTERFACE | AccessFlags,\n-        MemberRecordFlags     = MemberClassFlags | STATIC,\n-        ClassFlags            = LocalClassFlags | INTERFACE | PUBLIC | ANNOTATION,\n-        InterfaceVarFlags     = FINAL | STATIC | PUBLIC,\n-        VarFlags              = AccessFlags | FINAL | STATIC |\n-                                VOLATILE | TRANSIENT | ENUM,\n-        ConstructorFlags      = AccessFlags,\n-        InterfaceMethodFlags  = ABSTRACT | PUBLIC,\n-        MethodFlags           = AccessFlags | ABSTRACT | STATIC | NATIVE |\n-                                SYNCHRONIZED | FINAL | STRICTFP,\n-        RecordMethodFlags     = AccessFlags | ABSTRACT | STATIC |\n-                                SYNCHRONIZED | FINAL | STRICTFP;\n+        AccessFlags                       = PUBLIC | PROTECTED | PRIVATE,\n+        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC,\n+        StaticLocalFlags                  = LocalClassFlags | STATIC | INTERFACE,\n+        MemberClassFlags                  = LocalClassFlags | INTERFACE | AccessFlags,\n+        MemberStaticClassFlags            = MemberClassFlags | STATIC,\n+        ClassFlags                        = LocalClassFlags | INTERFACE | PUBLIC | ANNOTATION,\n+        InterfaceVarFlags                 = FINAL | STATIC | PUBLIC,\n+        VarFlags                          = AccessFlags | FINAL | STATIC |\n+                                            VOLATILE | TRANSIENT | ENUM,\n+        ConstructorFlags                  = AccessFlags,\n+        InterfaceMethodFlags              = ABSTRACT | PUBLIC,\n+        MethodFlags                       = AccessFlags | ABSTRACT | STATIC | NATIVE |\n+                                            SYNCHRONIZED | FINAL | STRICTFP,\n+        RecordMethodFlags                 = AccessFlags | ABSTRACT | STATIC |\n+                                            SYNCHRONIZED | FINAL | STRICTFP;\n@@ -402,8 +402,9 @@\n-        ExtendedStandardFlags       = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED,\n-        ExtendedMemberClassFlags    = (long)MemberClassFlags | SEALED | NON_SEALED,\n-        ExtendedClassFlags          = (long)ClassFlags | SEALED | NON_SEALED,\n-        ModifierFlags               = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED,\n-        InterfaceMethodMask         = ABSTRACT | PRIVATE | STATIC | PUBLIC | STRICTFP | DEFAULT,\n-        AnnotationTypeElementMask   = ABSTRACT | PUBLIC,\n-        LocalVarFlags               = FINAL | PARAMETER,\n-        ReceiverParamFlags          = PARAMETER;\n+        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED,\n+        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED,\n+        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED,\n+        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED,\n+        InterfaceMethodMask               = ABSTRACT | PRIVATE | STATIC | PUBLIC | STRICTFP | DEFAULT,\n+        AnnotationTypeElementMask         = ABSTRACT | PUBLIC,\n+        LocalVarFlags                     = FINAL | PARAMETER,\n+        ReceiverParamFlags                = PARAMETER;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+        allowRecords = Feature.RECORDS.allowedInSource(source);\n@@ -210,0 +211,4 @@\n+    \/** Are records allowed\n+     *\/\n+    private final boolean allowRecords;\n+\n@@ -5312,3 +5317,4 @@\n-            if (c.owner.kind != PCK &&\n-                ((c.flags() & STATIC) == 0 || c.name == names.empty) &&\n-                (TreeInfo.flags(l.head) & (STATIC | INTERFACE)) != 0) {\n+            if (!allowRecords &&\n+                    c.owner.kind != PCK &&\n+                    ((c.flags() & STATIC) == 0 || c.name == names.empty) &&\n+                    (TreeInfo.flags(l.head) & (STATIC | INTERFACE)) != 0) {\n@@ -5318,2 +5324,2 @@\n-                    sym.kind != VAR ||\n-                    ((VarSymbol) sym).getConstValue() == null)\n+                        sym.kind != VAR ||\n+                        ((VarSymbol) sym).getConstValue() == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1219,1 +1219,1 @@\n-            if (sym.isLocal()) {\n+            if (sym.owner.kind.matches(KindSelector.VAL_MTH)) {\n@@ -1223,0 +1223,1 @@\n+                \/\/ local statics are allowed only if records are allowed too\n@@ -1225,5 +1226,0 @@\n-                if (staticOrImplicitlyStatic) {\n-                    if (sym.owner.kind == TYP) {\n-                        log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);\n-                    }\n-                }\n@@ -1231,1 +1227,2 @@\n-                mask = (flags & RECORD) != 0 ? MemberRecordFlags : ExtendedMemberClassFlags;\n+                \/\/ statics in inner classes are allowed only if records are allowed too\n+                mask = ((flags & STATIC) != 0) && allowRecords ? ExtendedMemberStaticClassFlags : ExtendedMemberClassFlags;\n@@ -1233,1 +1230,1 @@\n-                    (sym.owner.flags_field & STATIC) != 0)\n+                    (sym.owner.flags_field & STATIC) != 0) {\n@@ -1235,1 +1232,1 @@\n-                else if ((flags & ENUM) != 0 || (flags & RECORD) != 0) {\n+                } else if (!allowRecords && ((flags & ENUM) != 0 || (flags & RECORD) != 0)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Verify that an anonymous class cannot contain a static field.\n+ * @summary Verify that an anonymous class can contain a static field only if source >= 16\n@@ -30,1 +30,2 @@\n- * @run compile\/fail AnonStaticMember_1.java\n+ * @compile\/fail\/ref=AnonStaticMember_1.out -source 15 -XDrawDiagnostics AnonStaticMember_1.java\n+ * @compile AnonStaticMember_1.java\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_1.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+- compiler.warn.source.no.system.modules.path: 15\n+AnonStaticMember_1.java:36:20: compiler.err.icls.cant.have.static.decl: compiler.misc.anonymous.class: AnonStaticMember_1$1\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_1.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Verify that an anonymous class cannot contain a static method.\n+ * @summary Verify that an anonymous class can contain a static method only if source >= 16\n@@ -7,1 +7,2 @@\n- * @run compile\/fail\/ref=AnonStaticMember_2.out -XDrawDiagnostics AnonStaticMember_2.java\n+ * @compile\/fail\/ref=AnonStaticMember_2.out -source 15 -XDrawDiagnostics AnonStaticMember_2.java\n+ * @compile AnonStaticMember_2.java\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_2.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-AnonStaticMember_2.java:12:21: compiler.err.icls.cant.have.static.decl: compiler.misc.anonymous.class: AnonStaticMember_2$1\n+- compiler.warn.source.no.system.modules.path: 15\n+AnonStaticMember_2.java:13:21: compiler.err.icls.cant.have.static.decl: compiler.misc.anonymous.class: AnonStaticMember_2$1\n@@ -3,0 +4,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/AnonStaticMember_2.out","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,2 @@\n- * @compile\/fail\/ref=InnerNamedConstant_2.out -XDrawDiagnostics InnerNamedConstant_2.java\n+ * @compile\/fail\/ref=InnerNamedConstant_2_A.out -XDrawDiagnostics -source 15 InnerNamedConstant_2.java\n+ * @compile\/fail\/ref=InnerNamedConstant_2_B.out -XDrawDiagnostics InnerNamedConstant_2.java\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,5 +0,0 @@\n-InnerNamedConstant_2.java:22:20: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n-InnerNamedConstant_2.java:23:29: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n-InnerNamedConstant_2.java:25:13: compiler.err.cant.assign.val.to.final.var: z\n-InnerNamedConstant_2.java:34:26: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner3\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -0,0 +1,7 @@\n+- compiler.warn.source.no.system.modules.path: 15\n+InnerNamedConstant_2.java:23:20: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n+InnerNamedConstant_2.java:24:29: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner2\n+InnerNamedConstant_2.java:26:13: compiler.err.cant.assign.val.to.final.var: z\n+InnerNamedConstant_2.java:35:26: compiler.err.icls.cant.have.static.decl: InnerNamedConstant_2.Inner3\n+4 errors\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2_A.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+InnerNamedConstant_2.java:26:13: compiler.err.cant.assign.val.to.final.var: z\n+1 error\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2_B.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Interfaces may only be declared in top level classes.\n+ * @summary Interfaces can be declared in inner classes only for source >= 16\n@@ -7,1 +7,2 @@\n- * @compile\/fail\/ref=InterfaceInInner.out -XDrawDiagnostics InterfaceInInner.java\n+ * @compile\/fail\/ref=InterfaceInInner.out -XDrawDiagnostics -source 15 InterfaceInInner.java\n+ * @compile InterfaceInInner.java\n","filename":"test\/langtools\/tools\/javac\/InterfaceInInner.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-InterfaceInInner.java:12:13: compiler.err.static.declaration.not.allowed.in.inner.classes\n+- compiler.warn.source.no.system.modules.path: 15\n+InterfaceInInner.java:13:13: compiler.err.icls.cant.have.static.decl: foo\n@@ -3,0 +4,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/InterfaceInInner.out","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n- * @compile\/fail\/ref=MinContextOpTest.out -XDrawDiagnostics MinContextOpTest.java\n+ * @compile\/fail\/ref=MinContextOpTest_A.out -XDrawDiagnostics -source 15 MinContextOpTest.java\n+ * @compile\/fail\/ref=MinContextOpTest_B.out -XDrawDiagnostics MinContextOpTest.java\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-MinContextOpTest.java:38:25: compiler.err.mod.not.allowed.here: static\n-MinContextOpTest.java:44:25: compiler.err.mod.not.allowed.here: static\n-MinContextOpTest.java:50:34: compiler.err.prob.found.req: (compiler.misc.infer.no.conforming.assignment.exists: T,K,V,E, (compiler.misc.inconvertible.types: java.util.function.Function<MinContextOpTest.A.T,MinContextOpTest.A.T>, java.util.function.Function<? super MinContextOpTest.A.T,? extends MinContextOpTest.A.T<?>>))\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -0,0 +1,6 @@\n+- compiler.warn.source.no.system.modules.path: 15\n+MinContextOpTest.java:39:25: compiler.err.mod.not.allowed.here: static\n+MinContextOpTest.java:45:25: compiler.err.mod.not.allowed.here: static\n+MinContextOpTest.java:51:34: compiler.err.prob.found.req: (compiler.misc.infer.no.conforming.assignment.exists: T,K,V,E, (compiler.misc.inconvertible.types: java.util.function.Function<MinContextOpTest.A.T,MinContextOpTest.A.T>, java.util.function.Function<? super MinContextOpTest.A.T,? extends MinContextOpTest.A.T<?>>))\n+3 errors\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest_A.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+MinContextOpTest.java:51:34: compiler.err.prob.found.req: (compiler.misc.infer.no.conforming.assignment.exists: T,K,V,E, (compiler.misc.inconvertible.types: java.util.function.Function<MinContextOpTest.A.T,MinContextOpTest.A.T>, java.util.function.Function<? super MinContextOpTest.A.T,? extends MinContextOpTest.A.T<?>>))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest_B.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -25,0 +25,2 @@\n+\/\/ key: compiler.warn.source.no.system.modules.path\n+\/\/ options: -source 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/EnumsMustBeStatic.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2020 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+\/\/ key: compiler.warn.source.no.system.modules.path\n+\/\/ options: -source 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InnerClassCantHaveStatic.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.static.declaration.not.allowed.in.inner.classes\n-\n-class Outer {\n-    class Inner {\n-        record R(int a) {}\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RecordsNotAllowedInInnerClasses.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary javac allows enum in an inner class\n+ * @summary javac allows enum in an inner class for source >= 16\n@@ -7,1 +7,2 @@\n- * @compile\/fail\/ref=NestedEnum.out -XDrawDiagnostics  NestedEnum.java\n+ * @compile\/fail\/ref=NestedEnum.out -XDrawDiagnostics -source 15 NestedEnum.java\n+ * @compile NestedEnum.java\n","filename":"test\/langtools\/tools\/javac\/enum\/NestedEnum.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-NestedEnum.java:12:9: compiler.err.static.declaration.not.allowed.in.inner.classes\n+- compiler.warn.source.no.system.modules.path: 15\n+NestedEnum.java:13:9: compiler.err.static.declaration.not.allowed.in.inner.classes\n@@ -3,0 +4,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/enum\/NestedEnum.out","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Empty Enums allowed in non-static contexts\n+ * @summary enums should be allowed in non-static contexts\n@@ -6,1 +6,2 @@\n- * @compile\/fail\/ref=T5081785.out -XDrawDiagnostics  T5081785.java\n+ * @compile\/fail\/ref=T5081785.out -XDrawDiagnostics -source 15 T5081785.java\n+ * @compile T5081785.java\n","filename":"test\/langtools\/tools\/javac\/enum\/T5081785.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,4 +1,5 @@\n-T5081785.java:29:9: compiler.err.static.declaration.not.allowed.in.inner.classes\n-T5081785.java:12:13: compiler.err.static.declaration.not.allowed.in.inner.classes\n-T5081785.java:19:27: compiler.err.static.declaration.not.allowed.in.inner.classes\n-T5081785.java:24:31: compiler.err.static.declaration.not.allowed.in.inner.classes\n+- compiler.warn.source.no.system.modules.path: 15\n+T5081785.java:30:9: compiler.err.static.declaration.not.allowed.in.inner.classes\n+T5081785.java:13:13: compiler.err.static.declaration.not.allowed.in.inner.classes\n+T5081785.java:20:27: compiler.err.static.declaration.not.allowed.in.inner.classes\n+T5081785.java:25:31: compiler.err.static.declaration.not.allowed.in.inner.classes\n@@ -6,0 +7,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/enum\/T5081785.out","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,0 +51,6 @@\n+\/** this test checks two thinks:\n+ *  1 - that static declarations are allowed inside inner classes\n+ *  2 - and in addtion that non-static variables can't be captured\n+ *      by static contexts\n+ *\/\n+\n@@ -60,1 +66,2 @@\n-                { int LOCAL_VARIABLE = 0;\n+                {\n+                    int LOCAL_VARIABLE = 0;\n@@ -64,0 +71,1 @@\n+                    int LOCAL_VARIABLE = 0;\n@@ -96,1 +104,1 @@\n-        ENUM(\"enum CE { #{STATIC_LOCAL} }\"),\n+        ENUM(\"enum CE { CE1; #{STATIC_LOCAL} }\"),\n@@ -127,1 +135,0 @@\n-        NONE(\"\"),\n@@ -182,2 +189,2 @@\n-        return decl == StaticLocalDecl.INTERFACE && (member == Member.DEFAULT_METHOD || member == Member.NONE) ||\n-               decl != StaticLocalDecl.INTERFACE && (member == Member.METHOD || member == Member.NONE);\n+        return decl == StaticLocalDecl.INTERFACE && member == Member.DEFAULT_METHOD ||\n+               decl != StaticLocalDecl.INTERFACE && member == Member.METHOD;\n@@ -188,1 +195,1 @@\n-            Assert.check(result.hasErrors(), result.compilationInfo());\n+            Assert.check(result.hasErrors(), \"unexpected compilation\\n\" + result.compilationInfo());\n@@ -198,4 +205,1 @@\n-        return ((container != Container.NO_CONTAINER &&\n-                container != Container.LAMBDA &&\n-                container != Container.ANONYMOUS)) ||\n-                (member != Member.NONE && !acceptableExpr());\n+        return (expr == Expression.LOCAL_VARIABLE || expr == Expression.INSTANCE_FIELD);\n@@ -209,4 +213,1 @@\n-        if ((container == Container.NO_CONTAINER ||\n-                container == Container.LAMBDA ||\n-                container == Container.ANONYMOUS) &&\n-                !acceptableExpr()) {\n+        if (expr == Expression.LOCAL_VARIABLE || expr == Expression.INSTANCE_FIELD) {\n@@ -214,2 +215,0 @@\n-        } else if (container == Container.ENUM) {\n-            return result.containsKey(\"compiler.err.enum.constant.expected\" );\n@@ -217,1 +216,1 @@\n-        return result.containsKey(\"compiler.err.static.declaration.not.allowed.in.inner.classes\" );\n+        return false;\n","filename":"test\/langtools\/tools\/javac\/records\/LocalStaticDeclarations.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -480,118 +480,33 @@\n-    public void testStaticLocalTypes() {\n-        \/\/ local records can also be final\n-        assertOK(\"class R { \\n\" +\n-                \"    void m() { \\n\" +\n-                \"        final record RR(int x) { };\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        \/\/ Can't capture locals\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R { \\n\" +\n-                        \"    void m(int y) { \\n\" +\n-                        \"        record RR(int x) { public int x() { return y; }};\\n\" +\n-                        \"    }\\n\" +\n-                        \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R { \\n\" +\n-                        \"    void m() {\\n\" +\n-                        \"        int y;\\n\" +\n-                        \"        record RR(int x) { public int x() { return y; }};\\n\" +\n-                        \"    }\\n\" +\n-                        \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m() {\\n\" +\n-                \"        String hello = \\\"hello\\\";\\n\" +\n-                \"        interface I {\\n\" +\n-                \"            public default void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(hello);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m() {\\n\" +\n-                \"        String hello = \\\"hello\\\";\\n\" +\n-                \"        record R(int i) {\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(hello);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m() {\\n\" +\n-                \"        String hello = \\\"hello\\\";\\n\" +\n-                \"        enum E {\\n\" +\n-                \"            A;\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(hello);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        interface I {\\n\" +\n-                \"            public default void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(param);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        record R(int i) {\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(param);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        enum E {\\n\" +\n-                \"            A;\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(param);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+    public void testStaticLocals() {\n+        \/\/ static locals can't capture local variables, instance fields or type variables\n+        for (String s : List.of(\n+                \"record RR(int x) { public int x() { return y; }};\",\n+                \"record RR(int x) { public int x() { return z; }};\",\n+                \"record RR(int x) { public int x() { return instance; }};\",\n+                \"record RR(T t) {};\",\n+                \"record RR(U u) {};\",\n+\n+                \"interface I { default int x() { return y; }};\",\n+                \"interface I { default int x() { return z; }};\",\n+                \"interface I { default int x() { return instance; }};\",\n+                \"interface I { default int x(T t) { return 0; }};\",\n+                \"interface I { default int x(U u) { return 0; }};\",\n+\n+                \"enum E { A; int x() { return y; }};\",\n+                \"enum E { A; int x() { return z; }};\",\n+                \"enum E { A; int x() { return instance; }};\",\n+                \"enum E { A; int x(T t) { return 0; }};\",\n+                \"enum E { A; int x(U u) { return 0; }};\"\n+        )) {\n+            assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                \"\"\"\n+                class R<T> {\n+                    int instance = 0;\n+                    <U> U m(int y) {\n+                        int z;\n+                        #S\n+                        return null;\n+                    }\n+                }\n+                \"\"\".replaceFirst(\"#S\", s));\n+        }\n@@ -599,15 +514,32 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    String instanceField = \\\"instance\\\";\\n\" +\n-                \"    public static void m() {\\n\" +\n-                \"        interface I {\\n\" +\n-                \"            public default void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(instanceField);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+        \/\/ a similar example but a bit more complex\n+        for (String s : List.of(\n+                \"record R() { void test1() { class X { void test2() { System.err.println(localVar); } } } }\",\n+                \"record R() { void test1() { class X { void test2() { System.err.println(param); } } } }\",\n+                \"record R() {void test1() { class X { void test2() { System.err.println(instanceField); } } } }\",\n+                \"record R() { void test1() { class X { T t; } } }\",\n+                \"record R() { void test1() { class X { U u; } } }\",\n+\n+                \"interface I { default void test1() { class X { void test2() { System.err.println(localVar); } } } }\",\n+                \"interface I() { default void test1() { class X { void test2() {System.err.println(param);} } } }\",\n+                \"interface I { default void test1() { class X { void test2() { System.err.println(instanceField); } } } }\",\n+                \"interface I { default void test1() { class X { T t; } } }\",\n+                \"interface I() { default void test1() { class X {U u;} } }\",\n+\n+                \"enum E { A; void test1() { class X { void test2() { System.err.println(localVar); } } } }\",\n+                \"enum E { A; void test1() { class X { void test2() {System.err.println(param);} } } }\",\n+                \"enum E { A; void test1() { class X { void test2() { System.err.println(instanceField); } } } }\",\n+                \"enum E { A; void test1() { class X { T t; } } }\",\n+                \"enum E { A; void test1() { class X {U u;} } }\"\n+        )) {\n+            assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                    \"\"\"\n+                    class C<T> {\n+                        String instanceField = \"instance\";\n+                        static <U> U m(String param) {\n+                            String localVar = \"local\";\n+                            #S\n+                            return null;\n+                    }\n+                }\n+                \"\"\".replaceFirst(\"#S\", s));\n+        }\n@@ -615,15 +547,4 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    String instanceField = \\\"instance\\\";\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        record R(int i) {\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(instanceField);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+        \/\/ can't self-shadow\n+        for (String s : List.of(\"record R() {}\", \"interface R {}\", \"enum R { A }\")) {\n+            assertFail(\"compiler.err.already.defined\", \"class R { void m() { #S } }\".replaceFirst(\"#S\", s));\n+        }\n@@ -631,16 +552,4 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    String instanceField = \\\"instance\\\";\\n\" +\n-                \"    public static void m(String param) {\\n\" +\n-                \"        enum E {\\n\" +\n-                \"            A;\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        System.err.println(instanceField);\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+        \/\/ can't be explicitly static\n+        for (String s : List.of(\"static record RR() { }\", \"static interface I {}\", \"static enum E { A }\")) {\n+            assertFail(\"compiler.err.illegal.start.of.expr\", \"class R { void m() { #S } }\".replaceFirst(\"#S\", s));\n+        }\n@@ -648,8 +557,8 @@\n-        \/\/ instance fields\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R { \\n\" +\n-                        \"    int z = 0;\\n\" +\n-                        \"    void m() { \\n\" +\n-                        \"        record RR(int x) { public int x() { return z; }};\\n\" +\n-                        \"    }\\n\" +\n-                        \"}\");\n+        \/\/ but static fields can be accessed\n+        for (String s : List.of(\n+                \"record RR() { public int x() { return z; } };\",\n+                \"interface I { default int x() { return z; } }\",\n+                \"enum E { A; int x() { return z; } }\"\n+        )) {\n+            assertOK(\"class R { static int z = 0; void m() { #S } }\".replaceFirst(\"#S\", s));\n+        }\n@@ -657,7 +566,3 @@\n-        \/\/ or type variables\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R<T> { \\n\" +\n-                        \"    void m() { \\n\" +\n-                        \"        record RR(T t) {};\\n\" +\n-                        \"    }\\n\" +\n-                        \"}\");\n+        \/\/ local records can also be final\n+        assertOK(\"class R { void m() { final record RR(int x) { }; } }\");\n+    }\n@@ -665,9 +570,29 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R {\\n\" +\n-                \"    static <U> U make(U u) { \/\/method is static\\n\" +\n-                \"        interface Checker {\\n\" +\n-                \"            void check(U u);\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+    public void testStaticDefinitionsInInnerClasses() {\n+        \/\/ static defs in inner classes can't capture instance fields or type variables\n+        for (String s : List.of(\n+                \"\"\"\n+                record R() {\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -675,20 +600,26 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class LocalEnum {\\n\" +\n-                \"    static <U> U getAndSet(U u) { \/\/method is static\\n\" +\n-                \"        enum X {\\n\" +\n-                \"            A;\\n\" +\n-                \"            U u;\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\\n\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R {\\n\" +\n-                \"    static <U> U make(U u) { \/\/method is static\\n\" +\n-                \"        record Checker() {\\n\" +\n-                \"            void check(U u);\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                interface I {\n+                    default void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -696,9 +627,30 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R {\\n\" +\n-                \"    <U> U make(U u) { \/\/ enclosing method is not static\\n\" +\n-                \"        interface Checker {\\n\" +\n-                \"            void check(U u);\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -706,20 +658,37 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class LocalEnum {\\n\" +\n-                \"    <U> U getAndSet(U u) { \/\/ enclosing method is not static\\n\" +\n-                \"        enum X {\\n\" +\n-                \"            A;\\n\" +\n-                \"            U u;\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\\n\");\n-\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class R {\\n\" +\n-                \"    <U> U make(U u) { \/\/ enclosing method is not static\\n\" +\n-                \"        record Checker() {\\n\" +\n-                \"            void check(U u);\\n\" +\n-                \"        }\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                static class SC {\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                    \"\"\"\n+                    class C<T> {\n+                        String field = \"field\";\n+                        class Inner {\n+                            #S\n+                        }\n+                    }\n+                    \"\"\".replaceFirst(\"#S\", s));\n+        }\n@@ -727,14 +696,51 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static <T> void main(String[] args) {\\n\" +\n-                \"        interface I {\\n\" +\n-                \"            public default void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        T t = null;\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+        \/\/ another, more complex, example\n+        \/\/ static defs in inner classes can't capture instance locals, fields or type variables\n+        for (String s : List.of(\n+                \"\"\"\n+                record R() {\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2() { System.err.println(field); } }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test() { System.err.println(param); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2() { System.err.println(param); } }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test() { System.err.println(local); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2() { System.err.println(local); } }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -742,14 +748,54 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static <T> void main(String[] args) {\\n\" +\n-                \"        record R(int i) {\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        T t = null;\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                interface I {\n+                    default void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test() { System.err.println(param); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X {\n+                            void test2() { System.err.println(param); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test() { System.err.println(local); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X {\n+                            void test2() { System.err.println(local); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -757,15 +803,62 @@\n-        assertFail(\"compiler.err.non-static.cant.be.ref\",\n-                \"class C {\\n\" +\n-                \"    public static <T> void main(String[] args) {\\n\" +\n-                \"        enum E {\\n\" +\n-                \"            A;\\n\" +\n-                \"            public void test1() {\\n\" +\n-                \"                class X {\\n\" +\n-                \"                    public void test2() {\\n\" +\n-                \"                        T t = null;\\n\" +\n-                \"                    }\\n\" +\n-                \"                }\\n\" +\n-                \"            }\\n\" +\n-                \"        }\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test() { System.err.println(param); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(param); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test() { System.err.println(local); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(local); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -773,9 +866,0 @@\n-        \/\/ but static fields are OK\n-        assertOK(\"class R { \\n\" +\n-                \"    static int z = 0;\\n\" +\n-                \"    void m() { \\n\" +\n-                \"        record RR(int x) { public int x() { return z; }};\\n\" +\n-                \"    }\\n\" +\n-                \"}\");\n-        \/\/ Can't self-shadow\n-        assertFail(\"compiler.err.already.defined\",\n@@ -783,3 +867,10 @@\n-                class R {\n-                    void m() {\n-                        record R(int x) { };\n+                static class SC {\n+                    void test() { System.err.println(field); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(field); }\n+                        }\n@@ -788,0 +879,1 @@\n+                \"\"\",\n@@ -789,3 +881,27 @@\n-        );\n-        \/\/ can't be explicitly static\n-        assertFail(\"compiler.err.illegal.start.of.expr\",\n+                static class SC {\n+                    void test() { System.err.println(param); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(param); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test() { System.err.println(local); }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X {\n+                            void test2() { System.err.println(local); }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n@@ -793,3 +909,8 @@\n-                class R {\n-                    void m() {\n-                        static record RR(int x) { };\n+                static class SC {\n+                    void test(T t) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X { void test2(T t) {} }\n@@ -799,1 +920,15 @@\n-        );\n+        )) {\n+            assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                    \"\"\"\n+                    class C<T> {\n+                        String field = \"field\";\n+                        <U> U m(String param) {\n+                            String local = \"local\";\n+                            class Local {\n+                                class Inner { #S }\n+                            }\n+                            return null;\n+                        }\n+                    }\n+                    \"\"\".replaceFirst(\"#S\", s));\n+        }\n@@ -801,1 +936,1 @@\n-        \/\/ positive cases\n+        \/\/ inner classes can contain static methods too\n@@ -804,11 +939,4 @@\n-                import java.security.*;\n-                class Test {\n-                    static Test newInstance(Object provider) {\n-                        return new Test() {\n-                            private final PrivilegedExceptionAction<KeyStore> action = new PrivilegedExceptionAction<KeyStore>() {\n-                                public KeyStore run() throws Exception {\n-                                    if (provider == null) {}\n-                                    return null;\n-                                }\n-                            };\n-                        };\n+                class C {\n+                    class Inner {\n+                        \/\/ static method inside inner class\n+                        static void m() {}\n@@ -822,17 +950,7 @@\n-                import java.security.*;\n-                class Test {\n-                    static Test newInstance(Object provider) {\n-                        return new Test() {\n-                            int m(PrivilegedExceptionAction<KeyStore> a) { return 0; }\n-                            {\n-                                m(\n-                                    new PrivilegedExceptionAction<KeyStore>() {\n-                                        public KeyStore run() throws Exception {\n-                                            if (provider == null) {}\n-                                            return null;\n-                                        }\n-                                    }\n-                                );\n-                            }\n-                        };\n-                    }\n+                class C {\n+                     void m() {\n+                         new Object() {\n+                            \/\/ static method inside inner class\n+                            static void m() {}\n+                         };\n+                     }\n@@ -872,1 +990,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n@@ -881,1 +999,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n@@ -891,1 +1009,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n@@ -900,1 +1018,1 @@\n-        assertFail(\"compiler.err.static.declaration.not.allowed.in.inner.classes\",\n+        assertOK(\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":450,"deletions":332,"binary":false,"changes":782,"status":"modified"}]}