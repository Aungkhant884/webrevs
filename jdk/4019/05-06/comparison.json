{"files":[{"patch":"@@ -573,16 +573,0 @@\n-    \/**\n-     * Calculate if the given data lengths and the already processed data\n-     * exceeds the maximum allowed processed data by GCM.\n-     * @param lengths lengths of unprocessed data.\n-     *\/\n-    private void checkDataLength(int ... lengths) {\n-        int max = MAX_BUF_SIZE;\n-        for (int len : lengths) {\n-            max = Math.subtractExact(max, len);\n-        }\n-        if (engine.processed > max) {\n-            throw new ProviderException(\"SunJCE provider only supports \" +\n-                \"input size up to \" + MAX_BUF_SIZE + \" bytes\");\n-        }\n-    }\n-\n@@ -592,0 +576,1 @@\n+     * return - number of processed bytes\n@@ -598,1 +583,1 @@\n-     * @param inLen lnput length\n+     * @param inLen input length\n@@ -612,0 +597,2 @@\n+        inLen -= (inLen % PARALLEL_LEN);\n+\n@@ -614,1 +601,1 @@\n-        if (inLen > TRIGGERLEN) {\n+        if (inLen >= TRIGGERLEN) {\n@@ -641,1 +628,0 @@\n-        GCMOperation op;\n@@ -646,3 +632,0 @@\n-        \/\/ length of total data, i.e. len(C)\n-        int processed = 0;\n-\n@@ -661,2 +644,0 @@\n-        byte[] in;\n-        byte[] out;\n@@ -713,1 +694,3 @@\n-         *  ByteBuffer wrapper for intrinsic implGCMCrypt\n+         *  ByteBuffer wrapper for intrinsic implGCMCrypt.  It will operation\n+         *  on 768 byte blocks and let the calling method operate on smaller\n+         *  sizes.\n@@ -715,2 +698,2 @@\n-        int implGCMCrypt(GCMOperation op, ByteBuffer src, ByteBuffer dst) {\n-            int srcLen = src.remaining() - (src.remaining() % blockSize);\n+        int implGCMCrypt(ByteBuffer src, ByteBuffer dst) {\n+            int srcLen = src.remaining() - (src.remaining() % PARALLEL_LEN);\n@@ -718,1 +701,1 @@\n-            if (srcLen < blockSize) {\n+            if (srcLen < PARALLEL_LEN) {\n@@ -722,7 +705,1 @@\n-            int rlen = srcLen;\n-            \/\/ 'in' and 'out' are always set together, just need to check 'in'\n-            if (in == null || (in.length != PARALLEL_LEN\n-                && in.length < srcLen)) {\n-                in = new byte[Math.min(PARALLEL_LEN, srcLen)];\n-                out = new byte[Math.min(PARALLEL_LEN, srcLen)];\n-            }\n+            int len;\n@@ -730,12 +707,10 @@\n-            if (srcLen >= PARALLEL_LEN) {\n-                if (src.hasArray() && dst.hasArray()) {\n-                    ByteBuffer ct = (encryption ? dst : src);\n-                    int len = GaloisCounterMode.implGCMCrypt(src.array(),\n-                        src.arrayOffset() + src.position(), srcLen,\n-                        ct.array(), ct.arrayOffset() + ct.position(),\n-                        dst.array(), dst.arrayOffset() + dst.position(),\n-                        gctr, ghash);\n-                    src.position(src.position() + len);\n-                    dst.position(dst.position() + len);\n-                    rlen -= len;\n-                } else {\n+            if (src.hasArray() && dst.hasArray()) {\n+                ByteBuffer ct = (encryption ? dst : src);\n+                len = GaloisCounterMode.implGCMCrypt(src.array(),\n+                    src.arrayOffset() + src.position(), srcLen,\n+                    ct.array(), ct.arrayOffset() + ct.position(),\n+                    dst.array(), dst.arrayOffset() + dst.position(),\n+                    gctr, ghash);\n+                src.position(src.position() + len);\n+                dst.position(dst.position() + len);\n+                return len;\n@@ -743,9 +718,1 @@\n-                    byte[] ct = (encryption ? out : in);\n-                    do {\n-                        src.get(in, 0, PARALLEL_LEN);\n-                        rlen -= GaloisCounterMode.implGCMCrypt(in, 0,\n-                            PARALLEL_LEN, ct, 0, out, 0, gctr, ghash);\n-                        dst.put(out, 0, PARALLEL_LEN);\n-                    } while (rlen >= PARALLEL_LEN);\n-                }\n-            }\n+            } else {\n@@ -753,3 +720,12 @@\n-            if (rlen >= blockSize) {\n-                src.get(in, 0, rlen);\n-                rlen = op.update(in, 0, rlen, out, 0);\n+                byte[] bin = new byte[PARALLEL_LEN];\n+                byte[] bout = new byte[PARALLEL_LEN];\n+                byte[] ct = (encryption ? bout : bin);\n+                len = srcLen;\n+                do {\n+                    src.get(bin, 0, PARALLEL_LEN);\n+                    len -= GaloisCounterMode.implGCMCrypt(bin, 0, PARALLEL_LEN,\n+                        ct, 0, bout, 0, gctr, ghash);\n+                    dst.put(bout, 0, PARALLEL_LEN);\n+                } while (len >= PARALLEL_LEN);\n+\n+                return srcLen - len;\n@@ -757,4 +733,0 @@\n-\n-            dst.put(out, 0, rlen);\n-            processed += srcLen;\n-            return srcLen;\n@@ -810,2 +782,0 @@\n-         * @throws UnsupportedOperationException if this method\n-         * has not been overridden by an implementation\n@@ -859,1 +829,2 @@\n-            int resultLen = 0;\n+            int len = 0;\n+            int resultLen;\n@@ -863,1 +834,7 @@\n-                \/\/ en\/decrypt on how much buffer there is in AES_BLOCK_SIZE\n+                \/\/ en\/decrypt any PARALLEL_LEN sized data in the buffer\n+                if (bLen >= PARALLEL_LEN) {\n+                    len = implGCMCrypt(buffer, dst);\n+                    bLen -= len;\n+                }\n+\n+                \/\/ en\/decrypt any blocksize data in the buffer\n@@ -865,1 +842,3 @@\n-                    resultLen += implGCMCrypt(op, buffer, dst);\n+                    resultLen = op.update(buffer, dst);\n+                    bLen -= resultLen;\n+                    len += resultLen;\n@@ -869,1 +848,1 @@\n-                if (bLen - resultLen > 0) {\n+                if (bLen > 0) {\n@@ -880,3 +859,3 @@\n-                    int len = slen + over;\n-                    if (len == blockSize) {\n-                        resultLen += op.update(block, 0, blockSize, dst);\n+                    int l = slen + over;\n+                    if (l == blockSize) {\n+                        len += op.update(block, 0, blockSize, dst);\n@@ -884,2 +863,1 @@\n-                        resultLen += op.doFinal(block, 0, len, block,\n-                                0);\n+                        len += op.doFinal(block, 0, l, block,0);\n@@ -887,1 +865,1 @@\n-                            dst.put(block, 0, len);\n+                            dst.put(block, 0, l);\n@@ -889,2 +867,1 @@\n-                        processed += resultLen;\n-                        return resultLen;\n+                        return len;\n@@ -897,2 +874,2 @@\n-            if (src.remaining() > TRIGGERLEN) {\n-                resultLen += implGCMCrypt(op, src, dst);\n+            if (src.remaining() >= PARALLEL_LEN) {\n+                len += implGCMCrypt(src, dst);\n@@ -901,3 +878,1 @@\n-            resultLen += op.doFinal(src, dst);\n-            processed += resultLen;\n-            return resultLen;\n+            return len + op.doFinal(src, dst);\n@@ -989,1 +964,1 @@\n-         * during in-place crypto, so to not overwrite the input if the authtag\n+         * during in-place crypto, so to not overwrite the input if the auth tag\n@@ -1037,0 +1012,5 @@\n+        GCMOperation op;\n+\n+        \/\/ data processed during encryption\n+        int processed = 0;\n+\n@@ -1043,0 +1023,16 @@\n+        \/**\n+         * Calculate if the given data lengths and the already processed data\n+         * exceeds the maximum allowed processed data by GCM.\n+         * @param lengths lengths of unprocessed data.\n+         *\/\n+        private void checkDataLength(int ... lengths) {\n+            int max = MAX_BUF_SIZE;\n+            for (int len : lengths) {\n+                max = Math.subtractExact(max, len);\n+                if (processed > max) {\n+                    throw new ProviderException(\"SunJCE provider only \" +\n+                        \"supports input size up to \" + MAX_BUF_SIZE + \" bytes\");\n+                }\n+            }\n+        }\n+\n@@ -1169,2 +1165,1 @@\n-                            dst);\n-                    processed += len;\n+                        dst);\n@@ -1175,3 +1170,14 @@\n-            \/\/ encrypt any blocksized data in 'src'\n-            if (src.remaining() >= blockSize) {\n-                len += implGCMCrypt(op, src, dst);\n+            int srcLen = src.remaining();\n+            int resultLen;\n+            \/\/ encrypt any PARALLEL_LEN sized data in 'src'\n+            if (srcLen >= PARALLEL_LEN) {\n+                resultLen = implGCMCrypt(src, dst);\n+                srcLen -= resultLen;\n+                len += resultLen;\n+            }\n+\n+            \/\/ encrypt any blocksize data in 'src'\n+            if (srcLen >= blockSize) {\n+                resultLen = op.update(src, dst);\n+                srcLen -= resultLen;\n+                len += resultLen;\n@@ -1181,3 +1187,3 @@\n-            if (src.remaining() > 0) {\n-                initBuffer(src.remaining());\n-                byte[] b = new byte[src.remaining()];\n+            if (srcLen > 0) {\n+                initBuffer(srcLen);\n+                byte[] b = new byte[srcLen];\n@@ -1194,0 +1200,1 @@\n+            processed += len;\n@@ -1207,1 +1214,1 @@\n-            } catch (ArrayIndexOutOfBoundsException aiobe) {\n+            } catch (ArrayIndexOutOfBoundsException e) {\n@@ -1216,1 +1223,1 @@\n-            int resultLen = 0;\n+            int len = 0;\n@@ -1225,1 +1232,1 @@\n-                    int r, bufOfs = 0;\n+                    int r;\n@@ -1227,1 +1234,1 @@\n-                    r = mergeBlock(buffer, bufOfs, in, inOfs, inLen, block);\n+                    r = mergeBlock(buffer, 0, in, inOfs, inLen, block);\n@@ -1230,4 +1237,3 @@\n-                    r = op.update(block, 0, blockSize, out, outOfs);\n-                    outOfs += r;\n-                    resultLen += r;\n-                    processed += r;\n+                    op.update(block, 0, blockSize, out, outOfs);\n+                    outOfs += blockSize;\n+                    len += blockSize;\n@@ -1246,1 +1252,1 @@\n-            processed += op.doFinal(in, inOfs, inLen, out, outOfs);\n+            len += op.doFinal(in, inOfs, inLen, out, outOfs);\n@@ -1248,1 +1254,0 @@\n-            resultLen += inLen;\n@@ -1250,1 +1255,1 @@\n-            block = getLengthBlock(sizeOfAAD, processed);\n+            block = getLengthBlock(sizeOfAAD, processed + len);\n@@ -1258,1 +1263,1 @@\n-            int len = resultLen + tagLenBytes;\n+            len += tagLenBytes;\n@@ -1320,0 +1325,16 @@\n+        \/**\n+         * Calculate if the given data lengths exceeds the maximum allowed\n+         * processed data by GCM.\n+         * @param lengths lengths of unprocessed data.\n+         *\/\n+        private void checkDataLength(int ... lengths) {\n+            int max = MAX_BUF_SIZE;\n+            for (int len : lengths) {\n+                max = Math.subtractExact(max, len);\n+                if (max < 0) {\n+                    throw new ProviderException(\"SunJCE provider only \" +\n+                        \"supports input size up to \" + MAX_BUF_SIZE + \" bytes\");\n+                }\n+            }\n+        }\n+\n@@ -1369,3 +1390,2 @@\n-                \/\/ store internally until decryptFinal is called because\n-                \/\/ spec mentioned that only return recovered data after tag\n-                \/\/ is successfully verified\n+                \/\/ store internally until doFinal.  Per the spec, data is\n+                \/\/ returned after tag is successfully verified.\n@@ -1419,1 +1439,1 @@\n-            } catch (ArrayIndexOutOfBoundsException aiobe) {\n+            } catch (ArrayIndexOutOfBoundsException e) {\n@@ -1437,1 +1457,2 @@\n-            len = decryptBlocks(new DecryptOp(gctr, ghash), in, inOfs, inLen, out, outOfs);\n+            len = decryptBlocks(new DecryptOp(gctr, ghash), in, inOfs, inLen,\n+                out, outOfs);\n@@ -1484,3 +1505,1 @@\n-            \/\/ Save GHASH context to allow the tag to be checked even though\n-            \/\/ the dst buffer is too short.  Context will be restored so the\n-            \/\/ method can be called again with the proper sized dst buffer.\n+            \/\/ Verify dst is large enough\n@@ -1515,3 +1534,0 @@\n-            \/\/ Set the mark for a later reset. Either it will be zero, or the\n-            \/\/ tag buffer creation above will have consume some or all of it.\n-            ct.mark();\n@@ -1521,3 +1537,1 @@\n-            \/\/ Perform GHASH check on data\n-            processed +=\n-                doLastBlock(new DecryptOp(gctr, ghash), buffer, ct, dst);\n+            len = doLastBlock(new DecryptOp(gctr, ghash), buffer, ct, dst);\n@@ -1542,1 +1556,1 @@\n-                    Arrays.fill(dst.array(), ofs , ofs + processed, (byte)0);\n+                    Arrays.fill(dst.array(), ofs , ofs + len, (byte)0);\n@@ -1545,1 +1559,1 @@\n-                        processed + dst.position(), (byte)0);\n+                        len + dst.position(), (byte)0);\n@@ -1553,1 +1567,1 @@\n-            return processed;\n+            return len;\n@@ -1624,5 +1638,9 @@\n-            resultLen = GaloisCounterMode.implGCMCrypt(in, inOfs, inLen, in,\n-                inOfs, out, outOfs, gctr, ghash);\n-            inOfs += resultLen;\n-            outOfs += resultLen;\n-            inLen -= resultLen;\n+            if (inLen >= PARALLEL_LEN) {\n+                resultLen = GaloisCounterMode.implGCMCrypt(in, inOfs, inLen, in,\n+                    inOfs, out, outOfs, gctr, ghash);\n+                inOfs += resultLen;\n+                inLen -= resultLen;\n+                outOfs += resultLen;\n+                len += resultLen;\n+            }\n+\n@@ -1630,2 +1648,1 @@\n-            return len + resultLen +\n-                    gctr.doFinal(in, inOfs, inLen, out, outOfs);\n+            return len + gctr.doFinal(in, inOfs, inLen, out, outOfs);\n@@ -1701,7 +1718,10 @@\n-            int len = implGCMCrypt(in, inOfs, inLen, out, outOfs, out, outOfs,\n-                    gctr, ghash);\n-            inLen -= len;\n-            outOfs += len;\n-            int flen = gctr.doFinal(in, inOfs + len, inLen, out, outOfs);\n-            ghash.doFinal(out, outOfs, inLen);\n-            return len + flen;\n+            int len = 0;\n+\n+            if (inLen >= PARALLEL_LEN) {\n+                len = implGCMCrypt(in, inOfs, inLen, out, outOfs, out, outOfs, gctr, ghash);\n+                inLen -= len;\n+                outOfs += len;\n+            }\n+\n+            gctr.doFinal(in, inOfs + len, inLen, out, outOfs);\n+            return len + ghash.doFinal(out, outOfs, inLen);\n@@ -1757,2 +1777,5 @@\n-            int len = implGCMCrypt(in, inOfs, inLen, in, inOfs, out, outOfs,\n-                    gctr, ghash);\n+            int len = 0;\n+            if (inLen >= PARALLEL_LEN) {\n+                implGCMCrypt(in, inOfs, inLen, in, inOfs, out, outOfs, gctr,\n+                    ghash);\n+            }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":159,"deletions":136,"binary":false,"changes":295,"status":"modified"}]}