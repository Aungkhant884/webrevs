{"files":[{"patch":"@@ -7639,6 +7639,0 @@\n-      } else {\n-        StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt_Parallel();\n-      }\n-    }\n-    if (UseAESIntrinsics) {\n-      if (VM_Version::supports_avx512_vaes() &&  VM_Version::supports_avx512vl() && VM_Version::supports_avx512dq()) {\n@@ -7649,0 +7643,2 @@\n+      } else {\n+        StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt_Parallel();\n@@ -7651,0 +7647,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-  code_size1 = 20000 LP64_ONLY(+12000),         \/\/ simply increase if too small (assembler will crash if too small)\n-  code_size2 = 35300 LP64_ONLY(+37000)          \/\/ simply increase if too small (assembler will crash if too small)\n+  code_size1 = 20000 LP64_ONLY(+10000),         \/\/ simply increase if too small (assembler will crash if too small)\n+  code_size2 = 35300 LP64_ONLY(+32000)          \/\/ simply increase if too small (assembler will crash if too small)\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+  static_field(StubRoutines,                _galoisCounterMode_AESCrypt,                      address)                               \\\n@@ -333,1 +334,0 @@\n-  static_field(StubRoutines,                _galoisCounterMode_AESCrypt,                      address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1090,0 +1090,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"galoisCounterMode_AESCrypt\") == 0 ||\n@@ -1111,1 +1112,0 @@\n-                  strcmp(call->as_CallLeaf()->_name, \"galoisCounterMode_AESCrypt\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+address StubRoutines::_galoisCounterMode_AESCrypt          = NULL;\n@@ -130,1 +131,0 @@\n-address StubRoutines::_galoisCounterMode_AESCrypt          = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+  static address _galoisCounterMode_AESCrypt;\n@@ -212,1 +213,0 @@\n-  static address _galoisCounterMode_AESCrypt;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,3 @@\n-        subkeyHtbl = new long[2*57]; \/\/ 48 keys for the interleaved implementation, 8 for avx-ghash implementation and one for the original key\n+         \/\/ 48 keys for the interleaved implementation,\n+         \/\/ 8 for avx-ghash implementation and 1 for the original key\n+        subkeyHtbl = new long[2*57];\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+\n@@ -170,1 +171,7 @@\n-        blockCipher.init(false, key.getAlgorithm(), keyValue);\n+        try {\n+            blockCipher.init(false, key.getAlgorithm(), keyValue);\n+        } finally {\n+            if (!encryption) {\n+                Arrays.fill(keyValue, (byte) 0);\n+            }\n+        }\n@@ -472,1 +479,1 @@\n-                Arrays.fill(encodedKey, (byte)0);\n+                Arrays.fill(encodedKey, (byte) 0);\n@@ -585,1 +592,0 @@\n-     * return - number of processed bytes\n@@ -587,1 +593,3 @@\n-     * Requires 768 bytes (48 AES blocks) to efficiently use the intrinsic\n+     * Requires 768 bytes (48 AES blocks) to efficiently use the intrinsic.\n+     * inLen that is less than 768 size block sizes, before or after this\n+     * intrinsic is used, will be done by the calling method\n@@ -590,0 +598,1 @@\n+     * @param inLen lnput length\n@@ -594,1 +603,1 @@\n-     * @param gctr object for the CTR operation\n+     * @param gctr object for the GCTR operation\n@@ -596,0 +605,1 @@\n+     * @return number of processed bytes\n@@ -603,0 +613,1 @@\n+        int cOfs = ctOfs;\n@@ -609,3 +620,3 @@\n-                        outOfs + len);\n-                ghash.update(ct, ctOfs, segments);\n-                ctOfs = len;\n+                    outOfs + len);\n+                ghash.update(ct, cOfs, segments);\n+                cOfs = ctOfs + len;\n@@ -616,0 +627,1 @@\n+\n@@ -617,1 +629,1 @@\n-        ghash.update(ct, ctOfs, inLen);\n+        ghash.update(ct, cOfs, inLen);\n@@ -705,2 +717,0 @@\n-            int rlen = srcLen;\n-\n@@ -712,0 +722,1 @@\n+            int rlen = srcLen;\n@@ -719,9 +730,1 @@\n-            byte[] ct;\n-            if (encryption) {\n-                ct = out;\n-            } else {\n-                ct = in;\n-            }\n-\n-            if (srcLen > PARALLEL_LEN) {\n-\n+            if (srcLen >= PARALLEL_LEN) {\n@@ -729,17 +732,9 @@\n-                    int l = rlen;\n-\n-                    if (encryption) {\n-                        rlen -= GaloisCounterMode.implGCMCrypt(src.array(),\n-                            src.arrayOffset() + src.position(), src.remaining(),\n-                            dst.array(), dst.arrayOffset() + dst.position(),\n-                            dst.array(), dst.arrayOffset() + dst.position(),\n-                            gctr, ghash);\n-                    } else {\n-                        rlen -= GaloisCounterMode.implGCMCrypt(src.array(),\n-                            src.arrayOffset() + src.position(), src.remaining(),\n-                            src.array(), src.arrayOffset() + src.position(),\n-                            dst.array(), dst.arrayOffset() + dst.position(),\n-                            gctr, ghash);\n-                    }\n-                    src.position(src.position() + srcLen);\n-                    dst.position(dst.position() + srcLen);\n+                    ByteBuffer ct = (encryption ? dst : src);\n+                    int len = GaloisCounterMode.implGCMCrypt(src.array(),\n+                        src.arrayOffset() + src.position(), srcLen,\n+                        ct.array(), ct.arrayOffset() + ct.position(),\n+                        dst.array(), dst.arrayOffset() + dst.position(),\n+                        gctr, ghash);\n+                    src.position(src.position() + len);\n+                    dst.position(dst.position() + len);\n+                    rlen -= len;\n@@ -748,0 +743,1 @@\n+                    byte[] ct = (encryption ? out : in);\n@@ -753,1 +749,1 @@\n-                    } while (rlen > PARALLEL_LEN);\n+                    } while (rlen >= PARALLEL_LEN);\n@@ -756,0 +752,1 @@\n+\n@@ -964,1 +961,5 @@\n-                    if (src.position() + src.arrayOffset() >=\n+                    \/\/ If during encryption and the input offset is behind or\n+                    \/\/ the same as the output offset, the same buffer can be\n+                    \/\/ used.  But during decryption always create a new\n+                    \/\/ buffer in case of a bad auth tag.\n+                    if (encryption && src.position() + src.arrayOffset() >=\n@@ -987,1 +988,4 @@\n-         * Overlap detection for data using byte array.\n+         * This is used for both overlap detection for the data or  decryption\n+         * during in-place crypto, so to not overwrite the input if the authtag\n+         * is invalid.\n+         *\n@@ -1590,4 +1594,4 @@\n-                    int r = op.update(buffer, len, bufRemainder, out, outOfs);\n-                    len += r;\n-                    outOfs += r;\n-                    bufRemainder -= r;\n+                    resultLen = op.update(buffer, len, bufRemainder, out, outOfs);\n+                    len += resultLen;\n+                    outOfs += resultLen;\n+                    bufRemainder -= resultLen;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":48,"deletions":44,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -101,0 +101,21 @@\n+ * @run main\/othervm\/timeout=600 -Xbatch -DcheckOutput=true -Dmode=GCM -DmsgSize=2054\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      compiler.codegen.aes.TestAESMain\n+ * @run main\/othervm\/timeout=600 -Xbatch -DcheckOutput=true -Dmode=GCM -DencInputOffset=1 -DmsgSize=2054\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      compiler.codegen.aes.TestAESMain\n+ * @run main\/othervm\/timeout=600 -Xbatch -DcheckOutput=true -Dmode=GCM -DencOutputOffset=1 -DmsgSize=2054\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      compiler.codegen.aes.TestAESMain\n+ * @run main\/othervm\/timeout=600 -Xbatch -DcheckOutput=true -Dmode=GCM -DdecOutputOffset=1 -DmsgSize=2054\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      compiler.codegen.aes.TestAESMain\n+ * @run main\/othervm\/timeout=600 -Xbatch -DcheckOutput=true -Dmode=GCM -DencInputOffset=1 -DencOutputOffset=1 -DmsgSize=2054\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      compiler.codegen.aes.TestAESMain\n+ * @run main\/othervm\/timeout=600 -Xbatch -DcheckOutput=true -Dmode=GCM -DencInputOffset=1 -DencOutputOffset=1 -DdecOutputOffset=1 -DmsgSize=2054\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      compiler.codegen.aes.TestAESMain\n+ * @run main\/othervm\/timeout=600 -Xbatch -DcheckOutput=true -Dmode=GCM -DencInputOffset=1 -DencOutputOffset=1 -DdecOutputOffset=1 -DpaddingStr=NoPadding -DmsgSize=2048\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      compiler.codegen.aes.TestAESMain\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/TestAESMain.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}