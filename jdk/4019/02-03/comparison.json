{"files":[{"patch":"@@ -960,1 +960,1 @@\n-                      Register processInChunks, Register state, Register subkeyHtbl, Register counter);\n+                      Register state, Register subkeyHtbl, Register counter);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1631,1 +1631,1 @@\n-                                    Register processInChunks, Register state, Register subkeyHtbl, Register counter) {\n+                                    Register state, Register subkeyHtbl, Register counter) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_aes.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4397,3 +4397,1 @@\n-  \/\/ processInChunks = r11   |  c_rarg5 (r9)\n-  \/\/ isEncrypt = r12         |  r10\n-  \/\/ state = r13             |  r13\n+  \/\/ state = r13             |  c_rarg5 (r9)\n@@ -4414,4 +4412,2 @@\n-    const Register processInChunks = c_rarg5;\n-    const Address state_mem(rbp, 2 * wordSize);\n-    const Register state = r13;\n-    const Address subkeyH_mem(rbp, 3 * wordSize);\n+    const Register state = c_rarg5;\n+    const Address subkeyH_mem(rbp, 2 * wordSize);\n@@ -4419,1 +4415,1 @@\n-    const Address counter_mem(rbp, 4 * wordSize);\n+    const Address counter_mem(rbp, 3 * wordSize);\n@@ -4424,3 +4420,1 @@\n-    const Register processInChunks = r11;\n-    const Address partial_mem(rbp, 7 * wordSize);\n-    const Address state_mem(rbp, 8 * wordSize);\n+    const Address state_mem(rbp, 7 * wordSize);\n@@ -4428,1 +4422,1 @@\n-    const Address subkeyH_mem(rbp, 9 * wordSize);\n+    const Address subkeyH_mem(rbp, 8 * wordSize);\n@@ -4430,1 +4424,1 @@\n-    const Address counter_mem(rbp, 10 * wordSize);\n+    const Address counter_mem(rbp, 9 * wordSize);\n@@ -4444,5 +4438,0 @@\n-    __ movl(processInChunks, partial_mem);\n-    __ movptr(state, state_mem);\n-    __ movptr(subkeyHtbl, subkeyH_mem);\n-    __ movptr(counter, counter_mem);\n-#else\n@@ -4450,0 +4439,1 @@\n+#endif\n@@ -4452,2 +4442,2 @@\n-#endif\n-    __ aesgcm_encrypt(in, len, ct, out, key, processInChunks, state, subkeyHtbl, counter);\n+\n+    __ aesgcm_encrypt(in, len, ct, out, key, state, subkeyHtbl, counter);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":10,"deletions":20,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -419,1 +419,1 @@\n-   do_intrinsic(_galoisCounterMode_AESCrypt, com_sun_crypto_provider_galoisCounterMode, gcm_crypt_name, aes_gcm_signature, F_R)   \\\n+   do_intrinsic(_galoisCounterMode_AESCrypt, com_sun_crypto_provider_galoisCounterMode, gcm_crypt_name, aes_gcm_signature, F_S)   \\\n@@ -421,1 +421,1 @@\n-   do_signature(aes_gcm_signature, \"([BII[BI[BIZLcom\/sun\/crypto\/provider\/GCTR;Lcom\/sun\/crypto\/provider\/GHASH;)I\")                                                             \\\n+   do_signature(aes_gcm_signature, \"([BII[BI[BILcom\/sun\/crypto\/provider\/GCTR;Lcom\/sun\/crypto\/provider\/GHASH;)I\")                                                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2491,2 +2491,1 @@\n-                                  Node* parm6, Node* parm7,\n-                                  Node* parm8) {\n+                                  Node* parm6, Node* parm7) {\n@@ -2539,2 +2538,1 @@\n-  if (parm8 != NULL) { call->init_req(TypeFunc::Parms+8, parm8);\n-    \/* close each nested if ===> *\/  } } } } } } } } }\n+  \/* close each nested if ===> *\/  } } } } } } } }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -805,2 +805,1 @@\n-                          Node* parm6 = NULL, Node* parm7 = NULL,\n-                          Node* parm8 = NULL);\n+                          Node* parm6 = NULL, Node* parm7 = NULL);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -551,1 +551,1 @@\n-    return inline_galoisCounterMode_AESCrypt(intrinsic_id());\n+    return inline_galoisCounterMode_AESCrypt();\n@@ -6688,1 +6688,1 @@\n-bool LibraryCallKit::inline_galoisCounterMode_AESCrypt(vmIntrinsics::ID id) {\n+bool LibraryCallKit::inline_galoisCounterMode_AESCrypt() {\n@@ -6692,4 +6692,3 @@\n-  if (id == vmIntrinsics::_galoisCounterMode_AESCrypt) {\n-    stubAddr = StubRoutines::galoisCounterMode_AESCrypt();\n-    stubName = \"galoisCounterMode_AESCrypt\";\n-  }\n+  stubAddr = StubRoutines::galoisCounterMode_AESCrypt();\n+  stubName = \"galoisCounterMode_AESCrypt\";\n+\n@@ -6698,11 +6697,9 @@\n-  Node* galoisCounterMode_object = argument(0);\n-  Node* in      = argument(1);\n-  Node* inOfs   = argument(2);\n-  Node* len     = argument(3);\n-  Node* ct      = argument(4);\n-  Node* ctOfs   = argument(5);\n-  Node* out     = argument(6);\n-  Node* outOfs  = argument(7);\n-  Node* processInChunks = argument(8);\n-  Node* gctr_object = argument(9);\n-  Node* ghash_object = argument(10);\n+  Node* in      = argument(0);\n+  Node* inOfs   = argument(1);\n+  Node* len     = argument(2);\n+  Node* ct      = argument(3);\n+  Node* ctOfs   = argument(4);\n+  Node* out     = argument(5);\n+  Node* outOfs  = argument(6);\n+  Node* gctr_object = argument(7);\n+  Node* ghash_object = argument(8);\n@@ -6736,1 +6733,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(galoisCounterMode_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n+  Node* embeddedCipherObj = load_field_from_object(gctr_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6740,1 +6737,4 @@\n-  if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) return false;\n+\n+  if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n+      return false;\n+  }\n@@ -6742,3 +6742,3 @@\n-  const TypeInstPtr* tinst = _gvn.type(galoisCounterMode_object)->isa_instptr();\n-  assert(tinst != NULL, \"GCM obj is null\");\n-  assert(tinst->klass()->is_loaded(), \"GCM obj is not loaded\");\n+  const TypeInstPtr* tinst = _gvn.type(gctr_object)->isa_instptr();\n+  assert(tinst != NULL, \"GCTR obj is null\");\n+  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n@@ -6765,1 +6765,1 @@\n-                               in_start, len, ct_start, out_start, k_start, processInChunks, state_start, subkeyHtbl_start, cnt_start);\n+                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, cnt_start);\n@@ -6785,3 +6785,3 @@\n-  Node* objGCM = argument(0);\n-  \/\/ Load embeddedCipher field of CipherBlockChaining object.\n-  Node* embeddedCipherObj = load_field_from_object(objGCM, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n+  Node* objGCTR = argument(7);\n+  \/\/ Load embeddedCipher field of GCTR object.\n+  Node* embeddedCipherObj = load_field_from_object(objGCTR, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6793,3 +6793,3 @@\n-  const TypeInstPtr* tinst = _gvn.type(objGCM)->isa_instptr();\n-  assert(tinst != NULL, \"GCMobj is null\");\n-  assert(tinst->klass()->is_loaded(), \"GCMobj is not loaded\");\n+  const TypeInstPtr* tinst = _gvn.type(objGCTR)->isa_instptr();\n+  assert(tinst != NULL, \"GCTR obj is null\");\n+  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-  bool inline_galoisCounterMode_AESCrypt(vmIntrinsics::ID id);\n+  bool inline_galoisCounterMode_AESCrypt();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -961,1 +961,1 @@\n-  int num_args = 9;\n+  int num_args = 8;\n@@ -970,4 +970,3 @@\n-  fields[argp++] = TypeInt::BOOL;    \/\/ bool processInChunks\n-  fields[argp++] = TypePtr::NOTNULL; \/\/ long[] state\n-  fields[argp++] = TypePtr::NOTNULL; \/\/ long[] subkeyHtbl\n-  fields[argp++] = TypePtr::NOTNULL; \/\/ byte[] counter\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ long[] state from GHASH obj\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ long[] subkeyHtbl from GHASH obj\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ byte[] counter from GCTR obj\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-    \/\/ hashtable subkeyHtbl holds 2*9 powers of subkeyH computed using\n+    \/\/ hashtable subkeyHtbl holds 2*57 powers of subkeyH computed using\n@@ -146,1 +146,1 @@\n-        subkeyHtbl = new long[2*9];\n+        subkeyHtbl = new long[2*57]; \/\/ 48 keys for the interleaved implementation, 8 for avx-ghash implementation and one for the original key\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -53,4 +54,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n-\n-import static com.sun.crypto.provider.AESConstants.AES_BLOCK_SIZE;\n-\n@@ -89,1 +86,3 @@\n-    private static final int TRIGGERLEN = 768;  \/\/ Interleaved implementation can deal with 768 bytes or higher lengths.\n+    private static final int TRIGGERLEN = 65536;  \/\/ 64k\n+    \/\/ x86-64 parallel intrinsic data size\n+    private static final int PARALLEL_LEN = 768;\n@@ -171,7 +170,1 @@\n-        try {\n-            blockCipher.init(false, key.getAlgorithm(), keyValue);\n-        } finally {\n-            if (!encryption) {\n-                Arrays.fill(keyValue, (byte) 0);\n-            }\n-        }\n+        blockCipher.init(false, key.getAlgorithm(), keyValue);\n@@ -479,1 +472,1 @@\n-                Arrays.fill(encodedKey, (byte) 0);\n+                Arrays.fill(encodedKey, (byte)0);\n@@ -589,0 +582,40 @@\n+    \/**\n+     * Intrinsic for Vector AES Galois Counter Mode implementation.\n+     * AES and GHASH operations are interleaved in the intrinsic implementation.\n+     * return - number of processed bytes\n+     *\n+     * Requires 768 bytes (48 AES blocks) to efficiently use the intrinsic\n+     * @param in input buffer\n+     * @param inOfs input offset\n+     * @param ct buffer that ghash will read (in for encrypt, out for decrypt)\n+     * @param ctOfs offset for ct buffer\n+     * @param out output buffer\n+     * @param outOfs output offset\n+     * @param gctr object for the CTR operation\n+     * @param ghash object for the ghash operation\n+     *\/\n+    @IntrinsicCandidate\n+    private static int implGCMCrypt(byte[] in, int inOfs, int inLen,\n+        byte[] ct, int ctOfs, byte[] out, int outOfs,\n+        GCTR gctr, GHASH ghash) {\n+\n+        int len = 0;\n+        if (inLen > TRIGGERLEN) {\n+            int i = 0;\n+            int segments = (inLen \/ 6);\n+            segments -= segments % gctr.blockSize;\n+            do {\n+                len += gctr.update(in, inOfs + len, segments, out,\n+                        outOfs + len);\n+                ghash.update(ct, ctOfs, segments);\n+                ctOfs = len;\n+            } while (++i < 5);\n+\n+            inLen -= len;\n+        }\n+        len += gctr.update(in, inOfs + len, inLen, out, outOfs + len);\n+        ghash.update(ct, ctOfs, inLen);\n+        return len;\n+    }\n+\n+\n@@ -594,2 +627,3 @@\n-        GCTR gctrPAndC;\n-        GHASH ghashAllToS;\n+        GCTR gctr;\n+        GHASH ghash;\n+        GCMOperation op;\n@@ -615,1 +649,2 @@\n-\n+        byte[] in;\n+        byte[] out;\n@@ -624,2 +659,2 @@\n-            gctrPAndC = new GCTR(blockCipher, j0Plus1);\n-            ghashAllToS = new GHASH(subkeyH);\n+            gctr = new GCTR(blockCipher, j0Plus1);\n+            ghash = new GHASH(subkeyH);\n@@ -639,3 +674,3 @@\n-        abstract byte[] doUpdate(byte[] in, int inOff, int inLen);\n-        abstract int doUpdate(byte[] in, int inOff, int inLen, byte[] out,\n-            int outOff) throws ShortBufferException;\n+        abstract byte[] doUpdate(byte[] in, int inOfs, int inLen);\n+        abstract int doUpdate(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws ShortBufferException;\n@@ -646,2 +681,2 @@\n-        abstract int doFinal(byte[] in, int inOff, int inLen, byte[] out,\n-            int outOff) throws IllegalBlockSizeException, AEADBadTagException,\n+        abstract int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws IllegalBlockSizeException, AEADBadTagException,\n@@ -665,0 +700,66 @@\n+        \/**\n+         *  ByteBuffer wrapper for intrinsic implGCMCrypt\n+         *\/\n+        int implGCMCrypt(GCMOperation op, ByteBuffer src, ByteBuffer dst) {\n+            int srcLen = src.remaining() - (src.remaining() % blockSize);\n+            int rlen = srcLen;\n+\n+\n+            if (srcLen < blockSize) {\n+                return 0;\n+            }\n+\n+            \/\/ 'in' and 'out' are always set together, just need to check 'in'\n+            if (in == null || (in.length != PARALLEL_LEN\n+                && in.length < srcLen)) {\n+                in = new byte[Math.min(PARALLEL_LEN, srcLen)];\n+                out = new byte[Math.min(PARALLEL_LEN, srcLen)];\n+            }\n+\n+            byte[] ct;\n+            if (encryption) {\n+                ct = out;\n+            } else {\n+                ct = in;\n+            }\n+\n+            if (srcLen > PARALLEL_LEN) {\n+\n+                if (src.hasArray() && dst.hasArray()) {\n+                    int l = rlen;\n+\n+                    if (encryption) {\n+                        rlen -= GaloisCounterMode.implGCMCrypt(src.array(),\n+                            src.arrayOffset() + src.position(), src.remaining(),\n+                            dst.array(), dst.arrayOffset() + dst.position(),\n+                            dst.array(), dst.arrayOffset() + dst.position(),\n+                            gctr, ghash);\n+                    } else {\n+                        rlen -= GaloisCounterMode.implGCMCrypt(src.array(),\n+                            src.arrayOffset() + src.position(), src.remaining(),\n+                            src.array(), src.arrayOffset() + src.position(),\n+                            dst.array(), dst.arrayOffset() + dst.position(),\n+                            gctr, ghash);\n+                    }\n+                    src.position(src.position() + srcLen);\n+                    dst.position(dst.position() + srcLen);\n+                } else {\n+\n+                    do {\n+                        src.get(in, 0, PARALLEL_LEN);\n+                        rlen -= GaloisCounterMode.implGCMCrypt(in, 0,\n+                            PARALLEL_LEN, ct, 0, out, 0, gctr, ghash);\n+                        dst.put(out, 0, PARALLEL_LEN);\n+                    } while (rlen > PARALLEL_LEN);\n+                }\n+            }\n+            if (rlen >= blockSize) {\n+                src.get(in, 0, rlen);\n+                rlen = op.update(in, 0, rlen, out, 0);\n+            }\n+\n+            dst.put(out, 0, rlen);\n+            processed += srcLen;\n+            return srcLen;\n+        }\n+\n@@ -741,1 +842,1 @@\n-                        ghashAllToS.update(aad, 0, aad.length - lastLen);\n+                        ghash.update(aad, 0, aad.length - lastLen);\n@@ -744,1 +845,1 @@\n-                        ghashAllToS.update(padded);\n+                        ghash.update(padded);\n@@ -746,1 +847,1 @@\n-                        ghashAllToS.update(aad);\n+                        ghash.update(aad);\n@@ -759,1 +860,2 @@\n-        int doLastBlock(GCM op, ByteBuffer buffer, ByteBuffer src, ByteBuffer dst) {\n+        int doLastBlock(GCMOperation op, ByteBuffer buffer, ByteBuffer src,\n+                        ByteBuffer dst) {\n@@ -766,1 +868,1 @@\n-                    resultLen += op.update(buffer, dst);\n+                    resultLen += implGCMCrypt(op, buffer, dst);\n@@ -799,1 +901,1 @@\n-                resultLen += throttleData(op, src, dst);\n+                resultLen += implGCMCrypt(op, src, dst);\n@@ -807,46 +909,0 @@\n-\n-        \/**\n-         * This segments large data into smaller chunks so hotspot will start\n-         * using GCTR and GHASH intrinsics sooner.  This is a problem for app\n-         * and perf tests that only use large input sizes.\n-         *\/\n-        int throttleData(GCM op, byte[] in, int inOfs, int inLen,\n-            byte[] out, int outOfs) {\n-\n-            int segments = (inLen \/ 6);\n-            segments -= segments % blockSize;\n-            int len = 0;\n-            int i = 0;\n-            do {\n-                len += op.update(in, inOfs + len, segments, out,outOfs + len);\n-            } while (++i < 5);\n-\n-            len += op.update(in, inOfs + len, inLen - len, out, outOfs + len);\n-            return len;\n-        }\n-\n-\n-        \/**\n-         * This segments large data into smaller chunks so hotspot will start\n-         * using GCTR and GHASH intrinsics sooner.  This is a problem for app\n-         * and perf tests that only use large input sizes.\n-         *\/\n-        int throttleData(GCM op, ByteBuffer src, ByteBuffer dst) {\n-            int inLen = src.limit();\n-            int segments = (src.remaining() \/ 6);\n-            segments -= segments % blockSize;\n-            int i = 0, resultLen = 0;\n-            do {\n-                src.limit(src.position() + segments);\n-                resultLen += op.update(src, dst);\n-            } while (++i < 5);\n-\n-            src.limit(inLen);\n-            \/\/ If there is still at least a blockSize left\n-            if (src.remaining() > blockSize) {\n-                resultLen += op.update(src, dst);\n-            }\n-\n-            return resultLen;\n-        }\n-\n@@ -936,1 +992,1 @@\n-            if (in == out && inOfs < outOfs) {\n+            if (in == out && (!encryption || inOfs < outOfs)) {\n@@ -977,1 +1033,0 @@\n-        GCTRGHASH gctrghash;\n@@ -981,1 +1036,1 @@\n-            gctrghash = new GCTRGHASH(gctrPAndC, ghashAllToS);\n+            op = new EncryptOp(gctr, ghash);\n@@ -1042,1 +1097,1 @@\n-                    len = gctrghash.update(block, 0, blockSize, out, outOfs);\n+                    len = op.update(block, 0, blockSize, out, outOfs);\n@@ -1051,0 +1106,9 @@\n+            if (inLen >= PARALLEL_LEN) {\n+                int r = GaloisCounterMode.implGCMCrypt(in, inOfs, inLen, out,\n+                    outOfs, out, outOfs, gctr, ghash);\n+                len += r;\n+                inOfs += r;\n+                inLen -= r;\n+                outOfs += r;\n+            }\n+\n@@ -1052,1 +1116,4 @@\n-                len += gctrghash.update(in, inOfs, inLen, out, outOfs);\n+                int r = op.update(in, inOfs, inLen, out, outOfs);\n+                len += r;\n+                inOfs += r;\n+                inLen -= r;\n@@ -1097,2 +1164,3 @@\n-                    len += cryptBlocks(\n-                            ByteBuffer.wrap(block, 0, blockSize), dst);\n+                    len += op.update(ByteBuffer.wrap(block, 0, blockSize),\n+                            dst);\n+                    processed += len;\n@@ -1105,1 +1173,1 @@\n-                len += cryptBlocks(src, dst);\n+                len += implGCMCrypt(op, src, dst);\n@@ -1158,2 +1226,1 @@\n-                    r = gctrghash.update(block, 0, blockSize, out,\n-                        outOfs);\n+                    r = op.update(block, 0, blockSize, out, outOfs);\n@@ -1164,1 +1231,1 @@\n-                    \/\/ Need to consume all the ibuffer here to prepare for doFinal()\n+                    \/\/ Need to consume the ibuffer here to prepare for doFinal()\n@@ -1175,10 +1242,1 @@\n-            if (inLen > TRIGGERLEN) {\n-                int r = throttleData(gctrghash, in, inOfs, inLen, out, outOfs);\n-                inOfs += r;\n-                inLen -= r;\n-                outOfs += r;\n-                resultLen += r;\n-                processed += r;\n-            }\n-\n-            processed += gctrghash.doFinal(in, inOfs, inLen, out, outOfs);\n+            processed += op.doFinal(in, inOfs, inLen, out, outOfs);\n@@ -1189,2 +1247,2 @@\n-            ghashAllToS.update(block);\n-            block = ghashAllToS.digest();\n+            ghash.update(block);\n+            block = ghash.digest();\n@@ -1222,1 +1280,1 @@\n-                processed += doLastBlock(gctrghash,\n+                processed += doLastBlock(op,\n@@ -1233,2 +1291,2 @@\n-            ghashAllToS.update(block);\n-            block = ghashAllToS.digest();\n+            ghash.update(block);\n+            block = ghash.digest();\n@@ -1243,12 +1301,0 @@\n-\n-        \/\/ Handler method for encrypting blocks\n-        int cryptBlocks(ByteBuffer src, ByteBuffer dst) {\n-            int len;\n-            if (src.remaining() > TRIGGERLEN) {\n-                len = throttleData(gctrghash, src, dst);\n-            } else {\n-                len = gctrghash.update(src, dst);\n-            }\n-            processed += len;\n-            return len;\n-        }\n@@ -1365,1 +1411,0 @@\n-            GHASH save = null;\n@@ -1379,1 +1424,2 @@\n-                save = ghashAllToS.clone();\n+                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                    \"be at least \" + (len - tagLenBytes) + \" bytes long\");\n@@ -1384,1 +1430,0 @@\n-\n@@ -1386,4 +1431,6 @@\n-            byte[] block = getLengthBlock(sizeOfAAD,\n-                decryptBlocks(ghashAllToS, in, inOfs, inLen, null, 0));\n-            ghashAllToS.update(block);\n-            block = ghashAllToS.digest();\n+            out = overlapDetection(in, inOfs, out, outOfs);\n+\n+            len = decryptBlocks(new DecryptOp(gctr, ghash), in, inOfs, inLen, out, outOfs);\n+            byte[] block = getLengthBlock(sizeOfAAD, len);\n+            ghash.update(block);\n+            block = ghash.digest();\n@@ -1400,0 +1447,2 @@\n+                \/\/ Clear output data\n+                Arrays.fill(out, outOfs, outOfs + len, (byte) 0);\n@@ -1403,8 +1452,0 @@\n-            if (save != null) {\n-                ghashAllToS = save;\n-                throw new ShortBufferException(\"Output buffer too small, must\" +\n-                    \"be at least \" + (len - tagLenBytes) + \" bytes long\");\n-            }\n-\n-            out = overlapDetection(in, inOfs, out, outOfs);\n-            len = decryptBlocks(gctrPAndC, in, inOfs, inLen, out, outOfs);\n@@ -1423,1 +1464,0 @@\n-            GHASH save = null;\n@@ -1444,1 +1484,2 @@\n-                save = ghashAllToS.clone();\n+                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                    \"be at least \" + (len - tagLenBytes) + \" bytes long\");\n@@ -1473,1 +1514,2 @@\n-\n+            dst = overlapDetection(src, dst);\n+            dst.mark();\n@@ -1476,1 +1518,2 @@\n-            doLastBlock(ghashAllToS, buffer, ct, null);\n+            processed +=\n+                doLastBlock(new DecryptOp(gctr, ghash), buffer, ct, dst);\n@@ -1479,2 +1522,2 @@\n-            ghashAllToS.update(block);\n-            block = ghashAllToS.digest();\n+            ghash.update(block);\n+            block = ghash.digest();\n@@ -1491,0 +1534,9 @@\n+                \/\/ Clear output data\n+                dst.reset();\n+                if (dst.hasArray()) {\n+                    int ofs = dst.arrayOffset() + dst.position();\n+                    Arrays.fill(dst.array(), ofs , ofs + processed, (byte)0);\n+                } else {\n+                    Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n+                        processed + dst.position(), (byte)0);\n+                }\n@@ -1494,18 +1546,0 @@\n-            if (save != null) {\n-                ghashAllToS = save;\n-                throw new ShortBufferException(\"Output buffer too small, must\" +\n-                    \" be at least \" + len + \" bytes long\");\n-            }\n-\n-            \/\/ Prepare for decryption\n-            if (buffer != null) {\n-                buffer.flip();\n-            }\n-            ct.reset();\n-            processed = 0;\n-            \/\/ Check for overlap in the bytebuffers\n-            dst = overlapDetection(src, dst);\n-\n-            \/\/ Decrypt the all the input data and put it into dst\n-            doLastBlock(gctrPAndC, buffer, ct, dst);\n-            restoreDst(dst);\n@@ -1513,3 +1547,2 @@\n-            if (ibuffer != null) {\n-                ibuffer.reset();\n-            }\n+            engine = null;\n+            restoreDst(dst);\n@@ -1525,1 +1558,1 @@\n-        int decryptBlocks(GCM op, byte[] in, int inOfs, int inLen,\n+        int decryptBlocks(GCMOperation op, byte[] in, int inOfs, int inLen,\n@@ -1530,0 +1563,1 @@\n+            int resultLen;\n@@ -1546,3 +1580,4 @@\n-                if (bLen >= blockSize) {\n-                    len += op.update(buffer, 0, bLen, out, outOfs);\n-                    outOfs += len; \/\/ noop for ghash\n+                if (bLen >= PARALLEL_LEN) {\n+                    len = GaloisCounterMode.implGCMCrypt(buffer, 0, bLen,\n+                        buffer, 0, out, outOfs, gctr, ghash);\n+                    outOfs += len;\n@@ -1553,1 +1588,0 @@\n-                \/\/ merge the remaining ibuffer with the 'in'\n@@ -1555,0 +1589,8 @@\n+                if (bufRemainder >= blockSize) {\n+                    int r = op.update(buffer, len, bufRemainder, out, outOfs);\n+                    len += r;\n+                    outOfs += r;\n+                    bufRemainder -= r;\n+                }\n+\n+                \/\/ merge the remaining ibuffer with the 'in'\n@@ -1565,1 +1607,1 @@\n-                        int resultLen = op.update(block, 0, blockSize,\n+                        resultLen = op.update(block, 0, blockSize,\n@@ -1567,1 +1609,1 @@\n-                        outOfs += resultLen; \/\/ noop for ghash\n+                        outOfs += resultLen;\n@@ -1578,8 +1620,8 @@\n-            if (inLen > TRIGGERLEN) {\n-                int l = throttleData(op, in, inOfs, inLen, out, outOfs);\n-                inOfs += l;\n-                inLen -= l;\n-                outOfs += l; \/\/ noop for ghash\n-                len += l;\n-            }\n-            return len + op.doFinal(in, inOfs, inLen, out, outOfs);\n+            resultLen = GaloisCounterMode.implGCMCrypt(in, inOfs, inLen, in,\n+                inOfs, out, outOfs, gctr, ghash);\n+            inOfs += resultLen;\n+            outOfs += resultLen;\n+            inLen -= resultLen;\n+            ghash.doFinal(in, inOfs, inLen);\n+            return len + resultLen +\n+                    gctr.doFinal(in, inOfs, inLen, out, outOfs);\n@@ -1617,1 +1659,1 @@\n-    static final class GCTRGHASH implements GCM {\n+    static final class EncryptOp implements GCMOperation {\n@@ -1621,1 +1663,1 @@\n-        GCTRGHASH(GCTR c, GHASH g) {\n+        EncryptOp(GCTR c, GHASH g) {\n@@ -1653,4 +1695,9 @@\n-        public int doFinal(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n-            int len = gctr.doFinal(in, inOfs, inLen, out, outOfs);\n-            ghash.doFinal(out, outOfs, len);\n-            return len;\n+        public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+                           int outOfs) {\n+            int len = implGCMCrypt(in, inOfs, inLen, out, outOfs, out, outOfs,\n+                    gctr, ghash);\n+            inLen -= len;\n+            outOfs += len;\n+            int flen = gctr.doFinal(in, inOfs + len, inLen, out, outOfs);\n+            ghash.doFinal(out, outOfs, inLen);\n+            return len + flen;\n@@ -1668,0 +1715,65 @@\n+\n+    \/**\n+     * This class is for decryption when both GCTR and GHASH\n+     * can operation in parallel.\n+     *\/\n+    static final class DecryptOp implements GCMOperation {\n+        GCTR gctr;\n+        GHASH ghash;\n+\n+        DecryptOp(GCTR c, GHASH g) {\n+            gctr = c;\n+            ghash = g;\n+        }\n+\n+        @Override\n+        public int update(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) {\n+            ghash.update(in, inOfs, inLen);\n+            return gctr.update(in, inOfs, inLen, out, outOfs);\n+        }\n+\n+        @Override\n+        public int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+            ghash.update(in, inOfs, inLen);\n+            return gctr.update(in, inOfs, inLen, dst);\n+        }\n+\n+        @Override\n+        public int update(ByteBuffer src, ByteBuffer dst) {\n+            src.mark();\n+            ghash.update(src, src.remaining());\n+            src.reset();\n+            return gctr.update(src, dst);\n+        }\n+\n+        @Override\n+        public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+                           int outOfs) {\n+            int len = implGCMCrypt(in, inOfs, inLen, in, inOfs, out, outOfs,\n+                    gctr, ghash);\n+            ghash.doFinal(in, inOfs + len, inLen - len);\n+            return len + gctr.doFinal(in, inOfs + len, inLen - len, out,\n+                    outOfs + len);\n+        }\n+\n+        @Override\n+        public int doFinal(ByteBuffer src, ByteBuffer dst) {\n+            src.mark();\n+            ghash.doFinal(src, src.remaining());\n+            src.reset();\n+            return gctr.doFinal(src, dst);\n+        }\n+    }\n+\n+    \/**\n+     * Interface to organize encryption and decryption operations in the\n+     * proper order for GHASH and GCTR.\n+     *\/\n+    public interface GCMOperation {\n+        int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs);\n+        int update(byte[] in, int inOfs, int inLen, ByteBuffer dst);\n+        int update(ByteBuffer src, ByteBuffer dst);\n+        int doFinal(byte[] in, int inOfs, int inLen, byte[] out, int outOfs);\n+        int doFinal(ByteBuffer src, ByteBuffer dst);\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":288,"deletions":176,"binary":false,"changes":464,"status":"modified"}]}