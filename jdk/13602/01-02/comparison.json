{"files":[{"patch":"@@ -4296,0 +4296,50 @@\n+#ifdef _LP64\n+\n+static void convertF2I_slowpath(C2_MacroAssembler& masm, C2GeneralStub<Register, XMMRegister, address>& stub) {\n+#define __ masm.\n+  Register dst = stub.data<0>();\n+  XMMRegister src = stub.data<1>();\n+  address target = stub.data<2>();\n+  __ bind(stub.entry());\n+  __ subptr(rsp, 8);\n+  __ movdbl(Address(rsp), src);\n+  __ call(RuntimeAddress(target));\n+  __ pop(dst);\n+  __ jmp(stub.continuation());\n+#undef __\n+}\n+\n+void C2_MacroAssembler::convertF2I(BasicType dst_bt, BasicType src_bt, Register dst, XMMRegister src) {\n+  assert(dst_bt == T_INT || dst_bt == T_LONG, \"\");\n+  assert(src_bt == T_FLOAT || src_bt == T_DOUBLE, \"\");\n+\n+  address slowpath_target;\n+  if (dst_bt == T_INT) {\n+    if (src_bt == T_FLOAT) {\n+      cvttss2sil(dst, src);\n+      cmpl(dst, 0x80000000);\n+      slowpath_target = StubRoutines::x86::f2i_fixup();\n+    } else {\n+      cvttsd2sil(dst, src);\n+      cmpl(dst, 0x80000000);\n+      slowpath_target = StubRoutines::x86::d2i_fixup();\n+    }\n+  } else {\n+    if (src_bt == T_FLOAT) {\n+      cvttss2siq(dst, src);\n+      cmp64(dst, ExternalAddress(StubRoutines::x86::double_sign_flip()));\n+      slowpath_target = StubRoutines::x86::f2l_fixup();\n+    } else {\n+      cvttsd2siq(dst, src);\n+      cmp64(dst, ExternalAddress(StubRoutines::x86::double_sign_flip()));\n+      slowpath_target = StubRoutines::x86::d2l_fixup();\n+    }\n+  }\n+\n+  auto stub = C2CodeStub::make<Register, XMMRegister, address>(dst, src, slowpath_target, 23, convertF2I_slowpath);\n+  jcc(Assembler::equal, stub->entry());\n+  bind(stub->continuation());\n+}\n+\n+#endif \/\/ _LP64\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -307,0 +307,4 @@\n+#ifdef _LP64\n+  void convertF2I(BasicType dst_bt, BasicType src_bt, Register dst, XMMRegister src);\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -11023,1 +11023,1 @@\n-  format %{ \"convert_f2i $dst,$src\" %}\n+  format %{ \"convert_f2i $dst, $src\" %}\n@@ -11025,13 +11025,1 @@\n-    __ cvttss2sil($dst$$Register, $src$$XMMRegister);\n-    __ cmpl($dst$$Register, 0x80000000);\n-    __ jcc(Assembler::equal, stub->entry());\n-    __ bind(stub->continuation());\n-  %}\n-  stub_max_size(23);\n-  stub_encode %{\n-    __ bind(entry());\n-    __ subptr(rsp, 8);\n-    __ movflt(Address(rsp), $src$$XMMRegister);\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));\n-    __ pop($dst$$Register);\n-    __ jmp(continuation());\n+    __ convertF2I(T_INT, T_FLOAT, $dst$$Register, $src$$XMMRegister);\n@@ -11046,1 +11034,1 @@\n-  format %{ \"convert_f2l $dst,$src\"%}\n+  format %{ \"convert_f2l $dst, $src\"%}\n@@ -11048,13 +11036,1 @@\n-    __ cvttss2siq($dst$$Register, $src$$XMMRegister);\n-    __ cmp64($dst$$Register, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));\n-    __ jcc(Assembler::equal, stub->entry());\n-    __ bind(stub->continuation());\n-  %}\n-  stub_max_size(23);\n-  stub_encode %{\n-    __ bind(entry());\n-    __ subptr(rsp, 8);\n-    __ movflt(Address(rsp), $src$$XMMRegister);\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));\n-    __ pop($dst$$Register);\n-    __ jmp(continuation());\n+    __ convertF2I(T_LONG, T_FLOAT, $dst$$Register, $src$$XMMRegister);\n@@ -11069,1 +11045,1 @@\n-  format %{ \"convert_d2i $dst,$src\"%}\n+  format %{ \"convert_d2i $dst, $src\"%}\n@@ -11071,13 +11047,1 @@\n-    __ cvttsd2sil($dst$$Register, $src$$XMMRegister);\n-    __ cmpl($dst$$Register, 0x80000000);\n-    __ jcc(Assembler::equal, stub->entry());\n-    __ bind(stub->continuation());\n-  %}\n-  stub_max_size(23);\n-  stub_encode %{\n-    __ bind(entry());\n-    __ subptr(rsp, 8);\n-    __ movdbl(Address(rsp), $src$$XMMRegister);\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));\n-    __ pop($dst$$Register);\n-    __ jmp(continuation());\n+    __ convertF2I(T_INT, T_DOUBLE, $dst$$Register, $src$$XMMRegister);\n@@ -11092,1 +11056,1 @@\n-  format %{ \"convert_d2l $dst,$src\"%}\n+  format %{ \"convert_d2l $dst, $src\"%}\n@@ -11094,13 +11058,1 @@\n-    __ cvttsd2siq($dst$$Register, $src$$XMMRegister);\n-    __ cmp64($dst$$Register, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));\n-    __ jcc(Assembler::equal, stub->entry());\n-    __ bind(stub->continuation());\n-  %}\n-  stub_max_size(23);\n-  stub_encode %{\n-    __ bind(entry());\n-    __ subptr(rsp, 8);\n-    __ movdbl(Address(rsp), $src$$XMMRegister);\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));\n-    __ pop($dst$$Register);\n-    __ jmp(continuation());\n+    __ convertF2I(T_LONG, T_DOUBLE, $dst$$Register, $src$$XMMRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":8,"deletions":56,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,1 +227,0 @@\n-    else if (!strcmp(ident, \"stub_encode\"))      stub_encode_parse(*instr);\n@@ -231,2 +230,1 @@\n-    else if (!strcmp(ident, \"size\"))             instr->_size      = size_parse();\n-    else if (!strcmp(ident, \"stub_max_size\"))    instr->_stubmaxsize = size_parse();\n+    else if (!strcmp(ident, \"size\"))             instr->_size      = size_parse(instr);\n@@ -2878,1 +2876,1 @@\n-InsEncode* ADLParser::ins_encode_parse_block(InstructForm& inst, const char* prefix, const char* prefix_code) {\n+void ADLParser::ins_encode_parse_block(InstructForm& inst) {\n@@ -2881,0 +2879,1 @@\n+  const char* prefix = \"__ins_encode_\";\n@@ -2899,1 +2898,1 @@\n-  if (prefix_code != nullptr) {\n+  if (!inst._is_postalloc_expand) {\n@@ -2904,1 +2903,1 @@\n-    encoding->add_code(prefix_code);\n+    encoding->add_code(\"    C2_MacroAssembler _masm(&cbuf);\\n\");\n@@ -2919,1 +2918,9 @@\n-  return encrule;\n+  \/\/ Check for duplicate ins_encode sections after parsing the block\n+  \/\/ so that parsing can continue and find any other errors.\n+  if (inst._insencode != NULL) {\n+    parse_err(SYNERR, \"Multiple ins_encode sections defined\\n\");\n+    return;\n+  }\n+\n+  \/\/ Set encode class of this instruction.\n+  inst._insencode = encrule;\n@@ -3034,11 +3041,1 @@\n-      InsEncode* encrule = ins_encode_parse_block(inst, \"__ins_encode\",\n-                                                  \"    C2_MacroAssembler _masm(&cbuf);\\n\");\n-      \/\/ Check for duplicate ins_encode sections after parsing the block\n-      \/\/ so that parsing can continue and find any other errors.\n-      if (inst._insencode != nullptr) {\n-        parse_err(SYNERR, \"Multiple ins_encode sections defined\\n\");\n-        return;\n-      }\n-\n-      \/\/ Set encode class of this instruction.\n-      inst._insencode = encrule;\n+      ins_encode_parse_block(inst);\n@@ -3194,22 +3191,0 @@\n-\/\/------------------------------stub_encode_parse------------------------------\n-\/\/ Encode rules have the form\n-\/\/   stub_encode %{\n-\/\/      ... \/\/ body\n-\/\/   %}\n-void ADLParser::stub_encode_parse(InstructForm& inst) {\n-  skipws();                        \/\/ Skip whitespace\n-  if ((_curchar != '%') || (*(_ptr+1) != '{')) {\n-    parse_err(SYNERR, \"missing '%%{' in stub_encode definition\\n\");\n-  }\n-\n-  next_char();                      \/\/ Skip '%'\n-  next_char();                      \/\/ Skip '{'\n-\n-  InsEncode* encrule = ins_encode_parse_block(inst, \"__stub_encode\", nullptr);\n-  if (inst._stubencode != nullptr) {\n-    parse_err(SYNERR, \"Multiple stub_encode sections defined\\n\");\n-    return;\n-  }\n-  inst._stubencode = encrule;\n-}\n-\n@@ -3236,10 +3211,1 @@\n-      InsEncode* encrule = ins_encode_parse_block(inst, \"__ins_encode\", nullptr);\n-      \/\/ Check for duplicate ins_encode sections after parsing the block\n-      \/\/ so that parsing can continue and find any other errors.\n-      if (inst._insencode != NULL) {\n-        parse_err(SYNERR, \"Multiple ins_encode sections defined\\n\");\n-        return;\n-      }\n-\n-      \/\/ Set encode class of this instruction.\n-      inst._insencode = encrule;\n+      ins_encode_parse_block(inst);\n@@ -3492,1 +3458,1 @@\n-char* ADLParser::size_parse() {\n+char* ADLParser::size_parse(InstructForm *instr) {\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":18,"deletions":52,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,3 +161,2 @@\n-  void           ins_encode_parse(InstructForm& inst);\n-  void           stub_encode_parse(InstructForm& inst);\n-  InsEncode     *ins_encode_parse_block(InstructForm& inst, const char* prefix, const char* prefix_code);\n+  void           ins_encode_parse(InstructForm &inst);\n+  void           ins_encode_parse_block(InstructForm &inst);\n@@ -172,1 +171,1 @@\n-  char          *size_parse(); \/\/ Parse instruction size\n+  char          *size_parse(InstructForm *insr); \/\/ Parse instruction size\n","filename":"src\/hotspot\/share\/adlc\/adlparse.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -322,1 +322,0 @@\n-  void defineStubEmit    (FILE* fp, InstructForm& node);\n","filename":"src\/hotspot\/share\/adlc\/archDesc.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+\n@@ -47,2 +48,0 @@\n-      _stubmaxsize          = NULL;\n-      _stubencode           = NULL;\n@@ -83,2 +82,0 @@\n-      _stubmaxsize           = instr->_stubmaxsize;\n-      _stubencode            = instr->_stubencode;\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,2 +102,0 @@\n-  char          *_stubmaxsize;\n-  InsEncode     *_stubencode;\n","filename":"src\/hotspot\/share\/adlc\/formssel.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -240,2 +240,0 @@\n-  AD.addInclude(AD._HPP_file, \"opto\/c2_CodeStubs.hpp\");\n-  AD.addInclude(AD._HPP_file, \"opto\/c2_MacroAssembler.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1895,1 +1895,0 @@\n-  const char   *_current_node;\n@@ -1924,3 +1923,2 @@\n-                  InsEncode &ins_encode, InstructForm &inst, const char* current_node)\n-    : _AD(AD), _fp(fp), _encoding(encoding), _ins_encode(ins_encode),\n-      _inst(inst), _current_node(current_node) {\n+                  InsEncode &ins_encode, InstructForm &inst)\n+    : _AD(AD), _fp(fp), _encoding(encoding), _ins_encode(ins_encode), _inst(inst) {\n@@ -2206,1 +2204,1 @@\n-          fprintf(_fp,\"->base(ra_,%s,idx%d), \", _current_node, _operand_idx);\n+          fprintf(_fp,\"->base(ra_,this,idx%d), \", _operand_idx);\n@@ -2210,1 +2208,1 @@\n-          fprintf(_fp,\"->index(ra_,%s,idx%d), \", _current_node, _operand_idx);\n+          fprintf(_fp,\"->index(ra_,this,idx%d), \", _operand_idx);\n@@ -2220,1 +2218,1 @@\n-            fprintf(_fp,\"->disp(ra_,%s,0), \", _current_node);\n+            fprintf(_fp,\"->disp(ra_,this,0), \");\n@@ -2222,1 +2220,1 @@\n-            fprintf(_fp,\"->disp(ra_,%s,idx%d), \", _current_node, _operand_idx);\n+            fprintf(_fp,\"->disp(ra_,this,idx%d), \", _operand_idx);\n@@ -2362,1 +2360,1 @@\n-          fprintf(_fp,\"->%s(ra_,%s\", reg_convert != NULL ? reg_convert : \"reg\", _current_node);\n+          fprintf(_fp,\"->%s(ra_,this\", reg_convert != NULL ? reg_convert : \"reg\");\n@@ -2377,1 +2375,1 @@\n-      fprintf(_fp,\"->base(ra_,%s,idx%d)\", _current_node, _operand_idx);\n+      fprintf(_fp,\"->base(ra_,this,idx%d)\", _operand_idx);\n@@ -2383,1 +2381,1 @@\n-      fprintf(_fp,\"->index(ra_,%s,idx%d)\", _current_node, _operand_idx);\n+      fprintf(_fp,\"->index(ra_,this,idx%d)\", _operand_idx);\n@@ -2412,1 +2410,1 @@\n-        fprintf(_fp,\"->disp(ra_,%s,0)\", _current_node);\n+        fprintf(_fp,\"->disp(ra_,this,0)\");\n@@ -2414,1 +2412,1 @@\n-        fprintf(_fp,\"->disp(ra_,%s,idx%d)\", _current_node, _operand_idx);\n+        fprintf(_fp,\"->disp(ra_,this,idx%d)\", _operand_idx);\n@@ -2612,1 +2610,1 @@\n-  DefineEmitState pending(fp, *this, *encoding, *ins_encode, inst, \"this\");\n+  DefineEmitState pending(fp, *this, *encoding, *ins_encode, inst);\n@@ -2667,8 +2665,0 @@\n-  if (inst._stubencode != nullptr) {\n-    fprintf(fp, \"  %sStub* stub = new (Compile::current()->comp_arena()) %sStub(this, ra_);\\n\",\n-            inst._ident, inst._ident);\n-    fprintf(fp, \"  if (!Compile::current()->output()->in_scratch_emit_size()) {\\n\");\n-    fprintf(fp, \"    Compile::current()->output()->add_stub(stub);\\n\");\n-    fprintf(fp, \"  }\\n\");\n-  }\n-\n@@ -2701,1 +2691,1 @@\n-    DefineEmitState pending(fp, *this, *encoding, *encode, inst, \"this\");\n+    DefineEmitState pending(fp, *this, *encoding, *encode, inst);\n@@ -2736,45 +2726,0 @@\n-void ArchDesc::defineStubEmit(FILE* fp, InstructForm& inst) {\n-  InsEncode* encode = inst._stubencode;\n-  if (encode == nullptr) {\n-    return;\n-  }\n-\n-  fprintf(fp, \"void %sStub::emit(C2_MacroAssembler& _masm) {\\n\", inst._ident);\n-  inst.index_temps(fp, _globalNames);\n-  encode->reset();\n-  const char* ec_name = encode->encode_class_iter();\n-  assert(ec_name != nullptr && _encode != nullptr, \"stub_encode missing body\");\n-\n-  EncClass* encoding = _encode->encClass(ec_name);\n-  assert(encoding != nullptr, \"\");\n-\n-  DefineEmitState pending(fp, *this, *encoding, *encode, inst, \"_node\");\n-  encoding->_code.reset();\n-  encoding->_rep_vars.reset();\n-  \/\/ Process list of user-defined strings,\n-  \/\/ and occurrences of replacement variables.\n-  \/\/ Replacement Vars are pushed into a list and then output\n-  const char* ec_code = nullptr;\n-  const char* ec_rep_var = nullptr;\n-  while ((ec_code = encoding->_code.iter()) != NULL) {\n-    if (!encoding->_code.is_signal(ec_code)) {\n-      \/\/ Emit pending code\n-      pending.emit();\n-      pending.clear();\n-      \/\/ Emit this code section\n-      fprintf(fp, \"%s\", ec_code);\n-    } else {\n-      \/\/ A replacement variable or one of its subfields\n-      \/\/ Obtain replacement variable from list\n-      ec_rep_var  = encoding->_rep_vars.iter();\n-      pending.add_rep_var(ec_rep_var);\n-    }\n-  }\n-  \/\/ Emit pending code\n-  pending.emit();\n-  pending.clear();\n-  fprintf(fp, \"}\\n\\n\");\n-  assert(encode->encode_class_iter() == nullptr,\n-         \"stub_encode should only have one encoding\");\n-}\n-\n@@ -2825,1 +2770,1 @@\n-    DefineEmitState pending(fp, *this, *encoding, *encode, inst, \"this\");\n+    DefineEmitState pending(fp, *this, *encoding, *encode, inst);\n@@ -3359,1 +3304,0 @@\n-        defineStubEmit(fp, *instr);\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":15,"deletions":71,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1526,1 +1526,2 @@\n-  fprintf(fp,\"\\n\/\/----------------------------Declare classes derived from MachNode----------\\n\\n\");\n+  fprintf(fp,\"\\n\");\n+  fprintf(fp,\"\/\/----------------------------Declare classes derived from MachNode----------\\n\");\n@@ -1528,1 +1529,2 @@\n-  for(InstructForm *instr = nullptr; (instr = (InstructForm*)_instructions.iter()) != nullptr;) {\n+  InstructForm *instr;\n+  for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {\n@@ -1533,0 +1535,1 @@\n+    fprintf(fp,\"\\n\");\n@@ -1995,20 +1998,2 @@\n-    fprintf(fp,\"};\\n\\n\");\n-\n-    \/\/ Stub attached to this node\n-    if (instr->_stubencode == nullptr) {\n-      continue;\n-    }\n-    assert(instr->_stubmaxsize != nullptr, \"missing stub_max_size in instruction\");\n-\n-    fprintf(fp, \"class %sStub : public C2CodeStub {\\n\", instr->_ident);\n-    fprintf(fp, \"private:\\n\");\n-    fprintf(fp, \"  const %sNode* _node;\\n\", instr->_ident);\n-    fprintf(fp, \"  PhaseRegAlloc* ra_;\\n\");\n-    fprintf(fp, \"  MachOper* opnd_array(uint index) const { return _node->opnd_array(index); }\\n\");\n-    fprintf(fp, \"public:\\n\");\n-    fprintf(fp, \"  %sStub(const %sNode* node, PhaseRegAlloc* ra) : _node(node), ra_(ra) {}\\n\",\n-            instr->_ident, instr->_ident);\n-    fprintf(fp, \"  int max_size() const { return %s; }\\n\", instr->_stubmaxsize);\n-    fprintf(fp, \"  void emit(C2_MacroAssembler& masm);\\n\");\n-    fprintf(fp, \"};\\n\\n\");\n-  } \/\/ End of InstructForm iteration\n+    fprintf(fp,\"};\\n\");\n+  };\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/logical.hpp\"\n","filename":"src\/hotspot\/share\/metaprogramming\/enableIf.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,7 @@\n+\n+\/\/ move here to avoid circular dependency between c2_CodeStubs.hpp and output.hpp\n+void C2CodeStub::add_to_stub_list() {\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    Compile::current()->output()->add_stub(this);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/output.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"utilities\/tuple.hpp\"\n@@ -34,0 +37,3 @@\n+template <class... Ts>\n+class C2GeneralStub;\n+\n@@ -39,0 +45,1 @@\n+  void add_to_stub_list();\n@@ -50,0 +57,4 @@\n+\n+  template <class... Ts>\n+  static C2GeneralStub<Ts...>* make(const Ts&... data, int max_size,\n+                                    void (*emit)(C2_MacroAssembler&, C2GeneralStub<Ts...>&));\n@@ -104,0 +115,28 @@\n+template <class... Ts>\n+class C2GeneralStub : public C2CodeStub {\n+private:\n+  Tuple<Ts...> _data;\n+  int _max_size;\n+  void (*_emit)(C2_MacroAssembler&, C2GeneralStub&);\n+\n+  constexpr C2GeneralStub(const Ts&... data, int max_size,\n+                          void (*emit)(C2_MacroAssembler&, C2GeneralStub<Ts...>&))\n+    : _data(data...), _max_size(max_size), _emit(emit) {}\n+\n+  friend C2CodeStub;\n+public:\n+  template <std::size_t I>\n+  constexpr const auto& data() const { return _data.template get<I>(); }\n+\n+  int max_size() const { return _max_size; }\n+  void emit(C2_MacroAssembler& masm) { _emit(masm, *this); }\n+};\n+\n+template <class... Ts>\n+C2GeneralStub<Ts...>* C2CodeStub::make(const Ts&... data, int max_size,\n+                                       void (*emit)(C2_MacroAssembler&, C2GeneralStub<Ts...>&)) {\n+  auto stub = new (Compile::current()->comp_arena()) C2GeneralStub<Ts...>(data..., max_size, emit);\n+  stub->add_to_stub_list();\n+  return stub;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_UTILITIES_TUPLE_HPP\n+#define SHARE_UTILITIES_TUPLE_HPP\n+\n+#include <type_traits>\n+\n+template <class... Ts>\n+class Tuple;\n+\n+template <>\n+class Tuple<> {};\n+\n+template <class T, class... Ts>\n+class Tuple<T, Ts...> {\n+private:\n+  T _first;\n+  Tuple<Ts...> _remaining;\n+  \n+public:\n+  constexpr Tuple(const T& first, const Ts&... remaining) noexcept\n+    : _first(first), _remaining(remaining...) {}\n+\n+  template <std::size_t I, std::enable_if_t<(I > 0), int> = 0>\n+  constexpr const auto& get() const noexcept {\n+    return _remaining.template get<I - 1>();\n+  };\n+\n+  template <std::size_t I, std::enable_if_t<I == 0, int> = 0>\n+  constexpr const T& get() const noexcept {\n+    return _first;\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_TUPLE_HPP\n","filename":"src\/hotspot\/share\/utilities\/tuple.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}