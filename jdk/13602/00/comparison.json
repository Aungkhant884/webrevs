{"files":[{"patch":"@@ -216,4 +216,1 @@\n-  \/\/ No default displacement otherwise Register can be implicitly\n-  \/\/ converted to 0(Register) which is quite a different animal.\n-\n-  Address(Register base, int disp)\n+  explicit Address(Register base, int disp = 0)\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -11025,1 +11025,13 @@\n-    __ convert_f2i($dst$$Register, $src$$XMMRegister);\n+    __ cvttss2sil($dst$$Register, $src$$XMMRegister);\n+    __ cmpl($dst$$Register, 0x80000000);\n+    __ jcc(Assembler::equal, stub->entry());\n+    __ bind(stub->continuation());\n+  %}\n+  stub_max_size(23);\n+  stub_encode %{\n+    __ bind(entry());\n+    __ subptr(rsp, 8);\n+    __ movflt(Address(rsp), $src$$XMMRegister);\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));\n+    __ pop($dst$$Register);\n+    __ jmp(continuation());\n@@ -11036,1 +11048,13 @@\n-    __ convert_f2l($dst$$Register, $src$$XMMRegister);\n+    __ cvttss2siq($dst$$Register, $src$$XMMRegister);\n+    __ cmp64($dst$$Register, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));\n+    __ jcc(Assembler::equal, stub->entry());\n+    __ bind(stub->continuation());\n+  %}\n+  stub_max_size(23);\n+  stub_encode %{\n+    __ bind(entry());\n+    __ subptr(rsp, 8);\n+    __ movflt(Address(rsp), $src$$XMMRegister);\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));\n+    __ pop($dst$$Register);\n+    __ jmp(continuation());\n@@ -11047,1 +11071,13 @@\n-    __ convert_d2i($dst$$Register, $src$$XMMRegister);\n+    __ cvttsd2sil($dst$$Register, $src$$XMMRegister);\n+    __ cmpl($dst$$Register, 0x80000000);\n+    __ jcc(Assembler::equal, stub->entry());\n+    __ bind(stub->continuation());\n+  %}\n+  stub_max_size(23);\n+  stub_encode %{\n+    __ bind(entry());\n+    __ subptr(rsp, 8);\n+    __ movdbl(Address(rsp), $src$$XMMRegister);\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));\n+    __ pop($dst$$Register);\n+    __ jmp(continuation());\n@@ -11058,1 +11094,13 @@\n-    __ convert_d2l($dst$$Register, $src$$XMMRegister);\n+    __ cvttsd2siq($dst$$Register, $src$$XMMRegister);\n+    __ cmp64($dst$$Register, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));\n+    __ jcc(Assembler::equal, stub->entry());\n+    __ bind(stub->continuation());\n+  %}\n+  stub_max_size(23);\n+  stub_encode %{\n+    __ bind(entry());\n+    __ subptr(rsp, 8);\n+    __ movdbl(Address(rsp), $src$$XMMRegister);\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));\n+    __ pop($dst$$Register);\n+    __ jmp(continuation());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":52,"deletions":4,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,1 @@\n+    else if (!strcmp(ident, \"stub_encode\"))      stub_encode_parse(*instr);\n@@ -230,1 +231,2 @@\n-    else if (!strcmp(ident, \"size\"))             instr->_size      = size_parse(instr);\n+    else if (!strcmp(ident, \"size\"))             instr->_size      = size_parse();\n+    else if (!strcmp(ident, \"stub_max_size\"))    instr->_stubmaxsize = size_parse();\n@@ -2876,1 +2878,1 @@\n-void ADLParser::ins_encode_parse_block(InstructForm& inst) {\n+InsEncode* ADLParser::ins_encode_parse_block(InstructForm& inst, const char* prefix, const char* prefix_code) {\n@@ -2879,1 +2881,0 @@\n-  const char* prefix = \"__ins_encode_\";\n@@ -2898,1 +2899,1 @@\n-  if (!inst._is_postalloc_expand) {\n+  if (prefix_code != nullptr) {\n@@ -2903,1 +2904,1 @@\n-    encoding->add_code(\"    C2_MacroAssembler _masm(&cbuf);\\n\");\n+    encoding->add_code(prefix_code);\n@@ -2918,9 +2919,1 @@\n-  \/\/ Check for duplicate ins_encode sections after parsing the block\n-  \/\/ so that parsing can continue and find any other errors.\n-  if (inst._insencode != NULL) {\n-    parse_err(SYNERR, \"Multiple ins_encode sections defined\\n\");\n-    return;\n-  }\n-\n-  \/\/ Set encode class of this instruction.\n-  inst._insencode = encrule;\n+  return encrule;\n@@ -3041,1 +3034,11 @@\n-      ins_encode_parse_block(inst);\n+      InsEncode* encrule = ins_encode_parse_block(inst, \"__ins_encode\",\n+                                                  \"    C2_MacroAssembler _masm(&cbuf);\\n\");\n+      \/\/ Check for duplicate ins_encode sections after parsing the block\n+      \/\/ so that parsing can continue and find any other errors.\n+      if (inst._insencode != nullptr) {\n+        parse_err(SYNERR, \"Multiple ins_encode sections defined\\n\");\n+        return;\n+      }\n+\n+      \/\/ Set encode class of this instruction.\n+      inst._insencode = encrule;\n@@ -3191,0 +3194,22 @@\n+\/\/------------------------------stub_encode_parse------------------------------\n+\/\/ Encode rules have the form\n+\/\/   stub_encode %{\n+\/\/      ... \/\/ body\n+\/\/   %}\n+void ADLParser::stub_encode_parse(InstructForm& inst) {\n+  skipws();                        \/\/ Skip whitespace\n+  if ((_curchar != '%') || (*(_ptr+1) != '{')) {\n+    parse_err(SYNERR, \"missing '%%{' in stub_encode definition\\n\");\n+  }\n+\n+  next_char();                      \/\/ Skip '%'\n+  next_char();                      \/\/ Skip '{'\n+\n+  InsEncode* encrule = ins_encode_parse_block(inst, \"__stub_encode\", nullptr);\n+  if (inst._stubencode != nullptr) {\n+    parse_err(SYNERR, \"Multiple stub_encode sections defined\\n\");\n+    return;\n+  }\n+  inst._stubencode = encrule;\n+}\n+\n@@ -3211,1 +3236,10 @@\n-      ins_encode_parse_block(inst);\n+      InsEncode* encrule = ins_encode_parse_block(inst, \"__ins_encode\", nullptr);\n+      \/\/ Check for duplicate ins_encode sections after parsing the block\n+      \/\/ so that parsing can continue and find any other errors.\n+      if (inst._insencode != NULL) {\n+        parse_err(SYNERR, \"Multiple ins_encode sections defined\\n\");\n+        return;\n+      }\n+\n+      \/\/ Set encode class of this instruction.\n+      inst._insencode = encrule;\n@@ -3458,1 +3492,1 @@\n-char* ADLParser::size_parse(InstructForm *instr) {\n+char* ADLParser::size_parse() {\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":52,"deletions":18,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,2 +161,3 @@\n-  void           ins_encode_parse(InstructForm &inst);\n-  void           ins_encode_parse_block(InstructForm &inst);\n+  void           ins_encode_parse(InstructForm& inst);\n+  void           stub_encode_parse(InstructForm& inst);\n+  InsEncode     *ins_encode_parse_block(InstructForm& inst, const char* prefix, const char* prefix_code);\n@@ -171,1 +172,1 @@\n-  char          *size_parse(InstructForm *insr); \/\/ Parse instruction size\n+  char          *size_parse(); \/\/ Parse instruction size\n","filename":"src\/hotspot\/share\/adlc\/adlparse.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -322,0 +322,1 @@\n+  void defineStubEmit    (FILE* fp, InstructForm& node);\n","filename":"src\/hotspot\/share\/adlc\/archDesc.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-\n@@ -48,0 +47,2 @@\n+      _stubmaxsize          = NULL;\n+      _stubencode           = NULL;\n@@ -82,0 +83,2 @@\n+      _stubmaxsize           = instr->_stubmaxsize;\n+      _stubencode            = instr->_stubencode;\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,2 @@\n+  char          *_stubmaxsize;\n+  InsEncode     *_stubencode;\n","filename":"src\/hotspot\/share\/adlc\/formssel.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,0 +240,2 @@\n+  AD.addInclude(AD._HPP_file, \"opto\/c2_CodeStubs.hpp\");\n+  AD.addInclude(AD._HPP_file, \"opto\/c2_MacroAssembler.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1895,0 +1895,1 @@\n+  const char   *_current_node;\n@@ -1923,2 +1924,3 @@\n-                  InsEncode &ins_encode, InstructForm &inst)\n-    : _AD(AD), _fp(fp), _encoding(encoding), _ins_encode(ins_encode), _inst(inst) {\n+                  InsEncode &ins_encode, InstructForm &inst, const char* current_node)\n+    : _AD(AD), _fp(fp), _encoding(encoding), _ins_encode(ins_encode),\n+      _inst(inst), _current_node(current_node) {\n@@ -2204,1 +2206,1 @@\n-          fprintf(_fp,\"->base(ra_,this,idx%d), \", _operand_idx);\n+          fprintf(_fp,\"->base(ra_,%s,idx%d), \", _current_node, _operand_idx);\n@@ -2208,1 +2210,1 @@\n-          fprintf(_fp,\"->index(ra_,this,idx%d), \", _operand_idx);\n+          fprintf(_fp,\"->index(ra_,%s,idx%d), \", _current_node, _operand_idx);\n@@ -2218,1 +2220,1 @@\n-            fprintf(_fp,\"->disp(ra_,this,0), \");\n+            fprintf(_fp,\"->disp(ra_,%s,0), \", _current_node);\n@@ -2220,1 +2222,1 @@\n-            fprintf(_fp,\"->disp(ra_,this,idx%d), \", _operand_idx);\n+            fprintf(_fp,\"->disp(ra_,%s,idx%d), \", _current_node, _operand_idx);\n@@ -2360,1 +2362,1 @@\n-          fprintf(_fp,\"->%s(ra_,this\", reg_convert != NULL ? reg_convert : \"reg\");\n+          fprintf(_fp,\"->%s(ra_,%s\", reg_convert != NULL ? reg_convert : \"reg\", _current_node);\n@@ -2375,1 +2377,1 @@\n-      fprintf(_fp,\"->base(ra_,this,idx%d)\", _operand_idx);\n+      fprintf(_fp,\"->base(ra_,%s,idx%d)\", _current_node, _operand_idx);\n@@ -2381,1 +2383,1 @@\n-      fprintf(_fp,\"->index(ra_,this,idx%d)\", _operand_idx);\n+      fprintf(_fp,\"->index(ra_,%s,idx%d)\", _current_node, _operand_idx);\n@@ -2410,1 +2412,1 @@\n-        fprintf(_fp,\"->disp(ra_,this,0)\");\n+        fprintf(_fp,\"->disp(ra_,%s,0)\", _current_node);\n@@ -2412,1 +2414,1 @@\n-        fprintf(_fp,\"->disp(ra_,this,idx%d)\", _operand_idx);\n+        fprintf(_fp,\"->disp(ra_,%s,idx%d)\", _current_node, _operand_idx);\n@@ -2610,1 +2612,1 @@\n-  DefineEmitState pending(fp, *this, *encoding, *ins_encode, inst);\n+  DefineEmitState pending(fp, *this, *encoding, *ins_encode, inst, \"this\");\n@@ -2665,0 +2667,8 @@\n+  if (inst._stubencode != nullptr) {\n+    fprintf(fp, \"  %sStub* stub = new (Compile::current()->comp_arena()) %sStub(this, ra_);\\n\",\n+            inst._ident, inst._ident);\n+    fprintf(fp, \"  if (!Compile::current()->output()->in_scratch_emit_size()) {\\n\");\n+    fprintf(fp, \"    Compile::current()->output()->add_stub(stub);\\n\");\n+    fprintf(fp, \"  }\\n\");\n+  }\n+\n@@ -2691,1 +2701,1 @@\n-    DefineEmitState pending(fp, *this, *encoding, *encode, inst);\n+    DefineEmitState pending(fp, *this, *encoding, *encode, inst, \"this\");\n@@ -2726,0 +2736,45 @@\n+void ArchDesc::defineStubEmit(FILE* fp, InstructForm& inst) {\n+  InsEncode* encode = inst._stubencode;\n+  if (encode == nullptr) {\n+    return;\n+  }\n+\n+  fprintf(fp, \"void %sStub::emit(C2_MacroAssembler& _masm) {\\n\", inst._ident);\n+  inst.index_temps(fp, _globalNames);\n+  encode->reset();\n+  const char* ec_name = encode->encode_class_iter();\n+  assert(ec_name != nullptr && _encode != nullptr, \"stub_encode missing body\");\n+\n+  EncClass* encoding = _encode->encClass(ec_name);\n+  assert(encoding != nullptr, \"\");\n+\n+  DefineEmitState pending(fp, *this, *encoding, *encode, inst, \"_node\");\n+  encoding->_code.reset();\n+  encoding->_rep_vars.reset();\n+  \/\/ Process list of user-defined strings,\n+  \/\/ and occurrences of replacement variables.\n+  \/\/ Replacement Vars are pushed into a list and then output\n+  const char* ec_code = nullptr;\n+  const char* ec_rep_var = nullptr;\n+  while ((ec_code = encoding->_code.iter()) != NULL) {\n+    if (!encoding->_code.is_signal(ec_code)) {\n+      \/\/ Emit pending code\n+      pending.emit();\n+      pending.clear();\n+      \/\/ Emit this code section\n+      fprintf(fp, \"%s\", ec_code);\n+    } else {\n+      \/\/ A replacement variable or one of its subfields\n+      \/\/ Obtain replacement variable from list\n+      ec_rep_var  = encoding->_rep_vars.iter();\n+      pending.add_rep_var(ec_rep_var);\n+    }\n+  }\n+  \/\/ Emit pending code\n+  pending.emit();\n+  pending.clear();\n+  fprintf(fp, \"}\\n\\n\");\n+  assert(encode->encode_class_iter() == nullptr,\n+         \"stub_encode should only have one encoding\");\n+}\n+\n@@ -2770,1 +2825,1 @@\n-    DefineEmitState pending(fp, *this, *encoding, *encode, inst);\n+    DefineEmitState pending(fp, *this, *encoding, *encode, inst, \"this\");\n@@ -3304,0 +3359,1 @@\n+        defineStubEmit(fp, *instr);\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":71,"deletions":15,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1526,2 +1526,1 @@\n-  fprintf(fp,\"\\n\");\n-  fprintf(fp,\"\/\/----------------------------Declare classes derived from MachNode----------\\n\");\n+  fprintf(fp,\"\\n\/\/----------------------------Declare classes derived from MachNode----------\\n\\n\");\n@@ -1529,2 +1528,1 @@\n-  InstructForm *instr;\n-  for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {\n+  for(InstructForm *instr = nullptr; (instr = (InstructForm*)_instructions.iter()) != nullptr;) {\n@@ -1535,1 +1533,0 @@\n-    fprintf(fp,\"\\n\");\n@@ -1998,2 +1995,20 @@\n-    fprintf(fp,\"};\\n\");\n-  };\n+    fprintf(fp,\"};\\n\\n\");\n+\n+    \/\/ Stub attached to this node\n+    if (instr->_stubencode == nullptr) {\n+      continue;\n+    }\n+    assert(instr->_stubmaxsize != nullptr, \"missing stub_max_size in instruction\");\n+\n+    fprintf(fp, \"class %sStub : public C2CodeStub {\\n\", instr->_ident);\n+    fprintf(fp, \"private:\\n\");\n+    fprintf(fp, \"  const %sNode* _node;\\n\", instr->_ident);\n+    fprintf(fp, \"  PhaseRegAlloc* ra_;\\n\");\n+    fprintf(fp, \"  MachOper* opnd_array(uint index) const { return _node->opnd_array(index); }\\n\");\n+    fprintf(fp, \"public:\\n\");\n+    fprintf(fp, \"  %sStub(const %sNode* node, PhaseRegAlloc* ra) : _node(node), ra_(ra) {}\\n\",\n+            instr->_ident, instr->_ident);\n+    fprintf(fp, \"  int max_size() const { return %s; }\\n\", instr->_stubmaxsize);\n+    fprintf(fp, \"  void emit(C2_MacroAssembler& masm);\\n\");\n+    fprintf(fp, \"};\\n\\n\");\n+  } \/\/ End of InstructForm iteration\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"}]}