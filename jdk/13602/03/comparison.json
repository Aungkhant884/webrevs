{"files":[{"patch":"@@ -216,4 +216,1 @@\n-  \/\/ No default displacement otherwise Register can be implicitly\n-  \/\/ converted to 0(Register) which is quite a different animal.\n-\n-  Address(Register base, int disp)\n+  explicit Address(Register base, int disp = 0)\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4296,0 +4296,50 @@\n+#ifdef _LP64\n+\n+static void convertF2I_slowpath(C2_MacroAssembler& masm, C2GeneralStub<Register, XMMRegister, address>& stub) {\n+#define __ masm.\n+  Register dst = stub.data<0>();\n+  XMMRegister src = stub.data<1>();\n+  address target = stub.data<2>();\n+  __ bind(stub.entry());\n+  __ subptr(rsp, 8);\n+  __ movdbl(Address(rsp), src);\n+  __ call(RuntimeAddress(target));\n+  __ pop(dst);\n+  __ jmp(stub.continuation());\n+#undef __\n+}\n+\n+void C2_MacroAssembler::convertF2I(BasicType dst_bt, BasicType src_bt, Register dst, XMMRegister src) {\n+  assert(dst_bt == T_INT || dst_bt == T_LONG, \"\");\n+  assert(src_bt == T_FLOAT || src_bt == T_DOUBLE, \"\");\n+\n+  address slowpath_target;\n+  if (dst_bt == T_INT) {\n+    if (src_bt == T_FLOAT) {\n+      cvttss2sil(dst, src);\n+      cmpl(dst, 0x80000000);\n+      slowpath_target = StubRoutines::x86::f2i_fixup();\n+    } else {\n+      cvttsd2sil(dst, src);\n+      cmpl(dst, 0x80000000);\n+      slowpath_target = StubRoutines::x86::d2i_fixup();\n+    }\n+  } else {\n+    if (src_bt == T_FLOAT) {\n+      cvttss2siq(dst, src);\n+      cmp64(dst, ExternalAddress(StubRoutines::x86::double_sign_flip()));\n+      slowpath_target = StubRoutines::x86::f2l_fixup();\n+    } else {\n+      cvttsd2siq(dst, src);\n+      cmp64(dst, ExternalAddress(StubRoutines::x86::double_sign_flip()));\n+      slowpath_target = StubRoutines::x86::d2l_fixup();\n+    }\n+  }\n+\n+  auto stub = C2CodeStub::make<Register, XMMRegister, address>(dst, src, slowpath_target, 23, convertF2I_slowpath);\n+  jcc(Assembler::equal, stub->entry());\n+  bind(stub->continuation());\n+}\n+\n+#endif \/\/ _LP64\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -307,0 +307,4 @@\n+#ifdef _LP64\n+  void convertF2I(BasicType dst_bt, BasicType src_bt, Register dst, XMMRegister src);\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -11023,1 +11023,1 @@\n-  format %{ \"convert_f2i $dst,$src\" %}\n+  format %{ \"convert_f2i $dst, $src\" %}\n@@ -11025,1 +11025,1 @@\n-    __ convert_f2i($dst$$Register, $src$$XMMRegister);\n+    __ convertF2I(T_INT, T_FLOAT, $dst$$Register, $src$$XMMRegister);\n@@ -11034,1 +11034,1 @@\n-  format %{ \"convert_f2l $dst,$src\"%}\n+  format %{ \"convert_f2l $dst, $src\"%}\n@@ -11036,1 +11036,1 @@\n-    __ convert_f2l($dst$$Register, $src$$XMMRegister);\n+    __ convertF2I(T_LONG, T_FLOAT, $dst$$Register, $src$$XMMRegister);\n@@ -11045,1 +11045,1 @@\n-  format %{ \"convert_d2i $dst,$src\"%}\n+  format %{ \"convert_d2i $dst, $src\"%}\n@@ -11047,1 +11047,1 @@\n-    __ convert_d2i($dst$$Register, $src$$XMMRegister);\n+    __ convertF2I(T_INT, T_DOUBLE, $dst$$Register, $src$$XMMRegister);\n@@ -11056,1 +11056,1 @@\n-  format %{ \"convert_d2l $dst,$src\"%}\n+  format %{ \"convert_d2l $dst, $src\"%}\n@@ -11058,1 +11058,1 @@\n-    __ convert_d2l($dst$$Register, $src$$XMMRegister);\n+    __ convertF2I(T_LONG, T_DOUBLE, $dst$$Register, $src$$XMMRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/logical.hpp\"\n","filename":"src\/hotspot\/share\/metaprogramming\/enableIf.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,7 @@\n+\n+\/\/ move here to avoid circular dependency between c2_CodeStubs.hpp and output.hpp\n+void C2CodeStub::add_to_stub_list() {\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    Compile::current()->output()->add_stub(this);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/output.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"utilities\/tuple.hpp\"\n@@ -34,0 +37,3 @@\n+template <class... Ts>\n+class C2GeneralStub;\n+\n@@ -39,0 +45,1 @@\n+  void add_to_stub_list();\n@@ -50,0 +57,4 @@\n+\n+  template <class... Ts>\n+  static C2GeneralStub<Ts...>* make(const Ts&... data, int max_size,\n+                                    void (*emit)(C2_MacroAssembler&, C2GeneralStub<Ts...>&));\n@@ -104,0 +115,28 @@\n+template <class... Ts>\n+class C2GeneralStub : public C2CodeStub {\n+private:\n+  Tuple<Ts...> _data;\n+  int _max_size;\n+  void (*_emit)(C2_MacroAssembler&, C2GeneralStub&);\n+\n+  constexpr C2GeneralStub(const Ts&... data, int max_size,\n+                          void (*emit)(C2_MacroAssembler&, C2GeneralStub<Ts...>&))\n+    : _data(data...), _max_size(max_size), _emit(emit) {}\n+\n+  friend C2CodeStub;\n+public:\n+  template <std::size_t I>\n+  constexpr const auto& data() const { return _data.template get<I>(); }\n+\n+  int max_size() const { return _max_size; }\n+  void emit(C2_MacroAssembler& masm) { _emit(masm, *this); }\n+};\n+\n+template <class... Ts>\n+C2GeneralStub<Ts...>* C2CodeStub::make(const Ts&... data, int max_size,\n+                                       void (*emit)(C2_MacroAssembler&, C2GeneralStub<Ts...>&)) {\n+  auto stub = new (Compile::current()->comp_arena()) C2GeneralStub<Ts...>(data..., max_size, emit);\n+  stub->add_to_stub_list();\n+  return stub;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_UTILITIES_TUPLE_HPP\n+#define SHARE_UTILITIES_TUPLE_HPP\n+\n+#include <type_traits>\n+\n+template <class... Ts>\n+class Tuple;\n+\n+template <>\n+class Tuple<> {};\n+\n+template <class T, class... Ts>\n+class Tuple<T, Ts...> {\n+private:\n+  T _first;\n+  Tuple<Ts...> _remaining;\n+\n+public:\n+  constexpr Tuple(const T& first, const Ts&... remaining) noexcept\n+    : _first(first), _remaining(remaining...) {}\n+\n+  template <std::size_t I, std::enable_if_t<(I > 0), int> = 0>\n+  constexpr const auto& get() const noexcept {\n+    return _remaining.template get<I - 1>();\n+  };\n+\n+  template <std::size_t I, std::enable_if_t<I == 0, int> = 0>\n+  constexpr const T& get() const noexcept {\n+    return _first;\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_TUPLE_HPP\n","filename":"src\/hotspot\/share\/utilities\/tuple.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsAppend = {\"-XX:-UseSuperWord\"})\n+public class ConvertF2I {\n+    static final int LENGTH = 1000;\n+    static final int[] INT_ARRAY = new int[LENGTH];\n+    static final long[] LONG_ARRAY = new long[LENGTH];\n+    static final float[] FLOAT_ARRAY = new float[LENGTH];\n+    static final double[] DOUBLE_ARRAY = new double[LENGTH];\n+    float f;\n+    double d;\n+\n+    @Benchmark\n+    public int f2iSingle() {\n+        return (int)f;\n+    }\n+\n+    @Benchmark\n+    public long f2lSingle() {\n+        return (long)f;\n+    }\n+\n+    @Benchmark\n+    public int d2iSingle() {\n+        return (int)d;\n+    }\n+\n+    @Benchmark\n+    public long d2lSingle() {\n+        return (long)d;\n+    }\n+\n+    @Benchmark\n+    public void f2iArray() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            INT_ARRAY[i] = (int)FLOAT_ARRAY[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void f2lArray() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            LONG_ARRAY[i] = (long)FLOAT_ARRAY[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void d2iArray() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            INT_ARRAY[i] = (int)DOUBLE_ARRAY[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void d2lArray() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            LONG_ARRAY[i] = (long)DOUBLE_ARRAY[i];\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/ConvertF2I.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}