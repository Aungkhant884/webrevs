{"files":[{"patch":"@@ -538,1 +538,2 @@\n-                int dp = StringCoding.countPositives(bytes, offset, length);\n+                byte[] dst = Arrays.copyOfRange(bytes, offset, offset + length);\n+                int dp = StringCoding.countPositives(dst, 0, length);\n@@ -540,1 +541,1 @@\n-                    this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                    this.value = dst;\n@@ -544,8 +545,3 @@\n-                int sl = offset + length;\n-                byte[] dst = new byte[length];\n-                if (dp > 0) {\n-                    System.arraycopy(bytes, offset, dst, 0, dp);\n-                    offset += dp;\n-                }\n-                while (offset < sl) {\n-                    int b1 = bytes[offset++];\n+                int i = dp; \/\/ invariant: dp <= i\n+                while (i < length) {\n+                    int b1 = dst[i++];\n@@ -556,2 +552,2 @@\n-                    if ((b1 & 0xfe) == 0xc2 && offset < sl) { \/\/ b1 either 0xc2 or 0xc3\n-                        int b2 = bytes[offset];\n+                    if ((b1 & 0xfe) == 0xc2 && i < length) { \/\/ b1 either 0xc2 or 0xc3\n+                        int b2 = dst[i];\n@@ -560,1 +556,1 @@\n-                            offset++;\n+                            i++;\n@@ -566,1 +562,1 @@\n-                    offset--;\n+                    i--;\n@@ -569,2 +565,2 @@\n-                if (offset == sl) {\n-                    if (dp != dst.length) {\n+                if (i == length) {\n+                    if (dp != length) {\n@@ -579,0 +575,1 @@\n+                dp = decodeUTF8_UTF16(dst, i, length, buf, dp, true);\n@@ -580,1 +577,0 @@\n-                dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n@@ -656,0 +652,1 @@\n+                    \/\/ ArrayDecoder is trusted\n@@ -686,0 +683,1 @@\n+\n@@ -687,6 +685,5 @@\n-                byte[] bs = StringUTF16.compress(ca, 0, caLen);\n-                if (bs != null) {\n-                    value = bs;\n-                    coder = LATIN1;\n-                    return;\n-                }\n+                \/\/ ca leaked to arbitrary decoder implementation\n+                byte[] bs = StringUTF16.maybeCompressUntrusted(ca, 0, caLen);\n+                value = bs;\n+                coder = bs.length == caLen ? LATIN1 : UTF16;\n+                return;\n@@ -830,4 +827,3 @@\n-            byte[] bs = StringUTF16.compress(ca, 0, caLen);\n-            if (bs != null) {\n-                return new String(bs, LATIN1);\n-            }\n+            \/\/ ca leaked to arbitrary decoder implementation\n+            byte[] bs = StringUTF16.maybeCompressUntrusted(ca, 0, caLen);\n+            return new String(bs, bs.length == caLen ? LATIN1 : UTF16);\n@@ -4764,6 +4760,5 @@\n-            byte[] val = StringUTF16.compress(value, off, len);\n-            if (val != null) {\n-                this.value = val;\n-                this.coder = LATIN1;\n-                return;\n-            }\n+            \/\/ user-supplied, untrusted value\n+            byte[] val = StringUTF16.maybeCompressUntrusted(value, off, len);\n+            this.value = val;\n+            this.coder = val.length == len ? LATIN1 : UTF16;\n+            return;\n@@ -4788,6 +4783,5 @@\n-                byte[] buf = StringUTF16.compress(val, 0, length);\n-                if (buf != null) {\n-                    this.coder = LATIN1;\n-                    this.value = buf;\n-                    return;\n-                }\n+                \/\/ asb may be mutated by user\n+                byte[] buf = StringUTF16.maybeCompressUntrusted(val, 0, length);\n+                this.value = buf;\n+                this.coder = buf.length == length ? LATIN1 : UTF16;\n+                return;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":33,"deletions":39,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+     * <br><strong>Warning: Make sure the byte array is not leaked to public,\n+     * Or the bytes may be non-positive when the caller reads the array again!<\/strong>\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -161,0 +161,39 @@\n+    \/**\n+     * Compresses a UTF16 array to LATIN1 if possible. Will not return\n+     * a compressible UTF16 array with any 0-valued significant bytes,\n+     * which is erroneous if COMPACT_STRING is enabled.\n+     *\/\n+    public static byte[] maybeCompressUntrusted(char[] val, int off, int len) {\n+        byte[] compressed = new byte[len];\n+        if (compress(val, off, compressed, 0, len) == len) {\n+            return compressed;\n+        }\n+\n+        byte[] trusted = toBytes(val, off, len); \/\/ now not leaked\n+        if (compress(trusted, 0, compressed, 0, len) == len) {\n+            return compressed;\n+        }\n+        return trusted;\n+    }\n+\n+    \/**\n+     * Compresses a UTF16 array to LATIN1 if possible. Will not return\n+     * a compressible UTF16 array with any 0-valued significant bytes,\n+     * which is erroneous if COMPACT_STRING is enabled.\n+     *\n+     * <p>The off and len are in char array\/UTF16 coder units.\n+     *\/\n+    public static byte[] maybeCompressUntrusted(byte[] val, int off, int len) {\n+        byte[] compressed = new byte[len];\n+        if (compress(val, off, compressed, 0, len) == len) {\n+            return compressed;\n+        }\n+\n+        byte[] trusted = Arrays.copyOfRange(val, off << 1, len << 1); \/\/ now not leaked\n+        if (compress(trusted, 0, compressed, 0, len) == len) {\n+            return compressed;\n+        }\n+        return trusted;\n+    }\n+\n+    \/\/ must not be used with leaked arrays\n@@ -169,0 +208,1 @@\n+    \/\/ must not be used with leaked arrays\n@@ -1166,0 +1206,1 @@\n+    \/\/ val must not be leaked\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"}]}