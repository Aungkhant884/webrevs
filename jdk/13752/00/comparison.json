{"files":[{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4913349\n+  @summary verifies that AWT_LOCK is properly taken during DnD\n+  @key headful\n+  @run main DnDAWTLockTest\n+*\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragGestureRecognizer;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetAdapter;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.util.StringTokenizer;\n+\n+\n+public class DnDAWTLockTest implements ClipboardOwner {\n+    public static final int STARTUP_TIMEOUT = 2000;\n+    volatile Frame frame;\n+\n+    static final Clipboard clipboard =\n+            Toolkit.getDefaultToolkit().getSystemClipboard();\n+\n+    Process process = null;\n+    Point sourcePoint = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        DnDAWTLockTest test = new DnDAWTLockTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> test.frame.dispose());\n+        }\n+    }\n+\n+    public void init() {\n+        frame = new Frame(\"Drop target frame\");\n+        frame.setLocation(200, 200);\n+        Panel panel = new DragSourcePanel();\n+        frame.add(panel);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() throws Exception {\n+        String stderr = null;\n+\n+        Robot robot = new Robot();\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+\n+        Point p = frame.getLocationOnScreen();\n+        Dimension d = frame.getSize();\n+\n+        Point pp = new Point(p);\n+        pp.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!Util.pointInComponent(robot, pp, frame)) {\n+            System.err.println(\"WARNING: Couldn't locate \" + frame +\n+                    \" at point \" + pp);\n+            return;\n+        }\n+\n+        sourcePoint = pp;\n+        clipboard.setContents(new StringSelection(Util.TRANSFER_DATA),\n+                this);\n+\n+        String javaPath = System.getProperty(\"java.home\", \"\");\n+        String[] command = {\n+                javaPath + File.separator + \"bin\" + File.separator + \"java\",\n+                \"-cp\", System.getProperty(\"test.classes\", \".\"),\n+                \"Child\"\n+        };\n+\n+        process = Runtime.getRuntime().exec(command);\n+        ProcessResults pres = ProcessResults.doWaitFor(process);\n+\n+        stderr = pres.stderr;\n+\n+        if (pres.stderr != null && pres.stderr.length() > 0) {\n+            System.err.println(\"========= Child VM System.err ========\");\n+            System.err.print(pres.stderr);\n+            System.err.println(\"======================================\");\n+        }\n+\n+        if (pres.stdout != null && pres.stdout.length() > 0) {\n+            System.err.println(\"========= Child VM System.out ========\");\n+            System.err.print(pres.stdout);\n+            System.err.println(\"======================================\");\n+        }\n+\n+        System.err.println(\"Child VM return code: \" + pres.exitValue);\n+\n+        if (stderr != null && stderr.contains(\"InternalError\")) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    public void lostOwnership(Clipboard c, Transferable trans) {\n+        Runnable r = new Runnable() {\n+            public void run() {\n+                try {\n+                    if (process == null) {\n+                        throw new RuntimeException(\"Null process\");\n+                    }\n+\n+                    if (sourcePoint == null) {\n+                        throw new RuntimeException(\"Null point\");\n+                    }\n+\n+                    Thread.sleep(STARTUP_TIMEOUT);\n+                    Transferable t = clipboard.getContents(null);\n+\n+                    String s =\n+                            (String) t.getTransferData(DataFlavor.stringFlavor);\n+                    StringTokenizer st = new StringTokenizer(s);\n+\n+                    int x = Integer.parseInt(st.nextToken());\n+                    int y = Integer.parseInt(st.nextToken());\n+\n+                    Point targetPoint = new Point(x, y);\n+\n+                    Robot robot = new Robot();\n+\n+                    robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+                    robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                    for (; !sourcePoint.equals(targetPoint);\n+                         sourcePoint.translate(\n+                                 sign(targetPoint.x - sourcePoint.x),\n+                                 sign(targetPoint.y - sourcePoint.y)\n+                         )) {\n+                        robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+                        robot.delay(25);\n+                    }\n+                    robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                    process.destroy();\n+                }\n+            }\n+        };\n+        new Thread(r).start();\n+    }\n+\n+    public static int sign(int n) {\n+        return Integer.compare(n, 0);\n+    }\n+}\n+\n+class Child {\n+    public static final int ACTION_TIMEOUT = 30000;\n+\n+    volatile Frame frame;\n+    volatile Panel panel;\n+\n+\n+    public void init() {\n+        panel = new DropTargetPanel();\n+\n+        frame = new Frame(\"Drag source frame\");\n+        frame.setLocation(500, 200);\n+        frame.add(panel);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public void run() {\n+        try {\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            Point targetPoint = panel.getLocationOnScreen();\n+            Dimension d = panel.getSize();\n+            targetPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+            if (!Util.pointInComponent(robot, targetPoint, panel)) {\n+                System.err.println(\"WARNING: Couldn't locate \" + panel +\n+                        \" at point \" + targetPoint);\n+                System.exit(0);\n+            }\n+\n+            String positionData = \"\" + targetPoint.x + \" \" + targetPoint.y;\n+            DnDAWTLockTest.clipboard.setContents(\n+                    new StringSelection(positionData), null);\n+\n+            Thread.sleep(ACTION_TIMEOUT);\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+        System.exit(0);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Child child = new Child();\n+        EventQueue.invokeAndWait(child::init);\n+        try {\n+            child.run();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> child.frame.dispose());\n+        }\n+    }\n+}\n+\n+class Util implements AWTEventListener {\n+    private static final Toolkit tk = Toolkit.getDefaultToolkit();\n+    public static final Object SYNC_LOCK = new Object();\n+    private Component clickedComponent = null;\n+    private static final int PAINT_TIMEOUT = 10000;\n+    private static final int MOUSE_RELEASE_TIMEOUT = 10000;\n+    private static final Util util = new Util();\n+    public static final String TRANSFER_DATA = \"TRANSFER_DATA\";\n+\n+    static {\n+        tk.addAWTEventListener(util, 0xFFFFFFFF);\n+    }\n+\n+    private void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component)e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    public static boolean pointInComponent(Robot robot, Point p, Component comp)\n+            throws InterruptedException {\n+        return util.isPointInComponent(robot, p, comp);\n+    }\n+\n+    private boolean isPointInComponent(Robot robot, Point p, Component comp)\n+            throws InterruptedException {\n+        tk.sync();\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+}\n+\n+class DragSourcePanel extends Panel {\n+    public DragSourcePanel() {\n+        final Transferable t = new StringSelection(Util.TRANSFER_DATA);\n+        final DragGestureListener dgl = new DragGestureListener() {\n+            public void dragGestureRecognized(DragGestureEvent dge) {\n+                dge.startDrag(null, t);\n+            }\n+        };\n+        final DragSource ds = DragSource.getDefaultDragSource();\n+        final DragGestureRecognizer dgr =\n+                ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                        dgl);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(100, 100);\n+    }\n+}\n+\n+class DropTargetPanel extends Panel {\n+    public DropTargetPanel() {\n+        final DropTargetListener dtl = new DropTargetAdapter() {\n+            public void drop(DropTargetDropEvent dtde) {\n+                Transferable t = dtde.getTransferable();\n+                dtde.acceptDrop(dtde.getDropAction());\n+                try {\n+                    t.getTransferData(DataFlavor.stringFlavor);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+                dtde.dropComplete(true);\n+                EventQueue.invokeLater(new Runnable() {\n+                    public void run() {\n+                        System.exit(0);\n+                    }\n+                });\n+            }\n+        };\n+        final DropTarget dt = new DropTarget(this, dtl);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(100, 100);\n+    }\n+}\n+\n+class ProcessResults {\n+    public int exitValue;\n+    public String stdout;\n+    public String stderr;\n+\n+    public ProcessResults() {\n+        exitValue = -1;\n+        stdout = \"\";\n+        stderr = \"\";\n+    }\n+\n+    \/**\n+     * Method to perform a \"wait\" for a process and return its exit value.\n+     * This is a workaround for <code>Process.waitFor()<\/code> never returning.\n+     *\/\n+    public static ProcessResults doWaitFor(Process p) {\n+        ProcessResults pres = new ProcessResults();\n+\n+        InputStream in = null;\n+        InputStream err = null;\n+\n+        try {\n+            in = p.getInputStream();\n+            err = p.getErrorStream();\n+\n+            boolean finished = false;\n+\n+            while (!finished) {\n+                try {\n+                    while (in.available() > 0) {\n+                        pres.stdout += (char)in.read();\n+                    }\n+                    while (err.available() > 0) {\n+                        pres.stderr += (char)err.read();\n+                    }\n+                    \/\/ Ask the process for its exitValue. If the process\n+                    \/\/ is not finished, an IllegalThreadStateException\n+                    \/\/ is thrown. If it is finished, we fall through and\n+                    \/\/ the variable finished is set to true.\n+                    pres.exitValue = p.exitValue();\n+                    finished  = true;\n+                }\n+                catch (IllegalThreadStateException e) {\n+                    \/\/ Process is not finished yet;\n+                    \/\/ Sleep a little to save on CPU cycles\n+                    Thread.sleep(500);\n+                }\n+            }\n+            if (in != null) in.close();\n+            if (err != null) err.close();\n+        }\n+        catch (Throwable e) {\n+            System.err.println(\"doWaitFor(): unexpected exception\");\n+            e.printStackTrace();\n+        }\n+        return pres;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDAWTLockTest.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4354044\n+  @summary tests that a drag can be initiated with MOUSE_MOVED event\n+  @key headful\n+*\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragGestureRecognizer;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.InvalidDnDOperationException;\n+import java.awt.event.InputEvent;\n+\n+public class DragGestureInvokeLaterTest {\n+\n+    volatile Frame frame;\n+    volatile DragSourcePanel panel;\n+\n+    public static void main(String[] args) throws Exception {\n+        DragGestureInvokeLaterTest test =\n+                new DragGestureInvokeLaterTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> test.frame.dispose());\n+        }\n+    }\n+\n+    public void init() {\n+        panel = new DragSourcePanel();\n+        frame = new Frame(\"DragGestureInvokeLaterTest frame\");\n+        frame.setSize(200, 200);\n+        frame.setLocation(200, 200);\n+        frame.add(panel);\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() throws Exception {\n+        Robot robot = new Robot();\n+\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+\n+        Point loc = panel.getLocationOnScreen();\n+\n+        robot.mouseMove(loc.x + 2, loc.y + 2);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        for (int i = 0; i < 10; i++) {\n+            robot.delay(100);\n+            robot.mouseMove(loc.x + 2 + i, loc.y + 2 + i);\n+        }\n+\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(1000);\n+    }\n+}\n+\n+class DragSourcePanel extends Panel\n+        implements DragSourceListener, DragGestureListener {\n+\n+    DragSource ds;\n+    DragGestureRecognizer dgr;\n+\n+    public DragSourcePanel() {\n+        ds = new DragSource();\n+        dgr = ds.createDefaultDragGestureRecognizer(this,\n+            DnDConstants.ACTION_COPY_OR_MOVE, this);\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent e) {\n+        Runnable dragThread = new DragThread(e);\n+        EventQueue.invokeLater(dragThread);\n+    }\n+\n+    class DragThread implements Runnable {\n+\n+        DragGestureEvent event;\n+\n+        public DragThread(DragGestureEvent e) {\n+            event = e;\n+        }\n+\n+        public void run() {\n+            try {\n+                event.startDrag(DragSource.DefaultCopyNoDrop,\n+                    new StringSelection(\"Test\"), DragSourcePanel.this);\n+            } catch (InvalidDnDOperationException e) {\n+                System.out.println(\"The test PASSED\");\n+                return;\n+            }\n+            throw new RuntimeException(\n+                    \"Test failed, InvalidDnDOperationException is not thrown\");\n+        }\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent e) {}\n+\n+    public void dragOver(DragSourceDragEvent e) {}\n+\n+    public void dropActionChanged(DragSourceDragEvent e) {}\n+\n+    public void dragExit(DragSourceEvent e) {}\n+\n+    public void dragDropEnd(DragSourceDropEvent e) {}\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DragGestureInvokeLaterTest.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4445747\n+  @summary tests that drag over drop target is not very slow on Win9X\/WinME\n+  @key headful\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetAdapter;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.dnd.InvalidDnDOperationException;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+public class DragOverDropTargetPerformanceTest {\n+\n+    Frame frame;\n+    DragSourceButton dragSourceButton;\n+    DropTargetPanel dropTargetPanel;\n+\n+    static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n+    static final int DROP_COMPLETION_TIMEOUT = 1000;\n+\n+    public static void main(String[] args) throws Exception {\n+        DragOverDropTargetPerformanceTest test =\n+                new DragOverDropTargetPerformanceTest();\n+\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(()-> test.frame.dispose());\n+        }\n+    }\n+\n+    public void init() {\n+        dragSourceButton = new DragSourceButton();\n+        dropTargetPanel = new DropTargetPanel();\n+\n+        frame  = new Frame();\n+        frame.setTitle(\"DragOverDropTargetPerformanceTest frame\");\n+        frame.setLocation(200, 200);\n+        frame.setLayout(new GridLayout(2, 1));\n+        frame.add(dragSourceButton);\n+        frame.add(dropTargetPanel);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public static int sign(int n) {\n+        return Integer.compare(n, 0);\n+    }\n+\n+    public void start() throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(10);\n+        robot.waitForIdle();\n+        robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+\n+        Point srcPoint = dragSourceButton.getLocationOnScreen();\n+        Dimension d = dragSourceButton.getSize();\n+        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        Point dstPoint = dropTargetPanel.getLocationOnScreen();\n+        d = dropTargetPanel.getSize();\n+        dstPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        robot.mouseMove(srcPoint.x, srcPoint.y);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        for (;!srcPoint.equals(dstPoint);\n+             srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                                sign(dstPoint.y - srcPoint.y))) {\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            robot.delay(10);\n+        }\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.keyRelease(KeyEvent.VK_CONTROL);\n+\n+        robot.delay(DROP_COMPLETION_TIMEOUT);\n+\n+        long dstime = dragSourceButton.getDragSourceTime();\n+        long dttime = dragSourceButton.getDropTargetTime();\n+        if (dstime == 0 || dttime == 0) {\n+            System.err.println(\n+                    \"WARNING: couldn't emulate DnD to measure performance.\");\n+        } else if (dttime > dstime * 4) {\n+            throw new RuntimeException(\"The test failed.\" +\n+                                       \"Over drag source: \" + dstime + \".\" +\n+                                       \"Over drop target: \" + dttime);\n+        }\n+    }\n+}\n+\n+class DragSourceButton extends Button implements Serializable,\n+                                                 Transferable,\n+                                                 DragGestureListener,\n+                                                 DragSourceListener {\n+    private final DataFlavor dataflavor =\n+        new DataFlavor(Button.class, \"DragSourceButton\");\n+    private long dsTime = 0;\n+    private long dtTime = 0;\n+\n+    public DragSourceButton() {\n+        this(\"DragSourceButton\");\n+    }\n+\n+    public DragSourceButton(String str) {\n+        super(str);\n+\n+        DragSource ds = DragSource.getDefaultDragSource();\n+        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                              this);\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        try {\n+            dge.startDrag(null, this, this);\n+            dsTime = System.currentTimeMillis();\n+        } catch (InvalidDnDOperationException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {\n+        long currentTime = System.currentTimeMillis();\n+        dsTime = currentTime - dsTime;\n+        dtTime = currentTime;\n+    }\n+\n+    public void dragExit(DragSourceEvent dse) {}\n+\n+    public void dragOver(DragSourceDragEvent dsde) {}\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {\n+        long currentTime = System.currentTimeMillis();\n+        dtTime = currentTime - dtTime;\n+    }\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {}\n+\n+    public Object getTransferData(DataFlavor flavor)\n+      throws UnsupportedFlavorException, IOException {\n+\n+        if (!isDataFlavorSupported(flavor)) {\n+            throw new UnsupportedFlavorException(flavor);\n+        }\n+\n+        return this;\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return new DataFlavor[] { dataflavor };\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+        return dataflavor.equals(dflavor);\n+    }\n+\n+    public long getDragSourceTime() {\n+        return dsTime;\n+    }\n+\n+    public long getDropTargetTime() {\n+        return dtTime;\n+    }\n+}\n+\n+class DropTargetPanel extends Panel {\n+\n+    final Dimension preferredDimension = new Dimension(200, 200);\n+    final DropTargetListener dtl = new DropTargetAdapter() {\n+            public void drop(DropTargetDropEvent dtde) {\n+                dtde.rejectDrop();\n+            }\n+        };\n+\n+    public DropTargetPanel() {\n+        setDropTarget(new DropTarget(this, dtl));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DragOverDropTargetPerformanceTest.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4924527\n+  @summary tests DragSourceDragEvent.getGestureModifiers[Ex]() \\\n+  for valid and invalid modifiers\n+  @key headful\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Cursor;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragGestureRecognizer;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceContext;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.event.InputEvent;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.ImageProducer;\n+\n+public class DragSourceDragEventModifiersTest  {\n+    boolean failed;\n+\n+    static class DummyImage extends Image {\n+        public DummyImage() {}\n+        public int getWidth(ImageObserver observer) {return 0;}\n+        public int getHeight(ImageObserver observer){return 0;}\n+        public ImageProducer getSource() {return null;}\n+        public Graphics getGraphics() {return null;}\n+        public void flush() {}\n+\n+        public Object getProperty(String name, ImageObserver observer) {\n+            return null;\n+        }\n+    }\n+\n+    static class DummyDGRecognizer extends DragGestureRecognizer {\n+        private final DragSource dragSource;\n+        private final Component component;\n+\n+        public DummyDGRecognizer(DragSource ds,Component c) {\n+            super(ds,c);\n+            component = c;\n+            dragSource = ds;\n+        }\n+\n+        public void addDragGestureListener(DragGestureListener dgl) {}\n+        public void appendEvent(InputEvent awtie) {}\n+        public void fireDragGestureRecognized(int dragAction, Point p) {}\n+        public Component getComponent() {return component;}\n+        public DragSource getDragSource() {return dragSource;}\n+        public int getSourceActions() {return DnDConstants.ACTION_COPY_OR_MOVE;}\n+        public InputEvent getTriggerEvent() {return null;}\n+        public void registerListeners() {}\n+        public void removeDragGestureListener(DragGestureListener dgl) {}\n+        public void resetRecognizer() {}\n+        public void setComponent(Component c) {}\n+        public void setSourceActions(int actions) {}\n+        public void unregisterListeners() {}\n+    }\n+\n+\n+    DragSource ds = new DragSource();\n+\n+    int[] actions = {\n+        DnDConstants.ACTION_NONE,\n+        DnDConstants.ACTION_COPY,\n+        DnDConstants.ACTION_MOVE,\n+        DnDConstants.ACTION_COPY_OR_MOVE,\n+        DnDConstants.ACTION_LINK,\n+        DnDConstants.ACTION_REFERENCE\n+    };\n+\n+    Cursor[] cursors = {\n+        DragSource.DefaultCopyDrop,\n+        DragSource.DefaultMoveDrop,\n+        DragSource.DefaultLinkDrop,\n+        DragSource.DefaultCopyNoDrop,\n+        DragSource.DefaultMoveNoDrop,\n+        DragSource.DefaultLinkNoDrop\n+    };\n+\n+    DummyImage image = new DummyImage();\n+\n+    Point point = new Point(0,0);\n+\n+    Transferable transferable = new Transferable() {\n+        public DataFlavor[] getTransferDataFlavors() {return null;}\n+        public boolean isDataFlavorSupported(DataFlavor flavor) {return false;}\n+        public Object getTransferData(DataFlavor flavor) {return null;}\n+    };\n+\n+    DragSourceListener dsl = new DragSourceListener() {\n+        public void dragEnter(DragSourceDragEvent dsde) {}\n+        public void dragOver(DragSourceDragEvent dsde) {}\n+        public void dropActionChanged(DragSourceDragEvent dsde) {}\n+        public void dragExit(DragSourceEvent dsde) {}\n+        public void dragDropEnd(DragSourceDropEvent dsde) {}\n+    };\n+    \/*\n+    int modifiers[] = {\n+        InputEvent.ALT_GRAPH_MASK,\n+        InputEvent.ALT_MASK,\n+        InputEvent.BUTTON1_MASK,\n+        InputEvent.BUTTON2_MASK,\n+        InputEvent.BUTTON3_MASK,\n+        InputEvent.CTRL_MASK,\n+        InputEvent.META_MASK,\n+        InputEvent.SHIFT_MASK\n+    };\n+\n+    int exModifiers[] = {\n+        InputEvent.SHIFT_DOWN_MASK,\n+        InputEvent.ALT_DOWN_MASK,\n+        InputEvent.BUTTON1_DOWN_MASK,\n+        InputEvent.BUTTON2_DOWN_MASK,\n+        InputEvent.BUTTON3_DOWN_MASK,\n+        InputEvent.CTRL_DOWN_MASK,\n+        InputEvent.META_DOWN_MASK,\n+        InputEvent.ALT_GRAPH_DOWN_MASK,\n+    };\n+    *\/\n+    DragGestureEvent getDragGestureEvent() {\n+         java.util.Vector vector = new java.util.Vector();\n+         vector.add(new java.lang.Integer(0));\n+         return new DragGestureEvent(new DummyDGRecognizer(ds, new Button()),\n+                                     actions[1],\n+                                     new java.awt.Point(0,0),\n+                                     vector);\n+    }\n+    DragGestureEvent dge = getDragGestureEvent();\n+\n+    DragSourceContext dsc = new DragSourceContext(dge,\n+                                                  cursors[0],\n+                                                  image,\n+                                                  point,\n+                                                  transferable,\n+                                                  dsl);\n+\n+    public static void main(String[] args) {\n+        new DragSourceDragEventModifiersTest().start();\n+    }\n+\n+    public void start() {\n+        try {\n+            \/\/ valid modifiers:\n+\n+            check(InputEvent.BUTTON1_MASK, InputEvent.BUTTON1_MASK,\n+                    InputEvent.BUTTON1_DOWN_MASK);\n+\n+            check(InputEvent.BUTTON1_MASK | InputEvent.SHIFT_MASK,\n+                    InputEvent.BUTTON1_MASK | InputEvent.SHIFT_MASK,\n+                    InputEvent.BUTTON1_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);\n+\n+            check(InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON1_MASK,\n+                    InputEvent.BUTTON1_DOWN_MASK);\n+\n+            check(InputEvent.BUTTON1_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK,\n+                    InputEvent.BUTTON1_MASK | InputEvent.SHIFT_MASK,\n+                    InputEvent.BUTTON1_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);\n+\n+            \/\/ invalid modifiers:\n+\n+            int invalidMods = 0;\n+            check(invalidMods, invalidMods, invalidMods);\n+\n+            invalidMods = InputEvent.BUTTON1_DOWN_MASK | InputEvent.SHIFT_MASK;\n+            check(invalidMods, invalidMods, invalidMods);\n+\n+            invalidMods = (InputEvent.ALT_GRAPH_DOWN_MASK << 1);\n+            check(invalidMods, invalidMods, invalidMods);\n+\n+            invalidMods = InputEvent.BUTTON1_DOWN_MASK\n+                    | (InputEvent.ALT_GRAPH_DOWN_MASK << 1);\n+            check(invalidMods, invalidMods, invalidMods);\n+\n+            invalidMods = InputEvent.BUTTON1_MASK\n+                    | (InputEvent.ALT_GRAPH_DOWN_MASK << 1);\n+            check(invalidMods, invalidMods, invalidMods);\n+\n+            invalidMods = InputEvent.BUTTON1_DOWN_MASK\n+                    | InputEvent.SHIFT_MASK\n+                    | (InputEvent.ALT_GRAPH_DOWN_MASK << 1);\n+            check(invalidMods, invalidMods, invalidMods);\n+\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+\n+        if (failed) {\n+            throw new RuntimeException(\"wrong behavior of \" +\n+                    \"DragSourceDragEvent.getModifiers[Ex](),\" +\n+                    \" see error messages above\");\n+        }\n+\n+        System.err.println(\"test passed!\");\n+    }\n+\n+    void check(int mods, int expectedMods, int expectedExMods) {\n+        System.err.println(\"testing DragSourceDragEvent \" +\n+                \"created with 1st constructor\");\n+        System.err.println(\"modifiers passed to the constructor: \"\n+                + Integer.toBinaryString(mods));\n+        verify(create1(mods), expectedMods, expectedExMods);\n+\n+        System.err.println(\"testing DragSourceDragEvent \" +\n+                \"created with 2nd constructor\");\n+        System.err.println(\"modifiers passed to the constructor: \"\n+                + Integer.toBinaryString(mods));\n+        verify(create2(mods), expectedMods, expectedExMods);\n+    }\n+\n+    void verify(DragSourceDragEvent dsde, int expectedMods, int expectedExMods) {\n+        if (dsde.getGestureModifiers() != expectedMods) {\n+            failed = true;\n+            System.err.print(\"ERROR: \");\n+        }\n+        System.err.println(\"getGestureModifiers() returned: \"\n+                + Integer.toBinaryString(dsde.getGestureModifiers()) +\n+                \" ; expected: \" + Integer.toBinaryString(expectedMods));\n+\n+        if (dsde.getGestureModifiersEx() != expectedExMods) {\n+            failed = true;\n+            System.err.print(\"ERROR: \");\n+        }\n+        System.err.println(\"getGestureModifiersEx() returned: \"\n+                + Integer.toBinaryString(dsde.getGestureModifiersEx()) +\n+                \" ; expected: \" + Integer.toBinaryString(expectedExMods));\n+\n+        System.err.println();\n+    }\n+\n+    DragSourceDragEvent create1(int mods) {\n+        return new DragSourceDragEvent(dsc, actions[0], actions[0], mods);\n+    }\n+\n+    DragSourceDragEvent create2(int mods) {\n+        return new DragSourceDragEvent(dsc, actions[0], actions[0], mods, 0, 0);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DragSourceDragEventModifiersTest.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4888520\n+  @summary tests that drag source application invoked via debug java does not\n+           crash on exit after drop on other Java drop target application\n+  @key headful\n+*\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceAdapter;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetAdapter;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.Reader;\n+\n+\n+public class DragSourceGCrashTest {\n+\n+    volatile Frame frame;\n+    volatile Panel panel;\n+\n+    public static void main(String[] args) throws Exception {\n+        DragSourceGCrashTest test = new DragSourceGCrashTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(()-> test.frame.dispose());\n+        }\n+    }\n+\n+    public void init() {\n+        frame = new Frame(\"target - DragSourceGCrashTest\");\n+        panel = new Panel();\n+        frame.add(panel);\n+        frame.setBounds(100, 100, 100, 100);\n+\n+        DropTargetListener dtl = new DropTargetAdapter() {\n+            public void drop(DropTargetDropEvent dtde) {\n+                dtde.acceptDrop(DnDConstants.ACTION_MOVE);\n+                Transferable t = dtde.getTransferable();\n+                try {\n+                    DataFlavor df = new DataFlavor(\n+                            \"text\/plain;class=java.io.Reader\");\n+                    Reader r = df.getReaderForText(t);\n+                    \/\/ To verify the bug do not close the reader!\n+                    dtde.dropComplete(true);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                    dtde.dropComplete(false);\n+                }\n+            }\n+        };\n+\n+        new DropTarget(frame, dtl);\n+\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() throws Exception {\n+        Robot robot = new Robot();\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+\n+        ProcessResults pres = null;\n+\n+        Point endPoint = panel.getLocationOnScreen();\n+\n+        endPoint.translate(panel.getWidth() \/ 2, panel.getHeight() \/ 2);\n+\n+        String jdkPath = System.getProperty(\"java.home\");\n+        String javaPath = jdkPath + File.separator + \"bin\" +\n+                File.separator + \"java\";\n+\n+        String[] cmd = {\n+                javaPath, \"-cp\",\n+                System.getProperty(\"test.classes\", \".\"),\n+                \"Child\",\n+                String.valueOf(endPoint.x),\n+                String.valueOf(endPoint.y)\n+        };\n+        Process process = Runtime.getRuntime().exec(cmd);\n+        pres = ProcessResults.doWaitFor(process);\n+\n+        if (pres.stderr != null && pres.stderr.length() > 0) {\n+            System.err.println(\"========= Child VM System.err ========\");\n+            System.err.print(pres.stderr);\n+            System.err.println(\"======================================\");\n+        }\n+\n+        if (pres.stdout != null && pres.stdout.length() > 0) {\n+            System.err.println(\"========= Child VM System.out ========\");\n+            System.err.print(pres.stdout);\n+            System.err.println(\"======================================\");\n+        }\n+\n+        if (pres.exitValue != 0) {\n+            throw new RuntimeException(\"FAILURE: child java exited \" +\n+                                       \"with code \" + pres.exitValue);\n+        }\n+    }\n+}\n+\n+class Child {\n+    volatile Frame frame;\n+    volatile Panel panel;\n+\n+    public static void main(String[] args) throws Exception {\n+        int endX = Integer.parseInt(args[0]);\n+        int endY = Integer.parseInt(args[1]);\n+        Point endPoint = new Point(endX, endY);\n+\n+        Child child = new Child();\n+        EventQueue.invokeAndWait(child::init);\n+        try {\n+            child.start(endPoint);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> child.frame.dispose());\n+        }\n+    }\n+\n+    public void init() {\n+        frame = new Frame(\"source - DragSourceGCrashTest\");\n+        panel = new Panel();\n+        frame.add(panel);\n+        frame.setBounds(200, 100, 100, 100);\n+\n+        final DragSourceListener dsl = new DragSourceAdapter() {\n+            public void dragDropEnd(DragSourceDropEvent dsde) {\n+                System.err.println(\"DragSourceListener.dragDropEnd(): \" +\n+                        \"exiting application\");\n+                System.exit(0);\n+            }\n+        };\n+        DragGestureListener dgl = new DragGestureListener() {\n+            public void dragGestureRecognized(DragGestureEvent dge) {\n+                dge.startDrag(null,\n+                        new StringSelection(\"test\"), dsl);\n+            }\n+        };\n+\n+        new DragSource().createDefaultDragGestureRecognizer(panel,\n+                DnDConstants.ACTION_MOVE, dgl);\n+\n+        frame.setVisible(true);\n+    }\n+\n+    public void start(Point endPoint) throws Exception {\n+        Robot robot = new Robot();\n+\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+\n+        Point startPoint = panel.getLocationOnScreen();\n+\n+        startPoint.translate(\n+                panel.getWidth() \/ 2,\n+                panel.getHeight() \/ 2\n+        );\n+\n+        robot.mouseMove(startPoint.x, startPoint.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        for (Point p = new Point(startPoint); !p.equals(endPoint);\n+             p.translate(\n+                     Integer.compare(endPoint.x - p.x, 0),\n+                     Integer.compare(endPoint.y - p.y, 0)\n+             )) {\n+            robot.mouseMove(p.x, p.y);\n+            robot.delay(50);\n+        }\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        long timeout = 30000;\n+        Object LOCK = new Object();\n+        synchronized (LOCK) {\n+            LOCK.wait(timeout);\n+            System.err.println(System.currentTimeMillis() + \" end\");\n+        }\n+        System.err.println(\"WARNING: drop has not ended within \" + timeout +\n+                \" ms, exiting application!\");\n+        System.exit(0);\n+    }\n+}\n+\n+class ProcessResults {\n+    final static long TIMEOUT = 60000;\n+\n+    public int exitValue;\n+    public String stdout;\n+    public String stderr;\n+\n+    public ProcessResults() {\n+        exitValue = -1;\n+        stdout = \"\";\n+        stderr = \"\";\n+    }\n+\n+    \/**\n+     * Method to perform a \"wait\" for a process and return its exit value.\n+     * This is a workaround for <code>Process.waitFor()<\/code> never returning.\n+     *\/\n+    public static ProcessResults doWaitFor(Process p) {\n+        ProcessResults pres = new ProcessResults();\n+\n+        InputStream in = null;\n+        InputStream err = null;\n+\n+        long startTime = System.currentTimeMillis();\n+\n+        try {\n+            in = p.getInputStream();\n+            err = p.getErrorStream();\n+\n+            boolean finished = false;\n+\n+            while (!finished) {\n+                try {\n+                    while (in.available() > 0) {\n+                        pres.stdout += (char)in.read();\n+                    }\n+                    while (err.available() > 0) {\n+                        pres.stderr += (char)err.read();\n+                    }\n+                    \/\/ Ask the process for its exitValue. If the process\n+                    \/\/ is not finished, an IllegalThreadStateException\n+                    \/\/ is thrown. If it is finished, we fall through and\n+                    \/\/ the variable finished is set to true.\n+                    pres.exitValue = p.exitValue();\n+                    finished  = true;\n+                }\n+                catch (IllegalThreadStateException e) {\n+                    if (System.currentTimeMillis() > startTime + TIMEOUT) {\n+                         System.err.println(\"WARNING: child process has not \" +\n+                                 \"exited within \" + TIMEOUT + \" ms, returning\" +\n+                                 \" from ProcessResults.doWaitFor()\");\n+                         pres.exitValue = 0;\n+                         return pres;\n+                    }\n+                    \/\/ Process is not finished yet;\n+                    \/\/ Sleep a little to save on CPU cycles\n+                    Thread.currentThread().sleep(500);\n+                }\n+            }\n+            if (in != null) in.close();\n+            if (err != null) err.close();\n+        }\n+        catch (Throwable e) {\n+            System.err.println(\"doWaitFor(): unexpected exception\");\n+            e.printStackTrace();\n+        }\n+        return pres;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DragSourceGCrashTest.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"}]}