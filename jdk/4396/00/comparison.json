{"files":[{"patch":"@@ -2401,0 +2401,5 @@\n+\n+            @Override\n+            public void exit(int statusCode) {\n+                Shutdown.exit(statusCode);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1515,0 +1515,5 @@\n+\n+            @Override\n+            public Class<?>[] exceptionTypes(MethodHandle handle) {\n+                return VarHandles.exceptionTypes(handle);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-    private static Class<?>[] exceptionTypes(MethodHandle handle) {\n+    static Class<?>[] exceptionTypes(MethodHandle handle) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,0 +398,6 @@\n+\n+    \/**\n+     * Direct access to Shutdown.exit to avoid security manager checks\n+     * @param statusCode the status code\n+     *\/\n+    void exit(int statusCode);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,0 +142,7 @@\n+\n+    \/**\n+     * A best-effort method that tries to find any exceptions thrown by the given method handle.\n+     * @param handle the handle to check\n+     * @return an array of exceptions, or {@code null}.\n+     *\/\n+    Class<?>[] exceptionTypes(MethodHandle handle);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -217,1 +217,2 @@\n-     * <p>The returned memory address is associated with the provided scope. When such scope is closed,\n+     * <p>\n+     * The returned memory address is associated with the provided scope. When such scope is closed,\n@@ -219,0 +220,3 @@\n+     * <p>\n+     * The target method handle should not throw any exceptions. If the target method handle does throw an exception,\n+     * the VM will exit with a non-zero exit code.\n@@ -224,1 +228,2 @@\n-     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch.\n+     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch, or\n+     *         if it is determined that the target method handle can throw an exception.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n+import sun.security.action.GetPropertyAction;\n@@ -31,0 +31,1 @@\n+import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n@@ -41,2 +42,2 @@\n-        String arch = System.getProperty(\"os.arch\");\n-        String os = System.getProperty(\"os.name\");\n+        String arch = privilegedGetProperty(\"os.arch\");\n+        String os = privilegedGetProperty(\"os.name\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -298,0 +298,3 @@\n+        } catch(Throwable t) {\n+            SharedUtils.handleUncaughtException(t);\n+            return null;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -54,0 +57,1 @@\n+import java.util.Arrays;\n@@ -76,0 +80,3 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n@@ -83,0 +90,1 @@\n+    private static final MethodHandle MH_HANDLE_UNCAUGHT_EXCEPTION;\n@@ -101,0 +109,2 @@\n+            MH_HANDLE_UNCAUGHT_EXCEPTION = lookup.findStatic(SharedUtils.class, \"handleUncaughtException\",\n+                    methodType(void.class, Throwable.class));\n@@ -364,0 +374,7 @@\n+    static void handleUncaughtException(Throwable t) {\n+        if (t != null) {\n+            t.printStackTrace();\n+            JLA.exit(1);\n+        }\n+    }\n+\n@@ -371,1 +388,5 @@\n-            closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            if (!upcall) {\n+                closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            } else {\n+                closer = MH_HANDLE_UNCAUGHT_EXCEPTION;\n+            }\n@@ -417,0 +438,7 @@\n+    public static void checkExceptions(MethodHandle target) {\n+        Class<?>[] exceptions = JLIA.exceptionTypes(target);\n+        if (exceptions != null && exceptions.length != 0) {\n+            throw new IllegalArgumentException(\"Target handle may throw exceptions: \" + Arrays.toString(exceptions));\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build ThrowingUpcall TestUpcallException\n+ *\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   TestUpcallException\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.test.lib.Utils;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestUpcallException {\n+\n+    @Test\n+    public void testExceptionInterpreted() throws InterruptedException, IOException {\n+        boolean useSpec = false;\n+        run(useSpec);\n+    }\n+\n+    @Test\n+    public void testExceptionSpecialized() throws IOException, InterruptedException {\n+        boolean useSpec = true;\n+        run(useSpec);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Target handle may throw exceptions.*\")\n+    public void testEagerExceptionBlocked() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            CLinker.getInstance().upcallStub(ThrowingUpcall.MH_throwException, FunctionDescriptor.ofVoid(), scope);\n+        }\n+    }\n+\n+    private void run(boolean useSpec) throws IOException, InterruptedException {\n+        Process process = new ProcessBuilder()\n+            .command(\n+                Paths.get(Utils.TEST_JDK)\n+                     .resolve(\"bin\")\n+                     .resolve(\"java\")\n+                     .toAbsolutePath()\n+                     .toString(),\n+                \"--add-modules\", \"jdk.incubator.foreign\",\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                \"-Djava.library.path=\" + System.getProperty(\"java.library.path\"),\n+                \"-Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=\" + useSpec,\n+                \"-cp\", Utils.TEST_CLASS_PATH,\n+                \/\/ security manager to block normal System.exit\n+                \"-Djava.security.manager=allow\",\n+                \"ThrowingUpcall\")\n+            .start();\n+\n+        int result = process.waitFor();\n+        assertNotEquals(result, 0);\n+\n+        List<String> outLines = linesFromStream(process.getInputStream());\n+        outLines.forEach(System.out::println);\n+        List<String> errLines = linesFromStream(process.getErrorStream());\n+        errLines.forEach(System.err::println);\n+\n+        \/\/ Exception message would be found in stack trace\n+        String shouldInclude = \"Testing upcall exceptions\";\n+        assertTrue(linesContain(errLines, shouldInclude), \"Did not find '\" + shouldInclude + \"' in stderr\");\n+\n+        \/\/ If the VM crashes with an uncaught IllegalStateException from the security manager\n+        \/\/ the crash log should include the exception message.\n+        \/\/ Make sure that is _not_ the case.\n+        String shouldNotInclude = \"Can not use exitVM\";\n+        assertFalse(linesContain(outLines, shouldNotInclude), \"Found '\" + shouldNotInclude + \"' in stdout\");\n+    }\n+\n+    private boolean linesContain(List<String> errLines, String shouldInclude) {\n+        return errLines.stream().anyMatch(line -> line.contains(shouldInclude));\n+    }\n+\n+    private static List<String> linesFromStream(InputStream stream) throws IOException {\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {\n+            return reader.lines().toList();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.security.Permission;\n+\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+public class ThrowingUpcall {\n+\n+    private static final MethodHandle downcall;\n+    public static final MethodHandle MH_throwException;\n+\n+    static {\n+        System.setSecurityManager(new SecurityManager() {\n+            @Override\n+            public void checkExit(int status) {\n+                throw new IllegalStateException(\"Can not use exitVM\");\n+            }\n+\n+            @Override\n+            public void checkPermission(Permission perm) {\n+                \/\/ do nothing\n+            }\n+        });\n+\n+        System.loadLibrary(\"TestUpcall\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+        downcall = CLinker.getInstance().downcallHandle(\n+            lookup.lookup(\"f0_V__\").orElseThrow(),\n+            MethodType.methodType(void.class, MemoryAddress.class),\n+            FunctionDescriptor.ofVoid(C_POINTER)\n+        );\n+\n+        try {\n+            MH_throwException = MethodHandles.lookup().findStatic(ThrowingUpcall.class, \"throwException\",\n+                    MethodType.methodType(void.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static void throwException() throws Throwable {\n+        throw new Throwable(\"Testing upcall exceptions\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        test();\n+    }\n+\n+    public static void test() throws Throwable {\n+        MethodHandle handle = MH_throwException;\n+        MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(void.class));\n+        handle = MethodHandles.insertArguments(invoker, 0, handle);\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress stub = CLinker.getInstance().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+\n+            downcall.invokeExact(stub); \/\/ should call Shutdown.exit(1);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}