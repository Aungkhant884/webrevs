{"files":[{"patch":"@@ -2858,5 +2858,4 @@\n-      RegMask rm = n->out_RegMask();\/\/ Make local copy\n-      while( rm.is_NotEmpty() ) {\n-        OptoReg::Name kill = rm.find_first_elem();\n-        rm.Remove(kill);\n-        verify_do_def( n, kill, msg );\n+      RegMaskIterator rmi(n->out_RegMask());\n+      while (rmi.has_next()) {\n+        OptoReg::Name kill = rmi.next();\n+        verify_do_def(n, kill, msg);\n@@ -3049,5 +3048,4 @@\n-      RegMask rm = n->out_RegMask();\/\/ Make local copy\n-      while( rm.is_NotEmpty() ) {\n-        OptoReg::Name kill = rm.find_first_elem();\n-        rm.Remove(kill);\n-        anti_do_def( b, n, kill, is_def );\n+      RegMaskIterator rmi(n->out_RegMask());\n+      while (rmi.has_next()) {\n+        OptoReg::Name kill = rmi.next();\n+        anti_do_def(b, n, kill, is_def);\n@@ -3068,5 +3066,4 @@\n-          RegMask rm = use->out_RegMask();\/\/ Make local copy\n-          while( rm.is_NotEmpty() ) {\n-            OptoReg::Name kill = rm.find_first_elem();\n-            rm.Remove(kill);\n-            anti_do_def( b, n, kill, false );\n+          RegMaskIterator rmi(use->out_RegMask());\n+          while (rmi.has_next()) {\n+            OptoReg::Name kill = rmi.next();\n+            anti_do_def(b, n, kill, false);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -787,9 +787,6 @@\n-      if( n_ideal_reg == MachProjNode::fat_proj ) {\n-        RegMask rm = n->out_RegMask();\n-        \/\/ wow, what an expensive iterator...\n-        nreg = rm.find_first_elem();\n-        while( OptoReg::is_valid(nreg)) {\n-          rm.Remove(nreg);\n-          value.map(nreg,n);\n-          regnd.map(nreg,n);\n-          nreg = rm.find_first_elem();\n+      if (n_ideal_reg == MachProjNode::fat_proj) {\n+        RegMaskIterator rmi(n->out_RegMask());\n+        while (rmi.has_next()) {\n+          nreg = rmi.next();\n+          value.map(nreg, n);\n+          regnd.map(nreg, n);\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -358,1 +358,0 @@\n-  RegMask rm = *this;           \/\/ Structure copy into local temp\n@@ -360,3 +359,4 @@\n-  OptoReg::Name start = rm.find_first_elem(); \/\/ Get a register\n-  if (OptoReg::is_valid(start)) { \/\/ Check for empty mask\n-    rm.Remove(start);           \/\/ Yank from mask\n+  RegMaskIterator rmi(*this);\n+  if (rmi.has_next()) {\n+    OptoReg::Name start = rmi.next();\n+\n@@ -369,5 +369,2 @@\n-    while (1) {                 \/\/\n-      OptoReg::Name reg = rm.find_first_elem(); \/\/ Get a register\n-      if (!OptoReg::is_valid(reg))\n-        break;                  \/\/ Empty mask, end loop\n-      rm.Remove(reg);           \/\/ Yank from mask\n+    while (rmi.has_next()) {\n+      OptoReg::Name reg = rmi.next(); \/\/ Get a register\n@@ -375,1 +372,1 @@\n-      if (last+1 == reg) {      \/\/ See if they are adjacent\n+      if (last + 1 == reg) {      \/\/ See if they are adjacent\n@@ -401,1 +398,1 @@\n-    if (rm.is_AllStack()) st->print(\"...\");\n+    if (is_AllStack()) st->print(\"...\");\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+  friend class RegMaskIterator;\n+\n@@ -365,0 +367,44 @@\n+class RegMaskIterator {\n+ private:\n+  uintptr_t _current_word;\n+  unsigned int _next_index;\n+  OptoReg::Name _reg;\n+  const RegMask&  _rm;\n+ public:\n+  RegMaskIterator(const RegMask& rm) : _current_word(0), _next_index(rm._lwm), _reg(OptoReg::Special), _rm(rm) {\n+    \/\/ Calculate the first element\n+    next();\n+  }\n+\n+  bool has_next() {\n+    return _reg != OptoReg::Bad;\n+  }\n+\n+  \/\/ Get the current element and calculate the next\n+  OptoReg::Name next() {\n+    OptoReg::Name r = _reg;\n+    if (_current_word != 0) {\n+      unsigned int next_bit = find_lowest_bit(_current_word);\n+      assert(next_bit > 0, \"must be\");\n+      assert(((_current_word >> next_bit) & 0x1) == 1, \"sanity\");\n+      _current_word = (_current_word >> next_bit) - 1;\n+      _reg = OptoReg::add(_reg, next_bit);\n+      return r;\n+    }\n+\n+    while (_next_index <= _rm._hwm) {\n+      _current_word = _rm._RM_UP[_next_index++];\n+      if (_current_word != 0) {\n+        unsigned int next_bit = find_lowest_bit(_current_word);\n+        assert(((_current_word >> next_bit) & 0x1) == 1, \"sanity\");\n+        _current_word = (_current_word >> next_bit) - 1;\n+        _reg = OptoReg::Name(((_next_index - 1) << RegMask::_LogWordBits) + next_bit);\n+        return r;\n+      }\n+    }\n+\n+    _reg = OptoReg::Name(OptoReg::Bad);\n+    return r;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"}]}