{"files":[{"patch":"@@ -4185,0 +4185,12 @@\n+    \/\/ Determine types\n+    const TypeVect* vec_t = last_ur->vect_type();\n+    uint vector_length    = vec_t->length();\n+    BasicType bt          = vec_t->element_basic_type();\n+    const Type* bt_t      = Type::get_const_basic_type(bt);\n+\n+    if (!last_ur->make_normal_vector_op_implemented(vec_t)) {\n+        DEBUG_ONLY( last_ur->dump(); )\n+        assert(false, \"do not have normal vector op for this reduction\");\n+        continue; \/\/ not implemented -> fails\n+    }\n+\n@@ -4216,2 +4228,0 @@\n-          DEBUG_ONLY( current->dump(-1); )\n-          assert(false, \"reduction (not last) has more than one use\");\n@@ -4245,6 +4255,0 @@\n-    \/\/ Determine types\n-    const TypeVect* vec_t = last_ur->vect_type();\n-    uint vector_length    = vec_t->length();\n-    BasicType bt          = vec_t->element_basic_type();\n-    const Type* bt_t      = Type::get_const_basic_type(bt);\n-\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) = 0;\n@@ -255,0 +256,3 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n+    return Matcher::match_rule_supported_vector(Op_AddVI, vt->length(), vt->element_basic_type());\n+  }\n@@ -266,0 +270,3 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n+    return Matcher::match_rule_supported_vector(Op_AddVL, vt->length(), vt->element_basic_type());\n+  }\n@@ -429,0 +436,3 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n+    return Matcher::match_rule_supported_vector(Op_MulVI, vt->length(), vt->element_basic_type());\n+  }\n@@ -440,0 +450,3 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n+    return Matcher::match_rule_supported_vector(Op_MulVL, vt->length(), vt->element_basic_type());\n+  }\n@@ -786,0 +799,3 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n+    return Matcher::match_rule_supported_vector(Op_AndV, vt->length(), vt->element_basic_type());\n+  }\n@@ -806,0 +822,3 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n+    return Matcher::match_rule_supported_vector(Op_OrV, vt->length(), vt->element_basic_type());\n+  }\n@@ -826,0 +845,3 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n+    return Matcher::match_rule_supported_vector(Op_XorV, vt->length(), vt->element_basic_type());\n+  }\n@@ -837,0 +859,3 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n+    return Matcher::match_rule_supported_vector(Op_MinV, vt->length(), vt->element_basic_type());\n+  }\n@@ -848,0 +873,3 @@\n+  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n+    return Matcher::match_rule_supported_vector(Op_MaxV, vt->length(), vt->element_basic_type());\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8302652\n+ * @summary Special test cases for PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestUnorderedReduction\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestUnorderedReduction {\n+    static final int RANGE = 1024;\n+    static final int ITER  = 10;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-Xbatch\",\n+                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestUnorderedReduction::test*\",\n+                                   \"-XX:MaxVectorSize=16\");\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\"})\n+    @Warmup(0)\n+    public void runTests() throws Exception {\n+        int[] data = new int[RANGE];\n+\n+\tinit(data);\n+        for (int i = 0; i < ITER; i++) {\n+            int r1 = test1(data, i);\n+            int r2 = ref1(data, i);\n+            if (r1 != r2) {\n+                throw new RuntimeException(\"Wrong result test1: \" + r1 + \" != \" + r2);\n+            }\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            int r1 = test2(data, i);\n+            int r2 = ref2(data, i);\n+            if (r1 != r2) {\n+                throw new RuntimeException(\"Wrong result test2: \" + r1 + \" != \" + r2);\n+            }\n+        }\n+    }\n+ \n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\",\n+                  IRNode.ADD_VI, \"= 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\"}, \/\/ count can be high\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static int test1(int[] data, int sum) {\n+        \/\/ Vectorizes, but the UnorderedReduction cannot be moved out of the loop,\n+        \/\/ because we have a use inside the loop.\n+        int x = 0;\n+        for (int i = 0; i < RANGE; i+=8) {\n+            sum += 11 * data[i+0]; \/\/ vec 1 (16 bytes)\n+            sum += 11 * data[i+1];\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            x = sum + i; \/\/ vec 1 reduction has more than 1 use\n+            sum += 11 * data[i+4]; \/\/ vec 2 (next 16 bytes)\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum + x;\n+    }\n+\n+    static int ref1(int[] data, int sum) {\n+        int x = 0;\n+        for (int i = 0; i < RANGE; i+=8) {\n+            sum += 11 * data[i+0];\n+            sum += 11 * data[i+1];\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            x = sum + i;\n+            sum += 11 * data[i+4];\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum + x;\n+    }\n+ \n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"<= 2\"}, \/\/ count must be low\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static int test2(int[] data, int sum) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Vectorized, and UnorderedReduction moved outside loop.\n+            sum += 11 * data[i+0]; \/\/ vec 1\n+            sum += 11 * data[i+1];\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            sum += 11 * data[i+4]; \/\/ vec 2\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum;\n+    }\n+\n+    static int ref2(int[] data, int sum) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            sum += 11 * data[i+0];\n+            sum += 11 * data[i+1];\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            sum += 11 * data[i+4];\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum;\n+    }\n+\n+\n+    static void init(int[] data) {\n+        for (int i = 0; i < RANGE; i++) {\n+            data[i] = i + 1;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReduction.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"}]}