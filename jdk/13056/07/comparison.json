{"files":[{"patch":"@@ -2847,6 +2847,1 @@\n-#ifdef ASSERT\n-      if (TraceNewVectors) {\n-        tty->print(\"new Vector node: \");\n-        macro_logic->dump();\n-      }\n-#endif\n+      VectorNode::trace_new_vector(macro_logic, \"MacroLogic\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4631,0 +4631,10 @@\n+\n+  \/\/ Move UnorderedReduction out of counted loop. Can be introduced by SuperWord.\n+  if (C->has_loops() && !C->major_progress()) {\n+    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+      IdealLoopTree* lpt = iter.current();\n+      if (lpt->is_counted() && lpt->is_innermost()) {\n+        move_unordered_reduction_out_of_loop(lpt);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1487,0 +1487,3 @@\n+  \/\/ Move UnorderedReduction out of loop if possible\n+  void move_unordered_reduction_out_of_loop(IdealLoopTree* loop);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -4123,0 +4124,185 @@\n+\n+\/\/ Having ReductionNodes in the loop is expensive. They need to recursively\n+\/\/ fold together the vector values, for every vectorized loop iteration. If\n+\/\/ we encounter the following pattern, we can vector accumulate the values\n+\/\/ inside the loop, and only have a single UnorderedReduction after the loop.\n+\/\/\n+\/\/ CountedLoop     init\n+\/\/          |        |\n+\/\/          +------+ | +-----------------------+\n+\/\/                 | | |                       |\n+\/\/                PhiNode (s)                  |\n+\/\/                  |                          |\n+\/\/                  |          Vector          |\n+\/\/                  |            |             |\n+\/\/               UnorderedReduction (first_ur) |\n+\/\/                  |                          |\n+\/\/                 ...         Vector          |\n+\/\/                  |            |             |\n+\/\/               UnorderedReduction (last_ur)  |\n+\/\/                       |                     |\n+\/\/                       +---------------------+\n+\/\/\n+\/\/ We patch the graph to look like this:\n+\/\/\n+\/\/ CountedLoop   identity_vector\n+\/\/         |         |\n+\/\/         +-------+ | +---------------+\n+\/\/                 | | |               |\n+\/\/                PhiNode (v)          |\n+\/\/                   |                 |\n+\/\/                   |         Vector  |\n+\/\/                   |           |     |\n+\/\/                 VectorAccumulator   |\n+\/\/                   |                 |\n+\/\/                  ...        Vector  |\n+\/\/                   |           |     |\n+\/\/      init       VectorAccumulator   |\n+\/\/        |          |     |           |\n+\/\/     UnorderedReduction  +-----------+\n+\/\/\n+\/\/ We turned the scalar (s) Phi into a vectorized one (v). In the loop, we\n+\/\/ use vector_accumulators, which do the same reductions, but only element\n+\/\/ wise. This is a single operation per vector_accumulator, rather than many\n+\/\/ for a UnorderedReduction. We can then reduce the last vector_accumulator\n+\/\/ after the loop, and also reduce the init value into it.\n+\/\/ We can not do this with all reductions. Some reductions do not allow the\n+\/\/ reordering of operations (for example float addition).\n+void PhaseIdealLoop::move_unordered_reduction_out_of_loop(IdealLoopTree* loop) {\n+  assert(!C->major_progress() && loop->is_counted() && loop->is_innermost(), \"sanity\");\n+\n+  \/\/ Find all Phi nodes with UnorderedReduction on backedge.\n+  CountedLoopNode* cl = loop->_head->as_CountedLoop();\n+  for (DUIterator_Fast jmax, j = cl->fast_outs(jmax); j < jmax; j++) {\n+    Node* phi = cl->fast_out(j);\n+    \/\/ We have a phi with a single use, and a UnorderedReduction on the backedge.\n+    if (!phi->is_Phi() || phi->outcnt() != 1 || !phi->in(2)->is_UnorderedReduction()) {\n+      continue;\n+    }\n+\n+    UnorderedReductionNode* last_ur = phi->in(2)->as_UnorderedReduction();\n+\n+    \/\/ Determine types\n+    const TypeVect* vec_t = last_ur->vect_type();\n+    uint vector_length    = vec_t->length();\n+    BasicType bt          = vec_t->element_basic_type();\n+    const Type* bt_t      = Type::get_const_basic_type(bt);\n+\n+    \/\/ Convert opcode from vector-reduction -> scalar -> normal-vector-op\n+    const int sopc        = VectorNode::scalar_opcode(last_ur->Opcode(), bt);\n+    const int vopc        = VectorNode::opcode(sopc, bt);\n+    if (!Matcher::match_rule_supported_vector(vopc, vector_length, bt)) {\n+        DEBUG_ONLY( last_ur->dump(); )\n+        assert(false, \"do not have normal vector op for this reduction\");\n+        continue; \/\/ not implemented -> fails\n+    }\n+\n+    \/\/ Traverse up the chain of UnorderedReductions, checking that it loops back to\n+    \/\/ the phi. Check that all UnorderedReductions only have a single use, except for\n+    \/\/ the last (last_ur), which only has phi as a use in the loop, and all other uses\n+    \/\/ are outside the loop.\n+    UnorderedReductionNode* current = last_ur;\n+    UnorderedReductionNode* first_ur = nullptr;\n+    while (true) {\n+      assert(current->is_UnorderedReduction(), \"sanity\");\n+\n+      \/\/ Expect no ctrl and a vector_input from within the loop.\n+      Node* ctrl = current->in(0);\n+      Node* vector_input = current->in(2);\n+      if (ctrl != nullptr || get_ctrl(vector_input) != cl) {\n+        DEBUG_ONLY( current->dump(1); )\n+        assert(false, \"reduction has ctrl or bad vector_input\");\n+        break; \/\/ Chain traversal fails.\n+      }\n+\n+      \/\/ Expect single use of UnorderedReduction, except for last_ur.\n+      if (current == last_ur) {\n+        \/\/ Expect all uses to be outside the loop, except phi.\n+        for (DUIterator_Fast kmax, k = current->fast_outs(kmax); k < kmax; k++) {\n+          Node* use = current->fast_out(k);\n+          if (use != phi && ctrl_or_self(use) == cl) {\n+            DEBUG_ONLY( current->dump(-1); )\n+            assert(false, \"reduction has use inside loop\");\n+            break; \/\/ Chain traversal fails.\n+          }\n+        }\n+      } else {\n+        if (current->outcnt() != 1) {\n+          break; \/\/ Chain traversal fails.\n+        }\n+      }\n+\n+      \/\/ Expect another UnorderedReduction or phi as the scalar input.\n+      Node* scalar_input = current->in(1);\n+      if (scalar_input->is_UnorderedReduction() &&\n+          scalar_input->Opcode() == current->Opcode()) {\n+        \/\/ Move up the UnorderedReduction chain.\n+        current = scalar_input->as_UnorderedReduction();\n+      } else if (scalar_input == phi) {\n+        \/\/ Chain terminates at phi.\n+        first_ur = current;\n+        current = nullptr;\n+        break; \/\/ Success.\n+      } else {\n+        DEBUG_ONLY( current->dump(1); )\n+        assert(false, \"scalar_input is neither phi nor a matchin reduction\");\n+        break; \/\/ Chain traversal fails.\n+      }\n+    }\n+    if (current != nullptr) {\n+      \/\/ Chain traversal was not successful.\n+      continue;\n+    }\n+    assert(first_ur != nullptr, \"must have successfully terminated chain traversal\");\n+\n+    Node* identity_scalar = ReductionNode::make_identity_con_scalar(_igvn, sopc, bt);\n+    set_ctrl(identity_scalar, C->root());\n+    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt_t);\n+    register_new_node(identity_vector, C->root());\n+    assert(vec_t == identity_vector->vect_type(), \"matching vector type\");\n+    VectorNode::trace_new_vector(identity_vector, \"UnorderedReduction\");\n+\n+    \/\/ Turn the scalar phi into a vector phi.\n+    _igvn.rehash_node_delayed(phi);\n+    Node* init = phi->in(1); \/\/ Remember init before replacing it.\n+    phi->set_req_X(1, identity_vector, &_igvn);\n+    phi->as_Type()->set_type(vec_t);\n+    _igvn.set_type(phi, vec_t);\n+\n+    \/\/ Traverse down the chain of UnorderedReductions, and replace them with vector_accumulators.\n+    current = first_ur;\n+    while (true) {\n+      \/\/ Create vector_accumulator to replace current.\n+      Node* last_vector_accumulator = current->in(1);\n+      Node* vector_input            = current->in(2);\n+      VectorNode* vector_accumulator = VectorNode::make(vopc, last_vector_accumulator, vector_input, vec_t);\n+      register_new_node(vector_accumulator, cl);\n+      _igvn.replace_node(current, vector_accumulator);\n+      VectorNode::trace_new_vector(vector_accumulator, \"UnorderedReduction\");\n+      if (current == last_ur) {\n+        break;\n+      }\n+      current = vector_accumulator->unique_out()->as_UnorderedReduction();\n+    }\n+\n+    \/\/ Create post-loop reduction.\n+    Node* last_accumulator = phi->in(2);\n+    Node* post_loop_reduction = ReductionNode::make(sopc, nullptr, init, last_accumulator, bt);\n+\n+    \/\/ Take over uses of last_accumulator that are not in the loop.\n+    for (DUIterator i = last_accumulator->outs(); last_accumulator->has_out(i); i++) {\n+      Node* use = last_accumulator->out(i);\n+      if (use != phi && use != post_loop_reduction) {\n+        assert(ctrl_or_self(use) != cl, \"use must be outside loop\");\n+        use->replace_edge(last_accumulator, post_loop_reduction,  &_igvn);\n+        --i;\n+      }\n+    }\n+    register_new_node(post_loop_reduction, get_late_ctrl(post_loop_reduction, cl));\n+    VectorNode::trace_new_vector(post_loop_reduction, \"UnorderedReduction\");\n+\n+    assert(last_accumulator->outcnt() == 2, \"last_accumulator has 2 uses: phi and post_loop_reduction\");\n+    assert(post_loop_reduction->outcnt() > 0, \"should have taken over all non loop uses of last_accumulator\");\n+    assert(phi->outcnt() == 1, \"accumulator is the only use of phi\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+class ReductionNode;\n@@ -167,0 +168,1 @@\n+class UnorderedReductionNode;\n@@ -721,0 +723,2 @@\n+        DEFINE_CLASS_ID(Reduction, Vector, 7)\n+          DEFINE_CLASS_ID(UnorderedReduction, Reduction, 0)\n@@ -944,0 +948,1 @@\n+  DEFINE_CLASS_QUERY(Reduction)\n@@ -953,0 +958,1 @@\n+  DEFINE_CLASS_QUERY(UnorderedReduction)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3332,6 +3332,1 @@\n-#ifdef ASSERT\n-      if (TraceNewVectors) {\n-        tty->print(\"new Vector node: \");\n-        vn->dump();\n-      }\n-#endif\n+      VectorNode::trace_new_vector(vn, \"SuperWord\");\n@@ -3377,0 +3372,1 @@\n+\n@@ -3509,6 +3505,1 @@\n-#ifdef ASSERT\n-    if (TraceNewVectors) {\n-      tty->print(\"new Vector node: \");\n-      vn->dump();\n-    }\n-#endif\n+    VectorNode::trace_new_vector(vn, \"SuperWord\");\n@@ -3587,6 +3578,1 @@\n-#ifdef ASSERT\n-    if (TraceNewVectors) {\n-      tty->print(\"new Vector node: \");\n-      vn->dump();\n-    }\n-#endif\n+    VectorNode::trace_new_vector(vn, \"SuperWord\");\n@@ -3624,6 +3610,1 @@\n-#ifdef ASSERT\n-  if (TraceNewVectors) {\n-    tty->print(\"new Vector node: \");\n-    pk->dump();\n-  }\n-#endif\n+  VectorNode::trace_new_vector(pk, \"SuperWord\");\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1539,1 +1539,1 @@\n-  Node* init = ReductionNode::make_reduction_input(gvn(), opc, elem_bt);\n+  Node* init = ReductionNode::make_identity_con_scalar(gvn(), opc, elem_bt);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\/\/ and vector length.\n+\/\/ and basic type.\n@@ -277,0 +277,103 @@\n+\/\/ Return the scalar opcode for the specified vector opcode\n+\/\/ and basic type.\n+int VectorNode::scalar_opcode(int sopc, BasicType bt) {\n+  switch (sopc) {\n+    case Op_AddReductionVI:\n+    case Op_AddVI:\n+      return Op_AddI;\n+    case Op_AddReductionVL:\n+    case Op_AddVL:\n+      return Op_AddL;\n+    case Op_MulReductionVI:\n+    case Op_MulVI:\n+      return Op_MulI;\n+    case Op_MulReductionVL:\n+    case Op_MulVL:\n+      return Op_MulL;\n+    case Op_AndReductionV:\n+    case Op_AndV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_AndI;\n+        case T_LONG:\n+          return Op_AndL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    case Op_OrReductionV:\n+    case Op_OrV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_OrI;\n+        case T_LONG:\n+          return Op_OrL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    case Op_XorReductionV:\n+    case Op_XorV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_XorI;\n+        case T_LONG:\n+          return Op_XorL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    case Op_MinReductionV:\n+    case Op_MinV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+          assert(false, \"boolean and char are signed, not implemented for Min\");\n+          return 0;\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_MinI;\n+        case T_LONG:\n+          return Op_MinL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    case Op_MaxReductionV:\n+    case Op_MaxV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+          assert(false, \"boolean and char are signed, not implemented for Max\");\n+          return 0;\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_MaxI;\n+        case T_LONG:\n+          return Op_MaxL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    default:\n+      assert(false,\n+             \"Vector node %s is not handled in VectorNode::scalar_opcode\",\n+             NodeClassNames[sopc]);\n+      return 0; \/\/ Unimplemented\n+  }\n+}\n+\n@@ -1401,3 +1504,3 @@\n-Node* ReductionNode::make_reduction_input(PhaseGVN& gvn, int opc, BasicType bt) {\n-  int vopc = opcode(opc, bt);\n-  guarantee(vopc != opc, \"Vector reduction for '%s' is not implemented\", NodeClassNames[opc]);\n+Node* ReductionNode::make_identity_con_scalar(PhaseGVN& gvn, int sopc, BasicType bt) {\n+  int vopc = opcode(sopc, bt);\n+  guarantee(vopc != sopc, \"Vector reduction for '%s' is not implemented\", NodeClassNames[sopc]);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":107,"deletions":4,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"opto\/cfgnode.hpp\"\n+#include \"opto\/loopnode.hpp\"\n@@ -93,1 +95,2 @@\n-  static int  opcode(int opc, BasicType bt);\n+  static int opcode(int sopc, BasicType bt);         \/\/ scalar_opc -> vector_opc\n+  static int scalar_opcode(int vopc, BasicType bt);  \/\/ vector_opc -> scalar_opc\n@@ -133,0 +136,9 @@\n+\n+  static void trace_new_vector(Node* n, const char* context) {\n+#ifdef ASSERT\n+    if (TraceNewVectors) {\n+      tty->print(\"TraceNewVectors [%s]: \", context);\n+      n->dump();\n+    }\n+#endif\n+  }\n@@ -194,1 +206,3 @@\n-               _vect_type(in2->bottom_type()->is_vect()) {}\n+               _vect_type(in2->bottom_type()->is_vect()) {\n+    init_class_id(Class_Reduction);\n+  }\n@@ -196,1 +210,1 @@\n-  static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);\n+  static ReductionNode* make(int opc, Node* ctrl, Node* in1, Node* in2, BasicType bt);\n@@ -199,1 +213,2 @@\n-  static Node* make_reduction_input(PhaseGVN& gvn, int opc, BasicType bt);\n+  \/\/ Make an identity scalar (zero for add, one for mul, etc) for scalar opc.\n+  static Node* make_identity_con_scalar(PhaseGVN& gvn, int sopc, BasicType bt);\n@@ -219,0 +234,9 @@\n+\/\/---------------------------UnorderedReductionNode-------------------------------------\n+\/\/ Order of reduction does not matter. Example int add. Not true for float add.\n+class UnorderedReductionNode : public ReductionNode {\n+public:\n+  UnorderedReductionNode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {\n+    init_class_id(Class_UnorderedReduction);\n+  }\n+};\n+\n@@ -221,1 +245,1 @@\n-class AddReductionVINode : public ReductionNode {\n+class AddReductionVINode : public UnorderedReductionNode {\n@@ -223,1 +247,1 @@\n-  AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -229,1 +253,1 @@\n-class AddReductionVLNode : public ReductionNode {\n+class AddReductionVLNode : public UnorderedReductionNode {\n@@ -231,1 +255,1 @@\n-  AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -389,1 +413,1 @@\n-class MulReductionVINode : public ReductionNode {\n+class MulReductionVINode : public UnorderedReductionNode {\n@@ -391,1 +415,1 @@\n-  MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -397,1 +421,1 @@\n-class MulReductionVLNode : public ReductionNode {\n+class MulReductionVLNode : public UnorderedReductionNode {\n@@ -399,1 +423,1 @@\n-  MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -740,1 +764,1 @@\n-class AndReductionVNode : public ReductionNode {\n+class AndReductionVNode : public UnorderedReductionNode {\n@@ -742,1 +766,1 @@\n-  AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -757,9 +781,1 @@\n-class OrReductionVNode : public ReductionNode {\n- public:\n-  OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------XorReductionVNode--------------------------------------\n-\/\/ Vector and int, long as a reduction\n-class XorReductionVNode : public ReductionNode {\n+class OrReductionVNode : public UnorderedReductionNode {\n@@ -767,1 +783,1 @@\n-  XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -780,0 +796,8 @@\n+\/\/------------------------------XorReductionVNode--------------------------------------\n+\/\/ Vector and int, long as a reduction\n+class XorReductionVNode : public UnorderedReductionNode {\n+ public:\n+  XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -782,1 +806,1 @@\n-class MinReductionVNode : public ReductionNode {\n+class MinReductionVNode : public UnorderedReductionNode {\n@@ -784,1 +808,1 @@\n-  MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -790,1 +814,1 @@\n-class MaxReductionVNode : public ReductionNode {\n+class MaxReductionVNode : public UnorderedReductionNode {\n@@ -792,1 +816,1 @@\n-  MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":52,"deletions":28,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\"})\n+        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\", IRNode.MUL_REDUCTION_VI, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\"})\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\", IRNode.ADD_REDUCTION_VI, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -154,1 +154,1 @@\n-        counts = {IRNode.OR_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.OR_REDUCTION_V, \">= 1\", IRNode.OR_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -171,1 +171,1 @@\n-        counts = {IRNode.AND_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.AND_REDUCTION_V, \">= 1\", IRNode.AND_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -188,1 +188,1 @@\n-        counts = {IRNode.XOR_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.XOR_REDUCTION_V, \">= 1\", IRNode.XOR_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -205,1 +205,1 @@\n-        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\"})\n+        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\", IRNode.MUL_REDUCTION_VI, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/RedTest_int.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\"})\n+        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\", IRNode.ADD_REDUCTION_VL, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -157,1 +157,1 @@\n-        counts = {IRNode.OR_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.OR_REDUCTION_V, \">= 1\", IRNode.OR_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -174,1 +174,1 @@\n-        counts = {IRNode.AND_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.AND_REDUCTION_V, \">= 1\", IRNode.AND_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -191,1 +191,1 @@\n-        counts = {IRNode.XOR_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.XOR_REDUCTION_V, \">= 1\", IRNode.XOR_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -208,1 +208,1 @@\n-        counts = {IRNode.MUL_REDUCTION_VL, \">= 1\"})\n+        counts = {IRNode.MUL_REDUCTION_VL, \">= 1\", IRNode.MUL_REDUCTION_VL, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/RedTest_long.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -26,14 +26,8 @@\n- * @bug 8074981\n- * @summary Add C2 x86 Superword support for scalar product reduction optimizations : int test\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n- *      -XX:LoopUnrollLimit=250 -XX:CompileThresholdScaling=0.1\n- *      -XX:CompileCommand=exclude,compiler.loopopts.superword.ReductionPerf::main\n- *      -XX:+SuperWordReductions\n- *      compiler.loopopts.superword.ReductionPerf\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n- *      -XX:LoopUnrollLimit=250 -XX:CompileThresholdScaling=0.1\n- *      -XX:CompileCommand=exclude,compiler.loopopts.superword.ReductionPerf::main\n- *      -XX:-SuperWordReductions\n- *      compiler.loopopts.superword.ReductionPerf\n+ * @bug 8074981 8302652\n+ * @summary Test SuperWord Reduction Perf.\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.simpleArch == \"x86\" | vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -Xbatch -XX:LoopUnrollLimit=250\n+ *                   -XX:CompileCommand=exclude,compiler.loopopts.superword.ReductionPerf::main\n+ *                   compiler.loopopts.superword.ReductionPerf\n@@ -43,0 +37,2 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n@@ -45,74 +41,188 @@\n-    public static void main(String[] args) throws Exception {\n-        int[] a1 = new int[8 * 1024];\n-        int[] a2 = new int[8 * 1024];\n-        int[] a3 = new int[8 * 1024];\n-        long[] b1 = new long[8 * 1024];\n-        long[] b2 = new long[8 * 1024];\n-        long[] b3 = new long[8 * 1024];\n-        float[] c1 = new float[8 * 1024];\n-        float[] c2 = new float[8 * 1024];\n-        float[] c3 = new float[8 * 1024];\n-        double[] d1 = new double[8 * 1024];\n-        double[] d2 = new double[8 * 1024];\n-        double[] d3 = new double[8 * 1024];\n-\n-        ReductionInit(a1, a2, a3, b1, b2, b3, c1, c2, c3, d1, d2, d3);\n-\n-        int sumIv = sumInt(a1, a2, a3);\n-        long sumLv = sumLong(b1, b2, b3);\n-        float sumFv = sumFloat(c1, c2, c3);\n-        double sumDv = sumDouble(d1, d2, d3);\n-        int mulIv = prodInt(a1, a2, a3);\n-        long mulLv = prodLong(b1, b2, b3);\n-        float mulFv = prodFloat(c1, c2, c3);\n-        double mulDv = prodDouble(d1, d2, d3);\n-\n-        int sumI = 0;\n-        long sumL = 0;\n-        float sumF = 0.f;\n-        double sumD = 0.;\n-        int mulI = 0;\n-        long mulL = 0;\n-        float mulF = 0.f;\n-        double mulD = 0.;\n-\n-        System.out.println(\"Warmup ...\");\n-        long start = System.currentTimeMillis();\n-\n-        for (int j = 0; j < 2000; j++) {\n-            sumI = sumInt(a1, a2, a3);\n-            sumL = sumLong(b1, b2, b3);\n-            sumF = sumFloat(c1, c2, c3);\n-            sumD = sumDouble(d1, d2, d3);\n-            mulI = prodInt(a1, a2, a3);\n-            mulL = prodLong(b1, b2, b3);\n-            mulF = prodFloat(c1, c2, c3);\n-            mulD = prodDouble(d1, d2, d3);\n-        }\n-\n-        long stop = System.currentTimeMillis();\n-        System.out.println(\" Warmup is done in \" + (stop - start) + \" msec\");\n-\n-        if (sumIv != sumI) {\n-            System.out.println(\"sum int:    \" + sumIv + \" != \" + sumI);\n-        }\n-        if (sumLv != sumL) {\n-            System.out.println(\"sum long:   \" + sumLv + \" != \" + sumL);\n-        }\n-        if (sumFv != sumF) {\n-            System.out.println(\"sum float:  \" + sumFv + \" != \" + sumF);\n-        }\n-        if (sumDv != sumD) {\n-            System.out.println(\"sum double: \" + sumDv + \" != \" + sumD);\n-        }\n-        if (mulIv != mulI) {\n-            System.out.println(\"prod int:    \" + mulIv + \" != \" + mulI);\n-        }\n-        if (mulLv != mulL) {\n-            System.out.println(\"prod long:   \" + mulLv + \" != \" + mulL);\n-        }\n-        if (mulFv != mulF) {\n-            System.out.println(\"prod float:  \" + mulFv + \" != \" + mulF);\n-        }\n-        if (mulDv != mulD) {\n-            System.out.println(\"prod double: \" + mulDv + \" != \" + mulD);\n+    static final int RANGE = 8192;\n+    static Random rand = Utils.getRandomInstance();\n+\n+    public static void main(String args[]) {\n+        \/\/ Please increase iterations for measurement to 2_000 and 100_000.\n+        int iter_warmup = 100;\n+        int iter_perf   = 1_000;\n+\n+        double[] aDouble = new double[RANGE];\n+        double[] bDouble = new double[RANGE];\n+        double[] cDouble = new double[RANGE];\n+        float[] aFloat = new float[RANGE];\n+        float[] bFloat = new float[RANGE];\n+        float[] cFloat = new float[RANGE];\n+        int[] aInt = new int[RANGE];\n+        int[] bInt = new int[RANGE];\n+        int[] cInt = new int[RANGE];\n+        long[] aLong = new long[RANGE];\n+        long[] bLong = new long[RANGE];\n+        long[] cLong = new long[RANGE];\n+\n+        long start, stop;\n+\n+        int startIntAdd = init(aInt, bInt, cInt);\n+        int goldIntAdd = testIntAdd(aInt, bInt, cInt, startIntAdd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntAdd(aInt, bInt, cInt, startIntAdd);\n+            verify(\"int add\", total, goldIntAdd);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntAdd(aInt, bInt, cInt, startIntAdd);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int add    \" + (stop - start));\n+\n+        int startIntMul = init(aInt, bInt, cInt);\n+        int goldIntMul = testIntMul(aInt, bInt, cInt, startIntMul);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntMul(aInt, bInt, cInt, startIntMul);\n+            verify(\"int mul\", total, goldIntMul);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntMul(aInt, bInt, cInt, startIntMul);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int mul    \" + (stop - start));\n+\n+        int startIntMin = init(aInt, bInt, cInt);\n+        int goldIntMin = testIntMin(aInt, bInt, cInt, startIntMin);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntMin(aInt, bInt, cInt, startIntMin);\n+            verify(\"int min\", total, goldIntMin);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntMin(aInt, bInt, cInt, startIntMin);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int min    \" + (stop - start));\n+\n+        int startIntMax = init(aInt, bInt, cInt);\n+        int goldIntMax = testIntMax(aInt, bInt, cInt, startIntMax);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntMax(aInt, bInt, cInt, startIntMax);\n+            verify(\"int max\", total, goldIntMax);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntMax(aInt, bInt, cInt, startIntMax);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int max    \" + (stop - start));\n+\n+        int startIntAnd = init(aInt, bInt, cInt);\n+        int goldIntAnd = testIntAnd(aInt, bInt, cInt, startIntAnd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntAnd(aInt, bInt, cInt, startIntAnd);\n+            verify(\"int and\", total, goldIntAnd);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntAnd(aInt, bInt, cInt, startIntAnd);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int and    \" + (stop - start));\n+\n+        int startIntOr = init(aInt, bInt, cInt);\n+        int goldIntOr = testIntOr(aInt, bInt, cInt, startIntOr);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntOr(aInt, bInt, cInt, startIntOr);\n+            verify(\"int or\", total, goldIntOr);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntOr(aInt, bInt, cInt, startIntOr);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int or     \" + (stop - start));\n+\n+        int startIntXor = init(aInt, bInt, cInt);\n+        int goldIntXor = testIntXor(aInt, bInt, cInt, startIntXor);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntXor(aInt, bInt, cInt, startIntXor);\n+            verify(\"int xor\", total, goldIntXor);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntXor(aInt, bInt, cInt, startIntXor);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int xor    \" + (stop - start));\n+\n+        long startLongAdd = init(aLong, bLong, cLong);\n+        long goldLongAdd = testLongAdd(aLong, bLong, cLong, startLongAdd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongAdd(aLong, bLong, cLong, startLongAdd);\n+            verify(\"long add\", total, goldLongAdd);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongAdd(aLong, bLong, cLong, startLongAdd);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long add   \" + (stop - start));\n+\n+        long startLongMul = init(aLong, bLong, cLong);\n+        long goldLongMul = testLongMul(aLong, bLong, cLong, startLongMul);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongMul(aLong, bLong, cLong, startLongMul);\n+            verify(\"long mul\", total, goldLongMul);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongMul(aLong, bLong, cLong, startLongMul);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long mul   \" + (stop - start));\n+\n+        long startLongMin = init(aLong, bLong, cLong);\n+        long goldLongMin = testLongMin(aLong, bLong, cLong, startLongMin);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongMin(aLong, bLong, cLong, startLongMin);\n+            verify(\"long min\", total, goldLongMin);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongMin(aLong, bLong, cLong, startLongMin);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long min   \" + (stop - start));\n+\n+        long startLongMax = init(aLong, bLong, cLong);\n+        long goldLongMax = testLongMax(aLong, bLong, cLong, startLongMax);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongMax(aLong, bLong, cLong, startLongMax);\n+            verify(\"long max\", total, goldLongMax);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongMax(aLong, bLong, cLong, startLongMax);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long max   \" + (stop - start));\n+\n+        long startLongAnd = init(aLong, bLong, cLong);\n+        long goldLongAnd = testLongAnd(aLong, bLong, cLong, startLongAnd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongAnd(aLong, bLong, cLong, startLongAnd);\n+            verify(\"long and\", total, goldLongAnd);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongAnd(aLong, bLong, cLong, startLongAnd);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long and   \" + (stop - start));\n+\n+        long startLongOr = init(aLong, bLong, cLong);\n+        long goldLongOr = testLongOr(aLong, bLong, cLong, startLongOr);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongOr(aLong, bLong, cLong, startLongOr);\n+            verify(\"long or\", total, goldLongOr);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongOr(aLong, bLong, cLong, startLongOr);\n@@ -120,0 +230,2 @@\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long or    \" + (stop - start));\n@@ -121,0 +233,6 @@\n+        long startLongXor = init(aLong, bLong, cLong);\n+        long goldLongXor = testLongXor(aLong, bLong, cLong, startLongXor);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongXor(aLong, bLong, cLong, startLongXor);\n+            verify(\"long xor\", total, goldLongXor);\n+        }\n@@ -122,2 +240,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            sumI = sumInt(a1, a2, a3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongXor(aLong, bLong, cLong, startLongXor);\n@@ -126,1 +244,1 @@\n-        System.out.println(\"sum int:    \" + (stop - start));\n+        System.out.println(\"long xor   \" + (stop - start));\n@@ -128,0 +246,6 @@\n+        float startFloatAdd = init(aFloat, bFloat, cFloat);\n+        float goldFloatAdd = testFloatAdd(aFloat, bFloat, cFloat, startFloatAdd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            float total = testFloatAdd(aFloat, bFloat, cFloat, startFloatAdd);\n+            verify(\"float add\", total, goldFloatAdd);\n+        }\n@@ -129,2 +253,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            sumL = sumLong(b1, b2, b3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testFloatAdd(aFloat, bFloat, cFloat, startFloatAdd);\n@@ -133,1 +257,1 @@\n-        System.out.println(\"sum long:   \" + (stop - start));\n+        System.out.println(\"float add  \" + (stop - start));\n@@ -135,0 +259,6 @@\n+        float startFloatMul = init(aFloat, bFloat, cFloat);\n+        float goldFloatMul = testFloatMul(aFloat, bFloat, cFloat, startFloatMul);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            float total = testFloatMul(aFloat, bFloat, cFloat, startFloatMul);\n+            verify(\"float mul\", total, goldFloatMul);\n+        }\n@@ -136,2 +266,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            sumF = sumFloat(c1, c2, c3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testFloatMul(aFloat, bFloat, cFloat, startFloatMul);\n@@ -140,1 +270,1 @@\n-        System.out.println(\"sum float:  \" + (stop - start));\n+        System.out.println(\"float mul  \" + (stop - start));\n@@ -142,0 +272,6 @@\n+        float startFloatMin = init(aFloat, bFloat, cFloat);\n+        float goldFloatMin = testFloatMin(aFloat, bFloat, cFloat, startFloatMin);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            float total = testFloatMin(aFloat, bFloat, cFloat, startFloatMin);\n+            verify(\"float min\", total, goldFloatMin);\n+        }\n@@ -143,2 +279,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            sumD = sumDouble(d1, d2, d3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testFloatMin(aFloat, bFloat, cFloat, startFloatMin);\n@@ -147,1 +283,1 @@\n-        System.out.println(\"sum double: \" + (stop - start));\n+        System.out.println(\"float min  \" + (stop - start));\n@@ -149,0 +285,6 @@\n+        float startFloatMax = init(aFloat, bFloat, cFloat);\n+        float goldFloatMax = testFloatMax(aFloat, bFloat, cFloat, startFloatMax);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            float total = testFloatMax(aFloat, bFloat, cFloat, startFloatMax);\n+            verify(\"float max\", total, goldFloatMax);\n+        }\n@@ -150,2 +292,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            mulI = prodInt(a1, a2, a3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testFloatMax(aFloat, bFloat, cFloat, startFloatMax);\n@@ -154,1 +296,1 @@\n-        System.out.println(\"prod int:    \" + (stop - start));\n+        System.out.println(\"float max  \" + (stop - start));\n@@ -156,0 +298,6 @@\n+        double startDoubleAdd = init(aDouble, bDouble, cDouble);\n+        double goldDoubleAdd = testDoubleAdd(aDouble, bDouble, cDouble, startDoubleAdd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            double total = testDoubleAdd(aDouble, bDouble, cDouble, startDoubleAdd);\n+            verify(\"double add\", total, goldDoubleAdd);\n+        }\n@@ -157,2 +305,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            mulL = prodLong(b1, b2, b3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testDoubleAdd(aDouble, bDouble, cDouble, startDoubleAdd);\n@@ -161,1 +309,1 @@\n-        System.out.println(\"prod long:   \" + (stop - start));\n+        System.out.println(\"double add \" + (stop - start));\n@@ -163,0 +311,6 @@\n+        double startDoubleMul = init(aDouble, bDouble, cDouble);\n+        double goldDoubleMul = testDoubleMul(aDouble, bDouble, cDouble, startDoubleMul);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            double total = testDoubleMul(aDouble, bDouble, cDouble, startDoubleMul);\n+            verify(\"double mul\", total, goldDoubleMul);\n+        }\n@@ -164,2 +318,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            mulF = prodFloat(c1, c2, c3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testDoubleMul(aDouble, bDouble, cDouble, startDoubleMul);\n@@ -168,1 +322,1 @@\n-        System.out.println(\"prod float:  \" + (stop - start));\n+        System.out.println(\"double mul \" + (stop - start));\n@@ -170,0 +324,6 @@\n+        double startDoubleMin = init(aDouble, bDouble, cDouble);\n+        double goldDoubleMin = testDoubleMin(aDouble, bDouble, cDouble, startDoubleMin);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            double total = testDoubleMin(aDouble, bDouble, cDouble, startDoubleMin);\n+            verify(\"double min\", total, goldDoubleMin);\n+        }\n@@ -171,2 +331,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            mulD = prodDouble(d1, d2, d3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testDoubleMin(aDouble, bDouble, cDouble, startDoubleMin);\n@@ -175,1 +335,1 @@\n-        System.out.println(\"prod double: \" + (stop - start));\n+        System.out.println(\"double min \" + (stop - start));\n@@ -177,0 +337,79 @@\n+        double startDoubleMax = init(aDouble, bDouble, cDouble);\n+        double goldDoubleMax = testDoubleMax(aDouble, bDouble, cDouble, startDoubleMax);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            double total = testDoubleMax(aDouble, bDouble, cDouble, startDoubleMax);\n+            verify(\"double max\", total, goldDoubleMax);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testDoubleMax(aDouble, bDouble, cDouble, startDoubleMax);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"double max \" + (stop - start));\n+\n+    }\n+\n+    \/\/ ------------------- Tests -------------------\n+\n+    static int testIntAdd(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total += v;\n+        }\n+        return total;\n+    }\n+\n+    static int testIntMul(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total *= v;\n+        }\n+        return total;\n+    }\n+\n+    static int testIntMin(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.min(total, v);\n+        }\n+        return total;\n+    }\n+\n+    static int testIntMax(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.max(total, v);\n+        }\n+        return total;\n+    }\n+\n+    static int testIntAnd(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total &= v;\n+        }\n+        return total;\n+    }\n+\n+    static int testIntOr(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total |= v;\n+        }\n+        return total;\n+    }\n+\n+    static int testIntXor(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total ^= v;\n+        }\n+        return total;\n+    }\n+\n+    static long testLongAdd(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total += v;\n+        }\n+        return total;\n@@ -179,17 +418,4 @@\n-    public static void ReductionInit(int[] a1, int[] a2, int[] a3,\n-                                     long[] b1, long[] b2, long[] b3,\n-                                     float[] c1, float[] c2, float[] c3,\n-                                     double[] d1, double[] d2, double[] d3) {\n-        for(int i = 0; i < a1.length; i++) {\n-            a1[i] =          (i + 0);\n-            a2[i] =          (i + 1);\n-            a3[i] =          (i + 2);\n-            b1[i] =   (long) (i + 0);\n-            b2[i] =   (long) (i + 1);\n-            b3[i] =   (long) (i + 2);\n-            c1[i] =  (float) (i + 0);\n-            c2[i] =  (float) (i + 1);\n-            c3[i] =  (float) (i + 2);\n-            d1[i] = (double) (i + 0);\n-            d2[i] = (double) (i + 1);\n-            d3[i] = (double) (i + 2);\n+    static long testLongMul(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total *= v;\n@@ -197,0 +423,9 @@\n+        return total;\n+    }\n+\n+    static long testLongMin(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.min(total, v);\n+        }\n+        return total;\n@@ -199,4 +434,4 @@\n-    public static int sumInt(int[] a1, int[] a2, int[] a3) {\n-        int total = 0;\n-        for (int i = 0; i < a1.length; i++) {\n-            total += (a1[i] * a2[i]) + (a1[i] * a3[i]) + (a2[i] * a3[i]);\n+    static long testLongMax(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.max(total, v);\n@@ -207,4 +442,4 @@\n-    public static long sumLong(long[] b1, long[] b2, long[] b3) {\n-        long total = 0;\n-        for (int i = 0; i < b1.length; i++) {\n-            total += (b1[i] * b2[i]) + (b1[i] * b3[i]) + (b2[i] * b3[i]);\n+    static long testLongAnd(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total &= v;\n@@ -215,4 +450,4 @@\n-    public static float sumFloat(float[] c1, float[] c2, float[] c3) {\n-        float total = 0;\n-        for (int i = 0; i < c1.length; i++) {\n-            total += (c1[i] * c2[i]) + (c1[i] * c3[i]) + (c2[i] * c3[i]);\n+    static long testLongOr(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total |= v;\n@@ -223,4 +458,4 @@\n-    public static double sumDouble(double[] d1, double[] d2, double[] d3) {\n-        double total = 0;\n-        for (int i = 0; i < d1.length; i++) {\n-            total += (d1[i] * d2[i]) + (d1[i] * d3[i]) + (d2[i] * d3[i]);\n+    static long testLongXor(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total ^= v;\n@@ -231,4 +466,4 @@\n-    public static int prodInt(int[] a1, int[] a2, int[] a3) {\n-        int total = 1;\n-        for (int i = 0; i < a1.length; i++) {\n-            total *= (a1[i] * a2[i]) + (a1[i] * a3[i]) + (a2[i] * a3[i]);\n+    static float testFloatAdd(float[] a, float[] b, float[] c, float total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            float v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total += v;\n@@ -239,4 +474,4 @@\n-    public static long prodLong(long[] b1, long[] b2, long[] b3) {\n-        long total = 1;\n-        for (int i = 0; i < b1.length; i++) {\n-            total *= (b1[i] * b2[i]) + (b1[i] * b3[i]) + (b2[i] * b3[i]);\n+    static float testFloatMul(float[] a, float[] b, float[] c, float total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            float v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total *= v;\n@@ -247,4 +482,4 @@\n-    public static float prodFloat(float[] c1, float[] c2, float[] c3) {\n-        float total = 1;\n-        for (int i = 0; i < c1.length; i++) {\n-            total *= (c1[i] * c2[i]) + (c1[i] * c3[i]) + (c2[i] * c3[i]);\n+    static float testFloatMin(float[] a, float[] b, float[] c, float total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            float v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.min(total, v);\n@@ -255,4 +490,4 @@\n-    public static double prodDouble(double[] d1, double[] d2, double[] d3) {\n-        double total = 1;\n-        for (int i = 0; i < d1.length; i++) {\n-            total *= (d1[i] * d2[i]) + (d1[i] * d3[i]) + (d2[i] * d3[i]);\n+    static float testFloatMax(float[] a, float[] b, float[] c, float total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            float v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.max(total, v);\n@@ -262,0 +497,93 @@\n+\n+    static double testDoubleAdd(double[] a, double[] b, double[] c, double total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            double v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total += v;\n+        }\n+        return total;\n+    }\n+\n+    static double testDoubleMul(double[] a, double[] b, double[] c, double total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            double v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total *= v;\n+        }\n+        return total;\n+    }\n+\n+    static double testDoubleMin(double[] a, double[] b, double[] c, double total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            double v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.min(total, v);\n+        }\n+        return total;\n+    }\n+\n+    static double testDoubleMax(double[] a, double[] b, double[] c, double total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            double v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.max(total, v);\n+        }\n+        return total;\n+    }\n+\n+    \/\/ ------------------- Initialization -------------------\n+\n+    static int init(int[] a, int[] b, int[] c) {\n+        for (int j = 0; j < RANGE; j++) {\n+            a[j] = rand.nextInt();\n+            b[j] = rand.nextInt();\n+            c[j] = rand.nextInt();\n+        }\n+        return rand.nextInt();\n+    }\n+\n+    static long init(long[] a, long[] b, long[] c) {\n+        for (int j = 0; j < RANGE; j++) {\n+            a[j] = rand.nextLong();\n+            b[j] = rand.nextLong();\n+            c[j] = rand.nextLong();\n+        }\n+        return rand.nextLong();\n+    }\n+\n+    static float init(float[] a, float[] b, float[] c) {\n+        for (int j = 0; j < RANGE; j++) {\n+            a[j] = rand.nextFloat();\n+            b[j] = rand.nextFloat();\n+            c[j] = rand.nextFloat();\n+        }\n+        return rand.nextFloat();\n+    }\n+\n+    static double init(double[] a, double[] b, double[] c) {\n+        for (int j = 0; j < RANGE; j++) {\n+            a[j] = rand.nextDouble();\n+            b[j] = rand.nextDouble();\n+            c[j] = rand.nextDouble();\n+        }\n+        return rand.nextDouble();\n+    }\n+\n+    \/\/ ------------------- Verification -------------------\n+\n+    static void verify(String context, double total, double gold) {\n+        if (total != gold) {\n+            throw new RuntimeException(\"Wrong result for \" + context + \": \" + total + \" != \" + gold);\n+        }\n+    }\n+    static void verify(String context, float total, float gold) {\n+        if (total != gold) {\n+            throw new RuntimeException(\"Wrong result for \" + context + \": \" + total + \" != \" + gold);\n+        }\n+    }\n+    static void verify(String context, int total, int gold) {\n+        if (total != gold) {\n+            throw new RuntimeException(\"Wrong result for \" + context + \": \" + total + \" != \" + gold);\n+        }\n+    }\n+    static void verify(String context, long total, long gold) {\n+        if (total != gold) {\n+            throw new RuntimeException(\"Wrong result for \" + context + \": \" + total + \" != \" + gold);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ReductionPerf.java","additions":491,"deletions":163,"binary":false,"changes":654,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\"})\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\", IRNode.ADD_REDUCTION_VI, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\"})\n+        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\", IRNode.ADD_REDUCTION_VL, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Long.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8302652\n+ * @summary Special test cases for PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestUnorderedReduction\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestUnorderedReduction {\n+    static final int RANGE = 1024;\n+    static final int ITER  = 10;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-Xbatch\",\n+                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestUnorderedReduction::test*\",\n+                                   \"-XX:MaxVectorSize=16\");\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\"})\n+    @Warmup(0)\n+    public void runTests() throws Exception {\n+        int[] data = new int[RANGE];\n+\n+        init(data);\n+        for (int i = 0; i < ITER; i++) {\n+            int r1 = test1(data, i);\n+            int r2 = ref1(data, i);\n+            if (r1 != r2) {\n+                throw new RuntimeException(\"Wrong result test1: \" + r1 + \" != \" + r2);\n+            }\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            int r1 = test2(data, i);\n+            int r2 = ref2(data, i);\n+            if (r1 != r2) {\n+                throw new RuntimeException(\"Wrong result test2: \" + r1 + \" != \" + r2);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\",\n+                  IRNode.ADD_VI, \"= 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\"}, \/\/ count can be high\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static int test1(int[] data, int sum) {\n+        \/\/ Vectorizes, but the UnorderedReduction cannot be moved out of the loop,\n+        \/\/ because we have a use inside the loop.\n+        int x = 0;\n+        for (int i = 0; i < RANGE; i+=8) {\n+            sum += 11 * data[i+0]; \/\/ vec 1 (16 bytes)\n+            sum += 11 * data[i+1];\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            x = sum + i; \/\/ vec 1 reduction has more than 1 use\n+            sum += 11 * data[i+4]; \/\/ vec 2 (next 16 bytes)\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum + x;\n+    }\n+\n+    static int ref1(int[] data, int sum) {\n+        int x = 0;\n+        for (int i = 0; i < RANGE; i+=8) {\n+            sum += 11 * data[i+0];\n+            sum += 11 * data[i+1];\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            x = sum + i;\n+            sum += 11 * data[i+4];\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum + x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"<= 2\"}, \/\/ count must be low\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static int test2(int[] data, int sum) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Vectorized, and UnorderedReduction moved outside loop.\n+            sum += 11 * data[i+0]; \/\/ vec 1\n+            sum += 11 * data[i+1];\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            sum += 11 * data[i+4]; \/\/ vec 2\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum;\n+    }\n+\n+    static int ref2(int[] data, int sum) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            sum += 11 * data[i+0];\n+            sum += 11 * data[i+1];\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            sum += 11 * data[i+4];\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum;\n+    }\n+\n+\n+    static void init(int[] data) {\n+        for (int i = 0; i < RANGE; i++) {\n+            data[i] = i + 1;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReduction.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"}]}