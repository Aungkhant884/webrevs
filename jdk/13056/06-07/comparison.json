{"files":[{"patch":"@@ -4191,1 +4191,4 @@\n-    if (!last_ur->make_normal_vector_op_implemented(vec_t)) {\n+    \/\/ Convert opcode from vector-reduction -> scalar -> normal-vector-op\n+    const int sopc        = VectorNode::scalar_opcode(last_ur->Opcode(), bt);\n+    const int vopc        = VectorNode::opcode(sopc, bt);\n+    if (!Matcher::match_rule_supported_vector(vopc, vector_length, bt)) {\n@@ -4255,2 +4258,1 @@\n-    \/\/ Create vector of identity elements (zero for add, one for mul, etc)\n-    Node* identity_scalar = ReductionNode::make_identity_input_for_reduction_from_vector_opc(_igvn, last_ur->Opcode(), bt);\n+    Node* identity_scalar = ReductionNode::make_identity_con_scalar(_igvn, sopc, bt);\n@@ -4276,1 +4278,1 @@\n-      VectorNode* vector_accumulator = current->make_normal_vector_op(last_vector_accumulator, vector_input, vec_t);\n+      VectorNode* vector_accumulator = VectorNode::make(vopc, last_vector_accumulator, vector_input, vec_t);\n@@ -4288,1 +4290,1 @@\n-    Node* post_loop_reduction = ReductionNode::make_from_vopc(first_ur->Opcode(), nullptr, init, last_accumulator, bt);\n+    Node* post_loop_reduction = ReductionNode::make(sopc, nullptr, init, last_accumulator, bt);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1539,1 +1539,1 @@\n-  Node* init = ReductionNode::make_identity_input_for_reduction_from_scalar_opc(gvn(), opc, elem_bt);\n+  Node* init = ReductionNode::make_identity_con_scalar(gvn(), opc, elem_bt);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\/\/ and vector length.\n+\/\/ and basic type.\n@@ -277,0 +277,103 @@\n+\/\/ Return the scalar opcode for the specified vector opcode\n+\/\/ and basic type.\n+int VectorNode::scalar_opcode(int sopc, BasicType bt) {\n+  switch (sopc) {\n+    case Op_AddReductionVI:\n+    case Op_AddVI:\n+      return Op_AddI;\n+    case Op_AddReductionVL:\n+    case Op_AddVL:\n+      return Op_AddL;\n+    case Op_MulReductionVI:\n+    case Op_MulVI:\n+      return Op_MulI;\n+    case Op_MulReductionVL:\n+    case Op_MulVL:\n+      return Op_MulL;\n+    case Op_AndReductionV:\n+    case Op_AndV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_AndI;\n+        case T_LONG:\n+          return Op_AndL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    case Op_OrReductionV:\n+    case Op_OrV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_OrI;\n+        case T_LONG:\n+          return Op_OrL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    case Op_XorReductionV:\n+    case Op_XorV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_XorI;\n+        case T_LONG:\n+          return Op_XorL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    case Op_MinReductionV:\n+    case Op_MinV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+          assert(false, \"boolean and char are signed, not implemented for Min\");\n+          return 0;\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_MinI;\n+        case T_LONG:\n+          return Op_MinL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    case Op_MaxReductionV:\n+    case Op_MaxV:\n+      switch (bt) {\n+        case T_BOOLEAN:\n+        case T_CHAR:\n+          assert(false, \"boolean and char are signed, not implemented for Max\");\n+          return 0;\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+          return Op_MaxI;\n+        case T_LONG:\n+          return Op_MaxL;\n+        default:\n+          assert(false, \"basic type not handled\");\n+          return 0;\n+      }\n+    default:\n+      assert(false,\n+             \"Vector node %s is not handled in VectorNode::scalar_opcode\",\n+             NodeClassNames[sopc]);\n+      return 0; \/\/ Unimplemented\n+  }\n+}\n+\n@@ -1268,1 +1371,1 @@\n-ReductionNode* ReductionNode::make(int opc, Node* ctrl, Node* n1, Node* n2, BasicType bt) {\n+ReductionNode* ReductionNode::make(int opc, Node *ctrl, Node* n1, Node* n2, BasicType bt) {\n@@ -1275,4 +1378,0 @@\n-  return ReductionNode::make_from_vopc(vopc, ctrl, n1, n2, bt);\n-}\n-\n-ReductionNode* ReductionNode::make_from_vopc(int vopc, Node* ctrl, Node* n1, Node* n2, BasicType bt) {\n@@ -1405,7 +1504,3 @@\n-\/\/ Input opc of pre-reduction operation, eg AddI for AddReductionVI\n-Node* ReductionNode::make_identity_input_for_reduction_from_scalar_opc(PhaseGVN& gvn, int opc, BasicType bt) {\n-  int vopc = opcode(opc, bt);\n-  guarantee(vopc != opc, \"Vector reduction for '%s' is not implemented\", NodeClassNames[opc]);\n-\n-  return make_identity_input_for_reduction_from_vector_opc(gvn, vopc, bt);\n-}\n+Node* ReductionNode::make_identity_con_scalar(PhaseGVN& gvn, int sopc, BasicType bt) {\n+  int vopc = opcode(sopc, bt);\n+  guarantee(vopc != sopc, \"Vector reduction for '%s' is not implemented\", NodeClassNames[sopc]);\n@@ -1413,2 +1508,0 @@\n-\/\/ Input opc of vector reduction, eg. AddReductionVI\n-Node* ReductionNode::make_identity_input_for_reduction_from_vector_opc(PhaseGVN& gvn, int vopc, BasicType bt) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":108,"deletions":15,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-  static int  opcode(int opc, BasicType bt);\n+  static int opcode(int sopc, BasicType bt);         \/\/ scalar_opc -> vector_opc\n+  static int scalar_opcode(int vopc, BasicType bt);  \/\/ vector_opc -> scalar_opc\n@@ -210,1 +211,0 @@\n-  static ReductionNode* make_from_vopc(int vopc, Node* ctrl, Node* in1, Node* in2, BasicType bt);\n@@ -213,3 +213,2 @@\n-  \/\/ Make an identity element (zero for add, one for mul, etc) for opc of scalar\/vector reduction.\n-  static Node* make_identity_input_for_reduction_from_scalar_opc(PhaseGVN& gvn, int opc, BasicType bt);\n-  static Node* make_identity_input_for_reduction_from_vector_opc(PhaseGVN& gvn, int vopc, BasicType bt);\n+  \/\/ Make an identity scalar (zero for add, one for mul, etc) for scalar opc.\n+  static Node* make_identity_con_scalar(PhaseGVN& gvn, int sopc, BasicType bt);\n@@ -242,3 +241,0 @@\n-\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) = 0;\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) = 0;\n@@ -253,6 +249,0 @@\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n-    return new AddVINode(in1, in2, vt);\n-  }\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n-    return Matcher::match_rule_supported_vector(Op_AddVI, vt->length(), vt->element_basic_type());\n-  }\n@@ -267,6 +257,0 @@\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n-    return new AddVLNode(in1, in2, vt);\n-  }\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n-    return Matcher::match_rule_supported_vector(Op_AddVL, vt->length(), vt->element_basic_type());\n-  }\n@@ -433,6 +417,0 @@\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n-    return new MulVINode(in1, in2, vt);\n-  }\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n-    return Matcher::match_rule_supported_vector(Op_MulVI, vt->length(), vt->element_basic_type());\n-  }\n@@ -447,6 +425,0 @@\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n-    return new MulVLNode(in1, in2, vt);\n-  }\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n-    return Matcher::match_rule_supported_vector(Op_MulVL, vt->length(), vt->element_basic_type());\n-  }\n@@ -796,6 +768,0 @@\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n-    return new AndVNode(in1, in2, vt);\n-  }\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n-    return Matcher::match_rule_supported_vector(Op_AndV, vt->length(), vt->element_basic_type());\n-  }\n@@ -819,6 +785,0 @@\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n-    return new OrVNode(in1, in2, vt);\n-  }\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n-    return Matcher::match_rule_supported_vector(Op_OrV, vt->length(), vt->element_basic_type());\n-  }\n@@ -842,6 +802,0 @@\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n-    return new XorVNode(in1, in2, vt);\n-  }\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n-    return Matcher::match_rule_supported_vector(Op_XorV, vt->length(), vt->element_basic_type());\n-  }\n@@ -856,6 +810,0 @@\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n-    return new MinVNode(in1, in2, vt);\n-  }\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n-    return Matcher::match_rule_supported_vector(Op_MinV, vt->length(), vt->element_basic_type());\n-  }\n@@ -870,6 +818,0 @@\n-  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n-    return new MaxVNode(in1, in2, vt);\n-  }\n-  virtual bool make_normal_vector_op_implemented(const TypeVect* vt) {\n-    return Matcher::match_rule_supported_vector(Op_MaxV, vt->length(), vt->element_basic_type());\n-  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":4,"deletions":62,"binary":false,"changes":66,"status":"modified"}]}