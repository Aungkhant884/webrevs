{"files":[{"patch":"@@ -4631,0 +4631,10 @@\n+\n+  \/\/ Move UnorderedReduction out of counted loop. Can be introduced by SuperWord.\n+  if (C->has_loops() && !C->major_progress()) {\n+    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+      IdealLoopTree* lpt = iter.current();\n+      if (lpt->_head->is_CountedLoop()) {\n+        move_unordered_reduction_out_of_loop(lpt);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1487,0 +1487,3 @@\n+  \/\/ Move UnorderedReduction out of loop if possible\n+  void move_unordered_reduction_out_of_loop(IdealLoopTree* loop);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -4123,0 +4124,200 @@\n+\n+\/\/ Having ReductionNodes in the loop is expensive. They need to recursively\n+\/\/ fold together the vector values, for every vectorized loop iteration. If\n+\/\/ we encounter the following pattern, we can vector accumulate the values\n+\/\/ inside the loop, and only have a single UnorderedReduction after the loop.\n+\/\/\n+\/\/ CountedLoop     init\n+\/\/          |        |\n+\/\/          +------+ | +-----------------------+\n+\/\/                 | | |                       |\n+\/\/                PhiNode (s)                  |\n+\/\/                  |                          |\n+\/\/                  |          Vector          |\n+\/\/                  |            |             |\n+\/\/               UnorderedReduction (first_ur) |\n+\/\/                  |                          |\n+\/\/                 ...         Vector          |\n+\/\/                  |            |             |\n+\/\/               UnorderedReduction (last_ur)  |\n+\/\/                       |                     |\n+\/\/                       +---------------------+\n+\/\/\n+\/\/ We patch the graph to look like this:\n+\/\/\n+\/\/ CountedLoop   identity_vector\n+\/\/         |         |\n+\/\/         +-------+ | +---------------+\n+\/\/                 | | |               |\n+\/\/                PhiNode (v)          |\n+\/\/                   |                 |\n+\/\/                   |         Vector  |\n+\/\/                   |           |     |\n+\/\/                 VectorAccumulator   |\n+\/\/                   |                 |\n+\/\/                  ...        Vector  |\n+\/\/                   |           |     |\n+\/\/      init       VectorAccumulator   |\n+\/\/        |          |     |           |\n+\/\/     UnorderedReduction  +-----------+\n+\/\/\n+\/\/ We turned the scalar (s) Phi into a vectorized one (v). In the loop, we\n+\/\/ use vector_accumulators, which do the same reductions, but only element\n+\/\/ wise. This is a single operation per vector_accumulator, rather than many\n+\/\/ for a UnorderedReduction. We can then reduce the last vector_accumulator\n+\/\/ after the loop, and also reduce the init value into it.\n+\/\/ We can not do this with all reductions. Some reductions do not allow the\n+\/\/ reordering of operations (for example float addition).\n+void PhaseIdealLoop::move_unordered_reduction_out_of_loop(IdealLoopTree* loop) {\n+  assert(!C->major_progress() && loop->_head->is_CountedLoop(), \"sanity\");\n+\n+  \/\/ Find all Phi nodes with UnorderedReduction on backedge.\n+  CountedLoopNode* cl = loop->_head->as_CountedLoop();\n+  for (DUIterator_Fast jmax, j = cl->fast_outs(jmax); j < jmax; j++) {\n+    Node* phi = cl->fast_out(j);\n+    \/\/ We have a phi with a single use, and a UnorderedReduction on the backedge.\n+    if (!phi->is_Phi() || phi->outcnt() != 1 || !phi->in(2)->is_UnorderedReduction()) {\n+      continue;\n+    }\n+\n+    UnorderedReductionNode* last_ur = phi->in(2)->as_UnorderedReduction();\n+\n+    \/\/ Traverse up the chain of UnorderedReductions, checking that it loops back to\n+    \/\/ the phi. Check that all UnorderedReductions only have a single use, except for\n+    \/\/ the last (last_ur), which only has phi as a use in the loop, and all other uses\n+    \/\/ are outside the loop.\n+    UnorderedReductionNode* current = last_ur;\n+    UnorderedReductionNode* first_ur = nullptr;\n+    while (true) {\n+      assert(current->is_UnorderedReduction(), \"sanity\");\n+\n+      \/\/ Expect no ctrl and a vector_input from within the loop.\n+      Node* ctrl = current->in(0);\n+      Node* vector_input = current->in(2);\n+      if (ctrl != nullptr || get_ctrl(vector_input) != cl) {\n+        DEBUG_ONLY( current->dump(1); )\n+        assert(false, \"reduction has ctrl or bad vector_input\");\n+        break; \/\/ Chain traversal fails.\n+      }\n+\n+      \/\/ Expect single use of UnorderedReduction, except for last_ur.\n+      if (current == last_ur) {\n+        \/\/ Expect all uses to be outside the loop, except phi.\n+        for (DUIterator_Fast kmax, k = current->fast_outs(kmax); k < kmax; k++) {\n+          Node* use = current->fast_out(k);\n+          if (use != phi && ctrl_or_self(use) == cl) {\n+            DEBUG_ONLY( current->dump(-1); )\n+            assert(false, \"reduction has use inside loop\");\n+            break; \/\/ Chain traversal fails.\n+          }\n+        }\n+      } else {\n+        if (current->outcnt() != 1) {\n+          DEBUG_ONLY( current->dump(-1); )\n+          assert(false, \"reduction (not last) has more than one use\");\n+          break; \/\/ Chain traversal fails.\n+        }\n+      }\n+\n+      \/\/ Expect another UnorderedReduction or phi as the scalar input.\n+      Node* scalar_input = current->in(1);\n+      if (scalar_input->is_UnorderedReduction() &&\n+          scalar_input->Opcode() == current->Opcode()) {\n+        \/\/ Move up the UnorderedReduction chain.\n+        current = scalar_input->as_UnorderedReduction();\n+      } else if (scalar_input == phi) {\n+        \/\/ Chain terminates at phi.\n+        first_ur = current;\n+        current = nullptr;\n+        break; \/\/ Success.\n+      } else {\n+        DEBUG_ONLY( current->dump(1); )\n+        assert(false, \"scalar_input is neither phi nor a matchin reduction\");\n+        break; \/\/ Chain traversal fails.\n+      }\n+    }\n+    if (current != nullptr) {\n+      \/\/ Chain traversal was not successful.\n+      continue;\n+    }\n+    assert(first_ur != nullptr, \"must have successfully terminated chain traversal\");\n+\n+    \/\/ Determine types\n+    const TypeVect* vec_t = last_ur->vect_type();\n+    uint vector_length    = vec_t->length();\n+    BasicType bt          = vec_t->element_basic_type();\n+    const Type* bt_t      = Type::get_const_basic_type(bt);\n+\n+    \/\/ Create vector of identity elements (zero for add, one for mul, etc)\n+    Node* identity_scalar = ReductionNode::make_identity_input_for_reduction_from_vector_opc(_igvn, last_ur->Opcode(), bt);\n+    set_ctrl(identity_scalar, C->root());\n+    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt_t);\n+    _igvn.register_new_node_with_optimizer(identity_vector);\n+    set_ctrl(identity_vector, C->root());\n+    assert(vec_t == identity_vector->vect_type(), \"matching vector type\");\n+#ifdef ASSERT\n+    if (TraceNewVectors) {\n+      tty->print(\"new Vector node: \");\n+      identity_vector->dump();\n+    }\n+#endif\n+\n+    \/\/ Traverse down the chain of UnorderedReductions, and create the vector_accumulators.\n+    current = first_ur;\n+    Node* last_vector_accumulator = phi;\n+    while (true) {\n+      \/\/ Create vector_accumulator to replace current.\n+      Node* vector_input = current->in(2);\n+      VectorNode* vector_accumulator = current->make_normal_vector_op(last_vector_accumulator, vector_input, vec_t);\n+      _igvn.register_new_node_with_optimizer(vector_accumulator, current);\n+      set_ctrl(vector_accumulator, cl);\n+      last_vector_accumulator = vector_accumulator;\n+      if (current != last_ur) {\n+        \/\/ All UnorderedReductions except the last are now useless.\n+        _igvn.rehash_node_delayed(current);\n+        current->set_req_X(1, C->top(), &_igvn);\n+        current->set_req_X(2, C->top(), &_igvn);\n+      }\n+#ifdef ASSERT\n+      if (TraceNewVectors) {\n+        tty->print(\"new Vector node: \");\n+        vector_accumulator->dump();\n+      }\n+#endif\n+      \/\/ Iterate down, until we hit last_ur.\n+      if (current != last_ur) {\n+        current = current->unique_out()->as_UnorderedReduction();\n+      } else {\n+        current = nullptr;\n+        break;\n+      }\n+    }\n+    assert(current == nullptr, \"terminated correctly\");\n+\n+    \/\/ After the loop, we can reduce the init and last_vector_accumulator.\n+    Node* init = phi->in(1);\n+    _igvn.rehash_node_delayed(last_ur);\n+    last_ur->set_req_X(1, init, &_igvn);\n+    last_ur->set_req_X(2, last_vector_accumulator, &_igvn);\n+\n+    \/\/ Turn the scalar phi into a vector phi.\n+    _igvn.rehash_node_delayed(phi);\n+    phi->set_req_X(1, identity_vector, &_igvn);\n+    phi->set_req_X(2, last_vector_accumulator, &_igvn);\n+    phi->as_Type()->set_type(vec_t);\n+    _igvn.set_type(phi, vec_t);\n+    assert(phi->outcnt() == 1, \"accumulator is only use of phi\");\n+\n+    \/\/ Update control to outside the loop.\n+    Node* new_ctrl = get_late_ctrl(last_ur, cl);\n+    set_ctrl(last_ur, new_ctrl);\n+    assert(new_ctrl != nullptr && new_ctrl != cl, \"new control of ur must be outside loop\");\n+\n+#ifdef ASSERT\n+    if (TraceNewVectors) {\n+      tty->print(\"new Vector node: \");\n+      phi->dump();\n+    }\n+#endif\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":201,"deletions":0,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+class ReductionNode;\n@@ -167,0 +168,1 @@\n+class UnorderedReductionNode;\n@@ -721,0 +723,2 @@\n+        DEFINE_CLASS_ID(Reduction, Vector, 7)\n+          DEFINE_CLASS_ID(UnorderedReduction, Reduction, 0)\n@@ -944,0 +948,1 @@\n+  DEFINE_CLASS_QUERY(Reduction)\n@@ -953,0 +958,1 @@\n+  DEFINE_CLASS_QUERY(UnorderedReduction)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3377,0 +3377,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1539,1 +1539,1 @@\n-  Node* init = ReductionNode::make_reduction_input(gvn(), opc, elem_bt);\n+  Node* init = ReductionNode::make_identity_input_for_reduction_from_scalar_opc(gvn(), opc, elem_bt);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1401,1 +1401,2 @@\n-Node* ReductionNode::make_reduction_input(PhaseGVN& gvn, int opc, BasicType bt) {\n+\/\/ Input opc of pre-reduction operation, eg AddI for AddReductionVI\n+Node* ReductionNode::make_identity_input_for_reduction_from_scalar_opc(PhaseGVN& gvn, int opc, BasicType bt) {\n@@ -1405,0 +1406,5 @@\n+  return make_identity_input_for_reduction_from_vector_opc(gvn, vopc, bt);\n+}\n+\n+\/\/ Input opc of vector reduction, eg. AddReductionVI\n+Node* ReductionNode::make_identity_input_for_reduction_from_vector_opc(PhaseGVN& gvn, int vopc, BasicType bt) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"opto\/cfgnode.hpp\"\n+#include \"opto\/loopnode.hpp\"\n@@ -194,1 +196,3 @@\n-               _vect_type(in2->bottom_type()->is_vect()) {}\n+               _vect_type(in2->bottom_type()->is_vect()) {\n+    init_class_id(Class_Reduction);\n+  }\n@@ -199,1 +203,3 @@\n-  static Node* make_reduction_input(PhaseGVN& gvn, int opc, BasicType bt);\n+  \/\/ Make an identity element (zero for add, one for mul, etc) for opc of scalar\/vector reduction.\n+  static Node* make_identity_input_for_reduction_from_scalar_opc(PhaseGVN& gvn, int opc, BasicType bt);\n+  static Node* make_identity_input_for_reduction_from_vector_opc(PhaseGVN& gvn, int vopc, BasicType bt);\n@@ -219,0 +225,11 @@\n+\/\/---------------------------UnorderedReductionNode-------------------------------------\n+\/\/ Order of reduction does not matter. Example int add. Not true for float add.\n+class UnorderedReductionNode : public ReductionNode {\n+public:\n+  UnorderedReductionNode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {\n+    init_class_id(Class_UnorderedReduction);\n+  }\n+\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) = 0;\n+};\n+\n@@ -221,1 +238,1 @@\n-class AddReductionVINode : public ReductionNode {\n+class AddReductionVINode : public UnorderedReductionNode {\n@@ -223,1 +240,1 @@\n-  AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -225,0 +242,3 @@\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n+    return new AddVINode(in1, in2, vt);\n+  }\n@@ -229,1 +249,1 @@\n-class AddReductionVLNode : public ReductionNode {\n+class AddReductionVLNode : public UnorderedReductionNode {\n@@ -231,1 +251,1 @@\n-  AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -233,0 +253,3 @@\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n+    return new AddVLNode(in1, in2, vt);\n+  }\n@@ -389,1 +412,1 @@\n-class MulReductionVINode : public ReductionNode {\n+class MulReductionVINode : public UnorderedReductionNode {\n@@ -391,1 +414,1 @@\n-  MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -393,0 +416,3 @@\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n+    return new MulVINode(in1, in2, vt);\n+  }\n@@ -397,1 +423,1 @@\n-class MulReductionVLNode : public ReductionNode {\n+class MulReductionVLNode : public UnorderedReductionNode {\n@@ -399,1 +425,1 @@\n-  MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -401,0 +427,3 @@\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n+    return new MulVLNode(in1, in2, vt);\n+  }\n@@ -740,1 +769,1 @@\n-class AndReductionVNode : public ReductionNode {\n+class AndReductionVNode : public UnorderedReductionNode {\n@@ -742,1 +771,1 @@\n-  AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -744,0 +773,3 @@\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n+    return new AndVNode(in1, in2, vt);\n+  }\n@@ -757,1 +789,1 @@\n-class OrReductionVNode : public ReductionNode {\n+class OrReductionVNode : public UnorderedReductionNode {\n@@ -759,9 +791,1 @@\n-  OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------XorReductionVNode--------------------------------------\n-\/\/ Vector and int, long as a reduction\n-class XorReductionVNode : public ReductionNode {\n- public:\n-  XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -769,0 +793,3 @@\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n+    return new OrVNode(in1, in2, vt);\n+  }\n@@ -780,0 +807,11 @@\n+\/\/------------------------------XorReductionVNode--------------------------------------\n+\/\/ Vector and int, long as a reduction\n+class XorReductionVNode : public UnorderedReductionNode {\n+ public:\n+  XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n+    return new XorVNode(in1, in2, vt);\n+  }\n+};\n+\n@@ -782,1 +820,1 @@\n-class MinReductionVNode : public ReductionNode {\n+class MinReductionVNode : public UnorderedReductionNode {\n@@ -784,1 +822,1 @@\n-  MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -786,0 +824,3 @@\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n+    return new MinVNode(in1, in2, vt);\n+  }\n@@ -790,1 +831,1 @@\n-class MaxReductionVNode : public ReductionNode {\n+class MaxReductionVNode : public UnorderedReductionNode {\n@@ -792,1 +833,1 @@\n-  MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n@@ -794,0 +835,3 @@\n+  virtual VectorNode* make_normal_vector_op(Node* in1, Node* in2, const TypeVect* vt) {\n+    return new MaxVNode(in1, in2, vt);\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":70,"deletions":26,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\"})\n+        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\", IRNode.MUL_REDUCTION_VI, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\"})\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\", IRNode.ADD_REDUCTION_VI, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -154,1 +154,1 @@\n-        counts = {IRNode.OR_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.OR_REDUCTION_V, \">= 1\", IRNode.OR_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -171,1 +171,1 @@\n-        counts = {IRNode.AND_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.AND_REDUCTION_V, \">= 1\", IRNode.AND_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -188,1 +188,1 @@\n-        counts = {IRNode.XOR_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.XOR_REDUCTION_V, \">= 1\", IRNode.XOR_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -205,1 +205,1 @@\n-        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\"})\n+        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\", IRNode.MUL_REDUCTION_VI, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/RedTest_int.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\"})\n+        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\", IRNode.ADD_REDUCTION_VL, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -157,1 +157,1 @@\n-        counts = {IRNode.OR_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.OR_REDUCTION_V, \">= 1\", IRNode.OR_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -174,1 +174,1 @@\n-        counts = {IRNode.AND_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.AND_REDUCTION_V, \">= 1\", IRNode.AND_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -191,1 +191,1 @@\n-        counts = {IRNode.XOR_REDUCTION_V, \">= 1\"})\n+        counts = {IRNode.XOR_REDUCTION_V, \">= 1\", IRNode.XOR_REDUCTION_V, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n@@ -208,1 +208,1 @@\n-        counts = {IRNode.MUL_REDUCTION_VL, \">= 1\"})\n+        counts = {IRNode.MUL_REDUCTION_VL, \">= 1\", IRNode.MUL_REDUCTION_VL, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/RedTest_long.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -26,14 +26,8 @@\n- * @bug 8074981\n- * @summary Add C2 x86 Superword support for scalar product reduction optimizations : int test\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n- *      -XX:LoopUnrollLimit=250 -XX:CompileThresholdScaling=0.1\n- *      -XX:CompileCommand=exclude,compiler.loopopts.superword.ReductionPerf::main\n- *      -XX:+SuperWordReductions\n- *      compiler.loopopts.superword.ReductionPerf\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n- *      -XX:LoopUnrollLimit=250 -XX:CompileThresholdScaling=0.1\n- *      -XX:CompileCommand=exclude,compiler.loopopts.superword.ReductionPerf::main\n- *      -XX:-SuperWordReductions\n- *      compiler.loopopts.superword.ReductionPerf\n+ * @bug 8074981 8302652\n+ * @summary Test SuperWord Reduction Perf.\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.simpleArch == \"x86\" | vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -Xbatch -XX:LoopUnrollLimit=250\n+ *                   -XX:CompileCommand=exclude,compiler.loopopts.superword.ReductionPerf::main\n+ *                   compiler.loopopts.superword.ReductionPerf\n@@ -43,0 +37,2 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n@@ -45,74 +41,188 @@\n-    public static void main(String[] args) throws Exception {\n-        int[] a1 = new int[8 * 1024];\n-        int[] a2 = new int[8 * 1024];\n-        int[] a3 = new int[8 * 1024];\n-        long[] b1 = new long[8 * 1024];\n-        long[] b2 = new long[8 * 1024];\n-        long[] b3 = new long[8 * 1024];\n-        float[] c1 = new float[8 * 1024];\n-        float[] c2 = new float[8 * 1024];\n-        float[] c3 = new float[8 * 1024];\n-        double[] d1 = new double[8 * 1024];\n-        double[] d2 = new double[8 * 1024];\n-        double[] d3 = new double[8 * 1024];\n-\n-        ReductionInit(a1, a2, a3, b1, b2, b3, c1, c2, c3, d1, d2, d3);\n-\n-        int sumIv = sumInt(a1, a2, a3);\n-        long sumLv = sumLong(b1, b2, b3);\n-        float sumFv = sumFloat(c1, c2, c3);\n-        double sumDv = sumDouble(d1, d2, d3);\n-        int mulIv = prodInt(a1, a2, a3);\n-        long mulLv = prodLong(b1, b2, b3);\n-        float mulFv = prodFloat(c1, c2, c3);\n-        double mulDv = prodDouble(d1, d2, d3);\n-\n-        int sumI = 0;\n-        long sumL = 0;\n-        float sumF = 0.f;\n-        double sumD = 0.;\n-        int mulI = 0;\n-        long mulL = 0;\n-        float mulF = 0.f;\n-        double mulD = 0.;\n-\n-        System.out.println(\"Warmup ...\");\n-        long start = System.currentTimeMillis();\n-\n-        for (int j = 0; j < 2000; j++) {\n-            sumI = sumInt(a1, a2, a3);\n-            sumL = sumLong(b1, b2, b3);\n-            sumF = sumFloat(c1, c2, c3);\n-            sumD = sumDouble(d1, d2, d3);\n-            mulI = prodInt(a1, a2, a3);\n-            mulL = prodLong(b1, b2, b3);\n-            mulF = prodFloat(c1, c2, c3);\n-            mulD = prodDouble(d1, d2, d3);\n-        }\n-\n-        long stop = System.currentTimeMillis();\n-        System.out.println(\" Warmup is done in \" + (stop - start) + \" msec\");\n-\n-        if (sumIv != sumI) {\n-            System.out.println(\"sum int:    \" + sumIv + \" != \" + sumI);\n-        }\n-        if (sumLv != sumL) {\n-            System.out.println(\"sum long:   \" + sumLv + \" != \" + sumL);\n-        }\n-        if (sumFv != sumF) {\n-            System.out.println(\"sum float:  \" + sumFv + \" != \" + sumF);\n-        }\n-        if (sumDv != sumD) {\n-            System.out.println(\"sum double: \" + sumDv + \" != \" + sumD);\n-        }\n-        if (mulIv != mulI) {\n-            System.out.println(\"prod int:    \" + mulIv + \" != \" + mulI);\n-        }\n-        if (mulLv != mulL) {\n-            System.out.println(\"prod long:   \" + mulLv + \" != \" + mulL);\n-        }\n-        if (mulFv != mulF) {\n-            System.out.println(\"prod float:  \" + mulFv + \" != \" + mulF);\n-        }\n-        if (mulDv != mulD) {\n-            System.out.println(\"prod double: \" + mulDv + \" != \" + mulD);\n+    static final int RANGE = 8192;\n+    static Random rand = Utils.getRandomInstance();\n+\n+    public static void main(String args[]) {\n+        \/\/ Please increase iterations for measurement to 2_000 and 100_000.\n+        int iter_warmup = 100;\n+        int iter_perf   = 1_000;\n+\n+        double[] aDouble = new double[RANGE];\n+        double[] bDouble = new double[RANGE];\n+        double[] cDouble = new double[RANGE];\n+        float[] aFloat = new float[RANGE];\n+        float[] bFloat = new float[RANGE];\n+        float[] cFloat = new float[RANGE];\n+        int[] aInt = new int[RANGE];\n+        int[] bInt = new int[RANGE];\n+        int[] cInt = new int[RANGE];\n+        long[] aLong = new long[RANGE];\n+        long[] bLong = new long[RANGE];\n+        long[] cLong = new long[RANGE];\n+\n+        long start, stop;\n+\n+        int startIntAdd = init(aInt, bInt, cInt);\n+        int goldIntAdd = testIntAdd(aInt, bInt, cInt, startIntAdd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntAdd(aInt, bInt, cInt, startIntAdd);\n+            verify(\"int add\", total, goldIntAdd);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntAdd(aInt, bInt, cInt, startIntAdd);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int add    \" + (stop - start));\n+\n+        int startIntMul = init(aInt, bInt, cInt);\n+        int goldIntMul = testIntMul(aInt, bInt, cInt, startIntMul);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntMul(aInt, bInt, cInt, startIntMul);\n+            verify(\"int mul\", total, goldIntMul);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntMul(aInt, bInt, cInt, startIntMul);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int mul    \" + (stop - start));\n+\n+        int startIntMin = init(aInt, bInt, cInt);\n+        int goldIntMin = testIntMin(aInt, bInt, cInt, startIntMin);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntMin(aInt, bInt, cInt, startIntMin);\n+            verify(\"int min\", total, goldIntMin);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntMin(aInt, bInt, cInt, startIntMin);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int min    \" + (stop - start));\n+\n+        int startIntMax = init(aInt, bInt, cInt);\n+        int goldIntMax = testIntMax(aInt, bInt, cInt, startIntMax);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntMax(aInt, bInt, cInt, startIntMax);\n+            verify(\"int max\", total, goldIntMax);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntMax(aInt, bInt, cInt, startIntMax);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int max    \" + (stop - start));\n+\n+        int startIntAnd = init(aInt, bInt, cInt);\n+        int goldIntAnd = testIntAnd(aInt, bInt, cInt, startIntAnd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntAnd(aInt, bInt, cInt, startIntAnd);\n+            verify(\"int and\", total, goldIntAnd);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntAnd(aInt, bInt, cInt, startIntAnd);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int and    \" + (stop - start));\n+\n+        int startIntOr = init(aInt, bInt, cInt);\n+        int goldIntOr = testIntOr(aInt, bInt, cInt, startIntOr);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntOr(aInt, bInt, cInt, startIntOr);\n+            verify(\"int or\", total, goldIntOr);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntOr(aInt, bInt, cInt, startIntOr);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int or     \" + (stop - start));\n+\n+        int startIntXor = init(aInt, bInt, cInt);\n+        int goldIntXor = testIntXor(aInt, bInt, cInt, startIntXor);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            int total = testIntXor(aInt, bInt, cInt, startIntXor);\n+            verify(\"int xor\", total, goldIntXor);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testIntXor(aInt, bInt, cInt, startIntXor);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"int xor    \" + (stop - start));\n+\n+        long startLongAdd = init(aLong, bLong, cLong);\n+        long goldLongAdd = testLongAdd(aLong, bLong, cLong, startLongAdd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongAdd(aLong, bLong, cLong, startLongAdd);\n+            verify(\"long add\", total, goldLongAdd);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongAdd(aLong, bLong, cLong, startLongAdd);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long add   \" + (stop - start));\n+\n+        long startLongMul = init(aLong, bLong, cLong);\n+        long goldLongMul = testLongMul(aLong, bLong, cLong, startLongMul);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongMul(aLong, bLong, cLong, startLongMul);\n+            verify(\"long mul\", total, goldLongMul);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongMul(aLong, bLong, cLong, startLongMul);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long mul   \" + (stop - start));\n+\n+        long startLongMin = init(aLong, bLong, cLong);\n+        long goldLongMin = testLongMin(aLong, bLong, cLong, startLongMin);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongMin(aLong, bLong, cLong, startLongMin);\n+            verify(\"long min\", total, goldLongMin);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongMin(aLong, bLong, cLong, startLongMin);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long min   \" + (stop - start));\n+\n+        long startLongMax = init(aLong, bLong, cLong);\n+        long goldLongMax = testLongMax(aLong, bLong, cLong, startLongMax);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongMax(aLong, bLong, cLong, startLongMax);\n+            verify(\"long max\", total, goldLongMax);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongMax(aLong, bLong, cLong, startLongMax);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long max   \" + (stop - start));\n+\n+        long startLongAnd = init(aLong, bLong, cLong);\n+        long goldLongAnd = testLongAnd(aLong, bLong, cLong, startLongAnd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongAnd(aLong, bLong, cLong, startLongAnd);\n+            verify(\"long and\", total, goldLongAnd);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongAnd(aLong, bLong, cLong, startLongAnd);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long and   \" + (stop - start));\n+\n+        long startLongOr = init(aLong, bLong, cLong);\n+        long goldLongOr = testLongOr(aLong, bLong, cLong, startLongOr);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongOr(aLong, bLong, cLong, startLongOr);\n+            verify(\"long or\", total, goldLongOr);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongOr(aLong, bLong, cLong, startLongOr);\n@@ -120,0 +230,2 @@\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"long or    \" + (stop - start));\n@@ -121,0 +233,6 @@\n+        long startLongXor = init(aLong, bLong, cLong);\n+        long goldLongXor = testLongXor(aLong, bLong, cLong, startLongXor);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            long total = testLongXor(aLong, bLong, cLong, startLongXor);\n+            verify(\"long xor\", total, goldLongXor);\n+        }\n@@ -122,2 +240,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            sumI = sumInt(a1, a2, a3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testLongXor(aLong, bLong, cLong, startLongXor);\n@@ -126,1 +244,1 @@\n-        System.out.println(\"sum int:    \" + (stop - start));\n+        System.out.println(\"long xor   \" + (stop - start));\n@@ -128,0 +246,6 @@\n+        float startFloatAdd = init(aFloat, bFloat, cFloat);\n+        float goldFloatAdd = testFloatAdd(aFloat, bFloat, cFloat, startFloatAdd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            float total = testFloatAdd(aFloat, bFloat, cFloat, startFloatAdd);\n+            verify(\"float add\", total, goldFloatAdd);\n+        }\n@@ -129,2 +253,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            sumL = sumLong(b1, b2, b3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testFloatAdd(aFloat, bFloat, cFloat, startFloatAdd);\n@@ -133,1 +257,1 @@\n-        System.out.println(\"sum long:   \" + (stop - start));\n+        System.out.println(\"float add  \" + (stop - start));\n@@ -135,0 +259,6 @@\n+        float startFloatMul = init(aFloat, bFloat, cFloat);\n+        float goldFloatMul = testFloatMul(aFloat, bFloat, cFloat, startFloatMul);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            float total = testFloatMul(aFloat, bFloat, cFloat, startFloatMul);\n+            verify(\"float mul\", total, goldFloatMul);\n+        }\n@@ -136,2 +266,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            sumF = sumFloat(c1, c2, c3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testFloatMul(aFloat, bFloat, cFloat, startFloatMul);\n@@ -140,1 +270,1 @@\n-        System.out.println(\"sum float:  \" + (stop - start));\n+        System.out.println(\"float mul  \" + (stop - start));\n@@ -142,0 +272,6 @@\n+        float startFloatMin = init(aFloat, bFloat, cFloat);\n+        float goldFloatMin = testFloatMin(aFloat, bFloat, cFloat, startFloatMin);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            float total = testFloatMin(aFloat, bFloat, cFloat, startFloatMin);\n+            verify(\"float min\", total, goldFloatMin);\n+        }\n@@ -143,2 +279,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            sumD = sumDouble(d1, d2, d3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testFloatMin(aFloat, bFloat, cFloat, startFloatMin);\n@@ -147,1 +283,1 @@\n-        System.out.println(\"sum double: \" + (stop - start));\n+        System.out.println(\"float min  \" + (stop - start));\n@@ -149,0 +285,6 @@\n+        float startFloatMax = init(aFloat, bFloat, cFloat);\n+        float goldFloatMax = testFloatMax(aFloat, bFloat, cFloat, startFloatMax);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            float total = testFloatMax(aFloat, bFloat, cFloat, startFloatMax);\n+            verify(\"float max\", total, goldFloatMax);\n+        }\n@@ -150,2 +292,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            mulI = prodInt(a1, a2, a3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testFloatMax(aFloat, bFloat, cFloat, startFloatMax);\n@@ -154,1 +296,1 @@\n-        System.out.println(\"prod int:    \" + (stop - start));\n+        System.out.println(\"float max  \" + (stop - start));\n@@ -156,0 +298,6 @@\n+        double startDoubleAdd = init(aDouble, bDouble, cDouble);\n+        double goldDoubleAdd = testDoubleAdd(aDouble, bDouble, cDouble, startDoubleAdd);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            double total = testDoubleAdd(aDouble, bDouble, cDouble, startDoubleAdd);\n+            verify(\"double add\", total, goldDoubleAdd);\n+        }\n@@ -157,2 +305,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            mulL = prodLong(b1, b2, b3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testDoubleAdd(aDouble, bDouble, cDouble, startDoubleAdd);\n@@ -161,1 +309,1 @@\n-        System.out.println(\"prod long:   \" + (stop - start));\n+        System.out.println(\"double add \" + (stop - start));\n@@ -163,0 +311,6 @@\n+        double startDoubleMul = init(aDouble, bDouble, cDouble);\n+        double goldDoubleMul = testDoubleMul(aDouble, bDouble, cDouble, startDoubleMul);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            double total = testDoubleMul(aDouble, bDouble, cDouble, startDoubleMul);\n+            verify(\"double mul\", total, goldDoubleMul);\n+        }\n@@ -164,2 +318,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            mulF = prodFloat(c1, c2, c3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testDoubleMul(aDouble, bDouble, cDouble, startDoubleMul);\n@@ -168,1 +322,1 @@\n-        System.out.println(\"prod float:  \" + (stop - start));\n+        System.out.println(\"double mul \" + (stop - start));\n@@ -170,0 +324,6 @@\n+        double startDoubleMin = init(aDouble, bDouble, cDouble);\n+        double goldDoubleMin = testDoubleMin(aDouble, bDouble, cDouble, startDoubleMin);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            double total = testDoubleMin(aDouble, bDouble, cDouble, startDoubleMin);\n+            verify(\"double min\", total, goldDoubleMin);\n+        }\n@@ -171,2 +331,2 @@\n-        for (int j = 0; j < 5000; j++) {\n-            mulD = prodDouble(d1, d2, d3);\n+        for (int j = 0; j < iter_perf; j++) {\n+            testDoubleMin(aDouble, bDouble, cDouble, startDoubleMin);\n@@ -175,1 +335,1 @@\n-        System.out.println(\"prod double: \" + (stop - start));\n+        System.out.println(\"double min \" + (stop - start));\n@@ -177,0 +337,79 @@\n+        double startDoubleMax = init(aDouble, bDouble, cDouble);\n+        double goldDoubleMax = testDoubleMax(aDouble, bDouble, cDouble, startDoubleMax);\n+        for (int j = 0; j < iter_warmup; j++) {\n+            double total = testDoubleMax(aDouble, bDouble, cDouble, startDoubleMax);\n+            verify(\"double max\", total, goldDoubleMax);\n+        }\n+        start = System.currentTimeMillis();\n+        for (int j = 0; j < iter_perf; j++) {\n+            testDoubleMax(aDouble, bDouble, cDouble, startDoubleMax);\n+        }\n+        stop = System.currentTimeMillis();\n+        System.out.println(\"double max \" + (stop - start));\n+\n+    }\n+\n+    \/\/ ------------------- Tests -------------------\n+\n+    static int testIntAdd(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total += v;\n+        }\n+        return total;\n+    }\n+\n+    static int testIntMul(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total *= v;\n+        }\n+        return total;\n+    }\n+\n+    static int testIntMin(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.min(total, v);\n+        }\n+        return total;\n+    }\n+\n+    static int testIntMax(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.max(total, v);\n+        }\n+        return total;\n+    }\n+\n+    static int testIntAnd(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total &= v;\n+        }\n+        return total;\n+    }\n+\n+    static int testIntOr(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total |= v;\n+        }\n+        return total;\n+    }\n+\n+    static int testIntXor(int[] a, int[] b, int[] c, int total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total ^= v;\n+        }\n+        return total;\n+    }\n+\n+    static long testLongAdd(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total += v;\n+        }\n+        return total;\n@@ -179,17 +418,4 @@\n-    public static void ReductionInit(int[] a1, int[] a2, int[] a3,\n-                                     long[] b1, long[] b2, long[] b3,\n-                                     float[] c1, float[] c2, float[] c3,\n-                                     double[] d1, double[] d2, double[] d3) {\n-        for(int i = 0; i < a1.length; i++) {\n-            a1[i] =          (i + 0);\n-            a2[i] =          (i + 1);\n-            a3[i] =          (i + 2);\n-            b1[i] =   (long) (i + 0);\n-            b2[i] =   (long) (i + 1);\n-            b3[i] =   (long) (i + 2);\n-            c1[i] =  (float) (i + 0);\n-            c2[i] =  (float) (i + 1);\n-            c3[i] =  (float) (i + 2);\n-            d1[i] = (double) (i + 0);\n-            d2[i] = (double) (i + 1);\n-            d3[i] = (double) (i + 2);\n+    static long testLongMul(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total *= v;\n@@ -197,0 +423,9 @@\n+        return total;\n+    }\n+\n+    static long testLongMin(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.min(total, v);\n+        }\n+        return total;\n@@ -199,4 +434,4 @@\n-    public static int sumInt(int[] a1, int[] a2, int[] a3) {\n-        int total = 0;\n-        for (int i = 0; i < a1.length; i++) {\n-            total += (a1[i] * a2[i]) + (a1[i] * a3[i]) + (a2[i] * a3[i]);\n+    static long testLongMax(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.max(total, v);\n@@ -207,4 +442,4 @@\n-    public static long sumLong(long[] b1, long[] b2, long[] b3) {\n-        long total = 0;\n-        for (int i = 0; i < b1.length; i++) {\n-            total += (b1[i] * b2[i]) + (b1[i] * b3[i]) + (b2[i] * b3[i]);\n+    static long testLongAnd(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total &= v;\n@@ -215,4 +450,4 @@\n-    public static float sumFloat(float[] c1, float[] c2, float[] c3) {\n-        float total = 0;\n-        for (int i = 0; i < c1.length; i++) {\n-            total += (c1[i] * c2[i]) + (c1[i] * c3[i]) + (c2[i] * c3[i]);\n+    static long testLongOr(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total |= v;\n@@ -223,4 +458,4 @@\n-    public static double sumDouble(double[] d1, double[] d2, double[] d3) {\n-        double total = 0;\n-        for (int i = 0; i < d1.length; i++) {\n-            total += (d1[i] * d2[i]) + (d1[i] * d3[i]) + (d2[i] * d3[i]);\n+    static long testLongXor(long[] a, long[] b, long[] c, long total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            long v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total ^= v;\n@@ -231,4 +466,4 @@\n-    public static int prodInt(int[] a1, int[] a2, int[] a3) {\n-        int total = 1;\n-        for (int i = 0; i < a1.length; i++) {\n-            total *= (a1[i] * a2[i]) + (a1[i] * a3[i]) + (a2[i] * a3[i]);\n+    static float testFloatAdd(float[] a, float[] b, float[] c, float total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            float v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total += v;\n@@ -239,4 +474,4 @@\n-    public static long prodLong(long[] b1, long[] b2, long[] b3) {\n-        long total = 1;\n-        for (int i = 0; i < b1.length; i++) {\n-            total *= (b1[i] * b2[i]) + (b1[i] * b3[i]) + (b2[i] * b3[i]);\n+    static float testFloatMul(float[] a, float[] b, float[] c, float total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            float v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total *= v;\n@@ -247,4 +482,4 @@\n-    public static float prodFloat(float[] c1, float[] c2, float[] c3) {\n-        float total = 1;\n-        for (int i = 0; i < c1.length; i++) {\n-            total *= (c1[i] * c2[i]) + (c1[i] * c3[i]) + (c2[i] * c3[i]);\n+    static float testFloatMin(float[] a, float[] b, float[] c, float total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            float v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.min(total, v);\n@@ -255,4 +490,4 @@\n-    public static double prodDouble(double[] d1, double[] d2, double[] d3) {\n-        double total = 1;\n-        for (int i = 0; i < d1.length; i++) {\n-            total *= (d1[i] * d2[i]) + (d1[i] * d3[i]) + (d2[i] * d3[i]);\n+    static float testFloatMax(float[] a, float[] b, float[] c, float total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            float v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.max(total, v);\n@@ -262,0 +497,93 @@\n+\n+    static double testDoubleAdd(double[] a, double[] b, double[] c, double total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            double v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total += v;\n+        }\n+        return total;\n+    }\n+\n+    static double testDoubleMul(double[] a, double[] b, double[] c, double total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            double v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total *= v;\n+        }\n+        return total;\n+    }\n+\n+    static double testDoubleMin(double[] a, double[] b, double[] c, double total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            double v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.min(total, v);\n+        }\n+        return total;\n+    }\n+\n+    static double testDoubleMax(double[] a, double[] b, double[] c, double total) {\n+        for (int i = 0; i < RANGE; i++) {\n+            double v = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+            total = Math.max(total, v);\n+        }\n+        return total;\n+    }\n+\n+    \/\/ ------------------- Initialization -------------------\n+\n+    static int init(int[] a, int[] b, int[] c) {\n+        for (int j = 0; j < RANGE; j++) {\n+            a[j] = rand.nextInt();\n+            b[j] = rand.nextInt();\n+            c[j] = rand.nextInt();\n+        }\n+        return rand.nextInt();\n+    }\n+\n+    static long init(long[] a, long[] b, long[] c) {\n+        for (int j = 0; j < RANGE; j++) {\n+            a[j] = rand.nextLong();\n+            b[j] = rand.nextLong();\n+            c[j] = rand.nextLong();\n+        }\n+        return rand.nextLong();\n+    }\n+\n+    static float init(float[] a, float[] b, float[] c) {\n+        for (int j = 0; j < RANGE; j++) {\n+            a[j] = rand.nextFloat();\n+            b[j] = rand.nextFloat();\n+            c[j] = rand.nextFloat();\n+        }\n+        return rand.nextFloat();\n+    }\n+\n+    static double init(double[] a, double[] b, double[] c) {\n+        for (int j = 0; j < RANGE; j++) {\n+            a[j] = rand.nextDouble();\n+            b[j] = rand.nextDouble();\n+            c[j] = rand.nextDouble();\n+        }\n+        return rand.nextDouble();\n+    }\n+\n+    \/\/ ------------------- Verification -------------------\n+\n+    static void verify(String context, double total, double gold) {\n+        if (total != gold) {\n+            throw new RuntimeException(\"Wrong result for \" + context + \": \" + total + \" != \" + gold);\n+        }\n+    }\n+    static void verify(String context, float total, float gold) {\n+        if (total != gold) {\n+            throw new RuntimeException(\"Wrong result for \" + context + \": \" + total + \" != \" + gold);\n+        }\n+    }\n+    static void verify(String context, int total, int gold) {\n+        if (total != gold) {\n+            throw new RuntimeException(\"Wrong result for \" + context + \": \" + total + \" != \" + gold);\n+        }\n+    }\n+    static void verify(String context, long total, long gold) {\n+        if (total != gold) {\n+            throw new RuntimeException(\"Wrong result for \" + context + \": \" + total + \" != \" + gold);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ReductionPerf.java","additions":491,"deletions":163,"binary":false,"changes":654,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\"})\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\", IRNode.ADD_REDUCTION_VI, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\"})\n+        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\", IRNode.ADD_REDUCTION_VL, \"<= 2\"}) \/\/ one for main-loop, one for vector-post-loop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Long.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}