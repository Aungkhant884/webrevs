{"files":[{"patch":"@@ -164,1 +164,0 @@\n-\n@@ -1783,22 +1782,38 @@\n-                    int gzlevel = 0;\n-                    \/* Parse \"gz=\" option. *\/\n-                    String option = t.nextToken();\n-                    String[] keyValue = option.split(\"=\");\n-                    if (keyValue.length == 1) {\n-                        err.println(\"Argument is expected for \\\"gz\\\"\");\n-                        usage();\n-                        return;\n-                    }\n-                    if (keyValue[0].equals(\"gz\")) {\n-                        String level = keyValue[1];\n-                        try {\n-                            gzlevel = Integer.parseInt(level);\n-                        } catch (NumberFormatException e) {\n-                            err.println(\"gz option value not an integer (\"+level+\")\");\n-                            usage();\n-                            return;\n-                        }\n-                        if (gzlevel < 1 || gzlevel > 9) {\n-                            err.println(\"Compression level out of range (1-9): \" + level);\n-                            usage();\n-                            return;\n+                    int gzlevel = -1;\n+                    int cntTokens = t.countTokens();\n+                    if (cntTokens > 0) {\n+                        String option = t.nextToken();\n+                        \/*\n+                         * possible command:\n+                         *     dumpheap gz=1 file;\n+                         *     dumpheap gz=1;\n+                         *     dumpheap file;\n+                         *\/\n+                        if (cntTokens == 2) {\n+                            \/* first argument is compression level, second is filename *\/\n+                            \/* Parse \"gz=\" option. *\/\n+                            gzlevel = parseHeapDumpCompressionLevel(option);\n+                            if (gzlevel < 1) {\n+                                usage();\n+                                return;\n+                            }\n+                            \/* Parse filename. *\/\n+                            filename = t.nextToken();\n+                        } else if (cntTokens == 1) {\n+                            filename = option;\n+                            \/\/ Try to parse \"gz=\" option, if failed, treat it as filename\n+                            if (option.startsWith(\"gz=\")) {\n+                              gzlevel = parseHeapDumpCompressionLevel(option);\n+                              if (gzlevel < 1) {\n+                                  err.println(\"Can not parse compression level from option \\\"\" + option + \"\\\".\");\n+                                  if (gzlevel == 0) {\n+                                      \/\/ compression level not in range.\n+                                      usage();\n+                                      return;\n+                                  } else {\n+                                      out.println(\"Use \\\"\" + option +\"\\\" as dumped file name.\");\n+                                  }\n+                              } else {\n+                                  filename = \"heap.bin.gz\";\n+                              }\n+                            }\n@@ -1806,10 +1821,0 @@\n-                        filename = \"heap.bin.gz\";\n-                    } else {\n-                        usage();\n-                        return;\n-                    }\n-                    \/* Parse filename. *\/\n-                    if (t.countTokens() == 2) {\n-                        filename = t.nextToken();\n-                    } else if (t.countTokens() == 1) {\n-                        filename = option;\n@@ -2089,0 +2094,29 @@\n+ \n+    \/* Parse compression level\n+     * @return  0 compress level is out of range\n+     *          1 compress level can not be parsed as number\n+     *\/\n+    private int parseHeapDumpCompressionLevel(String option) {\n+        int gzl = -1;\n+        String[] keyValue = option.split(\"=\");\n+        if (keyValue[0].equals(\"gz\")) {\n+            if (keyValue.length == 1) {\n+                err.println(\"Argument is expected for \\\"gz\\\"\");\n+                return -1;\n+            }\n+            String level = keyValue[1];\n+            try {\n+                gzl = Integer.parseInt(level);\n+            } catch (NumberFormatException e) {\n+                err.println(\"gz option value not an integer (\"+level+\")\");\n+                return -1;\n+            }\n+            if (gzl < 1 || gzl > 9) {\n+                err.println(\"Compression level out of range (1-9): \" + level);\n+                gzl = 0;\n+            }\n+        } else {\n+            err.println(\"Unknow option \\\"\" + option + \"\\\"\");\n+        }\n+        return gzl;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":67,"deletions":33,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-            if (gzLevel == 0) {\n+            if (gzLevel == -1) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/JMap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-        \/\/ Check weather we should dump the heap as segments\n+        \/\/ Check whether we should dump the heap as segments\n@@ -421,1 +421,1 @@\n-            hprofBufferedOut = new SegmentedOutputStream(fos, false);\n+            hprofBufferedOut = new SegmentedOutputStream(fos, false \/* allowSegmented *\/);\n@@ -474,1 +474,1 @@\n-            \/\/ Fill in final length\n+            \/\/ Fill in final length.\n@@ -477,1 +477,1 @@\n-            hprofBufferedOut.exitSegmentMode();\n+            hprofBufferedOut.finish();\n@@ -517,1 +517,1 @@\n-        assert !useSegmentedHeapDump : \"fillInHeapRecordLength is not supported for segment heap dump\";\n+        assert !useSegmentedHeapDump : \"fillInHeapRecordLength is not supported for segmented heap dump\";\n@@ -1307,1 +1307,1 @@\n-     * The class implements a buffered output stream for segment data dump.\n+     * The class implements a buffered output stream for segmented data dump.\n@@ -1309,1 +1309,1 @@\n-     * Because the current implementation of segment heap dump needs to update\n+     * Because the current implementation of segmented heap dump needs to update\n@@ -1313,1 +1313,1 @@\n-     * GZIPOutputStream when the whole segment data are ready and the size is updated.\n+     * GZIPOutputStream when the whole segmented data are ready and the size is updated.\n@@ -1316,2 +1316,2 @@\n-     * This class defines a switch to turn on\/off the segment mode. if turned off,\n-     * it behaves same as BufferedOutputStream.\n+     * This class defines a switch to turn on\/off the segmented mode. If turned off,\n+     * it behaves the same as BufferedOutputStream.\n@@ -1321,1 +1321,1 @@\n-         * Creates a new buffered output stream to support segment heap dump data.\n+         * Creates a new buffered output stream to support segmented heap dump data.\n@@ -1324,1 +1324,1 @@\n-         * @param   allowSegmental      whether allow segmental dump.\n+         * @param   allowSegmented      whether allow segmental dump.\n@@ -1326,1 +1326,1 @@\n-        public SegmentedOutputStream(OutputStream out, boolean allowSegmental) {\n+        public SegmentedOutputStream(OutputStream out, boolean allowSegmented) {\n@@ -1329,1 +1329,1 @@\n-            this.allowSegmental = allowSegmental;\n+            this.allowSegmented = allowSegmented;\n@@ -1335,1 +1335,1 @@\n-         * Creates a new buffered output stream to support segment heap dump data.\n+         * Creates a new buffered output stream to support segmented heap dump data.\n@@ -1408,1 +1408,1 @@\n-                        : \"invalid header in segment mode\";\n+                        : \"invalid header in segmented mode\";\n@@ -1426,1 +1426,1 @@\n-         * Enters segment mode, flush buffered data and set flag.\n+         * Enters segmented mode, flush buffered data and set flag.\n@@ -1429,1 +1429,1 @@\n-            if (allowSegmental && !segmentMode) {\n+            if (allowSegmented && !segmentMode && segmentWritten == 0) {\n@@ -1437,1 +1437,13 @@\n-         * Exits segment mode, flush segment data.\n+         * Before finish, flush all data in buffer.\n+         *\/\n+        public void finish() throws IOException {\n+            if (allowSegmented && segmentMode) {\n+                flush();\n+                assert segmentWritten == 0;\n+                segmentMode = false;\n+            }\n+        }\n+\n+        \/**\n+         * Exits segmented mode, flush segmented data.\n+         * @param    force    flush data regardless whether the buffer is full\n@@ -1440,1 +1452,1 @@\n-            if (allowSegmental && segmentMode) {\n+            if (allowSegmented && segmentMode && shouldFlush()) {\n@@ -1447,0 +1459,13 @@\n+\n+        \/**\n+         * Check whether the data should be flush based on data saved in\n+         * segmentBuffer.\n+         * This method is used to control the segments number and the memory usage.\n+         * If segment is too small, there will be lots segments in final dump file.\n+         * If it is too large, lots of memory is used in RAM.\n+         *\/\n+        private boolean shouldFlush() {\n+            \/\/ return true if data in segmentBuffer has been extended.\n+            return segmentWritten > SEGMENT_BUFFER_SIZE;\n+        }\n+\n@@ -1459,1 +1484,1 @@\n-         * Fills the segment data size into the header.\n+         * Fills the segmented data size into the header.\n@@ -1481,2 +1506,2 @@\n-        \/\/ data, making the segment data stored in this buffer could help rewrite the data\n-        \/\/ size before the segment data are written to underlying GZIPOutputStream.\n+        \/\/ data, making the segmented data stored in this buffer could help rewrite the data\n+        \/\/ size before the segmented data are written to underlying GZIPOutputStream.\n@@ -1493,1 +1518,1 @@\n-        private boolean allowSegmental;\n+        private boolean allowSegmented;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":49,"deletions":24,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.util.zip.GZIPInputStream;\n@@ -28,0 +32,3 @@\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.assertFalse;\n+import jdk.test.lib.hprof.HprofParser;\n@@ -42,0 +49,3 @@\n+    private static final String kHeapDumpFileNameDefault = \"heap.bin\";\n+    private static final String kHeapDumpFileNameGzDefault = \"heap.bin.gz\";\n+\n@@ -54,0 +64,78 @@\n+    private static void verifyDumpFile(File dump, boolean compression) throws Exception {\n+        assertTrue(dump.exists() && dump.isFile(), \"Could not create dump file \" + dump.getAbsolutePath());\n+        if (!compression) {\n+            printStackTraces(dump.getAbsolutePath());\n+            return;\n+        } else {\n+            String deCompressedFile = \"SAdump\" + System.currentTimeMillis() + \".hprof\";\n+            File out = new File(deCompressedFile);\n+            try {\n+                GZIPInputStream gis = new GZIPInputStream(new FileInputStream(dump));\n+                FileOutputStream fos = new FileOutputStream(out);\n+                byte[] buffer = new byte[1 << 20];\n+                int len = 0;\n+                while ((len = gis.read(buffer)) > 0) {\n+                    fos.write(buffer, 0, len);\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Can not decompress the compressed hprof file\");\n+            }\n+            printStackTraces(out.getAbsolutePath());\n+            out.delete();\n+        }\n+    }\n+\n+    private static class SubTest {\n+        private String cmd;\n+        private String fileName;\n+        private String expectedOutput;\n+        boolean compression;\n+        boolean needVerify;\n+\n+        public SubTest(String comm, String fName, String expected, boolean isComp, boolean verify) {\n+            cmd = comm;\n+            fileName = fName;\n+            expectedOutput = expected;\n+            compression = isComp;\n+            needVerify = verify;\n+        }\n+\n+        public String getCmd() { return cmd; }\n+        public String getFileName() { return fileName; }\n+        public String getExpectedOutput() { return expectedOutput; }\n+        public boolean isCompression() { return compression; }\n+        public boolean needVerify() { return needVerify; }\n+    }\n+\n+    private static void runTest(long appPid, SubTest subtest) throws Exception {\n+        ClhsdbLauncher test = new ClhsdbLauncher();\n+        String fileName = subtest.getFileName();\n+        String cmd = subtest.getCmd();\n+        String expectedOutput = subtest.getExpectedOutput();\n+        boolean compression = subtest.isCompression();\n+        \/* The expected generated file, used to distinguish with fileName in case fileName is blank or null *\/\n+        String expectedFileName = fileName;\n+        if (fileName == null || fileName.length() == 0) {\n+            if (!compression) {\n+                expectedFileName = kHeapDumpFileNameDefault;\n+            } else {\n+                expectedFileName = kHeapDumpFileNameGzDefault;\n+            }\n+        }\n+        assertTrue (expectedFileName != null && expectedFileName.length() > 0,\n+                \"Expected generated file name must have value\");\n+        File file = new File(expectedFileName);\n+        if (file.exists()) {\n+            file.delete();\n+        }\n+        String command = cmd + fileName;\n+        List<String> cmds = List.of(command);\n+        Map<String, List<String>> expStrMap = new HashMap<>();\n+        expStrMap.put(command, List.of(expectedOutput));\n+        test.run(appPid, cmds, expStrMap, null);\n+        if (subtest.needVerify()) {\n+            verifyDumpFile(file, compression);\n+        }\n+        file.delete();\n+    }\n+\n@@ -59,0 +147,1 @@\n+            \/\/ Use file name different with JDK's default value \"heapdump.bin\".\n@@ -60,1 +149,1 @@\n-            ClhsdbLauncher test = new ClhsdbLauncher();\n+            String heapDumpFileNameGz = \"heapdump.bin.gz\";\n@@ -66,1 +155,32 @@\n-            List<String> cmds = List.of(\"dumpheap \" + heapDumpFileName);\n+            SubTest[] subtests = new SubTest[] {\n+                    new SubTest(\"dumpheap \", heapDumpFileName,\n+                            \"heap written to \" + heapDumpFileName, false\/*compression*\/, true\/*verify*\/),\n+                    new SubTest(\"dumpheap gz=1 \", heapDumpFileNameGz,\n+                            \"heap written to \" + heapDumpFileNameGz, true, true),\n+                    new SubTest(\"dumpheap gz=9 \", heapDumpFileNameGz,\n+                            \"heap written to \" + heapDumpFileNameGz, true, true),\n+                    new SubTest(\"dumpheap gz=0 \", heapDumpFileNameGz,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\", true, false),\n+                    new SubTest(\"dumpheap gz=100 \", heapDumpFileNameGz,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\", true, false),\n+                    new SubTest(\"dumpheap gz= \", heapDumpFileNameGz,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\", true, false),\n+                    new SubTest(\"dumpheap gz \", heapDumpFileNameGz,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\", true, false),\n+                    new SubTest(\"dumpheap\", \"\",\n+                            \"heap written to \" + kHeapDumpFileNameDefault, false, true),\n+                    new SubTest(\"dumpheap gz=1\", \"\",\n+                            \"heap written to \" + kHeapDumpFileNameGzDefault, true, true),\n+                    new SubTest(\"dumpheap gz=9\", \"\",\n+                            \"heap written to \" + kHeapDumpFileNameGzDefault, true, true),\n+                    new SubTest(\"dumpheap gz=0\", \"\",\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\", true, false),\n+                    new SubTest(\"dumpheap gz=100\", \"\",\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\", true, false),\n+                    \/\/ command \"dumpheap gz=\"\n+                    new SubTest(\"dumpheap \", \"gz=\",\n+                            \"heap written to gz=\", false, true),\n+                    \/\/ command \"dumpheap gz\"\n+                    new SubTest(\"dumpheap \", \"gz\",\n+                            \"heap written to gz\", false, true)\n+            };\n@@ -68,6 +188,3 @@\n-            Map<String, List<String>> expStrMap = new HashMap<>();\n-            expStrMap.put(\"dumpheap\", List.of(\n-                    \"heap written to \" + heapDumpFileName));\n-\n-            test.run(theApp.getPid(), cmds, expStrMap, null);\n-            printStackTraces(heapDumpFileName);\n+            for (int i = 0; i < subtests.length;i++) {\n+                runTest(theApp.getPid(), subtests[i]);\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpheap.java","additions":125,"deletions":8,"binary":false,"changes":133,"status":"modified"}]}