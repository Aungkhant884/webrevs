{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,1 +164,0 @@\n-\n@@ -1776,1 +1775,1 @@\n-        new Command(\"dumpheap\", \"dumpheap [filename]\", false) {\n+        new Command(\"dumpheap\", \"dumpheap [gz=<1-9>] [filename]\", false) {\n@@ -1778,1 +1777,2 @@\n-                if (t.countTokens() > 1) {\n+                int cntTokens = t.countTokens();\n+                if (cntTokens > 2) {\n@@ -1782,2 +1782,37 @@\n-                    String filename;\n-                    if (t.countTokens() == 1) {\n+                    String filename = \"heap.bin\";\n+                    int gzlevel = 0;\n+                    \/*\n+                     * Possible command:\n+                     *     dumpheap gz=1 file;\n+                     *     dumpheap gz=1;\n+                     *     dumpheap file;\n+                     *     dumpheap\n+                     *\n+                     * Use default filename if cntTokens == 0.\n+                     * Handle cases with cntTokens == 1 or 2.\n+                     *\/\n+                    if (cntTokens > 2) {\n+                        err.println(\"Too big number of options: \" + cntTokens);\n+                        usage();\n+                        return;\n+                    }\n+                    if (cntTokens >= 1) { \/\/ parse first argument which is \"gz=\" option\n+                        String option = t.nextToken();\n+                        if (!option.startsWith(\"gz=\")) {\n+                            filename = option;\n+                        } else {\n+                            gzlevel = parseHeapDumpCompressionLevel(option);\n+                            if (gzlevel <= 0 || gzlevel > 9) {\n+                                usage();\n+                                return;\n+                            }\n+                            filename = \"heap.bin.gz\";\n+                        }\n+                    }\n+                    if (cntTokens == 2) { \/\/ parse second argument which is filename\n+                        if (gzlevel == 0) {\n+                            \/\/ The first option is not compression level, it is parsed as filename.\n+                            err.println(\"unknown option: \" + filename);\n+                            usage();\n+                            return;\n+                        }\n@@ -1785,2 +1820,5 @@\n-                    } else {\n-                        filename = \"heap.bin\";;\n+                        if (filename.startsWith(\"gz=\")) {\n+                            err.println(\"Filename should not start with \\\"gz=\\\": \" + filename);\n+                            usage();\n+                            return;\n+                        }\n@@ -1789,1 +1827,1 @@\n-                        jmap.writeHeapHprofBin(filename);\n+                        jmap.writeHeapHprofBin(filename, gzlevel);\n@@ -2060,0 +2098,30 @@\n+\n+    \/* Parse compression level\n+     * @return   1-9    compression level\n+     *           0      compression level is illegal\n+     *\/\n+    private int parseHeapDumpCompressionLevel(String option) {\n+\n+        String[] keyValue = option.split(\"=\");\n+        if (!keyValue[0].equals(\"gz\")) {\n+            err.println(\"Expected option is \\\"gz=\\\"\");\n+            return 0;\n+        }\n+        if (keyValue.length != 2) {\n+            err.println(\"Exactly one argument is expected for option \\\"gz\\\"\");\n+            return 0;\n+        }\n+        int gzl = 0;\n+        String level = keyValue[1];\n+        try {\n+            gzl = Integer.parseInt(level);\n+        } catch (NumberFormatException e) {\n+            err.println(\"gz option value not an integer (\"+level+\")\");\n+            return 0;\n+        }\n+        if (gzl < 1 || gzl > 9) {\n+            err.println(\"Compression level out of range (1-9): \" + level);\n+            return 0;\n+        }\n+        return gzl;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":77,"deletions":9,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,2 +128,3 @@\n-        System.out.println(\"    --binaryheap            To dump java heap in hprof binary format.\");\n-        System.out.println(\"    --dumpfile <name>       The name of the dump file.\");\n+        System.out.println(\"    --binaryheap            To dump java heap in hprof binary format. Only valid with --binaryheap.\");\n+        System.out.println(\"    --dumpfile <name>       The name of the dump file. Only valid with --binaryheap.\");\n+        System.out.println(\"    --gz <1-9>              The compression level for gzipped dump file.\");\n@@ -304,10 +305,12 @@\n-        Map<String, String> longOptsMap = Map.of(\"exe=\", \"exe\",\n-                                                 \"core=\", \"core\",\n-                                                 \"pid=\", \"pid\",\n-                                                 \"connect=\", \"connect\",\n-                                                 \"heap\", \"-heap\",\n-                                                 \"binaryheap\", \"binaryheap\",\n-                                                 \"dumpfile=\", \"dumpfile\",\n-                                                 \"histo\", \"-histo\",\n-                                                 \"clstats\", \"-clstats\",\n-                                                 \"finalizerinfo\", \"-finalizerinfo\");\n+        Map<String, String> longOptsMap = Map.ofEntries(\n+                Map.entry(\"exe=\", \"exe\"),\n+                Map.entry(\"core=\", \"core\"),\n+                Map.entry(\"pid=\", \"pid\"),\n+                Map.entry(\"connect=\", \"connect\"),\n+                Map.entry(\"heap\", \"-heap\"),\n+                Map.entry(\"binaryheap\", \"binaryheap\"),\n+                Map.entry(\"dumpfile=\", \"dumpfile\"),\n+                Map.entry(\"gz=\", \"gz\"),\n+                Map.entry(\"histo\", \"-histo\"),\n+                Map.entry(\"clstats\", \"-clstats\"),\n+                Map.entry(\"finalizerinfo\", \"-finalizerinfo\"));\n@@ -318,0 +321,2 @@\n+        String gzLevel = newArgMap.get(\"gz\");\n+        String command = \"-heap:format=b\";\n@@ -322,4 +327,5 @@\n-            if (dumpfile == null) {\n-                newArgMap.put(\"-heap:format=b\", null);\n-            } else {\n-                newArgMap.put(\"-heap:format=b,file=\" + dumpfile, null);\n+            if (gzLevel != null) {\n+                command += \",gz=\" + gzLevel;\n+            }\n+            if (dumpfile != null) {\n+                command += \",file=\" + dumpfile;\n@@ -327,0 +333,1 @@\n+            newArgMap.put(command, null);\n@@ -331,0 +338,1 @@\n+        newArgMap.remove(\"gz\");\n@@ -488,0 +496,2 @@\n+            \/\/ Exit with error status\n+            System.exit(1);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/SALauncher.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return \"-heap|-heap:format=b|-histo|-clstats|-finalizerinfo\";\n+        return \"-heap|-heap:format=b[,gz=<1-9>][,file=<dumpfile>]|-heap:format=x[,file=<dumpfile>]|{-histo|-clstats|-finalizerinfo\";\n@@ -57,6 +57,11 @@\n-        System.out.println(\"    <no option>\\tto print same info as Solaris pmap\");\n-        System.out.println(\"    -heap\\tto print java heap summary\");\n-        System.out.println(\"    -heap:format=b\\tto dump java heap in hprof binary format\");\n-        System.out.println(\"    -histo\\tto print histogram of java object heap\");\n-        System.out.println(\"    -clstats\\tto print class loader statistics\");\n-        System.out.println(\"    -finalizerinfo\\tto print information on objects awaiting finalization\");\n+        System.out.println(\"    <no option>\\tTo print same info as Solaris pmap.\");\n+        System.out.println(\"    -heap\\tTo print java heap summary.\");\n+        System.out.println(\"    -heap:format=b[,gz=<1-9>][,file=<dumpfile>]  \\tTo dump java heap in hprof binary format.\");\n+        System.out.println(\"                                                 \\tIf gz specified, the heap dump is written in gzipped format\");\n+        System.out.println(\"                                                 \\tusing the given compression level.\");\n+        System.err.println(\"                                                 \\t1 (recommended) is the fastest, 9 the strongest compression.\");\n+        System.out.println(\"    -heap:format=x[,file=<dumpfile>]             \\tTo dump java heap in GXL format.\");\n+        System.out.println(\"                                                 \\tPlease be aware that \\\"gz\\\" option is not valid for heap dump in GXL format.\");\n+        System.out.println(\"    -histo\\tTo print histogram of java object heap.\");\n+        System.out.println(\"    -clstats\\tTo print class loader statistics.\");\n+        System.out.println(\"    -finalizerinfo\\tTo print information on objects awaiting finalization.\");\n@@ -75,0 +80,1 @@\n+    private static int gzLevel = 0;\n@@ -97,1 +103,1 @@\n-            writeHeapHprofBin(dumpfile);\n+            writeHeapHprofBin(dumpfile, gzLevel);\n@@ -154,0 +160,20 @@\n+                        } else if (keyValue[0].equals(\"gz\")) {\n+                            if (mode == MODE_HEAP_GRAPH_GXL) {\n+                                System.err.println(\"\\\"gz\\\" option is not compatible with heap dump in GXL format\");\n+                                System.exit(1);\n+                            }\n+                            if (keyValue.length == 1) {\n+                                System.err.println(\"Argument is expected for \\\"gz\\\"\");\n+                                System.exit(1);\n+                            }\n+                            String level = keyValue[1];\n+                            try {\n+                                gzLevel = Integer.parseInt(level);\n+                            } catch (NumberFormatException e) {\n+                                System.err.println(\"\\\"gz\\\" option value not an integer (\"+level+\")\");\n+                                System.exit(1);\n+                            }\n+                            if (gzLevel < 1 || gzLevel > 9) {\n+                                System.err.println(\"compression level out of range (1-9): \" + level);\n+                                System.exit(1);\n+                            }\n@@ -179,1 +205,1 @@\n-    public boolean writeHeapHprofBin(String fileName) {\n+    public boolean writeHeapHprofBin(String fileName, int gzLevel) {\n@@ -181,1 +207,9 @@\n-            HeapGraphWriter hgw = new HeapHprofBinWriter();\n+            HeapGraphWriter hgw;\n+            if (gzLevel == 0) {\n+                hgw = new HeapHprofBinWriter();\n+            } else if (gzLevel >=1 && gzLevel <= 9) {\n+                hgw = new HeapHprofBinWriter(gzLevel);\n+            } else {\n+                System.err.println(\"Illegal compression level: \" + gzLevel);\n+                return false;\n+            }\n@@ -191,1 +225,1 @@\n-        return writeHeapHprofBin(\"heap.bin\");\n+        return writeHeapHprofBin(\"heap.bin\", -1);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/JMap.java","additions":46,"deletions":12,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.zip.*;\n@@ -389,0 +390,7 @@\n+        this.gzLevel = 0;\n+    }\n+\n+    public HeapHprofBinWriter(int gzLevel) {\n+        this.KlassMap = new ArrayList<Klass>();\n+        this.names = new HashSet<Symbol>();\n+        this.gzLevel = gzLevel;\n@@ -394,0 +402,4 @@\n+        \/\/ Check whether we should dump the heap as segments\n+        useSegmentedHeapDump = isCompression() ||\n+                (vm.getUniverse().heap().used() > HPROF_SEGMENTED_HEAP_DUMP_THRESHOLD);\n+\n@@ -396,2 +408,15 @@\n-        out = new DataOutputStream(new BufferedOutputStream(fos));\n-\n+        hprofBufferedOut = null;\n+        OutputStream dataOut = fos;\n+        if (useSegmentedHeapDump) {\n+            if (isCompression()) {\n+                dataOut = new GZIPOutputStream(fos) {\n+                    {\n+                        this.def.setLevel(gzLevel);\n+                    }\n+                };\n+            }\n+            hprofBufferedOut = new SegmentedOutputStream(dataOut);\n+        } else {\n+            hprofBufferedOut = new SegmentedOutputStream(fos, false \/* allowSegmented *\/);\n+        }\n+        out = new DataOutputStream(hprofBufferedOut);\n@@ -422,3 +447,0 @@\n-        \/\/ Check weather we should dump the heap as segments\n-        useSegmentedHeapDump = vm.getUniverse().heap().used() > HPROF_SEGMENTED_HEAP_DUMP_THRESHOLD;\n-\n@@ -450,4 +472,5 @@\n-        \/\/ Fill in final length\n-        fillInHeapRecordLength();\n-\n-        if (useSegmentedHeapDump) {\n+        if (!useSegmentedHeapDump) {\n+            \/\/ Fill in final length.\n+            fillInHeapRecordLength();\n+        } else {\n+            hprofBufferedOut.finish();\n@@ -462,0 +485,1 @@\n+        out.close();\n@@ -463,3 +487,1 @@\n-\n-        \/\/ close the file stream\n-        fos.close();\n+        hprofBufferedOut = null;\n@@ -470,5 +492,5 @@\n-        if (currentSegmentStart == 0) {\n-            \/\/ write heap data header, depending on heap size use segmented heap\n-            \/\/ format\n-            out.writeByte((byte) (useSegmentedHeapDump ? HPROF_HEAP_DUMP_SEGMENT\n-                    : HPROF_HEAP_DUMP));\n+        if (useSegmentedHeapDump) {\n+            hprofBufferedOut.enterSegmentMode();\n+        } else if (currentSegmentStart == 0) {\n+            \/\/ write heap data header\n+            out.writeByte((byte) (HPROF_HEAP_DUMP));\n@@ -489,5 +511,1 @@\n-            out.flush();\n-            if ((fos.getChannel().position() - currentSegmentStart - 4L) >= HPROF_SEGMENTED_HEAP_DUMP_SEGMENT_SIZE) {\n-                fillInHeapRecordLength();\n-                currentSegmentStart = 0;\n-            }\n+            hprofBufferedOut.exitSegmentMode();\n@@ -498,0 +516,1 @@\n+        assert !useSegmentedHeapDump : \"fillInHeapRecordLength is not supported for segmented heap dump\";\n@@ -572,0 +591,2 @@\n+        \/\/ only process when segmented heap dump is not used, since SegmentedOutputStream\n+        \/\/ could create segment automatically.\n@@ -573,1 +594,1 @@\n-        if (currentRecordLength > 0 &&\n+        if ((!useSegmentedHeapDump) && currentRecordLength > 0 &&\n@@ -1229,0 +1250,4 @@\n+    private boolean isCompression() {\n+        return (gzLevel >= 1 && gzLevel <= 9);\n+    }\n+\n@@ -1236,0 +1261,1 @@\n+    private SegmentedOutputStream hprofBufferedOut;\n@@ -1239,0 +1265,1 @@\n+    private int gzLevel;\n@@ -1277,0 +1304,220 @@\n+\n+    \/**\n+     * The class implements a buffered output stream for segmented data dump.\n+     * It is used inside HeapHprofBinWritter only for heap dump.\n+     * Because the current implementation of segmented heap dump needs to update\n+     * the segment size at segment header, and because it is hard to modify the\n+     * compressed data after they are written to file, this class first saves the\n+     * uncompressed data into an internal buffer, and then writes through to the\n+     * GZIPOutputStream when the whole segmented data are ready and the size is updated.\n+     * If the data to be written are larger than internal buffer, or the internal buffer\n+     * is full, the internal buffer will be extend to a larger one.\n+     * This class defines a switch to turn on\/off the segmented mode. If turned off,\n+     * it behaves the same as BufferedOutputStream.\n+     * *\/\n+    private class SegmentedOutputStream extends BufferedOutputStream {\n+        \/**\n+         * Creates a new buffered output stream to support segmented heap dump data.\n+         *\n+         * @param   out                 the underlying output stream.\n+         * @param   allowSegmented      whether allow segmental dump.\n+         *\/\n+        public SegmentedOutputStream(OutputStream out, boolean allowSegmented) {\n+            super(out, 8192);\n+            segmentMode = false;\n+            this.allowSegmented = allowSegmented;\n+            segmentBuffer = new byte[SEGMENT_BUFFER_SIZE];\n+            segmentWritten = 0;\n+        }\n+\n+        \/**\n+         * Creates a new buffered output stream to support segmented heap dump data.\n+         *\n+         * @param   out      the underlying output stream.\n+         *\/\n+        public SegmentedOutputStream(OutputStream out) {\n+            this(out, true);\n+        }\n+\n+        \/**\n+         * Writes the specified byte to this buffered output stream.\n+         *\n+         * @param      b   the byte to be written.\n+         * @throws     IOException  if an I\/O error occurs.\n+         *\/\n+        @Override\n+        public synchronized void write(int b) throws IOException {\n+           if (segmentMode) {\n+               if (segmentWritten == 0) {\n+                   \/\/ At the begining of the segment.\n+                   writeSegmentHeader();\n+               } else if (segmentWritten == segmentBuffer.length) {\n+                   \/\/ Internal buffer is full, extend a larger one.\n+                   int newSize = segmentBuffer.length + SEGMENT_BUFFER_INC_SIZE;\n+                   byte newBuf[] = new byte[newSize];\n+                   System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n+                   segmentBuffer = newBuf;\n+               }\n+               segmentBuffer[segmentWritten++] = (byte)b;\n+               return;\n+           }\n+           super.write(b);\n+        }\n+\n+        \/**\n+         * Writes {@code len} bytes from the specified byte array\n+         * starting at offset {@code off} to this output stream.\n+         *\n+         * @param      b     the data.\n+         * @param      off   the start offset in the data.\n+         * @param      len   the number of bytes to write.\n+         * @throws     IOException  if an I\/O error occurs.\n+         *\/\n+        @Override\n+        public synchronized void write(byte b[], int off, int len) throws IOException {\n+            if (segmentMode) {\n+                if (segmentWritten == 0) {\n+                    writeSegmentHeader();\n+                }\n+                \/\/ Data size is larger than segment buffer length, extend segment buffer.\n+                if (segmentWritten + len > segmentBuffer.length) {\n+                    int newSize = segmentBuffer.length + Math.max(SEGMENT_BUFFER_INC_SIZE, len);\n+                    byte newBuf[] = new byte[newSize];\n+                    System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n+                    segmentBuffer = newBuf;\n+                }\n+                System.arraycopy(b, off, segmentBuffer, segmentWritten, len);\n+                segmentWritten += len;\n+                return;\n+            }\n+            super.write(b, off, len);\n+        }\n+\n+        \/**\n+         * Flushes this buffered output stream. This forces any buffered\n+         * output bytes to be written out to the underlying output stream.\n+         *\n+         * @throws     IOException  if an I\/O error occurs.\n+         * @see        java.io.FilterOutputStream#out\n+         *\/\n+        @Override\n+        public synchronized void flush() throws IOException {\n+            if (segmentMode) {\n+                \/\/ The case that nothing has been written in segment.\n+                if (segmentWritten == 0) return;\n+                \/\/ There must be more data than just header size written for non-empty segment.\n+                assert segmentWritten > SEGMENT_HEADER_SIZE\n+                        : \"invalid header in segmented mode\";\n+\n+                if (segmentWritten > (segmentBuffer.length)) {\n+                    throw new RuntimeException(\"Heap segment size overflow.\");\n+                }\n+\n+                if (segmentWritten > SEGMENT_HEADER_SIZE) {\n+                    fillSegmentSize(segmentWritten - SEGMENT_HEADER_SIZE);\n+                    super.write(segmentBuffer, 0, segmentWritten);\n+                    super.flush();\n+                    segmentWritten = 0;\n+                }\n+                return;\n+            }\n+            super.flush();\n+        }\n+\n+        \/**\n+         * Enters segmented mode, flush buffered data and set flag.\n+         *\/\n+        public void enterSegmentMode() throws IOException {\n+            if (allowSegmented && !segmentMode && segmentWritten == 0) {\n+                super.flush();\n+                segmentMode = true;\n+                segmentWritten = 0;\n+            }\n+        }\n+\n+        \/**\n+         * Before finish, flush all data in buffer.\n+         *\/\n+        public void finish() throws IOException {\n+            if (allowSegmented && segmentMode) {\n+                flush();\n+                assert segmentWritten == 0;\n+                segmentMode = false;\n+            }\n+        }\n+\n+        \/**\n+         * Exits segmented mode, flush segmented data.\n+         * @param    force    flush data regardless whether the buffer is full\n+         *\/\n+        public void exitSegmentMode() throws IOException {\n+            if (allowSegmented && segmentMode && shouldFlush()) {\n+                flush();\n+                assert segmentWritten == 0;\n+                segmentMode = false;\n+            }\n+        }\n+\n+\n+        \/**\n+         * Check whether the data should be flush based on data saved in\n+         * segmentBuffer.\n+         * This method is used to control the segments number and the memory usage.\n+         * If segment is too small, there will be lots segments in final dump file.\n+         * If it is too large, lots of memory is used in RAM.\n+         *\/\n+        private boolean shouldFlush() {\n+            \/\/ return true if data in segmentBuffer has been extended.\n+            return segmentWritten > SEGMENT_BUFFER_SIZE;\n+        }\n+\n+        \/**\n+         * Writes the write segment header into internal buffer.\n+         *\/\n+        private void writeSegmentHeader() {\n+            assert segmentWritten == 0;\n+            segmentBuffer[segmentWritten++] = (byte)HPROF_HEAP_DUMP_SEGMENT;\n+            writeInteger(0);\n+            \/\/ segment size, write dummy length of 0 and we'll fix it later.\n+            writeInteger(0);\n+        }\n+\n+        \/**\n+         * Fills the segmented data size into the header.\n+         *\/\n+        private void fillSegmentSize(int size) {\n+            segmentBuffer[5] = (byte)(size >>> 24);\n+            segmentBuffer[6] = (byte)(size >>> 16);\n+            segmentBuffer[7] = (byte)(size >>>  8);\n+            segmentBuffer[8] = (byte)(size >>>  0);\n+        }\n+\n+        \/**\n+         * Writes an {@code int} to the internal segment buffer\n+         * {@code written} is incremented by {@code 4}.\n+         *\/\n+        private final void writeInteger(int v) {\n+            segmentBuffer[segmentWritten++] = (byte)(v >>> 24);\n+            segmentBuffer[segmentWritten++] = (byte)(v >>> 16);\n+            segmentBuffer[segmentWritten++] = (byte)(v >>>  8);\n+            segmentBuffer[segmentWritten++] = (byte)(v >>>  0);\n+        }\n+\n+        \/\/ The buffer size for segmentBuffer.\n+        \/\/ Since it is hard to calculate and fill the data size of an segment in compressed\n+        \/\/ data, making the segmented data stored in this buffer could help rewrite the data\n+        \/\/ size before the segmented data are written to underlying GZIPOutputStream.\n+        private static final int SEGMENT_BUFFER_SIZE = 1 << 20;\n+        \/\/ Buffer size used to extend the segment buffer.\n+        private static final int SEGMENT_BUFFER_INC_SIZE = 1 << 10;\n+        \/\/ Headers:\n+        \/\/    1 byte for HPROF_HEAP_DUMP_SEGMENT\n+        \/\/    4 bytes for timestamp\n+        \/\/    4 bytes for size\n+        private static final int SEGMENT_HEADER_SIZE = 9;\n+        \/\/ Segment support.\n+        private boolean segmentMode;\n+        private boolean allowSegmented;\n+        private byte segmentBuffer[];\n+        private int segmentWritten;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":271,"deletions":24,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n@@ -28,0 +31,3 @@\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.assertFalse;\n+import jdk.test.lib.hprof.HprofParser;\n@@ -42,0 +48,4 @@\n+    \/\/ The default heap dump file name defined in JDK.\n+    private static final String HEAP_DUMP_FILENAME_DEFAULT = \"heap.bin\";\n+    private static final String HEAP_DUMP_GZIPED_FILENAME_DEFAULT = \"heap.bin.gz\";\n+\n@@ -54,0 +64,59 @@\n+    private static void verifyDumpFile(File dump) throws Exception {\n+        assertTrue(dump.exists() && dump.isFile(), \"Could not create dump file \" + dump.getAbsolutePath());\n+        printStackTraces(dump.getAbsolutePath());\n+    }\n+\n+    private static class SubTest {\n+        private String cmd;\n+        private String fileName;\n+        private String expectedOutput;\n+        boolean compression;\n+        boolean needVerify;\n+\n+        public SubTest(String comm, String fName, boolean isComp, boolean verify, String expected) {\n+            cmd = comm;\n+            fileName = fName;\n+            expectedOutput = expected;\n+            compression = isComp;\n+            needVerify = verify;\n+        }\n+\n+        public String getCmd() { return cmd; }\n+        public String getFileName() { return fileName; }\n+        public String getExpectedOutput() { return expectedOutput; }\n+        public boolean isCompression() { return compression; }\n+        public boolean needVerify() { return needVerify; }\n+    }\n+\n+    private static void runTest(long appPid, SubTest subtest) throws Exception {\n+        ClhsdbLauncher test = new ClhsdbLauncher();\n+        String fileName = subtest.getFileName();\n+        String cmd = subtest.getCmd();\n+        String expectedOutput = subtest.getExpectedOutput();\n+        boolean compression = subtest.isCompression();\n+        \/* The expected generated file, used to distinguish with fileName in case fileName is blank or null *\/\n+        String expectedFileName = fileName;\n+        if (fileName == null || fileName.length() == 0) {\n+            if (!compression) {\n+                expectedFileName = HEAP_DUMP_FILENAME_DEFAULT;\n+            } else {\n+                expectedFileName = HEAP_DUMP_GZIPED_FILENAME_DEFAULT;\n+            }\n+        }\n+        assertTrue (expectedFileName != null && expectedFileName.length() > 0,\n+                \"Expected generated file name must have value\");\n+        File file = new File(expectedFileName);\n+        if (file.exists()) {\n+            file.delete();\n+        }\n+        String command = cmd + fileName;\n+        List<String> cmds = List.of(command);\n+        Map<String, List<String>> expStrMap = new HashMap<>();\n+        expStrMap.put(command, List.of(expectedOutput));\n+        test.run(appPid, cmds, expStrMap, null);\n+        if (subtest.needVerify()) {\n+            verifyDumpFile(file);\n+        }\n+        file.delete();\n+    }\n+\n@@ -59,0 +128,1 @@\n+            \/\/ Use file name different with JDK's default value \"heap.bin\".\n@@ -60,1 +130,1 @@\n-            ClhsdbLauncher test = new ClhsdbLauncher();\n+            String heapDumpFileNameGz = \"heapdump.bin.gz\";\n@@ -66,8 +136,38 @@\n-            List<String> cmds = List.of(\"dumpheap \" + heapDumpFileName);\n-\n-            Map<String, List<String>> expStrMap = new HashMap<>();\n-            expStrMap.put(\"dumpheap\", List.of(\n-                    \"heap written to \" + heapDumpFileName));\n-\n-            test.run(theApp.getPid(), cmds, expStrMap, null);\n-            printStackTraces(heapDumpFileName);\n+            SubTest[] subtests = new SubTest[] {\n+                    new SubTest(\"dumpheap \", heapDumpFileName, false\/*compression*\/, true,\/*verify*\/\n+                            \"heap written to \" + heapDumpFileName),\n+                    new SubTest(\"dumpheap gz=1 \", heapDumpFileNameGz, true, true,\n+                            \"heap written to \" + heapDumpFileNameGz),\n+                    new SubTest(\"dumpheap gz=9 \", heapDumpFileNameGz, true, true,\n+                            \"heap written to \" + heapDumpFileNameGz),\n+                    new SubTest(\"dumpheap gz=0 \", heapDumpFileNameGz, true, false,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\"),\n+                    new SubTest(\"dumpheap gz=100 \", heapDumpFileNameGz, true, false,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\"),\n+                    new SubTest(\"dumpheap gz= \", heapDumpFileNameGz, true, false,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\"),\n+                    new SubTest(\"dumpheap gz \", heapDumpFileNameGz, true, false,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\"),\n+                    new SubTest(\"dumpheap\", \"\", false, true,\n+                            \"heap written to \" + HEAP_DUMP_FILENAME_DEFAULT),\n+                    new SubTest(\"dumpheap gz=1\", \"\", true, true,\n+                            \"heap written to \" + HEAP_DUMP_GZIPED_FILENAME_DEFAULT),\n+                    new SubTest(\"dumpheap gz=9\", \"\", true, true,\n+                            \"heap written to \" + HEAP_DUMP_GZIPED_FILENAME_DEFAULT),\n+                    new SubTest(\"dumpheap gz=0\", \"\", true, false,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\"),\n+                    new SubTest(\"dumpheap gz=100\", \"\", true, false,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\"),\n+                    \/\/ Command \"dumpheap gz=\".\n+                    new SubTest(\"dumpheap \", \"gz=\", true, false,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\"),\n+                    \/\/ Command \"dumpheap gz\".\n+                    new SubTest(\"dumpheap \", \"gz\", false, true, \"heap written to gz\"),\n+                    \/\/ Command \"dump heap gz=1 gz=2\".\n+                    new SubTest(\"dumpheap gz=1\", \"gz=2\", true, false,\n+                            \"Usage: dumpheap \\\\[gz=<1-9>\\\\] \\\\[filename\\\\]\")\n+            };\n+            \/\/ Run subtests\n+            for (int i = 0; i < subtests.length;i++) {\n+                runTest(theApp.getPid(), subtests[i]);\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpheap.java","additions":110,"deletions":10,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-\n+    private static final String SUCCESS_STRING = \"heap written to\";\n@@ -58,1 +58,1 @@\n-    public static void launch(String expectedMessage, List<String> toolArgs)\n+    public static void launch(int expectedExitValue, List<String> toolArgs)\n@@ -84,3 +84,6 @@\n-            output.shouldContain(expectedMessage);\n-            output.shouldHaveExitValue(0);\n-\n+            output.shouldHaveExitValue(expectedExitValue);\n+            if (expectedExitValue == 0) {\n+                output.shouldContain(SUCCESS_STRING);\n+            } else {\n+                output.stdoutShouldNotContain(SUCCESS_STRING);\n+            }\n@@ -94,1 +97,1 @@\n-    public static void launch(String expectedMessage, String... toolArgs)\n+    public static void launch(int expectedExitValue, String... toolArgs)\n@@ -96,2 +99,1 @@\n-\n-        launch(expectedMessage, Arrays.asList(toolArgs));\n+        launch(expectedExitValue, Arrays.asList(toolArgs));\n@@ -111,1 +113,5 @@\n-    public static void testHeapDump() throws IOException {\n+    public static void testHeapDump(SubTest subtest) throws IOException {\n+        String gzOption = subtest.getGzOption();\n+        boolean checkSuccess = subtest.needCheckSuccess();\n+        int expectedExitValue = checkSuccess ? 0 : 1;\n+\n@@ -117,0 +123,7 @@\n+        if (gzOption == null || gzOption.length() == 0) {\n+            launch(expectedExitValue, \"jmap\",\n+                   \"--binaryheap\", \"--dumpfile=\" + dump.getAbsolutePath());\n+        } else {\n+            launch(expectedExitValue, \"jmap\",\n+                   \"--binaryheap\", gzOption, \"--dumpfile=\" + dump.getAbsolutePath());\n+        }\n@@ -118,7 +131,3 @@\n-        launch(\"heap written to\", \"jmap\",\n-               \"--binaryheap\", \"--dumpfile=\" + dump.getAbsolutePath());\n-\n-        assertTrue(dump.exists() && dump.isFile(),\n-                   \"Could not create dump file \" + dump.getAbsolutePath());\n-\n-        printStackTraces(dump.getAbsolutePath());\n+        if (checkSuccess) {\n+            assertTrue(dump.exists() && dump.isFile(),\n+                       \"Could not create dump file \" + dump.getAbsolutePath());\n@@ -126,1 +135,5 @@\n-        dump.delete();\n+            printStackTraces(dump.getAbsolutePath());\n+            dump.delete();\n+        } else {\n+            assertTrue(!dump.exists(), \"Unexpected file created: \" + dump.getAbsolutePath());\n+        }\n@@ -131,2 +144,13 @@\n-        testHeapDump();\n-\n+        SubTest[] subtests = new SubTest[] {\n+                new SubTest(\"\", true\/*checkSuccess*\/),\n+                new SubTest(\"--gz=1\", true),\n+                new SubTest(\"--gz=9\", true),\n+                new SubTest(\"--gz=0\", false),\n+                new SubTest(\"--gz=100\", false),\n+                new SubTest(\"--gz=\", false),\n+                new SubTest(\"--gz\", false),\n+        };\n+        \/\/ Run subtests\n+        for (int i = 0; i < subtests.length;i++) {\n+            testHeapDump(subtests[i]);\n+        }\n@@ -138,0 +162,13 @@\n+\n+    private static class SubTest {\n+        private String gzOption;\n+        boolean needCheckSuccess;\n+\n+        public SubTest(String gzOpt, boolean checkSuccess) {\n+            gzOption = gzOpt;\n+            needCheckSuccess = checkSuccess;\n+        }\n+\n+        public String getGzOption() { return gzOption; }\n+        public boolean needCheckSuccess() { return needCheckSuccess; }\n+    }\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/HeapDumpTest.java","additions":57,"deletions":20,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.zip.GZIPInputStream;\n@@ -145,0 +146,28 @@\n+            } else if ((i >>> 8) == 0x1f8b08) {\n+                \/\/ Possible gziped file.\n+                in.close();\n+                String deCompressedFile = \"heapdump\" + System.currentTimeMillis() + \".hprof\";\n+                File out = new File(deCompressedFile);\n+                try {\n+                    GZIPInputStream gis = new GZIPInputStream(new FileInputStream(heapFile));\n+                    FileOutputStream fos = new FileOutputStream(out);\n+                    byte[] buffer = new byte[1024 * 1024];\n+                    int len = 0;\n+                    while ((len = gis.read(buffer)) > 0) {\n+                        fos.write(buffer, 0, len);\n+                    }\n+\n+                    PositionDataInputStream in2 = new PositionDataInputStream(\n+                        new BufferedInputStream(new FileInputStream(out)));\n+                    i = in2.readInt();\n+                    if (i == HprofReader.MAGIC_NUMBER) {\n+                        HprofReader r\n+                            = new HprofReader(deCompressedFile, in2, dumpNumber,\n+                                              true, debugLevel);\n+                        r.read();\n+                        return r.printStackTraces();\n+                    }\n+                } catch (Exception e) {\n+                    throw new IOException(\"Can not decompress the compressed hprof file\", e);\n+                }\n+                out.delete();\n@@ -149,0 +178,1 @@\n+        return null;\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/Reader.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"}]}