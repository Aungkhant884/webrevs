{"files":[{"patch":"@@ -1776,1 +1776,1 @@\n-        new Command(\"dumpheap\", \"dumpheap [filename]\", false) {\n+        new Command(\"dumpheap\", \"dumpheap [gz=<1-9>] [filename]\", false) {\n@@ -1778,1 +1778,1 @@\n-                if (t.countTokens() > 1) {\n+                if (t.countTokens() > 2) {\n@@ -1782,2 +1782,24 @@\n-                    String filename;\n-                    if (t.countTokens() == 1) {\n+                    String filename = \"heap.bin\";\n+                    int gzlevel = 0;\n+                    if (t.countTokens() == 2) {\n+                        String option = t.nextToken();\n+                        String[] keyValue = option.split(\"=\");\n+                        if (keyValue[0].equals(\"gz\")) {\n+                            String level = keyValue[1];\n+                            try {\n+                                gzlevel = Integer.parseInt(level);\n+                            } catch (NumberFormatException e) {\n+                                err.println(\"gz option value not an integer (\"+level+\")\");\n+                                usage();\n+                                return;\n+                            }\n+                            if (gzlevel < 1 || gzlevel > 9) {\n+                                err.println(\"Compression level out of range (1-9): \" + level);\n+                                usage();\n+                                return;\n+                            }\n+                            filename = \"heap.bin.gz\";\n+                        } else {\n+                          usage();\n+                          return;\n+                        }\n@@ -1785,2 +1807,26 @@\n-                    } else {\n-                        filename = \"heap.bin\";;\n+                    } else if (t.countTokens() == 1) {\n+                        String option = t.nextToken();\n+                        if (option.startsWith(\"gz=\")) {\n+                            String[] keyValue = option.split(\"=\");\n+                            if (keyValue[0].equals(\"gz\")) {\n+                                String level = keyValue[1];\n+                                try {\n+                                    gzlevel = Integer.parseInt(level);\n+                                } catch (NumberFormatException e) {\n+                                    err.println(\"gz option value not an integer (\"+level+\")\");\n+                                    usage();\n+                                    return;\n+                                }\n+                                if (gzlevel < 1 || gzlevel > 9) {\n+                                    err.println(\"Compression level out of range (1-9): \" + level);\n+                                    usage();\n+                                    return;\n+                                }\n+                            } else {\n+                              usage();\n+                              return;\n+                            }\n+                            filename = \"heap.bin.gz\";\n+                        } else {\n+                          filename = option;\n+                        }\n@@ -1789,1 +1835,1 @@\n-                        jmap.writeHeapHprofBin(filename);\n+                        jmap.writeHeapHprofBin(filename, gzlevel);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":53,"deletions":7,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+        System.out.println(\"    --gz <1-9>              The compress level for gzipped dump file.\");\n@@ -304,10 +305,12 @@\n-        Map<String, String> longOptsMap = Map.of(\"exe=\", \"exe\",\n-                                                 \"core=\", \"core\",\n-                                                 \"pid=\", \"pid\",\n-                                                 \"connect=\", \"connect\",\n-                                                 \"heap\", \"-heap\",\n-                                                 \"binaryheap\", \"binaryheap\",\n-                                                 \"dumpfile=\", \"dumpfile\",\n-                                                 \"histo\", \"-histo\",\n-                                                 \"clstats\", \"-clstats\",\n-                                                 \"finalizerinfo\", \"-finalizerinfo\");\n+        Map<String, String> longOptsMap = Map.ofEntries(\n+           Map.entry(\"exe=\", \"exe\"),\n+           Map.entry(\"core=\", \"core\"),\n+           Map.entry(\"pid=\", \"pid\"),\n+           Map.entry(\"connect=\", \"connect\"),\n+           Map.entry(\"heap\", \"-heap\"),\n+           Map.entry(\"binaryheap\", \"binaryheap\"),\n+           Map.entry(\"dumpfile=\", \"dumpfile\"),\n+           Map.entry(\"gz=\", \"gz\"),\n+           Map.entry(\"histo\", \"-histo\"),\n+           Map.entry(\"clstats\", \"-clstats\"),\n+           Map.entry(\"finalizerinfo\", \"-finalizerinfo\"));\n@@ -318,0 +321,2 @@\n+        String gzLevel = newArgMap.get(\"gz\");\n+        String command = \"-heap:format=b\";\n@@ -322,4 +327,5 @@\n-            if (dumpfile == null) {\n-                newArgMap.put(\"-heap:format=b\", null);\n-            } else {\n-                newArgMap.put(\"-heap:format=b,file=\" + dumpfile, null);\n+            if (gzLevel != null) {\n+                command += \",gz=\" + gzLevel;\n+            }\n+            if (dumpfile != null) {\n+                command += \",file=\" + dumpfile;\n@@ -327,0 +333,1 @@\n+            newArgMap.put(command, null);\n@@ -331,0 +338,1 @@\n+        newArgMap.remove(\"gz\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/SALauncher.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        return \"-heap|-heap:format=b|-histo|-clstats|-finalizerinfo\";\n+        return \"-heap|-heap:format=b[,gz=<1-9>]|-histo|-clstats|-finalizerinfo\";\n@@ -59,1 +59,4 @@\n-        System.out.println(\"    -heap:format=b\\tto dump java heap in hprof binary format\");\n+        System.out.println(\"    -heap:format=b[,gz=<1-9>]\\tto dump java heap in hprof binary format\");\n+        System.out.println(\"                             \\tif gz specified, the heap dump is written\");\n+        System.out.println(\"                             \\tin gzipped format using the given compression level\");\n+        System.err.println(\"                             \\t1 (recommended) is the fastest, 9 the strongest compression.\");\n@@ -75,0 +78,1 @@\n+    private static int gzLevel = 0;\n@@ -97,1 +101,1 @@\n-            writeHeapHprofBin(dumpfile);\n+            writeHeapHprofBin(dumpfile, gzLevel);\n@@ -154,0 +158,12 @@\n+                        } else if (keyValue[0].equals(\"gz\")) {\n+                            String level = keyValue[1];\n+                            try {\n+                                gzLevel = Integer.parseInt(level);\n+                            } catch (NumberFormatException e) {\n+                                System.err.println(\"gz option value not an integer (\"+level+\")\");\n+                                System.exit(1);\n+                            }\n+                            if (gzLevel < 1 || gzLevel > 9) {\n+                                System.err.println(\"Compression level out of range (1-9): \" + level);\n+                                System.exit(1);\n+                            }\n@@ -179,1 +195,1 @@\n-    public boolean writeHeapHprofBin(String fileName) {\n+    public boolean writeHeapHprofBin(String fileName, int gzLevel) {\n@@ -181,1 +197,10 @@\n-            HeapGraphWriter hgw = new HeapHprofBinWriter();\n+            HeapGraphWriter hgw;\n+            if (gzLevel == 0) {\n+                hgw = new HeapHprofBinWriter();\n+            } else if (gzLevel >=1 && gzLevel <= 9) {\n+                System.err.println(\"Zlin: dump compress level: \" + gzLevel);\n+                hgw = new HeapHprofBinWriter(gzLevel);\n+            } else {\n+                System.err.println(\"Illegal compress level: \" + gzLevel);\n+                return false;\n+            }\n@@ -191,1 +216,1 @@\n-        return writeHeapHprofBin(\"heap.bin\");\n+        return writeHeapHprofBin(\"heap.bin\", 0);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/JMap.java","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.zip.*;\n@@ -389,0 +390,7 @@\n+        this.gzLevel = 0;\n+    }\n+\n+    public HeapHprofBinWriter(int gzLevel) {\n+        this.KlassMap = new ArrayList<Klass>();\n+        this.names = new HashSet<Symbol>();\n+        this.gzLevel = gzLevel;\n@@ -392,0 +400,1 @@\n+        GZIPOutputStream gzipOut = null;\n@@ -396,1 +405,12 @@\n-        out = new DataOutputStream(new BufferedOutputStream(fos));\n+        segmentOut = null;\n+        if (isCompression()) {\n+            gzipOut = new GZIPOutputStream(fos) {\n+                {\n+                    this.def.setLevel(gzLevel);\n+                }\n+            };\n+            segmentOut = new CompressedSegmentOutputStream(gzipOut);\n+            out = new DataOutputStream(segmentOut);\n+        } else {\n+            out = new DataOutputStream(new BufferedOutputStream(fos));\n+        }\n@@ -453,1 +473,4 @@\n-        if (useSegmentedHeapDump) {\n+        if (useSegmentedHeapDump || isCompression()) {\n+            if (isCompression()) {\n+                segmentOut.exitSegmentMode();\n+            }\n@@ -462,0 +485,1 @@\n+        out.close();\n@@ -463,3 +487,1 @@\n-\n-        \/\/ close the file stream\n-        fos.close();\n+        segmentOut = null;\n@@ -470,1 +492,1 @@\n-        if (currentSegmentStart == 0) {\n+        if (isCompression() == false && currentSegmentStart == 0) {\n@@ -483,0 +505,2 @@\n+        } else if (isCompression()) {\n+            segmentOut.enterSegmentMode();\n@@ -488,1 +512,1 @@\n-        if (useSegmentedHeapDump) {\n+        if (isCompression() == false && useSegmentedHeapDump) {\n@@ -494,0 +518,2 @@\n+        } else if (isCompression()) {\n+            segmentOut.exitSegmentMode();\n@@ -498,0 +524,2 @@\n+        \/\/ For compression, the length is written by CompressedSegmentOutputStream\n+        if (isCompression()) return;\n@@ -573,1 +601,1 @@\n-        if (currentRecordLength > 0 &&\n+        if (!isCompression() && currentRecordLength > 0 &&\n@@ -1229,0 +1257,4 @@\n+    private boolean isCompression() {\n+      return (gzLevel >= 1 && gzLevel <= 9);\n+    }\n+\n@@ -1236,0 +1268,1 @@\n+    private CompressedSegmentOutputStream segmentOut;\n@@ -1239,0 +1272,1 @@\n+    private int gzLevel;\n@@ -1277,0 +1311,177 @@\n+\n+    \/**\n+     * The class implements a buffered output stream for compressed data.\n+     * This class is used inside HeapHprofBinWritter only for compressed\n+     * segment data.\n+     * Because the current implementation of segment heap dump has to modify\n+     * the segment size before finish, and it is hard to modify the data after\n+     * written to gzipped file, This class fisrt save the uncompressed data\n+     * into an internal buffer, and then write through to the GZIPOutputStream\n+     * when the whole segment data are ready.\n+     * The Internal buffer will extend size when the segment length exceeds the\n+     * current buffer size.\n+     * This class defines a switch to turn on\/off the segment mode. if turn off,\n+     * it behaves same as a BufferedOutputStream.\n+     * *\/\n+    private class CompressedSegmentOutputStream extends BufferedOutputStream {\n+        \/**\n+         * Creates a new buffered output stream to support heap dump segment data.\n+         *\n+         * @param   out    the underlying output stream.\n+         *\/\n+        public CompressedSegmentOutputStream(OutputStream out) {\n+            super(out, 8192);\n+            segmentMode = false;\n+            segmentBuffer = new byte[SEGMENT_BUFFER_INIT_SIZE];\n+            segmentWritten = 0;\n+        }\n+\n+        \/**\n+         * Writes the specified byte to this buffered output stream.\n+         *\n+         * @param      b   the byte to be written.\n+         * @throws     IOException  if an I\/O error occurs.\n+         *\/\n+        @Override\n+        public synchronized void write(int b) throws IOException {\n+           if (segmentMode) {\n+               if (segmentWritten == 0) {\n+                   \/\/ At the begining of the segment.\n+                   writeSegmentHeader();\n+               } else if (segmentWritten >= segmentBuffer.length) {\n+                  int newSize = segmentBuffer.length + SEGMENT_BUFFER_INC_SIZE;\n+                  byte newBuf[] = new byte[newSize];\n+                  System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n+                  segmentBuffer = newBuf;\n+               }\n+               segmentBuffer[segmentWritten++] = (byte)b;\n+               return;\n+           }\n+           super.write(b);\n+        }\n+\n+        \/**\n+         * Writes {@code len} bytes from the specified byte array\n+         * starting at offset {@code off} to this output stream.\n+         *\n+         * @param      b     the data.\n+         * @param      off   the start offset in the data.\n+         * @param      len   the number of bytes to write.\n+         * @throws     IOException  if an I\/O error occurs.\n+         *\/\n+        @Override\n+        public synchronized void write(byte b[], int off, int len) throws IOException {\n+            if (segmentMode) {\n+                if (segmentWritten == 0) {\n+                    \/\/ At the begining of the segment.\n+                    writeSegmentHeader();\n+                } else if (segmentWritten + len >= segmentBuffer.length) {\n+                    \/\/ Enlarge segmentbuffer when it is not enough\n+                    int newSize = segmentBuffer.length + Math.max(SEGMENT_BUFFER_INC_SIZE, len);\n+                    byte newBuf[] = new byte[newSize];\n+                    System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n+                    segmentBuffer = newBuf;\n+                }\n+                System.arraycopy(b, off, segmentBuffer, segmentWritten, len);\n+                segmentWritten += len;\n+                return;\n+            }\n+            super.write(b, off, len);\n+        }\n+\n+        \/**\n+         * Flushes this buffered output stream. This forces any buffered\n+         * output bytes to be written out to the underlying output stream.\n+         *\n+         * @throws     IOException  if an I\/O error occurs.\n+         * @see        java.io.FilterOutputStream#out\n+         *\/\n+        @Override\n+        public synchronized void flush() throws IOException {\n+            if (segmentMode) {\n+                assert segmentWritten == 0 || segmentWritten >= SEGMENT_HEADER_SIZE\n+                        : \"invalid header in segment mode\";\n+                if (segmentWritten >= SEGMENT_HEADER_SIZE) {\n+                    fillSegmentSize(segmentWritten - SEGMENT_HEADER_SIZE);\n+                    super.write(segmentBuffer, 0, segmentWritten);\n+                    super.flush();\n+                    return;\n+                }\n+            }\n+            super.flush();\n+        }\n+\n+        \/**\n+         * Enters segment mode, flush buffered data and set flag.\n+         *\/\n+        public void enterSegmentMode() throws IOException {\n+            if (segmentMode) return;\n+            super.flush();\n+            segmentWritten = 0;\n+            segmentMode = true;\n+        }\n+\n+        \/**\n+         * Exits segment mode, flush segment data.\n+         *\/\n+        public void exitSegmentMode() throws IOException {\n+            if (!segmentMode) return;\n+            assert segmentWritten == 0 || segmentWritten >= SEGMENT_HEADER_SIZE\n+                    : \"invalid header in segment mode\";\n+            if (segmentWritten >= SEGMENT_HEADER_SIZE) {\n+                fillSegmentSize(segmentWritten - SEGMENT_HEADER_SIZE);\n+                super.write(segmentBuffer, 0, segmentWritten);\n+                super.flush();\n+            }\n+            segmentWritten = 0;\n+            segmentMode = false;\n+        }\n+\n+        \/**\n+         * Writes the write segment header into internal buffer.\n+         *\/\n+        private void writeSegmentHeader() {\n+            segmentBuffer[segmentWritten++] = ((byte)HPROF_HEAP_DUMP_SEGMENT);\n+            writeInteger(0);\n+            \/\/ segment size, write dummy length of 0 and we'll fix it later.\n+            writeInteger(0);\n+        }\n+\n+        \/**\n+         * Fills the segment data size into the header.\n+         *\/\n+        private void fillSegmentSize(int size) {\n+            segmentBuffer[5] = (byte)(size >>> 24);\n+            segmentBuffer[6] = (byte)(size >>> 16);\n+            segmentBuffer[7] = (byte)(size >>>  8);\n+            segmentBuffer[8] = (byte)(size >>>  0);\n+        }\n+\n+        \/**\n+         * Writes an {@code int} to the internal segment buffer\n+         * {@code written} is incremented by {@code 4}.\n+         *\/\n+        private final void writeInteger(int v) {\n+            segmentBuffer[segmentWritten++] = (byte)(v >>> 24);\n+            segmentBuffer[segmentWritten++] = (byte)(v >>> 16);\n+            segmentBuffer[segmentWritten++] = (byte)(v >>>  8);\n+            segmentBuffer[segmentWritten++] = (byte)(v >>>  0);\n+        }\n+\n+        \/\/ The buffer size for BufferedOutputStream. Used when gzipped heap dump is enabled.\n+        \/\/ Since it is hard to calculate and fill the data size of an segment in compressed\n+        \/\/ data, making the segment within this size could help rewrite the data size before\n+        \/\/ the segment data are written to GZIPOutputStream\n+        private static final int SEGMENT_BUFFER_INIT_SIZE = 1 << 20;\n+        \/\/ buffer size used for resize the segment buffer\n+        private static final int SEGMENT_BUFFER_INC_SIZE = 1 << 10;\n+        \/\/ Headers:\n+        \/\/    1 byte for HPROF_HEAP_DUMP_SEGMENT\n+        \/\/    4 bytes for timestamp\n+        \/\/    4 bytes for size\n+        private static final int SEGMENT_HEADER_SIZE = 9;\n+        \/\/ segment dump data support\n+        private boolean segmentMode;\n+        private byte segmentBuffer[];\n+        private int segmentWritten;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":219,"deletions":8,"binary":false,"changes":227,"status":"modified"}]}