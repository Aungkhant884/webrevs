{"files":[{"patch":"@@ -1784,21 +1784,11 @@\n-                    if (t.countTokens() == 2) {\n-                        String option = t.nextToken();\n-                        String[] keyValue = option.split(\"=\");\n-                        if (keyValue[0].equals(\"gz\")) {\n-                            String level = keyValue[1];\n-                            try {\n-                                gzlevel = Integer.parseInt(level);\n-                            } catch (NumberFormatException e) {\n-                                err.println(\"gz option value not an integer (\"+level+\")\");\n-                                usage();\n-                                return;\n-                            }\n-                            if (gzlevel < 1 || gzlevel > 9) {\n-                                err.println(\"Compression level out of range (1-9): \" + level);\n-                                usage();\n-                                return;\n-                            }\n-                            filename = \"heap.bin.gz\";\n-                        } else {\n-                          usage();\n-                          return;\n+                    \/* Parse \"gz=\" option. *\/\n+                    String option = t.nextToken();\n+                    String[] keyValue = option.split(\"=\");\n+                    if (keyValue[0].equals(\"gz\")) {\n+                        String level = keyValue[1];\n+                        try {\n+                            gzlevel = Integer.parseInt(level);\n+                        } catch (NumberFormatException e) {\n+                            err.println(\"gz option value not an integer (\"+level+\")\");\n+                            usage();\n+                            return;\n@@ -1806,26 +1796,4 @@\n-                        filename = t.nextToken();\n-                    } else if (t.countTokens() == 1) {\n-                        String option = t.nextToken();\n-                        if (option.startsWith(\"gz=\")) {\n-                            String[] keyValue = option.split(\"=\");\n-                            if (keyValue[0].equals(\"gz\")) {\n-                                String level = keyValue[1];\n-                                try {\n-                                    gzlevel = Integer.parseInt(level);\n-                                } catch (NumberFormatException e) {\n-                                    err.println(\"gz option value not an integer (\"+level+\")\");\n-                                    usage();\n-                                    return;\n-                                }\n-                                if (gzlevel < 1 || gzlevel > 9) {\n-                                    err.println(\"Compression level out of range (1-9): \" + level);\n-                                    usage();\n-                                    return;\n-                                }\n-                            } else {\n-                              usage();\n-                              return;\n-                            }\n-                            filename = \"heap.bin.gz\";\n-                        } else {\n-                          filename = option;\n+                        if (gzlevel < 1 || gzlevel > 9) {\n+                            err.println(\"Compression level out of range (1-9): \" + level);\n+                            usage();\n+                            return;\n@@ -1833,0 +1801,10 @@\n+                        filename = \"heap.bin.gz\";\n+                    } else {\n+                      usage();\n+                      return;\n+                    }\n+                    \/* Parse filename. *\/\n+                    if (t.countTokens() == 2) {\n+                       filename = t.nextToken();\n+                    } else if (t.countTokens() == 1) {\n+                       filename = option;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":25,"deletions":47,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-        System.out.println(\"    --gz <1-9>              The compress level for gzipped dump file.\");\n+        System.out.println(\"    --gz <1-9>              The compression level for gzipped dump file.\");\n@@ -306,11 +306,11 @@\n-           Map.entry(\"exe=\", \"exe\"),\n-           Map.entry(\"core=\", \"core\"),\n-           Map.entry(\"pid=\", \"pid\"),\n-           Map.entry(\"connect=\", \"connect\"),\n-           Map.entry(\"heap\", \"-heap\"),\n-           Map.entry(\"binaryheap\", \"binaryheap\"),\n-           Map.entry(\"dumpfile=\", \"dumpfile\"),\n-           Map.entry(\"gz=\", \"gz\"),\n-           Map.entry(\"histo\", \"-histo\"),\n-           Map.entry(\"clstats\", \"-clstats\"),\n-           Map.entry(\"finalizerinfo\", \"-finalizerinfo\"));\n+                Map.entry(\"exe=\", \"exe\"),\n+                Map.entry(\"core=\", \"core\"),\n+                Map.entry(\"pid=\", \"pid\"),\n+                Map.entry(\"connect=\", \"connect\"),\n+                Map.entry(\"heap\", \"-heap\"),\n+                Map.entry(\"binaryheap\", \"binaryheap\"),\n+                Map.entry(\"dumpfile=\", \"dumpfile\"),\n+                Map.entry(\"gz=\", \"gz\"),\n+                Map.entry(\"histo\", \"-histo\"),\n+                Map.entry(\"clstats\", \"-clstats\"),\n+                Map.entry(\"finalizerinfo\", \"-finalizerinfo\"));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/SALauncher.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -57,5 +57,5 @@\n-        System.out.println(\"    <no option>\\tto print same info as Solaris pmap\");\n-        System.out.println(\"    -heap\\tto print java heap summary\");\n-        System.out.println(\"    -heap:format=b[,gz=<1-9>]\\tto dump java heap in hprof binary format\");\n-        System.out.println(\"                             \\tif gz specified, the heap dump is written\");\n-        System.out.println(\"                             \\tin gzipped format using the given compression level\");\n+        System.out.println(\"    <no option>\\tTo print same info as Solaris pmap.\");\n+        System.out.println(\"    -heap\\tTo print java heap summary.\");\n+        System.out.println(\"    -heap:format=b[,gz=<1-9>]\\tTo dump java heap in hprof binary format.\");\n+        System.out.println(\"                             \\tIf gz specified, the heap dump is written\");\n+        System.out.println(\"                             \\tin gzipped format using the given compression level.\");\n@@ -63,3 +63,5 @@\n-        System.out.println(\"    -histo\\tto print histogram of java object heap\");\n-        System.out.println(\"    -clstats\\tto print class loader statistics\");\n-        System.out.println(\"    -finalizerinfo\\tto print information on objects awaiting finalization\");\n+        System.out.println(\"    -heap:format=x           \\tTo dump java heap in GXL format.\");\n+        System.out.println(\"                             \\tPlease be aware that \\\"gz\\\" option is not valid for heap dump in GXL format.\");\n+        System.out.println(\"    -histo\\tTo print histogram of java object heap.\");\n+        System.out.println(\"    -clstats\\tTo print class loader statistics.\");\n+        System.out.println(\"    -finalizerinfo\\tTo print information on objects awaiting finalization.\");\n@@ -160,0 +162,4 @@\n+                            if (mode == MODE_HEAP_GRAPH_GXL) {\n+                                System.err.println(\"The \\\"gz\\\" option is not compatible with heap dump in GXL format.\");\n+                                System.exit(1);\n+                            }\n@@ -203,1 +209,1 @@\n-                System.err.println(\"Illegal compress level: \" + gzLevel);\n+                System.err.println(\"Illegal compression level: \" + gzLevel);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/JMap.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -403,0 +403,4 @@\n+        \/\/ Check weather we should dump the heap as segments\n+        useSegmentedHeapDump = isCompression() ||\n+                (vm.getUniverse().heap().used() > HPROF_SEGMENTED_HEAP_DUMP_THRESHOLD);\n+\n@@ -405,9 +409,11 @@\n-        segmentOut = null;\n-        if (isCompression()) {\n-            gzipOut = new GZIPOutputStream(fos) {\n-                {\n-                    this.def.setLevel(gzLevel);\n-                }\n-            };\n-            segmentOut = new CompressedSegmentOutputStream(gzipOut);\n-            out = new DataOutputStream(segmentOut);\n+        hprofBufferedOut = null;\n+        OutputStream dataOut = fos;\n+        if (useSegmentedHeapDump) {\n+            if (isCompression()) {\n+                dataOut = new GZIPOutputStream(fos) {\n+                    {\n+                        this.def.setLevel(gzLevel);\n+                    }\n+                };\n+            }\n+            hprofBufferedOut = new SegmentedOutputStream(dataOut);\n@@ -415,1 +421,1 @@\n-            out = new DataOutputStream(new BufferedOutputStream(fos));\n+            hprofBufferedOut = new SegmentedOutputStream(fos, false);\n@@ -417,1 +423,1 @@\n-\n+        out = new DataOutputStream(hprofBufferedOut);\n@@ -442,3 +448,0 @@\n-        \/\/ Check weather we should dump the heap as segments\n-        useSegmentedHeapDump = vm.getUniverse().heap().used() > HPROF_SEGMENTED_HEAP_DUMP_THRESHOLD;\n-\n@@ -470,7 +473,5 @@\n-        \/\/ Fill in final length\n-        fillInHeapRecordLength();\n-\n-        if (useSegmentedHeapDump || isCompression()) {\n-            if (isCompression()) {\n-                segmentOut.exitSegmentMode();\n-            }\n+        if (!useSegmentedHeapDump) {\n+            \/\/ Fill in final length\n+            fillInHeapRecordLength();\n+        } else {\n+            hprofBufferedOut.exitSegmentMode();\n@@ -487,1 +488,1 @@\n-        segmentOut = null;\n+        hprofBufferedOut = null;\n@@ -492,5 +493,5 @@\n-        if (isCompression() == false && currentSegmentStart == 0) {\n-            \/\/ write heap data header, depending on heap size use segmented heap\n-            \/\/ format\n-            out.writeByte((byte) (useSegmentedHeapDump ? HPROF_HEAP_DUMP_SEGMENT\n-                    : HPROF_HEAP_DUMP));\n+        if (useSegmentedHeapDump) {\n+            hprofBufferedOut.enterSegmentMode();\n+        } else if (currentSegmentStart == 0) {\n+            \/\/ write heap data header\n+            out.writeByte((byte) (HPROF_HEAP_DUMP));\n@@ -505,2 +506,0 @@\n-        } else if (isCompression()) {\n-            segmentOut.enterSegmentMode();\n@@ -512,8 +511,2 @@\n-        if (isCompression() == false && useSegmentedHeapDump) {\n-            out.flush();\n-            if ((fos.getChannel().position() - currentSegmentStart - 4L) >= HPROF_SEGMENTED_HEAP_DUMP_SEGMENT_SIZE) {\n-                fillInHeapRecordLength();\n-                currentSegmentStart = 0;\n-            }\n-        } else if (isCompression()) {\n-            segmentOut.exitSegmentMode();\n+        if (useSegmentedHeapDump) {\n+            hprofBufferedOut.exitSegmentMode();\n@@ -524,2 +517,2 @@\n-        \/\/ For compression, the length is written by CompressedSegmentOutputStream\n-        if (isCompression()) return;\n+        \/\/ For compression, the length is written by SegmentedOutputStream\n+        if (useSegmentedHeapDump) return;\n@@ -600,0 +593,2 @@\n+        \/\/ only process when segmented heap dump is not used, since SegmentedOutputStream\n+        \/\/ could create segment automatically.\n@@ -601,1 +596,1 @@\n-        if (!isCompression() && currentRecordLength > 0 &&\n+        if ((!useSegmentedHeapDump) && currentRecordLength > 0 &&\n@@ -1268,1 +1263,1 @@\n-    private CompressedSegmentOutputStream segmentOut;\n+    private SegmentedOutputStream hprofBufferedOut;\n@@ -1313,1 +1308,1 @@\n-     * The class implements a buffered output stream for compressed segment data.\n+     * The class implements a buffered output stream for segment data.\n@@ -1320,2 +1315,2 @@\n-     * The Internal buffer size will be extended when the segment length exceeds the\n-     * current buffer size.\n+     * When the data to written is larger than internal buffer, or the internal buffer\n+     * is full, the internal buffer will be extend to a larger one.\n@@ -1325,1 +1320,1 @@\n-    private class CompressedSegmentOutputStream extends BufferedOutputStream {\n+    private class SegmentedOutputStream extends BufferedOutputStream {\n@@ -1327,1 +1322,1 @@\n-         * Creates a new buffered output stream to support heap dump segment data.\n+         * Creates a new buffered output stream to support segment heap dump data.\n@@ -1329,1 +1324,2 @@\n-         * @param   out    the underlying output stream.\n+         * @param   out                 the underlying output stream.\n+         * @param   allowSegmental      whether allow segmental dump.\n@@ -1331,1 +1327,1 @@\n-        public CompressedSegmentOutputStream(OutputStream out) {\n+        public SegmentedOutputStream(OutputStream out, boolean allowSegmental) {\n@@ -1334,1 +1330,2 @@\n-            segmentBuffer = new byte[SEGMENT_BUFFER_INIT_SIZE];\n+            this.allowSegmental = allowSegmental;\n+            segmentBuffer = new byte[SEGMENT_BUFFER_SIZE];\n@@ -1338,0 +1335,9 @@\n+        \/**\n+         * Creates a new buffered output stream to support segment heap dump data.\n+         *\n+         * @param   out                 the underlying output stream.\n+         *\/\n+        public SegmentedOutputStream(OutputStream out) {\n+            this(out, true);\n+        }\n+\n@@ -1350,5 +1356,5 @@\n-               } else if (segmentWritten >= segmentBuffer.length) {\n-                  int newSize = segmentBuffer.length + SEGMENT_BUFFER_INC_SIZE;\n-                  byte newBuf[] = new byte[newSize];\n-                  System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n-                  segmentBuffer = newBuf;\n+               } else if (segmentWritten == segmentBuffer.length) {\n+                   int newSize = segmentBuffer.length + SEGMENT_BUFFER_INC_SIZE;\n+                   byte newBuf[] = new byte[newSize];\n+                   System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n+                   segmentBuffer = newBuf;\n@@ -1376,1 +1382,3 @@\n-                } else if (segmentWritten + len >= segmentBuffer.length) {\n+                }\n+                \/\/ Data size is larger than segment buffer length, extend segment buffer.\n+                if (segmentWritten + len > segmentBuffer.length) {\n@@ -1399,1 +1407,1 @@\n-                assert segmentWritten == 0 || segmentWritten >= SEGMENT_HEADER_SIZE\n+                assert segmentWritten > SEGMENT_HEADER_SIZE\n@@ -1401,1 +1409,6 @@\n-                if (segmentWritten >= SEGMENT_HEADER_SIZE) {\n+\n+                if (segmentWritten > (segmentBuffer.length)) {\n+                    throw new RuntimeException(\"Heap segment size overflow.\");\n+                }\n+\n+                if (segmentWritten > SEGMENT_HEADER_SIZE) {\n@@ -1405,1 +1418,1 @@\n-                    return;\n+                    segmentWritten = 0;\n@@ -1407,0 +1420,1 @@\n+                return;\n@@ -1415,4 +1429,6 @@\n-            if (segmentMode) return;\n-            super.flush();\n-            segmentWritten = 0;\n-            segmentMode = true;\n+            if (!allowSegmental) return;\n+            if (!segmentMode) {\n+                super.flush();\n+                segmentMode = true;\n+                segmentWritten = 0;\n+            }\n@@ -1425,7 +1441,5 @@\n-            if (!segmentMode) return;\n-            assert segmentWritten == 0 || segmentWritten >= SEGMENT_HEADER_SIZE\n-                    : \"invalid header in segment mode\";\n-            if (segmentWritten >= SEGMENT_HEADER_SIZE) {\n-                fillSegmentSize(segmentWritten - SEGMENT_HEADER_SIZE);\n-                super.write(segmentBuffer, 0, segmentWritten);\n-                super.flush();\n+            if (!allowSegmental) return;\n+            if (segmentMode) {\n+                flush();\n+                assert segmentWritten == 0;\n+                segmentMode = false;\n@@ -1433,2 +1447,0 @@\n-            segmentWritten = 0;\n-            segmentMode = false;\n@@ -1441,1 +1453,2 @@\n-            segmentBuffer[segmentWritten++] = ((byte)HPROF_HEAP_DUMP_SEGMENT);\n+            assert segmentWritten == 0;\n+            segmentBuffer[segmentWritten++] = (byte)HPROF_HEAP_DUMP_SEGMENT;\n@@ -1468,2 +1481,1 @@\n-        \/\/ The buffer size for segmentBuffer. used to save data when gzipped heap dump is\n-        \/\/ enabled.\n+        \/\/ The buffer size for segmentBuffer.\n@@ -1472,3 +1484,3 @@\n-        \/\/ size before the segment data are written to GZIPOutputStream\n-        private static final int SEGMENT_BUFFER_INIT_SIZE = 1 << 20;\n-        \/\/ buffer size used for resize the segment buffer\n+        \/\/ size before the segment data are written to GZIPOutputStream.\n+        private static final int SEGMENT_BUFFER_SIZE = 1 << 20;\n+        \/\/ Buffer size used for resize the segment buffer.\n@@ -1481,1 +1493,1 @@\n-        \/\/ segment support\n+        \/\/ Segment support.\n@@ -1483,0 +1495,1 @@\n+        private boolean allowSegmental;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":91,"deletions":78,"binary":false,"changes":169,"status":"modified"}]}