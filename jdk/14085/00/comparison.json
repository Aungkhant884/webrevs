{"files":[{"patch":"@@ -7016,0 +7016,141 @@\n+  \/\/ In sun.security.util.math.intpoly.IntegerPolynomial1305, integers\n+  \/\/ are represented as long[5], with BITS_PER_LIMB = 26.\n+  \/\/ Pack five 26-bit limbs into three 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register dest2, Register src) {\n+    __ ldp(dest0, rscratch1, Address(src, 0));     \/\/ 26 bits\n+    __ add(dest0, dest0, rscratch1, Assembler::LSL, 26);  \/\/ 26 bits\n+    __ ldp(rscratch1, rscratch2, Address(src, 2 * sizeof (jlong)));\n+    __ add(dest0, dest0, rscratch1, Assembler::LSL, 52);  \/\/ 12 bits\n+\n+    __ add(dest1, zr, rscratch1, Assembler::LSR, 12);     \/\/ 14 bits\n+    __ add(dest1, dest1, rscratch2, Assembler::LSL, 14);  \/\/ 26 bits\n+    __ ldr(rscratch1, Address(src, 4 * sizeof (jlong)));\n+    __ add(dest1, dest1, rscratch1, Assembler::LSL, 40);  \/\/ 24 bits\n+\n+    __ add(dest2, zr, rscratch1, Assembler::LSR, 24);     \/\/ 2 bits\n+  }\n+\n+  \/\/ Multiply and multiply-accumulate unsigned 64-bit registers.\n+  void wide_mul(Register prod_lo, Register prod_hi, Register n, Register m) {\n+    __ mul(prod_lo, n, m);\n+    __ umulh(prod_hi, n, m);\n+  }\n+  void wide_madd(Register sum_lo, Register sum_hi, Register n, Register m) {\n+    wide_mul(rscratch1, rscratch2, n, m);\n+    __ adds(sum_lo, sum_lo, rscratch1);\n+    __ adc(sum_hi, sum_hi, rscratch2);\n+  }\n+\n+  \/\/ Poly1305, RFC 7539\n+\n+  address generate_poly1305_processBlocks() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    address start = __ pc();\n+    Label here;\n+    __ enter();\n+    RegSet callee_saved = RegSet::range(r19, r28);\n+    __ push(callee_saved, sp);\n+\n+    RegSetIterator<Register> regs = (RegSet::range(c_rarg0, r28) - r18_tls - rscratch1 - rscratch2).begin();\n+\n+    \/\/ Arguments\n+    const Register input_start = *regs, length = *++regs, acc_start = *++regs, r_start = *++regs;\n+\n+    \/\/ R_n is the randomly-generated key, packed into three registers\n+    const Register R_0 = *++regs, R_1 = *++regs, R_2 = *++regs;\n+    pack_26(R_0, R_1, R_2, r_start);\n+\n+    \/\/ RR_n is (R_n >> 2) * 5\n+    const Register RR_0 = *++regs, RR_1 = *++regs;\n+    __ lsr(RR_0, R_0, 2);\n+    __ add(RR_0, RR_0, RR_0, Assembler::LSL, 2);\n+    __ lsr(RR_1, R_1, 2);\n+    __ add(RR_1, RR_1, RR_1, Assembler::LSL, 2);\n+\n+    \/\/ U_n is the current checksum\n+    const Register U_0 = *++regs, U_1 = *++regs, U_2 = *++regs;\n+    pack_26(U_0, U_1, U_2, acc_start);\n+\n+    static constexpr int BLOCK_LENGTH = 16;\n+    Label DONE, LOOP;\n+\n+    __ cmp(length, checked_cast<u1>(BLOCK_LENGTH));\n+    __ br(Assembler::LT, DONE); {\n+      __ bind(LOOP);\n+\n+      \/\/ S_n is to be the sum of U_n and the next block of data\n+      const Register S_0 = *++regs, S_1 = *++regs, S_2 = *++regs;\n+      __ ldp(S_0, S_1, __ post(input_start, 2 * wordSize));\n+      __ adds(S_0, U_0, S_0);\n+      __ adcs(S_1, U_1, S_1);\n+      __ adc(S_2, U_2, zr);\n+      __ add(S_2, S_2, 1);\n+\n+      const Register U_0HI = *++regs, U_1HI = *++regs;\n+\n+      \/\/ NB: this logic depends on some of the special properties of\n+      \/\/ Poly1305 keys. In particular, because we know that the top\n+      \/\/ four bits of each 32-bit subword of \"r\" are zero, we can add\n+      \/\/ together partial products without any risk of needing to\n+      \/\/ propagate a carry out.\n+      wide_mul(U_0, U_0HI, S_0, R_0);  wide_madd(U_0, U_0HI, S_1, RR_1); wide_madd(U_0, U_0HI, S_2, RR_0);\n+      wide_mul(U_1, U_1HI, S_0, R_1);  wide_madd(U_1, U_1HI, S_1, R_0);  wide_madd(U_1, U_1HI, S_2, RR_1);\n+      __ andr(U_2, R_0, 3);\n+      __ mul(U_2, S_2, U_2);\n+\n+      \/\/ Recycle registers S_0, S_1, S_2\n+      regs = (regs.remaining() + S_0 + S_1 + S_2).begin();\n+\n+      \/\/ Partial reduction mod 2**130 - 5\n+      __ adds(U_1, U_0HI, U_1);\n+      __ adc(U_2, U_1HI, U_2);\n+      \/\/ Sum now in U_2:U_1, U_0.\n+      \/\/ Dead: U_0HI, U_1HI.\n+      regs = (regs.remaining() + U_0HI + U_1HI).begin();\n+\n+      \/\/ U_2:U_1:U_0 += (U_1HI >> 2)\n+      __ lsr(rscratch1, U_2, 2);\n+      __ andr(U_2, U_2, (u8)3);\n+      __ adds(U_0, U_0, rscratch1);\n+      __ adcs(U_1, U_1, zr);\n+      __ adc(U_2, U_2, zr);\n+\n+      \/\/ U_1HI:U_0HI, U_0 += (U_1HI >> 2) << 2\n+      __ adds(U_0, U_0, rscratch1, Assembler::LSL, 2);\n+      __ adcs(U_1, U_1, zr);\n+      __ adc(U_2, U_2, zr);\n+\n+      __ sub(length, length, checked_cast<u1>(BLOCK_LENGTH));\n+      __ cmp(length, checked_cast<u1>(BLOCK_LENGTH));\n+      __ br(~ Assembler::LT, LOOP);\n+    }\n+\n+    \/\/ Further reduce modulo 2^130 - 5\n+    __ lsr(rscratch1, U_2, 2);\n+    __ add(rscratch1, rscratch1, rscratch1, Assembler::LSL, 2); \/\/ rscratch1 = U_2 * 5\n+    __ adds(U_0, U_0, rscratch1); \/\/ U_0 += U_2 * 5\n+    __ adcs(U_1, U_1, zr);\n+    __ andr(U_2, U_2, (u1)3);\n+    __ adc(U_2, U_2, zr);\n+\n+    \/\/ Unpack the sum into five 26-bit limbs and write to memory.\n+    __ ubfiz(rscratch1, U_0, 0, 26);\n+    __ ubfx(rscratch2, U_0, 26, 26);\n+    __ stp(rscratch1, rscratch2, Address(acc_start));\n+    __ ubfx(rscratch1, U_0, 52, 12);\n+    __ bfi(rscratch1, U_1, 12, 14);\n+    __ ubfx(rscratch2, U_1, 14, 26);\n+    __ stp(rscratch1, rscratch2, Address(acc_start, 2 * sizeof (jlong)));\n+    __ ubfx(rscratch1, U_1, 40, 24);\n+    __ bfi(rscratch1, U_2, 24, 3);\n+    __ str(rscratch1, Address(acc_start, 4 * sizeof (jlong)));\n+\n+    __ bind(DONE);\n+    __ pop(callee_saved, sp);\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8103,0 +8244,4 @@\n+    if (UsePoly1305Intrinsics) {\n+      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":145,"deletions":0,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -572,0 +572,4 @@\n+\n+    if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n+      FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -187,0 +187,4 @@\n+  RegSetIterator<RegImpl>& operator=(const RegSetIterator<RegImpl>& mit) {\n+    _regs= mit._regs;\n+    return *this;\n+  }\n@@ -197,0 +201,4 @@\n+\n+  AbstractRegSet<RegImpl> remaining() const {\n+    return _regs;\n+  }\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    public void setup() {\n+    public void setup() throws Throwable {\n@@ -88,0 +88,2 @@\n+        byte[] d = data[0];\n+        polyEngineInit.invoke(polyObj, new SecretKeySpec(d, 0, 32, \"Poly1305\"), null);\n@@ -103,0 +105,11 @@\n+    @Benchmark\n+    public void updateBytes() {\n+        try {\n+            byte[] d = data[index];\n+            \/\/ index = (index +1) % SET_SIZE;\n+            polyEngineUpdate.invoke(polyObj, d, 0, d.length);\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/Poly1305DigestBench.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}