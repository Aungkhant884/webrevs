{"files":[{"patch":"@@ -7030,1 +7030,18 @@\n-    __ add(dest2, zr, rscratch1, Assembler::LSR, 24);     \/\/ 2 bits\n+    if (dest2->is_valid()) {\n+      __ add(dest2, zr, rscratch1, Assembler::LSR, 24);     \/\/ 2 bits\n+    } else {\n+#ifdef ASSERT\n+      Label OK;\n+      __ cmp(zr, rscratch1, Assembler::LSR, 24);     \/\/ 2 bits\n+      __ br(__ EQ, OK);\n+      __ stop(\"high bits of Poly1305 integer should be zero\");\n+      __ should_not_reach_here();\n+      __ bind(OK);\n+#endif\n+    }\n+  }\n+\n+  \/\/ As above, but return only a 128-bit integer, packed into two\n+  \/\/ 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register src) {\n+    pack_26(dest0, dest1, noreg, src);\n@@ -7064,3 +7081,5 @@\n-    \/\/ R_n is the randomly-generated key, packed into three registers\n-    const Register R_0 = *++regs, R_1 = *++regs, R_2 = *++regs;\n-    pack_26(R_0, R_1, R_2, r_start);\n+    \/\/ R_n is the 128-bit randomly-generated key, packed into two\n+    \/\/ registers.  The caller passes this key to us as long[5], with\n+    \/\/ BITS_PER_LIMB = 26.\n+    const Register R_0 = *++regs, R_1 = *++regs;\n+    pack_26(R_0, R_1, r_start);\n@@ -7098,3 +7117,3 @@\n-      \/\/ four bits of each 32-bit subword of \"r\" are zero, we can add\n-      \/\/ together partial products without any risk of needing to\n-      \/\/ propagate a carry out.\n+      \/\/ four bits of R_0 and R_1 are zero, we can add together\n+      \/\/ partial products without any risk of needing to propagate a\n+      \/\/ carry out.\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"}]}