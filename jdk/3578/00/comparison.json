{"files":[{"patch":"@@ -504,4 +504,5 @@\n-  ConstantPool* cp = method->constMethod()->constants();\n-  assert(cp != NULL, \"npe\");\n-  \/\/ don't inline method when constant pool contains a CONSTANT_Dynamic\n-  return !method->is_not_compilable(CompLevel_full_optimization) && !cp->has_dynamic_constant();\n+  \/\/ Skip redefined methods\n+  if (method->is_old()) {\n+    return false;\n+  }\n+  return !method->is_not_compilable(CompLevel_full_optimization);\n@@ -623,2 +624,40 @@\n-  oop result = cp->resolve_possibly_cached_constant_at(index, CHECK_NULL);\n-  return JVMCIENV->get_jobject(JVMCIENV->get_object_constant(result));\n+  oop obj = cp->resolve_possibly_cached_constant_at(index, CHECK_NULL);\n+  constantTag tag = cp->tag_at(index);\n+  if (tag.is_dynamic_constant() || tag.is_dynamic_constant_in_error()) {\n+    if (obj == Universe::the_null_sentinel()) {\n+      return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_NULL_POINTER());\n+    }\n+    BasicType bt = Signature::basic_type(cp->uncached_signature_ref_at(index));\n+    if (!is_reference_type(bt)) {\n+      if (!is_java_primitive(bt)) {\n+        return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_ILLEGAL());\n+      }\n+      jvalue value;\n+      jlong raw_value;\n+      BasicType bt2 = java_lang_boxing_object::get_value(obj, &value);\n+      assert(bt2 == bt, \"\");\n+      switch (bt2) {\n+        case T_BOOLEAN: raw_value = value.z; break;\n+        case T_BYTE:    raw_value = value.b; break;\n+        case T_SHORT:   raw_value = value.s; break;\n+        case T_CHAR:    raw_value = value.c; break;\n+        case T_INT:     raw_value = value.i; break;\n+        case T_LONG:    raw_value = value.j; break;\n+        case T_FLOAT: {\n+          JVMCIObject result = JVMCIENV->call_JavaConstant_forFloat(value.f, JVMCI_CHECK_NULL);\n+          return JVMCIENV->get_jobject(result);\n+        }\n+        case T_DOUBLE: {\n+          JVMCIObject result = JVMCIENV->call_JavaConstant_forDouble(value.d, JVMCI_CHECK_NULL);\n+          return JVMCIENV->get_jobject(result);\n+        }\n+        default: {\n+          return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_ILLEGAL());\n+        }\n+      }\n+\n+      JVMCIObject result = JVMCIENV->call_PrimitiveConstant_forTypeChar(type2char(bt2), raw_value, JVMCI_CHECK_NULL);\n+      return JVMCIENV->get_jobject(result);\n+    }\n+  }\n+  return JVMCIENV->get_jobject(JVMCIENV->get_object_constant(obj));\n@@ -2699,1 +2738,1 @@\n-  {CC \"resolvePossiblyCachedConstantInPool\",          CC \"(\" HS_CONSTANT_POOL \"I)\" OBJECTCONSTANT,                                          FN_PTR(resolvePossiblyCachedConstantInPool)},\n+  {CC \"resolvePossiblyCachedConstantInPool\",          CC \"(\" HS_CONSTANT_POOL \"I)\" JAVACONSTANT,                                            FN_PTR(resolvePossiblyCachedConstantInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":46,"deletions":7,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -248,0 +248,1 @@\n+    static_object_field(JavaConstant, ILLEGAL, \"Ljdk\/vm\/ci\/meta\/PrimitiveConstant;\")                          \\\n@@ -289,0 +290,1 @@\n+    static_object_field(JavaKind, Float, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                         \\\n@@ -290,0 +292,1 @@\n+    static_object_field(JavaKind, Double, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                        \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -433,0 +433,1 @@\n+  declare_constant(JVM_CONSTANT_Dynamic)                                  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -218,3 +218,3 @@\n-     * entry types: {@code JVM_CONSTANT_String}, {@code JVM_CONSTANT_MethodHandle},\n-     * {@code JVM_CONSTANT_MethodHandleInError}, {@code JVM_CONSTANT_MethodType} and\n-     * {@code JVM_CONSTANT_MethodTypeInError}.\n+     * entry types: {@code JVM_CONSTANT_Dynamic}, {@code JVM_CONSTANT_String},\n+     * {@code JVM_CONSTANT_MethodHandle}, {@code JVM_CONSTANT_MethodHandleInError},\n+     * {@code JVM_CONSTANT_MethodType} and {@code JVM_CONSTANT_MethodTypeInError}.\n@@ -222,1 +222,1 @@\n-    native HotSpotObjectConstantImpl resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi);\n+    native JavaConstant resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -143,0 +143,2 @@\n+        final JvmConstant jvmDynamic = add(new JvmConstant(c.jvmConstantDynamic, \"Dynamic\"));\n+        final JvmConstant jvmDynamicInError = add(new JvmConstant(c.jvmConstantDynamicInError, \"DynamicInError\"));\n@@ -548,0 +550,2 @@\n+            case \"Dynamic\":\n+            case \"DynamicInError\":\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -258,0 +258,2 @@\n+    final int jvmConstantDynamic = getConstant(\"JVM_CONSTANT_Dynamic\", Integer.class);\n+    final int jvmConstantDynamicInError = getConstant(\"JVM_CONSTANT_DynamicInError\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+    PrimitiveConstant ILLEGAL = new PrimitiveConstant(JavaKind.Illegal, 0);\n@@ -332,1 +333,1 @@\n-        return new PrimitiveConstant(JavaKind.Illegal, 0);\n+        return JavaConstant.ILLEGAL;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/JavaConstant.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-                throw new IllegalArgumentException(\"illegal call to bits on \" + this);\n+                throw new IllegalArgumentException(\"illegal call to getBitCount() on \" + this);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/JavaKind.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.jvmci\n+ * @summary Test CONSTANT_Dynamic resolution by HotSpotConstantPool.\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot:+open\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ * @run testng\/othervm\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler\n+ *      jdk.vm.ci.hotspot.test.TestDynamicConstant\n+ *\/\n+\n+package jdk.vm.ci.hotspot.test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.invoke.ConstantBootstraps;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.ConstantDynamic;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+import jdk.vm.ci.hotspot.HotSpotObjectConstant;\n+import jdk.vm.ci.meta.ConstantPool;\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.PrimitiveConstant;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.runtime.JVMCI;\n+\n+\/**\n+ * Tests support for Dynamic constants.\n+ *\n+ * @see \"https:\/\/openjdk.java.net\/jeps\/309\"\n+ * @see \"https:\/\/bugs.openjdk.java.net\/browse\/JDK-8177279\"\n+ *\/\n+public class TestDynamicConstant implements Opcodes {\n+\n+    private static final int PUBLIC_STATIC = ACC_PUBLIC | ACC_STATIC;\n+\n+    static final String testClassInternalName = Type.getInternalName(TestDynamicConstant.class);\n+    static final String constantBootstrapsClassInternalName = Type.getInternalName(ConstantBootstraps.class);\n+\n+    enum CondyType {\n+        \/**\n+         * Condy whose bootstrap method is one of the {@code TestDynamicConstant.get<type>BSM()}\n+         * methods.\n+         *\/\n+        CALL_DIRECT_BSM,\n+\n+        \/**\n+         * Condy whose bootstrap method is {@link ConstantBootstraps#invoke} that invokes one of the\n+         * {@code TestDynamicConstant.get<type>()} methods.\n+         *\/\n+        CALL_INDIRECT_BSM,\n+\n+        \/**\n+         * Condy whose bootstrap method is {@link ConstantBootstraps#invoke} that invokes one of the\n+         * {@code TestDynamicConstant.get<type>(<type> p1, <type> p2)} methods with args that are\n+         * condys themselves.\n+         *\/\n+        CALL_INDIRECT_WITH_ARGS_BSM\n+    }\n+\n+    \/**\n+     * Generates a class with a static {@code run} method that returns a value loaded from\n+     * CONSTANT_Dynamic constant pool entry.\n+     *\/\n+    static class TestGenerator {\n+\n+        \/**\n+         * Type of value returned by the generated {@code run} method.\n+         *\/\n+        final Type type;\n+\n+        \/**\n+         * Type of condy used to produce the returned value.\n+         *\/\n+        final CondyType condyType;\n+\n+        \/**\n+         * Base name of the static {@code TestDynamicConstant.get<type>} method(s) invoked from\n+         * condys in the generated class.\n+         *\/\n+        final String getter;\n+\n+        \/**\n+         * Name of the generated class.\n+         *\/\n+        final String className;\n+\n+        TestGenerator(Class<?> type, CondyType condyType) {\n+            String typeName = type.getSimpleName();\n+            this.type = Type.getType(type);\n+            this.condyType = condyType;\n+            this.getter = \"get\" + typeName.substring(0, 1).toUpperCase() + typeName.substring(1);\n+            this.className = TestDynamicConstant.class.getName() + \"$\" + typeName + '_' + condyType;\n+        }\n+\n+        Class<?> generateClass() throws ClassNotFoundException {\n+            TestCL cl = new TestCL(getClass().getClassLoader());\n+            return cl.findClass(className);\n+        }\n+\n+        byte[] generateClassfile() {\n+            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n+            cw.visit(V16, ACC_SUPER | ACC_PUBLIC, className.replace('.', '\/'), null, \"java\/lang\/Object\", null);\n+\n+            \/\/ @formatter:off\n+            \/\/ Object ConstantBootstraps.invoke(MethodHandles.Lookup lookup, String name, Class<?> type, MethodHandle handle, Object... args)\n+            \/\/ @formatter:on\n+            String invokeSig = \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+            Handle invokeHandle = new Handle(H_INVOKESTATIC, constantBootstrapsClassInternalName, \"invoke\", invokeSig, false);\n+\n+            String desc = type.getDescriptor();\n+            if (condyType == CondyType.CALL_DIRECT_BSM) {\n+                \/\/ Example: int TestDynamicConstant.getIntBSM(MethodHandles.Lookup l, String name,\n+                \/\/ Class<?> type)\n+                String sig = \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)\" + desc;\n+                Handle handle = new Handle(H_INVOKESTATIC, testClassInternalName, getter + \"BSM\", sig, false);\n+\n+                ConstantDynamic condy = new ConstantDynamic(\"const\", desc, handle);\n+                MethodVisitor run = cw.visitMethod(PUBLIC_STATIC, \"run\", \"()\" + desc, null, null);\n+                run.visitLdcInsn(condy);\n+                run.visitInsn(type.getOpcode(IRETURN));\n+                run.visitMaxs(0, 0);\n+                run.visitEnd();\n+            } else if (condyType == CondyType.CALL_INDIRECT_BSM) {\n+                \/\/ Example: int TestDynamicConstant.getInt()\n+                Handle handle = new Handle(H_INVOKESTATIC, testClassInternalName, getter, \"()\" + desc, false);\n+\n+                ConstantDynamic condy = new ConstantDynamic(\"const\", desc, invokeHandle, handle);\n+                MethodVisitor run = cw.visitMethod(PUBLIC_STATIC, \"run\", \"()\" + desc, null, null);\n+                run.visitLdcInsn(condy);\n+                run.visitInsn(type.getOpcode(IRETURN));\n+                run.visitMaxs(0, 0);\n+                run.visitEnd();\n+            } else {\n+                assert condyType == CondyType.CALL_INDIRECT_WITH_ARGS_BSM;\n+                \/\/ Example: int TestDynamicConstant.getInt()\n+                Handle handle1 = new Handle(H_INVOKESTATIC, testClassInternalName, getter, \"()\" + desc, false);\n+\n+                \/\/ Example: int TestDynamicConstant.getInt(int v1, int v2)\n+                Handle handle2 = new Handle(H_INVOKESTATIC, testClassInternalName, getter, \"(\" + desc + desc + \")\" + desc, false);\n+\n+                ConstantDynamic condy1 = new ConstantDynamic(\"const1\", desc, invokeHandle, handle1);\n+                ConstantDynamic condy2 = new ConstantDynamic(\"const2\", desc, invokeHandle, handle2, condy1, condy1);\n+\n+                MethodVisitor run = cw.visitMethod(PUBLIC_STATIC, \"run\", \"()\" + desc, null, null);\n+                run.visitLdcInsn(condy2);\n+                run.visitInsn(type.getOpcode(IRETURN));\n+                run.visitMaxs(0, 0);\n+                run.visitEnd();\n+            }\n+            cw.visitEnd();\n+            return cw.toByteArray();\n+        }\n+\n+        private final class TestCL extends ClassLoader {\n+            String saveClassfilesDir = System.getProperty(\"save.classfiles.dir\");\n+\n+            private TestCL(ClassLoader parent) {\n+                super(parent);\n+            }\n+\n+            @Override\n+            protected Class<?> findClass(String name) throws ClassNotFoundException {\n+                if (name.equals(className)) {\n+                    byte[] classfileBytes = generateClassfile();\n+                    if (saveClassfilesDir != null) {\n+                        try {\n+                            File classfile = new File(saveClassfilesDir, name.replace('.', File.separatorChar) + \".class\");\n+                            File classfileDir = classfile.getParentFile();\n+                            classfileDir.mkdirs();\n+                            Files.write(classfile.toPath(), classfileBytes);\n+                            System.out.println(\"Wrote: \" + classfile.getAbsolutePath());\n+                        } catch (IOException cause) {\n+                            Assert.fail(\"Error saving class file for \" + name, cause);\n+                        }\n+                    }\n+                    return defineClass(name, classfileBytes, 0, classfileBytes.length);\n+                } else {\n+                    return super.findClass(name);\n+                }\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"try\")\n+    @Test\n+    public void test() throws Throwable {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        Class<?>[] types = {boolean.class, byte.class, short.class, char.class, int.class, float.class, long.class, double.class, String.class};\n+        for (Class<?> type : types) {\n+            for (CondyType condyType : CondyType.values()) {\n+                TestGenerator e = new TestGenerator(type, condyType);\n+                Class<?> testClass = e.generateClass();\n+                Method m = testClass.getDeclaredMethod(\"run\");\n+                ResolvedJavaMethod run = metaAccess.lookupJavaMethod(m);\n+                ConstantPool cp = run.getConstantPool();\n+                Method getTagAt = cp.getClass().getDeclaredMethod(\"getTagAt\", int.class);\n+                getTagAt.setAccessible(true);\n+                Object lastConstant = null;\n+                for (int cpi = 1; cpi < cp.length(); cpi++) {\n+                    String tag = String.valueOf(getTagAt.invoke(cp, cpi));\n+                    if (tag.equals(\"Dynamic\")) {\n+                        lastConstant = cp.lookupConstant(cpi);\n+                    }\n+                }\n+                Assert.assertTrue(lastConstant != null, \"No Dynamic entries in constant pool of \" + testClass.getName());\n+\n+                \/\/ Execute code to resolve condy by execution and compare\n+                \/\/ with condy resolved via ConstantPool\n+                Object runResult = m.invoke(null);\n+                Object rawConstant;\n+                if (lastConstant instanceof PrimitiveConstant) {\n+                    rawConstant = ((PrimitiveConstant) lastConstant).asBoxedPrimitive();\n+                } else {\n+                    rawConstant = ((HotSpotObjectConstant) lastConstant).asObject(String.class);\n+                }\n+                Assert.assertEquals(runResult, rawConstant, String.format(\"%s: %s != %s\", m, runResult, rawConstant));\n+            }\n+        }\n+    }\n+\n+    \/\/ @formatter:off\n+    @SuppressWarnings(\"unused\") public static boolean getBooleanBSM(MethodHandles.Lookup l, String name, Class<?> type) { return true; }\n+    @SuppressWarnings(\"unused\") public static char    getCharBSM   (MethodHandles.Lookup l, String name, Class<?> type) { return '*'; }\n+    @SuppressWarnings(\"unused\") public static short   getShortBSM  (MethodHandles.Lookup l, String name, Class<?> type) { return Short.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static byte    getByteBSM   (MethodHandles.Lookup l, String name, Class<?> type) { return Byte.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static int     getIntBSM    (MethodHandles.Lookup l, String name, Class<?> type) { return Integer.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static float   getFloatBSM  (MethodHandles.Lookup l, String name, Class<?> type) { return Float.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static long    getLongBSM   (MethodHandles.Lookup l, String name, Class<?> type) { return Long.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static double  getDoubleBSM (MethodHandles.Lookup l, String name, Class<?> type) { return Double.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static String  getStringBSM (MethodHandles.Lookup l, String name, Class<?> type) { return \"a string\"; }\n+\n+\n+    public static boolean getBoolean() { return true; }\n+    public static char    getChar   () { return '*'; }\n+    public static short   getShort  () { return Short.MAX_VALUE; }\n+    public static byte    getByte   () { return Byte.MAX_VALUE; }\n+    public static int     getInt    () { return Integer.MAX_VALUE; }\n+    public static float   getFloat  () { return Float.MAX_VALUE; }\n+    public static long    getLong   () { return Long.MAX_VALUE; }\n+    public static double  getDouble () { return Double.MAX_VALUE; }\n+    public static String  getString () { return \"a string\"; }\n+\n+    public static boolean getBoolean(boolean v1, boolean v2) { return v1 || v2; }\n+    public static char    getChar   (char v1, char v2)       { return (char)(v1 ^ v2); }\n+    public static short   getShort  (short v1, short v2)     { return (short)(v1 ^ v2); }\n+    public static byte    getByte   (byte v1,   byte v2)     { return (byte)(v1 ^ v2); }\n+    public static int     getInt    (int v1, int v2)         { return v1 ^ v2; }\n+    public static float   getFloat  (float v1, float v2)     { return v1 * v2; }\n+    public static long    getLong   (long v1, long v2)       { return v1 ^ v2; }\n+    public static double  getDouble (double v1, double v2)   { return v1 * v2; }\n+    public static String  getString (String v1, String v2)   { return v1 + v2; }\n+    \/\/ @formatter:on\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestDynamicConstant.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -36,0 +36,11 @@\n+import static jdk.vm.ci.meta.MetaUtil.toInternalName;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import org.junit.Test;\n+\n@@ -45,10 +56,0 @@\n-import org.junit.Test;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-\n-import static jdk.vm.ci.meta.MetaUtil.toInternalName;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n@@ -120,1 +121,1 @@\n-         }\n+        }\n@@ -190,0 +191,3 @@\n+            if (c.getJavaKind() == JavaKind.Illegal) {\n+                continue;\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestMetaAccessProvider.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"}]}