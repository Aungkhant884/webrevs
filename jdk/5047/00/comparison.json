{"files":[{"patch":"@@ -71,0 +71,1 @@\n+#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n@@ -1453,0 +1454,1 @@\n+  _evac_failure_injector(),\n@@ -1486,5 +1488,0 @@\n-#ifndef PRODUCT\n-  _evacuation_failure_alot_for_current_gc(false),\n-  _evacuation_failure_alot_gc_number(0),\n-  _evacuation_failure_alot_count(0),\n-#endif\n@@ -1523,2 +1520,0 @@\n-  \/\/ Initialize the G1EvacuationFailureALot counters and flags.\n-  NOT_PRODUCT(reset_evacuation_should_fail();)\n@@ -1781,0 +1776,2 @@\n+  evac_failure_injector()->reset();\n+\n@@ -3587,1 +3584,1 @@\n-  NOT_PRODUCT(set_evacuation_failure_alot_for_current_gc();)\n+  evac_failure_injector()->arm_if_needed();\n@@ -4303,1 +4300,1 @@\n-    NOT_PRODUCT(reset_evacuation_should_fail();)\n+    evac_failure_injector()->reset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n@@ -218,0 +219,2 @@\n+  G1YoungGCEvacFailureInjector _evac_failure_injector;\n+\n@@ -577,0 +580,2 @@\n+  G1YoungGCEvacFailureInjector* evac_failure_injector() { return &_evac_failure_injector; }\n+\n@@ -898,33 +903,0 @@\n-#ifndef PRODUCT\n-  \/\/ Support for forcing evacuation failures. Analogous to\n-  \/\/ PromotionFailureALot for the other collectors.\n-\n-  \/\/ Records whether G1EvacuationFailureALot should be in effect\n-  \/\/ for the current GC\n-  bool _evacuation_failure_alot_for_current_gc;\n-\n-  \/\/ Used to record the GC number for interval checking when\n-  \/\/ determining whether G1EvaucationFailureALot is in effect\n-  \/\/ for the current GC.\n-  size_t _evacuation_failure_alot_gc_number;\n-\n-  \/\/ Count of the number of evacuations between failures.\n-  volatile size_t _evacuation_failure_alot_count;\n-\n-  \/\/ Set whether G1EvacuationFailureALot should be in effect\n-  \/\/ for the current GC (based upon the type of GC and which\n-  \/\/ command line flags are set);\n-  inline bool evacuation_failure_alot_for_gc_type(bool for_young_gc,\n-                                                  bool during_concurrent_start,\n-                                                  bool mark_or_rebuild_in_progress);\n-\n-  inline void set_evacuation_failure_alot_for_current_gc();\n-\n-  \/\/ Return true if it's time to cause an evacuation failure.\n-  inline bool evacuation_should_fail();\n-\n-  \/\/ Reset the G1EvacuationFailureALot counters.  Should be called at\n-  \/\/ the end of an evacuation pause in which an evacuation failure occurred.\n-  inline void reset_evacuation_should_fail();\n-#endif \/\/ !PRODUCT\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":33,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -214,72 +214,0 @@\n-#ifndef PRODUCT\n-\/\/ Support for G1EvacuationFailureALot\n-\n-inline bool\n-G1CollectedHeap::evacuation_failure_alot_for_gc_type(bool for_young_gc,\n-                                                     bool during_concurrent_start,\n-                                                     bool mark_or_rebuild_in_progress) {\n-  bool res = false;\n-  if (mark_or_rebuild_in_progress) {\n-    res |= G1EvacuationFailureALotDuringConcMark;\n-  }\n-  if (during_concurrent_start) {\n-    res |= G1EvacuationFailureALotDuringConcurrentStart;\n-  }\n-  if (for_young_gc) {\n-    res |= G1EvacuationFailureALotDuringYoungGC;\n-  } else {\n-    \/\/ GCs are mixed\n-    res |= G1EvacuationFailureALotDuringMixedGC;\n-  }\n-  return res;\n-}\n-\n-inline void\n-G1CollectedHeap::set_evacuation_failure_alot_for_current_gc() {\n-  if (G1EvacuationFailureALot) {\n-    \/\/ Note we can't assert that _evacuation_failure_alot_for_current_gc\n-    \/\/ is clear here. It may have been set during a previous GC but that GC\n-    \/\/ did not copy enough objects (i.e. G1EvacuationFailureALotCount) to\n-    \/\/ trigger an evacuation failure and clear the flags and and counts.\n-\n-    \/\/ Check if we have gone over the interval.\n-    const size_t gc_num = total_collections();\n-    const size_t elapsed_gcs = gc_num - _evacuation_failure_alot_gc_number;\n-\n-    _evacuation_failure_alot_for_current_gc = (elapsed_gcs >= G1EvacuationFailureALotInterval);\n-\n-    \/\/ Now check if G1EvacuationFailureALot is enabled for the current GC type.\n-    const bool in_young_only_phase = collector_state()->in_young_only_phase();\n-    const bool in_concurrent_start_gc = collector_state()->in_concurrent_start_gc();\n-    const bool mark_or_rebuild_in_progress = collector_state()->mark_or_rebuild_in_progress();\n-\n-    _evacuation_failure_alot_for_current_gc &=\n-      evacuation_failure_alot_for_gc_type(in_young_only_phase,\n-                                          in_concurrent_start_gc,\n-                                          mark_or_rebuild_in_progress);\n-  }\n-}\n-\n-inline bool G1CollectedHeap::evacuation_should_fail() {\n-  if (!G1EvacuationFailureALot || !_evacuation_failure_alot_for_current_gc) {\n-    return false;\n-  }\n-  \/\/ G1EvacuationFailureALot is in effect for current GC\n-  \/\/ Access to _evacuation_failure_alot_count is not atomic;\n-  \/\/ the value does not have to be exact.\n-  if (++_evacuation_failure_alot_count < G1EvacuationFailureALotCount) {\n-    return false;\n-  }\n-  _evacuation_failure_alot_count = 0;\n-  return true;\n-}\n-\n-inline void G1CollectedHeap::reset_evacuation_should_fail() {\n-  if (G1EvacuationFailureALot) {\n-    _evacuation_failure_alot_gc_number = total_collections();\n-    _evacuation_failure_alot_count = 0;\n-    _evacuation_failure_alot_for_current_gc = false;\n-  }\n-}\n-#endif  \/\/ #ifndef PRODUCT\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp\"\n@@ -457,1 +458,0 @@\n-#ifndef PRODUCT\n@@ -459,1 +459,1 @@\n-  if (_g1h->evacuation_should_fail()) {\n+  if (_g1h->evac_failure_injector()->evacuation_should_fail()) {\n@@ -465,1 +465,0 @@\n-#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+\n+#ifndef PRODUCT\n+\n+bool G1YoungGCEvacFailureInjector::arm_if_needed_for_gc_type(bool for_young_gc,\n+                                                             bool during_concurrent_start,\n+                                                             bool mark_or_rebuild_in_progress) {\n+  bool res = false;\n+  if (mark_or_rebuild_in_progress) {\n+    res |= G1EvacuationFailureALotDuringConcMark;\n+  }\n+  if (during_concurrent_start) {\n+    res |= G1EvacuationFailureALotDuringConcurrentStart;\n+  }\n+  if (for_young_gc) {\n+    res |= G1EvacuationFailureALotDuringYoungGC;\n+  } else {\n+    \/\/ GCs are mixed\n+    res |= G1EvacuationFailureALotDuringMixedGC;\n+  }\n+  return res;\n+}\n+\n+void G1YoungGCEvacFailureInjector::arm_if_needed() {\n+  if (G1EvacuationFailureALot) {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    \/\/ Check if we have gone over the interval.\n+    const size_t gc_num = g1h->total_collections();\n+    const size_t elapsed_gcs = gc_num - _last_collection_with_evacuation_failure;\n+\n+    _inject_evacuation_failure_for_current_gc = (elapsed_gcs >= G1EvacuationFailureALotInterval);\n+\n+    \/\/ Now check if evacuation failure injection should be enabled for the current GC.\n+    G1CollectorState* collector_state = g1h->collector_state();\n+    const bool in_young_only_phase = collector_state->in_young_only_phase();\n+    const bool in_concurrent_start_gc = collector_state->in_concurrent_start_gc();\n+    const bool mark_or_rebuild_in_progress = collector_state->mark_or_rebuild_in_progress();\n+\n+    _inject_evacuation_failure_for_current_gc &=\n+      arm_if_needed_for_gc_type(in_young_only_phase,\n+                                in_concurrent_start_gc,\n+                                mark_or_rebuild_in_progress);\n+  }\n+}\n+\n+void G1YoungGCEvacFailureInjector::reset() {\n+  if (G1EvacuationFailureALot) {\n+    _last_collection_with_evacuation_failure = G1CollectedHeap::heap()->total_collections();\n+    _evacuation_failure_object_count = 0;\n+    _inject_evacuation_failure_for_current_gc = false;\n+  }\n+}\n+\n+#endif \/\/ #ifndef PRODUCT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_HPP\n+#define SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Support for injecting evacuation failures based on the G1EvacuationFailureALot*\n+\/\/ flags. Analogous to PromotionFailureALot for the other collectors.\n+\/\/\n+\/\/ Every G1EvacuationFailureALotInterval collections without evacuation failure\n+\/\/ inbetween we \"arm\" the injector to induce evacuation failures after\n+\/\/ G1EvacuationFailureALotCount successful evacuations.\n+\/\/\n+\/\/ Available only in non-product builds.\n+class G1YoungGCEvacFailureInjector {\n+  \/\/ Should we inject evacuation failures in the current GC.\n+  bool _inject_evacuation_failure_for_current_gc;\n+\n+  \/\/ Records the number of the last collection when evacuation failure happened.\n+  \/\/ Used to determine whether evacuation failure injection should be in effect\n+  \/\/ for the current GC.\n+  size_t _last_collection_with_evacuation_failure;\n+\n+  \/\/ The number of evacuations between induced failures.\n+  volatile size_t _evacuation_failure_object_count;\n+\n+  bool arm_if_needed_for_gc_type(bool for_young_gc,\n+                                 bool during_concurrent_start,\n+                                 bool mark_or_rebuild_in_progress) PRODUCT_RETURN_( return false; );\n+public:\n+\n+  \/\/ Arm the evacuation failure injector if needed for the current\n+  \/\/ GC (based upon the type of GC and which command line flags are set);\n+  void arm_if_needed() PRODUCT_RETURN;\n+\n+  \/\/ Return true if it's time to cause an evacuation failure.\n+  bool evacuation_should_fail() PRODUCT_RETURN_( return false; );\n+\n+  \/\/ Reset the evacuation failure injection counters. Should be called at\n+  \/\/ the end of an evacuation pause in which an evacuation failure occurred.\n+  void reset() PRODUCT_RETURN;\n+};\n+\n+#endif \/* SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_HPP *\/\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_INLINE_HPP\n+#define SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_INLINE_HPP\n+\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n+\n+#ifndef PRODUCT\n+\n+inline bool G1YoungGCEvacFailureInjector::evacuation_should_fail() {\n+  if (!G1EvacuationFailureALot || !_inject_evacuation_failure_for_current_gc) {\n+    return false;\n+  }\n+  \/\/ Injecting evacuation failures is in effect for current GC\n+  \/\/ Access to _evacuation_failure_alot_count is not atomic;\n+  \/\/ the value does not have to be exact.\n+  if (++_evacuation_failure_object_count < G1EvacuationFailureALotCount) {\n+    return false;\n+  }\n+  _evacuation_failure_object_count = 0;\n+  return true;\n+}\n+\n+#endif  \/\/ #ifndef PRODUCT\n+\n+#endif \/* SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_INLINE_HPP *\/\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}