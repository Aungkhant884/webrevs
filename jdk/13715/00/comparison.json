{"files":[{"patch":"@@ -62,7 +62,1 @@\n-  \/\/ Re-check whether the passed object is null. With ReferentBasedDiscovery the\n-  \/\/ mutator may have changed the referent's value (i.e. cleared it) between the\n-  \/\/ time the referent was determined to be potentially alive and calling this\n-  \/\/ method.\n-  if (obj == NULL) {\n-    return false;\n-  }\n+  assert(obj != nullptr, \"precondition\");\n@@ -70,0 +64,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -219,6 +219,0 @@\n-  product(intx, RefDiscoveryPolicy, 0,                                      \\\n-          \"Select type of reference discovery policy: \"                     \\\n-          \"reference-based(0) or referent-based(1)\")                        \\\n-          range(ReferenceProcessor::DiscoveryPolicyMin,                     \\\n-                ReferenceProcessor::DiscoveryPolicyMax)                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-  guarantee(RefDiscoveryPolicy == ReferenceBasedDiscovery ||\n-            RefDiscoveryPolicy == ReferentBasedDiscovery,\n-            \"Unrecognized RefDiscoveryPolicy\");\n@@ -924,26 +921,10 @@\n-\/\/ We mention two of several possible choices here:\n-\/\/ #0: if the reference object is not in the \"originating generation\"\n-\/\/     (or part of the heap being collected, indicated by our \"span\")\n-\/\/     we don't treat it specially (i.e. we scan it as we would\n-\/\/     a normal oop, treating its references as strong references).\n-\/\/     This means that references can't be discovered unless their\n-\/\/     referent is also in the same span. This is the simplest,\n-\/\/     most \"local\" and most conservative approach, albeit one\n-\/\/     that may cause weak references to be enqueued least promptly.\n-\/\/     We call this choice the \"ReferenceBasedDiscovery\" policy.\n-\/\/ #1: the reference object may be in any generation (span), but if\n-\/\/     the referent is in the generation (span) being currently collected\n-\/\/     then we can discover the reference object, provided\n-\/\/     the object has not already been discovered by\n-\/\/     a different concurrently running discoverer (as may be the\n-\/\/     case, for instance, if the reference object is in G1 old gen and\n-\/\/     the referent in G1 young gen), and provided the processing\n-\/\/     of this reference object by the current collector will\n-\/\/     appear atomically to every other discoverer in the system.\n-\/\/     (Thus, for instance, a concurrent discoverer may not\n-\/\/     discover references in other generations even if the\n-\/\/     referent is in its own generation). This policy may,\n-\/\/     in certain cases, enqueue references somewhat sooner than\n-\/\/     might Policy #0 above, but at marginally increased cost\n-\/\/     and complexity in processing these references.\n-\/\/     We call this choice the \"ReferentBasedDiscovery\" policy.\n+\/\/ Reference discovery policy:\n+\/\/   if the reference object is not in the \"originating generation\"\n+\/\/   (or part of the heap being collected, indicated by our \"span\")\n+\/\/   we don't treat it specially (i.e. we scan it as we would\n+\/\/   a normal oop, treating its references as strong references).\n+\/\/   This means that references can't be discovered unless their\n+\/\/   referent is also in the same span. This is the simplest,\n+\/\/   most \"local\" and most conservative approach, albeit one\n+\/\/   that may cause weak references to be enqueued least promptly.\n+\/\/   We call this choice the \"ReferenceBasedDiscovery\" policy.\n@@ -961,2 +942,1 @@\n-  if (RefDiscoveryPolicy == ReferenceBasedDiscovery &&\n-      !is_subject_to_discovery(obj)) {\n+  if (!is_subject_to_discovery(obj)) {\n@@ -1000,15 +980,0 @@\n-    if (RefDiscoveryPolicy == ReferentBasedDiscovery) {\n-      \/\/ assumes that an object is not processed twice;\n-      \/\/ if it's been already discovered it must be on another\n-      \/\/ generation's discovered list; so we won't discover it.\n-      return false;\n-    } else {\n-      assert(RefDiscoveryPolicy == ReferenceBasedDiscovery,\n-             \"Unrecognized policy\");\n-      \/\/ Check assumption that an object is not potentially\n-      \/\/ discovered twice except by concurrent collectors that potentially\n-      \/\/ trace the same Reference object twice.\n-      assert(UseG1GC, \"Only possible with a concurrent marking collector\");\n-      return true;\n-    }\n-  }\n@@ -1016,14 +981,5 @@\n-  if (RefDiscoveryPolicy == ReferentBasedDiscovery) {\n-    verify_referent(obj);\n-    \/\/ Discover if and only if EITHER:\n-    \/\/ .. reference is in our span, OR\n-    \/\/ .. we are a stw discoverer and referent is in our span\n-    if (is_subject_to_discovery(obj) ||\n-        (discovery_is_stw() &&\n-         is_subject_to_discovery(java_lang_ref_Reference::unknown_referent_no_keepalive(obj)))) {\n-    } else {\n-      return false;\n-    }\n-  } else {\n-    assert(RefDiscoveryPolicy == ReferenceBasedDiscovery &&\n-           is_subject_to_discovery(obj), \"code inconsistency\");\n+    \/\/ Check assumption that an object is not potentially\n+    \/\/ discovered twice except by concurrent collectors that potentially\n+    \/\/ trace the same Reference object twice.\n+    assert(UseG1GC, \"Only possible with a concurrent marking collector\");\n+    return true;\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":16,"deletions":60,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -381,8 +381,0 @@\n-  \/\/ RefDiscoveryPolicy values\n-  enum DiscoveryPolicy {\n-    ReferenceBasedDiscovery = 0,\n-    ReferentBasedDiscovery  = 1,\n-    DiscoveryPolicyMin      = ReferenceBasedDiscovery,\n-    DiscoveryPolicyMax      = ReferentBasedDiscovery\n-  };\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -526,0 +526,1 @@\n+  { \"RefDiscoveryPolicy\",           JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,4 +53,0 @@\n-TEST_VM(FlagGuard, intx_flag) {\n-  TEST_FLAG(RefDiscoveryPolicy, intx, 1337);\n-}\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_globals.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}