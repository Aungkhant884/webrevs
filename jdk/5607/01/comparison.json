{"files":[{"patch":"@@ -213,8 +213,1 @@\n-  assert(obj != NULL, \"Must be\");\n-  if (HeapRegion::is_in_same_region(p, obj)) {\n-    return;\n-  }\n-  HeapRegion* from = _g1h->heap_region_containing(p);\n-  if (!from->is_young()) {\n-    enqueue_card_if_tracked(_g1h->region_attr(obj), p, obj);\n-  }\n+  write_ref_field_post(p, obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -107,2 +107,0 @@\n-  void handle_evacuation_failure_notifications(oop obj, markWord m, size_t word_sz);\n-\n@@ -133,3 +131,5 @@\n-  template <class T> void enqueue_card_if_tracked(G1HeapRegionAttr region_attr, T* p, oop o) {\n-    assert(!HeapRegion::is_in_same_region(p, o), \"Should have filtered out cross-region references already.\");\n-    assert(!_g1h->heap_region_containing(p)->is_young(), \"Should have filtered out from-young references already.\");\n+  \/\/ Apply the post barrier to the given reference field. Enqueues the card of p\n+  \/\/ if the barrier (same region, not from survivor) does not filter out not find\n+  \/\/ that it is not required.\n+  \/\/ To be called during GC if nothing particular about p and obj are known.\n+  template <class T> void write_ref_field_post(T* p, oop obj);\n@@ -137,18 +137,4 @@\n-#ifdef ASSERT\n-    HeapRegion* const hr_obj = _g1h->heap_region_containing(o);\n-    assert(region_attr.needs_remset_update() == hr_obj->rem_set()->is_tracked(),\n-           \"State flag indicating remset tracking disagrees (%s) with actual remembered set (%s) for region %u\",\n-           BOOL_TO_STR(region_attr.needs_remset_update()),\n-           BOOL_TO_STR(hr_obj->rem_set()->is_tracked()),\n-           hr_obj->hrm_index());\n-#endif\n-    if (!region_attr.needs_remset_update()) {\n-      return;\n-    }\n-    size_t card_index = ct()->index_for(p);\n-    \/\/ If the card hasn't been added to the buffer, do it.\n-    if (_last_enqueued_card != card_index) {\n-      _rdc_local_qset.enqueue(ct()->byte_for_index(card_index));\n-      _last_enqueued_card = card_index;\n-    }\n-  }\n+  \/\/ Enqueue the card if the reference's target region's remembered set is tracked.\n+  \/\/ Assumes that a significant amount of pre-filtering (like done by\n+  \/\/ enqueue_card_after_barrier_filters()) has already been performed.\n+  template <class T> void enqueue_card_if_tracked(G1HeapRegionAttr region_attr, T* p, oop o);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,34 @@\n+template <class T> void G1ParScanThreadState::write_ref_field_post(T* p, oop obj) {\n+  assert(obj != NULL, \"Must be\");\n+  if (HeapRegion::is_in_same_region(p, obj)) {\n+    return;\n+  }\n+  HeapRegion* from = _g1h->heap_region_containing(p);\n+  if (!from->is_young()) {\n+    enqueue_card_if_tracked(_g1h->region_attr(obj), p, obj);\n+  }\n+}\n+\n+template <class T> void G1ParScanThreadState::enqueue_card_if_tracked(G1HeapRegionAttr region_attr, T* p, oop o) {\n+  assert(!HeapRegion::is_in_same_region(p, o), \"Should have filtered out cross-region references already.\");\n+  assert(!_g1h->heap_region_containing(p)->is_young(), \"Should have filtered out from-young references already.\");\n+\n+#ifdef ASSERT\n+  HeapRegion* const hr_obj = _g1h->heap_region_containing(o);\n+  assert(region_attr.needs_remset_update() == hr_obj->rem_set()->is_tracked(),\n+         \"State flag indicating remset tracking disagrees (%s) with actual remembered set (%s) for region %u\",\n+         BOOL_TO_STR(region_attr.needs_remset_update()),\n+         BOOL_TO_STR(hr_obj->rem_set()->is_tracked()),\n+         hr_obj->hrm_index());\n+#endif\n+  if (!region_attr.needs_remset_update()) {\n+    return;\n+  }\n+  size_t card_index = ct()->index_for(p);\n+  \/\/ If the card hasn't been added to the buffer, do it.\n+  if (_last_enqueued_card != card_index) {\n+    _rdc_local_qset.enqueue(ct()->byte_for_index(card_index));\n+    _last_enqueued_card = card_index;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"}]}