{"files":[{"patch":"@@ -1243,3 +1243,1 @@\n-  bool is_obj_dead(const oop obj, const HeapRegion* hr) const {\n-    return hr->is_obj_dead(obj, _cm->prev_mark_bitmap());\n-  }\n+  inline bool is_obj_dead(const oop obj, const HeapRegion* hr) const;\n@@ -1250,6 +1248,1 @@\n-  bool is_obj_ill(const oop obj, const HeapRegion* hr) const {\n-    return\n-      !hr->obj_allocated_since_next_marking(obj) &&\n-      !is_marked_next(obj) &&\n-      !hr->is_closed_archive();\n-  }\n+  inline bool is_obj_ill(const oop obj, const HeapRegion* hr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n@@ -210,0 +211,4 @@\n+inline bool G1CollectedHeap::is_obj_dead(const oop obj, const HeapRegion* hr) const {\n+  return hr->is_obj_dead(obj, _cm->prev_mark_bitmap());\n+}\n+\n@@ -217,0 +222,7 @@\n+inline bool G1CollectedHeap::is_obj_ill(const oop obj, const HeapRegion* hr) const {\n+  return\n+    !hr->obj_allocated_since_next_marking(obj) &&\n+    !is_marked_next(obj) &&\n+    !hr->is_closed_archive();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -213,8 +213,1 @@\n-  assert(obj != NULL, \"Must be\");\n-  if (HeapRegion::is_in_same_region(p, obj)) {\n-    return;\n-  }\n-  HeapRegion* from = _g1h->heap_region_containing(p);\n-  if (!from->is_young()) {\n-    enqueue_card_if_tracked(_g1h->region_attr(obj), p, obj);\n-  }\n+  write_ref_field_post(p, obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/g1\/g1CardTable.hpp\"\n@@ -32,2 +31,0 @@\n-#include \"gc\/g1\/g1RemSet.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -43,0 +40,2 @@\n+class G1CardTable;\n+class G1EvacuationRootClosures;\n@@ -45,1 +44,0 @@\n-class G1EvacuationRootClosures;\n@@ -63,1 +61,1 @@\n-  G1ScanEvacuatedObjClosure  _scanner;\n+  G1ScanEvacuatedObjClosure _scanner;\n@@ -107,2 +105,0 @@\n-  void handle_evacuation_failure_notifications(oop obj, markWord m, size_t word_sz);\n-\n@@ -133,3 +129,5 @@\n-  template <class T> void enqueue_card_if_tracked(G1HeapRegionAttr region_attr, T* p, oop o) {\n-    assert(!HeapRegion::is_in_same_region(p, o), \"Should have filtered out cross-region references already.\");\n-    assert(!_g1h->heap_region_containing(p)->is_young(), \"Should have filtered out from-young references already.\");\n+  \/\/ Apply the post barrier to the given reference field. Enqueues the card of p\n+  \/\/ if the barrier does not filter out the reference for some reason (e.g.\n+  \/\/ p and q are in the same region, p is in survivor)\n+  \/\/ To be called during GC if nothing particular about p and obj are known.\n+  template <class T> void write_ref_field_post(T* p, oop obj);\n@@ -137,18 +135,4 @@\n-#ifdef ASSERT\n-    HeapRegion* const hr_obj = _g1h->heap_region_containing(o);\n-    assert(region_attr.needs_remset_update() == hr_obj->rem_set()->is_tracked(),\n-           \"State flag indicating remset tracking disagrees (%s) with actual remembered set (%s) for region %u\",\n-           BOOL_TO_STR(region_attr.needs_remset_update()),\n-           BOOL_TO_STR(hr_obj->rem_set()->is_tracked()),\n-           hr_obj->hrm_index());\n-#endif\n-    if (!region_attr.needs_remset_update()) {\n-      return;\n-    }\n-    size_t card_index = ct()->index_for(p);\n-    \/\/ If the card hasn't been added to the buffer, do it.\n-    if (_last_enqueued_card != card_index) {\n-      _rdc_local_qset.enqueue(ct()->byte_for_index(card_index));\n-      _last_enqueued_card = card_index;\n-    }\n-  }\n+  \/\/ Enqueue the card if the reference's target region's remembered set is tracked.\n+  \/\/ Assumes that a significant amount of pre-filtering (like done by\n+  \/\/ write_ref_field_post() above) has already been performed.\n+  template <class T> void enqueue_card_if_tracked(G1HeapRegionAttr region_attr, T* p, oop o);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":12,"deletions":28,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1CardTable.hpp\"\n@@ -98,0 +99,34 @@\n+template <class T> void G1ParScanThreadState::write_ref_field_post(T* p, oop obj) {\n+  assert(obj != NULL, \"Must be\");\n+  if (HeapRegion::is_in_same_region(p, obj)) {\n+    return;\n+  }\n+  HeapRegion* from = _g1h->heap_region_containing(p);\n+  if (!from->is_young()) {\n+    enqueue_card_if_tracked(_g1h->region_attr(obj), p, obj);\n+  }\n+}\n+\n+template <class T> void G1ParScanThreadState::enqueue_card_if_tracked(G1HeapRegionAttr region_attr, T* p, oop o) {\n+  assert(!HeapRegion::is_in_same_region(p, o), \"Should have filtered out cross-region references already.\");\n+  assert(!_g1h->heap_region_containing(p)->is_young(), \"Should have filtered out from-young references already.\");\n+\n+#ifdef ASSERT\n+  HeapRegion* const hr_obj = _g1h->heap_region_containing(o);\n+  assert(region_attr.needs_remset_update() == hr_obj->rem_set()->is_tracked(),\n+         \"State flag indicating remset tracking disagrees (%s) with actual remembered set (%s) for region %u\",\n+         BOOL_TO_STR(region_attr.needs_remset_update()),\n+         BOOL_TO_STR(hr_obj->rem_set()->is_tracked()),\n+         hr_obj->hrm_index());\n+#endif\n+  if (!region_attr.needs_remset_update()) {\n+    return;\n+  }\n+  size_t card_index = ct()->index_for(p);\n+  \/\/ If the card hasn't been added to the buffer, do it.\n+  if (_last_enqueued_card != card_index) {\n+    _rdc_local_qset.enqueue(ct()->byte_for_index(card_index));\n+    _last_enqueued_card = card_index;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"}]}