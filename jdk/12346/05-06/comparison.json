{"files":[{"patch":"@@ -75,2 +75,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -90,0 +88,1 @@\n+import java.util.function.IntFunction;\n@@ -91,0 +90,1 @@\n+import jdk.internal.util.LazyReferenceArray;\n@@ -148,5 +148,1 @@\n-    @Stable\n-    private static final ZoneOffset[] SECONDS_CACHE = new ZoneOffset[MAX_SECONDS_CACHE_SLOT * 2 + 1];\n-\n-    \/** Access to the SECONDS_CACHE must be made via VarHandle volatile access *\/\n-    private static final VarHandle SECONDS_CACHE_VH = MethodHandles.arrayElementVarHandle(ZoneOffset[].class);\n+    private static final LazyReferenceArray<ZoneOffset> SECONDS_CACHE = LazyReferenceArray.create(MAX_SECONDS_CACHE_SLOT * 2 + 1);\n@@ -433,0 +429,3 @@\n+        final class Holder {\n+            private static final IntFunction<ZoneOffset> ZONE_OFFSET_MAPPER = new ZoneOffsetMapper();\n+        }\n@@ -437,15 +436,2 @@\n-            int slot = cacheSlot(totalSeconds);\n-            \/\/ Happens-before semantics are needed for double-checked locking\n-            \/\/ to prevent reading uninitialized ZoneOffset objects due to reordering.\n-            ZoneOffset cached = getAcquireSecondsCache(slot);\n-            if (cached == null) {\n-                synchronized (SECONDS_CACHE) {\n-                    cached = getAcquireSecondsCache(slot);\n-                    if (cached == null) {\n-                        cached = new ZoneOffset(totalSeconds);\n-                        setReleaseSecondsCache(slot, cached);\n-                        ID_CACHE.putIfAbsent(cached.getId(), cached);\n-                    }\n-                }\n-            }\n-            return cached;\n+            int slot = secondsToSlot(totalSeconds);\n+            return SECONDS_CACHE.computeIfAbsent(slot, Holder.ZONE_OFFSET_MAPPER);\n@@ -457,5 +443,10 @@\n-    static ZoneOffset getAcquireSecondsCache(int slot) {\n-        return (ZoneOffset) SECONDS_CACHE_VH.getAcquire(SECONDS_CACHE, slot);\n-    }\n-    static void setReleaseSecondsCache(int slot, ZoneOffset value) {\n-        SECONDS_CACHE_VH.setRelease(SECONDS_CACHE, slot, value);\n+    \/\/ Declare a concrete class rather than a lambda to improve startup time\n+    private static final class ZoneOffsetMapper implements IntFunction<ZoneOffset> {\n+\n+        @Override\n+        public ZoneOffset apply(int slot) {\n+            int totalSeconds = slotToSeconds(slot);\n+            ZoneOffset newValue = new ZoneOffset(totalSeconds);\n+            ID_CACHE.putIfAbsent(newValue.getId(), newValue);\n+            return newValue;\n+        }\n@@ -464,1 +455,1 @@\n-    private static int cacheSlot(int totalSeconds) {\n+    private static int secondsToSlot(int totalSeconds) {\n@@ -468,0 +459,4 @@\n+    private static int slotToSeconds(int slot) {\n+        return (slot - MAX_SECONDS_CACHE_SLOT) * (15 * SECONDS_PER_MINUTE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+package jdk.internal.util;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * An array of object references in which elements may be updated\n+ * just once (lazily) and atomically. This contrasts to {@link AtomicReferenceArray } where\n+ * any number of updates can be done and where there is no simple way to atomically compute\n+ * a value (guaranteed to only be computed once) if it is missing.\n+ * <p>\n+ * This class is thread-safe.\n+ * <p>\n+ * The JVM may apply certain optimizations as it knows a component is updated just once\n+ * as described by {@link Stable}.\n+ *\n+ * @param <E> The type of elements held in this array\n+ *\/\n+public final class LazyReferenceArray<E> {\n+\n+    private static final VarHandle ARRAY_VH = MethodHandles.arrayElementVarHandle(Object[].class);\n+\n+    @Stable\n+    private final Object[] array;\n+\n+    \/**\n+     * Creates a new AtomicReferenceArray of the given length, with all\n+     * elements initially null.\n+     *\n+     * @param length the length of the array\n+     *\/\n+    private LazyReferenceArray(int length) {\n+        this.array = new Object[length];\n+    }\n+\n+    \/**\n+     * {@return the length of the array}.\n+     *\/\n+    public int length() {\n+        return array.length;\n+    }\n+\n+    \/**\n+     * {@return the element at index {@code i} or {@code null} if\n+     * no such element exists }\n+     *\n+     * @param index the element index\n+     * @throws IndexOutOfBoundsException if {@code index < 0 or index >= length() }\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public E getOrNull(int index) {\n+        return getAcquire(index);\n+    }\n+\n+    \/**\n+     * {@return the element at index {@code i} or, if no such element exists, throws\n+     * a NoSuchElementException}.\n+     *\n+     * @param index the element index\n+     * @throws NoSuchElementException    if no such element exists at the provided {@code index}\n+     * @throws IndexOutOfBoundsException if {@code index < 0 or index >= length() }\n+     *\/\n+    public E getOrThrow(int index) {\n+        E value = getOrNull(index);\n+        if (value == null) {\n+            throw new NoSuchElementException(\"No element at \" + index);\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * If the specified index is not already associated with a value, atomically attempts\n+     * to compute its value using the given mapping function and enters it into this\n+     * array.\n+     *\n+     * <p>If the mapping function returns {@code null}, an exception is thrown.\n+     * If the mapping function itself throws an (unchecked) exception, the\n+     * exception is rethrown, and no mapping is recorded.  The most\n+     * common usage is to construct a new object serving as an initial\n+     * mapped value or memoized result, as in:\n+     *\n+     * <pre> {@code\n+     * array.computeIfAbsent(index, i -> new Value(f(i)));\n+     * }<\/pre>\n+     *\n+     * @param index to use as array index\n+     * @param mappingFunction to apply if no previous value exists\n+     * @return the element at the provided index (pre-existing or newly computed)\n+     * @throws IndexOutOfBoundsException if {@code index < 0 or index >= length() }.\n+     * @throws NullPointerException      if the provided {@code mappingFunction} is {@code null} or\n+     *                                   the provided {@code mappingFunction} returns {@code null}.\n+     *\/\n+    public E computeIfAbsent(int index,\n+                             IntFunction<? extends E> mappingFunction) {\n+        Objects.checkIndex(index, array.length);\n+        Objects.requireNonNull(mappingFunction);\n+\n+        E value = getAcquire(index);\n+        if (value == null) {\n+            synchronized (array) {\n+                value = getAcquire(index);\n+                if (value == null) {\n+                    value = Objects.requireNonNull(\n+                            mappingFunction.apply(index));\n+                    setRelease(index, value);\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+    \/\/ Use acquire\/release to ensure happens-before so that newly\n+    \/\/ constructed elements are always observed correctly\n+    private E getAcquire(int index) {\n+        return (E) ARRAY_VH.getAcquire(array, index);\n+    }\n+\n+    void setRelease(int slot, Object value) {\n+        ARRAY_VH.setRelease(array, slot, value);\n+    }\n+\n+    \/**\n+     * {@return a new AtomicReferenceArray of the given length, with all\n+     * elements initially null}.\n+     *\n+     * @param length the length of the array\n+     * @throws IllegalArgumentException if the provided {@code length} is negative.\n+     *\/\n+    public static <E> LazyReferenceArray<E> create(int length) {\n+        if (length < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return new LazyReferenceArray<>(length);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/LazyReferenceArray.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Verify basic LazyReferenceArray operations\n+ * @run junit BasicLazyReferenceArrayTest\n+ *\/\n+\n+import jdk.internal.util.LazyReferenceArray;\n+import org.junit.jupiter.api.*;\n+\n+import java.util.NoSuchElementException;\n+import java.util.function.IntFunction;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class BasicLazyReferenceArrayTest {\n+\n+    private static final int LENGTH = 10;\n+\n+    LazyReferenceArray<Integer> instance;\n+\n+    @BeforeEach\n+    void setup() {\n+        instance = LazyReferenceArray.create(LENGTH);\n+    }\n+\n+    @Test\n+    void length() {\n+        assertEquals(LENGTH, instance.length());\n+    }\n+\n+    @Test\n+    void emptyGet() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            assertNull(instance.getOrNull(i));\n+        }\n+    }\n+\n+    @Test\n+    void emptyGetOrThrow() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            final int val = i;\n+            assertThrows(NoSuchElementException.class,\n+                    () -> instance.getOrThrow(val));\n+        }\n+    }\n+\n+    @Test\n+    void compute() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            Integer val = instance.computeIfAbsent(i, intIdentity());\n+            assertEquals(i, val);\n+        }\n+    }\n+\n+    @Test\n+    void nulls() {\n+        \/\/ Mapper is null\n+        assertThrows(NullPointerException.class,\n+                () -> instance.computeIfAbsent(0, null));\n+        \/\/ Mapper returns null\n+        assertThrows(NullPointerException.class,\n+                () -> instance.computeIfAbsent(0, i -> null));\n+    }\n+\n+    @Test\n+    void indexes() {\n+        assertThrows(IndexOutOfBoundsException.class,\n+                () -> instance.computeIfAbsent(-1, intIdentity()));\n+        assertThrows(IndexOutOfBoundsException.class,\n+                () -> instance.computeIfAbsent(LENGTH, intIdentity()));\n+    }\n+\n+    @Test\n+    void get() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            Integer val = instance.computeIfAbsent(i, intIdentity());\n+            assertEquals(i, instance.getOrNull(i));\n+        }\n+\n+    }\n+\n+    private static IntFunction<Integer> intIdentity() {\n+        return i -> i;\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/util\/LazyReferenceArray\/BasicLazyReferenceArrayTest.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -55,1 +55,1 @@\n-            .map(h -> h * 3600)\n+            .map(h -> h * 3_600)\n@@ -57,1 +57,1 @@\n-            .flatMap(s -> IntStream.iterate(s, l -> l + 3600 \/ 4).limit(4))\n+            .flatMap(s -> IntStream.iterate(s, l -> l + 3_600 \/ 4).limit(4 + 1))\n@@ -60,0 +60,1 @@\n+            .sorted()\n@@ -62,0 +63,8 @@\n+    @Setup\n+    public void setup() {\n+        for (int s : CACHED_SECONDS) {\n+            ZoneOffset zo = ZoneOffset.ofTotalSeconds(s);\n+            System.out.println(zo.getId() + \" = \" + zo.getTotalSeconds());\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/ZoneOffsetBench.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}