{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n@@ -137,5 +138,0 @@\n-    \/** Cache of time-zone offset by offset in seconds. *\/\n-    private static final ConcurrentMap<Integer, ZoneOffset> SECONDS_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n-    \/** Cache of time-zone offset by ID. *\/\n-    private static final ConcurrentMap<String, ZoneOffset> ID_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n-\n@@ -146,0 +142,8 @@\n+\n+    \/\/ Max slot number for either direction - or +\n+    private static final int MAX_SECONDS_CACHE_SLOT = MAX_SECONDS \/ (15 * SECONDS_PER_MINUTE);\n+\n+    \/** Cache of time-zone offset by offset in seconds [-18h, +18h] for each even quarter of an hour. *\/\n+    private static final AtomicReferenceArray<ZoneOffset> SECONDS_CACHE = new AtomicReferenceArray<>(MAX_SECONDS_CACHE_SLOT * 2 + 1);\n+    \/** Cache of time-zone offset by ID. *\/\n+    private static final ConcurrentMap<String, ZoneOffset> ID_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n@@ -427,5 +431,9 @@\n-            return SECONDS_CACHE.computeIfAbsent(totalSeconds, totalSecs -> {\n-                ZoneOffset result = new ZoneOffset(totalSecs);\n-                ID_CACHE.putIfAbsent(result.getId(), result);\n-                return result;\n-            });\n+            int slot = cacheSlot(totalSeconds);\n+            ZoneOffset cached = SECONDS_CACHE.get(slot);\n+            if (cached != null)\n+                return cached;\n+            \/\/ There is no guarantee we might create several instances for the same totalSeconds\n+            ZoneOffset newZoneOffset = new ZoneOffset(totalSeconds);\n+            SECONDS_CACHE.set(slot, newZoneOffset);\n+            ID_CACHE.putIfAbsent(newZoneOffset.getId(), newZoneOffset);\n+            return newZoneOffset;\n@@ -437,0 +445,4 @@\n+    private static int cacheSlot(int totalSeconds) {\n+        return MAX_SECONDS_CACHE_SLOT + totalSeconds \/ (15 * SECONDS_PER_MINUTE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+\n@@ -90,1 +91,0 @@\n-    private static final ZoneOffset OFFSET_M18 = ZoneOffset.ofHours(-18);\n@@ -101,3 +101,5 @@\n-            {make(OFFSET_PONE), OFFSET_PONE},\n-            {make(OFFSET_PTWO), OFFSET_PTWO},\n-            {make(OFFSET_M18), OFFSET_M18},\n+                {make(ZoneOffset.MIN), ZoneOffset.MIN},\n+                {make(ZoneOffset.UTC), ZoneOffset.UTC},\n+                {make(OFFSET_PONE), OFFSET_PONE},\n+                {make(OFFSET_PTWO), OFFSET_PTWO},\n+                {make(ZoneOffset.MAX), ZoneOffset.MAX},\n@@ -139,1 +141,3 @@\n-        assertEquals(test.isValidOffset(LDT, expectedOffset), true);\n+        if (expectedOffset == ZoneOffset.UTC)\n+            \/\/ The tests below are not made to work with ZoneOffset.UTC\n+            return;\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/zone\/TCKFixedZoneRules.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"}]}