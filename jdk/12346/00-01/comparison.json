{"files":[{"patch":"@@ -75,0 +75,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -88,1 +90,0 @@\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n@@ -147,1 +148,6 @@\n-    private static final AtomicReferenceArray<ZoneOffset> SECONDS_CACHE = new AtomicReferenceArray<>(MAX_SECONDS_CACHE_SLOT * 2 + 1);\n+    @Stable\n+    private static final ZoneOffset[] SECONDS_CACHE = new ZoneOffset[MAX_SECONDS_CACHE_SLOT * 2 + 1];\n+\n+    \/** Access to the SECONDS_CACHE must be made via VarHandle volatile access *\/\n+    private static final VarHandle SECONDS_CACHE_VH = MethodHandles.arrayElementVarHandle(ZoneOffset[].class);\n+\n@@ -432,8 +438,14 @@\n-            ZoneOffset cached = SECONDS_CACHE.get(slot);\n-            if (cached != null)\n-                return cached;\n-            \/\/ There is no guarantee we might create several instances for the same totalSeconds\n-            ZoneOffset newZoneOffset = new ZoneOffset(totalSeconds);\n-            SECONDS_CACHE.set(slot, newZoneOffset);\n-            ID_CACHE.putIfAbsent(newZoneOffset.getId(), newZoneOffset);\n-            return newZoneOffset;\n+            \/\/ Happens-before semantics are needed for double-checked locking\n+            \/\/ to prevent reading uninitialized ZoneOffset objects due to reordering.\n+            ZoneOffset cached = getAcquireSecondsCache(slot);\n+            if (cached == null) {\n+                synchronized (SECONDS_CACHE) {\n+                    cached = getAcquireSecondsCache(slot);\n+                    if (cached == null) {\n+                        cached = new ZoneOffset(totalSeconds);\n+                        setReleaseSecondsCache(slot, cached);\n+                        ID_CACHE.putIfAbsent(cached.getId(), cached);\n+                    }\n+                }\n+            }\n+            return cached;\n@@ -445,0 +457,20 @@\n+    static ZoneOffset getAcquireSecondsCache(int slot) {\n+        return (ZoneOffset) SECONDS_CACHE_VH.getAcquire(SECONDS_CACHE, slot);\n+    }\n+    static void setReleaseSecondsCache(int slot, ZoneOffset value) {\n+        SECONDS_CACHE_VH.setRelease(SECONDS_CACHE, slot, value);\n+    }\n+\n+    \/\/ Atomically sets a new value in SECONDS_CACHE if, and only if, the slot is null\n+    \/\/ returning if the slot was set.\n+\/*    boolean trySetSecondsPerMinute(int slot) {\n+        ZoneOffset cached = (ZoneOffset) SECONDS_CACHE_VH.get(SECONDS_CACHE, slot);\n+        if (cached != null)\n+            return cached;\n+        synchronized (SECONDS_CACHE) {\n+            ZoneOffset retry = SECONDS_CACHE.get(slot);\n+            if (retry != null)\n+                \/\/ Someone else beat us in the synchronization race\n+                return retry;\n+    }*\/\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":42,"deletions":10,"binary":false,"changes":52,"status":"modified"}]}