{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -137,5 +139,0 @@\n-    \/** Cache of time-zone offset by offset in seconds. *\/\n-    private static final ConcurrentMap<Integer, ZoneOffset> SECONDS_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n-    \/** Cache of time-zone offset by ID. *\/\n-    private static final ConcurrentMap<String, ZoneOffset> ID_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n-\n@@ -146,0 +143,13 @@\n+\n+    \/\/ Max slot number for either direction - or +\n+    private static final int MAX_SECONDS_CACHE_SLOT = MAX_SECONDS \/ (15 * SECONDS_PER_MINUTE);\n+\n+    \/** Cache of time-zone offset by offset in seconds [-18h, +18h] for each even quarter of an hour. *\/\n+    @Stable\n+    private static final ZoneOffset[] SECONDS_CACHE = new ZoneOffset[MAX_SECONDS_CACHE_SLOT * 2 + 1];\n+\n+    \/** Access to the SECONDS_CACHE must be made via VarHandle volatile access *\/\n+    private static final VarHandle SECONDS_CACHE_VH = MethodHandles.arrayElementVarHandle(ZoneOffset[].class);\n+\n+    \/** Cache of time-zone offset by ID. *\/\n+    private static final ConcurrentMap<String, ZoneOffset> ID_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n@@ -427,5 +437,15 @@\n-            return SECONDS_CACHE.computeIfAbsent(totalSeconds, totalSecs -> {\n-                ZoneOffset result = new ZoneOffset(totalSecs);\n-                ID_CACHE.putIfAbsent(result.getId(), result);\n-                return result;\n-            });\n+            int slot = cacheSlot(totalSeconds);\n+            \/\/ Happens-before semantics are needed for double-checked locking\n+            \/\/ to prevent reading uninitialized ZoneOffset objects due to reordering.\n+            ZoneOffset cached = getAcquireSecondsCache(slot);\n+            if (cached == null) {\n+                synchronized (SECONDS_CACHE) {\n+                    cached = getAcquireSecondsCache(slot);\n+                    if (cached == null) {\n+                        cached = new ZoneOffset(totalSeconds);\n+                        setReleaseSecondsCache(slot, cached);\n+                        ID_CACHE.putIfAbsent(cached.getId(), cached);\n+                    }\n+                }\n+            }\n+            return cached;\n@@ -437,0 +457,11 @@\n+    static ZoneOffset getAcquireSecondsCache(int slot) {\n+        return (ZoneOffset) SECONDS_CACHE_VH.getAcquire(SECONDS_CACHE, slot);\n+    }\n+    static void setReleaseSecondsCache(int slot, ZoneOffset value) {\n+        SECONDS_CACHE_VH.setRelease(SECONDS_CACHE, slot, value);\n+    }\n+\n+    private static int cacheSlot(int totalSeconds) {\n+        return MAX_SECONDS_CACHE_SLOT + totalSeconds \/ (15 * SECONDS_PER_MINUTE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":42,"deletions":11,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+\n@@ -90,1 +91,0 @@\n-    private static final ZoneOffset OFFSET_M18 = ZoneOffset.ofHours(-18);\n@@ -101,3 +101,5 @@\n-            {make(OFFSET_PONE), OFFSET_PONE},\n-            {make(OFFSET_PTWO), OFFSET_PTWO},\n-            {make(OFFSET_M18), OFFSET_M18},\n+                {make(ZoneOffset.MIN), ZoneOffset.MIN},\n+                {make(ZoneOffset.UTC), ZoneOffset.UTC},\n+                {make(OFFSET_PONE), OFFSET_PONE},\n+                {make(OFFSET_PTWO), OFFSET_PTWO},\n+                {make(ZoneOffset.MAX), ZoneOffset.MAX},\n@@ -139,1 +141,4 @@\n-        assertEquals(test.isValidOffset(LDT, expectedOffset), true);\n+        if (expectedOffset == ZoneOffset.UTC) {\n+            \/\/ The tests below are not made to work with ZoneOffset.UTC\n+            return;\n+        }\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/zone\/TCKFixedZoneRules.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.time;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.time.ZoneOffset;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Examine ZoneOffset.ofTotalSeconds operations\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class ZoneOffsetBench {\n+\n+    \/\/ An array with all the cached values [-18h, 18h]\n+    private static final int CACHED_SECONDS[] = IntStream.range(-18, 18)\n+            \/\/ Convert hour to seconds\n+            .map(h -> h * 3600)\n+            \/\/ Include each even quarter of an hour\n+            .flatMap(s -> IntStream.iterate(s, l -> l + 3600 \/ 4).limit(4))\n+            \/\/ There some overlaps so remove these\n+            .distinct()\n+            .toArray();\n+\n+    @Benchmark\n+    public void getFromCache(Blackhole bh) {\n+        for (int s : CACHED_SECONDS) {\n+            ZoneOffset zo = ZoneOffset.ofTotalSeconds(s);\n+            bh.consume(zo.getTotalSeconds());\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/ZoneOffsetBench.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}