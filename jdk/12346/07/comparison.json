{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+import java.util.function.IntFunction;\n@@ -89,0 +90,1 @@\n+import jdk.internal.util.LazyReferenceArray;\n@@ -137,5 +139,0 @@\n-    \/** Cache of time-zone offset by offset in seconds. *\/\n-    private static final ConcurrentMap<Integer, ZoneOffset> SECONDS_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n-    \/** Cache of time-zone offset by ID. *\/\n-    private static final ConcurrentMap<String, ZoneOffset> ID_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n-\n@@ -146,0 +143,9 @@\n+\n+    \/\/ Max slot number for either direction - or +\n+    private static final int MAX_SECONDS_CACHE_SLOT = MAX_SECONDS \/ (15 * SECONDS_PER_MINUTE);\n+\n+    \/** Cache of time-zone offset by offset in seconds [-18h, +18h] for each even quarter of an hour. *\/\n+    private static final LazyReferenceArray<ZoneOffset> SECONDS_CACHE = LazyReferenceArray.create(MAX_SECONDS_CACHE_SLOT * 2 + 1);\n+\n+    \/** Cache of time-zone offset by ID. *\/\n+    private static final ConcurrentMap<String, ZoneOffset> ID_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n@@ -423,0 +429,3 @@\n+        final class Holder {\n+            private static final IntFunction<ZoneOffset> ZONE_OFFSET_MAPPER = new ZoneOffsetMapper();\n+        }\n@@ -427,5 +436,2 @@\n-            return SECONDS_CACHE.computeIfAbsent(totalSeconds, totalSecs -> {\n-                ZoneOffset result = new ZoneOffset(totalSecs);\n-                ID_CACHE.putIfAbsent(result.getId(), result);\n-                return result;\n-            });\n+            int slot = secondsToSlot(totalSeconds);\n+            return SECONDS_CACHE.computeIfAbsent(slot, Holder.ZONE_OFFSET_MAPPER);\n@@ -437,0 +443,20 @@\n+    \/\/ Declare a concrete class rather than a lambda to improve startup time\n+    private static final class ZoneOffsetMapper implements IntFunction<ZoneOffset> {\n+\n+        @Override\n+        public ZoneOffset apply(int slot) {\n+            int totalSeconds = slotToSeconds(slot);\n+            ZoneOffset newValue = new ZoneOffset(totalSeconds);\n+            ID_CACHE.putIfAbsent(newValue.getId(), newValue);\n+            return newValue;\n+        }\n+    }\n+\n+    private static int secondsToSlot(int totalSeconds) {\n+        return MAX_SECONDS_CACHE_SLOT + totalSeconds \/ (15 * SECONDS_PER_MINUTE);\n+    }\n+\n+    private static int slotToSeconds(int slot) {\n+        return (slot - MAX_SECONDS_CACHE_SLOT) * (15 * SECONDS_PER_MINUTE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":37,"deletions":11,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * An array of object references in which elements may be updated\n+ * just once (lazily) and atomically. This contrasts to {@link AtomicReferenceArray } where\n+ * any number of updates can be done and where there is no simple way to atomically compute\n+ * a value (guaranteed to only be computed once) if it is missing.\n+ * <p>\n+ * This class is thread-safe.\n+ * <p>\n+ * The JVM may apply certain optimizations as it knows a component is updated just once\n+ * as described by {@link Stable}.\n+ *\n+ * @param <E> The type of elements held in this array\n+ *\/\n+public final class LazyReferenceArray<E> {\n+\n+    private static final VarHandle ARRAY_VH = MethodHandles.arrayElementVarHandle(Object[].class);\n+\n+    @Stable\n+    private final Object[] array;\n+\n+    \/**\n+     * Creates a new AtomicReferenceArray of the given length, with all\n+     * elements initially null.\n+     *\n+     * @param length the length of the array\n+     *\/\n+    private LazyReferenceArray(int length) {\n+        this.array = new Object[length];\n+    }\n+\n+    \/**\n+     * {@return the length of the array}.\n+     *\/\n+    public int length() {\n+        return array.length;\n+    }\n+\n+    \/**\n+     * {@return the element at index {@code i} or {@code null} if\n+     * no such element exists }\n+     *\n+     * @param index the element index\n+     * @throws IndexOutOfBoundsException if {@code index < 0 or index >= length() }\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public E getOrNull(int index) {\n+        return getAcquire(index);\n+    }\n+\n+    \/**\n+     * {@return the element at index {@code i} or, if no such element exists, throws\n+     * a NoSuchElementException}.\n+     *\n+     * @param index the element index\n+     * @throws NoSuchElementException    if no such element exists at the provided {@code index}\n+     * @throws IndexOutOfBoundsException if {@code index < 0 or index >= length() }\n+     *\/\n+    public E getOrThrow(int index) {\n+        E value = getOrNull(index);\n+        if (value == null) {\n+            throw new NoSuchElementException(\"No element at \" + index);\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * If the specified index is not already associated with a value, atomically attempts\n+     * to compute its value using the given mapping function and enters it into this\n+     * array.\n+     *\n+     * <p>If the mapping function returns {@code null}, an exception is thrown.\n+     * If the mapping function itself throws an (unchecked) exception, the\n+     * exception is rethrown, and no mapping is recorded.  The most\n+     * common usage is to construct a new object serving as an initial\n+     * mapped value or memoized result, as in:\n+     *\n+     * <pre> {@code\n+     * array.computeIfAbsent(index, i -> new Value(f(i)));\n+     * }<\/pre>\n+     *\n+     * @param index to use as array index\n+     * @param mappingFunction to apply if no previous value exists\n+     * @return the element at the provided index (pre-existing or newly computed)\n+     * @throws IndexOutOfBoundsException if {@code index < 0 or index >= length() }.\n+     * @throws NullPointerException      if the provided {@code mappingFunction} is {@code null} or\n+     *                                   the provided {@code mappingFunction} returns {@code null}.\n+     *\/\n+    public E computeIfAbsent(int index,\n+                             IntFunction<? extends E> mappingFunction) {\n+        Objects.checkIndex(index, array.length);\n+        Objects.requireNonNull(mappingFunction);\n+\n+        E value = getAcquire(index);\n+        if (value == null) {\n+            synchronized (array) {\n+                value = getAcquire(index);\n+                if (value == null) {\n+                    value = Objects.requireNonNull(\n+                            mappingFunction.apply(index));\n+                    setRelease(index, value);\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+    \/\/ Use acquire\/release to ensure happens-before so that newly\n+    \/\/ constructed elements are always observed correctly\n+    private E getAcquire(int index) {\n+        return (E) ARRAY_VH.getAcquire(array, index);\n+    }\n+\n+    void setRelease(int slot, Object value) {\n+        ARRAY_VH.setRelease(array, slot, value);\n+    }\n+\n+    \/**\n+     * {@return a new AtomicReferenceArray of the given length, with all\n+     * elements initially null}.\n+     *\n+     * @param length the length of the array\n+     * @throws IllegalArgumentException if the provided {@code length} is negative.\n+     *\/\n+    public static <E> LazyReferenceArray<E> create(int length) {\n+        if (length < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return new LazyReferenceArray<>(length);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/LazyReferenceArray.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+\n@@ -90,1 +91,0 @@\n-    private static final ZoneOffset OFFSET_M18 = ZoneOffset.ofHours(-18);\n@@ -101,3 +101,5 @@\n-            {make(OFFSET_PONE), OFFSET_PONE},\n-            {make(OFFSET_PTWO), OFFSET_PTWO},\n-            {make(OFFSET_M18), OFFSET_M18},\n+                {make(ZoneOffset.MIN), ZoneOffset.MIN},\n+                {make(ZoneOffset.UTC), ZoneOffset.UTC},\n+                {make(OFFSET_PONE), OFFSET_PONE},\n+                {make(OFFSET_PTWO), OFFSET_PTWO},\n+                {make(ZoneOffset.MAX), ZoneOffset.MAX},\n@@ -139,1 +141,4 @@\n-        assertEquals(test.isValidOffset(LDT, expectedOffset), true);\n+        if (expectedOffset == ZoneOffset.UTC) {\n+            \/\/ The tests below are not made to work with ZoneOffset.UTC\n+            return;\n+        }\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/zone\/TCKFixedZoneRules.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Verify basic LazyReferenceArray operations\n+ * @run junit BasicLazyReferenceArrayTest\n+ *\/\n+\n+import jdk.internal.util.LazyReferenceArray;\n+import org.junit.jupiter.api.*;\n+\n+import java.util.NoSuchElementException;\n+import java.util.function.IntFunction;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class BasicLazyReferenceArrayTest {\n+\n+    private static final int LENGTH = 10;\n+\n+    LazyReferenceArray<Integer> instance;\n+\n+    @BeforeEach\n+    void setup() {\n+        instance = LazyReferenceArray.create(LENGTH);\n+    }\n+\n+    @Test\n+    void length() {\n+        assertEquals(LENGTH, instance.length());\n+    }\n+\n+    @Test\n+    void emptyGetOrNull() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            assertNull(instance.getOrNull(i));\n+        }\n+    }\n+\n+    @Test\n+    void emptyGetOrThrow() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            final int val = i;\n+            assertThrows(NoSuchElementException.class,\n+                    () -> instance.getOrThrow(val));\n+        }\n+    }\n+\n+    @Test\n+    void compute() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            Integer val = instance.computeIfAbsent(i, intIdentity());\n+            assertEquals(i, val);\n+        }\n+    }\n+\n+    @Test\n+    void nulls() {\n+        \/\/ Mapper is null\n+        assertThrows(NullPointerException.class,\n+                () -> instance.computeIfAbsent(0, null));\n+        \/\/ Mapper returns null\n+        assertThrows(NullPointerException.class,\n+                () -> instance.computeIfAbsent(0, i -> null));\n+    }\n+\n+    @Test\n+    void indexes() {\n+        assertThrows(IndexOutOfBoundsException.class,\n+                () -> instance.computeIfAbsent(-1, intIdentity()));\n+        assertThrows(IndexOutOfBoundsException.class,\n+                () -> instance.computeIfAbsent(LENGTH, intIdentity()));\n+    }\n+\n+    @Test\n+    void get() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            Integer val = instance.computeIfAbsent(i, intIdentity());\n+            assertEquals(i, instance.getOrNull(i));\n+        }\n+\n+    }\n+\n+    private static IntFunction<Integer> intIdentity() {\n+        return i -> i;\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/util\/LazyReferenceArray\/BasicLazyReferenceArrayTest.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.time;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.time.ZoneOffset;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Examine ZoneOffset.ofTotalSeconds operations\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class ZoneOffsetBench {\n+\n+    \/\/ An array with all the cached values [-18h, 18h]\n+    private static final int CACHED_SECONDS[] = IntStream.range(-18, 18)\n+            \/\/ Convert hour to seconds\n+            .map(h -> h * 3_600)\n+            \/\/ Include each even quarter of an hour\n+            .flatMap(s -> IntStream.iterate(s, l -> l + 3_600 \/ 4).limit(4 + 1))\n+            \/\/ There some overlaps so remove these\n+            .distinct()\n+            .sorted()\n+            .toArray();\n+\n+    @Benchmark\n+    public void getFromCache(Blackhole bh) {\n+        for (int s : CACHED_SECONDS) {\n+            ZoneOffset zo = ZoneOffset.ofTotalSeconds(s);\n+            bh.consume(zo.getTotalSeconds());\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/ZoneOffsetBench.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}