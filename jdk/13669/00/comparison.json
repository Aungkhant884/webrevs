{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import static sun.security.ssl.SSLExtension.SH_PRE_SHARED_KEY;\n@@ -345,0 +346,3 @@\n+                    \/\/ the server is disallowing this session resumption,\n+                    \/\/ so don't include the pre-shared key in the ServerHello handshake message\n+                    shc.handshakeExtensions.remove(SH_PRE_SHARED_KEY);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerNameExtension.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIMatcher;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.StandardConstants;\n+\n+\/*\n+ * @test\n+ * @bug 8301686\n+ * @summary verifies that if the server rejects session resumption due to SNI mismatch,\n+ *          during TLS handshake, then the subsequent communication between the server and the\n+ *          client happens correctly without any errors\n+ * @run main\/othervm -Djavax.net.ssl.keyStore=${test.src}\/..\/etc\/keystore\n+ *                   -Djavax.net.ssl.keyStorePassword=passphrase\n+ *                   -Djavax.net.ssl.trustStore=${test.src}\/..\/etc\/truststore\n+ *                   -Djavax.net.ssl.trustStorePassword=passphrase\n+ *                   -Djavax.net.debug=all\n+ *                   ServerNameRejectedTLSSessionResumption\n+ *\/\n+public class ServerNameRejectedTLSSessionResumption {\n+\n+    private static final String CLIENT_REQUESTED_SNI = \"client.local\";\n+    \/\/ dummy host, no connection is attempted in this test\n+    private static final String PEER_HOST = \"foobar\";\n+    \/\/ dummy port, no connection is attempted in this test\n+    private static final int PEER_PORT = 12345;\n+\n+    public static void main(final String[] args) throws Exception {\n+        final SSLContext sslContext = SSLContext.getDefault();\n+        \/\/ create client and server SSLEngine(s) using the same SSLContext\n+        final SSLEngine clientEngine = createClientSSLEngine(sslContext);\n+        \/\/ use a SNIMatcher on the server's SSLEngine which accepts the SNI name presented\n+        \/\/ by the client SSLEngine\n+        final SSLEngine serverEngine = createServerSSLEngine(sslContext,\n+                new TestSNIMatcher(CLIENT_REQUESTED_SNI));\n+        \/\/ establish communication, which involves TLS handshake, between the client\n+        \/\/ and server engines. this communication expected to be successful.\n+        communicate(clientEngine, serverEngine);\n+        \/\/ now that the communication has been successful, we expect the SSLContext's (internal)\n+        \/\/ cache to have created and cached a SSLSession against the peer host:port\n+\n+        \/\/ now create the SSLEngine(s) again with the same SSLContext instance as before,\n+        \/\/ so that the SSLContext instance attempts to reuse the cached SSLSession against the\n+        \/\/ peer host:port\n+        final SSLEngine secondClientEngine = createClientSSLEngine(sslContext);\n+        \/\/ the newly created SSLEngine for the server will not use any SNIMatcher so as to reject\n+        \/\/ the session resumption (of the cached SSLSession)\n+        final SSLEngine secondServerEngine = createServerSSLEngine(sslContext, null);\n+        \/\/ attempt communication, which again involves TLS handshake since these are\n+        \/\/ new engine instances. The session resumption should be rejected and a fresh session\n+        \/\/ should get created and communication should succeed without any errors\n+        communicate(secondClientEngine, secondServerEngine);\n+    }\n+\n+    private static void communicate(final SSLEngine clientEngine,\n+                                    final SSLEngine serverEngine) throws Exception {\n+\n+        final ByteBuffer msgFromClient = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+        final ByteBuffer msgFromServer = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+        final ByteBuffer clientBuffer = ByteBuffer.allocate(1 << 15);\n+        final ByteBuffer serverBuffer = ByteBuffer.allocate(1 << 15);\n+        \/*\n+         * For data transport, this test uses local ByteBuffers\n+         *\/\n+        final ByteBuffer clientToServerTransport = ByteBuffer.allocateDirect(1 << 16);\n+        final ByteBuffer serverToClientTransport = ByteBuffer.allocateDirect(1 << 16);\n+        boolean isClientToServer = true;\n+        while (true) {\n+            if (isClientToServer) {\n+                \/\/ send client's message over the transport, will initiate a TLS handshake if\n+                \/\/ necessary\n+                SSLEngineResult result = clientEngine.wrap(msgFromClient, clientToServerTransport);\n+                \/\/ run any delegated tasks\n+                final HandshakeStatus hsStatus = checkAndRunTasks(clientEngine, result.getHandshakeStatus());\n+                clientToServerTransport.flip(); \/\/ will now contain the network data from client to server\n+\n+                \/\/ read from the client generated network data into server's buffer\n+                result = serverEngine.unwrap(clientToServerTransport, serverBuffer);\n+                checkAndRunTasks(serverEngine, result.getHandshakeStatus());\n+                clientToServerTransport.compact();\n+\n+                if (hsStatus == HandshakeStatus.NEED_UNWRAP) {\n+                    isClientToServer = false;\n+                } else if (hsStatus == HandshakeStatus.FINISHED) {\n+                    break;\n+                } else if (hsStatus != HandshakeStatus.NEED_WRAP) {\n+                    throw new Exception(\"Unexpected handshake result \" + result);\n+                }\n+            } else {\n+                \/\/ send server's message over the transport\n+                SSLEngineResult result = serverEngine.wrap(msgFromServer, serverToClientTransport);\n+                \/\/ run any delegated tasks on the server side\n+                final HandshakeStatus hsStatus = checkAndRunTasks(serverEngine, result.getHandshakeStatus());\n+                serverToClientTransport.flip(); \/\/ will now contain the network data from server to client\n+\n+                \/\/ read from the server generated network data into client's buffer\n+                result = clientEngine.unwrap(serverToClientTransport, clientBuffer);\n+                \/\/ run any delegated tasks on the client side\n+                checkAndRunTasks(clientEngine, result.getHandshakeStatus());\n+                serverToClientTransport.compact();\n+\n+                if (hsStatus == HandshakeStatus.NEED_UNWRAP) {\n+                    isClientToServer = true;\n+                } else if (hsStatus == HandshakeStatus.FINISHED) {\n+                    break;\n+                } else if (hsStatus != HandshakeStatus.NEED_WRAP) {\n+                    throw new Exception(\"Unexpected handshake result \" + result);\n+                }\n+            }\n+        }\n+        serverEngine.wrap(msgFromServer, serverToClientTransport);\n+        serverToClientTransport.flip();\n+        clientEngine.unwrap(serverToClientTransport, clientBuffer);\n+        serverToClientTransport.compact();\n+    }\n+\n+    private static SSLEngine createServerSSLEngine(final SSLContext sslContext,\n+                                                   final SNIMatcher sniMatcher) {\n+        final SSLEngine serverEngine = sslContext.createSSLEngine();\n+        serverEngine.setUseClientMode(false);\n+        if (sniMatcher != null) {\n+            final SSLParameters sslParameters = serverEngine.getSSLParameters(); \/\/ returns a copy\n+            sslParameters.setSNIMatchers(List.of(sniMatcher));\n+            serverEngine.setSSLParameters(sslParameters); \/\/ use the updated params\n+        }\n+        return serverEngine;\n+    }\n+\n+    private static SSLEngine createClientSSLEngine(final SSLContext sslContext) {\n+        final SSLEngine clientEngine = sslContext.createSSLEngine(PEER_HOST, PEER_PORT);\n+        clientEngine.setUseClientMode(true);\n+        final SSLParameters params = clientEngine.getSSLParameters(); \/\/ returns a copy\n+        \/\/ setup SNI name that will be used by the client during TLS handshake\n+        params.setServerNames(List.of(new SNIHostName(CLIENT_REQUESTED_SNI)));\n+        clientEngine.setSSLParameters(params); \/\/ use the updated params\n+        return clientEngine;\n+    }\n+\n+    private static HandshakeStatus checkAndRunTasks(final SSLEngine engine,\n+                                                    final HandshakeStatus handshakeStatus) {\n+        if (handshakeStatus != HandshakeStatus.NEED_TASK) {\n+            return handshakeStatus;\n+        }\n+        Runnable runnable;\n+        while ((runnable = engine.getDelegatedTask()) != null) {\n+            System.out.println(\"Running task \" + runnable);\n+            runnable.run();\n+        }\n+        return engine.getHandshakeStatus();\n+    }\n+\n+    private static final class TestSNIMatcher extends SNIMatcher {\n+\n+        private final String recognizedSNIServerName;\n+\n+        private TestSNIMatcher(final String recognizedSNIServerName) {\n+            super(StandardConstants.SNI_HOST_NAME);\n+            this.recognizedSNIServerName = recognizedSNIServerName;\n+        }\n+\n+        @Override\n+        public boolean matches(final SNIServerName clientRequestedSNI) {\n+            Objects.requireNonNull(clientRequestedSNI);\n+            System.out.println(\"Attempting SNI match against client request SNI name: \"\n+                    + clientRequestedSNI + \" against server recognized SNI name \"\n+                    + recognizedSNIServerName);\n+            if (!SNIHostName.class.isInstance(clientRequestedSNI)) {\n+                System.out.println(\"SNI match failed - client request SNI isn't a SNIHostName\");\n+                \/\/ we only support SNIHostName type\n+                return false;\n+            }\n+            final String requestedName = ((SNIHostName) clientRequestedSNI).getAsciiName();\n+            final boolean matches = recognizedSNIServerName.equals(requestedName);\n+            System.out.println(\"SNI match \" + (matches ? \"passed\" : \"failed\"));\n+            return matches;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/ServerNameRejectedTLSSessionResumption.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}