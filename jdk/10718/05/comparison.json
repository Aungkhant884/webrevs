{"files":[{"patch":"@@ -2715,0 +2715,38 @@\n+\/\/ Cache Management Operations\n+#define INSN(NAME, funct)                                                                    \\\n+  void NAME(Register Rs1) {                                                                  \\\n+    unsigned insn = 0;                                                                       \\\n+    patch((address)&insn, 6,  0, 0b0001111);                                                 \\\n+    patch((address)&insn, 14, 12, 0b010);                                                    \\\n+    patch_reg((address)&insn, 15, Rs1);                                                      \\\n+    patch((address)&insn, 31, 20, funct);                                                    \\\n+    emit(insn);                                                                              \\\n+  }\n+\n+  INSN(cbo_inval, 0b0000000000000);\n+  INSN(cbo_clean, 0b0000000000001);\n+  INSN(cbo_flush, 0b0000000000010);\n+  INSN(cbo_zero,  0b0000000001000);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct)                                                                    \\\n+  void NAME(Register Rs1, int32_t offset) {                                                  \\\n+    guarantee((offset & 0x1f) == 0, \"offset lowest 5 bits must be zero\");                    \\\n+    int32_t upperOffset = offset >> 5;                                                       \\\n+    unsigned insn = 0;                                                                       \\\n+    patch((address)&insn, 6,  0, 0b0010011);                                                 \\\n+    patch((address)&insn, 14, 12, 0b110);                                                    \\\n+    patch_reg((address)&insn, 15, Rs1);                                                      \\\n+    patch((address)&insn, 24, 20, funct);                                                    \\\n+    upperOffset &= 0x7f;                                                                     \\\n+    patch((address)&insn, 31, 25, upperOffset);                                              \\\n+    emit(insn);                                                                              \\\n+  }\n+\n+  INSN(prefetch_i, 0b0000000000000);\n+  INSN(prefetch_r, 0b0000000000001);\n+  INSN(prefetch_w, 0b0000000000010);\n+\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+#define DEFAULT_CACHE_LINE_SIZE 64\n+\n","filename":"src\/hotspot\/cpu\/riscv\/globalDefinitions_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+  product(bool, UseBlockZeroing, false,                                          \\\n+          \"Use Zicboz for block zeroing\")                                        \\\n@@ -88,0 +90,3 @@\n+  product(intx, CacheLineSize, DEFAULT_CACHE_LINE_SIZE,                          \\\n+          \"Size in bytes of a CPU cache line\")                                   \\\n+          range(wordSize, max_jint)                                          \\\n@@ -98,0 +103,3 @@\n+  product(bool, UseZicbom, false, EXPERIMENTAL, \"Use Zicbom instructions\")       \\\n+  product(bool, UseZicbop, false, EXPERIMENTAL, \"Use Zicbop instructions\")       \\\n+  product(bool, UseZicboz, false, EXPERIMENTAL, \"Use Zicboz instructions\")       \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4106,0 +4106,38 @@\n+\/\/ Zero blocks of memory by using CBO.ZERO.\n+\/\/\n+\/\/ Aligns the base address first sufficiently for CBO.ZERO, then uses\n+\/\/ CBO.ZERO repeatedly for every full block.  cnt is the size to be\n+\/\/ zeroed in HeapWords.  Returns the count of words left to be zeroed\n+\/\/ in cnt.\n+\/\/\n+\/\/ NOTE: This is intended to be used in the zero_blocks() stub.  If\n+\/\/ you want to use it elsewhere, note that cnt must be >= CacheLineSize.\n+void MacroAssembler::zero_dcache_blocks(Register base, Register cnt, Register tmp1, Register tmp2, Register tmp3) {\n+  Label initial_table_end, loop_cbo_zero;\n+\n+  \/\/ Align base with cache line size.\n+  neg(tmp1, base);\n+  andi(tmp1, tmp1, CacheLineSize - 1);\n+\n+  \/\/ tmp1: the number of bytes to be filled to align the base with cache line size.\n+  add(base, base, tmp1);\n+  srai(tmp2, tmp1, 3);\n+  sub(cnt, cnt, tmp2);\n+  add(tmp3, zr, zr);\n+  movptr(tmp3, initial_table_end);\n+  srli(tmp2, tmp1, 1);\n+  sub(tmp2, tmp3, tmp2);\n+  j(tmp2);\n+  for (int i = -CacheLineSize + 8; i < 0; i += 8) {\n+    sd(zr, Address(base, i));\n+  }\n+  bind(initial_table_end);\n+\n+  li(tmp1, CacheLineSize >> 3);\n+  bind(loop_cbo_zero);\n+  cbo_zero(base);\n+  sub(cnt, cnt, tmp1);\n+  add(base, base, CacheLineSize);\n+  bge(cnt, tmp1, loop_cbo_zero);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -627,0 +627,4 @@\n+  void movptr(Register Rd, Label &L) {\n+    wrap_label(Rd, L, (MacroAssembler::jal_jalr_insn)&MacroAssembler::movptr);\n+  }\n+\n@@ -1100,0 +1104,1 @@\n+  void zero_dcache_blocks(Register base, Register cnt, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -668,0 +668,5 @@\n+\/\/ Class for 64 bit register r7\n+reg_class r7_reg(\n+    R7, R7_H\n+);\n+\n@@ -730,0 +735,4 @@\n+reg_class r31_reg(\n+    R31, R31_H\n+);\n+\n@@ -3270,0 +3279,10 @@\n+operand iRegP_R7()\n+%{\n+  constraint(ALLOC_IN_RC(r7_reg));\n+  match(RegP);\n+  match(iRegPNoSp);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -3358,0 +3377,22 @@\n+\/\/ Pointer 64 bit Register R30 only\n+operand iRegP_R30()\n+%{\n+  constraint(ALLOC_IN_RC(r30_reg));\n+  match(RegP);\n+  match(iRegPNoSp);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Pointer 64 bit Register R31 only\n+operand iRegP_R31()\n+%{\n+  constraint(ALLOC_IN_RC(r31_reg));\n+  match(RegP);\n+  match(iRegPNoSp);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -10287,1 +10328,2 @@\n-instruct clearArray_reg_reg(iRegL_R29 cnt, iRegP_R28 base, Universe dummy)\n+instruct clearArray_reg_reg(iRegL_R29 cnt, iRegP_R28 base, iRegP_R30 tmp1,\n+                            iRegP_R31 tmp2, iRegP_R7 tmp3, Universe dummy)\n@@ -10289,0 +10331,1 @@\n+  \/\/ temp registers must match the one used in StubGenerator::generate_zero_blocks()\n@@ -10291,1 +10334,1 @@\n-  effect(USE_KILL cnt, USE_KILL base);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -674,1 +674,1 @@\n-    const Register base = x28, cnt = x29;\n+    const Register base = x28, cnt = x29, tmp1 = x30, tmp2 = x31, tmp3 = x7;\n@@ -680,0 +680,11 @@\n+    if (UseBlockZeroing) {\n+      \/\/ Ensure count >= CacheLineSize so that it still deserves a cbo.zero\n+      \/\/ after alignment.\n+      Label small;\n+      int low_limit = MAX2(CacheLineSize, BlockZeroingLowLimit);\n+      __ li(t0, low_limit);\n+      __ blt(cnt, t0, small);\n+      __ zero_dcache_blocks(base, cnt, tmp1, tmp2, tmp3);\n+      __ bind(small);\n+    }\n+\n@@ -687,2 +698,1 @@\n-        __ sd(zr, Address(base, 0));\n-        __ add(base, base, 8);\n+        __ sd(zr, Address(base, i << 3));\n@@ -690,0 +700,1 @@\n+      __ add(base, base, MacroAssembler::zero_words_block_size << 3);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -47,0 +47,5 @@\n+  if (!FLAG_IS_DEFAULT(CacheLineSize) && !is_power_of_2(CacheLineSize)) {\n+    warning(\"CacheLineSize must be a power of 2\");\n+    FLAG_SET_DEFAULT(CacheLineSize, DEFAULT_CACHE_LINE_SIZE);\n+  }\n+\n@@ -130,0 +135,12 @@\n+  if (UseZicboz) {\n+    if (FLAG_IS_DEFAULT(UseBlockZeroing)) {\n+      FLAG_SET_DEFAULT(UseBlockZeroing, true);\n+    }\n+    if (FLAG_IS_DEFAULT(BlockZeroingLowLimit)) {\n+      FLAG_SET_DEFAULT(BlockZeroingLowLimit, CacheLineSize);\n+    }\n+  } else if (UseBlockZeroing) {\n+    warning(\"Zicboz is not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseBlockZeroing, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}