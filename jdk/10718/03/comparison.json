{"files":[{"patch":"@@ -2715,0 +2715,38 @@\n+\/\/ Cache Management Operations\n+#define INSN(NAME, funct)                                                                    \\\n+  void NAME(Register Rs1) {                                                                  \\\n+    unsigned insn = 0;                                                                       \\\n+    patch((address)&insn, 6,  0, 0b0001111);                                                 \\\n+    patch((address)&insn, 14, 12, 0b010);                                                    \\\n+    patch_reg((address)&insn, 15, Rs1);                                                      \\\n+    patch((address)&insn, 31, 20, funct);                                                    \\\n+    emit(insn);                                                                              \\\n+  }\n+\n+  INSN(cbo_inval, 0b0000000000000);\n+  INSN(cbo_clean, 0b0000000000001);\n+  INSN(cbo_flush, 0b0000000000010);\n+  INSN(cbo_zero,  0b0000000001000);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct)                                                                    \\\n+  void NAME(Register Rs1, int32_t offset) {                                                  \\\n+    guarantee((offset & 0x1f) == 0, \"offset lowest 5 bits must be zero\");                    \\\n+    int32_t upperOffset = offset >> 5;                                                       \\\n+    unsigned insn = 0;                                                                       \\\n+    patch((address)&insn, 6,  0, 0b0010011);                                                 \\\n+    patch((address)&insn, 14, 12, 0b110);                                                    \\\n+    patch_reg((address)&insn, 15, Rs1);                                                      \\\n+    patch((address)&insn, 24, 20, funct);                                                    \\\n+    upperOffset &= 0x7f;                                                                     \\\n+    patch((address)&insn, 31, 25, upperOffset);                                              \\\n+    emit(insn);                                                                              \\\n+  }\n+\n+  INSN(prefetch_i, 0b0000000000000);\n+  INSN(prefetch_r, 0b0000000000001);\n+  INSN(prefetch_w, 0b0000000000010);\n+\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+#define DEFAULT_CACHE_LINE_SIZE 64\n+\n","filename":"src\/hotspot\/cpu\/riscv\/globalDefinitions_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+  product(bool, UseBlockZeroing, false,                                          \\\n+          \"Use Zicboz for block zeroing\")                                        \\\n@@ -88,0 +90,3 @@\n+  product(intx, CacheLineSize, DEFAULT_CACHE_LINE_SIZE,                          \\\n+          \"Size of a CPU cache line\")                                            \\\n+          range(1, max_jint)                                                     \\\n@@ -98,0 +103,3 @@\n+  product(bool, UseZicbom, false, EXPERIMENTAL, \"Use Zicbom instructions\")       \\\n+  product(bool, UseZicbop, false, EXPERIMENTAL, \"Use Zicbop instructions\")       \\\n+  product(bool, UseZicboz, false, EXPERIMENTAL, \"Use Zicboz instructions\")       \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4106,0 +4106,38 @@\n+\/\/ Zero blocks of memory by using CBO.ZERO.\n+\/\/\n+\/\/ Aligns the base address first sufficiently for CBO.ZERO, then uses\n+\/\/ CBO.ZERO repeatedly for every full block.  cnt is the size to be\n+\/\/ zeroed in HeapWords.  Returns the count of words left to be zeroed\n+\/\/ in cnt.\n+\/\/\n+\/\/ NOTE: This is intended to be used in the zero_blocks() stub.  If\n+\/\/ you want to use it elsewhere, note that cnt must be >= CacheLineSize.\n+void MacroAssembler::zero_dcache_blocks(Register base, Register cnt) {\n+  Label initial_table_end, loop_cbo_zero;\n+\n+  \/\/ Align base with cache line size.\n+  neg(t0, base);\n+  andi(t0, t0, CacheLineSize - 1);\n+\n+  \/\/ t0: the number of bytes to be filled to align the base with cache line size.\n+  add(base, base, t0);\n+  srai(t1, t0, 3);\n+  sub(cnt, cnt, t1);\n+  add(t2, zr, zr);\n+  movptr(t2, initial_table_end);\n+  srli(t1, t0, 1);\n+  sub(t1, t2, t1);\n+  j(t1);\n+  for (int i = -CacheLineSize + 8; i < 0; i += 8) {\n+    sd(zr, Address(base, i));\n+  }\n+  bind(initial_table_end);\n+\n+  li(t0, CacheLineSize >> 3);\n+  bind(loop_cbo_zero);\n+  cbo_zero(base);\n+  sub(cnt, cnt, t0);\n+  add(base, base, CacheLineSize);\n+  bge(cnt, t0, loop_cbo_zero);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -627,0 +627,4 @@\n+  void movptr(Register Rd, Label &L) {\n+    wrap_label(Rd, L, (MacroAssembler::jal_jalr_insn)&MacroAssembler::movptr);\n+  }\n+\n@@ -1100,0 +1104,1 @@\n+  void zero_dcache_blocks(Register base, Register cnt);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -680,0 +680,11 @@\n+    if (UseBlockZeroing) {\n+      \/\/ Ensure count >= CacheLineSize so that it still deserves a cbo.zero\n+      \/\/ after alignment.\n+      Label small;\n+      int low_limit = MAX2(CacheLineSize, BlockZeroingLowLimit);\n+      __ li(t0, low_limit);\n+      __ blt(cnt, t0, small);\n+      __ zero_dcache_blocks(base, cnt);\n+      __ bind(small);\n+    }\n+\n@@ -687,2 +698,1 @@\n-        __ sd(zr, Address(base, 0));\n-        __ add(base, base, 8);\n+        __ sd(zr, Address(base, i << 3));\n@@ -690,0 +700,1 @@\n+      __ add(base, base, MacroAssembler::zero_words_block_size << 3);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,0 +47,5 @@\n+  if (!FLAG_IS_DEFAULT(CacheLineSize) && !is_power_of_2(CacheLineSize)) {\n+    warning(\"CacheLineSize must be a power of 2\");\n+    FLAG_SET_DEFAULT(CacheLineSize, DEFAULT_CACHE_LINE_SIZE);\n+  }\n+\n@@ -130,0 +135,12 @@\n+  if (UseZicboz) {\n+    if (FLAG_IS_DEFAULT(UseBlockZeroing)) {\n+      FLAG_SET_DEFAULT(UseBlockZeroing, true);\n+    }\n+    if (FLAG_IS_DEFAULT(BlockZeroingLowLimit)) {\n+      FLAG_SET_DEFAULT(BlockZeroingLowLimit, CacheLineSize);\n+    }\n+  } else if (UseBlockZeroing) {\n+    warning(\"Zicboz is not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseBlockZeroing, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}