{"files":[{"patch":"@@ -3009,0 +3009,38 @@\n+\/\/ Cache Management Operations\n+#define INSN(NAME, funct)                                                         \\\n+  void NAME(Register Rs1) {                                                                  \\\n+    unsigned insn = 0;                                                                       \\\n+    patch((address)&insn, 6,  0, 0b0001111);                                                 \\\n+    patch((address)&insn, 14, 12, 0b010);                                                    \\\n+    patch_reg((address)&insn, 15, Rs1);                                                      \\\n+    patch((address)&insn, 31, 20, funct);                                                    \\\n+    emit(insn);                                                                              \\\n+  }\n+\n+  INSN(cbo_inval, 0b0000000000000);\n+  INSN(cbo_clean, 0b0000000000001);\n+  INSN(cbo_flush, 0b0000000000010);\n+  INSN(cbo_zero,  0b0000000001000);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct)                                                         \\\n+  void NAME(Register Rs1, int32_t offset) {                                                  \\\n+    guarantee((offset & 0x1f) == 0, \"offset lowest 5 bits must be zero\");                    \\\n+    int32_t upperOffset = offset >> 5;                                                       \\\n+    unsigned insn = 0;                                                                       \\\n+    patch((address)&insn, 6,  0, 0b0010011);                                                 \\\n+    patch((address)&insn, 14, 12, 0b110);                                                    \\\n+    patch_reg((address)&insn, 15, Rs1);                                                      \\\n+    patch((address)&insn, 24, 20, funct);                                                    \\\n+    upperOffset &= 0x7f;                                                                     \\\n+    patch((address)&insn, 31, 25, upperOffset);                                              \\\n+    emit(insn);                                                                              \\\n+  }\n+\n+  INSN(prefetch_i, 0b0000000000000);\n+  INSN(prefetch_r, 0b0000000000001);\n+  INSN(prefetch_w, 0b0000000000010);\n+\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+  product(bool, UseBlockZeroing, false,                                           \\\n+          \"Use Zicboz for block zeroing\")                                        \\\n@@ -98,0 +100,3 @@\n+  product(bool, UseZicbom, false, EXPERIMENTAL, \"Use Zicbom instructions\")       \\\n+  product(bool, UseZicbop, false, EXPERIMENTAL, \"Use Zicbop instructions\")       \\\n+  product(bool, UseZicboz, false, EXPERIMENTAL, \"Use Zicboz instructions\")       \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3747,0 +3747,38 @@\n+\/\/ Zero blocks of memory by using CBO.ZERO.\n+\/\/\n+\/\/ Aligns the base address first sufficiently for CBO.ZERO, then uses\n+\/\/ CBO.ZERO repeatedly for every full block.  cnt is the size to be\n+\/\/ zeroed in HeapWords.  Returns the count of words left to be zeroed\n+\/\/ in cnt.\n+\/\/\n+\/\/ NOTE: This is intended to be used in the zero_blocks() stub.  If\n+\/\/ you want to use it elsewhere, note that cnt must be >= 2*zva_length.\n+void MacroAssembler::zero_dcache_blocks(Register base, Register cnt) {\n+  Label initial_table_end, loop_cbo_zero;\n+\n+  \/\/ Align base with cache line size.\n+  neg(t0, base);\n+  andi(t0, t0, VM_Version::cache_line_size() - 1);\n+\n+  \/\/ t0: the number of bytes to be filled to align the base with cache line size.\n+  add(base, base, t0);\n+  srai(t1, t0, 3);\n+  sub(cnt, cnt, t1);\n+  add(t2, zr, zr);\n+  wrap_label(t2, initial_table_end, (Assembler::jal_jalr_insn)&MacroAssembler::movptr);\n+  srli(t1, t0, 1);\n+  sub(t1, t2, t1);\n+  j(t1);\n+  for (int i = -VM_Version::cache_line_size() + 8; i < 0; i += 8) {\n+    sd(zr, Address(base, i));\n+  }\n+  bind(initial_table_end);\n+\n+  li(t0, VM_Version::cache_line_size() >> 3);\n+  bind(loop_cbo_zero);\n+  cbo_zero(base);\n+  sub(cnt, cnt, t0);\n+  add(base, base, VM_Version::cache_line_size());\n+  bge(cnt, t0, loop_cbo_zero);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -787,0 +787,1 @@\n+  void zero_dcache_blocks(Register base, Register cnt);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -680,0 +680,11 @@\n+    if (UseBlockZeroing) {\n+      \/\/ Ensure count >= cache_line_size so that it still deserves a cbo.zero\n+      \/\/ after alignment.\n+      Label small;\n+      int low_limit = MAX2(VM_Version::cache_line_size(), (int)BlockZeroingLowLimit);\n+      __ li(t0, low_limit);\n+      __ blt(cnt, t0, small);\n+      __ zero_dcache_blocks(base, cnt);\n+      __ bind(small);\n+    }\n+\n@@ -687,2 +698,1 @@\n-        __ sd(zr, Address(base, 0));\n-        __ add(base, base, 8);\n+        __ sd(zr, Address(base, i << 3));\n@@ -690,0 +700,1 @@\n+      __ add(base, base, MacroAssembler::zero_words_block_size << 3);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+uint32_t VM_Version::_cache_line_size;\n@@ -130,0 +131,12 @@\n+  if (UseZicboz) {\n+    if (FLAG_IS_DEFAULT(UseBlockZeroing)) {\n+      FLAG_SET_DEFAULT(UseBlockZeroing, true);\n+    }\n+    if (FLAG_IS_DEFAULT(BlockZeroingLowLimit)) {\n+      FLAG_SET_DEFAULT(BlockZeroingLowLimit, 4 * VM_Version::cache_line_size());\n+    }\n+  } else if (UseBlockZeroing) {\n+    warning(\"Zicboz is not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseBlockZeroing, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  static uint32_t _cache_line_size;\n@@ -69,0 +70,2 @@\n+\n+  static int cache_line_size() { return _cache_line_size; }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -116,0 +116,2 @@\n+\n+  _cache_line_size = 64;\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}