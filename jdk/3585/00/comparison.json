{"files":[{"patch":"@@ -1447,1 +1447,1 @@\n-  _evacuation_failed(false),\n+  _num_regions_failed_evacuation(0),\n@@ -3090,2 +3090,10 @@\n-  G1ParRemoveSelfForwardPtrsTask rsfp_task(rdcqs);\n-  workers()->run_task(&rsfp_task);\n+  uint num_workers = MIN2(workers()->active_workers(), num_regions_failed_evacuation());\n+\n+  G1ParRemoveSelfForwardPtrsTask cl(rdcqs);\n+  log_debug(gc, ergo)(\"Running %s using %u workers for %u failed regions\",\n+                      cl.name(), num_workers, num_regions_failed_evacuation());\n+  workers()->run_task(&cl, num_workers);\n+\n+  assert(cl.num_failed_regions() == num_regions_failed_evacuation(),\n+         \"Removed regions %u inconsistent with expected %u\",\n+         cl.num_failed_regions(), num_regions_failed_evacuation());\n@@ -3104,4 +3112,0 @@\n-  if (!_evacuation_failed) {\n-    _evacuation_failed = true;\n-  }\n-\n@@ -3661,1 +3665,1 @@\n-  _evacuation_failed = false;\n+  _num_regions_failed_evacuation = false;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -854,2 +854,2 @@\n-  \/\/ True iff a evacuation has failed in the current collection.\n-  bool _evacuation_failed;\n+  \/\/ Number of regions evacuation failed in the current collection.\n+  volatile uint _num_regions_failed_evacuation;\n@@ -1140,1 +1140,3 @@\n-  bool evacuation_failed() { return _evacuation_failed; }\n+  inline bool evacuation_failed() const;\n+  inline uint num_regions_failed_evacuation() const;\n+  inline void region_failed_evacuation();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -191,0 +192,12 @@\n+bool G1CollectedHeap::evacuation_failed() const {\n+  return num_regions_failed_evacuation() > 0;\n+}\n+\n+uint G1CollectedHeap::num_regions_failed_evacuation() const {\n+  return Atomic::load(&_num_regions_failed_evacuation);\n+}\n+\n+void G1CollectedHeap::region_failed_evacuation() {\n+  Atomic::inc(&_num_regions_failed_evacuation, memory_order_relaxed);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -208,0 +208,2 @@\n+  uint volatile* _num_failed_regions;\n+\n@@ -209,1 +211,1 @@\n-  RemoveSelfForwardPtrHRClosure(G1RedirtyCardsQueueSet* rdcqs, uint worker_id) :\n+  RemoveSelfForwardPtrHRClosure(G1RedirtyCardsQueueSet* rdcqs, uint worker_id, uint volatile* num_failed_regions) :\n@@ -213,1 +215,2 @@\n-    _log_buffer_cl(&_rdc_local_qset) {\n+    _log_buffer_cl(&_rdc_local_qset),\n+    _num_failed_regions(num_failed_regions) {\n@@ -255,0 +258,2 @@\n+\n+      Atomic::inc(_num_failed_regions, memory_order_relaxed);\n@@ -264,1 +269,2 @@\n-  _hrclaimer(_g1h->workers()->active_workers()) { }\n+  _hrclaimer(_g1h->workers()->active_workers()),\n+  _num_failed_regions(0) { }\n@@ -267,1 +273,1 @@\n-  RemoveSelfForwardPtrHRClosure rsfp_cl(_rdcqs, worker_id);\n+  RemoveSelfForwardPtrHRClosure rsfp_cl(_rdcqs, worker_id, &_num_failed_regions);\n@@ -276,0 +282,4 @@\n+\n+uint G1ParRemoveSelfForwardPtrsTask::num_failed_regions() const {\n+  return Atomic::load(&_num_failed_regions);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+  uint volatile _num_failed_regions;\n+\n@@ -48,0 +50,2 @@\n+\n+  uint num_failed_regions() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -620,3 +620,3 @@\n-    if (!r->evacuation_failed()) {\n-      r->set_evacuation_failed(true);\n-     _g1h->hr_printer()->evac_failure(r);\n+    if (r->set_evacuation_failed()) {\n+      _g1h->region_failed_evacuation();\n+      _g1h->hr_printer()->evac_failure(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  set_evacuation_failed(false);\n+  reset_evacuation_failed();\n@@ -114,0 +114,1 @@\n+  _next_marked_bytes = 0;\n@@ -141,1 +142,1 @@\n-  _evacuation_failed = false;\n+  Atomic::store(&_evacuation_failed, false);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-  bool _evacuation_failed;\n+  volatile bool _evacuation_failed;\n@@ -500,1 +500,1 @@\n-  bool evacuation_failed() { return _evacuation_failed; }\n+  inline bool evacuation_failed() const;\n@@ -502,3 +502,3 @@\n-  \/\/ Sets the \"evacuation_failed\" property of the region.\n-  void set_evacuation_failed(bool b) {\n-    _evacuation_failed = b;\n+  \/\/ Sets the \"evacuation_failed\" property of the region, returning true if this\n+  \/\/ has been the first call, false otherwise.\n+  inline bool set_evacuation_failed();\n@@ -506,4 +506,1 @@\n-    if (b) {\n-      _next_marked_bytes = 0;\n-    }\n-  }\n+  inline void reset_evacuation_failed();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -454,0 +454,12 @@\n+inline bool HeapRegion::evacuation_failed() const {\n+  return Atomic::load(&_evacuation_failed);\n+}\n+\n+inline bool HeapRegion::set_evacuation_failed() {\n+  return !Atomic::load(&_evacuation_failed) && !Atomic::cmpxchg(&_evacuation_failed, false, true, memory_order_relaxed);\n+}\n+\n+inline void HeapRegion::reset_evacuation_failed() {\n+  Atomic::store(&_evacuation_failed, false);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}