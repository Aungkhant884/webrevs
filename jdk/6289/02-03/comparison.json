{"files":[{"patch":"@@ -1,203 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1BufferListFreeMemoryTask.hpp\"\n-#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1_globals.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n-#include \"heapRegionRemSet.hpp\"\n-#include \"ci\/ciUtilities.hpp\"\n-\n-constexpr const char* G1BufferListFreeMemoryTask::_state_names[];\n-\n-const char* G1BufferListFreeMemoryTask::get_state_name(State value) const {\n-  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n-}\n-\n-bool G1BufferListFreeMemoryTask::deadline_exceeded(jlong deadline) {\n-  return os::elapsed_counter() >= deadline;\n-}\n-\n-static size_t keep_size(size_t free, size_t used, double percent) {\n-  size_t to_keep = used * percent;\n-  return MIN2(free, to_keep);\n-}\n-\n-bool G1BufferListFreeMemoryTask::calculate_return_infos(jlong deadline) {\n-  \/\/ Ignore the deadline in this step as it is very short.\n-\n-  G1BufferListMemoryStats used = _total_used;\n-  G1BufferListMemoryStats free = G1BufferListFreePool<mtGCCardSet>::free_list_sizes();\n-\n-  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n-  for (uint i = 0; i < used.num_pools(); i++) {\n-    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n-                                         used._num_mem_sizes[i],\n-                                         G1RemSetFreeMemoryKeepExcessRatio);\n-    log_trace(gc, task)(\"Card Set Free Memory: Type %s: Free: %zu (%zu) \"\n-                        \"Used: %zu Keep: %zu\",\n-                        G1CardSetConfiguration::mem_object_type_name_str(i),\n-                        free._num_mem_sizes[i], free._num_buffers[i],\n-                        used._num_mem_sizes[i], return_to_vm_size);\n-\n-    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n-  }\n-\n-  G1BufferListFreePool<mtGCCardSet>::update_unlink_processors(_return_info);\n-  return false;\n-}\n-\n-bool G1BufferListFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n-  for (int i = 0; i < _return_info->length(); i++) {\n-    G1ReturnMemoryProcessor* info = _return_info->at(i);\n-    if (!info->finished_return_to_vm()) {\n-      if (info->return_to_vm(deadline)) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-bool G1BufferListFreeMemoryTask::return_memory_to_os(jlong deadline) {\n-  for (int i = 0; i < _return_info->length(); i++) {\n-    G1ReturnMemoryProcessor* info = _return_info->at(i);\n-    if (!info->finished_return_to_os()) {\n-      if (info->return_to_os(deadline)) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-bool G1BufferListFreeMemoryTask::cleanup_return_infos() {\n-  for (int i = 0; i < _return_info->length(); i++) {\n-     G1ReturnMemoryProcessor* info = _return_info->at(i);\n-     delete info;\n-  }\n-  delete _return_info;\n-\n-  _return_info = nullptr;\n-  return false;\n-}\n-\n-bool G1BufferListFreeMemoryTask::free_excess_card_set_memory() {\n-  jlong start = os::elapsed_counter();\n-  jlong end = start +\n-              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Step start %1.3f end %1.3f\",\n-                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n-\n-  State next_state;\n-\n-  do {\n-    switch (_state) {\n-      case State::CalculateUsed: {\n-        if (calculate_return_infos(end)) {\n-          next_state = _state;\n-          return true;\n-        }\n-        next_state = State::ReturnToVM;\n-        break;\n-      }\n-      case State::ReturnToVM: {\n-        if (return_memory_to_vm(end)) {\n-          next_state = _state;\n-          return true;\n-        }\n-        next_state = State::ReturnToOS;\n-        break;\n-      }\n-      case State::ReturnToOS: {\n-        if (return_memory_to_os(end)) {\n-          next_state = _state;\n-          return true;\n-        }\n-        next_state = State::Cleanup;\n-        break;\n-      }\n-      case State::Cleanup: {\n-        cleanup_return_infos();\n-        next_state = State::Inactive;\n-        break;\n-      }\n-      default:\n-        log_error(gc, task)(\"Should not try to free excess card set memory in %s state\", get_state_name(_state));\n-        ShouldNotReachHere();\n-        break;\n-    }\n-\n-    set_state(next_state);\n-  } while (_state != State::Inactive && !deadline_exceeded(end));\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Step took %1.3fms, done %s\",\n-                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n-                      bool_to_str(_state == State::CalculateUsed));\n-\n-  return is_active();\n-}\n-\n-void G1BufferListFreeMemoryTask::set_state(State new_state) {\n-  log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n-                      get_state_name(_state),\n-                      get_state_name(new_state));\n-  _state = new_state;\n-}\n-\n-bool G1BufferListFreeMemoryTask::is_active() const {\n-  return _state != State::Inactive;\n-}\n-\n-jlong G1BufferListFreeMemoryTask::reschedule_delay_ms() const {\n-  return G1RemSetFreeMemoryRescheduleDelayMillis;\n-}\n-\n-G1BufferListFreeMemoryTask::G1BufferListFreeMemoryTask(const char* name) :\n-  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n-\n-void G1BufferListFreeMemoryTask::execute() {\n-  SuspendibleThreadSetJoiner sts;\n-\n-  if (free_excess_card_set_memory()) {\n-    schedule(reschedule_delay_ms());\n-  }\n-}\n-\n-void G1BufferListFreeMemoryTask::notify_new_stats(G1BufferListMemoryStats* young_gen_stats,\n-                                                  G1BufferListMemoryStats* collection_set_candidate_stats) {\n-  assert_at_safepoint_on_vm_thread();\n-\n-  _total_used = *young_gen_stats;\n-  _total_used.add(*collection_set_candidate_stats);\n-\n-  if (!is_active()) {\n-    set_state(State::CalculateUsed);\n-    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BufferListFreeMemoryTask.cpp","additions":0,"deletions":203,"binary":false,"changes":203,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1BUFFERLISTFREEMEMORYTASK_HPP\n-#define SHARE_GC_G1_G1BUFFERLISTFREEMEMORYTASK_HPP\n-\n-#include \"gc\/g1\/g1ServiceThread.hpp\"\n-#include \"gc\/g1\/g1BufferListFreePool.hpp\"\n-#include \"gc\/g1\/g1CardSetMemory.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-\/\/ Task handling deallocation of free card set memory.\n-class G1BufferListFreeMemoryTask : public G1ServiceTask {\n-\n-  enum class State : uint {\n-    Inactive,\n-    CalculateUsed,\n-    ReturnToVM,\n-    ReturnToOS,\n-    Cleanup\n-  };\n-\n-  static constexpr const char* _state_names[] = { \"Invalid\",\n-                                                  \"CalculateUsed\",\n-                                                  \"ReturnToVM\",\n-                                                  \"ReturnToOS\",\n-                                                  \"Cleanup\" };\n-\n-  const char* get_state_name(State value) const;\n-\n-  State _state;\n-\n-  \/\/ Current total card set memory usage.\n-  G1BufferListMemoryStats _total_used;\n-\n-  typedef G1BufferListFreePool<mtGCCardSet>::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n-  typedef G1BufferListFreePool<mtGCCardSet>::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n-\n-  G1ReturnMemoryProcessorSet* _return_info;\n-\n-  \/\/ Returns whether the given deadline has passed.\n-  bool deadline_exceeded(jlong deadline);\n-\n-  \/\/ Methods for the tasks to be done. They all return true if that step has\n-  \/\/ completed.\n-  bool calculate_return_infos(jlong deadline);\n-  bool return_memory_to_vm(jlong deadline);\n-  bool return_memory_to_os(jlong deadline);\n-  bool cleanup_return_infos();\n-\n-  \/\/ Free excess card set memory, main method. Returns true if there is more work\n-  \/\/ to do.\n-  bool free_excess_card_set_memory();\n-\n-  void set_state(State new_state);\n-  \/\/ Returns whether we are currently processing a recent request.\n-  bool is_active() const;\n-\n-  \/\/ The delay used to reschedule this task if not all work has been completed.\n-  jlong reschedule_delay_ms() const;\n-\n-public:\n-  explicit G1BufferListFreeMemoryTask(const char* name);\n-\n-  void execute() override;\n-\n-  \/\/ Notify the task of new used remembered set memory statistics for the young\n-  \/\/ generation and the collection set candidate sets.\n-  void notify_new_stats(G1BufferListMemoryStats* young_gen_stats,\n-                        G1BufferListMemoryStats* collection_set_candidate_stats);\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1BUFFERLISTFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BufferListFreeMemoryTask.hpp","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,205 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/g1\/g1BufferListFreePool.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/formatBuffer.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n-G1BufferListMemoryStats::G1BufferListMemoryStats() {\n-  clear();\n-}\n-\n-void G1BufferListMemoryStats::clear() {\n-  for (uint i = 0; i < num_pools(); i++) {\n-    _num_mem_sizes[i] = 0;\n-    _num_buffers[i] = 0;\n-  }\n-}\n-\n-template<MEMFLAGS flag>\n-void G1BufferListFreePool<flag>::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n-  uint num_free_lists = _freelist_pool.num_free_lists();\n-\n-  for (uint i = 0; i < num_free_lists; i++) {\n-    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n-  }\n-}\n-\n-template<MEMFLAGS flag>\n-void G1BufferListFreePool<flag>::G1ReturnMemoryProcessor::visit_free_list(G1SegmentedArrayBufferList<flag>* source) {\n-  assert(_source == nullptr, \"already visited\");\n-  if (_return_to_vm_size > 0) {\n-    _source = source;\n-  } else {\n-    assert(_source == nullptr, \"must be\");\n-  }\n-  if (source->mem_size() > _return_to_vm_size) {\n-    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n-  } else {\n-    assert(_first == nullptr, \"must be\");\n-  }\n-  \/\/ Above we were racing with other threads getting the contents of the free list,\n-  \/\/ so while we might have been asked to return something to the OS initially,\n-  \/\/ the free list might be empty anyway. In this case just reset internal values\n-  \/\/ used for checking whether there is work available.\n-  if (_first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-}\n-\n-template<MEMFLAGS flag>\n-bool G1BufferListFreePool<flag>::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n-  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n-  assert(_first != nullptr, \"must have element to return\");\n-\n-  size_t keep_size = 0;\n-  size_t keep_num = 0;\n-\n-  G1SegmentedArrayBuffer<flag>* cur = _first;\n-  G1SegmentedArrayBuffer<flag>* last = nullptr;\n-\n-  while (cur != nullptr && _return_to_vm_size > 0) {\n-    size_t cur_size = cur->mem_size();\n-    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n-\n-    keep_size += cur_size;\n-    keep_num++;\n-\n-    last = cur;\n-    cur = cur->next();\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  assert(_first != nullptr, \"must be\");\n-  assert(last != nullptr, \"must be\");\n-\n-  last->set_next(nullptr);\n-\n-  \/\/ Wait for any in-progress pops to avoid ABA for them.\n-  GlobalCounter::write_synchronize();\n-  _source->bulk_add(*_first, *last, keep_num, keep_size);\n-  _first = cur;\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n-\n-  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n-  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n-  \/\/ inconsistent.\n-  \/\/ So also check if we actually already at the end of the list for the exit\n-  \/\/ condition.\n-  if (_return_to_vm_size == 0 || _first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-  return _source != nullptr;\n-}\n-\n-template<MEMFLAGS flag>\n-bool G1BufferListFreePool<flag>::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n-  assert(finished_return_to_vm(), \"not finished returning to VM\");\n-  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n-\n-  \/\/ Now delete the rest.\n-  size_t num_delete = 0;\n-  size_t mem_size_deleted = 0;\n-\n-  while (_first != nullptr) {\n-    G1SegmentedArrayBuffer<flag>* next = _first->next();\n-    num_delete++;\n-    mem_size_deleted += _first->mem_size();\n-    delete _first;\n-    _first = next;\n-\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n-\n-  return _first != nullptr;\n-}\n-\n-template<MEMFLAGS flag>\n-G1BufferListFreePool<flag> G1BufferListFreePool<flag>::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n-\n-template<MEMFLAGS flag>\n-G1BufferListFreePool<flag>::G1BufferListFreePool(uint num_free_lists) :\n-  _num_free_lists(num_free_lists) {\n-\n-  _free_lists = NEW_C_HEAP_ARRAY(G1SegmentedArrayBufferList<flag>, _num_free_lists, mtGC);\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    new (&_free_lists[i]) G1SegmentedArrayBufferList<flag>();\n-  }\n-}\n-\n-template<MEMFLAGS flag>\n-G1BufferListFreePool<flag>::~G1BufferListFreePool() {\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    _free_lists[i].~G1SegmentedArrayBufferList<flag>();\n-  }\n-  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n-}\n-\n-template<MEMFLAGS flag>\n-G1BufferListMemoryStats G1BufferListFreePool<flag>::memory_sizes() const {\n-  G1BufferListMemoryStats free_list_stats;\n-  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n-  for (uint i = 0; i < num_free_lists(); i++) {\n-    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n-    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n-  }\n-  return free_list_stats;\n-}\n-\n-template<MEMFLAGS flag>\n-size_t G1BufferListFreePool<flag>::mem_size() const {\n-  size_t result = 0;\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    result += _free_lists[i].mem_size();\n-  }\n-  return result;\n-}\n-\n-template<MEMFLAGS flag>\n-void G1BufferListFreePool<flag>::print_on(outputStream* out) {\n-  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n-    _free_lists[i].print_on(out, fmt);\n-  }\n-}\n-\n-template class G1BufferListFreePool<mtGCCardSet>;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BufferListFreePool.cpp","additions":0,"deletions":205,"binary":false,"changes":205,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1BUFFERLISTFREEPOOL_HPP\n-#define SHARE_GC_G1_G1BUFFERLISTFREEPOOL_HPP\n-\n-#include \"gc\/g1\/g1CardSet.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n-\/\/ used for each. Note that statistics are typically not taken atomically so there\n-\/\/ can be inconsistencies. The user must be prepared for them.\n-class G1BufferListMemoryStats {\n-public:\n-\n-  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n-  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n-\n-  \/\/ Returns all-zero statistics.\n-  G1BufferListMemoryStats();\n-\n-  void add(G1BufferListMemoryStats const other) {\n-    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n-    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n-      _num_mem_sizes[i] += other._num_mem_sizes[i];\n-      _num_buffers[i] += other._num_buffers[i];\n-    }\n-  }\n-\n-  void clear();\n-\n-  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n-};\n-\n-\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n-template<MEMFLAGS flag>\n-class G1BufferListFreePool {\n-  \/\/ The global free pool.\n-  static G1BufferListFreePool<flag> _freelist_pool;\n-\n-  const uint _num_free_lists;\n-  G1SegmentedArrayBufferList<flag>* _free_lists;\n-\n-public:\n-  static G1BufferListFreePool<flag>* free_list_pool() { return &_freelist_pool; }\n-  static G1BufferListMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n-\n-  class G1ReturnMemoryProcessor;\n-  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n-\n-  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n-\n-  explicit G1BufferListFreePool<flag>(uint num_free_lists);\n-  ~G1BufferListFreePool();\n-\n-  G1SegmentedArrayBufferList<flag>* free_list(uint i) {\n-    assert(i < _num_free_lists, \"must be\");\n-    return &_free_lists[i];\n-  }\n-\n-  uint num_free_lists() const { return _num_free_lists; }\n-\n-  G1BufferListMemoryStats memory_sizes() const;\n-  size_t mem_size() const;\n-\n-  void print_on(outputStream* out);\n-};\n-\n-\/\/ Data structure containing current in-progress state for returning memory to the\n-\/\/ operating system for a single G1SegmentedArrayBufferList.\n-template<MEMFLAGS flag>\n-class G1BufferListFreePool<flag>::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n-  G1SegmentedArrayBufferList<flag>* _source;\n-  size_t _return_to_vm_size;\n-\n-  G1SegmentedArrayBuffer<flag>* _first;\n-  size_t _unlinked_bytes;\n-  size_t _num_unlinked;\n-\n-public:\n-  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n-    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n-  }\n-\n-  \/\/ Updates the instance members about the given card set buffer list for the purpose\n-  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n-  \/\/ nothing to return to the VM, do not set the source list.\n-  void visit_free_list(G1SegmentedArrayBufferList<flag>* source);\n-\n-  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n-  bool finished_return_to_os() const { return _first == nullptr; }\n-\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_vm() re-adds buffers to the respective free list.\n-  bool return_to_vm(jlong deadline);\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_os() gives back buffers to the OS.\n-  bool return_to_os(jlong deadline);\n-};\n-\n-#endif \/\/SHARE_GC_G1_G1BUFFERLISTFREEPOOL_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BufferListFreePool.hpp","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -145,1 +145,1 @@\n-                                               G1BufferListFreePool<mtGCCardSet>* free_list_pool) : _config(config) {\n+                                               G1SegmentedArrayFreePool<mtGCCardSet>* free_list_pool) : _config(config) {\n@@ -205,2 +205,2 @@\n-G1BufferListMemoryStats G1CardSetMemoryManager::memory_stats() const {\n-  G1BufferListMemoryStats result;\n+G1SegmentedArrayMemoryStats G1CardSetMemoryManager::memory_stats() const {\n+  G1SegmentedArrayMemoryStats result;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1BufferListFreePool.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n@@ -147,1 +147,1 @@\n-                         G1BufferListFreePool<mtGCCardSet>* free_list_pool);\n+                         G1SegmentedArrayFreePool<mtGCCardSet>* free_list_pool);\n@@ -166,1 +166,1 @@\n-  G1BufferListMemoryStats memory_stats() const;\n+  G1SegmentedArrayMemoryStats memory_stats() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"gc\/g1\/g1BufferListFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n@@ -1726,1 +1726,1 @@\n-  _free_card_set_memory_task = new G1BufferListFreeMemoryTask(\"Card Set Free Memory Task\");\n+  _free_card_set_memory_task = new G1SegmentedArrayFreeMemoryTask(\"Card Set Free Memory Task\");\n@@ -2946,1 +2946,1 @@\n-void G1CollectedHeap::set_collection_set_candidates_stats(G1BufferListMemoryStats& stats) {\n+void G1CollectedHeap::set_collection_set_candidates_stats(G1SegmentedArrayMemoryStats& stats) {\n@@ -2950,1 +2950,1 @@\n-void G1CollectedHeap::set_young_gen_card_set_stats(const G1BufferListMemoryStats& stats) {\n+void G1CollectedHeap::set_young_gen_card_set_stats(const G1SegmentedArrayMemoryStats& stats) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/g1\/g1BufferListFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n@@ -68,1 +68,1 @@\n-class G1BufferListFreeMemoryTask;\n+class G1SegmentedArrayFreeMemoryTask;\n@@ -147,1 +147,1 @@\n-  G1BufferListFreeMemoryTask* _free_card_set_memory_task;\n+  G1SegmentedArrayFreeMemoryTask* _free_card_set_memory_task;\n@@ -164,1 +164,1 @@\n-  G1BufferListMemoryStats _young_gen_card_set_stats;\n+  G1SegmentedArrayMemoryStats _young_gen_card_set_stats;\n@@ -166,1 +166,1 @@\n-  G1BufferListMemoryStats _collection_set_candidates_card_set_stats;\n+  G1SegmentedArrayMemoryStats _collection_set_candidates_card_set_stats;\n@@ -263,2 +263,2 @@\n-  void set_collection_set_candidates_stats(G1BufferListMemoryStats& stats);\n-  void set_young_gen_card_set_stats(const G1BufferListMemoryStats& stats);\n+  void set_collection_set_candidates_stats(G1SegmentedArrayMemoryStats& stats);\n+  void set_young_gen_card_set_stats(const G1SegmentedArrayMemoryStats& stats);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3047,1 +3047,1 @@\n-  _total_remset_bytes += G1BufferListFreePool<mtGCCardSet>::free_list_pool()->mem_size() + HeapRegionRemSet::static_mem_size();\n+  _total_remset_bytes += G1SegmentedArrayFreePool<mtGCCardSet>::free_list_pool()->mem_size() + HeapRegionRemSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-    G1BufferListFreePool<mtGCCardSet>::free_list_pool()->print_on(out);\n+    G1SegmentedArrayFreePool<mtGCCardSet>::free_list_pool()->print_on(out);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"heapRegionRemSet.hpp\"\n+#include \"ci\/ciUtilities.hpp\"\n+\n+constexpr const char* G1SegmentedArrayFreeMemoryTask::_state_names[];\n+\n+const char* G1SegmentedArrayFreeMemoryTask::get_state_name(State value) const {\n+  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::deadline_exceeded(jlong deadline) {\n+  return os::elapsed_counter() >= deadline;\n+}\n+\n+static size_t keep_size(size_t free, size_t used, double percent) {\n+  size_t to_keep = used * percent;\n+  return MIN2(free, to_keep);\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::calculate_return_infos(jlong deadline) {\n+  \/\/ Ignore the deadline in this step as it is very short.\n+\n+  G1SegmentedArrayMemoryStats used = _total_used;\n+  G1SegmentedArrayMemoryStats free = G1SegmentedArrayFreePool<mtGCCardSet>::free_list_sizes();\n+\n+  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n+  for (uint i = 0; i < used.num_pools(); i++) {\n+    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n+                                         used._num_mem_sizes[i],\n+                                         G1RemSetFreeMemoryKeepExcessRatio);\n+    log_trace(gc, task)(\"Card Set Free Memory: Type %s: Free: %zu (%zu) \"\n+                        \"Used: %zu Keep: %zu\",\n+                        G1CardSetConfiguration::mem_object_type_name_str(i),\n+                        free._num_mem_sizes[i], free._num_buffers[i],\n+                        used._num_mem_sizes[i], return_to_vm_size);\n+\n+    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n+  }\n+\n+  G1SegmentedArrayFreePool<mtGCCardSet>::update_unlink_processors(_return_info);\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_vm()) {\n+      if (info->return_to_vm(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::return_memory_to_os(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_os()) {\n+      if (info->return_to_os(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::cleanup_return_infos() {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+     G1ReturnMemoryProcessor* info = _return_info->at(i);\n+     delete info;\n+  }\n+  delete _return_info;\n+\n+  _return_info = nullptr;\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::free_excess_card_set_memory() {\n+  jlong start = os::elapsed_counter();\n+  jlong end = start +\n+              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step start %1.3f end %1.3f\",\n+                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n+\n+  State next_state;\n+\n+  do {\n+    switch (_state) {\n+      case State::CalculateUsed: {\n+        if (calculate_return_infos(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToVM;\n+        break;\n+      }\n+      case State::ReturnToVM: {\n+        if (return_memory_to_vm(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToOS;\n+        break;\n+      }\n+      case State::ReturnToOS: {\n+        if (return_memory_to_os(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::Cleanup;\n+        break;\n+      }\n+      case State::Cleanup: {\n+        cleanup_return_infos();\n+        next_state = State::Inactive;\n+        break;\n+      }\n+      default:\n+        log_error(gc, task)(\"Should not try to free excess card set memory in %s state\", get_state_name(_state));\n+        ShouldNotReachHere();\n+        break;\n+    }\n+\n+    set_state(next_state);\n+  } while (_state != State::Inactive && !deadline_exceeded(end));\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step took %1.3fms, done %s\",\n+                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n+                      bool_to_str(_state == State::CalculateUsed));\n+\n+  return is_active();\n+}\n+\n+void G1SegmentedArrayFreeMemoryTask::set_state(State new_state) {\n+  log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n+                      get_state_name(_state),\n+                      get_state_name(new_state));\n+  _state = new_state;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::is_active() const {\n+  return _state != State::Inactive;\n+}\n+\n+jlong G1SegmentedArrayFreeMemoryTask::reschedule_delay_ms() const {\n+  return G1RemSetFreeMemoryRescheduleDelayMillis;\n+}\n+\n+G1SegmentedArrayFreeMemoryTask::G1SegmentedArrayFreeMemoryTask(const char* name) :\n+  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n+\n+void G1SegmentedArrayFreeMemoryTask::execute() {\n+  SuspendibleThreadSetJoiner sts;\n+\n+  if (free_excess_card_set_memory()) {\n+    schedule(reschedule_delay_ms());\n+  }\n+}\n+\n+void G1SegmentedArrayFreeMemoryTask::notify_new_stats(G1SegmentedArrayMemoryStats* young_gen_stats,\n+                                                      G1SegmentedArrayMemoryStats* collection_set_candidate_stats) {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  _total_used = *young_gen_stats;\n+  _total_used.add(*collection_set_candidate_stats);\n+\n+  if (!is_active()) {\n+    set_state(State::CalculateUsed);\n+    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreeMemoryTask.cpp","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1SEGMENTEDARRAYFREEMEMORYTASK_HPP\n+#define SHARE_GC_G1_G1SEGMENTEDARRAYFREEMEMORYTASK_HPP\n+\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ Task handling deallocation of free card set memory.\n+class G1SegmentedArrayFreeMemoryTask : public G1ServiceTask {\n+\n+  enum class State : uint {\n+    Inactive,\n+    CalculateUsed,\n+    ReturnToVM,\n+    ReturnToOS,\n+    Cleanup\n+  };\n+\n+  static constexpr const char* _state_names[] = { \"Invalid\",\n+                                                  \"CalculateUsed\",\n+                                                  \"ReturnToVM\",\n+                                                  \"ReturnToOS\",\n+                                                  \"Cleanup\" };\n+\n+  const char* get_state_name(State value) const;\n+\n+  State _state;\n+\n+  \/\/ Current total card set memory usage.\n+  G1SegmentedArrayMemoryStats _total_used;\n+\n+  typedef G1SegmentedArrayFreePool<mtGCCardSet>::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n+  typedef G1SegmentedArrayFreePool<mtGCCardSet>::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n+\n+  G1ReturnMemoryProcessorSet* _return_info;\n+\n+  \/\/ Returns whether the given deadline has passed.\n+  bool deadline_exceeded(jlong deadline);\n+\n+  \/\/ Methods for the tasks to be done. They all return true if that step has\n+  \/\/ completed.\n+  bool calculate_return_infos(jlong deadline);\n+  bool return_memory_to_vm(jlong deadline);\n+  bool return_memory_to_os(jlong deadline);\n+  bool cleanup_return_infos();\n+\n+  \/\/ Free excess card set memory, main method. Returns true if there is more work\n+  \/\/ to do.\n+  bool free_excess_card_set_memory();\n+\n+  void set_state(State new_state);\n+  \/\/ Returns whether we are currently processing a recent request.\n+  bool is_active() const;\n+\n+  \/\/ The delay used to reschedule this task if not all work has been completed.\n+  jlong reschedule_delay_ms() const;\n+\n+public:\n+  explicit G1SegmentedArrayFreeMemoryTask(const char* name);\n+\n+  void execute() override;\n+\n+  \/\/ Notify the task of new used remembered set memory statistics for the young\n+  \/\/ generation and the collection set candidate sets.\n+  void notify_new_stats(G1SegmentedArrayMemoryStats* young_gen_stats,\n+                        G1SegmentedArrayMemoryStats* collection_set_candidate_stats);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1SEGMENTEDARRAYFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+G1SegmentedArrayMemoryStats::G1SegmentedArrayMemoryStats() {\n+  clear();\n+}\n+\n+void G1SegmentedArrayMemoryStats::clear() {\n+  for (uint i = 0; i < num_pools(); i++) {\n+    _num_mem_sizes[i] = 0;\n+    _num_buffers[i] = 0;\n+  }\n+}\n+\n+template<MEMFLAGS flag>\n+void G1SegmentedArrayFreePool<flag>::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+  uint num_free_lists = _freelist_pool.num_free_lists();\n+\n+  for (uint i = 0; i < num_free_lists; i++) {\n+    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  }\n+}\n+\n+template<MEMFLAGS flag>\n+void G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::visit_free_list(G1SegmentedArrayBufferList<flag>* source) {\n+  assert(_source == nullptr, \"already visited\");\n+  if (_return_to_vm_size > 0) {\n+    _source = source;\n+  } else {\n+    assert(_source == nullptr, \"must be\");\n+  }\n+  if (source->mem_size() > _return_to_vm_size) {\n+    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n+  } else {\n+    assert(_first == nullptr, \"must be\");\n+  }\n+  \/\/ Above we were racing with other threads getting the contents of the free list,\n+  \/\/ so while we might have been asked to return something to the OS initially,\n+  \/\/ the free list might be empty anyway. In this case just reset internal values\n+  \/\/ used for checking whether there is work available.\n+  if (_first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+}\n+\n+template<MEMFLAGS flag>\n+bool G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n+  assert(_first != nullptr, \"must have element to return\");\n+\n+  size_t keep_size = 0;\n+  size_t keep_num = 0;\n+\n+  G1SegmentedArrayBuffer<flag>* cur = _first;\n+  G1SegmentedArrayBuffer<flag>* last = nullptr;\n+\n+  while (cur != nullptr && _return_to_vm_size > 0) {\n+    size_t cur_size = cur->mem_size();\n+    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n+\n+    keep_size += cur_size;\n+    keep_num++;\n+\n+    last = cur;\n+    cur = cur->next();\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  assert(_first != nullptr, \"must be\");\n+  assert(last != nullptr, \"must be\");\n+\n+  last->set_next(nullptr);\n+\n+  \/\/ Wait for any in-progress pops to avoid ABA for them.\n+  GlobalCounter::write_synchronize();\n+  _source->bulk_add(*_first, *last, keep_num, keep_size);\n+  _first = cur;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+\n+  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n+  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n+  \/\/ inconsistent.\n+  \/\/ So also check if we actually already at the end of the list for the exit\n+  \/\/ condition.\n+  if (_return_to_vm_size == 0 || _first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+  return _source != nullptr;\n+}\n+\n+template<MEMFLAGS flag>\n+bool G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+  assert(finished_return_to_vm(), \"not finished returning to VM\");\n+  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n+\n+  \/\/ Now delete the rest.\n+  size_t num_delete = 0;\n+  size_t mem_size_deleted = 0;\n+\n+  while (_first != nullptr) {\n+    G1SegmentedArrayBuffer<flag>* next = _first->next();\n+    num_delete++;\n+    mem_size_deleted += _first->mem_size();\n+    delete _first;\n+    _first = next;\n+\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+\n+  return _first != nullptr;\n+}\n+\n+template<MEMFLAGS flag>\n+G1SegmentedArrayFreePool<flag> G1SegmentedArrayFreePool<flag>::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+\n+template<MEMFLAGS flag>\n+G1SegmentedArrayFreePool<flag>::G1SegmentedArrayFreePool(uint num_free_lists) :\n+  _num_free_lists(num_free_lists) {\n+\n+  _free_lists = NEW_C_HEAP_ARRAY(G1SegmentedArrayBufferList<flag>, _num_free_lists, mtGC);\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    new (&_free_lists[i]) G1SegmentedArrayBufferList<flag>();\n+  }\n+}\n+\n+template<MEMFLAGS flag>\n+G1SegmentedArrayFreePool<flag>::~G1SegmentedArrayFreePool() {\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    _free_lists[i].~G1SegmentedArrayBufferList<flag>();\n+  }\n+  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n+}\n+\n+template<MEMFLAGS flag>\n+G1SegmentedArrayMemoryStats G1SegmentedArrayFreePool<flag>::memory_sizes() const {\n+  G1SegmentedArrayMemoryStats free_list_stats;\n+  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n+  for (uint i = 0; i < num_free_lists(); i++) {\n+    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n+    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n+  }\n+  return free_list_stats;\n+}\n+\n+template<MEMFLAGS flag>\n+size_t G1SegmentedArrayFreePool<flag>::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    result += _free_lists[i].mem_size();\n+  }\n+  return result;\n+}\n+\n+template<MEMFLAGS flag>\n+void G1SegmentedArrayFreePool<flag>::print_on(outputStream* out) {\n+  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n+    _free_lists[i].print_on(out, fmt);\n+  }\n+}\n+\n+template class G1SegmentedArrayFreePool<mtGCCardSet>;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.cpp","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+#define SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n+\/\/ used for each. Note that statistics are typically not taken atomically so there\n+\/\/ can be inconsistencies. The user must be prepared for them.\n+class G1SegmentedArrayMemoryStats {\n+public:\n+\n+  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n+\n+  \/\/ Returns all-zero statistics.\n+  G1SegmentedArrayMemoryStats();\n+\n+  void add(G1SegmentedArrayMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n+    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n+      _num_mem_sizes[i] += other._num_mem_sizes[i];\n+      _num_buffers[i] += other._num_buffers[i];\n+    }\n+  }\n+\n+  void clear();\n+\n+  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n+};\n+\n+\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n+template<MEMFLAGS flag>\n+class G1SegmentedArrayFreePool {\n+  \/\/ The global free pool.\n+  static G1SegmentedArrayFreePool<flag> _freelist_pool;\n+\n+  const uint _num_free_lists;\n+  G1SegmentedArrayBufferList<flag>* _free_lists;\n+\n+public:\n+  static G1SegmentedArrayFreePool<flag>* free_list_pool() { return &_freelist_pool; }\n+  static G1SegmentedArrayMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+\n+  class G1ReturnMemoryProcessor;\n+  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n+\n+  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+\n+  explicit G1SegmentedArrayFreePool<flag>(uint num_free_lists);\n+  ~G1SegmentedArrayFreePool();\n+\n+  G1SegmentedArrayBufferList<flag>* free_list(uint i) {\n+    assert(i < _num_free_lists, \"must be\");\n+    return &_free_lists[i];\n+  }\n+\n+  uint num_free_lists() const { return _num_free_lists; }\n+\n+  G1SegmentedArrayMemoryStats memory_sizes() const;\n+  size_t mem_size() const;\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Data structure containing current in-progress state for returning memory to the\n+\/\/ operating system for a single G1SegmentedArrayBufferList.\n+template<MEMFLAGS flag>\n+class G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1SegmentedArrayBufferList<flag>* _source;\n+  size_t _return_to_vm_size;\n+\n+  G1SegmentedArrayBuffer<flag>* _first;\n+  size_t _unlinked_bytes;\n+  size_t _num_unlinked;\n+\n+public:\n+  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n+    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n+  }\n+\n+  \/\/ Updates the instance members about the given card set buffer list for the purpose\n+  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n+  \/\/ nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1SegmentedArrayBufferList<flag>* source);\n+\n+  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n+  bool finished_return_to_os() const { return _first == nullptr; }\n+\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  bool return_to_vm(jlong deadline);\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_os() gives back buffers to the OS.\n+  bool return_to_os(jlong deadline);\n+};\n+\n+#endif \/\/SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.hpp","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -333,1 +333,1 @@\n-    G1BufferListMemoryStats _card_set_stats;\n+    G1SegmentedArrayMemoryStats _card_set_stats;\n@@ -449,1 +449,1 @@\n-    G1BufferListMemoryStats card_set_stats() const {\n+    G1SegmentedArrayMemoryStats card_set_stats() const {\n@@ -459,1 +459,1 @@\n-  G1BufferListMemoryStats _all_card_set_stats;\n+  G1SegmentedArrayMemoryStats _all_card_set_stats;\n@@ -493,1 +493,1 @@\n-  const G1BufferListMemoryStats all_card_set_stats() const {\n+  const G1SegmentedArrayMemoryStats all_card_set_stats() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-class G1BufferListMemoryStats;\n+class G1SegmentedArrayMemoryStats;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-      G1BufferListMemoryStats _total;\n+      G1SegmentedArrayMemoryStats _total;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  _card_set_mm(config, G1BufferListFreePool<mtGCCardSet>::free_list_pool()),\n+  _card_set_mm(config, G1SegmentedArrayFreePool<mtGCCardSet>::free_list_pool()),\n@@ -107,1 +107,1 @@\n-G1BufferListMemoryStats HeapRegionRemSet::card_set_memory_stats() const {\n+G1SegmentedArrayMemoryStats HeapRegionRemSet::card_set_memory_stats() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-  G1BufferListMemoryStats card_set_memory_stats() const;\n+  G1SegmentedArrayMemoryStats card_set_memory_stats() const;\n@@ -146,1 +146,1 @@\n-    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size() + sizeof(G1BufferListFreePool<mtGCCardSet>);\n+    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size() + sizeof(G1SegmentedArrayFreePool<mtGCCardSet>);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}