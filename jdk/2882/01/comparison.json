{"files":[{"patch":"@@ -333,0 +333,5 @@\n+        WIN_SHORTCUT_PROMPT (\"win-shortcut-prompt\",\n+                OptionCategories.PLATFORM_WIN, () -> {\n+            setOptionValue(\"win-shortcut-prompt\", true);\n+        }),\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+            options.put(CLIOptions.WIN_SHORTCUT_PROMPT.getId(), USE.INSTALL);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ValidOptions.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,1 +208,1 @@\n-\\          Adds the application to the system menu\\n\\\n+\\          Request to add a Start menu shortcut for this application\\n\\\n@@ -214,1 +214,4 @@\n-\\          Creates a desktop shortcut for the application\\n\\\n+\\          Request to add desktop shortcut for this application\\n\\\n+\\  --win-shortcut-prompt\\n\\\n+\\          Adds a dialog to enable the user to choose if shortcuts\\n\\\n+\\          will be created by installer\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,1 +34,18 @@\n-MSG_Help_win_install=\\  --win-dir-chooser\\n          \\u30E6\\u30FC\\u30B6\\u30FC\\u304C\\u88FD\\u54C1\\u3092\\u30A4\\u30F3\\u30B9\\u30C8\\u30FC\\u30EB\\u3059\\u308B\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u3092\\u9078\\u629E\\n          \\u3059\\u308B\\u305F\\u3081\\u306E\\u30C0\\u30A4\\u30A2\\u30ED\\u30B0\\u3092\\u8FFD\\u52A0\\u3057\\u307E\\u3059\\n  --win-menu\\n          \\u30B7\\u30B9\\u30C6\\u30E0\\u30FB\\u30E1\\u30CB\\u30E5\\u30FC\\u306B\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u3092\\u8FFD\\u52A0\\u3057\\u307E\\u3059\\n  --win-menu-group <menu group name>\\n          \\u3053\\u306E\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u3092\\u914D\\u7F6E\\u3059\\u308B\\u30B9\\u30BF\\u30FC\\u30C8\\u30FB\\u30E1\\u30CB\\u30E5\\u30FC\\u30FB\\u30B0\\u30EB\\u30FC\\u30D7\\n  --win-per-user-install\\n          \\u30E6\\u30FC\\u30B6\\u30FC\\u3054\\u3068\\u306B\\u30A4\\u30F3\\u30B9\\u30C8\\u30FC\\u30EB\\u3092\\u5B9F\\u884C\\u3059\\u308B\\u3088\\u3046\\u306B\\u30EA\\u30AF\\u30A8\\u30B9\\u30C8\\u3057\\u307E\\u3059\\n  --win-shortcut\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u30C7\\u30B9\\u30AF\\u30C8\\u30C3\\u30D7\\u30FB\\u30B7\\u30E7\\u30FC\\u30C8\\u30AB\\u30C3\\u30C8\\u3092\\u4F5C\\u6210\\u3057\\u307E\\u3059\\n  --win-upgrade-uuid <id string>\\n          \\u3053\\u306E\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u306E\\u30A2\\u30C3\\u30D7\\u30B0\\u30EC\\u30FC\\u30C9\\u306B\\u95A2\\u9023\\u4ED8\\u3051\\u3089\\u308C\\u3066\\u3044\\u308BUUID\\n\n+MSG_Help_win_install=\\\n+\\  --win-dir-chooser\\n\\\n+\\          Adds a dialog to enable the user to choose a directory in which\\n\\\n+\\          the product is installed\\n\\\n+\\  --win-menu\\n\\\n+\\          Request to add a Start menu shortcut for this application\\n\\\n+\\  --win-menu-group <menu group name>\\n\\\n+\\          Start Menu group this application is placed in\\n\\\n+\\  --win-per-user-install\\n\\\n+\\          Request to perform an install on a per-user basis\\n\\\n+\\  --win-shortcut\\n\\\n+\\          Request to add desktop shortcut for this application\\n\\\n+\\  --win-shortcut-prompt\\n\\\n+\\          Adds a dialog to enable the user to choose if shortcuts\\n\\\n+\\          will be created by installer\\n\\\n+\\  --win-upgrade-uuid <id string>\\n\\\n+\\          UUID associated with upgrades for this package\\n\\\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_ja.properties","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,1 +33,18 @@\n-MSG_Help_win_install=\\  --win-dir-chooser\\n          \\u6DFB\\u52A0\\u4E00\\u4E2A\\u5BF9\\u8BDD\\u6846\\u4EE5\\u5141\\u8BB8\\u7528\\u6237\\u9009\\u62E9\\n          \\u4EA7\\u54C1\\u7684\\u5B89\\u88C5\\u76EE\\u5F55\\n  --win-menu\\n          \\u5C06\\u8BE5\\u5E94\\u7528\\u7A0B\\u5E8F\\u6DFB\\u52A0\\u5230\\u7CFB\\u7EDF\\u83DC\\u5355\\u4E2D\\n  --win-menu-group <menu group name>\\n          \\u542F\\u52A8\\u8BE5\\u5E94\\u7528\\u7A0B\\u5E8F\\u6240\\u5728\\u7684\\u83DC\\u5355\\u7EC4\\n  --win-per-user-install\\n          \\u8BF7\\u6C42\\u57FA\\u4E8E\\u6BCF\\u4E2A\\u7528\\u6237\\u6267\\u884C\\u5B89\\u88C5\\n  --win-shortcut\\n          \\u4E3A\\u5E94\\u7528\\u7A0B\\u5E8F\\u521B\\u5EFA\\u684C\\u9762\\u5FEB\\u6377\\u65B9\\u5F0F\\n  --win-upgrade-uuid <id string>\\n          \\u4E0E\\u6B64\\u7A0B\\u5E8F\\u5305\\u5347\\u7EA7\\u76F8\\u5173\\u8054\\u7684 UUID\\n\n+MSG_Help_win_install=\\\n+\\  --win-dir-chooser\\n\\\n+\\          Adds a dialog to enable the user to choose a directory in which\\n\\\n+\\          the product is installed\\n\\\n+\\  --win-menu\\n\\\n+\\          Request to add a Start menu shortcut for this application\\n\\\n+\\  --win-menu-group <menu group name>\\n\\\n+\\          Start Menu group this application is placed in\\n\\\n+\\  --win-per-user-install\\n\\\n+\\          Request to perform an install on a per-user basis\\n\\\n+\\  --win-shortcut\\n\\\n+\\          Request to add desktop shortcut for this application\\n\\\n+\\  --win-shortcut-prompt\\n\\\n+\\          Adds a dialog to enable the user to choose if shortcuts\\n\\\n+\\          will be created by installer\\n\\\n+\\  --win-upgrade-uuid <id string>\\n\\\n+\\          UUID associated with upgrades for this package\\n\\\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_zh_CN.properties","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,1 @@\n+ * <li>ui.wxf. Source file with UI description of the installer.\n@@ -86,0 +87,1 @@\n+ *\n@@ -107,4 +109,0 @@\n- * <li>JpLicenseRtf. Set to the value of --license-file command line option.\n- * Undefined is --license-file command line option was not specified\n- * <li>JpInstallDirChooser. Set to \"yes\" if --win-dir-chooser command line\n- * option was specified. Undefined otherwise\n@@ -116,0 +114,9 @@\n+ *\n+ * <p>\n+ * ui.wxf file is generated based on --license-file, --win-shortcut-prompt,\n+ * --win-dir-chooser command line options. It is parametrized with the following\n+ * WiX variables:\n+ * <ul>\n+ * <li>JpLicenseRtf. Set to the value of --license-file command line option.\n+ * Undefined if --license-file command line option was not specified\n+ * <\/ul>\n@@ -154,1 +161,0 @@\n-\n@@ -187,8 +193,0 @@\n-    private static final BundlerParamInfo<Boolean> INSTALLDIR_CHOOSER =\n-            new StandardBundlerParam<> (\n-            Arguments.CLIOptions.WIN_DIR_CHOOSER.getId(),\n-            Boolean.class,\n-            params -> Boolean.FALSE,\n-            (s, p) -> Boolean.valueOf(s)\n-    );\n-\n@@ -197,0 +195,7 @@\n+        wixFragments = Stream.of(\n+                Map.entry(\"bundle.wxf\", new WixAppImageFragmentBuilder()),\n+                Map.entry(\"ui.wxf\", new WixUiFragmentBuilder())\n+        ).map(e -> {\n+            e.getValue().setOutputFileName(e.getKey());\n+            return e.getValue();\n+        }).collect(Collectors.toList());\n@@ -280,1 +285,2 @@\n-            wixSourcesBuilder.setWixVersion(wixToolset.get(WixTool.Light).version);\n+            wixFragments.forEach(wixFragment -> wixFragment.setWixVersion(\n+                    wixToolset.get(WixTool.Light).version));\n@@ -282,1 +288,1 @@\n-            wixSourcesBuilder.logWixFeatures();\n+            wixFragments.get(0).logWixFeatures();\n@@ -372,4 +378,4 @@\n-            wixSourcesBuilder\n-            .initFromParams(WIN_APP_IMAGE.fetchFrom(params), params)\n-            .createMainFragment(CONFIG_ROOT.fetchFrom(params).resolve(\n-                    \"bundle.wxf\"));\n+            for (var wixFragment : wixFragments) {\n+                wixFragment.initFromParams(params);\n+                wixFragment.addFilesToConfigRoot();\n+            }\n@@ -427,16 +433,0 @@\n-        String licenseFile = LICENSE_FILE.fetchFrom(params);\n-        if (licenseFile != null) {\n-            String lname = IOUtils.getFileName(Path.of(licenseFile)).toString();\n-            Path destFile = CONFIG_ROOT.fetchFrom(params).resolve(lname);\n-            data.put(\"JpLicenseRtf\", destFile.toAbsolutePath().toString());\n-        }\n-\n-        \/\/ Copy CA dll to include with installer\n-        if (INSTALLDIR_CHOOSER.fetchFrom(params)) {\n-            data.put(\"JpInstallDirChooser\", \"yes\");\n-            String fname = \"wixhelper.dll\";\n-            try (InputStream is = OverridableResource.readDefault(fname)) {\n-                Files.copy(is, CONFIG_ROOT.fetchFrom(params).resolve(fname));\n-            }\n-        }\n-\n@@ -479,2 +469,5 @@\n-        .addSource(CONFIG_ROOT.fetchFrom(params).resolve(\"main.wxs\"), wixVars)\n-        .addSource(CONFIG_ROOT.fetchFrom(params).resolve(\"bundle.wxf\"), null);\n+        .addSource(CONFIG_ROOT.fetchFrom(params).resolve(\"main.wxs\"), wixVars);\n+\n+        for (var wixFragment : wixFragments) {\n+            wixFragment.configureWixPipeline(wixPipeline);\n+        }\n@@ -485,3 +478,0 @@\n-        boolean enableLicenseUI = (LICENSE_FILE.fetchFrom(params) != null);\n-        boolean enableInstalldirUI = INSTALLDIR_CHOOSER.fetchFrom(params);\n-\n@@ -493,3 +483,0 @@\n-        if (enableLicenseUI || enableInstalldirUI) {\n-            wixPipeline.addLightOptions(\"-ext\", \"WixUIExtension\");\n-        }\n@@ -515,6 +502,0 @@\n-        \/\/ Only needed if we using CA dll, so Wix can find it\n-        if (enableInstalldirUI) {\n-            wixPipeline.addLightOptions(\"-b\", CONFIG_ROOT.fetchFrom(params)\n-                    .toAbsolutePath().toString());\n-        }\n-\n@@ -646,1 +627,1 @@\n-    private WixSourcesBuilder wixSourcesBuilder = new WixSourcesBuilder();\n+    private List<WixFragmentBuilder> wixFragments;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":32,"deletions":51,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,893 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import jdk.jpackage.internal.IOUtils.XmlConsumer;\n+import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n+import static jdk.jpackage.internal.StandardBundlerParam.INSTALL_DIR;\n+import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n+import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n+import static jdk.jpackage.internal.WinMsiBundler.MSI_SYSTEM_WIDE;\n+import static jdk.jpackage.internal.WinMsiBundler.WIN_APP_IMAGE;\n+\n+\/**\n+ * Creates WiX fragment with components for contents of app image.\n+ *\/\n+class WixAppImageFragmentBuilder extends WixFragmentBuilder {\n+\n+    @Override\n+    void initFromParams(Map<String, ? super Object> params) {\n+        super.initFromParams(params);\n+\n+        Path appImageRoot = WIN_APP_IMAGE.fetchFrom(params);\n+\n+        Supplier<ApplicationLayout> appImageSupplier = () -> {\n+            if (StandardBundlerParam.isRuntimeInstaller(params)) {\n+                return ApplicationLayout.javaRuntime();\n+            } else {\n+                return ApplicationLayout.platformAppImage();\n+            }\n+        };\n+\n+        systemWide = MSI_SYSTEM_WIDE.fetchFrom(params);\n+\n+        registryKeyPath = Path.of(\"Software\",\n+                VENDOR.fetchFrom(params),\n+                APP_NAME.fetchFrom(params),\n+                VERSION.fetchFrom(params)).toString();\n+\n+        installDir = (systemWide ? PROGRAM_FILES : LOCAL_PROGRAM_FILES).resolve(\n+                WINDOWS_INSTALL_DIR.fetchFrom(params));\n+\n+        do {\n+            ApplicationLayout layout = appImageSupplier.get();\n+            \/\/ Don't want AppImageFile.FILENAME in installed application.\n+            \/\/ Register it with app image at a role without a match in installed\n+            \/\/ app layout to exclude it from layout transformation.\n+            layout.pathGroup().setPath(new Object(),\n+                    AppImageFile.getPathInAppImage(Path.of(\"\")));\n+\n+            \/\/ Want absolute paths to source files in generated WiX sources.\n+            \/\/ This is to handle scenario if sources would be processed from\n+            \/\/ differnt current directory.\n+            appImage = layout.resolveAt(appImageRoot.toAbsolutePath().normalize());\n+        } while (false);\n+\n+        installedAppImage = appImageSupplier.get().resolveAt(INSTALLDIR);\n+\n+        shortcutFolders = Stream.of(ShortcutsFolder.values()).filter(\n+                shortcutFolder -> shortcutFolder.requested(params)).collect(\n+                        Collectors.toSet());\n+\n+        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n+            launcherPaths = Collections.emptyList();\n+        } else {\n+            launcherPaths = AppImageFile.getLauncherNames(appImageRoot, params).stream()\n+                    .map(name -> installedAppImage.launchersDirectory().resolve(name))\n+                    .map(WixAppImageFragmentBuilder::addExeSuffixToPath)\n+                    .collect(Collectors.toList());\n+        }\n+\n+        programMenuFolderName = MENU_GROUP.fetchFrom(params);\n+\n+        initFileAssociations(params);\n+    }\n+\n+    @Override\n+    void addFilesToConfigRoot() throws IOException {\n+        removeFolderItems = new HashMap<>();\n+        defaultedMimes = new HashSet<>();\n+        super.addFilesToConfigRoot();\n+    }\n+\n+    @Override\n+    protected Collection<XmlConsumer> getFragmentWriters() {\n+        return List.of(\n+                xml -> {\n+                    addFaComponentGroup(xml);\n+\n+                    addShortcutComponentGroup(xml);\n+\n+                    addFilesComponentGroup(xml);\n+\n+                    for (var shortcutFolder : shortcutFolders) {\n+                        xml.writeStartElement(\"Property\");\n+                        xml.writeAttribute(\"Id\", shortcutFolder.property);\n+                        xml.writeAttribute(\"Value\", \"1\");\n+                        xml.writeEndElement();\n+                    }\n+                },\n+                this::addIcons\n+        );\n+    }\n+\n+    private void normalizeFileAssociation(FileAssociation fa) {\n+        fa.launcherPath = addExeSuffixToPath(\n+                installedAppImage.launchersDirectory().resolve(fa.launcherPath));\n+\n+        if (fa.iconPath != null && !Files.exists(fa.iconPath)) {\n+            fa.iconPath = null;\n+        }\n+\n+        if (fa.iconPath != null) {\n+            fa.iconPath = fa.iconPath.toAbsolutePath();\n+        }\n+\n+        \/\/ Filter out empty extensions.\n+        fa.extensions = fa.extensions.stream().filter(Predicate.not(\n+                String::isEmpty)).collect(Collectors.toList());\n+    }\n+\n+    private static Path addExeSuffixToPath(Path path) {\n+        return IOUtils.addSuffix(path, \".exe\");\n+    }\n+\n+    private Path getInstalledFaIcoPath(FileAssociation fa) {\n+        String fname = String.format(\"fa_%s.ico\", String.join(\"_\", fa.extensions));\n+        return installedAppImage.destktopIntegrationDirectory().resolve(fname);\n+    }\n+\n+    private void initFileAssociations(Map<String, ? super Object> params) {\n+        associations = FileAssociation.fetchFrom(params).stream()\n+                .peek(this::normalizeFileAssociation)\n+                \/\/ Filter out file associations without extensions.\n+                .filter(fa -> !fa.extensions.isEmpty())\n+                .collect(Collectors.toList());\n+\n+        associations.stream().filter(fa -> fa.iconPath != null).forEach(fa -> {\n+            \/\/ Need to add fa icon in the image.\n+            Object key = new Object();\n+            appImage.pathGroup().setPath(key, fa.iconPath);\n+            installedAppImage.pathGroup().setPath(key, getInstalledFaIcoPath(fa));\n+        });\n+    }\n+\n+    private static UUID createNameUUID(String str) {\n+        return UUID.nameUUIDFromBytes(str.getBytes(StandardCharsets.UTF_8));\n+    }\n+\n+    private static UUID createNameUUID(Path path, String role) {\n+        if (path.isAbsolute() || !ROOT_DIRS.contains(path.getName(0))) {\n+            throw throwInvalidPathException(path);\n+        }\n+        \/\/ Paths are case insensitive on Windows\n+        String keyPath = path.toString().toLowerCase();\n+        if (role != null) {\n+            keyPath = role + \"@\" + keyPath;\n+        }\n+        return createNameUUID(keyPath);\n+    }\n+\n+    \/**\n+     * Value for Id attribute of various WiX elements.\n+     *\/\n+    enum Id {\n+        File,\n+        Folder(\"dir\"),\n+        Shortcut,\n+        ProgId,\n+        Icon,\n+        CreateFolder(\"mkdir\"),\n+        RemoveFolder(\"rm\");\n+\n+        Id() {\n+            this.prefix = name().toLowerCase();\n+        }\n+\n+        Id(String prefix) {\n+            this.prefix = prefix;\n+        }\n+\n+        String of(Path path) {\n+            if (this == Folder && KNOWN_DIRS.contains(path)) {\n+                return IOUtils.getFileName(path).toString();\n+            }\n+\n+            String result = of(path, prefix, name());\n+\n+            if (this == Icon) {\n+                \/\/ Icon id constructed from UUID value is too long and triggers\n+                \/\/ CNDL1000 warning, so use Java hash code instead.\n+                result = String.format(\"%s%d\", prefix, result.hashCode()).replace(\n+                        \"-\", \"_\");\n+            }\n+\n+            return result;\n+        }\n+\n+        private static String of(Path path, String prefix, String role) {\n+            Objects.requireNonNull(role);\n+            Objects.requireNonNull(prefix);\n+            return String.format(\"%s%s\", prefix,\n+                    createNameUUID(path, role).toString().replace(\"-\", \"\"));\n+        }\n+\n+        static String of(Path path, String prefix) {\n+            return of(path, prefix, prefix);\n+        }\n+\n+        private final String prefix;\n+    }\n+\n+    enum Component {\n+        File(cfg().file()),\n+        Shortcut(cfg().file().withRegistryKeyPath()),\n+        ProgId(cfg().file().withRegistryKeyPath()),\n+        CreateFolder(cfg().withRegistryKeyPath()),\n+        RemoveFolder(cfg().withRegistryKeyPath());\n+\n+        Component() {\n+            this.cfg = cfg();\n+            this.id = Id.valueOf(name());\n+        }\n+\n+        Component(Config cfg) {\n+            this.cfg = cfg;\n+            this.id = Id.valueOf(name());\n+        }\n+\n+        UUID guidOf(Path path) {\n+            return createNameUUID(path, name());\n+        }\n+\n+        String idOf(Path path) {\n+            return id.of(path);\n+        }\n+\n+        boolean isRegistryKeyPath() {\n+            return cfg.withRegistryKeyPath;\n+        }\n+\n+        boolean isFile() {\n+            return cfg.isFile;\n+        }\n+\n+        static void startElement(XMLStreamWriter xml, String componentId,\n+                String componentGuid) throws XMLStreamException, IOException {\n+            xml.writeStartElement(\"Component\");\n+            xml.writeAttribute(\"Win64\", is64Bit() ? \"yes\" : \"no\");\n+            xml.writeAttribute(\"Id\", componentId);\n+            xml.writeAttribute(\"Guid\", componentGuid);\n+        }\n+\n+        private static final class Config {\n+            Config withRegistryKeyPath() {\n+                withRegistryKeyPath = true;\n+                return this;\n+            }\n+\n+            Config file() {\n+                isFile = true;\n+                return this;\n+            }\n+\n+            private boolean isFile;\n+            private boolean withRegistryKeyPath;\n+        }\n+\n+        private static Config cfg() {\n+            return new Config();\n+        }\n+\n+        private final Config cfg;\n+        private final Id id;\n+    };\n+\n+    private static void addComponentGroup(XMLStreamWriter xml, String id,\n+            List<String> componentIds) throws XMLStreamException, IOException {\n+        xml.writeStartElement(\"ComponentGroup\");\n+        xml.writeAttribute(\"Id\", id);\n+        componentIds = componentIds.stream().filter(Objects::nonNull).collect(\n+                Collectors.toList());\n+        for (var componentId : componentIds) {\n+            xml.writeStartElement(\"ComponentRef\");\n+            xml.writeAttribute(\"Id\", componentId);\n+            xml.writeEndElement();\n+        }\n+        xml.writeEndElement();\n+    }\n+\n+    private String addComponent(XMLStreamWriter xml, Path path,\n+            Component role, XmlConsumer xmlConsumer) throws XMLStreamException,\n+            IOException {\n+\n+        final Path directoryRefPath;\n+        if (role.isFile()) {\n+            directoryRefPath = path.getParent();\n+        } else {\n+            directoryRefPath = path;\n+        }\n+\n+        xml.writeStartElement(\"DirectoryRef\");\n+        xml.writeAttribute(\"Id\", Id.Folder.of(directoryRefPath));\n+\n+        final String componentId = \"c\" + role.idOf(path);\n+        Component.startElement(xml, componentId, String.format(\"{%s}\",\n+                role.guidOf(path)));\n+\n+        if (role == Component.Shortcut) {\n+            xml.writeStartElement(\"Condition\");\n+            String property = shortcutFolders.stream().filter(shortcutFolder -> {\n+                return path.startsWith(shortcutFolder.root);\n+            }).map(shortcutFolder -> {\n+                return shortcutFolder.property;\n+            }).findFirst().get();\n+            xml.writeCharacters(property);\n+            xml.writeEndElement();\n+        }\n+\n+        boolean isRegistryKeyPath = !systemWide || role.isRegistryKeyPath();\n+        if (isRegistryKeyPath) {\n+            addRegistryKeyPath(xml, directoryRefPath);\n+            if ((role.isFile() || (role == Component.CreateFolder\n+                    && !systemWide)) && !SYSTEM_DIRS.contains(directoryRefPath)) {\n+                xml.writeStartElement(\"RemoveFolder\");\n+                int counter = Optional.ofNullable(removeFolderItems.get(\n+                        directoryRefPath)).orElse(Integer.valueOf(0)).intValue() + 1;\n+                removeFolderItems.put(directoryRefPath, counter);\n+                xml.writeAttribute(\"Id\", String.format(\"%s_%d\", Id.RemoveFolder.of(\n+                        directoryRefPath), counter));\n+                xml.writeAttribute(\"On\", \"uninstall\");\n+                xml.writeEndElement();\n+            }\n+        }\n+\n+        xml.writeStartElement(role.name());\n+        if (role != Component.CreateFolder) {\n+            xml.writeAttribute(\"Id\", role.idOf(path));\n+        }\n+\n+        if (!isRegistryKeyPath) {\n+            xml.writeAttribute(\"KeyPath\", \"yes\");\n+        }\n+\n+        xmlConsumer.accept(xml);\n+        xml.writeEndElement();\n+\n+        xml.writeEndElement(); \/\/ <Component>\n+        xml.writeEndElement(); \/\/ <DirectoryRef>\n+\n+        return componentId;\n+    }\n+\n+    private void addFaComponentGroup(XMLStreamWriter xml)\n+            throws XMLStreamException, IOException {\n+\n+        List<String> componentIds = new ArrayList<>();\n+        for (var fa : associations) {\n+            componentIds.addAll(addFaComponents(xml, fa));\n+        }\n+        addComponentGroup(xml, \"FileAssociations\", componentIds);\n+    }\n+\n+    private void addShortcutComponentGroup(XMLStreamWriter xml) throws\n+            XMLStreamException, IOException {\n+        List<String> componentIds = new ArrayList<>();\n+        Set<ShortcutsFolder> defineShortcutFolders = new HashSet<>();\n+        for (var launcherPath : launcherPaths) {\n+            for (var folder : shortcutFolders) {\n+                String componentId = addShortcutComponent(xml, launcherPath,\n+                        folder);\n+                if (componentId != null) {\n+                    defineShortcutFolders.add(folder);\n+                    componentIds.add(componentId);\n+                }\n+            }\n+        }\n+\n+        for (var folder : defineShortcutFolders) {\n+            Path path = folder.getPath(this);\n+            componentIds.addAll(addRootBranch(xml, path));\n+        }\n+\n+        addComponentGroup(xml, \"Shortcuts\", componentIds);\n+    }\n+\n+    private String addShortcutComponent(XMLStreamWriter xml, Path launcherPath,\n+            ShortcutsFolder folder) throws XMLStreamException, IOException {\n+        Objects.requireNonNull(folder);\n+\n+        if (!INSTALLDIR.equals(launcherPath.getName(0))) {\n+            throw throwInvalidPathException(launcherPath);\n+        }\n+\n+        String launcherBasename = IOUtils.replaceSuffix(\n+                IOUtils.getFileName(launcherPath), \"\").toString();\n+\n+        Path shortcutPath = folder.getPath(this).resolve(launcherBasename);\n+        return addComponent(xml, shortcutPath, Component.Shortcut, unused -> {\n+            final Path icoFile = IOUtils.addSuffix(\n+                    installedAppImage.destktopIntegrationDirectory().resolve(\n+                            launcherBasename), \".ico\");\n+\n+            xml.writeAttribute(\"Name\", launcherBasename);\n+            xml.writeAttribute(\"WorkingDirectory\", INSTALLDIR.toString());\n+            xml.writeAttribute(\"Advertise\", \"no\");\n+            xml.writeAttribute(\"IconIndex\", \"0\");\n+            xml.writeAttribute(\"Target\", String.format(\"[#%s]\",\n+                    Component.File.idOf(launcherPath)));\n+            xml.writeAttribute(\"Icon\", Id.Icon.of(icoFile));\n+        });\n+    }\n+\n+    private List<String> addFaComponents(XMLStreamWriter xml,\n+            FileAssociation fa) throws XMLStreamException, IOException {\n+        List<String> components = new ArrayList<>();\n+        for (var extension: fa.extensions) {\n+            Path path = INSTALLDIR.resolve(String.format(\"%s_%s\", extension,\n+                    fa.launcherPath.getFileName()));\n+            components.add(addComponent(xml, path, Component.ProgId, unused -> {\n+                xml.writeAttribute(\"Description\", fa.description);\n+\n+                if (fa.iconPath != null) {\n+                    xml.writeAttribute(\"Icon\", Id.File.of(getInstalledFaIcoPath(\n+                            fa)));\n+                    xml.writeAttribute(\"IconIndex\", \"0\");\n+                }\n+\n+                xml.writeStartElement(\"Extension\");\n+                xml.writeAttribute(\"Id\", extension);\n+                xml.writeAttribute(\"Advertise\", \"no\");\n+\n+                var mimeIt = fa.mimeTypes.iterator();\n+                if (mimeIt.hasNext()) {\n+                    String mime = mimeIt.next();\n+                    xml.writeAttribute(\"ContentType\", mime);\n+\n+                    if (!defaultedMimes.contains(mime)) {\n+                        xml.writeStartElement(\"MIME\");\n+                        xml.writeAttribute(\"ContentType\", mime);\n+                        xml.writeAttribute(\"Default\", \"yes\");\n+                        xml.writeEndElement();\n+                        defaultedMimes.add(mime);\n+                    }\n+                }\n+\n+                xml.writeStartElement(\"Verb\");\n+                xml.writeAttribute(\"Id\", \"open\");\n+                xml.writeAttribute(\"Command\", \"Open\");\n+                xml.writeAttribute(\"Argument\", \"\\\"%1\\\"\");\n+                xml.writeAttribute(\"TargetFile\", Id.File.of(fa.launcherPath));\n+                xml.writeEndElement(); \/\/ <Verb>\n+\n+                xml.writeEndElement(); \/\/ <Extension>\n+            }));\n+        }\n+\n+        return components;\n+    }\n+\n+    private List<String> addRootBranch(XMLStreamWriter xml, Path path)\n+            throws XMLStreamException, IOException {\n+        if (!ROOT_DIRS.contains(path.getName(0))) {\n+            throw throwInvalidPathException(path);\n+        }\n+\n+        Function<Path, String> createDirectoryName = dir -> null;\n+\n+        boolean sysDir = true;\n+        int levels = 1;\n+        var dirIt = path.iterator();\n+        xml.writeStartElement(\"DirectoryRef\");\n+        xml.writeAttribute(\"Id\", dirIt.next().toString());\n+\n+        path = path.getName(0);\n+        while (dirIt.hasNext()) {\n+            levels++;\n+            Path name = dirIt.next();\n+            path = path.resolve(name);\n+\n+            if (sysDir && !SYSTEM_DIRS.contains(path)) {\n+                sysDir = false;\n+                createDirectoryName = dir -> dir.getFileName().toString();\n+            }\n+\n+            final String directoryId;\n+            if (!sysDir && path.equals(installDir)) {\n+                directoryId = INSTALLDIR.toString();\n+            } else {\n+                directoryId = Id.Folder.of(path);\n+            }\n+            xml.writeStartElement(\"Directory\");\n+            xml.writeAttribute(\"Id\", directoryId);\n+\n+            String directoryName = createDirectoryName.apply(path);\n+            if (directoryName != null) {\n+                xml.writeAttribute(\"Name\", directoryName);\n+            }\n+        }\n+\n+        while (0 != levels--) {\n+            xml.writeEndElement();\n+        }\n+\n+        List<String> componentIds = new ArrayList<>();\n+\n+        return componentIds;\n+    }\n+\n+    private String addRemoveDirectoryComponent(XMLStreamWriter xml, Path path)\n+            throws XMLStreamException, IOException {\n+        return addComponent(xml, path, Component.RemoveFolder,\n+                unused -> xml.writeAttribute(\"On\", \"uninstall\"));\n+    }\n+\n+    private List<String> addDirectoryHierarchy(XMLStreamWriter xml)\n+            throws XMLStreamException, IOException {\n+\n+        Set<Path> allDirs = new HashSet<>();\n+        Set<Path> emptyDirs = new HashSet<>();\n+        appImage.transform(installedAppImage, new PathGroup.TransformHandler() {\n+            @Override\n+            public void copyFile(Path src, Path dst) throws IOException {\n+                Path dir = dst.getParent();\n+                createDirectory(dir);\n+                emptyDirs.remove(dir);\n+            }\n+\n+            @Override\n+            public void createDirectory(final Path dir) throws IOException {\n+                if (!allDirs.contains(dir)) {\n+                    emptyDirs.add(dir);\n+                }\n+\n+                Path it = dir;\n+                while (it != null && allDirs.add(it)) {\n+                    it = it.getParent();\n+                }\n+\n+                it = dir;\n+                while ((it = it.getParent()) != null && emptyDirs.remove(it));\n+            }\n+        });\n+\n+        List<String> componentIds = new ArrayList<>();\n+        for (var dir : emptyDirs) {\n+            componentIds.add(addComponent(xml, dir, Component.CreateFolder,\n+                    unused -> {}));\n+        }\n+\n+        if (!systemWide) {\n+            \/\/ Per-user install requires <RemoveFolder> component in every\n+            \/\/ directory.\n+            for (var dir : allDirs.stream()\n+                    .filter(Predicate.not(emptyDirs::contains))\n+                    .filter(Predicate.not(removeFolderItems::containsKey))\n+                    .collect(Collectors.toList())) {\n+                componentIds.add(addRemoveDirectoryComponent(xml, dir));\n+            }\n+        }\n+\n+        allDirs.remove(INSTALLDIR);\n+        for (var dir : allDirs) {\n+            xml.writeStartElement(\"DirectoryRef\");\n+            xml.writeAttribute(\"Id\", Id.Folder.of(dir.getParent()));\n+            xml.writeStartElement(\"Directory\");\n+            xml.writeAttribute(\"Id\", Id.Folder.of(dir));\n+            xml.writeAttribute(\"Name\", IOUtils.getFileName(dir).toString());\n+            xml.writeEndElement();\n+            xml.writeEndElement();\n+        }\n+\n+        componentIds.addAll(addRootBranch(xml, installDir));\n+\n+        return componentIds;\n+    }\n+\n+    private void addFilesComponentGroup(XMLStreamWriter xml)\n+            throws XMLStreamException, IOException {\n+\n+        List<Map.Entry<Path, Path>> files = new ArrayList<>();\n+        appImage.transform(installedAppImage, new PathGroup.TransformHandler() {\n+            @Override\n+            public void copyFile(Path src, Path dst) throws IOException {\n+                files.add(Map.entry(src, dst));\n+            }\n+\n+            @Override\n+            public void createDirectory(final Path dir) throws IOException {\n+            }\n+        });\n+\n+        List<String> componentIds = new ArrayList<>();\n+        for (var file : files) {\n+            Path src = file.getKey();\n+            Path dst = file.getValue();\n+\n+            componentIds.add(addComponent(xml, dst, Component.File, unused -> {\n+                xml.writeAttribute(\"Source\", src.normalize().toString());\n+                Path name = dst.getFileName();\n+                if (!name.equals(src.getFileName())) {\n+                    xml.writeAttribute(\"Name\", name.toString());\n+                }\n+            }));\n+        }\n+\n+        componentIds.addAll(addDirectoryHierarchy(xml));\n+\n+        componentIds.add(addDirectoryCleaner(xml, INSTALLDIR));\n+\n+        addComponentGroup(xml, \"Files\", componentIds);\n+    }\n+\n+    private void addIcons(XMLStreamWriter xml) throws\n+            XMLStreamException, IOException {\n+\n+        PathGroup srcPathGroup = appImage.pathGroup();\n+        PathGroup dstPathGroup = installedAppImage.pathGroup();\n+\n+        \/\/ Build list of copy operations for all .ico files in application image\n+        List<Map.Entry<Path, Path>> icoFiles = new ArrayList<>();\n+        srcPathGroup.transform(dstPathGroup, new PathGroup.TransformHandler() {\n+            @Override\n+            public void copyFile(Path src, Path dst) throws IOException {\n+                if (IOUtils.getFileName(src).toString().endsWith(\".ico\")) {\n+                    icoFiles.add(Map.entry(src, dst));\n+                }\n+            }\n+\n+            @Override\n+            public void createDirectory(Path dst) throws IOException {\n+            }\n+        });\n+\n+        for (var icoFile : icoFiles) {\n+            xml.writeStartElement(\"Icon\");\n+            xml.writeAttribute(\"Id\", Id.Icon.of(icoFile.getValue()));\n+            xml.writeAttribute(\"SourceFile\", icoFile.getKey().toString());\n+            xml.writeEndElement();\n+        }\n+    }\n+\n+    private void addRegistryKeyPath(XMLStreamWriter xml, Path path) throws\n+            XMLStreamException, IOException {\n+        addRegistryKeyPath(xml, path, () -> \"ProductCode\", () -> \"[ProductCode]\");\n+    }\n+\n+    private void addRegistryKeyPath(XMLStreamWriter xml, Path path,\n+            Supplier<String> nameAttr, Supplier<String> valueAttr) throws\n+            XMLStreamException, IOException {\n+\n+        String regRoot = USER_PROFILE_DIRS.stream().anyMatch(path::startsWith)\n+                || !systemWide ? \"HKCU\" : \"HKLM\";\n+\n+        xml.writeStartElement(\"RegistryKey\");\n+        xml.writeAttribute(\"Root\", regRoot);\n+        xml.writeAttribute(\"Key\", registryKeyPath);\n+        if (getWixVersion().compareTo(\"3.6\") < 0) {\n+            xml.writeAttribute(\"Action\", \"createAndRemoveOnUninstall\");\n+        }\n+        xml.writeStartElement(\"RegistryValue\");\n+        xml.writeAttribute(\"Type\", \"string\");\n+        xml.writeAttribute(\"KeyPath\", \"yes\");\n+        xml.writeAttribute(\"Name\", nameAttr.get());\n+        xml.writeAttribute(\"Value\", valueAttr.get());\n+        xml.writeEndElement(); \/\/ <RegistryValue>\n+        xml.writeEndElement(); \/\/ <RegistryKey>\n+    }\n+\n+    private String addDirectoryCleaner(XMLStreamWriter xml, Path path) throws\n+            XMLStreamException, IOException {\n+        if (getWixVersion().compareTo(\"3.6\") < 0) {\n+            return null;\n+        }\n+\n+        \/\/ rm -rf\n+        final String baseId = Id.of(path, \"rm_rf\");\n+        final String propertyId = baseId.toUpperCase();\n+        final String componentId = (\"c\" + baseId);\n+\n+        xml.writeStartElement(\"Property\");\n+        xml.writeAttribute(\"Id\", propertyId);\n+        xml.writeStartElement(\"RegistrySearch\");\n+        xml.writeAttribute(\"Id\", Id.of(path, \"regsearch\"));\n+        xml.writeAttribute(\"Root\", systemWide ? \"HKLM\" : \"HKCU\");\n+        xml.writeAttribute(\"Key\", registryKeyPath);\n+        xml.writeAttribute(\"Type\", \"raw\");\n+        xml.writeAttribute(\"Name\", propertyId);\n+        xml.writeEndElement(); \/\/ <RegistrySearch>\n+        xml.writeEndElement(); \/\/ <Property>\n+\n+        xml.writeStartElement(\"DirectoryRef\");\n+        xml.writeAttribute(\"Id\", INSTALLDIR.toString());\n+        Component.startElement(xml, componentId, \"*\");\n+\n+        addRegistryKeyPath(xml, INSTALLDIR, () -> propertyId, () -> {\n+            \/\/ The following code converts a path to value to be saved in registry.\n+            \/\/ E.g.:\n+            \/\/  INSTALLDIR -> [INSTALLDIR]\n+            \/\/  TERGETDIR\/ProgramFiles64Folder\/foo\/bar -> [ProgramFiles64Folder]foo\/bar\n+            final Path rootDir = KNOWN_DIRS.stream()\n+                    .sorted(Comparator.comparing(Path::getNameCount).reversed())\n+                    .filter(path::startsWith)\n+                    .findFirst().get();\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(String.format(\"[%s]\", rootDir.getFileName().toString()));\n+            sb.append(rootDir.relativize(path).toString());\n+            return sb.toString();\n+        });\n+\n+        xml.writeStartElement(\n+                \"http:\/\/schemas.microsoft.com\/wix\/UtilExtension\",\n+                \"RemoveFolderEx\");\n+        xml.writeAttribute(\"On\", \"uninstall\");\n+        xml.writeAttribute(\"Property\", propertyId);\n+        xml.writeEndElement(); \/\/ <RemoveFolderEx>\n+        xml.writeEndElement(); \/\/ <Component>\n+        xml.writeEndElement(); \/\/ <DirectoryRef>\n+\n+        return componentId;\n+    }\n+\n+    private static IllegalArgumentException throwInvalidPathException(Path v) {\n+        throw new IllegalArgumentException(String.format(\"Invalid path [%s]\", v));\n+    }\n+\n+    enum ShortcutsFolder {\n+        ProgramMenu(PROGRAM_MENU_PATH, Arguments.CLIOptions.WIN_MENU_HINT,\n+                \"JP_INSTALL_STARTMENU_SHORTCUT\", \"JpStartMenuShortcutPrompt\"),\n+        Desktop(DESKTOP_PATH, Arguments.CLIOptions.WIN_SHORTCUT_HINT,\n+                \"JP_INSTALL_DESKTOP_SHORTCUT\", \"JpDesktopShortcutPrompt\");\n+\n+        private ShortcutsFolder(Path root, Arguments.CLIOptions cliOption,\n+                String property, String wixVariableName) {\n+            this.root = root;\n+            this.bundlerParam = new StandardBundlerParam<>(\n+                    cliOption.getId(),\n+                    Boolean.class,\n+                    params -> false,\n+                    \/\/ valueOf(null) is false,\n+                    \/\/ and we actually do want null in some cases\n+                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ? false : Boolean.valueOf(s)\n+            );\n+            this.wixVariableName = wixVariableName;\n+            this.property = property;\n+        }\n+\n+        Path getPath(WixAppImageFragmentBuilder outer) {\n+            if (this == ProgramMenu) {\n+                return root.resolve(outer.programMenuFolderName);\n+            }\n+            return root;\n+        }\n+\n+        boolean requested(Map<String, ? super Object> params) {\n+            return bundlerParam.fetchFrom(params);\n+        }\n+\n+        String getWixVariableName() {\n+            return wixVariableName;\n+        }\n+\n+        private final Path root;\n+        private final String property;\n+        private final String wixVariableName;\n+        private final StandardBundlerParam<Boolean> bundlerParam;\n+    }\n+\n+    private boolean systemWide;\n+\n+    private String registryKeyPath;\n+\n+    private Path installDir;\n+\n+    private String programMenuFolderName;\n+\n+    private List<FileAssociation> associations;\n+\n+    private Set<ShortcutsFolder> shortcutFolders;\n+\n+    private List<Path> launcherPaths;\n+\n+    private ApplicationLayout appImage;\n+    private ApplicationLayout installedAppImage;\n+\n+    private Map<Path, Integer> removeFolderItems;\n+    private Set<String> defaultedMimes;\n+\n+    private final static Path TARGETDIR = Path.of(\"TARGETDIR\");\n+\n+    private final static Path INSTALLDIR = Path.of(\"INSTALLDIR\");\n+\n+    private final static Set<Path> ROOT_DIRS = Set.of(INSTALLDIR, TARGETDIR);\n+\n+    private final static Path PROGRAM_MENU_PATH = TARGETDIR.resolve(\"ProgramMenuFolder\");\n+\n+    private final static Path DESKTOP_PATH = TARGETDIR.resolve(\"DesktopFolder\");\n+\n+    private final static Path PROGRAM_FILES = TARGETDIR.resolve(\n+            is64Bit() ? \"ProgramFiles64Folder\" : \"ProgramFilesFolder\");\n+\n+    private final static Path LOCAL_PROGRAM_FILES = TARGETDIR.resolve(\"LocalAppDataFolder\");\n+\n+    private final static Set<Path> SYSTEM_DIRS = Set.of(TARGETDIR,\n+            PROGRAM_MENU_PATH, DESKTOP_PATH, PROGRAM_FILES, LOCAL_PROGRAM_FILES);\n+\n+    private final static Set<Path> KNOWN_DIRS = Stream.of(Set.of(INSTALLDIR),\n+            SYSTEM_DIRS).flatMap(Set::stream).collect(\n+            Collectors.toUnmodifiableSet());\n+\n+    private final static Set<Path> USER_PROFILE_DIRS = Set.of(LOCAL_PROGRAM_FILES,\n+            PROGRAM_MENU_PATH, DESKTOP_PATH);\n+\n+    private static final StandardBundlerParam<String> MENU_GROUP =\n+            new StandardBundlerParam<>(\n+                    Arguments.CLIOptions.WIN_MENU_GROUP.getId(),\n+                    String.class,\n+                    params -> I18N.getString(\"param.menu-group.default\"),\n+                    (s, p) -> s\n+            );\n+\n+    private static final BundlerParamInfo<String> WINDOWS_INSTALL_DIR =\n+            new StandardBundlerParam<>(\n+            \"windows-install-dir\",\n+            String.class,\n+            params -> {\n+                 String dir = INSTALL_DIR.fetchFrom(params);\n+                 if (dir != null) {\n+                     if (dir.contains(\":\") || dir.contains(\"..\")) {\n+                         Log.error(MessageFormat.format(I18N.getString(\n+                                \"message.invalid.install.dir\"), dir,\n+                                APP_NAME.fetchFrom(params)));\n+                     } else {\n+                        if (dir.startsWith(\"\\\\\")) {\n+                             dir = dir.substring(1);\n+                        }\n+                        if (dir.endsWith(\"\\\\\")) {\n+                             dir = dir.substring(0, dir.length() - 1);\n+                        }\n+                        return dir;\n+                     }\n+                 }\n+                 return APP_NAME.fetchFrom(params); \/\/ Default to app name\n+             },\n+            (s, p) -> s\n+    );\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":893,"deletions":0,"binary":false,"changes":893,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import jdk.jpackage.internal.IOUtils.XmlConsumer;\n+import jdk.jpackage.internal.OverridableResource.Source;\n+import static jdk.jpackage.internal.OverridableResource.createResource;\n+import static jdk.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;\n+\n+\/**\n+ * Creates WiX fragment.\n+ *\/\n+abstract class WixFragmentBuilder {\n+\n+    void setWixVersion(DottedVersion v) {\n+        wixVersion = v;\n+    }\n+\n+    void setOutputFileName(String v) {\n+        outputFileName = v;\n+    }\n+\n+    void initFromParams(Map<String, ? super Object> params) {\n+        wixVariables = null;\n+        additionalResources = null;\n+        configRoot = CONFIG_ROOT.fetchFrom(params);\n+        fragmentResource = createResource(outputFileName, params).setSourceOrder(\n+                Source.ResourceDir);\n+    }\n+\n+    void logWixFeatures() {\n+        if (wixVersion.compareTo(\"3.6\") >= 0) {\n+            Log.verbose(MessageFormat.format(I18N.getString(\n+                    \"message.use-wix36-features\"), wixVersion));\n+        }\n+    }\n+\n+    void configureWixPipeline(WixPipeline wixPipeline) {\n+        wixPipeline.addSource(configRoot.resolve(outputFileName),\n+                Optional.ofNullable(wixVariables).map(WixVariables::getValues).orElse(\n+                        null));\n+    }\n+\n+    void addFilesToConfigRoot() throws IOException {\n+        Path fragmentPath = configRoot.resolve(outputFileName);\n+        if (fragmentResource.saveToFile(fragmentPath) == null) {\n+            createWixSource(fragmentPath, xml -> {\n+                for (var fragmentWriter : getFragmentWriters()) {\n+                    xml.writeStartElement(\"Fragment\");\n+                    fragmentWriter.accept(xml);\n+                    xml.writeEndElement();  \/\/ <Fragment>\n+                }\n+            });\n+        }\n+\n+        if (additionalResources != null) {\n+            for (var resource : additionalResources) {\n+                resource.resource.saveToFile(configRoot.resolve(\n+                        resource.saveAsName));\n+            }\n+        }\n+    }\n+\n+    DottedVersion getWixVersion() {\n+        return wixVersion;\n+    }\n+\n+    static boolean is64Bit() {\n+        return !(\"x86\".equals(System.getProperty(\"os.arch\")));\n+    }\n+\n+    protected Path getConfigRoot() {\n+        return configRoot;\n+    }\n+\n+    protected abstract Collection<XmlConsumer> getFragmentWriters();\n+\n+    protected void defineWixVariable(String variableName) {\n+        setWixVariable(variableName, \"yes\");\n+    }\n+\n+    protected void setWixVariable(String variableName, String variableValue) {\n+        if (wixVariables == null) {\n+            wixVariables = new WixVariables();\n+        }\n+        wixVariables.setWixVariable(variableName, variableValue);\n+    }\n+\n+    protected void addResource(OverridableResource resource, String saveAsName) {\n+        if (additionalResources == null) {\n+            additionalResources = new ArrayList<>();\n+        }\n+        additionalResources.add(new ResourceWithName(resource, saveAsName));\n+    }\n+\n+    static void createWixSource(Path file, XmlConsumer xmlConsumer)\n+            throws IOException {\n+        IOUtils.createXml(file, xml -> {\n+            xml.writeStartElement(\"Wix\");\n+            xml.writeDefaultNamespace(\"http:\/\/schemas.microsoft.com\/wix\/2006\/wi\");\n+            xml.writeNamespace(\"util\",\n+                    \"http:\/\/schemas.microsoft.com\/wix\/UtilExtension\");\n+\n+            xmlConsumer.accept(xml);\n+\n+            xml.writeEndElement(); \/\/ <Wix>\n+        });\n+    }\n+\n+    private static class ResourceWithName {\n+\n+        ResourceWithName(OverridableResource resource, String saveAsName) {\n+            this.resource = resource;\n+            this.saveAsName = saveAsName;\n+        }\n+        private final OverridableResource resource;\n+        private final String saveAsName;\n+    }\n+\n+    private DottedVersion wixVersion;\n+    private WixVariables wixVariables;\n+    private List<ResourceWithName> additionalResources;\n+    private OverridableResource fragmentResource;\n+    private String outputFileName;\n+    private Path configRoot;\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixFragmentBuilder.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -115,1 +115,1 @@\n-                \"-arch\", WixSourcesBuilder.is64Bit() ? \"x64\" : \"x86\",\n+                \"-arch\", WixFragmentBuilder.is64Bit() ? \"x64\" : \"x86\",\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixPipeline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,897 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Path;\n-import java.nio.file.Files;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.UUID;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.xml.stream.XMLStreamException;\n-import javax.xml.stream.XMLStreamWriter;\n-import jdk.jpackage.internal.IOUtils.XmlConsumer;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALL_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.WinMsiBundler.MSI_SYSTEM_WIDE;\n-\n-\/**\n- * Creates application WiX source files.\n- *\/\n-class WixSourcesBuilder {\n-\n-    WixSourcesBuilder setWixVersion(DottedVersion v) {\n-        wixVersion = v;\n-        return this;\n-    }\n-\n-    WixSourcesBuilder initFromParams(Path appImageRoot,\n-            Map<String, ? super Object> params) {\n-        Supplier<ApplicationLayout> appImageSupplier = () -> {\n-            if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-                return ApplicationLayout.javaRuntime();\n-            } else {\n-                return ApplicationLayout.platformAppImage();\n-            }\n-        };\n-\n-        systemWide = MSI_SYSTEM_WIDE.fetchFrom(params);\n-\n-        registryKeyPath = Path.of(\"Software\",\n-                VENDOR.fetchFrom(params),\n-                APP_NAME.fetchFrom(params),\n-                VERSION.fetchFrom(params)).toString();\n-\n-        installDir = (systemWide ? PROGRAM_FILES : LOCAL_PROGRAM_FILES).resolve(\n-                WINDOWS_INSTALL_DIR.fetchFrom(params));\n-\n-        do {\n-            ApplicationLayout layout = appImageSupplier.get();\n-            \/\/ Don't want AppImageFile.FILENAME in installed application.\n-            \/\/ Register it with app image at a role without a match in installed\n-            \/\/ app layout to exclude it from layout transformation.\n-            layout.pathGroup().setPath(new Object(),\n-                    AppImageFile.getPathInAppImage(Path.of(\"\")));\n-\n-            \/\/ Want absolute paths to source files in generated WiX sources.\n-            \/\/ This is to handle scenario if sources would be processed from\n-            \/\/ differnt current directory.\n-            appImage = layout.resolveAt(appImageRoot.toAbsolutePath().normalize());\n-        } while (false);\n-\n-        installedAppImage = appImageSupplier.get().resolveAt(INSTALLDIR);\n-\n-        shortcutFolders = new HashSet<>();\n-        if (SHORTCUT_HINT.fetchFrom(params)) {\n-            shortcutFolders.add(ShortcutsFolder.Desktop);\n-        }\n-        if (MENU_HINT.fetchFrom(params)) {\n-            shortcutFolders.add(ShortcutsFolder.ProgramMenu);\n-        }\n-\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            launcherPaths = Collections.emptyList();\n-        } else {\n-            launcherPaths = AppImageFile.getLauncherNames(appImageRoot, params).stream()\n-                    .map(name -> installedAppImage.launchersDirectory().resolve(name))\n-                    .map(WixSourcesBuilder::addExeSuffixToPath)\n-                    .collect(Collectors.toList());\n-        }\n-\n-        programMenuFolderName = MENU_GROUP.fetchFrom(params);\n-\n-        initFileAssociations(params);\n-\n-        return this;\n-    }\n-\n-    void createMainFragment(Path file) throws IOException {\n-        removeFolderItems = new HashMap<>();\n-        defaultedMimes = new HashSet<>();\n-        IOUtils.createXml(file, xml -> {\n-            xml.writeStartElement(\"Wix\");\n-            xml.writeDefaultNamespace(\"http:\/\/schemas.microsoft.com\/wix\/2006\/wi\");\n-            xml.writeNamespace(\"util\",\n-                    \"http:\/\/schemas.microsoft.com\/wix\/UtilExtension\");\n-\n-            xml.writeStartElement(\"Fragment\");\n-\n-            addFaComponentGroup(xml);\n-\n-            addShortcutComponentGroup(xml);\n-\n-            addFilesComponentGroup(xml);\n-\n-            xml.writeEndElement();  \/\/ <Fragment>\n-\n-            addIconsFragment(xml);\n-\n-            xml.writeEndElement(); \/\/ <Wix>\n-        });\n-    }\n-\n-    void logWixFeatures() {\n-        if (wixVersion.compareTo(\"3.6\") >= 0) {\n-            Log.verbose(MessageFormat.format(I18N.getString(\n-                    \"message.use-wix36-features\"), wixVersion));\n-        }\n-    }\n-\n-    static boolean is64Bit() {\n-        return !(\"x86\".equals(System.getProperty(\"os.arch\")));\n-    }\n-\n-    private void normalizeFileAssociation(FileAssociation fa) {\n-        fa.launcherPath = addExeSuffixToPath(\n-                installedAppImage.launchersDirectory().resolve(fa.launcherPath));\n-\n-        if (fa.iconPath != null && !Files.exists(fa.iconPath)) {\n-            fa.iconPath = null;\n-        }\n-\n-        if (fa.iconPath != null) {\n-            fa.iconPath = fa.iconPath.toAbsolutePath();\n-        }\n-\n-        \/\/ Filter out empty extensions.\n-        fa.extensions = fa.extensions.stream().filter(Predicate.not(\n-                String::isEmpty)).collect(Collectors.toList());\n-    }\n-\n-    private static Path addExeSuffixToPath(Path path) {\n-        return IOUtils.addSuffix(path, \".exe\");\n-    }\n-\n-    private Path getInstalledFaIcoPath(FileAssociation fa) {\n-        String fname = String.format(\"fa_%s.ico\", String.join(\"_\", fa.extensions));\n-        return installedAppImage.destktopIntegrationDirectory().resolve(fname);\n-    }\n-\n-    private void initFileAssociations(Map<String, ? super Object> params) {\n-        associations = FileAssociation.fetchFrom(params).stream()\n-                .peek(this::normalizeFileAssociation)\n-                \/\/ Filter out file associations without extensions.\n-                .filter(fa -> !fa.extensions.isEmpty())\n-                .collect(Collectors.toList());\n-\n-        associations.stream().filter(fa -> fa.iconPath != null).forEach(fa -> {\n-            \/\/ Need to add fa icon in the image.\n-            Object key = new Object();\n-            appImage.pathGroup().setPath(key, fa.iconPath);\n-            installedAppImage.pathGroup().setPath(key, getInstalledFaIcoPath(fa));\n-        });\n-    }\n-\n-    private static UUID createNameUUID(String str) {\n-        return UUID.nameUUIDFromBytes(str.getBytes(StandardCharsets.UTF_8));\n-    }\n-\n-    private static UUID createNameUUID(Path path, String role) {\n-        if (path.isAbsolute() || !ROOT_DIRS.contains(path.getName(0))) {\n-            throw throwInvalidPathException(path);\n-        }\n-        \/\/ Paths are case insensitive on Windows\n-        String keyPath = path.toString().toLowerCase();\n-        if (role != null) {\n-            keyPath = role + \"@\" + keyPath;\n-        }\n-        return createNameUUID(keyPath);\n-    }\n-\n-    \/**\n-     * Value for Id attribute of various WiX elements.\n-     *\/\n-    enum Id {\n-        File,\n-        Folder(\"dir\"),\n-        Shortcut,\n-        ProgId,\n-        Icon,\n-        CreateFolder(\"mkdir\"),\n-        RemoveFolder(\"rm\");\n-\n-        Id() {\n-            this.prefix = name().toLowerCase();\n-        }\n-\n-        Id(String prefix) {\n-            this.prefix = prefix;\n-        }\n-\n-        String of(Path path) {\n-            if (this == Folder && KNOWN_DIRS.contains(path)) {\n-                return IOUtils.getFileName(path).toString();\n-            }\n-\n-            String result = of(path, prefix, name());\n-\n-            if (this == Icon) {\n-                \/\/ Icon id constructed from UUID value is too long and triggers\n-                \/\/ CNDL1000 warning, so use Java hash code instead.\n-                result = String.format(\"%s%d\", prefix, result.hashCode()).replace(\n-                        \"-\", \"_\");\n-            }\n-\n-            return result;\n-        }\n-\n-        private static String of(Path path, String prefix, String role) {\n-            Objects.requireNonNull(role);\n-            Objects.requireNonNull(prefix);\n-            return String.format(\"%s%s\", prefix,\n-                    createNameUUID(path, role).toString().replace(\"-\", \"\"));\n-        }\n-\n-        static String of(Path path, String prefix) {\n-            return of(path, prefix, prefix);\n-        }\n-\n-        private final String prefix;\n-    }\n-\n-    enum Component {\n-        File(cfg().file()),\n-        Shortcut(cfg().file().withRegistryKeyPath()),\n-        ProgId(cfg().file().withRegistryKeyPath()),\n-        CreateFolder(cfg().withRegistryKeyPath()),\n-        RemoveFolder(cfg().withRegistryKeyPath());\n-\n-        Component() {\n-            this.cfg = cfg();\n-            this.id = Id.valueOf(name());\n-        }\n-\n-        Component(Config cfg) {\n-            this.cfg = cfg;\n-            this.id = Id.valueOf(name());\n-        }\n-\n-        UUID guidOf(Path path) {\n-            return createNameUUID(path, name());\n-        }\n-\n-        String idOf(Path path) {\n-            return id.of(path);\n-        }\n-\n-        boolean isRegistryKeyPath() {\n-            return cfg.withRegistryKeyPath;\n-        }\n-\n-        boolean isFile() {\n-            return cfg.isFile;\n-        }\n-\n-        static void startElement(XMLStreamWriter xml, String componentId,\n-                String componentGuid) throws XMLStreamException, IOException {\n-            xml.writeStartElement(\"Component\");\n-            xml.writeAttribute(\"Win64\", is64Bit() ? \"yes\" : \"no\");\n-            xml.writeAttribute(\"Id\", componentId);\n-            xml.writeAttribute(\"Guid\", componentGuid);\n-        }\n-\n-        private static final class Config {\n-            Config withRegistryKeyPath() {\n-                withRegistryKeyPath = true;\n-                return this;\n-            }\n-\n-            Config file() {\n-                isFile = true;\n-                return this;\n-            }\n-\n-            private boolean isFile;\n-            private boolean withRegistryKeyPath;\n-        }\n-\n-        private static Config cfg() {\n-            return new Config();\n-        }\n-\n-        private final Config cfg;\n-        private final Id id;\n-    };\n-\n-    private static void addComponentGroup(XMLStreamWriter xml, String id,\n-            List<String> componentIds) throws XMLStreamException, IOException {\n-        xml.writeStartElement(\"ComponentGroup\");\n-        xml.writeAttribute(\"Id\", id);\n-        componentIds = componentIds.stream().filter(Objects::nonNull).collect(\n-                Collectors.toList());\n-        for (var componentId : componentIds) {\n-            xml.writeStartElement(\"ComponentRef\");\n-            xml.writeAttribute(\"Id\", componentId);\n-            xml.writeEndElement();\n-        }\n-        xml.writeEndElement();\n-    }\n-\n-    private String addComponent(XMLStreamWriter xml, Path path,\n-            Component role, XmlConsumer xmlConsumer) throws XMLStreamException,\n-            IOException {\n-\n-        final Path directoryRefPath;\n-        if (role.isFile()) {\n-            directoryRefPath = path.getParent();\n-        } else {\n-            directoryRefPath = path;\n-        }\n-\n-        xml.writeStartElement(\"DirectoryRef\");\n-        xml.writeAttribute(\"Id\", Id.Folder.of(directoryRefPath));\n-\n-        final String componentId = \"c\" + role.idOf(path);\n-        Component.startElement(xml, componentId, String.format(\"{%s}\",\n-                role.guidOf(path)));\n-\n-        boolean isRegistryKeyPath = !systemWide || role.isRegistryKeyPath();\n-        if (isRegistryKeyPath) {\n-            addRegistryKeyPath(xml, directoryRefPath);\n-            if ((role.isFile() || (role == Component.CreateFolder\n-                    && !systemWide)) && !SYSTEM_DIRS.contains(directoryRefPath)) {\n-                xml.writeStartElement(\"RemoveFolder\");\n-                int counter = Optional.ofNullable(removeFolderItems.get(\n-                        directoryRefPath)).orElse(Integer.valueOf(0)).intValue() + 1;\n-                removeFolderItems.put(directoryRefPath, counter);\n-                xml.writeAttribute(\"Id\", String.format(\"%s_%d\", Id.RemoveFolder.of(\n-                        directoryRefPath), counter));\n-                xml.writeAttribute(\"On\", \"uninstall\");\n-                xml.writeEndElement();\n-            }\n-        }\n-\n-        xml.writeStartElement(role.name());\n-        if (role != Component.CreateFolder) {\n-            xml.writeAttribute(\"Id\", role.idOf(path));\n-        }\n-\n-        if (!isRegistryKeyPath) {\n-            xml.writeAttribute(\"KeyPath\", \"yes\");\n-        }\n-\n-        xmlConsumer.accept(xml);\n-        xml.writeEndElement();\n-\n-        xml.writeEndElement(); \/\/ <Component>\n-        xml.writeEndElement(); \/\/ <DirectoryRef>\n-\n-        return componentId;\n-    }\n-\n-    private void addFaComponentGroup(XMLStreamWriter xml)\n-            throws XMLStreamException, IOException {\n-\n-        List<String> componentIds = new ArrayList<>();\n-        for (var fa : associations) {\n-            componentIds.addAll(addFaComponents(xml, fa));\n-        }\n-        addComponentGroup(xml, \"FileAssociations\", componentIds);\n-    }\n-\n-    private void addShortcutComponentGroup(XMLStreamWriter xml) throws\n-            XMLStreamException, IOException {\n-        List<String> componentIds = new ArrayList<>();\n-        Set<ShortcutsFolder> defineShortcutFolders = new HashSet<>();\n-        for (var launcherPath : launcherPaths) {\n-            for (var folder : shortcutFolders) {\n-                String componentId = addShortcutComponent(xml, launcherPath,\n-                        folder);\n-                if (componentId != null) {\n-                    defineShortcutFolders.add(folder);\n-                    componentIds.add(componentId);\n-                }\n-            }\n-        }\n-\n-        for (var folder : defineShortcutFolders) {\n-            Path path = folder.getPath(this);\n-            componentIds.addAll(addRootBranch(xml, path));\n-        }\n-\n-        addComponentGroup(xml, \"Shortcuts\", componentIds);\n-    }\n-\n-    private String addShortcutComponent(XMLStreamWriter xml, Path launcherPath,\n-            ShortcutsFolder folder) throws XMLStreamException, IOException {\n-        Objects.requireNonNull(folder);\n-\n-        if (!INSTALLDIR.equals(launcherPath.getName(0))) {\n-            throw throwInvalidPathException(launcherPath);\n-        }\n-\n-        String launcherBasename = IOUtils.replaceSuffix(\n-                IOUtils.getFileName(launcherPath), \"\").toString();\n-\n-        Path shortcutPath = folder.getPath(this).resolve(launcherBasename);\n-        return addComponent(xml, shortcutPath, Component.Shortcut, unused -> {\n-            final Path icoFile = IOUtils.addSuffix(\n-                    installedAppImage.destktopIntegrationDirectory().resolve(\n-                            launcherBasename), \".ico\");\n-\n-            xml.writeAttribute(\"Name\", launcherBasename);\n-            xml.writeAttribute(\"WorkingDirectory\", INSTALLDIR.toString());\n-            xml.writeAttribute(\"Advertise\", \"no\");\n-            xml.writeAttribute(\"IconIndex\", \"0\");\n-            xml.writeAttribute(\"Target\", String.format(\"[#%s]\",\n-                    Component.File.idOf(launcherPath)));\n-            xml.writeAttribute(\"Icon\", Id.Icon.of(icoFile));\n-        });\n-    }\n-\n-    private List<String> addFaComponents(XMLStreamWriter xml,\n-            FileAssociation fa) throws XMLStreamException, IOException {\n-        List<String> components = new ArrayList<>();\n-        for (var extension: fa.extensions) {\n-            Path path = INSTALLDIR.resolve(String.format(\"%s_%s\", extension,\n-                    fa.launcherPath.getFileName()));\n-            components.add(addComponent(xml, path, Component.ProgId, unused -> {\n-                xml.writeAttribute(\"Description\", fa.description);\n-\n-                if (fa.iconPath != null) {\n-                    xml.writeAttribute(\"Icon\", Id.File.of(getInstalledFaIcoPath(\n-                            fa)));\n-                    xml.writeAttribute(\"IconIndex\", \"0\");\n-                }\n-\n-                xml.writeStartElement(\"Extension\");\n-                xml.writeAttribute(\"Id\", extension);\n-                xml.writeAttribute(\"Advertise\", \"no\");\n-\n-                var mimeIt = fa.mimeTypes.iterator();\n-                if (mimeIt.hasNext()) {\n-                    String mime = mimeIt.next();\n-                    xml.writeAttribute(\"ContentType\", mime);\n-\n-                    if (!defaultedMimes.contains(mime)) {\n-                        xml.writeStartElement(\"MIME\");\n-                        xml.writeAttribute(\"ContentType\", mime);\n-                        xml.writeAttribute(\"Default\", \"yes\");\n-                        xml.writeEndElement();\n-                        defaultedMimes.add(mime);\n-                    }\n-                }\n-\n-                xml.writeStartElement(\"Verb\");\n-                xml.writeAttribute(\"Id\", \"open\");\n-                xml.writeAttribute(\"Command\", \"Open\");\n-                xml.writeAttribute(\"Argument\", \"\\\"%1\\\"\");\n-                xml.writeAttribute(\"TargetFile\", Id.File.of(fa.launcherPath));\n-                xml.writeEndElement(); \/\/ <Verb>\n-\n-                xml.writeEndElement(); \/\/ <Extension>\n-            }));\n-        }\n-\n-        return components;\n-    }\n-\n-    private List<String> addRootBranch(XMLStreamWriter xml, Path path)\n-            throws XMLStreamException, IOException {\n-        if (!ROOT_DIRS.contains(path.getName(0))) {\n-            throw throwInvalidPathException(path);\n-        }\n-\n-        Function<Path, String> createDirectoryName = dir -> null;\n-\n-        boolean sysDir = true;\n-        int levels = 1;\n-        var dirIt = path.iterator();\n-        xml.writeStartElement(\"DirectoryRef\");\n-        xml.writeAttribute(\"Id\", dirIt.next().toString());\n-\n-        path = path.getName(0);\n-        while (dirIt.hasNext()) {\n-            levels++;\n-            Path name = dirIt.next();\n-            path = path.resolve(name);\n-\n-            if (sysDir && !SYSTEM_DIRS.contains(path)) {\n-                sysDir = false;\n-                createDirectoryName = dir -> dir.getFileName().toString();\n-            }\n-\n-            final String directoryId;\n-            if (!sysDir && path.equals(installDir)) {\n-                directoryId = INSTALLDIR.toString();\n-            } else {\n-                directoryId = Id.Folder.of(path);\n-            }\n-            xml.writeStartElement(\"Directory\");\n-            xml.writeAttribute(\"Id\", directoryId);\n-\n-            String directoryName = createDirectoryName.apply(path);\n-            if (directoryName != null) {\n-                xml.writeAttribute(\"Name\", directoryName);\n-            }\n-        }\n-\n-        while (0 != levels--) {\n-            xml.writeEndElement();\n-        }\n-\n-        List<String> componentIds = new ArrayList<>();\n-\n-        return componentIds;\n-    }\n-\n-    private String addRemoveDirectoryComponent(XMLStreamWriter xml, Path path)\n-            throws XMLStreamException, IOException {\n-        return addComponent(xml, path, Component.RemoveFolder,\n-                unused -> xml.writeAttribute(\"On\", \"uninstall\"));\n-    }\n-\n-    private List<String> addDirectoryHierarchy(XMLStreamWriter xml)\n-            throws XMLStreamException, IOException {\n-\n-        Set<Path> allDirs = new HashSet<>();\n-        Set<Path> emptyDirs = new HashSet<>();\n-        appImage.transform(installedAppImage, new PathGroup.TransformHandler() {\n-            @Override\n-            public void copyFile(Path src, Path dst) throws IOException {\n-                Path dir = dst.getParent();\n-                createDirectory(dir);\n-                emptyDirs.remove(dir);\n-            }\n-\n-            @Override\n-            public void createDirectory(final Path dir) throws IOException {\n-                if (!allDirs.contains(dir)) {\n-                    emptyDirs.add(dir);\n-                }\n-\n-                Path it = dir;\n-                while (it != null && allDirs.add(it)) {\n-                    it = it.getParent();\n-                }\n-\n-                it = dir;\n-                while ((it = it.getParent()) != null && emptyDirs.remove(it));\n-            }\n-        });\n-\n-        List<String> componentIds = new ArrayList<>();\n-        for (var dir : emptyDirs) {\n-            componentIds.add(addComponent(xml, dir, Component.CreateFolder,\n-                    unused -> {}));\n-        }\n-\n-        if (!systemWide) {\n-            \/\/ Per-user install requires <RemoveFolder> component in every\n-            \/\/ directory.\n-            for (var dir : allDirs.stream()\n-                    .filter(Predicate.not(emptyDirs::contains))\n-                    .filter(Predicate.not(removeFolderItems::containsKey))\n-                    .collect(Collectors.toList())) {\n-                componentIds.add(addRemoveDirectoryComponent(xml, dir));\n-            }\n-        }\n-\n-        allDirs.remove(INSTALLDIR);\n-        for (var dir : allDirs) {\n-            xml.writeStartElement(\"DirectoryRef\");\n-            xml.writeAttribute(\"Id\", Id.Folder.of(dir.getParent()));\n-            xml.writeStartElement(\"Directory\");\n-            xml.writeAttribute(\"Id\", Id.Folder.of(dir));\n-            xml.writeAttribute(\"Name\", IOUtils.getFileName(dir).toString());\n-            xml.writeEndElement();\n-            xml.writeEndElement();\n-        }\n-\n-        componentIds.addAll(addRootBranch(xml, installDir));\n-\n-        return componentIds;\n-    }\n-\n-    private void addFilesComponentGroup(XMLStreamWriter xml)\n-            throws XMLStreamException, IOException {\n-\n-        List<Map.Entry<Path, Path>> files = new ArrayList<>();\n-        appImage.transform(installedAppImage, new PathGroup.TransformHandler() {\n-            @Override\n-            public void copyFile(Path src, Path dst) throws IOException {\n-                files.add(Map.entry(src, dst));\n-            }\n-\n-            @Override\n-            public void createDirectory(final Path dir) throws IOException {\n-            }\n-        });\n-\n-        List<String> componentIds = new ArrayList<>();\n-        for (var file : files) {\n-            Path src = file.getKey();\n-            Path dst = file.getValue();\n-\n-            componentIds.add(addComponent(xml, dst, Component.File, unused -> {\n-                xml.writeAttribute(\"Source\", src.normalize().toString());\n-                Path name = dst.getFileName();\n-                if (!name.equals(src.getFileName())) {\n-                    xml.writeAttribute(\"Name\", name.toString());\n-                }\n-            }));\n-        }\n-\n-        componentIds.addAll(addDirectoryHierarchy(xml));\n-\n-        componentIds.add(addDirectoryCleaner(xml, INSTALLDIR));\n-\n-        addComponentGroup(xml, \"Files\", componentIds);\n-    }\n-\n-    private void addIconsFragment(XMLStreamWriter xml) throws\n-            XMLStreamException, IOException {\n-\n-        PathGroup srcPathGroup = appImage.pathGroup();\n-        PathGroup dstPathGroup = installedAppImage.pathGroup();\n-\n-        \/\/ Build list of copy operations for all .ico files in application image\n-        List<Map.Entry<Path, Path>> icoFiles = new ArrayList<>();\n-        srcPathGroup.transform(dstPathGroup, new PathGroup.TransformHandler() {\n-            @Override\n-            public void copyFile(Path src, Path dst) throws IOException {\n-                if (IOUtils.getFileName(src).toString().endsWith(\".ico\")) {\n-                    icoFiles.add(Map.entry(src, dst));\n-                }\n-            }\n-\n-            @Override\n-            public void createDirectory(Path dst) throws IOException {\n-            }\n-        });\n-\n-        xml.writeStartElement(\"Fragment\");\n-        for (var icoFile : icoFiles) {\n-            xml.writeStartElement(\"Icon\");\n-            xml.writeAttribute(\"Id\", Id.Icon.of(icoFile.getValue()));\n-            xml.writeAttribute(\"SourceFile\", icoFile.getKey().toString());\n-            xml.writeEndElement();\n-        }\n-        xml.writeEndElement();\n-    }\n-\n-    private void addRegistryKeyPath(XMLStreamWriter xml, Path path) throws\n-            XMLStreamException, IOException {\n-        addRegistryKeyPath(xml, path, () -> \"ProductCode\", () -> \"[ProductCode]\");\n-    }\n-\n-    private void addRegistryKeyPath(XMLStreamWriter xml, Path path,\n-            Supplier<String> nameAttr, Supplier<String> valueAttr) throws\n-            XMLStreamException, IOException {\n-\n-        String regRoot = USER_PROFILE_DIRS.stream().anyMatch(path::startsWith)\n-                || !systemWide ? \"HKCU\" : \"HKLM\";\n-\n-        xml.writeStartElement(\"RegistryKey\");\n-        xml.writeAttribute(\"Root\", regRoot);\n-        xml.writeAttribute(\"Key\", registryKeyPath);\n-        if (wixVersion.compareTo(\"3.6\") < 0) {\n-            xml.writeAttribute(\"Action\", \"createAndRemoveOnUninstall\");\n-        }\n-        xml.writeStartElement(\"RegistryValue\");\n-        xml.writeAttribute(\"Type\", \"string\");\n-        xml.writeAttribute(\"KeyPath\", \"yes\");\n-        xml.writeAttribute(\"Name\", nameAttr.get());\n-        xml.writeAttribute(\"Value\", valueAttr.get());\n-        xml.writeEndElement(); \/\/ <RegistryValue>\n-        xml.writeEndElement(); \/\/ <RegistryKey>\n-    }\n-\n-    private String addDirectoryCleaner(XMLStreamWriter xml, Path path) throws\n-            XMLStreamException, IOException {\n-        if (wixVersion.compareTo(\"3.6\") < 0) {\n-            return null;\n-        }\n-\n-        \/\/ rm -rf\n-        final String baseId = Id.of(path, \"rm_rf\");\n-        final String propertyId = baseId.toUpperCase();\n-        final String componentId = (\"c\" + baseId);\n-\n-        xml.writeStartElement(\"Property\");\n-        xml.writeAttribute(\"Id\", propertyId);\n-        xml.writeStartElement(\"RegistrySearch\");\n-        xml.writeAttribute(\"Id\", Id.of(path, \"regsearch\"));\n-        xml.writeAttribute(\"Root\", systemWide ? \"HKLM\" : \"HKCU\");\n-        xml.writeAttribute(\"Key\", registryKeyPath);\n-        xml.writeAttribute(\"Type\", \"raw\");\n-        xml.writeAttribute(\"Name\", propertyId);\n-        xml.writeEndElement(); \/\/ <RegistrySearch>\n-        xml.writeEndElement(); \/\/ <Property>\n-\n-        xml.writeStartElement(\"DirectoryRef\");\n-        xml.writeAttribute(\"Id\", INSTALLDIR.toString());\n-        Component.startElement(xml, componentId, \"*\");\n-\n-        addRegistryKeyPath(xml, INSTALLDIR, () -> propertyId, () -> {\n-            \/\/ The following code converts a path to value to be saved in registry.\n-            \/\/ E.g.:\n-            \/\/  INSTALLDIR -> [INSTALLDIR]\n-            \/\/  TERGETDIR\/ProgramFiles64Folder\/foo\/bar -> [ProgramFiles64Folder]foo\/bar\n-            final Path rootDir = KNOWN_DIRS.stream()\n-                    .sorted(Comparator.comparing(Path::getNameCount).reversed())\n-                    .filter(path::startsWith)\n-                    .findFirst().get();\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(String.format(\"[%s]\", rootDir.getFileName().toString()));\n-            sb.append(rootDir.relativize(path).toString());\n-            return sb.toString();\n-        });\n-\n-        xml.writeStartElement(\n-                \"http:\/\/schemas.microsoft.com\/wix\/UtilExtension\",\n-                \"RemoveFolderEx\");\n-        xml.writeAttribute(\"On\", \"uninstall\");\n-        xml.writeAttribute(\"Property\", propertyId);\n-        xml.writeEndElement(); \/\/ <RemoveFolderEx>\n-        xml.writeEndElement(); \/\/ <Component>\n-        xml.writeEndElement(); \/\/ <DirectoryRef>\n-\n-        return componentId;\n-    }\n-\n-    private static IllegalArgumentException throwInvalidPathException(Path v) {\n-        throw new IllegalArgumentException(String.format(\"Invalid path [%s]\", v));\n-    }\n-\n-    enum ShortcutsFolder {\n-        ProgramMenu(PROGRAM_MENU_PATH),\n-        Desktop(DESKTOP_PATH);\n-\n-        private ShortcutsFolder(Path root) {\n-            this.root = root;\n-        }\n-\n-        Path getPath(WixSourcesBuilder outer) {\n-            if (this == ProgramMenu) {\n-                return root.resolve(outer.programMenuFolderName);\n-            }\n-            return root;\n-        }\n-\n-        private final Path root;\n-    }\n-\n-    private DottedVersion wixVersion;\n-\n-    private boolean systemWide;\n-\n-    private String registryKeyPath;\n-\n-    private Path installDir;\n-\n-    private String programMenuFolderName;\n-\n-    private List<FileAssociation> associations;\n-\n-    private Set<ShortcutsFolder> shortcutFolders;\n-\n-    private List<Path> launcherPaths;\n-\n-    private ApplicationLayout appImage;\n-    private ApplicationLayout installedAppImage;\n-\n-    private Map<Path, Integer> removeFolderItems;\n-    private Set<String> defaultedMimes;\n-\n-    private final static Path TARGETDIR = Path.of(\"TARGETDIR\");\n-\n-    private final static Path INSTALLDIR = Path.of(\"INSTALLDIR\");\n-\n-    private final static Set<Path> ROOT_DIRS = Set.of(INSTALLDIR, TARGETDIR);\n-\n-    private final static Path PROGRAM_MENU_PATH = TARGETDIR.resolve(\"ProgramMenuFolder\");\n-\n-    private final static Path DESKTOP_PATH = TARGETDIR.resolve(\"DesktopFolder\");\n-\n-    private final static Path PROGRAM_FILES = TARGETDIR.resolve(\n-            is64Bit() ? \"ProgramFiles64Folder\" : \"ProgramFilesFolder\");\n-\n-    private final static Path LOCAL_PROGRAM_FILES = TARGETDIR.resolve(\"LocalAppDataFolder\");\n-\n-    private final static Set<Path> SYSTEM_DIRS = Set.of(TARGETDIR,\n-            PROGRAM_MENU_PATH, DESKTOP_PATH, PROGRAM_FILES, LOCAL_PROGRAM_FILES);\n-\n-    private final static Set<Path> KNOWN_DIRS = Stream.of(Set.of(INSTALLDIR),\n-            SYSTEM_DIRS).flatMap(Set::stream).collect(\n-            Collectors.toUnmodifiableSet());\n-\n-    private final static Set<Path> USER_PROFILE_DIRS = Set.of(LOCAL_PROGRAM_FILES,\n-            PROGRAM_MENU_PATH, DESKTOP_PATH);\n-\n-    private static final StandardBundlerParam<Boolean> MENU_HINT =\n-        new StandardBundlerParam<>(\n-                Arguments.CLIOptions.WIN_MENU_HINT.getId(),\n-                Boolean.class,\n-                params -> false,\n-                \/\/ valueOf(null) is false,\n-                \/\/ and we actually do want null in some cases\n-                (s, p) -> (s == null ||\n-                        \"null\".equalsIgnoreCase(s))? true : Boolean.valueOf(s)\n-        );\n-\n-    private static final StandardBundlerParam<Boolean> SHORTCUT_HINT =\n-        new StandardBundlerParam<>(\n-                Arguments.CLIOptions.WIN_SHORTCUT_HINT.getId(),\n-                Boolean.class,\n-                params -> false,\n-                \/\/ valueOf(null) is false,\n-                \/\/ and we actually do want null in some cases\n-                (s, p) -> (s == null ||\n-                       \"null\".equalsIgnoreCase(s))? false : Boolean.valueOf(s)\n-        );\n-\n-    private static final StandardBundlerParam<String> MENU_GROUP =\n-            new StandardBundlerParam<>(\n-                    Arguments.CLIOptions.WIN_MENU_GROUP.getId(),\n-                    String.class,\n-                    params -> I18N.getString(\"param.menu-group.default\"),\n-                    (s, p) -> s\n-            );\n-\n-    private static final BundlerParamInfo<String> WINDOWS_INSTALL_DIR =\n-            new StandardBundlerParam<>(\n-            \"windows-install-dir\",\n-            String.class,\n-            params -> {\n-                 String dir = INSTALL_DIR.fetchFrom(params);\n-                 if (dir != null) {\n-                     if (dir.contains(\":\") || dir.contains(\"..\")) {\n-                         Log.error(MessageFormat.format(I18N.getString(\n-                                \"message.invalid.install.dir\"), dir,\n-                                APP_NAME.fetchFrom(params)));\n-                     } else {\n-                        if (dir.startsWith(\"\\\\\")) {\n-                             dir = dir.substring(1);\n-                        }\n-                        if (dir.endsWith(\"\\\\\")) {\n-                             dir = dir.substring(0, dir.length() - 1);\n-                        }\n-                        return dir;\n-                     }\n-                 }\n-                 return APP_NAME.fetchFrom(params); \/\/ Default to app name\n-             },\n-            (s, p) -> s\n-    );\n-}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixSourcesBuilder.java","additions":0,"deletions":897,"binary":false,"changes":897,"status":"deleted"},{"patch":"@@ -0,0 +1,501 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import jdk.jpackage.internal.IOUtils.XmlConsumer;\n+import static jdk.jpackage.internal.OverridableResource.createResource;\n+import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n+import jdk.jpackage.internal.WixAppImageFragmentBuilder.ShortcutsFolder;\n+\n+\/**\n+ * Creates UI WiX fragment.\n+ *\/\n+final class WixUiFragmentBuilder extends WixFragmentBuilder {\n+\n+    @Override\n+    void initFromParams(Map<String, ? super Object> params) {\n+        super.initFromParams(params);\n+\n+        String licenseFile = LICENSE_FILE.fetchFrom(params);\n+        withLicenseDlg = licenseFile != null;\n+        if (withLicenseDlg) {\n+            Path licenseFileName = IOUtils.getFileName(Path.of(licenseFile));\n+            Path destFile = getConfigRoot().resolve(licenseFileName);\n+            setWixVariable(\"JpLicenseRtf\", destFile.toAbsolutePath().toString());\n+        }\n+\n+        withInstallDirChooserDlg = INSTALLDIR_CHOOSER.fetchFrom(params);\n+\n+        List<ShortcutsFolder> shortcutFolders = Stream.of(\n+                ShortcutsFolder.values()).filter(shortcutFolder -> {\n+            return shortcutFolder.requested(params)\n+                    && SHORTCUT_PROMPT.fetchFrom(params);\n+        }).collect(Collectors.toList());\n+\n+        withShortcutPromptDlg = !shortcutFolders.isEmpty();\n+\n+        customDialogs = new ArrayList<>();\n+\n+        if (withShortcutPromptDlg) {\n+            CustomDialog dialog = new CustomDialog(params, I18N.getString(\n+                    \"resource.shortcutpromptdlg-wix-file\"),\n+                    \"ShortcutPromptDlg.wxs\");\n+            for (var shortcutFolder : shortcutFolders) {\n+                dialog.wixVariables.defineWixVariable(\n+                        shortcutFolder.getWixVariableName());\n+            }\n+            customDialogs.add(dialog);\n+        }\n+\n+        if (withInstallDirChooserDlg) {\n+            CustomDialog dialog = new CustomDialog(params, I18N.getString(\n+                    \"resource.installdirnotemptydlg-wix-file\"),\n+                    \"InstallDirNotEmptyDlg.wxs\");\n+            List<Dialog> dialogIds = getUI().dialogIdsSupplier.apply(this);\n+            dialog.wixVariables.setWixVariable(\"JpAfterInstallDirDlg\",\n+                    dialogIds.get(dialogIds.indexOf(Dialog.InstallDirDlg) + 1).id);\n+            customDialogs.add(dialog);\n+        }\n+    }\n+\n+    @Override\n+    void configureWixPipeline(WixPipeline wixPipeline) {\n+        super.configureWixPipeline(wixPipeline);\n+\n+        if (withShortcutPromptDlg || withInstallDirChooserDlg || withLicenseDlg) {\n+            wixPipeline.addLightOptions(\"-ext\", \"WixUIExtension\");\n+        }\n+\n+        \/\/ Only needed if we using CA dll, so Wix can find it\n+        if (withInstallDirChooserDlg) {\n+            wixPipeline.addLightOptions(\"-b\",\n+                    getConfigRoot().toAbsolutePath().toString());\n+        }\n+\n+        for (var customDialog : customDialogs) {\n+            customDialog.addToWixPipeline(wixPipeline);\n+        }\n+    }\n+\n+    @Override\n+    void addFilesToConfigRoot() throws IOException {\n+        super.addFilesToConfigRoot();\n+\n+        if (withInstallDirChooserDlg) {\n+            String fname = \"wixhelper.dll\"; \/\/ CA dll\n+            try (InputStream is = OverridableResource.readDefault(fname)) {\n+                Files.copy(is, getConfigRoot().resolve(fname));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected Collection<XmlConsumer> getFragmentWriters() {\n+        return List.of(this::addUI);\n+    }\n+\n+    private void addUI(XMLStreamWriter xml) throws XMLStreamException,\n+            IOException {\n+\n+        if (withInstallDirChooserDlg) {\n+            xml.writeStartElement(\"Property\");\n+            xml.writeAttribute(\"Id\", \"WIXUI_INSTALLDIR\");\n+            xml.writeAttribute(\"Value\", \"INSTALLDIR\");\n+            xml.writeEndElement(); \/\/ Property\n+        }\n+\n+        if (withLicenseDlg) {\n+            xml.writeStartElement(\"WixVariable\");\n+            xml.writeAttribute(\"Id\", \"WixUILicenseRtf\");\n+            xml.writeAttribute(\"Value\", \"$(var.JpLicenseRtf)\");\n+            xml.writeEndElement(); \/\/ WixVariable\n+        }\n+\n+        xml.writeStartElement(\"UI\");\n+        xml.writeAttribute(\"Id\", \"JpUI\");\n+\n+        var ui = getUI();\n+        if (ui != null) {\n+            ui.write(this, xml);\n+        }\n+\n+        xml.writeEndElement(); \/\/ UI\n+    }\n+\n+    private UI getUI() {\n+        if (withInstallDirChooserDlg || withShortcutPromptDlg) {\n+            \/\/ WixUI_InstallDir for shortcut prompt dialog too because in\n+            \/\/ WixUI_Minimal UI sequence WelcomeEulaDlg dialog doesn't have \"Next\"\n+            \/\/ button, but has \"Install\" button. So inserting shortcut prompt dialog\n+            \/\/ after welcome dialog in WixUI_Minimal UI sequence would be confusing\n+            return UI.InstallDir;\n+        } else if (withLicenseDlg) {\n+            return UI.Minimal;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private enum UI {\n+        InstallDir(\"WixUI_InstallDir\",\n+                WixUiFragmentBuilder::dialogSequenceForWixUI_InstallDir,\n+                Dialog::createPairsForWixUI_InstallDir),\n+        Minimal(\"WixUI_Minimal\", null, null);\n+\n+        UI(String wixUIRef,\n+                Function<WixUiFragmentBuilder, List<Dialog>> dialogIdsSupplier,\n+                Supplier<Map<DialogPair, List<Publish>>> dialogPairsSupplier) {\n+            this.wixUIRef = wixUIRef;\n+            this.dialogIdsSupplier = dialogIdsSupplier;\n+            this.dialogPairsSupplier = dialogPairsSupplier;\n+        }\n+\n+        void write(WixUiFragmentBuilder outer, XMLStreamWriter xml) throws\n+                XMLStreamException, IOException {\n+            xml.writeStartElement(\"UIRef\");\n+            xml.writeAttribute(\"Id\", wixUIRef);\n+            xml.writeEndElement(); \/\/ UIRef\n+\n+            if (dialogIdsSupplier != null) {\n+                List<Dialog> dialogIds = dialogIdsSupplier.apply(outer);\n+                Map<DialogPair, List<Publish>> dialogPairs = dialogPairsSupplier.get();\n+\n+                if (dialogIds.contains(Dialog.InstallDirDlg)) {\n+                    xml.writeStartElement(\"DialogRef\");\n+                    xml.writeAttribute(\"Id\", \"InstallDirNotEmptyDlg\");\n+                    xml.writeEndElement(); \/\/ DialogRef\n+                }\n+\n+                var it = dialogIds.iterator();\n+                Dialog firstId = it.next();\n+                while (it.hasNext()) {\n+                    Dialog secondId = it.next();\n+                    DialogPair pair = new DialogPair(firstId, secondId);\n+                    for (var curPair : List.of(pair, pair.flip())) {\n+                        for (var publish : dialogPairs.get(curPair)) {\n+                            writePublishDialogPair(xml, publish, curPair);\n+                        }\n+                    }\n+                    firstId = secondId;\n+                }\n+            }\n+        }\n+\n+        private final String wixUIRef;\n+        private final Function<WixUiFragmentBuilder, List<Dialog>> dialogIdsSupplier;\n+        private final Supplier<Map<DialogPair, List<Publish>>> dialogPairsSupplier;\n+    }\n+\n+    private List<Dialog> dialogSequenceForWixUI_InstallDir() {\n+        List<Dialog> dialogIds = new ArrayList<>(\n+                List.of(Dialog.WixUI_WelcomeDlg));\n+        if (withLicenseDlg) {\n+            dialogIds.add(Dialog.WixUI_LicenseAgreementDlg);\n+        }\n+\n+        if (withInstallDirChooserDlg) {\n+            dialogIds.add(Dialog.InstallDirDlg);\n+        }\n+\n+        if (withShortcutPromptDlg) {\n+            dialogIds.add(Dialog.ShortcutPromptDlg);\n+        }\n+\n+        dialogIds.add(Dialog.WixUI_VerifyReadyDlg);\n+\n+        return dialogIds;\n+    }\n+\n+    private enum Dialog {\n+        WixUI_WelcomeDlg,\n+        WixUI_LicenseAgreementDlg,\n+        InstallDirDlg,\n+        ShortcutPromptDlg,\n+        WixUI_VerifyReadyDlg;\n+\n+        Dialog() {\n+            if (name().startsWith(\"WixUI_\")) {\n+                id = name().substring(\"WixUI_\".length());\n+            } else {\n+                id = name();\n+            }\n+        }\n+\n+        static Map<DialogPair, List<Publish>> createPair(Dialog firstId,\n+                Dialog secondId, List<PublishBuilder> nextBuilders,\n+                List<PublishBuilder> prevBuilders) {\n+            var pair = new DialogPair(firstId, secondId);\n+            return Map.of(pair, nextBuilders.stream().map(b -> {\n+                return buildPublish(b.create()).next().create();\n+            }).collect(Collectors.toList()), pair.flip(),\n+                    prevBuilders.stream().map(b -> {\n+                        return buildPublish(b.create()).back().create();\n+                    }).collect(Collectors.toList()));\n+        }\n+\n+        static Map<DialogPair, List<Publish>> createPair(Dialog firstId,\n+                Dialog secondId, List<PublishBuilder> builders) {\n+            return createPair(firstId, secondId, builders, builders);\n+        }\n+\n+        static Map<DialogPair, List<Publish>> createPairsForWixUI_InstallDir() {\n+            Map<DialogPair, List<Publish>> map = new HashMap<>();\n+\n+            \/\/ Order is a \"weight\" of action. If there are multiple\n+            \/\/ \"NewDialog\" action for the same dialog Id, MSI would pick the one\n+            \/\/ with higher order value. In WixUI_InstallDir dialog sequence the\n+            \/\/ highest order value is 4. InstallDirNotEmptyDlg adds NewDialog\n+            \/\/ action with order 5. Setting order to 6 for all\n+            \/\/ actions configured in this function would make them executed\n+            \/\/ instead of corresponding default actions defined in\n+            \/\/ WixUI_InstallDir dialog sequence.\n+            var order = 6;\n+\n+            \/\/ Based on WixUI_InstallDir.wxs\n+            var backFromVerifyReadyDlg = List.of(buildPublish().condition(\n+                    \"NOT Installed\").order(order));\n+            var uncondinal = List.of(buildPublish().condition(\"1\"));\n+            var ifNotIstalled = List.of(\n+                    buildPublish().condition(\"NOT Installed\").order(order));\n+            var ifLicenseAccepted = List.of(buildPublish().condition(\n+                    \"LicenseAccepted = \\\"1\\\"\").order(order));\n+\n+            \/\/ Empty condition list for the default dialog sequence\n+            map.putAll(createPair(WixUI_WelcomeDlg, WixUI_LicenseAgreementDlg,\n+                    List.of()));\n+            map.putAll(\n+                    createPair(WixUI_WelcomeDlg, InstallDirDlg, ifNotIstalled));\n+            map.putAll(createPair(WixUI_WelcomeDlg, ShortcutPromptDlg,\n+                    ifNotIstalled));\n+\n+            map.putAll(createPair(WixUI_LicenseAgreementDlg, InstallDirDlg,\n+                    List.of()));\n+            map.putAll(createPair(WixUI_LicenseAgreementDlg, ShortcutPromptDlg,\n+                    ifLicenseAccepted, uncondinal));\n+            map.putAll(createPair(WixUI_LicenseAgreementDlg,\n+                    WixUI_VerifyReadyDlg, ifLicenseAccepted,\n+                    backFromVerifyReadyDlg));\n+\n+            map.putAll(createPair(InstallDirDlg, ShortcutPromptDlg, List.of(),\n+                    uncondinal));\n+            map.putAll(createPair(InstallDirDlg, WixUI_VerifyReadyDlg, List.of()));\n+\n+            map.putAll(createPair(ShortcutPromptDlg, WixUI_VerifyReadyDlg,\n+                    uncondinal, backFromVerifyReadyDlg));\n+\n+            return map;\n+        }\n+\n+        private final String id;\n+    }\n+\n+    private final static class DialogPair {\n+\n+        DialogPair(Dialog first, Dialog second) {\n+            this(first.id, second.id);\n+        }\n+\n+        DialogPair(String firstId, String secondId) {\n+            this.firstId = firstId;\n+            this.secondId = secondId;\n+        }\n+\n+        DialogPair flip() {\n+            return new DialogPair(secondId, firstId);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int hash = 3;\n+            hash = 97 * hash + Objects.hashCode(this.firstId);\n+            hash = 97 * hash + Objects.hashCode(this.secondId);\n+            return hash;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            final DialogPair other = (DialogPair) obj;\n+            if (!Objects.equals(this.firstId, other.firstId)) {\n+                return false;\n+            }\n+            if (!Objects.equals(this.secondId, other.secondId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        private final String firstId;\n+        private final String secondId;\n+    }\n+\n+    private final static class Publish {\n+\n+        Publish(String control, String condition, int order) {\n+            this.control = control;\n+            this.condition = condition;\n+            this.order = order;\n+        }\n+\n+        private final String control;\n+        private final String condition;\n+        private final int order;\n+    }\n+\n+    private final static class PublishBuilder {\n+\n+        PublishBuilder() {\n+            order(0);\n+            next();\n+            condition(\"1\");\n+        }\n+\n+        PublishBuilder(Publish publish) {\n+            order(publish.order);\n+            control(publish.control);\n+            condition(publish.condition);\n+        }\n+\n+        public PublishBuilder control(String v) {\n+            control = v;\n+            return this;\n+        }\n+\n+        public PublishBuilder next() {\n+            return control(\"Next\");\n+        }\n+\n+        public PublishBuilder back() {\n+            return control(\"Back\");\n+        }\n+\n+        public PublishBuilder condition(String v) {\n+            condition = v;\n+            return this;\n+        }\n+\n+        public PublishBuilder order(int v) {\n+            order = v;\n+            return this;\n+        }\n+\n+        Publish create() {\n+            return new Publish(control, condition, order);\n+        }\n+\n+        private String control;\n+        private String condition;\n+        private int order;\n+    }\n+\n+    private static PublishBuilder buildPublish() {\n+        return new PublishBuilder();\n+    }\n+\n+    private static PublishBuilder buildPublish(Publish publish) {\n+        return new PublishBuilder(publish);\n+    }\n+\n+    private static void writePublishDialogPair(XMLStreamWriter xml,\n+            Publish publish, DialogPair dialogPair) throws IOException,\n+            XMLStreamException {\n+        xml.writeStartElement(\"Publish\");\n+        xml.writeAttribute(\"Dialog\", dialogPair.firstId);\n+        xml.writeAttribute(\"Control\", publish.control);\n+        xml.writeAttribute(\"Event\", \"NewDialog\");\n+        xml.writeAttribute(\"Value\", dialogPair.secondId);\n+        if (publish.order != 0) {\n+            xml.writeAttribute(\"Order\", String.valueOf(publish.order));\n+        }\n+        xml.writeCharacters(publish.condition);\n+        xml.writeEndElement();\n+    }\n+\n+    private final class CustomDialog {\n+\n+        CustomDialog(Map<String, ? super Object> params, String category,\n+                String wxsFileName) {\n+            this.wxsFileName = wxsFileName;\n+            this.wixVariables = new WixVariables();\n+\n+            addResource(\n+                    createResource(wxsFileName, params).setCategory(category),\n+                    wxsFileName);\n+        }\n+\n+        void addToWixPipeline(WixPipeline wixPipeline) {\n+            wixPipeline.addSource(getConfigRoot().toAbsolutePath().resolve(\n+                    wxsFileName), wixVariables.getValues());\n+        }\n+\n+        private final WixVariables wixVariables;\n+        private final String wxsFileName;\n+    }\n+\n+    private boolean withInstallDirChooserDlg;\n+    private boolean withShortcutPromptDlg;\n+    private boolean withLicenseDlg;\n+    private List<CustomDialog> customDialogs;\n+\n+    private static final BundlerParamInfo<Boolean> INSTALLDIR_CHOOSER\n+            = new StandardBundlerParam<>(\n+                    Arguments.CLIOptions.WIN_DIR_CHOOSER.getId(),\n+                    Boolean.class,\n+                    params -> false,\n+                    (s, p) -> Boolean.valueOf(s)\n+            );\n+\n+    private static final StandardBundlerParam<Boolean> SHORTCUT_PROMPT\n+            = new StandardBundlerParam<>(\n+                    Arguments.CLIOptions.WIN_SHORTCUT_PROMPT.getId(),\n+                    Boolean.class,\n+                    params -> false,\n+                    (s, p) -> Boolean.valueOf(s)\n+            );\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixUiFragmentBuilder.java","additions":501,"deletions":0,"binary":false,"changes":501,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class WixVariables {\n+\n+    void defineWixVariable(String variableName) {\n+        setWixVariable(variableName, \"yes\");\n+    }\n+\n+    void setWixVariable(String variableName, String variableValue) {\n+        values.put(variableName, variableValue);\n+    }\n+\n+    Map<String, String> getValues() {\n+        return values;\n+    }\n+\n+    private final Map<String, String> values = new HashMap<>();\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixVariables.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<!--\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+-->\n+\n+<Wix xmlns=\"http:\/\/schemas.microsoft.com\/wix\/2006\/wi\"\n+     xmlns:util=\"http:\/\/schemas.microsoft.com\/wix\/UtilExtension\">\n+\n+  <Fragment>\n+\n+    <Binary Id=\"JpCaDll\" SourceFile=\"wixhelper.dll\"\/>\n+    <CustomAction Id=\"JpCheckInstallDir\" BinaryKey=\"JpCaDll\" DllEntry=\"CheckInstallDir\" \/>\n+\n+    <UI>\n+      <Dialog Id=\"InstallDirNotEmptyDlg\" Width=\"300\" Height=\"85\" Title=\"!(loc.InstallDirNotEmptyDlg_Title)\">\n+        <Control Id=\"Yes\" Type=\"PushButton\" X=\"100\" Y=\"55\" Width=\"50\" Height=\"15\" Default=\"no\" Cancel=\"no\" Text=\"!(loc.WixUIYes)\">\n+          <Publish Event=\"NewDialog\" Value=\"$(var.JpAfterInstallDirDlg)\">1<\/Publish>\n+        <\/Control>\n+        <Control Id=\"No\" Type=\"PushButton\" X=\"150\" Y=\"55\" Width=\"50\" Height=\"15\" Default=\"yes\" Cancel=\"yes\" Text=\"!(loc.WixUINo)\">\n+          <Publish Event=\"NewDialog\" Value=\"InstallDirDlg\">1<\/Publish>\n+        <\/Control>\n+        <Control Id=\"Text\" Type=\"Text\" X=\"25\" Y=\"15\" Width=\"250\" Height=\"30\" TabSkip=\"no\">\n+          <Text>!(loc.message.install.dir.exist)<\/Text>\n+        <\/Control>\n+      <\/Dialog>\n+\n+      <Publish Dialog=\"InstallDirDlg\" Control=\"Next\" Event=\"DoAction\" Value=\"JpCheckInstallDir\" Order=\"3\">1<\/Publish>\n+      <Publish Dialog=\"InstallDirDlg\" Control=\"Next\" Event=\"NewDialog\" Value=\"InstallDirNotEmptyDlg\" Order=\"5\">INSTALLDIR_VALID=\"0\"<\/Publish>\n+      <Publish Dialog=\"InstallDirDlg\" Control=\"Next\" Event=\"NewDialog\" Value=\"$(var.JpAfterInstallDirDlg)\" Order=\"5\">INSTALLDIR_VALID=\"1\"<\/Publish>\n+\n+    <\/UI>\n+  <\/Fragment>\n+<\/Wix>\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/InstallDirNotEmptyDlg.wxs","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -7,0 +7,8 @@\n+\n+  <String Id=\"ShortcutPromptDlg_Title\">[ProductName] Setup<\/String>\n+  <String Id=\"ShortcutPromptDlgTitle\">{\\WixUI_Font_Title}Shortcuts<\/String>\n+  <String Id=\"ShortcutPromptDlgBannerBitmap\">WixUI_Bmp_Banner<\/String>\n+  <String Id=\"ShortcutPromptDlgDescription\">Select shortcuts to create.<\/String>\n+  <String Id=\"ShortcutPromptDlgDesktopShortcutControlLabel\">Create desktop shortcut(s)<\/String>\n+  <String Id=\"ShortcutPromptDlgStartMenuShortcutControlLabel\">Create start menu shortcut(s)<\/String>\n+  <String Id=\"InstallDirNotEmptyDlg_Title\">[ProductName] Setup<\/String>\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/MsiInstallerStrings_en.wxl","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,0 +7,8 @@\n+\n+  <String Id=\"ShortcutPromptDlg_Title\">[ProductName] Setup<\/String>\n+  <String Id=\"ShortcutPromptDlgTitle\">{\\WixUI_Font_Title}Shortcuts<\/String>\n+  <String Id=\"ShortcutPromptDlgBannerBitmap\">WixUI_Bmp_Banner<\/String>\n+  <String Id=\"ShortcutPromptDlgDescription\">Select shortcuts to create.<\/String>\n+  <String Id=\"ShortcutPromptDlgDesktopShortcutControlLabel\">Create desktop shortcut(s)<\/String>\n+  <String Id=\"ShortcutPromptDlgStartMenuShortcutControlLabel\">Create start menu shortcut(s)<\/String>\n+  <String Id=\"InstallDirNotEmptyDlg_Title\">[ProductName] Setup<\/String>  \n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/MsiInstallerStrings_ja.wxl","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,0 +7,8 @@\n+\n+  <String Id=\"ShortcutPromptDlg_Title\">[ProductName] Setup<\/String>\n+  <String Id=\"ShortcutPromptDlgTitle\">{\\WixUI_Font_Title}Shortcuts<\/String>\n+  <String Id=\"ShortcutPromptDlgBannerBitmap\">WixUI_Bmp_Banner<\/String>\n+  <String Id=\"ShortcutPromptDlgDescription\">Select shortcuts to create.<\/String>\n+  <String Id=\"ShortcutPromptDlgDesktopShortcutControlLabel\">Create desktop shortcut(s)<\/String>\n+  <String Id=\"ShortcutPromptDlgStartMenuShortcutControlLabel\">Create start menu shortcut(s)<\/String>\n+  <String Id=\"InstallDirNotEmptyDlg_Title\">[ProductName] Setup<\/String>\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/MsiInstallerStrings_zh_CN.wxl","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<!--\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+-->\n+\n+<Wix xmlns=\"http:\/\/schemas.microsoft.com\/wix\/2006\/wi\"\n+     xmlns:util=\"http:\/\/schemas.microsoft.com\/wix\/UtilExtension\">\n+\n+  <?define JpDesktopShortcutPromptControlY=140 ?>\n+  <?define JpStartMenuShortcutPromptControlY=180 ?>\n+\n+  <?ifndef JpDesktopShortcutPrompt ?>\n+    <?define JpStartMenuShortcutPromptControlY=$(var.JpDesktopShortcutPromptControlY) ?>\n+  <?endif?>\n+\n+  <Fragment>\n+    <UI>\n+      <Dialog Id=\"ShortcutPromptDlg\" Width=\"370\" Height=\"270\" Title=\"!(loc.ShortcutPromptDlg_Title)\" NoMinimize=\"yes\">\n+        <Control Id=\"Description\" Type=\"Text\" X=\"25\" Y=\"23\" Width=\"280\" Height=\"15\" Transparent=\"yes\" NoPrefix=\"yes\"\n+                 Text=\"!(loc.ShortcutPromptDlgDescription)\" \/>\n+        <Control Id=\"Title\" Type=\"Text\" X=\"15\" Y=\"6\" Width=\"200\" Height=\"15\" Transparent=\"yes\" NoPrefix=\"yes\"\n+                 Text=\"!(loc.ShortcutPromptDlgTitle)\" \/>\n+        <Control Id=\"BannerBitmap\" Type=\"Bitmap\" X=\"0\" Y=\"0\" Width=\"370\" Height=\"44\" TabSkip=\"no\"\n+                 Text=\"!(loc.ShortcutPromptDlgBannerBitmap)\" \/>\n+        <Control Id=\"BannerLine\" Type=\"Line\" X=\"0\" Y=\"44\" Width=\"370\" Height=\"0\" \/>\n+        <Control Id=\"BottomLine\" Type=\"Line\" X=\"0\" Y=\"234\" Width=\"370\" Height=\"0\" \/>\n+\n+        <?ifdef JpDesktopShortcutPrompt ?>\n+        <Control Type=\"CheckBox\" X=\"20\" Width=\"200\" Height=\"17\" CheckBoxValue=\"1\"\n+                 Id=\"InstallDesktopShortcut\"\n+                 Y=\"$(var.JpDesktopShortcutPromptControlY)\"\n+                 Property=\"JP_INSTALL_DESKTOP_SHORTCUT\"\n+                 Text=\"!(loc.ShortcutPromptDlgDesktopShortcutControlLabel)\"\/>\n+        <?endif?>\n+\n+        <?ifdef JpStartMenuShortcutPrompt ?>\n+        <Control Type=\"CheckBox\" X=\"20\" Width=\"200\" Height=\"17\" CheckBoxValue=\"1\"\n+                 Id=\"InstallStartMenuShortcut\"\n+                 Y=\"$(var.JpStartMenuShortcutPromptControlY)\"\n+                 Property=\"JP_INSTALL_STARTMENU_SHORTCUT\"\n+                 Text=\"!(loc.ShortcutPromptDlgStartMenuShortcutControlLabel)\"\/>\n+        <?endif?>\n+\n+        <Control Id=\"Next\" Type=\"PushButton\" X=\"236\" Y=\"243\" Width=\"56\" Height=\"17\" Default=\"yes\"\n+                 Text=\"!(loc.WixUINext)\" \/>\n+        <Control Id=\"Back\" Type=\"PushButton\" X=\"180\" Y=\"243\" Width=\"56\" Height=\"17\"\n+                 Text=\"!(loc.WixUIBack)\" \/>\n+        <Control Id=\"Cancel\" Type=\"PushButton\" X=\"304\" Y=\"243\" Width=\"56\" Height=\"17\" Cancel=\"yes\"\n+                 Text=\"!(loc.WixUICancel)\">\n+          <Publish Event=\"SpawnDialog\" Value=\"CancelDlg\">1<\/Publish>\n+        <\/Control>\n+      <\/Dialog>\n+    <\/UI>\n+  <\/Fragment>\n+<\/Wix>\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/ShortcutPromptDlg.wxs","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+resource.shortcutpromptdlg-wix-file=Shortcut prompt dialog WiX project file\n+resource.installdirnotemptydlg-wix-file=Not empty install directory dialog WiX project file\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+resource.shortcutpromptdlg-wix-file=Shortcut prompt dialog WiX project file\n+resource.installdirnotemptydlg-wix-file=Not empty install directory dialog WiX project file\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_ja.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+resource.shortcutpromptdlg-wix-file=Shortcut prompt dialog WiX project file\n+resource.installdirnotemptydlg-wix-file=Not empty install directory dialog WiX project file\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_zh_CN.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,5 +77,0 @@\n-    <?ifdef JpInstallDirChooser ?>\n-    <Binary Id=\"JpCaDll\" SourceFile=\"wixhelper.dll\"\/>\n-    <CustomAction Id=\"JpCheckInstallDir\" BinaryKey=\"JpCaDll\" DllEntry=\"CheckInstallDir\" \/>\n-    <?endif?>\n-\n@@ -88,47 +83,2 @@\n-\n-    <UI>\n-      <?ifdef JpInstallDirChooser ?>\n-      <Dialog Id=\"JpInvalidInstallDir\" Width=\"300\" Height=\"85\" Title=\"[ProductName] Setup\" NoMinimize=\"yes\">\n-        <Control Id=\"JpInvalidInstallDirYes\" Type=\"PushButton\" X=\"100\" Y=\"55\" Width=\"50\" Height=\"15\" Default=\"no\" Cancel=\"no\" Text=\"Yes\">\n-          <Publish Event=\"NewDialog\" Value=\"VerifyReadyDlg\">1<\/Publish>\n-        <\/Control>\n-        <Control Id=\"JpInvalidInstallDirNo\" Type=\"PushButton\" X=\"150\" Y=\"55\" Width=\"50\" Height=\"15\" Default=\"yes\" Cancel=\"yes\" Text=\"No\">\n-          <Publish Event=\"NewDialog\" Value=\"InstallDirDlg\">1<\/Publish>\n-        <\/Control>\n-        <Control Id=\"Text\" Type=\"Text\" X=\"25\" Y=\"15\" Width=\"250\" Height=\"30\" TabSkip=\"no\">\n-          <Text>!(loc.message.install.dir.exist)<\/Text>\n-        <\/Control>\n-      <\/Dialog>\n-\n-      <!--\n-        Run WixUI_InstallDir dialog in the default install directory.\n-      -->\n-      <Property Id=\"WIXUI_INSTALLDIR\" Value=\"INSTALLDIR\"\/>\n-      <UIRef Id=\"WixUI_InstallDir\" \/>\n-\n-      <Publish Dialog=\"InstallDirDlg\" Control=\"Next\" Event=\"DoAction\" Value=\"JpCheckInstallDir\" Order=\"3\">1<\/Publish>\n-      <Publish Dialog=\"InstallDirDlg\" Control=\"Next\" Event=\"NewDialog\" Value=\"JpInvalidInstallDir\" Order=\"5\">INSTALLDIR_VALID=\"0\"<\/Publish>\n-      <Publish Dialog=\"InstallDirDlg\" Control=\"Next\" Event=\"NewDialog\" Value=\"VerifyReadyDlg\" Order=\"5\">INSTALLDIR_VALID=\"1\"<\/Publish>\n-\n-      <?ifndef JpLicenseRtf ?>\n-      <!--\n-        No license file provided.\n-        Override the dialog sequence in built-in dialog set \"WixUI_InstallDir\"\n-        to exclude license dialog.\n-      -->\n-      <Publish Dialog=\"WelcomeDlg\" Control=\"Next\" Event=\"NewDialog\" Value=\"InstallDirDlg\" Order=\"2\">1<\/Publish>\n-      <Publish Dialog=\"InstallDirDlg\" Control=\"Back\" Event=\"NewDialog\" Value=\"WelcomeDlg\" Order=\"2\">1<\/Publish>\n-      <?endif?>\n-\n-      <?else?>\n-\n-      <?ifdef JpLicenseRtf ?>\n-      <UIRef Id=\"WixUI_Minimal\" \/>\n-      <?endif?>\n-\n-      <?endif?>\n-    <\/UI>\n-\n-    <?ifdef JpLicenseRtf ?>\n-    <WixVariable Id=\"WixUILicenseRtf\" Value=\"$(var.JpLicenseRtf)\"\/>\n-    <?endif?>\n+    \n+    <UIRef Id=\"JpUI\"\/>\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/main.wxs","additions":2,"deletions":52,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import java.util.List;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.TKit;\n+\n+\/**\n+ * Test all possible combinations of --win-dir-chooser, --win-shortcut-prompt\n+ * and --license parameters.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --win-dir-chooser, --win-shortcut-prompt and --license parameters\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @requires (os.family == \"windows\")\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @run main\/othervm\/timeout=360 -Xmx512m  jdk.jpackage.test.Main\n+ *  --jpt-run=WinInstallerUiTest\n+ *\/\n+public class WinInstallerUiTest {\n+\n+    public WinInstallerUiTest(Boolean withDirChooser, Boolean withLicense,\n+            Boolean withShortcutPrompt) {\n+        this.withShortcutPrompt = withShortcutPrompt;\n+        this.withDirChooser = withDirChooser;\n+        this.withLicense = withLicense;\n+    }\n+\n+    @Parameters\n+    public static List<Object[]> data() {\n+        List<Object[]> data = new ArrayList<>();\n+        for (var withDirChooser : List.of(Boolean.TRUE, Boolean.FALSE)) {\n+            for (var withLicense : List.of(Boolean.TRUE, Boolean.FALSE)) {\n+                for (var withShortcutPrompt : List.of(Boolean.TRUE, Boolean.FALSE)) {\n+                    data.add(new Object[]{withDirChooser, withLicense,\n+                        withShortcutPrompt});\n+                }\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+    @Test\n+    public void test() {\n+        PackageTest test = new PackageTest()\n+                .forTypes(PackageType.WINDOWS)\n+                .configureHelloApp();\n+\n+        test.addInitializer(JPackageCommand::setFakeRuntime);\n+        test.addInitializer(this::setPackageName);\n+\n+        if (withDirChooser) {\n+            test.addInitializer(cmd -> cmd.addArgument(\"--win-dir-chooser\"));\n+        }\n+\n+        if (withShortcutPrompt) {\n+            test.addInitializer(cmd -> {\n+                cmd.addArgument(\"--win-shortcut-prompt\");\n+                cmd.addArgument(\"--win-menu\");\n+                cmd.addArgument(\"--win-shortcut\");\n+            });\n+        }\n+\n+        if (withLicense) {\n+            test.addInitializer(cmd -> {\n+                cmd.addArguments(\"--license-file\", TKit.createRelativePathCopy(\n+                        TKit.TEST_SRC_ROOT.resolve(Path.of(\"resources\",\n+                                \"license.txt\"))));\n+            });\n+        }\n+\n+        test.run();\n+    }\n+\n+    private void setPackageName(JPackageCommand cmd) {\n+        StringBuilder sb = new StringBuilder(cmd.name());\n+        sb.append(\"With\");\n+        if (withDirChooser) {\n+            sb.append(\"DirChooser\");\n+        }\n+        if (withShortcutPrompt) {\n+            sb.append(\"ShortcutPrompt\");\n+        }\n+        if (withLicense) {\n+            sb.append(\"License\");\n+        }\n+        cmd.setArgumentValue(\"--name\", sb.toString());\n+    }\n+\n+    private final boolean withDirChooser;\n+    private final boolean withLicense;\n+    private final boolean withShortcutPrompt;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinInstallerUiTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import java.util.List;\n+import jdk.jpackage.test.PackageType;\n+\n+\/**\n+ * Test all possible combinations of --win-shortcut-prompt, --win-menu and\n+ * --win-shortcut parameters.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --win-shortcut-prompt, --win-menu and --win-shortcut parameters\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @requires (os.family == \"windows\")\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @run main\/othervm\/timeout=360 -Xmx512m  jdk.jpackage.test.Main\n+ *  --jpt-run=WinShortcutPromptTest\n+ *\/\n+public class WinShortcutPromptTest {\n+\n+    public WinShortcutPromptTest(Boolean withStartMenuShortcut,\n+            Boolean withDesktopShortcut, Boolean withShortcutPrompt) {\n+        this.withStartMenuShortcut = withStartMenuShortcut;\n+        this.withDesktopShortcut = withDesktopShortcut;\n+        this.withShortcutPrompt = withShortcutPrompt;\n+    }\n+\n+    @Parameters\n+    public static List<Object[]> data() {\n+        List<Object[]> data = new ArrayList<>();\n+        for (var withStartMenuShortcut : List.of(Boolean.TRUE, Boolean.FALSE)) {\n+            for (var withDesktopShortcut : List.of(Boolean.TRUE, Boolean.FALSE)) {\n+                for (var withShortcutPrompt : List.of(Boolean.TRUE, Boolean.FALSE)) {\n+                    data.add(new Object[]{withStartMenuShortcut,\n+                        withDesktopShortcut, withShortcutPrompt});\n+                }\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+    @Test\n+    public void test() {\n+        PackageTest test = new PackageTest()\n+                .forTypes(PackageType.WINDOWS)\n+                .configureHelloApp();\n+\n+        test.addInitializer(JPackageCommand::setFakeRuntime);\n+        test.addInitializer(this::setPackageName);\n+\n+        if (withShortcutPrompt) {\n+            test.addInitializer(cmd -> cmd.addArgument(\"--win-shortcut-prompt\"));\n+        }\n+\n+        if (withStartMenuShortcut) {\n+            test.addInitializer(cmd -> cmd.addArgument(\"--win-menu\"));\n+        }\n+\n+        if (withDesktopShortcut) {\n+            test.addInitializer(cmd -> cmd.addArgument(\"--win-shortcut\"));\n+        }\n+\n+        test.run();\n+    }\n+\n+    private void setPackageName(JPackageCommand cmd) {\n+        StringBuilder sb = new StringBuilder(cmd.name());\n+        sb.append(\"With\");\n+        if (withShortcutPrompt) {\n+            sb.append(\"ShortcutPrompt\");\n+        }\n+        if (withStartMenuShortcut) {\n+            sb.append(\"StartMenu\");\n+        }\n+        if (withDesktopShortcut) {\n+            sb.append(\"Desktop\");\n+        }\n+        cmd.setArgumentValue(\"--name\", sb.toString());\n+    }\n+\n+    private final boolean withStartMenuShortcut;\n+    private final boolean withDesktopShortcut;\n+    private final boolean withShortcutPrompt;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinShortcutPromptTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}