{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  os::SuspendResume sr;\n+  SuspendResume sr;\n","filename":"src\/hotspot\/os\/aix\/osThread_aix.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  os::SuspendResume sr;\n+  SuspendResume sr;\n","filename":"src\/hotspot\/os\/bsd\/osThread_bsd.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-  os::SuspendResume sr;\n+  SuspendResume sr;\n","filename":"src\/hotspot\/os\/linux\/osThread_linux.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/suspendedThreadTask.hpp\"\n@@ -43,0 +44,1 @@\n+#include \"suspendResume_posix.hpp\"\n@@ -1632,1 +1634,1 @@\n-  os::SuspendResume::State current = osthread->sr.state();\n+  SuspendResume::State current = osthread->sr.state();\n@@ -1634,1 +1636,1 @@\n-  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n+  if (current == SuspendResume::SR_SUSPEND_REQUEST) {\n@@ -1638,2 +1640,2 @@\n-    os::SuspendResume::State state = osthread->sr.suspended();\n-    if (state == os::SuspendResume::SR_SUSPENDED) {\n+    SuspendResume::State state = osthread->sr.suspended();\n+    if (state == SuspendResume::SR_SUSPENDED) {\n@@ -1653,2 +1655,2 @@\n-        os::SuspendResume::State result = osthread->sr.running();\n-        if (result == os::SuspendResume::SR_RUNNING) {\n+        SuspendResume::State result = osthread->sr.running();\n+        if (result == SuspendResume::SR_RUNNING) {\n@@ -1658,1 +1660,1 @@\n-        } else if (result != os::SuspendResume::SR_SUSPENDED) {\n+        } else if (result != SuspendResume::SR_SUSPENDED) {\n@@ -1663,1 +1665,1 @@\n-    } else if (state == os::SuspendResume::SR_RUNNING) {\n+    } else if (state == SuspendResume::SR_RUNNING) {\n@@ -1670,1 +1672,1 @@\n-  } else if (current == os::SuspendResume::SR_RUNNING) {\n+  } else if (current == SuspendResume::SR_RUNNING) {\n@@ -1672,1 +1674,1 @@\n-  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n+  } else if (current == SuspendResume::SR_WAKEUP_REQUEST) {\n@@ -1731,1 +1733,1 @@\n-  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n+  if (osthread->sr.request_suspend() != SuspendResume::SR_SUSPEND_REQUEST) {\n@@ -1747,2 +1749,2 @@\n-      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n-      if (cancelled == os::SuspendResume::SR_RUNNING) {\n+      SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n+      if (cancelled == SuspendResume::SR_RUNNING) {\n@@ -1750,1 +1752,1 @@\n-      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n+      } else if (cancelled == SuspendResume::SR_SUSPENDED) {\n@@ -1769,1 +1771,1 @@\n-  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n+  if (osthread->sr.request_wakeup() != SuspendResume::SR_WAKEUP_REQUEST) {\n@@ -1790,1 +1792,1 @@\n-void os::SuspendedThreadTask::internal_do_task() {\n+void SuspendedThreadTask::internal_do_task() {\n@@ -1792,1 +1794,1 @@\n-    os::SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n+    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"suspendResume_posix.hpp\"\n+\n+\/* try to switch state from state \"from\" to state \"to\"\n+ * returns the state set after the method is complete\n+ *\/\n+SuspendResume::State SuspendResume::switch_state(SuspendResume::State from,\n+                                                 SuspendResume::State to)\n+{\n+  SuspendResume::State result = Atomic::cmpxchg(&_state, from, to);\n+  if (result == from) {\n+    \/\/ success\n+    return to;\n+  }\n+  return result;\n+}\n","filename":"src\/hotspot\/os\/posix\/suspendResume_posix.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_SUSPENDRESUME_POSIX_HPP\n+#define OS_POSIX_SUSPENDRESUME_POSIX_HPP\n+\n+\/\/ Suspend\/resume support for POSIX platforms\n+\/\/ Protocol:\n+\/\/\n+\/\/ a thread starts in SR_RUNNING\n+\/\/\n+\/\/ SR_RUNNING can go to\n+\/\/   * SR_SUSPEND_REQUEST when the WatcherThread wants to suspend it\n+\/\/ SR_SUSPEND_REQUEST can go to\n+\/\/   * SR_RUNNING if WatcherThread decides it waited for SR_SUSPENDED too long (timeout)\n+\/\/   * SR_SUSPENDED if the stopped thread receives the signal and switches state\n+\/\/ SR_SUSPENDED can go to\n+\/\/   * SR_WAKEUP_REQUEST when the WatcherThread has done the work and wants to resume\n+\/\/ SR_WAKEUP_REQUEST can go to\n+\/\/   * SR_RUNNING when the stopped thread receives the signal\n+\/\/   * SR_WAKEUP_REQUEST on timeout (resend the signal and try again)\n+class SuspendResume {\n+public:\n+  enum State {\n+    SR_RUNNING,\n+    SR_SUSPEND_REQUEST,\n+    SR_SUSPENDED,\n+    SR_WAKEUP_REQUEST\n+  };\n+\n+private:\n+  volatile State _state;\n+\n+private:\n+  \/* try to switch state from state \"from\" to state \"to\"\n+   * returns the state set after the method is complete\n+   *\/\n+  State switch_state(State from, State to);\n+\n+public:\n+  SuspendResume() : _state(SR_RUNNING) { }\n+\n+  State state() const { return _state; }\n+\n+  State request_suspend() {\n+    return switch_state(SR_RUNNING, SR_SUSPEND_REQUEST);\n+  }\n+\n+  State cancel_suspend() {\n+    return switch_state(SR_SUSPEND_REQUEST, SR_RUNNING);\n+  }\n+\n+  State suspended() {\n+    return switch_state(SR_SUSPEND_REQUEST, SR_SUSPENDED);\n+  }\n+\n+  State request_wakeup() {\n+    return switch_state(SR_SUSPENDED, SR_WAKEUP_REQUEST);\n+  }\n+\n+  State running() {\n+    return switch_state(SR_WAKEUP_REQUEST, SR_RUNNING);\n+  }\n+\n+  bool is_running() const {\n+    return _state == SR_RUNNING;\n+  }\n+\n+  bool is_suspended() const {\n+    return _state == SR_SUSPENDED;\n+  }\n+};\n+\n+#endif \/\/ OS_POSIX_SUSPENDRESUME_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/suspendResume_posix.hpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -5542,1 +5542,1 @@\n-void os::SuspendedThreadTask::internal_do_task() {\n+void SuspendedThreadTask::internal_do_task() {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,3 +81,3 @@\n-      \/\/ V  [libjvm.so+0xba0b08]  OSThreadSampler::protected_task(os::SuspendedThreadTaskContext const&)+0x98\n-      \/\/ V  [libjvm.so+0xff33c4]  os::SuspendedThreadTask::internal_do_task()+0x14c\n-      \/\/ V  [libjvm.so+0xfe3c9c]  os::SuspendedThreadTask::run()+0x24\n+      \/\/ V  [libjvm.so+0xba0b08]  OSThreadSampler::protected_task(SuspendedThreadTaskContext const&)+0x98\n+      \/\/ V  [libjvm.so+0xff33c4]  SuspendedThreadTask::internal_do_task()+0x14c\n+      \/\/ V  [libjvm.so+0xfe3c9c]  SuspendedThreadTask::run()+0x24\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/javaThread_linux_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/suspendedThreadTask.hpp\"\n@@ -119,1 +120,1 @@\n-class OSThreadSampler : public os::SuspendedThreadTask {\n+class OSThreadSampler : public SuspendedThreadTask {\n@@ -124,1 +125,1 @@\n-                  u4 max_frames) : os::SuspendedThreadTask((Thread*)thread),\n+                  u4 max_frames) : SuspendedThreadTask((Thread*)thread),\n@@ -132,2 +133,2 @@\n-  void do_task(const os::SuspendedThreadTaskContext& context);\n-  void protected_task(const os::SuspendedThreadTaskContext& context);\n+  void do_task(const SuspendedThreadTaskContext& context);\n+  void protected_task(const SuspendedThreadTaskContext& context);\n@@ -147,1 +148,1 @@\n-  OSThreadSamplerCallback(OSThreadSampler& sampler, const os::SuspendedThreadTaskContext &context) :\n+  OSThreadSamplerCallback(OSThreadSampler& sampler, const SuspendedThreadTaskContext &context) :\n@@ -155,1 +156,1 @@\n-  const os::SuspendedThreadTaskContext& _context;\n+  const SuspendedThreadTaskContext& _context;\n@@ -158,1 +159,1 @@\n-void OSThreadSampler::do_task(const os::SuspendedThreadTaskContext& context) {\n+void OSThreadSampler::do_task(const SuspendedThreadTaskContext& context) {\n@@ -180,1 +181,1 @@\n-void OSThreadSampler::protected_task(const os::SuspendedThreadTaskContext& context) {\n+void OSThreadSampler::protected_task(const SuspendedThreadTaskContext& context) {\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1676,5 +1676,0 @@\n-void os::SuspendedThreadTask::run() {\n-  internal_do_task();\n-  _done = true;\n-}\n-\n@@ -1896,16 +1891,0 @@\n-#ifndef _WINDOWS\n-\/* try to switch state from state \"from\" to state \"to\"\n- * returns the state set after the method is complete\n- *\/\n-os::SuspendResume::State os::SuspendResume::switch_state(os::SuspendResume::State from,\n-                                                         os::SuspendResume::State to)\n-{\n-  os::SuspendResume::State result = Atomic::cmpxchg(&_state, from, to);\n-  if (result == from) {\n-    \/\/ success\n-    return to;\n-  }\n-  return result;\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -920,24 +920,0 @@\n-  class SuspendedThreadTaskContext {\n-  public:\n-    SuspendedThreadTaskContext(Thread* thread, void *ucontext) : _thread(thread), _ucontext(ucontext) {}\n-    Thread* thread() const { return _thread; }\n-    void* ucontext() const { return _ucontext; }\n-  private:\n-    Thread* _thread;\n-    void* _ucontext;\n-  };\n-\n-  class SuspendedThreadTask {\n-  public:\n-    SuspendedThreadTask(Thread* thread) : _thread(thread), _done(false) {}\n-    void run();\n-    bool is_done() { return _done; }\n-    virtual void do_task(const SuspendedThreadTaskContext& context) = 0;\n-  protected:\n-    ~SuspendedThreadTask() {}\n-  private:\n-    void internal_do_task();\n-    Thread* _thread;\n-    bool _done;\n-  };\n-\n@@ -949,69 +925,0 @@\n-#ifndef _WINDOWS\n-  \/\/ Suspend\/resume support\n-  \/\/ Protocol:\n-  \/\/\n-  \/\/ a thread starts in SR_RUNNING\n-  \/\/\n-  \/\/ SR_RUNNING can go to\n-  \/\/   * SR_SUSPEND_REQUEST when the WatcherThread wants to suspend it\n-  \/\/ SR_SUSPEND_REQUEST can go to\n-  \/\/   * SR_RUNNING if WatcherThread decides it waited for SR_SUSPENDED too long (timeout)\n-  \/\/   * SR_SUSPENDED if the stopped thread receives the signal and switches state\n-  \/\/ SR_SUSPENDED can go to\n-  \/\/   * SR_WAKEUP_REQUEST when the WatcherThread has done the work and wants to resume\n-  \/\/ SR_WAKEUP_REQUEST can go to\n-  \/\/   * SR_RUNNING when the stopped thread receives the signal\n-  \/\/   * SR_WAKEUP_REQUEST on timeout (resend the signal and try again)\n-  class SuspendResume {\n-   public:\n-    enum State {\n-      SR_RUNNING,\n-      SR_SUSPEND_REQUEST,\n-      SR_SUSPENDED,\n-      SR_WAKEUP_REQUEST\n-    };\n-\n-  private:\n-    volatile State _state;\n-\n-  private:\n-    \/* try to switch state from state \"from\" to state \"to\"\n-     * returns the state set after the method is complete\n-     *\/\n-    State switch_state(State from, State to);\n-\n-  public:\n-    SuspendResume() : _state(SR_RUNNING) { }\n-\n-    State state() const { return _state; }\n-\n-    State request_suspend() {\n-      return switch_state(SR_RUNNING, SR_SUSPEND_REQUEST);\n-    }\n-\n-    State cancel_suspend() {\n-      return switch_state(SR_SUSPEND_REQUEST, SR_RUNNING);\n-    }\n-\n-    State suspended() {\n-      return switch_state(SR_SUSPEND_REQUEST, SR_SUSPENDED);\n-    }\n-\n-    State request_wakeup() {\n-      return switch_state(SR_SUSPENDED, SR_WAKEUP_REQUEST);\n-    }\n-\n-    State running() {\n-      return switch_state(SR_WAKEUP_REQUEST, SR_RUNNING);\n-    }\n-\n-    bool is_running() const {\n-      return _state == SR_RUNNING;\n-    }\n-\n-    bool is_suspended() const {\n-      return _state == SR_SUSPENDED;\n-    }\n-  };\n-#endif \/\/ !WINDOWS\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":93,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"runtime\/suspendedThreadTask.hpp\"\n@@ -35,0 +35,4 @@\n+#if defined(LINUX) || defined(AIX) || defined(BSD)\n+#include \"suspendResume_posix.hpp\"\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/osThread.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/suspendedThreadTask.hpp\"\n+\n+void SuspendedThreadTask::run() {\n+  internal_do_task();\n+  _done = true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/suspendedThreadTask.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SUSPENDEDTHREADTASK_HPP\n+#define SHARE_RUNTIME_SUSPENDEDTHREADTASK_HPP\n+\n+class Thread;\n+\n+class SuspendedThreadTaskContext {\n+public:\n+  SuspendedThreadTaskContext(Thread* thread, void *ucontext) : _thread(thread), _ucontext(ucontext) {}\n+  Thread* thread() const { return _thread; }\n+  void* ucontext() const { return _ucontext; }\n+private:\n+  Thread* _thread;\n+  void* _ucontext;\n+};\n+\n+class SuspendedThreadTask {\n+public:\n+  SuspendedThreadTask(Thread* thread) : _thread(thread), _done(false) {}\n+  void run();\n+  bool is_done() { return _done; }\n+  virtual void do_task(const SuspendedThreadTaskContext& context) = 0;\n+protected:\n+  ~SuspendedThreadTask() {}\n+private:\n+  void internal_do_task();\n+  Thread* _thread;\n+  bool _done;\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_SUSPENDEDTHREADTASK_HPP\n","filename":"src\/hotspot\/share\/runtime\/suspendedThreadTask.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}