{"files":[{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/suspendedThreadTask.hpp\"\n@@ -43,0 +44,1 @@\n+#include \"suspendResume_posix.hpp\"\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/suspend.hpp\"\n+#include \"suspendResume_posix.hpp\"\n@@ -29,6 +29,0 @@\n-void SuspendedThreadTask::run() {\n-  internal_do_task();\n-  _done = true;\n-}\n-\n-#ifndef _WINDOWS\n@@ -48,1 +42,0 @@\n-#endif\n","filename":"src\/hotspot\/os\/posix\/suspendResume_posix.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"previous_filename":"src\/hotspot\/share\/runtime\/suspend.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_SUSPENDRESUME_POSIX_HPP\n+#define OS_POSIX_SUSPENDRESUME_POSIX_HPP\n+\n+\/\/ Suspend\/resume support for POSIX platforms\n+\/\/ Protocol:\n+\/\/\n+\/\/ a thread starts in SR_RUNNING\n+\/\/\n+\/\/ SR_RUNNING can go to\n+\/\/   * SR_SUSPEND_REQUEST when the WatcherThread wants to suspend it\n+\/\/ SR_SUSPEND_REQUEST can go to\n+\/\/   * SR_RUNNING if WatcherThread decides it waited for SR_SUSPENDED too long (timeout)\n+\/\/   * SR_SUSPENDED if the stopped thread receives the signal and switches state\n+\/\/ SR_SUSPENDED can go to\n+\/\/   * SR_WAKEUP_REQUEST when the WatcherThread has done the work and wants to resume\n+\/\/ SR_WAKEUP_REQUEST can go to\n+\/\/   * SR_RUNNING when the stopped thread receives the signal\n+\/\/   * SR_WAKEUP_REQUEST on timeout (resend the signal and try again)\n+class SuspendResume {\n+public:\n+  enum State {\n+    SR_RUNNING,\n+    SR_SUSPEND_REQUEST,\n+    SR_SUSPENDED,\n+    SR_WAKEUP_REQUEST\n+  };\n+\n+private:\n+  volatile State _state;\n+\n+private:\n+  \/* try to switch state from state \"from\" to state \"to\"\n+   * returns the state set after the method is complete\n+   *\/\n+  State switch_state(State from, State to);\n+\n+public:\n+  SuspendResume() : _state(SR_RUNNING) { }\n+\n+  State state() const { return _state; }\n+\n+  State request_suspend() {\n+    return switch_state(SR_RUNNING, SR_SUSPEND_REQUEST);\n+  }\n+\n+  State cancel_suspend() {\n+    return switch_state(SR_SUSPEND_REQUEST, SR_RUNNING);\n+  }\n+\n+  State suspended() {\n+    return switch_state(SR_SUSPEND_REQUEST, SR_SUSPENDED);\n+  }\n+\n+  State request_wakeup() {\n+    return switch_state(SR_SUSPENDED, SR_WAKEUP_REQUEST);\n+  }\n+\n+  State running() {\n+    return switch_state(SR_WAKEUP_REQUEST, SR_RUNNING);\n+  }\n+\n+  bool is_running() const {\n+    return _state == SR_RUNNING;\n+  }\n+\n+  bool is_suspended() const {\n+    return _state == SR_SUSPENDED;\n+  }\n+};\n+\n+#endif \/\/ OS_POSIX_SUSPENDRESUME_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/suspendResume_posix.hpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"runtime\/suspend.hpp\"\n+#include \"runtime\/suspendedThreadTask.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/suspend.hpp\"\n+#include \"runtime\/suspendedThreadTask.hpp\"\n@@ -35,0 +35,4 @@\n+#if defined(LINUX) || defined(AIX) || defined(BSD)\n+#include \"suspendResume_posix.hpp\"\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/osThread.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_SUSPEND_HPP\n-#define SHARE_RUNTIME_SUSPEND_HPP\n-\n-class Thread;\n-\n-class SuspendedThreadTaskContext {\n-public:\n-  SuspendedThreadTaskContext(Thread* thread, void *ucontext) : _thread(thread), _ucontext(ucontext) {}\n-  Thread* thread() const { return _thread; }\n-  void* ucontext() const { return _ucontext; }\n-private:\n-  Thread* _thread;\n-  void* _ucontext;\n-};\n-\n-class SuspendedThreadTask {\n-public:\n-  SuspendedThreadTask(Thread* thread) : _thread(thread), _done(false) {}\n-  void run();\n-  bool is_done() { return _done; }\n-  virtual void do_task(const SuspendedThreadTaskContext& context) = 0;\n-protected:\n-  ~SuspendedThreadTask() {}\n-private:\n-  void internal_do_task();\n-  Thread* _thread;\n-  bool _done;\n-};\n-\n-#ifndef _WINDOWS\n-\/\/ Suspend\/resume support\n-\/\/ Protocol:\n-\/\/\n-\/\/ a thread starts in SR_RUNNING\n-\/\/\n-\/\/ SR_RUNNING can go to\n-\/\/   * SR_SUSPEND_REQUEST when the WatcherThread wants to suspend it\n-\/\/ SR_SUSPEND_REQUEST can go to\n-\/\/   * SR_RUNNING if WatcherThread decides it waited for SR_SUSPENDED too long (timeout)\n-\/\/   * SR_SUSPENDED if the stopped thread receives the signal and switches state\n-\/\/ SR_SUSPENDED can go to\n-\/\/   * SR_WAKEUP_REQUEST when the WatcherThread has done the work and wants to resume\n-\/\/ SR_WAKEUP_REQUEST can go to\n-\/\/   * SR_RUNNING when the stopped thread receives the signal\n-\/\/   * SR_WAKEUP_REQUEST on timeout (resend the signal and try again)\n-class SuspendResume {\n-public:\n-  enum State {\n-    SR_RUNNING,\n-    SR_SUSPEND_REQUEST,\n-    SR_SUSPENDED,\n-    SR_WAKEUP_REQUEST\n-  };\n-\n-private:\n-  volatile State _state;\n-\n-private:\n-  \/* try to switch state from state \"from\" to state \"to\"\n-   * returns the state set after the method is complete\n-   *\/\n-  State switch_state(State from, State to);\n-\n-public:\n-  SuspendResume() : _state(SR_RUNNING) { }\n-\n-  State state() const { return _state; }\n-\n-  State request_suspend() {\n-    return switch_state(SR_RUNNING, SR_SUSPEND_REQUEST);\n-  }\n-\n-  State cancel_suspend() {\n-    return switch_state(SR_SUSPEND_REQUEST, SR_RUNNING);\n-  }\n-\n-  State suspended() {\n-    return switch_state(SR_SUSPEND_REQUEST, SR_SUSPENDED);\n-  }\n-\n-  State request_wakeup() {\n-    return switch_state(SR_SUSPENDED, SR_WAKEUP_REQUEST);\n-  }\n-\n-  State running() {\n-    return switch_state(SR_WAKEUP_REQUEST, SR_RUNNING);\n-  }\n-\n-  bool is_running() const {\n-    return _state == SR_RUNNING;\n-  }\n-\n-  bool is_suspended() const {\n-    return _state == SR_SUSPENDED;\n-  }\n-};\n-#endif \/\/ !WINDOWS\n-\n-#endif \/\/ SHARE_RUNTIME_SUSPEND_HPP\n","filename":"src\/hotspot\/share\/runtime\/suspend.hpp","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/suspendedThreadTask.hpp\"\n+\n+void SuspendedThreadTask::run() {\n+  internal_do_task();\n+  _done = true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/suspendedThreadTask.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SUSPENDEDTHREADTASK_HPP\n+#define SHARE_RUNTIME_SUSPENDEDTHREADTASK_HPP\n+\n+class Thread;\n+\n+class SuspendedThreadTaskContext {\n+public:\n+  SuspendedThreadTaskContext(Thread* thread, void *ucontext) : _thread(thread), _ucontext(ucontext) {}\n+  Thread* thread() const { return _thread; }\n+  void* ucontext() const { return _ucontext; }\n+private:\n+  Thread* _thread;\n+  void* _ucontext;\n+};\n+\n+class SuspendedThreadTask {\n+public:\n+  SuspendedThreadTask(Thread* thread) : _thread(thread), _done(false) {}\n+  void run();\n+  bool is_done() { return _done; }\n+  virtual void do_task(const SuspendedThreadTaskContext& context) = 0;\n+protected:\n+  ~SuspendedThreadTask() {}\n+private:\n+  void internal_do_task();\n+  Thread* _thread;\n+  bool _done;\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_SUSPENDEDTHREADTASK_HPP\n","filename":"src\/hotspot\/share\/runtime\/suspendedThreadTask.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}