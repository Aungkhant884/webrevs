{"files":[{"patch":"@@ -1105,0 +1105,7 @@\n+\/\/\n+\/\/ The safepoints using the Phi node have to be processed before safepoints of\n+\/\/ CastPP nodes. The reason is, when reducing a CastPP we add a reference (the\n+\/\/ NSR merge pointer) to the input of the CastPP (i.e., the Phi) in the\n+\/\/ safepoint. If we process CastPP's safepoints before Phi's safepoints the\n+\/\/ algorithm that process Phi's safepoints will think that the added Phi\n+\/\/ reference is a regular reference.\n@@ -1106,1 +1113,0 @@\n-  Unique_Node_List safepoints;\n@@ -1108,0 +1114,2 @@\n+  Unique_Node_List safepoints;\n+  Unique_Node_List casts;\n@@ -1109,2 +1117,3 @@\n-  uint outcnt = ophi->outcnt();\n-  for (uint i = 0; i < outcnt; i++) {\n+  \/\/ Just collect the users of the Phis for later processing\n+  \/\/ in the needed order.\n+  for (uint i = 0; i < ophi->outcnt(); i++) {\n@@ -1115,1 +1124,5 @@\n-      Unique_Node_List child_sfpts;\n+      casts.push(use);\n+    } else {\n+      assert(use->outcnt() == 0, \"Only CastPP & SafePoint users should be left.\");\n+    }\n+  }\n@@ -1117,8 +1130,4 @@\n-      for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n-        Node* use_use = use->fast_out(j);\n-        if (use_use->is_SafePoint()) {\n-          child_sfpts.push(use_use);\n-        } else {\n-          assert(use_use->outcnt() == 0, \"Only SafePoint users should be left.\");\n-        }\n-      }\n+  \/\/ Need to process safepoints using the Phi first\n+  if (!reduce_phi_on_safepoints_helper(ophi, nullptr, selector, safepoints)) {\n+    return false;\n+  }\n@@ -1126,2 +1135,11 @@\n-      if (!reduce_phi_on_safepoints_helper(ophi, use, selector, child_sfpts)) {\n-        return false;\n+  \/\/ Now process CastPP->safepoints\n+  for (uint i = 0; i < casts.size(); i++) {\n+    Node* cast = casts.at(i);\n+    Unique_Node_List cast_sfpts;\n+\n+    for (DUIterator_Fast jmax, j = cast->fast_outs(jmax); j < jmax; j++) {\n+      Node* use_use = cast->fast_out(j);\n+      if (use_use->is_SafePoint()) {\n+        cast_sfpts.push(use_use);\n+      } else {\n+        assert(use_use->outcnt() == 0, \"Only SafePoint users should be left.\");\n@@ -1130,0 +1148,4 @@\n+\n+    if (!reduce_phi_on_safepoints_helper(ophi, cast, selector, cast_sfpts)) {\n+      return false;\n+    }\n@@ -1132,1 +1154,1 @@\n-  return reduce_phi_on_safepoints_helper(ophi, nullptr, selector, safepoints);\n+  return true;\n@@ -4492,1 +4514,1 @@\n-        assert(false, \"Unexpected user of reducible Phi -> %s\", use->Name());\n+        assert(false, \"Unexpected user of reducible Phi -> %s : %d\", use->Name(), use->outcnt());\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":38,"deletions":16,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                                   \"-XX:CompileCommand=inline,*Nested::*\",\n@@ -95,1 +96,3 @@\n-                 \"testString_two_C2\"\n+                 \"testString_two_C2\",\n+                 \"testLoadNarrowKlass_C2\",\n+                 \"testReReduce_C2\"\n@@ -150,0 +153,2 @@\n+        Asserts.assertEQ(testLoadNarrowKlass_Interp(cond1),                         testLoadNarrowKlass_C2(cond1));\n+        Asserts.assertEQ(testReReduce_Interp(cond1, x, y),                          testReReduce_C2(cond1, x, y));\n@@ -1254,0 +1259,56 @@\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    Class testLoadNarrowKlass(boolean cond1) {\n+        Object p = new Circle(10);\n+\n+        if (cond1) {\n+            p = dummy(1, 2);\n+        }\n+\n+        return p.getClass();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ The allocation won't be reduced because we don't support NarrowKlass\n+    \/\/ loads under CastPPs.\n+    Class testLoadNarrowKlass_C2(boolean cond1) { return testLoadNarrowKlass(cond1); }\n+\n+    @DontCompile\n+    Class testLoadNarrowKlass_Interp(boolean cond1) { return testLoadNarrowKlass(cond1); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testReReduce(boolean cond, int x, int y) {\n+        Nested A = new Nested(x, y);\n+        Nested B = new Nested(y, x);\n+        Nested C = new Nested(y, x);\n+        Nested P = null;\n+\n+        if (x == y) {\n+            A.other = B;\n+            P = A;\n+        } else if (x > y) {\n+            P = B;\n+        } else {\n+            C.other = B;\n+            P = C;\n+        }\n+\n+        if (x == y)\n+            dummy_defaults();\n+\n+        return P.x;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ The last allocation won't be reduced because it would cause the creation\n+    \/\/ of a nested SafePointScalarMergeNode.\n+    int testReReduce_C2(boolean cond1, int x, int y) { return testReReduce(cond1, x, y); }\n+\n+    @DontCompile\n+    int testReReduce_Interp(boolean cond1, int x, int y) { return testReReduce(cond1, x, y); }\n+\n@@ -1285,0 +1346,10 @@\n+    static class Nested {\n+        int x, y;\n+        Nested other;\n+        Nested(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+            this.other = null;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"}]}