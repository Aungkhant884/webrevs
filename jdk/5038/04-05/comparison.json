{"files":[{"patch":"@@ -379,1 +379,1 @@\n-                c.sourcefile = tree.sourcefile;\n+                c.classfile = c.sourcefile = tree.sourcefile;\n@@ -498,1 +498,1 @@\n-        c.sourcefile = env.toplevel.sourcefile;\n+        c.classfile = c.sourcefile = env.toplevel.sourcefile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-            sym.module_info.sourcefile = toplevel.sourcefile;\n+            sym.module_info.classfile = sym.module_info.sourcefile = toplevel.sourcefile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -731,10 +731,15 @@\n-    public javax.tools.JavaFileObject getFileObjectOf(Element e) {\n-        return switch(e.getKind()) {\n-            case PACKAGE -> ((PackageSymbol)e).sourcefile;\n-            \/\/ TODO: ModuleSymbol doesn't directly have a JavaFileObject field at present.\n-            case MODULE  -> null;\n-            \/\/ TODO: this is likely not quite right for nested types\n-            \/\/ that have already been compiled; their class file\n-            \/\/ should be their own class file rather than the class\n-            \/\/ file for the outermost class.\n-            default      -> ((Symbol)e).outermostClass().classfile;\n+    public JavaFileObject getFileObjectOf(Element e) {\n+        Symbol sym = (Symbol) e;\n+        return switch(sym.kind) {\n+            case PCK -> {\n+                if (((PackageSymbol) sym).package_info == null) {\n+                    yield null;\n+                }\n+                yield ((PackageSymbol) sym).package_info.classfile;\n+            }\n+            case MDL -> {\n+                ModuleSymbol msym = (ModuleSymbol) sym;\n+                yield msym.module_info.classfile;\n+            }\n+            case TYP -> ((ClassSymbol) sym).classfile;\n+            default -> sym.enclClass().classfile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,324 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8224922\n+ * @summary Verify the behavior of the Elements.getFileObjectOf\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask toolbox.TestRunner\n+ * @build TestFileObjectOf\n+ * @run main TestFileObjectOf\n+ *\/\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import javax.tools.JavaFileObject;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TestFileObjectOf extends TestRunner {\n+\n+    private final ToolBox tb;\n+\n+    TestFileObjectOf() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new TestFileObjectOf().runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSourceFiles(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module m {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public class TestClass {\n+                              int fieldTestClass;\n+                              TestClass() { }\n+                              void methodTestClass(int parameterTestClass) {\n+                                  int localTestClass;\n+                              }\n+                              public static class InnerClass {\n+                                  int fieldInnerClass;\n+                                  InnerClass() {}\n+                                  void methodInnerClass(int parameterInnerClass) {\n+                                      int localInnerClass;\n+                                  }\n+                              }\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public enum TestEnum {\n+                              CONSTANT;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test2;\n+                          public class TestClass2 {}\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\").resolve(\"m\");\n+        tb.createDirectories(classes);\n+\n+        \/\/from source, implicit:\n+        {\n+            String moduleInfoSource = src.resolve(\"module-info.java\").toUri().toString();\n+            String packageInfoSource = src.resolve(\"test\").resolve(\"package-info.java\").toUri().toString();\n+            String testClassSource = src.resolve(\"test\").resolve(\"TestClass.java\").toUri().toString();\n+            String testEnumSource = src.resolve(\"test\").resolve(\"TestEnum.java\").toUri().toString();\n+            String testClass2Source = src.resolve(\"test2\").resolve(\"TestClass2.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName(),\n+                         \"-sourcepath\", src.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"parameterTestClass: \" + testClassSource,\n+                    \"localTestClass: \" + testClassSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"fieldInnerClass: \" + testClassSource,\n+                    \"methodInnerClass: \" + testClassSource,\n+                    \"parameterInnerClass: \" + testClassSource,\n+                    \"localInnerClass: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        tb.cleanDirectory(classes);\n+\n+        \/\/from source, explicit:\n+        {\n+            String moduleInfoSource = src.resolve(\"module-info.java\").toUri().toString();\n+            String packageInfoSource = src.resolve(\"test\").resolve(\"package-info.java\").toUri().toString();\n+            String testClassSource = src.resolve(\"test\").resolve(\"TestClass.java\").toUri().toString();\n+            String testEnumSource = src.resolve(\"test\").resolve(\"TestEnum.java\").toUri().toString();\n+            String testClass2Source = src.resolve(\"test2\").resolve(\"TestClass2.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"parameterTestClass: \" + testClassSource,\n+                    \"localTestClass: \" + testClassSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"fieldInnerClass: \" + testClassSource,\n+                    \"methodInnerClass: \" + testClassSource,\n+                    \"parameterInnerClass: \" + testClassSource,\n+                    \"localInnerClass: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        \/\/from class:\n+        {\n+            String moduleInfoSource = classes.resolve(\"module-info.class\").toUri().toString();\n+            String packageInfoSource = classes.resolve(\"test\").resolve(\"package-info.class\").toUri().toString();\n+            String testClassSource = classes.resolve(\"test\").resolve(\"TestClass.class\").toUri().toString();\n+            String testInnerClassSource = classes.resolve(\"test\").resolve(\"TestClass$InnerClass.class\").toUri().toString();\n+            String testEnumSource = classes.resolve(\"test\").resolve(\"TestEnum.class\").toUri().toString();\n+            String testClass2Source = classes.resolve(\"test2\").resolve(\"TestClass2.class\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName(),\n+                         \"--module-path\", classes.toString(),\n+                         \"--add-modules\", \"m\")\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testInnerClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"<clinit>: \" + testEnumSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testInnerClassSource,\n+                    \"fieldInnerClass: \" + testInnerClassSource,\n+                    \"methodInnerClass: \" + testInnerClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class PrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"m\"));\n+            \n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"test\"));\n+                        q.add(elements.getPackageElement(\"test2\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestFileObjectOf.java","additions":324,"deletions":0,"binary":false,"changes":324,"status":"added"},{"patch":"@@ -92,1 +92,2 @@\n-            \"javax.annotation.processing.SupportedSourceVersion\"\n+            \"javax.annotation.processing.SupportedSourceVersion\",\n+            \"javax.tools.JavaFileObject\"\n","filename":"test\/langtools\/tools\/javac\/tree\/NoPrivateTypesExported.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}