{"files":[{"patch":"@@ -735,1 +735,2 @@\n-                if (((PackageSymbol) sym).package_info == null) {\n+                PackageSymbol psym = (PackageSymbol) sym;\n+                if (psym.package_info == null) {\n@@ -738,1 +739,1 @@\n-                yield ((PackageSymbol) sym).package_info.classfile;\n+                yield psym.package_info.classfile;\n@@ -740,0 +741,1 @@\n+\n@@ -742,0 +744,3 @@\n+                if (msym.module_info == null) {\n+                    yield null;\n+                }\n@@ -744,2 +749,2 @@\n-            case TYP -> ((ClassSymbol) sym).classfile;\n-            default -> sym.enclClass().classfile;\n+            case TYP -> ((ClassSymbol) sym).outermostClass().classfile;\n+            default -> sym.outermostClass().classfile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import toolbox.JarTask;\n@@ -324,0 +325,271 @@\n+    @Test\n+    public void testUnnamed(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          public class TestClass {\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        \/\/from source, implicit:\n+        {\n+            String testClassSource = src.resolve(\"TestClass.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName(),\n+                         \"-sourcepath\", src.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        tb.cleanDirectory(classes);\n+\n+        \/\/from source, explicit:\n+        {\n+            String testClassSource = src.resolve(\"TestClass.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        \/\/from class:\n+        {\n+            String testClassSource = classes.resolve(\"TestClass.class\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName(),\n+                         \"-classpath\", classes.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class UnnamedPrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testAutomaticModule(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          public class TestClass {\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        Path module = base.resolve(\"m.jar\");\n+\n+        new JavacTask(tb)\n+            .options(\"-classpath\", \"\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+        new JarTask(tb, module)\n+            .baseDir(classes)\n+            .files(\".\")\n+            .run();\n+\n+        String testClassSource = \"jar:file:\/\/\" + module.toAbsolutePath().toString() + \"!\/test\/TestClass.class\";\n+\n+        List<String> log;\n+\n+        log = new JavacTask(tb)\n+            .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                     \"-processor\", AutomaticModulePrintFiles.class.getName(),\n+                     \"--module-path\", module.toString(),\n+                     \"--add-modules\", \"m\")\n+            .outdir(classes)\n+            .classes(\"java.lang.Object\")\n+            .run()\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        List<String> expected = List.of(\n+                \"m: \" + \"<null>\",\n+                \"test: \" + \"<null>\",\n+                \"TestClass: \" + testClassSource,\n+                \"<init>: \" + testClassSource\n+        );\n+\n+        if (!expected.equals(log))\n+            throw new AssertionError(\"expected output not found: \" + log);\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class AutomaticModulePrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"m\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"test\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestFileObjectOf.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"modified"}]}