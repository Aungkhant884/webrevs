{"files":[{"patch":"@@ -134,0 +134,6 @@\n+    \/**\n+     * {@return the class or interface defining the executable}\n+     *\/\n+    @Override\n+    Element getEnclosingElement();\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -803,10 +803,36 @@\n-     * <p>For other kinds of elements, if they have a file object, the\n-     * file object will be the object associated with the {@linkplain\n-     * #getOutermostTypeElement(Element) outermost class or interface\n-     * of the element}. For top-level classes and interfaces, the name\n-     * of the file object will commonly contain the name of the\n-     * top-level class or interface. For example, for class {@code\n-     * Foo}, its file name could contain \"{@code Foo.java}\". Note\n-     * however that a single source file can contain multiple\n-     * top-level files so this pattern so this relationship does not\n-     * always hold.\n+     * <p>If it has a file object, the file object for a top-level\n+     * {@code public} class or interface will be a source or class\n+     * file corresponding to that class or interface. In this case,\n+     * typically the leading portion of the name of the file will match\n+     * the name of the class or interface. A single compilation unit\n+     * can define multiple top-level classes and interfaces, such as a\n+     * primary {@code public} class or interfaces whose name\n+     * corresponds to the file name and one or more <em>auxiliary<\/em>\n+     * classes or interfaces whose names do not correspond to the file\n+     * name. If a source file is providing the reference\n+     * representation of an auxiliary class or interface, the file\n+     * for the primary class is returned. If a class file is providing\n+     * the reference representation of an auxiliary class or interface,\n+     * the separate class file for the auxiliary class is returned.\n+     *\n+     * <p>For a nested class or interface, if it has a file object:\n+     *\n+     * <ul>\n+     *\n+     * <li>if a source file is providing the reference representation,\n+     * the file object will be that of the {@linkplain\n+     * #getOutermostTypeElement(Element) outermost enclosing} class or\n+     * interface\n+     *\n+     * <li>if a class file is providing the reference representation,\n+     * the file object for be for the nested class or interface itself\n+     *\n+     * <\/ul>\n+     *\n+     * <p>For other lexically enclosed elements, such as {@linkplain\n+     * VariableElement#getEnclosingElement() variables}, {@linkplain\n+     * ExecutableElement#getEnclosingElement() methods, and\n+     * constructors}, if they have a file object, the file object will\n+     * be the object associated with the {@linkplain\n+     * Element#getEnclosingElement() enclosing element} of the nested\n+     * element.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":36,"deletions":10,"binary":false,"changes":46,"status":"modified"}]}