{"files":[{"patch":"@@ -1163,1 +1163,1 @@\n-\/\/ Mirror of Integer.stringSize() method, return the count of digits in integer,\n+\/\/ Mirror of DecimalDigits.stringSize() method, return the count of digits in integer,\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -832,1 +833,1 @@\n-        int spaceNeeded = count + Integer.stringSize(i);\n+        int spaceNeeded = count + DecimalDigits.stringSize(i);\n@@ -835,1 +836,1 @@\n-            StringLatin1.getChars(i, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(i, spaceNeeded, value);\n@@ -837,1 +838,3 @@\n-            StringUTF16.getChars(i, count, spaceNeeded, value);\n+            StringUTF16.checkBoundsBeginEnd(count, spaceNeeded, value);\n+            int pos = DecimalDigits.getCharsUTF16(i, spaceNeeded, value);\n+            assert count == pos;\n@@ -857,1 +860,1 @@\n-        int spaceNeeded = count + Long.stringSize(l);\n+        int spaceNeeded = count + DecimalDigits.stringSize(l);\n@@ -860,1 +863,1 @@\n-            StringLatin1.getChars(l, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(l, spaceNeeded, value);\n@@ -862,1 +865,3 @@\n-            StringUTF16.getChars(l, count, spaceNeeded, value);\n+            StringUTF16.checkBoundsBeginEnd(count, spaceNeeded, value);\n+            int pos = DecimalDigits.getCharsUTF16(l, spaceNeeded, value);\n+            assert count == pos;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -429,1 +430,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -432,1 +433,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -436,1 +437,1 @@\n-            StringUTF16.getChars(i, size, buf);\n+            DecimalDigits.getCharsUTF16(i, size, buf);\n@@ -459,26 +460,0 @@\n-    \/**\n-     * Returns the string representation size for a given int value.\n-     *\n-     * @param x int value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(int x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        int p = -10;\n-        for (int i = 1; i < 10; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 10 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -459,1 +460,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -462,1 +463,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -466,1 +467,1 @@\n-            StringUTF16.getChars(i, size, buf);\n+            DecimalDigits.getCharsUTF16(i, size, buf);\n@@ -489,26 +490,0 @@\n-    \/**\n-     * Returns the string representation size for a given long value.\n-     *\n-     * @param x long value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(long x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        long p = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 19 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -101,1 +102,1 @@\n-        return checkOverflow(lengthCoder + Integer.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -112,1 +113,1 @@\n-        return checkOverflow(lengthCoder + Long.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -253,1 +254,1 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            return DecimalDigits.getCharsLatin1(value, (int)indexCoder, buf);\n@@ -255,1 +256,1 @@\n-            return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;\n+            return DecimalDigits.getCharsUTF16(value, (int)indexCoder, buf) | UTF16;\n@@ -288,1 +289,1 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            return DecimalDigits.getCharsLatin1(value, (int)indexCoder, buf);\n@@ -290,1 +291,1 @@\n-            return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;\n+            return DecimalDigits.getCharsUTF16(value, (int)indexCoder, buf) | UTF16;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -82,114 +82,0 @@\n-    \/**\n-     * Places characters representing the integer i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n-     * integer.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(int i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        int q;\n-        int charPos = index;\n-\n-        boolean negative = i < 0;\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Generate two digits per iteration\n-        while (i <= -100) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (q * 100) - i);\n-            i = q;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i < -9) {\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, -i);\n-        } else {\n-            buf[--charPos] = (byte)('0' - i);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n-    \/**\n-     * Places characters representing the long i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n-     * long.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(long i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        long q;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i <= Integer.MIN_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (int)((q * 100) - i));\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int)i;\n-        while (i2 <= -100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (q2 * 100) - i2);\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 < -9) {\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, -i2);\n-        } else {\n-            buf[--charPos] = (byte)('0' - i2);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n-    private static void writeDigitPair(byte[] buf, int charPos, int value) {\n-        short pair = DecimalDigits.digitPair(value);\n-        buf[charPos] = (byte)(pair);\n-        buf[charPos + 1] = (byte)(pair >> 8);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -1363,1 +1363,1 @@\n-        int pos = getChars(i, end, value);\n+        int pos = DecimalDigits.getCharsUTF16(i, end, value);\n@@ -1370,1 +1370,1 @@\n-        int pos = getChars(l, end, value);\n+        int pos = DecimalDigits.getCharsUTF16(l, end, value);\n@@ -1519,103 +1519,0 @@\n-    \/\/ Used by trusted callers.  Assumes all necessary bounds checks have\n-    \/\/ been done by the caller.\n-\n-    \/**\n-     * This is a variant of {@link StringLatin1#getChars(int, int, byte[])}, but for\n-     * UTF-16 coder.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, UTF16-coded.\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(int i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        int q, r;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        while (i <= -100) {\n-            q = i \/ 100;\n-            r = (q * 100) - i;\n-            i = q;\n-            charPos -= 2;\n-            putPair(buf, charPos, r);\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i < -9) {\n-            charPos -= 2;\n-            putPair(buf, charPos, -i);\n-        } else {\n-            putChar(buf, --charPos, '0' - i);\n-        }\n-\n-        if (negative) {\n-            putChar(buf, --charPos, '-');\n-        }\n-        return charPos;\n-    }\n-\n-    \/**\n-     * This is a variant of {@link StringLatin1#getChars(long, int, byte[])}, but for\n-     * UTF-16 coder.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, UTF16-coded.\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(long i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        long q;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i <= Integer.MIN_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            putPair(buf, charPos, (int)((q * 100) - i));\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int)i;\n-        while (i2 <= -100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            putPair(buf, charPos, (q2 * 100) - i2);\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 < -9) {\n-            charPos -= 2;\n-            putPair(buf, charPos, -i2);\n-        } else {\n-            putChar(buf, --charPos, '0' - i2);\n-        }\n-\n-        if (negative) {\n-            putChar(buf, --charPos, '-');\n-        }\n-        return charPos;\n-    }\n-\n-    private static void putPair(byte[] buf, int charPos, int v) {\n-        int packed = (int) DecimalDigits.digitPair(v);\n-        putChar(buf, charPos, packed & 0xFF);\n-        putChar(buf, charPos + 1, packed >> 8);\n-    }\n-    \/\/ End of trusted methods.\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":2,"deletions":105,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2482,0 +2482,3 @@\n+            public void putUTF16Char(byte[] bytes, int index, int ch) {\n+                StringUTF16.putChar(bytes, index, ch);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -2894,18 +2896,0 @@\n-        \/*\n-         * Copied from Long.stringSize\n-         *\/\n-        private static int stringSize(long x) {\n-            int d = 1;\n-            if (x >= 0) {\n-                d = 0;\n-                x = -x;\n-            }\n-            long p = -10;\n-            for (int i = 1; i < 19; i++) {\n-                if (x > p)\n-                    return i + d;\n-                p = 10 * p;\n-            }\n-            return 19 + d;\n-        }\n-\n@@ -2920,1 +2904,1 @@\n-            int size = stringSize(value);\n+            int size = DecimalDigits.stringSize(value);\n@@ -3354,11 +3338,0 @@\n-        \/\/ Simplified variant of Integer.stringSize that assumes positive values\n-        private static int stringSize(int x) {\n-            int p = 10;\n-            for (int i = 1; i < 10; i++) {\n-                if (x < p)\n-                    return i;\n-                p = 10 * p;\n-            }\n-            return 10;\n-        }\n-\n@@ -3385,1 +3358,1 @@\n-            int stringSize = stringSize(val);\n+            int stringSize = DecimalDigits.stringSize(val);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":4,"deletions":31,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -356,0 +356,10 @@\n+    \/**\n+     * Put the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     * @param ch the Unicode character to be encoded and stored\n+     *\/\n+    void putUTF16Char(byte[] bytes, int index, int ch);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,1 +35,2 @@\n- * Digits class for decimal digits.\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * decimal digits ASCII strings.\n@@ -38,0 +41,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -62,0 +66,5 @@\n+    \/**\n+     * Singleton instance of DecimalDigits.\n+     *\/\n+    public static final Digits INSTANCE = new DecimalDigits();\n+\n@@ -75,5 +84,0 @@\n-    \/**\n-     * Singleton instance of DecimalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new DecimalDigits();\n-\n@@ -136,2 +140,2 @@\n-        boolean negative = value < 0;\n-        int sign = negative ? 1 : 0;\n+        return stringSize(value);\n+    }\n@@ -139,2 +143,16 @@\n-        if (!negative) {\n-            value = -value;\n+    \/**\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(int x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n@@ -142,0 +160,8 @@\n+        int p = -10;\n+        for (int i = 1; i < 10; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 10 + d;\n+    }\n@@ -143,1 +169,18 @@\n-        long precision = -10;\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(long x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        long p = -10;\n@@ -145,2 +188,36 @@\n-            if (value > precision)\n-                return i + sign;\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 19 + d;\n+    }\n+\n+    \/\/ Used by trusted callers.  Assumes all necessary bounds checks have\n+    \/\/ been done by the caller.\n+\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there. <strong>Caller must ensure buf has enough capacity for the value to be written!<\/strong>\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n+     * integer.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q, r;\n+        int charPos = index;\n+\n+        boolean negative = i < 0;\n+        if (!negative) {\n+            i = -i;\n+        }\n@@ -148,1 +225,7 @@\n-            precision = 10 * precision;\n+        \/\/ Generate two digits per iteration\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            r = (q * 100) - i;\n+            i = q;\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, r);\n@@ -151,1 +234,12 @@\n-        return 19 + sign;\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i < -9) {\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, -i);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i);\n+        }\n+\n+        if (negative) {\n+            buf[--charPos] = (byte)'-';\n+        }\n+        return charPos;\n@@ -154,0 +248,1 @@\n+\n@@ -155,3 +250,15 @@\n-     * For values from 0 to 99 return a short encoding a pair of ASCII-encoded digit characters in little-endian\n-     * @param i value to convert\n-     * @return a short encoding a pair of ASCII-encoded digit characters\n+     * Places characters representing the long i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there. <strong>Caller must ensure buf has enough capacity for the value to be written!<\/strong>\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n+     * long.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n@@ -159,2 +266,145 @@\n-    public static short digitPair(int i) {\n-        return DIGITS[i];\n+    public static int getCharsLatin1(long i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        long q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i <= Integer.MIN_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, (int)((q * 100) - i));\n+            i = q;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int)i;\n+        while (i2 <= -100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, (q2 * 100) - i2);\n+            i2 = q2;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 < -9) {\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, -i2);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i2);\n+        }\n+\n+        if (negative) {\n+            buf[--charPos] = (byte)'-';\n+        }\n+        return charPos;\n+    }\n+\n+    \/**\n+     * This is a variant of {@link StringLatin1#getChars(int, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, UTF16-coded.\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsUTF16(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q, r;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            r = (q * 100) - i;\n+            i = q;\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, r);\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i < -9) {\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, -i);\n+        } else {\n+            JLA.putUTF16Char(buf, --charPos, '0' - i);\n+        }\n+\n+        if (negative) {\n+            JLA.putUTF16Char(buf, --charPos, '-');\n+        }\n+        return charPos;\n+    }\n+\n+    \/**\n+     * This is a variant of {@link StringLatin1#getChars(long, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, UTF16-coded.\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsUTF16(long i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        long q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i <= Integer.MIN_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, (int)((q * 100) - i));\n+            i = q;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int)i;\n+        while (i2 <= -100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, (q2 * 100) - i2);\n+            i2 = q2;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 < -9) {\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, -i2);\n+        } else {\n+            JLA.putUTF16Char(buf, --charPos, '0' - i2);\n+        }\n+\n+        if (negative) {\n+            JLA.putUTF16Char(buf, --charPos, '-');\n+        }\n+        return charPos;\n+    }\n+\n+    private static void writeDigitPairLatin1(byte[] buf, int charPos, int value) {\n+        short pair = DIGITS[value];\n+        buf[charPos] = (byte)(pair);\n+        buf[charPos + 1] = (byte)(pair >> 8);\n+    }\n+\n+    private static void writeDigitPairUTF16(byte[] buf, int charPos, int value) {\n+        int pair = (int) DIGITS[value];\n+        JLA.putUTF16Char(buf, charPos, pair & 0xFF);\n+        JLA.putUTF16Char(buf, charPos + 1, pair >> 8);\n@@ -162,0 +412,1 @@\n+    \/\/ End of trusted methods.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":271,"deletions":20,"binary":false,"changes":291,"status":"modified"}]}