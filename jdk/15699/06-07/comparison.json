{"files":[{"patch":"@@ -550,0 +550,6 @@\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static boolean isLatin1(long indexCoder) {\n+        return indexCoder < UTF16;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2522,0 +2522,8 @@\n+            public boolean stringConcatHelpeIsLatin1(long lengthCoder) {\n+                return StringConcatHelper.isLatin1(lengthCoder);\n+            }\n+\n+            public void stringConcatHelperPutCharUTF16(byte[] buffer, int index, int ch) {\n+                StringConcatHelper.putCharUTF16(buffer, index, ch);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,11 +102,2 @@\n-    private static final MethodHandle PUT_CHAR_DIGIT;\n-\n-    static {\n-        try {\n-            Lookup lookup = MethodHandles.lookup();\n-            PUT_CHAR_DIGIT = lookup.findStatic(FormatItem.class, \"putByte\",\n-                    MethodType.methodType(void.class,\n-                            byte[].class, int.class, int.class));\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(\"putByte lookup failed\", ex);\n-        }\n+    private static void putCharUTF16(byte[] buffer, int index, int ch) {\n+        JLA.stringConcatHelperPutCharUTF16(buffer, index, ch);\n@@ -115,2 +106,2 @@\n-    private static void putByte(byte[] buffer, int index, int ch) {\n-        buffer[index] = (byte)ch;\n+    private static boolean isLatin1(long lengthCoder) {\n+        return JLA.stringConcatHelpeIsLatin1(lengthCoder);\n@@ -175,1 +166,6 @@\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n@@ -177,0 +173,1 @@\n+        private long prependUTF16(long lengthCoder, byte[] buffer) throws Throwable {\n@@ -178,1 +175,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)')');\n+                putCharUTF16(buffer, (int)--lengthCoder, (int)')');\n@@ -186,2 +183,1 @@\n-                        putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                                (int)groupingSeparator);\n+                        putCharUTF16(buffer, (int) --lengthCoder, (int) groupingSeparator);\n@@ -191,2 +187,1 @@\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n+                    putCharUTF16(buffer, (int) --lengthCoder, digits[digits.length - i] + digitOffset);\n@@ -196,2 +191,1 @@\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n+                    putCharUTF16(buffer, (int) --lengthCoder, digits[digits.length - i] + digitOffset);\n@@ -202,1 +196,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) '0');\n@@ -206,1 +200,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'(');\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) '(');\n@@ -208,0 +202,1 @@\n+\n@@ -209,1 +204,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)prefixSign);\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) prefixSign);\n@@ -214,0 +209,39 @@\n+\n+        private long prependLatin1(long lengthCoder, byte[] buffer) throws Throwable {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+\n+            if (parentheses) {\n+                buffer[--lengthCoderLatin1] = ')';\n+            }\n+\n+            if (0 < groupSize) {\n+                int groupIndex = groupSize;\n+\n+                for (int i = 1; i <= length; i++) {\n+                    if (groupIndex-- == 0) {\n+                        buffer[--lengthCoderLatin1] = (byte) groupingSeparator;\n+                        groupIndex = groupSize - 1;\n+                    }\n+\n+                    buffer[--lengthCoderLatin1] = (byte) (digits[digits.length - i] + digitOffset);\n+                }\n+            } else {\n+                for (int i = 1; i <= length; i++) {\n+                    buffer[--lengthCoderLatin1] = (byte) (digits[digits.length - i] + digitOffset);\n+                }\n+            }\n+\n+            for (int i = length + signLength() + groupLength(); i < width; i++) {\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            if (parentheses) {\n+                buffer[--lengthCoderLatin1] = '(';\n+            }\n+\n+            if (prefixSign != '\\0') {\n+                buffer[--lengthCoderLatin1] = prefixSign;\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n@@ -224,0 +258,1 @@\n+        private final byte[] digits;\n@@ -229,1 +264,3 @@\n-            this.length = HexDigits.INSTANCE.size(value);\n+            this.length = HexDigits.stringSize(value);\n+            this.digits = new byte[length];\n+            HexDigits.getCharsLatin1(value, length, this.digits);\n@@ -247,3 +284,25 @@\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            HexDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n-            lengthCoder -= length;\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n+\n+        protected long prependLatin1(long lengthCoder, byte[] buffer) throws Throwable {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+            for (int i = 1; i <= length; i++) {\n+                buffer[--lengthCoderLatin1] = digits[digits.length - i];\n+            }\n+\n+            if (hasPrefix && value != 0) {\n+                buffer[--lengthCoderLatin1] = 'x';\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n+\n+        protected long prependUTF16(long lengthCoder, byte[] buffer) throws Throwable {\n+            for (int i = 1; i <= length; i++) {\n+                putCharUTF16(buffer, (int)--lengthCoder, digits[digits.length - i]);\n+            }\n@@ -252,1 +311,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -255,3 +314,3 @@\n-            if (hasPrefix) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'x');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            if (hasPrefix && value != 0) {\n+                putCharUTF16(buffer, (int)--lengthCoder, 'x');\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -272,0 +331,1 @@\n+        private final byte[] digits;\n@@ -277,1 +337,3 @@\n-            this.length = OctalDigits.INSTANCE.size(value);\n+            this.length = OctalDigits.stringSize(value);\n+            this.digits = new byte[length];\n+            OctalDigits.getCharsLatin1(value, length, this.digits);\n@@ -295,3 +357,6 @@\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            OctalDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n-            lengthCoder -= length;\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n@@ -299,2 +364,21 @@\n-            for (int i = 0; i < zeroesLength(); i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+        protected long prependLatin1(long lengthCoder, byte[] buffer) throws Throwable {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+            for (int i = 1; i <= length; i++) {\n+                buffer[--lengthCoderLatin1] = digits[digits.length - i];\n+            }\n+\n+            int zeroesLength = zeroesLength();\n+            if (hasPrefix && value != 0) {\n+                zeroesLength++;\n+            }\n+\n+            for (int i = 0; i < zeroesLength; i++) {\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n+\n+        protected long prependUTF16(long lengthCoder, byte[] buffer) throws Throwable {\n+            for (int i = 1; i <= length; i++) {\n+                putCharUTF16(buffer, (int)--lengthCoder, digits[digits.length - i]);\n@@ -303,0 +387,1 @@\n+            int zeroesLength = zeroesLength();\n@@ -304,1 +389,4 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                zeroesLength++;\n+            }\n+            for (int i = 0; i < zeroesLength; i++) {\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":127,"deletions":39,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -409,0 +409,10 @@\n+    \/**\n+     * Returns {@code true} if lengthCoder is Latin1\n+     *\/\n+    boolean stringConcatHelpeIsLatin1(long lengthCoder);\n+\n+    \/**\n+     * putChar of to buffer as UTF16\n+     *\/\n+    void stringConcatHelperPutCharUTF16(byte[] buffer, int index, int ch);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Digits provides a fast methodology for converting integers and longs to\n- * ASCII strings.\n- *\n- * @since 21\n- *\/\n-public sealed interface Digits permits HexDigits, OctalDigits {\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param buffer     byte buffer to copy into\n-     * @param index      insert point + 1\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\n-     * @throws Throwable if putCharMH fails (unusual).\n-     *\/\n-    int digits(long value, byte[] buffer, int index,\n-               MethodHandle putCharMH) throws Throwable;\n-\n-    \/**\n-     * Calculate the number of digits required to represent the long.\n-     *\n-     * @param value value to convert\n-     *\n-     * @return number of digits\n-     *\/\n-    int size(long value);\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Digits.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -33,1 +33,2 @@\n- * Digits class for hexadecimal digits.\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * hexadecimal digits ASCII strings.\n@@ -37,1 +38,1 @@\n-public final class HexDigits implements Digits {\n+public final class HexDigits {\n@@ -68,5 +69,0 @@\n-    \/**\n-     * Singleton instance of HexDigits.\n-     *\/\n-    public static final Digits INSTANCE = new HexDigits();\n-\n@@ -115,3 +111,13 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer) {\n@@ -121,2 +127,2 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits >> 8);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -126,1 +132,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        buffer[--index] = (byte) (digits >> 8);\n@@ -129,1 +135,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -135,2 +141,8 @@\n-    @Override\n-    public int size(long value) {\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":28,"deletions":16,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -37,1 +37,7 @@\n-public final class OctalDigits implements Digits {\n+\/**\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * octal digits ASCII strings.\n+ *\n+ * @since 21\n+ *\/\n+public final class OctalDigits {\n@@ -41,5 +47,0 @@\n-    \/**\n-     * Singleton instance of OctalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new OctalDigits();\n-\n@@ -67,3 +68,13 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer){\n@@ -73,2 +84,2 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits >> 8);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -78,1 +89,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        buffer[--index] = (byte) (digits >> 8);\n@@ -81,1 +92,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -87,2 +98,8 @@\n-    @Override\n-    public int size(long value) {\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OctalDigits.java","additions":32,"deletions":15,"binary":false,"changes":47,"status":"modified"}]}