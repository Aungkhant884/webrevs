{"files":[{"patch":"@@ -1163,1 +1163,1 @@\n-\/\/ Mirror of Integer.stringSize() method, return the count of digits in integer,\n+\/\/ Mirror of DecimalDigits.stringSize() method, return the count of digits in integer,\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -832,1 +833,1 @@\n-        int spaceNeeded = count + Integer.stringSize(i);\n+        int spaceNeeded = count + DecimalDigits.stringSize(i);\n@@ -835,1 +836,1 @@\n-            StringLatin1.getChars(i, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(i, spaceNeeded, value);\n@@ -857,1 +858,1 @@\n-        int spaceNeeded = count + Long.stringSize(l);\n+        int spaceNeeded = count + DecimalDigits.stringSize(l);\n@@ -860,1 +861,1 @@\n-            StringLatin1.getChars(l, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(l, spaceNeeded, value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -429,1 +430,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -432,1 +433,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -459,26 +460,0 @@\n-    \/**\n-     * Returns the string representation size for a given int value.\n-     *\n-     * @param x int value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(int x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        int p = -10;\n-        for (int i = 1; i < 10; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 10 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -459,1 +460,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -462,1 +463,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -489,26 +490,0 @@\n-    \/**\n-     * Returns the string representation size for a given long value.\n-     *\n-     * @param x long value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(long x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        long p = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 19 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -101,1 +102,1 @@\n-        return checkOverflow(lengthCoder + Integer.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -112,1 +113,1 @@\n-        return checkOverflow(lengthCoder + Long.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -253,1 +254,1 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            return DecimalDigits.getCharsLatin1(value, (int)indexCoder, buf);\n@@ -288,1 +289,1 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            return DecimalDigits.getCharsLatin1(value, (int)indexCoder, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,109 +84,0 @@\n-    \/**\n-     * Places characters representing the integer i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n-     * integer.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(int i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        int q, r;\n-        int charPos = index;\n-\n-        boolean negative = i < 0;\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Generate two digits per iteration\n-        while (i <= -100) {\n-            q = i \/ 100;\n-            r = (q * 100) - i;\n-            i = q;\n-            charPos -= 2;\n-            ByteArrayLittleEndian.setShort(buf, charPos, DecimalDigits.digitPair(r));\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i < -9) {\n-            charPos -= 2;\n-            ByteArrayLittleEndian.setShort(buf, charPos, DecimalDigits.digitPair(-i));\n-        } else {\n-            buf[--charPos] = (byte)('0' - i);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n-    \/**\n-     * Places characters representing the long i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n-     * long.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(long i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        long q;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i <= Integer.MIN_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            ByteArrayLittleEndian.setShort(buf, charPos, DecimalDigits.digitPair((int)((q * 100) - i)));\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int)i;\n-        while (i2 <= -100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            ByteArrayLittleEndian.setShort(buf, charPos, DecimalDigits.digitPair((q2 * 100) - i2));\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 < -9) {\n-            charPos -= 2;\n-            ByteArrayLittleEndian.setShort(buf, charPos, DecimalDigits.digitPair(-i2));\n-        } else {\n-            buf[--charPos] = (byte)('0' - i2);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -2894,18 +2896,0 @@\n-        \/*\n-         * Copied from Long.stringSize\n-         *\/\n-        private static int stringSize(long x) {\n-            int d = 1;\n-            if (x >= 0) {\n-                d = 0;\n-                x = -x;\n-            }\n-            long p = -10;\n-            for (int i = 1; i < 19; i++) {\n-                if (x > p)\n-                    return i + d;\n-                p = 10 * p;\n-            }\n-            return 19 + d;\n-        }\n-\n@@ -2920,1 +2904,1 @@\n-            int size = stringSize(value);\n+            int size = DecimalDigits.stringSize(value);\n@@ -3354,11 +3338,0 @@\n-        \/\/ Simplified variant of Integer.stringSize that assumes positive values\n-        private static int stringSize(int x) {\n-            int p = 10;\n-            for (int i = 1; i < 10; i++) {\n-                if (x < p)\n-                    return i;\n-                p = 10 * p;\n-            }\n-            return 10;\n-        }\n-\n@@ -3385,1 +3358,1 @@\n-            int stringSize = stringSize(val);\n+            int stringSize = DecimalDigits.stringSize(val);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":4,"deletions":31,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -134,2 +134,2 @@\n-        boolean negative = value < 0;\n-        int sign = negative ? 1 : 0;\n+        return stringSize(value);\n+    }\n@@ -137,2 +137,25 @@\n-        if (!negative) {\n-            value = -value;\n+    \/**\n+     * For values from 0 to 99 return a short encoding a pair of ASCII-encoded digit characters in little-endian\n+     * @param i value to convert\n+     * @return a short encoding a pair of ASCII-encoded digit characters\n+     *\/\n+    public static short digitPair(int i) {\n+        return DIGITS[i];\n+    }\n+\n+    \/**\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(int x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n@@ -140,0 +163,8 @@\n+        int p = -10;\n+        for (int i = 1; i < 10; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 10 + d;\n+    }\n@@ -141,1 +172,18 @@\n-        long precision = -10;\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(long x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        long p = -10;\n@@ -143,2 +191,6 @@\n-            if (value > precision)\n-                return i + sign;\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 19 + d;\n+    }\n@@ -146,1 +198,34 @@\n-            precision = 10 * precision;\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there. <strong>Caller must ensure buf has enough capacity for the value to be written!<\/strong>\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n+     * integer.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q, r;\n+        int charPos = index;\n+\n+        boolean negative = i < 0;\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Generate two digits per iteration\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            r = (q * 100) - i;\n+            i = q;\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[r]);\n@@ -149,1 +234,12 @@\n-        return 19 + sign;\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i < -9) {\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[-i]);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i);\n+        }\n+\n+        if (negative) {\n+            buf[--charPos] = (byte)'-';\n+        }\n+        return charPos;\n@@ -152,0 +248,1 @@\n+\n@@ -153,3 +250,15 @@\n-     * For values from 0 to 99 return a short encoding a pair of ASCII-encoded digit characters in little-endian\n-     * @param i value to convert\n-     * @return a short encoding a pair of ASCII-encoded digit characters\n+     * Places characters representing the long i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there. <strong>Caller must ensure buf has enough capacity for the value to be written!<\/strong>\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n+     * long.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n@@ -157,2 +266,40 @@\n-    public static short digitPair(int i) {\n-        return DIGITS[i];\n+    public static int getCharsLatin1(long i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        long q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i <= Integer.MIN_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[(int)((q * 100) - i)]);\n+            i = q;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int)i;\n+        while (i2 <= -100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[(q2 * 100) - i2]);\n+            i2 = q2;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 < -9) {\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[-i2]);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i2);\n+        }\n+\n+        if (negative) {\n+            buf[--charPos] = (byte)'-';\n+        }\n+        return charPos;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":161,"deletions":14,"binary":false,"changes":175,"status":"modified"}]}