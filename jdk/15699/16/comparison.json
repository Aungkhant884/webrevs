{"files":[{"patch":"@@ -1163,1 +1163,1 @@\n-\/\/ Mirror of Integer.stringSize() method, return the count of digits in integer,\n+\/\/ Mirror of DecimalDigits.stringSize() method, return the count of digits in integer,\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -832,1 +833,1 @@\n-        int spaceNeeded = count + Integer.stringSize(i);\n+        int spaceNeeded = count + DecimalDigits.stringSize(i);\n@@ -835,1 +836,1 @@\n-            StringLatin1.getChars(i, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(i, spaceNeeded, value);\n@@ -837,1 +838,3 @@\n-            StringUTF16.getChars(i, count, spaceNeeded, value);\n+            StringUTF16.checkBoundsBeginEnd(count, spaceNeeded, value);\n+            int pos = DecimalDigits.getCharsUTF16(i, spaceNeeded, value);\n+            assert count == pos;\n@@ -857,1 +860,1 @@\n-        int spaceNeeded = count + Long.stringSize(l);\n+        int spaceNeeded = count + DecimalDigits.stringSize(l);\n@@ -860,1 +863,1 @@\n-            StringLatin1.getChars(l, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(l, spaceNeeded, value);\n@@ -862,1 +865,3 @@\n-            StringUTF16.getChars(l, count, spaceNeeded, value);\n+            StringUTF16.checkBoundsBeginEnd(count, spaceNeeded, value);\n+            int pos = DecimalDigits.getCharsUTF16(l, spaceNeeded, value);\n+            assert count == pos;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -429,1 +430,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -432,1 +433,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -436,1 +437,1 @@\n-            StringUTF16.getChars(i, size, buf);\n+            DecimalDigits.getCharsUTF16(i, size, buf);\n@@ -459,26 +460,0 @@\n-    \/**\n-     * Returns the string representation size for a given int value.\n-     *\n-     * @param x int value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(int x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        int p = -10;\n-        for (int i = 1; i < 10; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 10 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -459,1 +460,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -462,1 +463,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -466,1 +467,1 @@\n-            StringUTF16.getChars(i, size, buf);\n+            DecimalDigits.getCharsUTF16(i, size, buf);\n@@ -489,26 +490,0 @@\n-    \/**\n-     * Returns the string representation size for a given long value.\n-     *\n-     * @param x long value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(long x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        long p = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 19 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -101,1 +102,1 @@\n-        return checkOverflow(lengthCoder + Integer.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -112,1 +113,1 @@\n-        return checkOverflow(lengthCoder + Long.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -253,1 +254,1 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            return DecimalDigits.getCharsLatin1(value, (int)indexCoder, buf);\n@@ -255,1 +256,1 @@\n-            return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;\n+            return DecimalDigits.getCharsUTF16(value, (int)indexCoder, buf) | UTF16;\n@@ -288,1 +289,1 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            return DecimalDigits.getCharsLatin1(value, (int)indexCoder, buf);\n@@ -290,1 +291,1 @@\n-            return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;\n+            return DecimalDigits.getCharsUTF16(value, (int)indexCoder, buf) | UTF16;\n@@ -522,25 +523,4 @@\n-    \/*\n-     * Initialize after phase1.\n-     *\/\n-    private static class LateInit {\n-        static final MethodHandle GETCHAR_LATIN1_MH;\n-\n-        static final MethodHandle GETCHAR_UTF16_MH;\n-\n-        static final MethodHandle PUTCHAR_LATIN1_MH;\n-\n-        static final MethodHandle PUTCHAR_UTF16_MH;\n-\n-        static {\n-            MethodType getCharMT =\n-                MethodType.methodType(char.class,\n-                        byte[].class, int.class);\n-            MethodType putCharMT =\n-                MethodType.methodType(void.class,\n-                        byte[].class, int.class, int.class);\n-            GETCHAR_LATIN1_MH = lookupStatic(\"getCharLatin1\", getCharMT);\n-            GETCHAR_UTF16_MH = lookupStatic(\"getCharUTF16\", getCharMT);\n-            PUTCHAR_LATIN1_MH = lookupStatic(\"putCharLatin1\", putCharMT);\n-            PUTCHAR_UTF16_MH = lookupStatic(\"putCharUTF16\", putCharMT);\n-        }\n-\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static boolean isLatin1(long indexCoder) {\n+        return indexCoder < UTF16;\n@@ -573,14 +553,0 @@\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static MethodHandle selectGetChar(long indexCoder) {\n-        return indexCoder < UTF16 ? LateInit.GETCHAR_LATIN1_MH :\n-                                    LateInit.GETCHAR_UTF16_MH;\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static MethodHandle selectPutChar(long indexCoder) {\n-        return indexCoder < UTF16 ? LateInit.PUTCHAR_LATIN1_MH :\n-                                    LateInit.PUTCHAR_UTF16_MH;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":11,"deletions":45,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -82,114 +82,0 @@\n-    \/**\n-     * Places characters representing the integer i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n-     * integer.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(int i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        int q;\n-        int charPos = index;\n-\n-        boolean negative = i < 0;\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Generate two digits per iteration\n-        while (i <= -100) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (q * 100) - i);\n-            i = q;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i < -9) {\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, -i);\n-        } else {\n-            buf[--charPos] = (byte)('0' - i);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n-    \/**\n-     * Places characters representing the long i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n-     * long.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(long i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        long q;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i <= Integer.MIN_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (int)((q * 100) - i));\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int)i;\n-        while (i2 <= -100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (q2 * 100) - i2);\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 < -9) {\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, -i2);\n-        } else {\n-            buf[--charPos] = (byte)('0' - i2);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n-    private static void writeDigitPair(byte[] buf, int charPos, int value) {\n-        short pair = DecimalDigits.digitPair(value);\n-        buf[charPos] = (byte)(pair);\n-        buf[charPos + 1] = (byte)(pair >> 8);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -1361,14 +1361,0 @@\n-    public static int getChars(int i, int begin, int end, byte[] value) {\n-        checkBoundsBeginEnd(begin, end, value);\n-        int pos = getChars(i, end, value);\n-        assert begin == pos;\n-        return pos;\n-    }\n-\n-    public static int getChars(long l, int begin, int end, byte[] value) {\n-        checkBoundsBeginEnd(begin, end, value);\n-        int pos = getChars(l, end, value);\n-        assert begin == pos;\n-        return pos;\n-    }\n-\n@@ -1519,103 +1505,0 @@\n-    \/\/ Used by trusted callers.  Assumes all necessary bounds checks have\n-    \/\/ been done by the caller.\n-\n-    \/**\n-     * This is a variant of {@link StringLatin1#getChars(int, int, byte[])}, but for\n-     * UTF-16 coder.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, UTF16-coded.\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(int i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        int q, r;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        while (i <= -100) {\n-            q = i \/ 100;\n-            r = (q * 100) - i;\n-            i = q;\n-            charPos -= 2;\n-            putPair(buf, charPos, r);\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i < -9) {\n-            charPos -= 2;\n-            putPair(buf, charPos, -i);\n-        } else {\n-            putChar(buf, --charPos, '0' - i);\n-        }\n-\n-        if (negative) {\n-            putChar(buf, --charPos, '-');\n-        }\n-        return charPos;\n-    }\n-\n-    \/**\n-     * This is a variant of {@link StringLatin1#getChars(long, int, byte[])}, but for\n-     * UTF-16 coder.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, UTF16-coded.\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(long i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        long q;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i <= Integer.MIN_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            putPair(buf, charPos, (int)((q * 100) - i));\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int)i;\n-        while (i2 <= -100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            putPair(buf, charPos, (q2 * 100) - i2);\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 < -9) {\n-            charPos -= 2;\n-            putPair(buf, charPos, -i2);\n-        } else {\n-            putChar(buf, --charPos, '0' - i2);\n-        }\n-\n-        if (negative) {\n-            putChar(buf, --charPos, '-');\n-        }\n-        return charPos;\n-    }\n-\n-    private static void putPair(byte[] buf, int charPos, int v) {\n-        int packed = (int) DecimalDigits.digitPair(v);\n-        putChar(buf, charPos, packed & 0xFF);\n-        putChar(buf, charPos + 1, packed >> 8);\n-    }\n-    \/\/ End of trusted methods.\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2482,0 +2482,3 @@\n+            public void putCharUTF16(byte[] buffer, int index, int ch) {\n+                StringUTF16.putChar(buffer, index, ch);\n+            }\n@@ -2522,0 +2525,8 @@\n+            public long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value, String prefix) {\n+                return StringConcatHelper.prepend(indexCoder, buf, value, prefix);\n+            }\n+\n+            public boolean stringConcatHelpeIsLatin1(long lengthCoder) {\n+                return StringConcatHelper.isLatin1(lengthCoder);\n+            }\n+\n@@ -2530,0 +2541,4 @@\n+            public long stringConcatMix(long lengthCoder, char value) {\n+                return StringConcatHelper.mix(lengthCoder, value);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -2894,18 +2896,0 @@\n-        \/*\n-         * Copied from Long.stringSize\n-         *\/\n-        private static int stringSize(long x) {\n-            int d = 1;\n-            if (x >= 0) {\n-                d = 0;\n-                x = -x;\n-            }\n-            long p = -10;\n-            for (int i = 1; i < 19; i++) {\n-                if (x > p)\n-                    return i + d;\n-                p = 10 * p;\n-            }\n-            return 19 + d;\n-        }\n-\n@@ -2920,1 +2904,1 @@\n-            int size = stringSize(value);\n+            int size = DecimalDigits.stringSize(value);\n@@ -3354,11 +3338,0 @@\n-        \/\/ Simplified variant of Integer.stringSize that assumes positive values\n-        private static int stringSize(int x) {\n-            int p = 10;\n-            for (int i = 1; i < 10; i++) {\n-                if (x < p)\n-                    return i;\n-                p = 10 * p;\n-            }\n-            return 10;\n-        }\n-\n@@ -3385,1 +3358,1 @@\n-            int stringSize = stringSize(val);\n+            int stringSize = DecimalDigits.stringSize(val);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":4,"deletions":31,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -42,2 +43,1 @@\n-\n-import static java.lang.invoke.MethodType.methodType;\n+import jdk.internal.vm.annotation.Stable;\n@@ -57,17 +57,0 @@\n-    private static final MethodHandle CHAR_MIX =\n-            JLA.stringConcatHelper(\"mix\",\n-                    MethodType.methodType(long.class, long.class,char.class));\n-\n-    private static final MethodHandle STRING_PREPEND =\n-            JLA.stringConcatHelper(\"prepend\",\n-                    MethodType.methodType(long.class, long.class, byte[].class,\n-                            String.class, String.class));\n-\n-    private static final MethodHandle SELECT_GETCHAR_MH =\n-            JLA.stringConcatHelper(\"selectGetChar\",\n-                    MethodType.methodType(MethodHandle.class, long.class));\n-\n-    private static final MethodHandle SELECT_PUTCHAR_MH =\n-            JLA.stringConcatHelper(\"selectPutChar\",\n-                    MethodType.methodType(MethodHandle.class, long.class));\n-\n@@ -75,7 +58,1 @@\n-        try {\n-            return (long)CHAR_MIX.invokeExact(lengthCoder, value);\n-        } catch (Error | RuntimeException ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        return JLA.stringConcatMix(lengthCoder, value);\n@@ -88,3 +65,2 @@\n-    private static long stringPrepend(long lengthCoder, byte[] buffer,\n-                                            String value) throws Throwable {\n-        return (long)STRING_PREPEND.invokeExact(lengthCoder, buffer, value,\n+    private static long stringPrepend(long lengthCoder, byte[] buffer, String value) {\n+        return JLA.stringConcatHelperPrepend(lengthCoder, buffer, value,\n@@ -94,19 +70,2 @@\n-    private static MethodHandle selectGetChar(long indexCoder) throws Throwable {\n-        return (MethodHandle)SELECT_GETCHAR_MH.invokeExact(indexCoder);\n-    }\n-\n-    private static MethodHandle selectPutChar(long indexCoder) throws Throwable {\n-        return (MethodHandle)SELECT_PUTCHAR_MH.invokeExact(indexCoder);\n-    }\n-\n-    private static final MethodHandle PUT_CHAR_DIGIT;\n-\n-    static {\n-        try {\n-            Lookup lookup = MethodHandles.lookup();\n-            PUT_CHAR_DIGIT = lookup.findStatic(FormatItem.class, \"putByte\",\n-                    MethodType.methodType(void.class,\n-                            byte[].class, int.class, int.class));\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(\"putByte lookup failed\", ex);\n-        }\n+    private static void putCharUTF16(byte[] buffer, int index, int ch) {\n+        JLA.putCharUTF16(buffer, index, ch);\n@@ -115,2 +74,2 @@\n-    private static void putByte(byte[] buffer, int index, int ch) {\n-        buffer[index] = (byte)ch;\n+    private static boolean isLatin1(long lengthCoder) {\n+        return JLA.stringConcatHelpeIsLatin1(lengthCoder);\n@@ -131,1 +90,0 @@\n-        private final byte[] digits;\n@@ -141,1 +99,1 @@\n-                          boolean parentheses, int groupSize, long value) throws Throwable {\n+                          boolean parentheses, int groupSize, long value) {\n@@ -146,3 +104,1 @@\n-            int length = DecimalDigits.INSTANCE.size(value);\n-            this.digits = new byte[length];\n-            DecimalDigits.INSTANCE.digits(value, this.digits, length, PUT_CHAR_DIGIT);\n+            int length = DecimalDigits.stringSize(value);\n@@ -174,2 +130,10 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n+\n+        private long prependLatin1(long lengthCoder, byte[] buffer) {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n@@ -178,1 +142,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)')');\n+                buffer[--lengthCoderLatin1] = ')';\n@@ -184,0 +148,3 @@\n+                byte[] digits = new byte[length];\n+                DecimalDigits.getCharsLatin1(value, length, digits);\n+\n@@ -186,2 +153,1 @@\n-                        putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                                (int)groupingSeparator);\n+                        buffer[--lengthCoderLatin1] = (byte) groupingSeparator;\n@@ -191,2 +157,1 @@\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n+                    buffer[--lengthCoderLatin1] = (byte) (digits[digits.length - i] + digitOffset);\n@@ -195,0 +160,30 @@\n+                DecimalDigits.getCharsLatin1(value, (int)lengthCoder, buffer);\n+                lengthCoderLatin1 -= length;\n+            }\n+\n+            for (int i = length + signLength() + groupLength(); i < width; i++) {\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            if (parentheses) {\n+                buffer[--lengthCoderLatin1] = '(';\n+            }\n+\n+            if (prefixSign != '\\0') {\n+                buffer[--lengthCoderLatin1] = prefixSign;\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n+\n+        private long prependUTF16(long lengthCoder, byte[] buffer) {\n+            if (parentheses) {\n+                putCharUTF16(buffer, (int)--lengthCoder, (int)')');\n+            }\n+\n+            if (0 < groupSize) {\n+                int groupIndex = groupSize;\n+\n+                byte[] digits = new byte[length];\n+                DecimalDigits.getCharsLatin1(value, length, digits);\n+\n@@ -196,2 +191,6 @@\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n+                    if (groupIndex-- == 0) {\n+                        putCharUTF16(buffer, (int) --lengthCoder, (int) groupingSeparator);\n+                        groupIndex = groupSize - 1;\n+                    }\n+\n+                    putCharUTF16(buffer, (int) --lengthCoder, digits[digits.length - i] + digitOffset);\n@@ -199,0 +198,3 @@\n+            } else {\n+                DecimalDigits.getCharsUTF16(value, (int)lengthCoder, buffer);\n+                lengthCoder -= length;\n@@ -202,1 +204,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) '0');\n@@ -206,1 +208,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'(');\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) '(');\n@@ -208,0 +210,1 @@\n+\n@@ -209,1 +212,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)prefixSign);\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) prefixSign);\n@@ -229,1 +232,1 @@\n-            this.length = HexDigits.INSTANCE.size(value);\n+            this.length = HexDigits.stringSize(value);\n@@ -246,3 +249,23 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            HexDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n+\n+        protected long prependLatin1(long lengthCoder, byte[] buffer) {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+            HexDigits.getCharsLatin1(value, lengthCoderLatin1, buffer);\n+            lengthCoderLatin1 -= length;\n+\n+            if (hasPrefix && value != 0) {\n+                buffer[--lengthCoderLatin1] = 'x';\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n+\n+        protected long prependUTF16(long lengthCoder, byte[] buffer) {\n+            HexDigits.getCharsUTF16(value, (int)lengthCoder, buffer);\n@@ -252,1 +275,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -255,3 +278,3 @@\n-            if (hasPrefix) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'x');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            if (hasPrefix && value != 0) {\n+                putCharUTF16(buffer, (int)--lengthCoder, 'x');\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -277,1 +300,1 @@\n-            this.length = OctalDigits.INSTANCE.size(value);\n+            this.length = OctalDigits.stringSize(value);\n@@ -294,4 +317,7 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            OctalDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n-            lengthCoder -= length;\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n@@ -299,2 +325,8 @@\n-            for (int i = 0; i < zeroesLength(); i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+        protected long prependLatin1(long lengthCoder, byte[] buffer) {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+            OctalDigits.getCharsLatin1(value, lengthCoderLatin1, buffer);\n+            lengthCoderLatin1 -= length;\n+\n+            int zeroesLength = zeroesLength();\n+            if (hasPrefix && value != 0) {\n+                zeroesLength++;\n@@ -303,0 +335,12 @@\n+            for (int i = 0; i < zeroesLength; i++) {\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n+\n+        protected long prependUTF16(long lengthCoder, byte[] buffer) {\n+            OctalDigits.getCharsUTF16(value, (int) lengthCoder, buffer);\n+            lengthCoder -= length;\n+\n+            int zeroesLength = zeroesLength();\n@@ -304,1 +348,4 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                zeroesLength++;\n+            }\n+            for (int i = 0; i < zeroesLength; i++) {\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -316,0 +363,8 @@\n+        @Stable\n+        private final static byte[] BYTES_TRUE_LATIN1 = \"true\".getBytes(StandardCharsets.ISO_8859_1);\n+        @Stable\n+        private final static byte[] BYTES_TRUE_UTF16 = \"true\".getBytes(StandardCharsets.UTF_16);\n+        @Stable\n+        private final static byte[] BYTES_FALSE_LATIN1 = \"false\".getBytes(StandardCharsets.ISO_8859_1);\n+        @Stable\n+        private final static byte[] BYTES_FALSE_UTF16 = \"false\".getBytes(StandardCharsets.UTF_16);\n@@ -327,8 +382,5 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            if (value) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'r');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'t');\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            boolean latin1 = isLatin1(lengthCoder);\n+            byte[] bytes;\n+            if (latin1) {\n+                bytes = value ? BYTES_TRUE_LATIN1 : BYTES_FALSE_LATIN1;\n@@ -336,5 +388,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'s');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'a');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'f');\n+                bytes = value ? BYTES_FALSE_LATIN1 : BYTES_FALSE_UTF16;\n@@ -342,2 +390,2 @@\n-\n-            return lengthCoder;\n+            System.arraycopy(bytes, 0, buffer, (int) (lengthCoder) - bytes.length, bytes.length);\n+            return lengthCoder - bytes.length;\n@@ -363,4 +411,6 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)value);\n-\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            if (isLatin1(lengthCoder)) {\n+                buffer[(int) --lengthCoder] = (byte) value;\n+            } else {\n+                putCharUTF16(buffer, (int) --lengthCoder, value);\n+            }\n@@ -387,1 +437,1 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+        public long prepend(long lengthCoder, byte[] buffer) {\n@@ -423,1 +473,1 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+        public long prepend(long lengthCoder, byte[] buffer) {\n@@ -452,1 +502,1 @@\n-        public abstract long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n+        public abstract long prepend(long lengthCoder, byte[] buffer);\n@@ -473,2 +523,1 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+        public long prepend(long lengthCoder, byte[] buffer) {\n@@ -477,2 +526,8 @@\n-            for (int i = length(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n+            if (isLatin1(lengthCoder)) {\n+                for (int i = length(); i < width; i++) {\n+                    buffer[(int) --lengthCoder] = ' ';\n+                }\n+            } else {\n+                for (int i = length(); i < width; i++) {\n+                    putCharUTF16(buffer, (int) --lengthCoder, (int) ' ');\n+                }\n@@ -503,5 +558,10 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            for (int i = length(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            int length = length();\n+            if (isLatin1(lengthCoder)) {\n+                for (int i = length; i < width; i++) {\n+                    buffer[(int)--lengthCoder] = ' ';\n+                }\n+            } else {\n+                for (int i = length; i < width; i++) {\n+                    putCharUTF16(buffer, (int)--lengthCoder, ' ');\n+                }\n@@ -521,0 +581,6 @@\n+        @Stable\n+        private final static byte[] BYTES_LATIN1 = \"null\".getBytes(StandardCharsets.ISO_8859_1);\n+\n+        @Stable\n+        private final static byte[] BYTES_UTF16 = \"null\".getBytes(StandardCharsets.UTF_16);\n+\n@@ -530,9 +596,4 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'n');\n-\n-            return lengthCoder;\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            byte[] bytes = isLatin1(lengthCoder) ? BYTES_LATIN1 : BYTES_UTF16;\n+            System.arraycopy(bytes, 0, buffer, (int) (lengthCoder) - bytes.length, bytes.length);\n+            return lengthCoder - 4;\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":184,"deletions":123,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -409,0 +409,10 @@\n+    \/**\n+     * Returns {@code true} if lengthCoder is Latin1\n+     *\/\n+    boolean stringConcatHelpeIsLatin1(long lengthCoder);\n+\n+    \/**\n+     * putChar of to buffer as UTF16\n+     *\/\n+    void putCharUTF16(byte[] buffer, int index, int ch);\n+\n@@ -419,0 +429,11 @@\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     *\/\n+    long stringConcatMix(long lengthCoder, char value);\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\/\n+    long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value, String prefix);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,1 +35,2 @@\n- * Digits class for decimal digits.\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * decimal digits ASCII strings.\n@@ -37,1 +40,2 @@\n-public final class DecimalDigits implements Digits {\n+public final class DecimalDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -76,1 +80,1 @@\n-     * Singleton instance of DecimalDigits.\n+     * Constructor.\n@@ -78,1 +82,2 @@\n-    public static final Digits INSTANCE = new DecimalDigits();\n+    private DecimalDigits() {\n+    }\n@@ -81,1 +86,9 @@\n-     * Constructor.\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n@@ -83,1 +96,13 @@\n-    private DecimalDigits() {\n+    public static int stringSize(int x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        int p = -10;\n+        for (int i = 1; i < 10; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 10 + d;\n@@ -86,4 +111,52 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n-        boolean negative = value < 0;\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(long x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        long p = -10;\n+        for (int i = 1; i < 19; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 19 + d;\n+    }\n+\n+    \/\/ Used by trusted callers.  Assumes all necessary bounds checks have\n+    \/\/ been done by the caller.\n+\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there. <strong>Caller must ensure buf has enough capacity for the value to be written!<\/strong>\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n+     * integer.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q, r;\n+        int charPos = index;\n+\n+        boolean negative = i < 0;\n@@ -91,1 +164,1 @@\n-            value = -value;\n+            i = -i;\n@@ -94,7 +167,8 @@\n-        long q;\n-        int r;\n-        while (value <= Integer.MIN_VALUE) {\n-            q = value \/ 100;\n-            r = (int)((q * 100) - value);\n-            value = q;\n-            int digits = DIGITS[r];\n+        \/\/ Generate two digits per iteration\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            r = (q * 100) - i;\n+            i = q;\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, r);\n+        }\n@@ -102,2 +176,6 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i < -9) {\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, -i);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i);\n@@ -106,8 +184,2 @@\n-        int iq, ivalue = (int)value;\n-        while (ivalue <= -100) {\n-            iq = ivalue \/ 100;\n-            r = (iq * 100) - ivalue;\n-            ivalue = iq;\n-            int digits = DIGITS[r];\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+        if (negative) {\n+            buf[--charPos] = (byte)'-';\n@@ -115,0 +187,3 @@\n+        return charPos;\n+    }\n+\n@@ -116,2 +191,33 @@\n-        if (ivalue < 0) {\n-            ivalue = -ivalue;\n+    \/**\n+     * Places characters representing the long i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there. <strong>Caller must ensure buf has enough capacity for the value to be written!<\/strong>\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n+     * long.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(long i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        long q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i <= Integer.MIN_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, (int)((q * 100) - i));\n+            i = q;\n@@ -120,2 +226,9 @@\n-        int digits = DIGITS[ivalue];\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int)i;\n+        while (i2 <= -100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, (q2 * 100) - i2);\n+            i2 = q2;\n+        }\n@@ -123,2 +236,6 @@\n-        if (9 < ivalue) {\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 < -9) {\n+            charPos -= 2;\n+            writeDigitPairLatin1(buf, charPos, -i2);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i2);\n@@ -128,1 +245,1 @@\n-            putCharMH.invokeExact(buffer, --index, (int)'-');\n+            buf[--charPos] = (byte)'-';\n@@ -130,2 +247,1 @@\n-\n-        return index;\n+        return charPos;\n@@ -134,4 +250,13 @@\n-    @Override\n-    public int size(long value) {\n-        boolean negative = value < 0;\n-        int sign = negative ? 1 : 0;\n+    \/**\n+     * This is a variant of {@link StringLatin1#getChars(int, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, UTF16-coded.\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsUTF16(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q, r;\n+        int charPos = index;\n@@ -139,0 +264,1 @@\n+        boolean negative = (i < 0);\n@@ -140,1 +266,1 @@\n-            value = -value;\n+            i = -i;\n@@ -143,4 +269,8 @@\n-        long precision = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (value > precision)\n-                return i + sign;\n+        \/\/ Get 2 digits\/iteration using ints\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            r = (q * 100) - i;\n+            i = q;\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, r);\n+        }\n@@ -148,1 +278,6 @@\n-            precision = 10 * precision;\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i < -9) {\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, -i);\n+        } else {\n+            JLA.putCharUTF16(buf, --charPos, '0' - i);\n@@ -151,1 +286,4 @@\n-        return 19 + sign;\n+        if (negative) {\n+            JLA.putCharUTF16(buf, --charPos, '-');\n+        }\n+        return charPos;\n@@ -155,3 +293,7 @@\n-     * For values from 0 to 99 return a short encoding a pair of ASCII-encoded digit characters in little-endian\n-     * @param i value to convert\n-     * @return a short encoding a pair of ASCII-encoded digit characters\n+     * This is a variant of {@link StringLatin1#getChars(long, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, UTF16-coded.\n+     * @return index of the most significant digit or minus sign, if present\n@@ -159,2 +301,52 @@\n-    public static short digitPair(int i) {\n-        return DIGITS[i];\n+    public static int getCharsUTF16(long i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        long q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i <= Integer.MIN_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, (int)((q * 100) - i));\n+            i = q;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int)i;\n+        while (i2 <= -100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, (q2 * 100) - i2);\n+            i2 = q2;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 < -9) {\n+            charPos -= 2;\n+            writeDigitPairUTF16(buf, charPos, -i2);\n+        } else {\n+            JLA.putCharUTF16(buf, --charPos, '0' - i2);\n+        }\n+\n+        if (negative) {\n+            JLA.putCharUTF16(buf, --charPos, '-');\n+        }\n+        return charPos;\n+    }\n+\n+    private static void writeDigitPairLatin1(byte[] buf, int charPos, int value) {\n+        short pair = DIGITS[value];\n+        buf[charPos] = (byte)(pair);\n+        buf[charPos + 1] = (byte)(pair >> 8);\n+    }\n+\n+    private static void writeDigitPairUTF16(byte[] buf, int charPos, int value) {\n+        int packed = (int) DIGITS[value];\n+        JLA.putCharUTF16(buf, charPos, packed & 0xFF);\n+        JLA.putCharUTF16(buf, charPos + 1, packed >> 8);\n@@ -162,0 +354,1 @@\n+    \/\/ End of trusted methods.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":246,"deletions":53,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Digits provides a fast methodology for converting integers and longs to\n- * ASCII strings.\n- *\n- * @since 21\n- *\/\n-public sealed interface Digits permits DecimalDigits, HexDigits, OctalDigits {\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param buffer     byte buffer to copy into\n-     * @param index      insert point + 1\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\n-     * @throws Throwable if putCharMH fails (unusual).\n-     *\/\n-    int digits(long value, byte[] buffer, int index,\n-               MethodHandle putCharMH) throws Throwable;\n-\n-    \/**\n-     * Calculate the number of digits required to represent the long.\n-     *\n-     * @param value value to convert\n-     *\n-     * @return number of digits\n-     *\/\n-    int size(long value);\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Digits.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -54,2 +54,0 @@\n-     *\n-     * @throws Throwable if fails to prepend value (unusual).\n@@ -57,1 +55,1 @@\n-    long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n+    long prepend(long lengthCoder, byte[] buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/FormatConcatItem.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,1 +35,2 @@\n- * Digits class for hexadecimal digits.\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * hexadecimal digits ASCII strings.\n@@ -37,1 +40,3 @@\n-public final class HexDigits implements Digits {\n+public final class HexDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -68,5 +73,0 @@\n-    \/**\n-     * Singleton instance of HexDigits.\n-     *\/\n-    public static final Digits INSTANCE = new HexDigits();\n-\n@@ -115,3 +115,41 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer) {\n+        while ((value & ~0xFF) != 0) {\n+            putPair(buffer, index, (int) (value & 0xFF));\n+            value >>>= 8;\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0xFF)];\n+        buffer[--index] = (byte) (digits >> 8);\n+\n+        if (0xF < value) {\n+            buffer[--index] = (byte) (digits & 0xFF);\n+        }\n+\n+        return index;\n+    }\n+\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer) {\n@@ -119,1 +157,2 @@\n-            int digits = DIGITS[(int) (value & 0xFF)];\n+            index -= 2;\n+            putPair(buffer, index, (int) (value & 0xFF));\n@@ -121,2 +160,0 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -126,1 +163,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        JLA.putCharUTF16(buffer, --index, (byte) (digits >> 8));\n@@ -129,1 +166,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            JLA.putCharUTF16(buffer, --index, (byte) (digits & 0xFF));\n@@ -135,2 +172,8 @@\n-    @Override\n-    public int size(long value) {\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n@@ -140,0 +183,6 @@\n+\n+    private static void putPair(byte[] buf, int charPos, int v) {\n+        int packed = (int) DIGITS[v];\n+        JLA.putCharUTF16(buf, charPos, packed & 0xFF);\n+        JLA.putCharUTF16(buf, charPos + 1, packed >> 8);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":66,"deletions":17,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -37,1 +39,9 @@\n-public final class OctalDigits implements Digits {\n+\/**\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * octal digits ASCII strings.\n+ *\n+ * @since 21\n+ *\/\n+public final class OctalDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -41,5 +51,0 @@\n-    \/**\n-     * Singleton instance of OctalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new OctalDigits();\n-\n@@ -67,3 +72,13 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer){\n@@ -73,2 +88,2 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits >> 8);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -78,1 +93,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        buffer[--index] = (byte) (digits >> 8);\n@@ -81,1 +96,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -87,2 +102,39 @@\n-    @Override\n-    public int size(long value) {\n+\n+    \/**\n+     * This is a variant of {@link OctalDigits#getCharsLatin1(int, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer){\n+        while ((value & ~0x3F) != 0) {\n+            index -= 2;\n+            putPair(buffer, index, (int) (value & 0x3F));\n+            value >>>= 6;\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0x3F)];\n+        JLA.putCharUTF16(buffer, --index, digits >> 8);\n+\n+        if (7 < value) {\n+            JLA.putCharUTF16(buffer, --index, digits & 0xFF);\n+        }\n+\n+        return index;\n+    }\n+\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n@@ -91,0 +143,6 @@\n+\n+    private static void putPair(byte[] buf, int charPos, int v) {\n+        int packed = (int) DIGITS[v];\n+        JLA.putCharUTF16(buf, charPos, packed & 0xFF);\n+        JLA.putCharUTF16(buf, charPos + 1, packed >> 8);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OctalDigits.java","additions":73,"deletions":15,"binary":false,"changes":88,"status":"modified"}]}