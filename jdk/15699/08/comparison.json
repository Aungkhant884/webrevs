{"files":[{"patch":"@@ -1163,1 +1163,1 @@\n-\/\/ Mirror of Integer.stringSize() method, return the count of digits in integer,\n+\/\/ Mirror of DecimalDigits.stringSize() method, return the count of digits in integer,\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -832,1 +833,1 @@\n-        int spaceNeeded = count + Integer.stringSize(i);\n+        int spaceNeeded = count + DecimalDigits.stringSize(i);\n@@ -835,1 +836,1 @@\n-            StringLatin1.getChars(i, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(i, spaceNeeded, value);\n@@ -857,1 +858,1 @@\n-        int spaceNeeded = count + Long.stringSize(l);\n+        int spaceNeeded = count + DecimalDigits.stringSize(l);\n@@ -860,1 +861,1 @@\n-            StringLatin1.getChars(l, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(l, spaceNeeded, value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -429,1 +430,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -432,1 +433,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -459,26 +460,0 @@\n-    \/**\n-     * Returns the string representation size for a given int value.\n-     *\n-     * @param x int value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(int x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        int p = -10;\n-        for (int i = 1; i < 10; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 10 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -459,1 +460,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -462,1 +463,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -489,26 +490,0 @@\n-    \/**\n-     * Returns the string representation size for a given long value.\n-     *\n-     * @param x long value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(long x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        long p = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 19 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -101,1 +102,1 @@\n-        return checkOverflow(lengthCoder + Integer.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -112,1 +113,1 @@\n-        return checkOverflow(lengthCoder + Long.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -253,1 +254,1 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            return DecimalDigits.getCharsLatin1(value, (int)indexCoder, buf);\n@@ -288,1 +289,1 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            return DecimalDigits.getCharsLatin1(value, (int)indexCoder, buf);\n@@ -549,0 +550,6 @@\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static boolean isLatin1(long indexCoder) {\n+        return indexCoder < UTF16;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -82,114 +82,0 @@\n-    \/**\n-     * Places characters representing the integer i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n-     * integer.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(int i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        int q;\n-        int charPos = index;\n-\n-        boolean negative = i < 0;\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Generate two digits per iteration\n-        while (i <= -100) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (q * 100) - i);\n-            i = q;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i < -9) {\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, -i);\n-        } else {\n-            buf[--charPos] = (byte)('0' - i);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n-    \/**\n-     * Places characters representing the long i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n-     * long.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(long i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        long q;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i <= Integer.MIN_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (int)((q * 100) - i));\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int)i;\n-        while (i2 <= -100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (q2 * 100) - i2);\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 < -9) {\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, -i2);\n-        } else {\n-            buf[--charPos] = (byte)('0' - i2);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n-    private static void writeDigitPair(byte[] buf, int charPos, int value) {\n-        short pair = DecimalDigits.digitPair(value);\n-        buf[charPos] = (byte)(pair);\n-        buf[charPos + 1] = (byte)(pair >> 8);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2482,0 +2482,3 @@\n+            public void putCharUTF16(byte[] buffer, int index, int ch) {\n+                StringUTF16.putChar(buffer, index, ch);\n+            }\n@@ -2522,0 +2525,4 @@\n+            public boolean stringConcatHelpeIsLatin1(long lengthCoder) {\n+                return StringConcatHelper.isLatin1(lengthCoder);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -2894,18 +2896,0 @@\n-        \/*\n-         * Copied from Long.stringSize\n-         *\/\n-        private static int stringSize(long x) {\n-            int d = 1;\n-            if (x >= 0) {\n-                d = 0;\n-                x = -x;\n-            }\n-            long p = -10;\n-            for (int i = 1; i < 19; i++) {\n-                if (x > p)\n-                    return i + d;\n-                p = 10 * p;\n-            }\n-            return 19 + d;\n-        }\n-\n@@ -2920,1 +2904,1 @@\n-            int size = stringSize(value);\n+            int size = DecimalDigits.stringSize(value);\n@@ -3354,11 +3338,0 @@\n-        \/\/ Simplified variant of Integer.stringSize that assumes positive values\n-        private static int stringSize(int x) {\n-            int p = 10;\n-            for (int i = 1; i < 10; i++) {\n-                if (x < p)\n-                    return i;\n-                p = 10 * p;\n-            }\n-            return 10;\n-        }\n-\n@@ -3385,1 +3358,1 @@\n-            int stringSize = stringSize(val);\n+            int stringSize = DecimalDigits.stringSize(val);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":4,"deletions":31,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -102,11 +102,2 @@\n-    private static final MethodHandle PUT_CHAR_DIGIT;\n-\n-    static {\n-        try {\n-            Lookup lookup = MethodHandles.lookup();\n-            PUT_CHAR_DIGIT = lookup.findStatic(FormatItem.class, \"putByte\",\n-                    MethodType.methodType(void.class,\n-                            byte[].class, int.class, int.class));\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(\"putByte lookup failed\", ex);\n-        }\n+    private static void putCharUTF16(byte[] buffer, int index, int ch) {\n+        JLA.putCharUTF16(buffer, index, ch);\n@@ -115,2 +106,2 @@\n-    private static void putByte(byte[] buffer, int index, int ch) {\n-        buffer[index] = (byte)ch;\n+    private static boolean isLatin1(long lengthCoder) {\n+        return JLA.stringConcatHelpeIsLatin1(lengthCoder);\n@@ -146,1 +137,1 @@\n-            int length = DecimalDigits.INSTANCE.size(value);\n+            int length = DecimalDigits.stringSize(value);\n@@ -148,1 +139,1 @@\n-            DecimalDigits.INSTANCE.digits(value, this.digits, length, PUT_CHAR_DIGIT);\n+            DecimalDigits.getCharsLatin1(value, length, this.digits);\n@@ -175,1 +166,6 @@\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n@@ -177,0 +173,1 @@\n+        private long prependUTF16(long lengthCoder, byte[] buffer) throws Throwable {\n@@ -178,1 +175,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)')');\n+                putCharUTF16(buffer, (int)--lengthCoder, (int)')');\n@@ -186,2 +183,1 @@\n-                        putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                                (int)groupingSeparator);\n+                        putCharUTF16(buffer, (int) --lengthCoder, (int) groupingSeparator);\n@@ -191,2 +187,1 @@\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n+                    putCharUTF16(buffer, (int) --lengthCoder, digits[digits.length - i] + digitOffset);\n@@ -196,2 +191,1 @@\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n+                    putCharUTF16(buffer, (int) --lengthCoder, digits[digits.length - i] + digitOffset);\n@@ -202,1 +196,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) '0');\n@@ -206,1 +200,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'(');\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) '(');\n@@ -208,0 +202,1 @@\n+\n@@ -209,1 +204,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)prefixSign);\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) prefixSign);\n@@ -214,0 +209,39 @@\n+\n+        private long prependLatin1(long lengthCoder, byte[] buffer) throws Throwable {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+\n+            if (parentheses) {\n+                buffer[--lengthCoderLatin1] = ')';\n+            }\n+\n+            if (0 < groupSize) {\n+                int groupIndex = groupSize;\n+\n+                for (int i = 1; i <= length; i++) {\n+                    if (groupIndex-- == 0) {\n+                        buffer[--lengthCoderLatin1] = (byte) groupingSeparator;\n+                        groupIndex = groupSize - 1;\n+                    }\n+\n+                    buffer[--lengthCoderLatin1] = (byte) (digits[digits.length - i] + digitOffset);\n+                }\n+            } else {\n+                for (int i = 1; i <= length; i++) {\n+                    buffer[--lengthCoderLatin1] = (byte) (digits[digits.length - i] + digitOffset);\n+                }\n+            }\n+\n+            for (int i = length + signLength() + groupLength(); i < width; i++) {\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            if (parentheses) {\n+                buffer[--lengthCoderLatin1] = '(';\n+            }\n+\n+            if (prefixSign != '\\0') {\n+                buffer[--lengthCoderLatin1] = prefixSign;\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n@@ -229,1 +263,1 @@\n-            this.length = HexDigits.INSTANCE.size(value);\n+            this.length = HexDigits.stringSize(value);\n@@ -247,2 +281,22 @@\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            HexDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n+\n+        protected long prependLatin1(long lengthCoder, byte[] buffer) throws Throwable {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+            HexDigits.getCharsLatin1(value, lengthCoderLatin1, buffer);\n+            lengthCoderLatin1 -= length;\n+\n+            if (hasPrefix && value != 0) {\n+                buffer[--lengthCoderLatin1] = 'x';\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n+\n+        protected long prependUTF16(long lengthCoder, byte[] buffer) throws Throwable {\n+            HexDigits.getCharsUTF16(value, (int)lengthCoder, buffer);\n@@ -252,1 +306,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -255,3 +309,3 @@\n-            if (hasPrefix) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'x');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            if (hasPrefix && value != 0) {\n+                putCharUTF16(buffer, (int)--lengthCoder, 'x');\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -277,1 +331,1 @@\n-            this.length = OctalDigits.INSTANCE.size(value);\n+            this.length = OctalDigits.stringSize(value);\n@@ -295,3 +349,6 @@\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            OctalDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n-            lengthCoder -= length;\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n@@ -299,2 +356,8 @@\n-            for (int i = 0; i < zeroesLength(); i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+        protected long prependLatin1(long lengthCoder, byte[] buffer) throws Throwable {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+            OctalDigits.getCharsLatin1(value, lengthCoderLatin1, buffer);\n+            lengthCoderLatin1 -= length;\n+\n+            int zeroesLength = zeroesLength();\n+            if (hasPrefix && value != 0) {\n+                zeroesLength++;\n@@ -303,0 +366,12 @@\n+            for (int i = 0; i < zeroesLength; i++) {\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n+\n+        protected long prependUTF16(long lengthCoder, byte[] buffer) throws Throwable {\n+            OctalDigits.getCharsUTF16(value, (int) lengthCoder, buffer);\n+            lengthCoder -= length;\n+\n+            int zeroesLength = zeroesLength();\n@@ -304,1 +379,4 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                zeroesLength++;\n+            }\n+            for (int i = 0; i < zeroesLength; i++) {\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":118,"deletions":40,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -409,0 +409,10 @@\n+    \/**\n+     * Returns {@code true} if lengthCoder is Latin1\n+     *\/\n+    boolean stringConcatHelpeIsLatin1(long lengthCoder);\n+\n+    \/**\n+     * putChar of to buffer as UTF16\n+     *\/\n+    void putCharUTF16(byte[] buffer, int index, int ch);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n- * Digits class for decimal digits.\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * decimal digits ASCII strings.\n@@ -37,1 +38,1 @@\n-public final class DecimalDigits implements Digits {\n+public final class DecimalDigits {\n@@ -76,1 +77,1 @@\n-     * Singleton instance of DecimalDigits.\n+     * Constructor.\n@@ -78,1 +79,2 @@\n-    public static final Digits INSTANCE = new DecimalDigits();\n+    private DecimalDigits() {\n+    }\n@@ -81,1 +83,3 @@\n-     * Constructor.\n+     * For values from 0 to 99 return a short encoding a pair of ASCII-encoded digit characters in little-endian\n+     * @param i value to convert\n+     * @return a short encoding a pair of ASCII-encoded digit characters\n@@ -83,1 +87,2 @@\n-    private DecimalDigits() {\n+    public static short digitPair(int i) {\n+        return DIGITS[i];\n@@ -86,6 +91,16 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n-        boolean negative = value < 0;\n-        if (!negative) {\n-            value = -value;\n+    \/**\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(int x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n@@ -93,11 +108,5 @@\n-\n-        long q;\n-        int r;\n-        while (value <= Integer.MIN_VALUE) {\n-            q = value \/ 100;\n-            r = (int)((q * 100) - value);\n-            value = q;\n-            int digits = DIGITS[r];\n-\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+        int p = -10;\n+        for (int i = 1; i < 10; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n@@ -105,0 +114,2 @@\n+        return 10 + d;\n+    }\n@@ -106,8 +117,22 @@\n-        int iq, ivalue = (int)value;\n-        while (ivalue <= -100) {\n-            iq = ivalue \/ 100;\n-            r = (iq * 100) - ivalue;\n-            ivalue = iq;\n-            int digits = DIGITS[r];\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(long x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        long p = -10;\n+        for (int i = 1; i < 19; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n@@ -115,0 +140,24 @@\n+        return 19 + d;\n+    }\n+\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there. <strong>Caller must ensure buf has enough capacity for the value to be written!<\/strong>\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n+     * integer.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q, r;\n+        int charPos = index;\n@@ -116,2 +165,3 @@\n-        if (ivalue < 0) {\n-            ivalue = -ivalue;\n+        boolean negative = i < 0;\n+        if (!negative) {\n+            i = -i;\n@@ -120,2 +170,8 @@\n-        int digits = DIGITS[ivalue];\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        \/\/ Generate two digits per iteration\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            r = (q * 100) - i;\n+            i = q;\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[r]);\n+        }\n@@ -123,2 +179,6 @@\n-        if (9 < ivalue) {\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i < -9) {\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[-i]);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i);\n@@ -128,1 +188,1 @@\n-            putCharMH.invokeExact(buffer, --index, (int)'-');\n+            buf[--charPos] = (byte)'-';\n@@ -130,2 +190,1 @@\n-\n-        return index;\n+        return charPos;\n@@ -134,4 +193,0 @@\n-    @Override\n-    public int size(long value) {\n-        boolean negative = value < 0;\n-        int sign = negative ? 1 : 0;\n@@ -139,0 +194,23 @@\n+    \/**\n+     * Places characters representing the long i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there. <strong>Caller must ensure buf has enough capacity for the value to be written!<\/strong>\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n+     * long.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(long i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        long q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n@@ -140,1 +218,1 @@\n-            value = -value;\n+            i = -i;\n@@ -143,4 +221,7 @@\n-        long precision = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (value > precision)\n-                return i + sign;\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i <= Integer.MIN_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[(int)((q * 100) - i)]);\n+            i = q;\n+        }\n@@ -148,1 +229,8 @@\n-            precision = 10 * precision;\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int)i;\n+        while (i2 <= -100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[(q2 * 100) - i2]);\n+            i2 = q2;\n@@ -151,2 +239,7 @@\n-        return 19 + sign;\n-    }\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 < -9) {\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[-i2]);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i2);\n+        }\n@@ -154,7 +247,4 @@\n-    \/**\n-     * For values from 0 to 99 return a short encoding a pair of ASCII-encoded digit characters in little-endian\n-     * @param i value to convert\n-     * @return a short encoding a pair of ASCII-encoded digit characters\n-     *\/\n-    public static short digitPair(int i) {\n-        return DIGITS[i];\n+        if (negative) {\n+            buf[--charPos] = (byte)'-';\n+        }\n+        return charPos;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":149,"deletions":59,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Digits provides a fast methodology for converting integers and longs to\n- * ASCII strings.\n- *\n- * @since 21\n- *\/\n-public sealed interface Digits permits DecimalDigits, HexDigits, OctalDigits {\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param buffer     byte buffer to copy into\n-     * @param index      insert point + 1\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\n-     * @throws Throwable if putCharMH fails (unusual).\n-     *\/\n-    int digits(long value, byte[] buffer, int index,\n-               MethodHandle putCharMH) throws Throwable;\n-\n-    \/**\n-     * Calculate the number of digits required to represent the long.\n-     *\n-     * @param value value to convert\n-     *\n-     * @return number of digits\n-     *\/\n-    int size(long value);\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Digits.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,1 +35,2 @@\n- * Digits class for hexadecimal digits.\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * hexadecimal digits ASCII strings.\n@@ -37,1 +40,3 @@\n-public final class HexDigits implements Digits {\n+public final class HexDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -68,5 +73,0 @@\n-    \/**\n-     * Singleton instance of HexDigits.\n-     *\/\n-    public static final Digits INSTANCE = new HexDigits();\n-\n@@ -115,3 +115,13 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer) {\n@@ -121,2 +131,2 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits >> 8);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -126,1 +136,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        buffer[--index] = (byte) (digits >> 8);\n@@ -129,1 +139,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -135,2 +145,38 @@\n-    @Override\n-    public int size(long value) {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer) {\n+        while ((value & ~0xFF) != 0) {\n+            int digits = DIGITS[(int) (value & 0xFF)];\n+            value >>>= 8;\n+            JLA.putCharUTF16(buffer, --index, (byte) (digits >> 8));\n+            JLA.putCharUTF16(buffer, --index, (byte) (digits & 0xFF));\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0xFF)];\n+        JLA.putCharUTF16(buffer, --index, (byte) (digits >> 8));\n+\n+        if (0xF < value) {\n+            JLA.putCharUTF16(buffer, --index, (byte) (digits & 0xFF));\n+        }\n+\n+        return index;\n+    }\n+\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":62,"deletions":16,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -37,1 +39,9 @@\n-public final class OctalDigits implements Digits {\n+\/**\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * octal digits ASCII strings.\n+ *\n+ * @since 21\n+ *\/\n+public final class OctalDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -41,5 +51,0 @@\n-    \/**\n-     * Singleton instance of OctalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new OctalDigits();\n-\n@@ -67,3 +72,45 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer){\n+        while ((value & ~0x3F) != 0) {\n+            int digits = DIGITS[(int) (value & 0x3F)];\n+            value >>>= 6;\n+            buffer[--index] = (byte) (digits >> 8);\n+            buffer[--index] = (byte) (digits & 0xFF);\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0x3F)];\n+        buffer[--index] = (byte) (digits >> 8);\n+\n+        if (7 < value) {\n+            buffer[--index] = (byte) (digits & 0xFF);\n+        }\n+\n+        return index;\n+    }\n+\n+\n+    \/**\n+     * This is a variant of {@link OctalDigits#getCharsLatin1(int, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer){\n@@ -73,2 +120,2 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            JLA.putCharUTF16(buffer, --index, digits >> 8);\n+            JLA.putCharUTF16(buffer, --index, digits & 0xFF);\n@@ -78,1 +125,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        JLA.putCharUTF16(buffer, --index, digits >> 8);\n@@ -81,1 +128,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            JLA.putCharUTF16(buffer, --index, digits & 0xFF);\n@@ -87,2 +134,8 @@\n-    @Override\n-    public int size(long value) {\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OctalDigits.java","additions":68,"deletions":15,"binary":false,"changes":83,"status":"modified"}]}