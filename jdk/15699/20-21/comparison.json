{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.util.FormatConcatItem;\n@@ -32,0 +31,1 @@\n+import jdk.internal.util.FormatConcatItem;\n@@ -523,4 +523,25 @@\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static boolean isLatin1(long indexCoder) {\n-        return indexCoder < UTF16;\n+    \/*\n+     * Initialize after phase1.\n+     *\/\n+    private static class LateInit {\n+        static final MethodHandle GETCHAR_LATIN1_MH;\n+\n+        static final MethodHandle GETCHAR_UTF16_MH;\n+\n+        static final MethodHandle PUTCHAR_LATIN1_MH;\n+\n+        static final MethodHandle PUTCHAR_UTF16_MH;\n+\n+        static {\n+            MethodType getCharMT =\n+                MethodType.methodType(char.class,\n+                        byte[].class, int.class);\n+            MethodType putCharMT =\n+                MethodType.methodType(void.class,\n+                        byte[].class, int.class, int.class);\n+            GETCHAR_LATIN1_MH = lookupStatic(\"getCharLatin1\", getCharMT);\n+            GETCHAR_UTF16_MH = lookupStatic(\"getCharUTF16\", getCharMT);\n+            PUTCHAR_LATIN1_MH = lookupStatic(\"putCharLatin1\", putCharMT);\n+            PUTCHAR_UTF16_MH = lookupStatic(\"putCharUTF16\", putCharMT);\n+        }\n+\n@@ -553,0 +574,14 @@\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static MethodHandle selectGetChar(long indexCoder) {\n+        return indexCoder < UTF16 ? LateInit.GETCHAR_LATIN1_MH :\n+                                    LateInit.GETCHAR_UTF16_MH;\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static MethodHandle selectPutChar(long indexCoder) {\n+        return indexCoder < UTF16 ? LateInit.PUTCHAR_LATIN1_MH :\n+                                    LateInit.PUTCHAR_UTF16_MH;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2482,2 +2482,2 @@\n-            public void putCharUTF16(byte[] buffer, int index, int ch) {\n-                StringUTF16.putChar(buffer, index, ch);\n+            public void putUTF16Char(byte[] bytes, int index, int ch) {\n+                StringUTF16.putChar(bytes, index, ch);\n@@ -2525,8 +2525,0 @@\n-            public long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value, String prefix) {\n-                return StringConcatHelper.prepend(indexCoder, buf, value, prefix);\n-            }\n-\n-            public boolean stringConcatHelpeIsLatin1(long lengthCoder) {\n-                return StringConcatHelper.isLatin1(lengthCoder);\n-            }\n-\n@@ -2541,4 +2533,0 @@\n-            public long stringConcatMix(long lengthCoder, char value) {\n-                return StringConcatHelper.mix(lengthCoder, value);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -43,1 +42,2 @@\n-import jdk.internal.vm.annotation.Stable;\n+\n+import static java.lang.invoke.MethodType.methodType;\n@@ -57,0 +57,17 @@\n+    private static final MethodHandle CHAR_MIX =\n+            JLA.stringConcatHelper(\"mix\",\n+                    MethodType.methodType(long.class, long.class,char.class));\n+\n+    private static final MethodHandle STRING_PREPEND =\n+            JLA.stringConcatHelper(\"prepend\",\n+                    MethodType.methodType(long.class, long.class, byte[].class,\n+                            String.class, String.class));\n+\n+    private static final MethodHandle SELECT_GETCHAR_MH =\n+            JLA.stringConcatHelper(\"selectGetChar\",\n+                    MethodType.methodType(MethodHandle.class, long.class));\n+\n+    private static final MethodHandle SELECT_PUTCHAR_MH =\n+            JLA.stringConcatHelper(\"selectPutChar\",\n+                    MethodType.methodType(MethodHandle.class, long.class));\n+\n@@ -58,1 +75,7 @@\n-        return JLA.stringConcatMix(lengthCoder, value);\n+        try {\n+            return (long)CHAR_MIX.invokeExact(lengthCoder, value);\n+        } catch (Error | RuntimeException ex) {\n+            throw ex;\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(ex);\n+        }\n@@ -65,2 +88,3 @@\n-    private static long stringPrepend(long lengthCoder, byte[] buffer, String value) {\n-        return JLA.stringConcatHelperPrepend(lengthCoder, buffer, value,\n+    private static long stringPrepend(long lengthCoder, byte[] buffer,\n+                                            String value) throws Throwable {\n+        return (long)STRING_PREPEND.invokeExact(lengthCoder, buffer, value,\n@@ -70,2 +94,19 @@\n-    private static void putCharUTF16(byte[] buffer, int index, int ch) {\n-        JLA.putCharUTF16(buffer, index, ch);\n+    private static MethodHandle selectGetChar(long indexCoder) throws Throwable {\n+        return (MethodHandle)SELECT_GETCHAR_MH.invokeExact(indexCoder);\n+    }\n+\n+    private static MethodHandle selectPutChar(long indexCoder) throws Throwable {\n+        return (MethodHandle)SELECT_PUTCHAR_MH.invokeExact(indexCoder);\n+    }\n+\n+    private static final MethodHandle PUT_CHAR_DIGIT;\n+\n+    static {\n+        try {\n+            Lookup lookup = MethodHandles.lookup();\n+            PUT_CHAR_DIGIT = lookup.findStatic(FormatItem.class, \"putByte\",\n+                    MethodType.methodType(void.class,\n+                            byte[].class, int.class, int.class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"putByte lookup failed\", ex);\n+        }\n@@ -74,2 +115,2 @@\n-    private static boolean isLatin1(long lengthCoder) {\n-        return JLA.stringConcatHelpeIsLatin1(lengthCoder);\n+    private static void putByte(byte[] buffer, int index, int ch) {\n+        buffer[index] = (byte)ch;\n@@ -90,0 +131,1 @@\n+        private final byte[] digits;\n@@ -99,1 +141,1 @@\n-                          boolean parentheses, int groupSize, long value) {\n+                          boolean parentheses, int groupSize, long value) throws Throwable {\n@@ -104,1 +146,3 @@\n-            int length = DecimalDigits.stringSize(value);\n+            int length = DecimalDigits.INSTANCE.size(value);\n+            this.digits = new byte[length];\n+            DecimalDigits.INSTANCE.digits(value, this.digits, length, PUT_CHAR_DIGIT);\n@@ -130,10 +174,2 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n-            if (isLatin1(lengthCoder)) {\n-                return prependLatin1(lengthCoder, buffer);\n-            } else {\n-                return prependUTF16(lengthCoder, buffer);\n-            }\n-        }\n-\n-        private long prependLatin1(long lengthCoder, byte[] buffer) {\n-            int lengthCoderLatin1 = (int) lengthCoder;\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n@@ -142,1 +178,1 @@\n-                buffer[--lengthCoderLatin1] = ')';\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)')');\n@@ -148,4 +184,0 @@\n-                int digitLength = this.length + (isNegative ? 1 : 0);\n-                byte[] digits = new byte[digitLength];\n-                DecimalDigits.getCharsLatin1(value, digitLength, digits);\n-\n@@ -154,1 +186,2 @@\n-                        buffer[--lengthCoderLatin1] = (byte) groupingSeparator;\n+                        putCharMH.invokeExact(buffer, (int)--lengthCoder,\n+                                (int)groupingSeparator);\n@@ -158,1 +191,2 @@\n-                    buffer[--lengthCoderLatin1] = (byte) (digits[digits.length - i] + digitOffset);\n+                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n+                            digits[digits.length - i] + digitOffset);\n@@ -161,31 +195,0 @@\n-                DecimalDigits.getCharsLatin1(value, lengthCoderLatin1, buffer);\n-                lengthCoderLatin1 -= length;\n-            }\n-\n-            for (int i = length + signLength() + groupLength(); i < width; i++) {\n-                buffer[--lengthCoderLatin1] = '0';\n-            }\n-\n-            if (parentheses) {\n-                buffer[--lengthCoderLatin1] = '(';\n-            }\n-\n-            if (prefixSign != '\\0') {\n-                buffer[--lengthCoderLatin1] = prefixSign;\n-            }\n-\n-            return lengthCoderLatin1;\n-        }\n-\n-        private long prependUTF16(long lengthCoder, byte[] buffer) {\n-            if (parentheses) {\n-                putCharUTF16(buffer, (int)--lengthCoder, (int)')');\n-            }\n-\n-            if (0 < groupSize) {\n-                int groupIndex = groupSize;\n-\n-                int digitLength = this.length + (isNegative ? 1 : 0);\n-                byte[] digits = new byte[digitLength];\n-                DecimalDigits.getCharsLatin1(value, digitLength, digits);\n-\n@@ -193,6 +196,2 @@\n-                    if (groupIndex-- == 0) {\n-                        putCharUTF16(buffer, (int) --lengthCoder, (int) groupingSeparator);\n-                        groupIndex = groupSize - 1;\n-                    }\n-\n-                    putCharUTF16(buffer, (int) --lengthCoder, digits[digits.length - i] + digitOffset);\n+                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n+                            digits[digits.length - i] + digitOffset);\n@@ -200,3 +199,0 @@\n-            } else {\n-                DecimalDigits.getCharsUTF16(value, (int)lengthCoder, buffer);\n-                lengthCoder -= length;\n@@ -206,1 +202,1 @@\n-                putCharUTF16(buffer, (int) --lengthCoder, (int) '0');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n@@ -210,1 +206,1 @@\n-                putCharUTF16(buffer, (int) --lengthCoder, (int) '(');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'(');\n@@ -212,1 +208,0 @@\n-\n@@ -214,1 +209,1 @@\n-                putCharUTF16(buffer, (int) --lengthCoder, (int) prefixSign);\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)prefixSign);\n@@ -234,1 +229,1 @@\n-            this.length = HexDigits.stringSize(value);\n+            this.length = HexDigits.INSTANCE.size(value);\n@@ -251,23 +246,3 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n-            if (isLatin1(lengthCoder)) {\n-                return prependLatin1(lengthCoder, buffer);\n-            } else {\n-                return prependUTF16(lengthCoder, buffer);\n-            }\n-        }\n-\n-        protected long prependLatin1(long lengthCoder, byte[] buffer) {\n-            int lengthCoderLatin1 = (int) lengthCoder;\n-            HexDigits.getCharsLatin1(value, lengthCoderLatin1, buffer);\n-            lengthCoderLatin1 -= length;\n-\n-            if (hasPrefix && value != 0) {\n-                buffer[--lengthCoderLatin1] = 'x';\n-                buffer[--lengthCoderLatin1] = '0';\n-            }\n-\n-            return lengthCoderLatin1;\n-        }\n-\n-        protected long prependUTF16(long lengthCoder, byte[] buffer) {\n-            HexDigits.getCharsUTF16(value, (int)lengthCoder, buffer);\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            HexDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n@@ -277,1 +252,1 @@\n-                putCharUTF16(buffer, (int)--lengthCoder, '0');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n@@ -280,3 +255,3 @@\n-            if (hasPrefix && value != 0) {\n-                putCharUTF16(buffer, (int)--lengthCoder, 'x');\n-                putCharUTF16(buffer, (int)--lengthCoder, '0');\n+            if (hasPrefix) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'x');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n@@ -302,1 +277,1 @@\n-            this.length = OctalDigits.stringSize(value);\n+            this.length = OctalDigits.INSTANCE.size(value);\n@@ -319,17 +294,4 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n-            if (isLatin1(lengthCoder)) {\n-                return prependLatin1(lengthCoder, buffer);\n-            } else {\n-                return prependUTF16(lengthCoder, buffer);\n-            }\n-        }\n-\n-        protected long prependLatin1(long lengthCoder, byte[] buffer) {\n-            int lengthCoderLatin1 = (int) lengthCoder;\n-            OctalDigits.getCharsLatin1(value, lengthCoderLatin1, buffer);\n-            lengthCoderLatin1 -= length;\n-\n-            int zeroesLength = zeroesLength();\n-            if (hasPrefix && value != 0) {\n-                zeroesLength++;\n-            }\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            OctalDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n+            lengthCoder -= length;\n@@ -337,2 +299,2 @@\n-            for (int i = 0; i < zeroesLength; i++) {\n-                buffer[--lengthCoderLatin1] = '0';\n+            for (int i = 0; i < zeroesLength(); i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n@@ -341,8 +303,0 @@\n-            return lengthCoderLatin1;\n-        }\n-\n-        protected long prependUTF16(long lengthCoder, byte[] buffer) {\n-            OctalDigits.getCharsUTF16(value, (int) lengthCoder, buffer);\n-            lengthCoder -= length;\n-\n-            int zeroesLength = zeroesLength();\n@@ -350,4 +304,1 @@\n-                zeroesLength++;\n-            }\n-            for (int i = 0; i < zeroesLength; i++) {\n-                putCharUTF16(buffer, (int)--lengthCoder, '0');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n@@ -365,8 +316,0 @@\n-        @Stable\n-        private final static byte[] BYTES_TRUE_LATIN1 = \"true\".getBytes(StandardCharsets.ISO_8859_1);\n-        @Stable\n-        private final static byte[] BYTES_TRUE_UTF16 = \"true\".getBytes(StandardCharsets.UTF_16);\n-        @Stable\n-        private final static byte[] BYTES_FALSE_LATIN1 = \"false\".getBytes(StandardCharsets.ISO_8859_1);\n-        @Stable\n-        private final static byte[] BYTES_FALSE_UTF16 = \"false\".getBytes(StandardCharsets.UTF_16);\n@@ -384,5 +327,8 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n-            boolean latin1 = isLatin1(lengthCoder);\n-            byte[] bytes;\n-            if (latin1) {\n-                bytes = value ? BYTES_TRUE_LATIN1 : BYTES_FALSE_LATIN1;\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            if (value) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'r');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'t');\n@@ -390,1 +336,5 @@\n-                bytes = value ? BYTES_FALSE_LATIN1 : BYTES_FALSE_UTF16;\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'s');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'a');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'f');\n@@ -392,2 +342,2 @@\n-            System.arraycopy(bytes, 0, buffer, (int) (lengthCoder) - bytes.length, bytes.length);\n-            return lengthCoder - bytes.length;\n+\n+            return lengthCoder;\n@@ -413,6 +363,4 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n-            if (isLatin1(lengthCoder)) {\n-                buffer[(int) --lengthCoder] = (byte) value;\n-            } else {\n-                putCharUTF16(buffer, (int) --lengthCoder, value);\n-            }\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)value);\n+\n@@ -439,1 +387,1 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n@@ -475,1 +423,1 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n@@ -504,1 +452,1 @@\n-        public abstract long prepend(long lengthCoder, byte[] buffer);\n+        public abstract long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n@@ -525,1 +473,2 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n@@ -528,8 +477,2 @@\n-            if (isLatin1(lengthCoder)) {\n-                for (int i = length(); i < width; i++) {\n-                    buffer[(int) --lengthCoder] = ' ';\n-                }\n-            } else {\n-                for (int i = length(); i < width; i++) {\n-                    putCharUTF16(buffer, (int) --lengthCoder, (int) ' ');\n-                }\n+            for (int i = length(); i < width; i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n@@ -560,10 +503,5 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n-            int length = length();\n-            if (isLatin1(lengthCoder)) {\n-                for (int i = length; i < width; i++) {\n-                    buffer[(int)--lengthCoder] = ' ';\n-                }\n-            } else {\n-                for (int i = length; i < width; i++) {\n-                    putCharUTF16(buffer, (int)--lengthCoder, ' ');\n-                }\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            for (int i = length(); i < width; i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n@@ -583,6 +521,0 @@\n-        @Stable\n-        private final static byte[] BYTES_LATIN1 = \"null\".getBytes(StandardCharsets.ISO_8859_1);\n-\n-        @Stable\n-        private final static byte[] BYTES_UTF16 = \"null\".getBytes(StandardCharsets.UTF_16);\n-\n@@ -598,4 +530,9 @@\n-        public long prepend(long lengthCoder, byte[] buffer) {\n-            byte[] bytes = isLatin1(lengthCoder) ? BYTES_LATIN1 : BYTES_UTF16;\n-            System.arraycopy(bytes, 0, buffer, (int) (lengthCoder) - bytes.length, bytes.length);\n-            return lengthCoder - 4;\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'n');\n+\n+            return lengthCoder;\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":123,"deletions":186,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -356,0 +356,10 @@\n+    \/**\n+     * Put the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     * @param ch the Unicode character to be encoded and stored\n+     *\/\n+    void putUTF16Char(byte[] bytes, int index, int ch);\n+\n@@ -409,10 +419,0 @@\n-    \/**\n-     * Returns {@code true} if lengthCoder is Latin1\n-     *\/\n-    boolean stringConcatHelpeIsLatin1(long lengthCoder);\n-\n-    \/**\n-     * putChar of to buffer as UTF16\n-     *\/\n-    void putCharUTF16(byte[] buffer, int index, int ch);\n-\n@@ -429,11 +429,0 @@\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     *\/\n-    long stringConcatMix(long lengthCoder, char value);\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\/\n-    long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value, String prefix);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-public final class DecimalDigits {\n+public final class DecimalDigits implements Digits {\n@@ -66,0 +66,5 @@\n+    \/**\n+     * Singleton instance of DecimalDigits.\n+     *\/\n+    public static final Digits INSTANCE = new DecimalDigits();\n+\n@@ -85,0 +90,53 @@\n+    @Override\n+    public int digits(long value, byte[] buffer, int index,\n+                      MethodHandle putCharMH) throws Throwable {\n+        boolean negative = value < 0;\n+        if (!negative) {\n+            value = -value;\n+        }\n+\n+        long q;\n+        int r;\n+        while (value <= Integer.MIN_VALUE) {\n+            q = value \/ 100;\n+            r = (int)((q * 100) - value);\n+            value = q;\n+            int digits = DIGITS[r];\n+\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+        }\n+\n+        int iq, ivalue = (int)value;\n+        while (ivalue <= -100) {\n+            iq = ivalue \/ 100;\n+            r = (iq * 100) - ivalue;\n+            ivalue = iq;\n+            int digits = DIGITS[r];\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+        }\n+\n+        if (ivalue < 0) {\n+            ivalue = -ivalue;\n+        }\n+\n+        int digits = DIGITS[ivalue];\n+        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+\n+        if (9 < ivalue) {\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+        }\n+\n+        if (negative) {\n+            putCharMH.invokeExact(buffer, --index, (int)'-');\n+        }\n+\n+        return index;\n+    }\n+\n+    @Override\n+    public int size(long value) {\n+        return stringSize(value);\n+    }\n+\n@@ -283,1 +341,1 @@\n-            JLA.putCharUTF16(buf, --charPos, '0' - i);\n+            JLA.putUTF16Char(buf, --charPos, '0' - i);\n@@ -287,1 +345,1 @@\n-            JLA.putCharUTF16(buf, --charPos, '-');\n+            JLA.putUTF16Char(buf, --charPos, '-');\n@@ -334,1 +392,1 @@\n-            JLA.putCharUTF16(buf, --charPos, '0' - i2);\n+            JLA.putUTF16Char(buf, --charPos, '0' - i2);\n@@ -338,1 +396,1 @@\n-            JLA.putCharUTF16(buf, --charPos, '-');\n+            JLA.putUTF16Char(buf, --charPos, '-');\n@@ -351,2 +409,2 @@\n-        JLA.putCharUTF16(buf, charPos, pair & 0xFF);\n-        JLA.putCharUTF16(buf, charPos + 1, pair >> 8);\n+        JLA.putUTF16Char(buf, charPos, pair & 0xFF);\n+        JLA.putUTF16Char(buf, charPos + 1, pair >> 8);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":65,"deletions":7,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+\/**\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * ASCII strings.\n+ *\n+ * @since 21\n+ *\/\n+public sealed interface Digits permits DecimalDigits, HexDigits, OctalDigits {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param buffer     byte buffer to copy into\n+     * @param index      insert point + 1\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    int digits(long value, byte[] buffer, int index,\n+               MethodHandle putCharMH) throws Throwable;\n+\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    int size(long value);\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Digits.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -54,0 +54,2 @@\n+     *\n+     * @throws Throwable if fails to prepend value (unusual).\n@@ -55,1 +57,1 @@\n-    long prepend(long lengthCoder, byte[] buffer);\n+    long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/FormatConcatItem.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -35,2 +33,1 @@\n- * Digits provides a fast methodology for converting integers and longs to\n- * hexadecimal digits ASCII strings.\n+ * Digits class for hexadecimal digits.\n@@ -40,3 +37,1 @@\n-public final class HexDigits {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n+public final class HexDigits implements Digits {\n@@ -73,0 +68,5 @@\n+    \/**\n+     * Singleton instance of HexDigits.\n+     *\/\n+    public static final Digits INSTANCE = new HexDigits();\n+\n@@ -115,39 +115,3 @@\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param index      insert point + 1\n-     * @param buffer     byte buffer to copy into\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\/\n-    public static int getCharsLatin1(long value, int index, byte[] buffer) {\n-        while ((value & ~0xFF) != 0) {\n-            short pair = DIGITS[((int) value) & 0xFF];\n-            buffer[--index] = (byte)(pair >> 8);\n-            buffer[--index] = (byte)(pair);\n-            value >>>= 8;\n-        }\n-\n-        int digits = DIGITS[(int) (value & 0xFF)];\n-        buffer[--index] = (byte) (digits >> 8);\n-\n-        if (0xF < value) {\n-            buffer[--index] = (byte) (digits & 0xFF);\n-        }\n-\n-        return index;\n-    }\n-\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param index      insert point + 1\n-     * @param buffer     byte buffer to copy into\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\/\n-    public static int getCharsUTF16(long value, int index, byte[] buffer) {\n+    @Override\n+    public int digits(long value, byte[] buffer, int index,\n+                      MethodHandle putCharMH) throws Throwable {\n@@ -155,3 +119,1 @@\n-            int pair = (int) DIGITS[((int) value) & 0xFF];\n-            JLA.putCharUTF16(buffer, --index, pair >> 8);\n-            JLA.putCharUTF16(buffer, --index, pair & 0xFF);\n+            int digits = DIGITS[(int) (value & 0xFF)];\n@@ -159,0 +121,2 @@\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -162,1 +126,1 @@\n-        JLA.putCharUTF16(buffer, --index, (byte) (digits >> 8));\n+        putCharMH.invokeExact(buffer, --index, digits >> 8);\n@@ -165,1 +129,1 @@\n-            JLA.putCharUTF16(buffer, --index, (byte) (digits & 0xFF));\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -171,8 +135,2 @@\n-    \/**\n-     * Calculate the number of digits required to represent the long.\n-     *\n-     * @param value value to convert\n-     *\n-     * @return number of digits\n-     *\/\n-    public static int stringSize(long value) {\n+    @Override\n+    public int size(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":17,"deletions":59,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -39,9 +37,1 @@\n-\/**\n- * Digits provides a fast methodology for converting integers and longs to\n- * octal digits ASCII strings.\n- *\n- * @since 21\n- *\/\n-public final class OctalDigits {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n+public final class OctalDigits implements Digits {\n@@ -51,0 +41,5 @@\n+    \/**\n+     * Singleton instance of OctalDigits.\n+     *\/\n+    public static final Digits INSTANCE = new OctalDigits();\n+\n@@ -72,11 +67,3 @@\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param index      insert point + 1\n-     * @param buffer     byte buffer to copy into\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\/\n-    public static int getCharsLatin1(long value, int index, byte[] buffer){\n+    @Override\n+    public int digits(long value, byte[] buffer, int index,\n+                      MethodHandle putCharMH) throws Throwable {\n@@ -84,1 +71,1 @@\n-            int digits = DIGITS[((int) value) & 0x3F];\n+            int digits = DIGITS[(int) (value & 0x3F)];\n@@ -86,2 +73,2 @@\n-            buffer[--index] = (byte) (digits >> 8);\n-            buffer[--index] = (byte) (digits & 0xFF);\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -91,1 +78,1 @@\n-        buffer[--index] = (byte) (digits >> 8);\n+        putCharMH.invokeExact(buffer, --index, digits >> 8);\n@@ -94,1 +81,1 @@\n-            buffer[--index] = (byte) (digits & 0xFF);\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -100,38 +87,2 @@\n-\n-    \/**\n-     * This is a variant of {@link OctalDigits#getCharsLatin1(int, int, byte[])}, but for\n-     * UTF-16 coder.\n-     *\n-     * @param value      value to convert\n-     * @param index      insert point + 1\n-     * @param buffer     byte buffer to copy into\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\/\n-    public static int getCharsUTF16(long value, int index, byte[] buffer){\n-        while ((value & ~0x3F) != 0) {\n-            int pair = (int) DIGITS[((int) value) & 0x3F];\n-            JLA.putCharUTF16(buffer, --index, pair >> 8);\n-            JLA.putCharUTF16(buffer, --index, pair & 0xFF);\n-            value >>>= 6;\n-        }\n-\n-        int digits = DIGITS[(int) (value & 0x3F)];\n-        JLA.putCharUTF16(buffer, --index, digits >> 8);\n-\n-        if (7 < value) {\n-            JLA.putCharUTF16(buffer, --index, digits & 0xFF);\n-        }\n-\n-        return index;\n-    }\n-\n-    \/**\n-     * Calculate the number of digits required to represent the long.\n-     *\n-     * @param value value to convert\n-     *\n-     * @return number of digits\n-     *\/\n-    public static int stringSize(long value) {\n+    @Override\n+    public int size(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OctalDigits.java","additions":16,"deletions":65,"binary":false,"changes":81,"status":"modified"}]}