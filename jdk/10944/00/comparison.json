{"files":[{"patch":"@@ -2096,0 +2096,6 @@\n+    } else if (VectorNode::is_minmax_opcode(opc) && is_subword_type(velt_basic_type(p0))) {\n+      \/\/ Java API for Math.min\/max operations supports only int, long, float\n+      \/\/ and double types. Thus, avoid generating vector min\/max nodes for\n+      \/\/ integer subword types with superword vectorization.\n+      \/\/ See JDK-8294816 for miscompilation issues with shorts.\n+      return false;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -479,0 +479,4 @@\n+bool VectorNode::is_minmax_opcode(int opc) {\n+  return opc == Op_MinI || opc == Op_MaxI;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+  static bool is_minmax_opcode(int opc);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8294816\n+ * @summary Test Math.min\/max vectorization miscompilation for integer subwords\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.TestMinMaxSubword\n+ *\/\n+\n+public class TestMinMaxSubword {\n+    private static final int LENGTH = 256;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static int val = 65536;\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static byte[] ba;\n+    private static byte[] bb;\n+\n+    static {\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        for(int i = 0; i < LENGTH; i++) {\n+            sa[i] = (short) (RANDOM.nextInt(999) + 1);\n+            ba[i] = (byte) (RANDOM.nextInt(99) + 1);\n+        }\n+    }\n+\n+    \/\/ Ensure vector max\/min instructions are not generated for integer subword types\n+    \/\/ as Java APIs for Math.min\/max do not support integer subword types and superword\n+    \/\/ should not generate vectorized Min\/Max nodes for them.\n+    @Test\n+    @IR(failOn = {IRNode.Min_V})\n+    public static void testMinShort() {\n+        for (int i = 0; i < LENGTH; i++) {\n+           sb[i] = (short) Math.min(sa[i], val);\n+        }\n+    }\n+\n+    @Run(test = \"testMinShort\")\n+    public static void testMinShort_runner() {\n+        testMinShort();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(sb[i], sa[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.Max_V})\n+    public static void testMaxShort() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            sb[i] = (short) Math.max(sa[i], val);\n+        }\n+    }\n+    @Run(test = \"testMaxShort\")\n+    public static void testMaxShort_runner() {\n+        testMaxShort();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(sb[i], (short) 0);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.Min_V})\n+    public static void testMinByte() {\n+        for (int i = 0; i < LENGTH; i++) {\n+           bb[i] = (byte) Math.min(ba[i], val);\n+        }\n+    }\n+\n+    @Run(test = \"testMinByte\")\n+    public static void testMinByte_runner() {\n+        testMinByte();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(bb[i], ba[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.Max_V})\n+    public static void testMaxByte() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            bb[i] = (byte) Math.max(ba[i], val);\n+        }\n+    }\n+    @Run(test = \"testMaxByte\")\n+    public static void testMaxByte_runner() {\n+        testMaxByte();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(bb[i], (byte) 0);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMinMaxSubword.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}