{"files":[{"patch":"@@ -5009,0 +5009,59 @@\n+void Assembler::sall(Address dst, int imm8) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  prefix(dst);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(4), dst);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(4), dst);\n+    emit_int8(imm8);\n+  }\n+}\n+\n+void Assembler::sall(Address dst) {\n+  InstructionMark im(this);\n+  prefix(dst);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(4), dst);\n+}\n+\n+void Assembler::sall(Register dst, int imm8) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  int encode = prefix_and_encode(dst->encoding());\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n+void Assembler::sall(Register dst) {\n+  int encode = prefix_and_encode(dst->encoding());\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n+void Assembler::sarl(Address dst, int imm8) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionMark im(this);\n+  prefix(dst);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(7), dst);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(7), dst);\n+    emit_int8(imm8);\n+  }\n+}\n+\n+void Assembler::sarl(Address dst) {\n+  InstructionMark im(this);\n+  prefix(dst);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(7), dst);\n+}\n+\n@@ -10439,0 +10498,55 @@\n+void Assembler::salq(Address dst, int imm8) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  if (imm8 == 1) {\n+    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_operand(as_Register(4), dst);\n+  }\n+  else {\n+    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_operand(as_Register(4), dst);\n+    emit_int8(imm8);\n+  }\n+}\n+\n+void Assembler::salq(Address dst) {\n+  InstructionMark im(this);\n+  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_operand(as_Register(4), dst);\n+}\n+\n+void Assembler::salq(Register dst, int imm8) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  int encode = prefixq_and_encode(dst->encoding());\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n+void Assembler::salq(Register dst) {\n+  int encode = prefixq_and_encode(dst->encoding());\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n+void Assembler::sarq(Address dst, int imm8) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  if (imm8 == 1) {\n+    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_operand(as_Register(7), dst);\n+  }\n+  else {\n+    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_operand(as_Register(7), dst);\n+    emit_int8(imm8);\n+  }\n+}\n+\n+void Assembler::sarq(Address dst) {\n+  InstructionMark im(this);\n+  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_operand(as_Register(7), dst);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -1916,0 +1916,14 @@\n+  void sall(Register dst, int imm8);\n+  void sall(Register dst);\n+  void sall(Address dst, int imm8);\n+  void sall(Address dst);\n+\n+#ifdef _LP64\n+  void salq(Register dst, int imm8);\n+  void salq(Register dst);\n+  void salq(Address dst, int imm8);\n+  void salq(Address dst);\n+#endif\n+\n+  void sarl(Address dst, int imm8);\n+  void sarl(Address dst);\n@@ -1919,0 +1933,3 @@\n+#ifdef _LP64\n+  void sarq(Address dst, int imm8);\n+  void sarq(Address dst);\n@@ -1921,0 +1938,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1822,135 +1822,0 @@\n-  enc_class cdql_enc(no_rax_rdx_RegI div)\n-  %{\n-    \/\/ Full implementation of Java idiv and irem; checks for\n-    \/\/ special case as described in JVM spec., p.243 & p.271.\n-    \/\/\n-    \/\/         normal case                           special case\n-    \/\/\n-    \/\/ input : rax: dividend                         min_int\n-    \/\/         reg: divisor                          -1\n-    \/\/\n-    \/\/ output: rax: quotient  (= rax idiv reg)       min_int\n-    \/\/         rdx: remainder (= rax irem reg)       0\n-    \/\/\n-    \/\/  Code sequnce:\n-    \/\/\n-    \/\/    0:   3d 00 00 00 80          cmp    $0x80000000,%eax\n-    \/\/    5:   75 07\/08                jne    e <normal>\n-    \/\/    7:   33 d2                   xor    %edx,%edx\n-    \/\/  [div >= 8 -> offset + 1]\n-    \/\/  [REX_B]\n-    \/\/    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div\n-    \/\/    c:   74 03\/04                je     11 <done>\n-    \/\/ 000000000000000e <normal>:\n-    \/\/    e:   99                      cltd\n-    \/\/  [div >= 8 -> offset + 1]\n-    \/\/  [REX_B]\n-    \/\/    f:   f7 f9                   idiv   $div\n-    \/\/ 0000000000000011 <done>:\n-\n-    \/\/ cmp    $0x80000000,%eax\n-    emit_opcode(cbuf, 0x3d);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x80);\n-\n-    \/\/ jne    e <normal>\n-    emit_opcode(cbuf, 0x75);\n-    emit_d8(cbuf, $div$$reg < 8 ? 0x07 : 0x08);\n-\n-    \/\/ xor    %edx,%edx\n-    emit_opcode(cbuf, 0x33);\n-    emit_d8(cbuf, 0xD2);\n-\n-    \/\/ cmp    $0xffffffffffffffff,%ecx\n-    if ($div$$reg >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-    }\n-    emit_opcode(cbuf, 0x83);\n-    emit_rm(cbuf, 0x3, 0x7, $div$$reg & 7);\n-    emit_d8(cbuf, 0xFF);\n-\n-    \/\/ je     11 <done>\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, $div$$reg < 8 ? 0x03 : 0x04);\n-\n-    \/\/ <normal>\n-    \/\/ cltd\n-    emit_opcode(cbuf, 0x99);\n-\n-    \/\/ idivl (note: must be emitted by the user of this rule)\n-    \/\/ <done>\n-  %}\n-\n-  enc_class cdqq_enc(no_rax_rdx_RegL div)\n-  %{\n-    \/\/ Full implementation of Java ldiv and lrem; checks for\n-    \/\/ special case as described in JVM spec., p.243 & p.271.\n-    \/\/\n-    \/\/         normal case                           special case\n-    \/\/\n-    \/\/ input : rax: dividend                         min_long\n-    \/\/         reg: divisor                          -1\n-    \/\/\n-    \/\/ output: rax: quotient  (= rax idiv reg)       min_long\n-    \/\/         rdx: remainder (= rax irem reg)       0\n-    \/\/\n-    \/\/  Code sequnce:\n-    \/\/\n-    \/\/    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx\n-    \/\/    7:   00 00 80\n-    \/\/    a:   48 39 d0                cmp    %rdx,%rax\n-    \/\/    d:   75 08                   jne    17 <normal>\n-    \/\/    f:   33 d2                   xor    %edx,%edx\n-    \/\/   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div\n-    \/\/   15:   74 05                   je     1c <done>\n-    \/\/ 0000000000000017 <normal>:\n-    \/\/   17:   48 99                   cqto\n-    \/\/   19:   48 f7 f9                idiv   $div\n-    \/\/ 000000000000001c <done>:\n-\n-    \/\/ mov    $0x8000000000000000,%rdx\n-    emit_opcode(cbuf, Assembler::REX_W);\n-    emit_opcode(cbuf, 0xBA);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x80);\n-\n-    \/\/ cmp    %rdx,%rax\n-    emit_opcode(cbuf, Assembler::REX_W);\n-    emit_opcode(cbuf, 0x39);\n-    emit_d8(cbuf, 0xD0);\n-\n-    \/\/ jne    17 <normal>\n-    emit_opcode(cbuf, 0x75);\n-    emit_d8(cbuf, 0x08);\n-\n-    \/\/ xor    %edx,%edx\n-    emit_opcode(cbuf, 0x33);\n-    emit_d8(cbuf, 0xD2);\n-\n-    \/\/ cmp    $0xffffffffffffffff,$div\n-    emit_opcode(cbuf, $div$$reg < 8 ? Assembler::REX_W : Assembler::REX_WB);\n-    emit_opcode(cbuf, 0x83);\n-    emit_rm(cbuf, 0x3, 0x7, $div$$reg & 7);\n-    emit_d8(cbuf, 0xFF);\n-\n-    \/\/ je     1e <done>\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, 0x05);\n-\n-    \/\/ <normal>\n-    \/\/ cqto\n-    emit_opcode(cbuf, Assembler::REX_W);\n-    emit_opcode(cbuf, 0x99);\n-\n-    \/\/ idivq (note: must be emitted by the user of this rule)\n-    \/\/ <done>\n-  %}\n-\n@@ -8386,2 +8251,13 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));\n+  ins_encode %{\n+    Label normal;\n+    Label done;\n+    __ cmpl($rax$$Register, 0x80000000);\n+    __ jccb(Assembler::notEqual, normal);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ cmpl($div$$Register, -1);\n+    __ jccb(Assembler::equal, done);\n+    __ bind(normal);\n+    __ cdql();\n+    __ idivl($div$$Register);\n+    __ bind(done);\n+  %}\n@@ -8407,2 +8283,14 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));\n+  ins_encode %{\n+    Label normal;\n+    Label done;\n+    __ mov64($rdx$$Register, 0x8000000000000000);\n+    __ cmpq($rax$$Register, $rdx$$Register);\n+    __ jccb(Assembler::notEqual, normal);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ cmpq($div$$Register, -1);\n+    __ jccb(Assembler::equal, done);\n+    __ bind(normal);\n+    __ cdqq();\n+    __ idivq($div$$Register);\n+    __ bind(done);\n+  %}\n@@ -8428,2 +8316,13 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));\n+  ins_encode %{\n+    Label normal;\n+    Label done;\n+    __ cmpl($rax$$Register, 0x80000000);\n+    __ jccb(Assembler::notEqual, normal);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ cmpl($div$$Register, -1);\n+    __ jccb(Assembler::equal, done);\n+    __ bind(normal);\n+    __ cdql();\n+    __ idivl($div$$Register);\n+    __ bind(done);\n+  %}\n@@ -8450,2 +8349,14 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));\n+  ins_encode %{\n+    Label normal;\n+    Label done;\n+    __ mov64($rdx$$Register, 0x8000000000000000);\n+    __ cmpq($rax$$Register, $rdx$$Register);\n+    __ jccb(Assembler::notEqual, normal);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ cmpq($div$$Register, -1);\n+    __ jccb(Assembler::equal, done);\n+    __ bind(normal);\n+    __ cdqq();\n+    __ idivq($div$$Register);\n+    __ bind(done);\n+  %}\n@@ -8483,2 +8394,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(reg_opc_imm_wide(dst, 0x3F));\n+  ins_encode %{\n+    __ sarq($dst$$Register, 63);\n+  %}\n@@ -8493,2 +8405,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(reg_opc_imm_wide(dst, 0x2));\n+  ins_encode %{\n+    __ sarq($dst$$Register, 2);\n+  %}\n@@ -8531,2 +8444,13 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));\n+  ins_encode %{\n+    Label normal;\n+    Label done;\n+    __ cmpl($rax$$Register, 0x80000000);\n+    __ jccb(Assembler::notEqual, normal);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ cmpl($div$$Register, -1);\n+    __ jccb(Assembler::equal, done);\n+    __ bind(normal);\n+    __ cdql();\n+    __ idivl($div$$Register);\n+    __ bind(done);\n+  %}\n@@ -8552,2 +8476,14 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));\n+  ins_encode %{\n+    Label normal;\n+    Label done;\n+    __ mov64($rdx$$Register, 0x8000000000000000);\n+    __ cmpq($rax$$Register, $rdx$$Register);\n+    __ jccb(Assembler::notEqual, normal);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ cmpq($div$$Register, -1);\n+    __ jccb(Assembler::equal, done);\n+    __ bind(normal);\n+    __ cdqq();\n+    __ idivq($div$$Register);\n+    __ bind(done);\n+  %}\n@@ -8565,2 +8501,3 @@\n-  opcode(0xD1, 0x4); \/* D1 \/4 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n@@ -8577,2 +8514,3 @@\n-  opcode(0xD1, 0x4); \/* D1 \/4 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sall($dst$$Address, $shift$$constant);\n+  %}\n@@ -8589,2 +8527,3 @@\n-  opcode(0xC1, 0x4); \/* C1 \/4 ib *\/\n-  ins_encode(reg_opc_imm(dst, shift));\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n@@ -8601,2 +8540,3 @@\n-  opcode(0xC1, 0x4); \/* C1 \/4 ib *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ sall($dst$$Address, $shift$$constant);\n+  %}\n@@ -8613,2 +8553,3 @@\n-  opcode(0xD3, 0x4); \/* D3 \/4 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sall($dst$$Register);\n+  %}\n@@ -8625,2 +8566,3 @@\n-  opcode(0xD3, 0x4); \/* D3 \/4 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sall($dst$$Address);\n+  %}\n@@ -8650,2 +8592,3 @@\n-  opcode(0xD1, 0x7); \/* D1 \/7 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sarl($dst$$Address, $shift$$constant);\n+  %}\n@@ -8675,2 +8618,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ sarl($dst$$Address, $shift$$constant);\n+  %}\n@@ -8685,1 +8629,0 @@\n-\n@@ -8687,2 +8630,3 @@\n-  opcode(0xD3, 0x7); \/* D3 \/7 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sarl($dst$$Register);\n+  %}\n@@ -8699,2 +8643,3 @@\n-  opcode(0xD3, 0x7); \/* D3 \/7 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sarl($dst$$Address);\n+  %}\n@@ -8786,2 +8731,3 @@\n-  opcode(0xD1, 0x4); \/* D1 \/4 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n@@ -8798,2 +8744,3 @@\n-  opcode(0xD1, 0x4); \/* D1 \/4 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ salq($dst$$Address, $shift$$constant);\n+  %}\n@@ -8810,2 +8757,3 @@\n-  opcode(0xC1, 0x4); \/* C1 \/4 ib *\/\n-  ins_encode(reg_opc_imm_wide(dst, shift));\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n@@ -8822,3 +8770,3 @@\n-  opcode(0xC1, 0x4); \/* C1 \/4 ib *\/\n-  ins_encode(REX_mem_wide(dst), OpcP,\n-             RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ salq($dst$$Address, $shift$$constant);\n+  %}\n@@ -8835,2 +8783,3 @@\n-  opcode(0xD3, 0x4); \/* D3 \/4 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ salq($dst$$Register);\n+  %}\n@@ -8847,2 +8796,3 @@\n-  opcode(0xD3, 0x4); \/* D3 \/4 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ salq($dst$$Address);\n+  %}\n@@ -8861,1 +8811,1 @@\n-  }\n+  %}\n@@ -8872,2 +8822,3 @@\n-  opcode(0xD1, 0x7); \/* D1 \/7 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sarq($dst$$Address, $shift$$constant);\n+  %}\n@@ -8897,3 +8848,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(REX_mem_wide(dst), OpcP,\n-             RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ sarq($dst$$Address, $shift$$constant);\n+  %}\n@@ -8910,2 +8861,3 @@\n-  opcode(0xD3, 0x7); \/* D3 \/7 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sarq($dst$$Register);\n+  %}\n@@ -8922,2 +8874,3 @@\n-  opcode(0xD3, 0x7); \/* D3 \/7 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sarq($dst$$Address);\n+  %}\n@@ -8936,1 +8889,1 @@\n-  }\n+  %}\n@@ -8961,1 +8914,1 @@\n-  }\n+  %}\n@@ -10032,1 +9985,1 @@\n-  __ sarl($dst$$Register, 31);\n+    __ sarl($dst$$Register, 31);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":151,"deletions":198,"binary":false,"changes":349,"status":"modified"}]}