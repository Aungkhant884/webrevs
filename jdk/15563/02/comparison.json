{"files":[{"patch":"@@ -108,0 +108,1 @@\n+        --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.runtime;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import jdk.internal.misc.Unsafe;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * The purpose of these microbenchmarks is to get the overhead of NMT in disable\/summary\/detail mode.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+public abstract class NMTBenchmark {\n+  static final int S = 1024;\n+\n+  Unsafe unsafe;\n+  long addresses[];\n+\n+  \/\/@Param({\"100000\", \"1000000\"})\n+  @Param({\"100000\"})\n+  public int N;\n+\n+  @Param({\"0\", \"4\"})\n+  public int THREADS;\n+\n+  \/\/ Each TestThread instance allocates\/frees a portion (`start` to `end`) of the `addresses` array.\n+  \/\/ The thread index and a flag for doing allocate or freeing it are sent to the constructor.\n+  private class TestThread extends Thread {\n+    private int thr_index;\n+    private int count;\n+    private int start, end;\n+    private boolean allocate;\n+\n+    public TestThread(int index, boolean alloc_or_free) {\n+      thr_index = index;\n+      count = N \/ THREADS;\n+      start = thr_index * count;\n+      end = start + count;\n+      allocate = alloc_or_free;\n+    }\n+\n+    public void run() {\n+      for (int i = start; i < end; i++) {\n+        if (allocate) {\n+          alloc(i);\n+        } else {\n+          deallocate(i);\n+        }\n+      }\n+    }\n+\n+    \/\/ make a deeper and different stack trace\n+    \/\/ NMT uses hash of stack trace to store them in a static table.\n+    \/\/ So, if all allocations come from the same call-site, they all hashed into one entry in that table.\n+    private void alloc(int i) {\n+      if (i % 3 == 0) alloc0(i);\n+      if (i % 3 == 1) alloc1(i);\n+      if (i % 3 == 2) alloc2(i);\n+    }\n+    private void alloc0(int i) {\n+      if (unsafe == null) return;\n+      addresses[i] = unsafe.allocateMemory(S);\n+    }\n+    private void alloc1(int i) { alloc0(i); }\n+    private void alloc2(int i) { alloc1(i); }\n+\n+    private void deallocate(int i) {\n+      if (unsafe == null)\n+        return;\n+\n+      if (addresses[i] != 0) {\n+        unsafe.freeMemory(addresses[i]);\n+        addresses[i] = 0;\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void mixAallocateFreeMemory(Blackhole bh) throws InterruptedException{\n+\n+    Unsafe unsafe = Unsafe.getUnsafe();\n+    if (unsafe == null) {\n+      throw new InterruptedException();\n+    }\n+\n+    addresses = new long[N];\n+    if (THREADS != 0) { \/\/ Multi-threaded\n+      TestThread threads[] = new TestThread[THREADS];\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        \/\/ One half of threads allocate and the other half free the memory\n+        threads[t] = new TestThread(t, t < (THREADS \/ 2) ? true : false);\n+        threads[t].start();\n+      }\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        try {\n+          threads[t].join();\n+        } catch (InterruptedException ie) {\n+          \/\/ do nothing\n+        }\n+      }\n+    } else { \/\/ No threads used.\n+\n+      for (int i = 0; i < N; i++) {\n+        addresses[i] = unsafe.allocateMemory(S);\n+        \/\/Mixing alloc\/free\n+        if (i % 3 == 0) {\n+          if (addresses[i] != 0) {\n+            unsafe.freeMemory(addresses[i]);\n+            addresses[i] = 0;\n+          }\n+        }\n+      }\n+\n+      for (int i = 0; i < N; i++) {\n+        if (i % 2 == 0) {\n+            if (addresses[i] != 0) {\n+              unsafe.freeMemory(addresses[i]);\n+              addresses[i] = 0;\n+            }\n+        }\n+      }\n+\n+      \/\/ free the rest of allocations\n+      for (int i = 0; i < N; i++) {\n+        if (addresses[i] != 0) {\n+          unsafe.freeMemory(addresses[i]);\n+          addresses[i] = 0;\n+        }\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void onlyAllocateMemory() throws InterruptedException {\n+    Unsafe unsafe = Unsafe.getUnsafe();\n+    if (unsafe == null) {\n+      throw new InterruptedException();\n+    }\n+\n+    addresses = new long[N];\n+    if (THREADS != 0) { \/\/ Multi-threaded\n+      TestThread threads[] = new TestThread[THREADS];\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        \/\/ One half of threads allocate and the other half free the memory\n+        threads[t] = new TestThread(t, t < (THREADS \/ 2) ? true : false);\n+        threads[t].start();\n+      }\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        try {\n+          threads[t].join();\n+        } catch (InterruptedException ie) {\n+          \/\/ do nothing\n+        }\n+      }\n+    } else { \/\/ No threads used.\n+      for (int i = 0; i < N; i++) {\n+        addresses[i] = unsafe.allocateMemory(S);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void mixAllocateReallocateMemory() throws InterruptedException {\n+    Unsafe unsafe = Unsafe.getUnsafe();\n+    if (unsafe == null) {\n+      throw new InterruptedException();\n+    }\n+\n+    addresses = new long[N];\n+    if (THREADS != 0) { \/\/ Multi-threaded\n+      TestThread threads[] = new TestThread[THREADS];\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        \/\/ One half of threads allocate and the other half free the memory\n+        threads[t] = new TestThread(t, t < (THREADS \/ 2) ? true : false);\n+        threads[t].start();\n+      }\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        try {\n+          threads[t].join();\n+        } catch (InterruptedException ie) {\n+          \/\/ do nothing\n+        }\n+      }\n+    } else { \/\/ No threads used.\n+      for (int i = 0; i < N; i++) {\n+        addresses[i] = unsafe.allocateMemory(S);\n+        \/\/Mixing alloc\/realloc\n+        if (i % 3 == 0) {\n+          if (addresses[i] != 0) {\n+            unsafe.reallocateMemory(addresses[i], S * 2);\n+            addresses[i] = 0;\n+          }\n+        }\n+      }\n+\n+      for (int i = 0; i < N; i++) {\n+        if (i % 2 == 0) {\n+            if (addresses[i] != 0) {\n+              unsafe.reallocateMemory(addresses[i], S \/ 2);\n+              addresses[i] = 0;\n+            }\n+        }\n+      }\n+    }\n+  }\n+\n+  public static final String ADD_EXPORTS = \"--add-exports\";\n+  public static final String MISC_PACKAGE = \"java.base\/jdk.internal.misc=ALL-UNNAMED\"; \/\/ used for Unsafe API\n+\n+  @Fork(value = 2, jvmArgsPrepend = { \"-XX:NativeMemoryTracking=off\", ADD_EXPORTS, MISC_PACKAGE})\n+  public static class NMTOff extends NMTBenchmark { }\n+\n+  @Fork(value = 2, jvmArgsPrepend = { \"-XX:NativeMemoryTracking=summary\", ADD_EXPORTS, MISC_PACKAGE})\n+  public static class NMTSummary extends NMTBenchmark { }\n+\n+  @Fork(value = 2, jvmArgsPrepend = { \"-XX:NativeMemoryTracking=detail\", ADD_EXPORTS, MISC_PACKAGE})\n+  public static class NMTDetail extends NMTBenchmark { }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/runtime\/NMTBenchmark.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"}]}