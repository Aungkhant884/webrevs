{"files":[{"patch":"@@ -4107,7 +4107,0 @@\n-  \/\/ Number of stack slots between incoming argument block and the start of\n-  \/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n-  \/\/ EPILOG must remove this many slots. aarch64 needs two slots for\n-  \/\/ return address and fp.\n-  \/\/ TODO think this is correct but check\n-  in_preserve_stack_slots(4);\n-\n@@ -4132,19 +4125,0 @@\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots.  Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count.  Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE.  Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-\n-  calling_convention\n-  %{\n-    \/\/ No difference between ingoing\/outgoing just pass false\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-  c_calling_convention\n-  %{\n-    \/\/ This is obviously always outgoing\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, NULL, length);\n-  %}\n-\n@@ -12409,1 +12383,1 @@\n- \n+\n@@ -12716,1 +12690,1 @@\n-\/\/ Rotations \n+\/\/ Rotations\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-  SharedRuntime::java_calling_convention(signature, args, 5, true);\n+  SharedRuntime::java_calling_convention(signature, args, 5);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-  SharedRuntime::java_calling_convention(&sig_bt, &regs, 1, true);\n+  SharedRuntime::java_calling_convention(&sig_bt, &regs, 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FrameMap_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,2 +279,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -2525,0 +2524,9 @@\n+\/\/ Number of stack slots between incoming argument block and the start of\n+\/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n+\/\/ EPILOG must remove this many slots. aarch64 needs two slots for\n+\/\/ return address and fp.\n+\/\/ TODO think this is correct but check\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return 4;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1681,6 +1681,0 @@\n-  \/\/ Number of stack slots between incoming argument block and the start of\n-  \/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n-  \/\/ EPILOG must remove this many slots.\n-  \/\/ FP + LR\n-  in_preserve_stack_slots(2 * VMRegImpl::slots_per_word);\n-\n@@ -1703,16 +1697,0 @@\n-  \/\/ Body of function which returns an OptoRegs array locating\n-  \/\/ arguments either in registers or in stack slots for calling\n-  \/\/ java\n-  calling_convention %{\n-    (void) SharedRuntime::java_calling_convention(sig_bt, regs, length, is_outgoing);\n-\n-  %}\n-\n-  \/\/ Body of function which returns an OptoRegs array locating\n-  \/\/ arguments either in registers or in stack slots for callin\n-  \/\/ C.\n-  c_calling_convention %{\n-    \/\/ This is obviously always outgoing\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -424,1 +424,1 @@\n-  SharedRuntime::java_calling_convention(signature, args, 5, true);\n+  SharedRuntime::java_calling_convention(signature, args, 5);\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -367,2 +367,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -373,1 +372,0 @@\n-  (void) is_outgoing;\n@@ -1374,0 +1372,8 @@\n+\/\/ Number of stack slots between incoming argument block and the start of\n+\/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n+\/\/ EPILOG must remove this many slots.\n+\/\/ FP + LR\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return 2 * VMRegImpl::slots_per_word;\n+}\n+\n@@ -1378,1 +1384,0 @@\n-\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3856,2 +3856,0 @@\n-  in_preserve_stack_slots((frame::jit_in_preserve_size \/ VMRegImpl::stack_slot_size));\n-\n@@ -3882,34 +3880,0 @@\n-  \/\/ This is the body of the function\n-  \/\/\n-  \/\/ void Matcher::calling_convention(OptoRegPair* sig, \/\/ array of ideal regs\n-  \/\/                                  uint length,      \/\/ length of array\n-  \/\/                                  bool is_outgoing)\n-  \/\/\n-  \/\/ The `sig' array is to be updated. sig[j] represents the location\n-  \/\/ of the j-th argument, either a register or a stack slot.\n-\n-  \/\/ Comment taken from x86_32.ad:\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots. Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count. Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE. Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  calling_convention %{\n-    \/\/ No difference between ingoing\/outgoing. Just pass false.\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-  \/\/ Comment taken from x86_32.ad:\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots. Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count. Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE. Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  c_calling_convention %{\n-    \/\/ This is obviously always outgoing.\n-    \/\/ C argument in register AND stack slot.\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -636,2 +636,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -2514,0 +2513,4 @@\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return frame::jit_in_preserve_size \/ VMRegImpl::stack_slot_size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2457,2 +2457,0 @@\n-  in_preserve_stack_slots(frame::jit_in_preserve_size_in_4_byte_units);\n-\n@@ -2473,32 +2471,0 @@\n-  \/\/ This is the body of the function\n-  \/\/\n-  \/\/ void Matcher::calling_convention(OptoRegPair* sig \/* array of ideal regs *\/,\n-  \/\/                                  uint length      \/* length of array *\/,\n-  \/\/                                  bool is_outgoing)\n-  \/\/\n-  \/\/ The `sig' array is to be updated. Sig[j] represents the location\n-  \/\/ of the j-th argument, either a register or a stack slot.\n-\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots. Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count. Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE. Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  calling_convention %{\n-    \/\/ No difference between ingoing\/outgoing just pass false.\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots. Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count. Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE. Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  c_calling_convention %{\n-    \/\/ This is obviously always outgoing.\n-    \/\/ C argument must be in register AND stack slot.\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -652,2 +652,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -2582,0 +2581,4 @@\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return frame::jit_in_preserve_size_in_4_byte_units;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -512,1 +512,1 @@\n-  SharedRuntime::java_calling_convention(signature, args, 5, true);\n+  SharedRuntime::java_calling_convention(signature, args, 5);\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-  SharedRuntime::java_calling_convention(&sig_bt, &regs, 1, true);\n+  SharedRuntime::java_calling_convention(&sig_bt, &regs, 1);\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -421,2 +421,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -2202,0 +2201,8 @@\n+\/\/ Number of stack slots between incoming argument block and the start of\n+\/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n+\/\/ EPILOG must remove this many slots.  Intel needs one slot for\n+\/\/ return address and one for rbp, (must save rbp)\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return 2+VerifyStackAtCalls;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -454,2 +454,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -2595,0 +2594,9 @@\n+\n+\/\/ Number of stack slots between incoming argument block and the start of\n+\/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n+\/\/ EPILOG must remove this many slots.  amd64 needs two slots for\n+\/\/ return address.\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return 4 + 2 * VerifyStackAtCalls;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3162,6 +3162,0 @@\n-  \/\/ Number of stack slots between incoming argument block and the start of\n-  \/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n-  \/\/ EPILOG must remove this many slots.  Intel needs one slot for\n-  \/\/ return address and one for rbp, (must save rbp)\n-  in_preserve_stack_slots(2+VerifyStackAtCalls);\n-\n@@ -3183,23 +3177,0 @@\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots.  Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count.  Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE.  Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  calling_convention %{\n-    \/\/ No difference between ingoing\/outgoing just pass false\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots.  Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count.  Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE.  Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  c_calling_convention %{\n-    \/\/ This is obviously always outgoing\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2759,6 +2759,0 @@\n-  \/\/ Number of stack slots between incoming argument block and the start of\n-  \/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n-  \/\/ EPILOG must remove this many slots.  amd64 needs two slots for\n-  \/\/ return address.\n-  in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);\n-\n@@ -2780,19 +2774,0 @@\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots.  Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count.  Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE.  Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-\n-  calling_convention\n-  %{\n-    \/\/ No difference between ingoing\/outgoing just pass false\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-  c_calling_convention\n-  %{\n-    \/\/ This is obviously always outgoing\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -54,2 +54,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1022,1 +1022,2 @@\n-        preserve_stack_parse(frame);\n+        parse_err(WARN, \"Using obsolete token, in_preserve_stack_slots\");\n+        skipws();\n@@ -1032,1 +1033,2 @@\n-        frame->_calling_convention = calling_convention_parse();\n+        parse_err(WARN, \"Using obsolete token, calling_convention\");\n+        skipws();\n@@ -1044,1 +1046,2 @@\n-        frame->_c_calling_convention = calling_convention_parse();\n+        parse_err(WARN, \"Using obsolete token, c_calling_convention\");\n+        skipws();\n@@ -1075,4 +1078,0 @@\n-  if(frame->_in_preserve_slots == NULL) {\n-    parse_err(SYNERR, \"missing stack slot preservation definition in frame section.\\n\");\n-    return;\n-  }\n@@ -1083,4 +1082,0 @@\n-  if(frame->_calling_convention == NULL) {\n-    parse_err(SYNERR, \"missing calling convention definition in frame section.\\n\");\n-    return;\n-  }\n@@ -1099,3 +1094,0 @@\n-  if(frame->_c_calling_convention == NULL) {\n-    frame->_c_calling_convention = frame->_calling_convention;\n-  }\n@@ -1224,28 +1216,0 @@\n-\/\/------------------------------preserve_stack_parse---------------------------\n-void ADLParser::preserve_stack_parse(FrameForm *frame) {\n-  if(_curchar == '(') {\n-    char *token = get_paren_expr(\"preserve_stack_slots\");\n-    frame->_in_preserve_slots   = token;\n-\n-    if(_curchar != ';') {  \/\/ check for semi-colon\n-      parse_err(SYNERR, \"missing %c in preserve stack slot entry.\\n\", ';');\n-      return;\n-    }\n-    next_char();           \/\/ skip the semi-colon\n-  }\n-  else {\n-    parse_err(SYNERR, \"Missing %c in preserve stack slot entry.\\n\", '(');\n-  }\n-}\n-\n-\/\/------------------------------calling_convention_parse-----------------------\n-char *ADLParser::calling_convention_parse() {\n-  char   *desc = NULL;          \/\/ String representation of calling_convention\n-\n-  skipws();                     \/\/ Skip leading whitespace\n-  if ( (desc = find_cpp_block(\"calling convention block\")) == NULL ) {\n-    parse_err(SYNERR, \"incorrect or missing block for 'calling_convention'.\\n\");\n-  }\n-  return desc;\n-}\n-\n@@ -1254,1 +1218,1 @@\n-  char   *desc = NULL;          \/\/ String representation of calling_convention\n+  char   *desc = NULL;          \/\/ String representation of return_value\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":7,"deletions":43,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -122,2 +122,0 @@\n-  void preserve_stack_parse(FrameForm *frame);\n-  char *calling_convention_parse();\n","filename":"src\/hotspot\/share\/adlc\/adlparse.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -444,1 +444,0 @@\n-  _in_preserve_slots = NULL;\n@@ -446,2 +445,0 @@\n-  _calling_convention = NULL;\n-  _c_calling_convention = NULL;\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -348,1 +348,0 @@\n-  char *_in_preserve_slots;\n@@ -350,2 +349,0 @@\n-  char *_calling_convention;\n-  char *_c_calling_convention;\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4161,6 +4161,0 @@\n-  \/\/ Java Stack Slot Preservation\n-  fprintf(fp_cpp,\"uint Compile::in_preserve_stack_slots() \");\n-  fprintf(fp_cpp,\"{ return %s; }\\n\\n\", _frame->_in_preserve_slots);\n-  \/\/ Top Of Stack Slot Preservation, for both Java and C\n-  fprintf(fp_cpp,\"uint Compile::out_preserve_stack_slots() \");\n-  fprintf(fp_cpp,\"{ return SharedRuntime::out_preserve_stack_slots(); }\\n\\n\");\n@@ -4170,8 +4164,0 @@\n-  \/\/ Java Argument Position\n-  fprintf(fp_cpp,\"void Matcher::calling_convention(BasicType *sig_bt, VMRegPair *regs, uint length, bool is_outgoing) {\\n\");\n-  fprintf(fp_cpp,\"%s\\n\", _frame->_calling_convention);\n-  fprintf(fp_cpp,\"}\\n\\n\");\n-  \/\/ Native Argument Position\n-  fprintf(fp_cpp,\"void Matcher::c_calling_convention(BasicType *sig_bt, VMRegPair *regs, uint length) {\\n\");\n-  fprintf(fp_cpp,\"%s\\n\", _frame->_c_calling_convention);\n-  fprintf(fp_cpp,\"}\\n\\n\");\n@@ -4179,1 +4165,1 @@\n-  fprintf(fp_cpp,\"OptoRegPair Matcher::return_value(uint ideal_reg, bool is_outgoing) {\\n\");\n+  fprintf(fp_cpp,\"OptoRegPair Matcher::return_value(uint ideal_reg) {\\n\");\n@@ -4183,1 +4169,1 @@\n-  fprintf(fp_cpp,\"OptoRegPair Matcher::c_return_value(uint ideal_reg, bool is_outgoing) {\\n\");\n+  fprintf(fp_cpp,\"OptoRegPair Matcher::c_return_value(uint ideal_reg) {\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs, outgoing);\n+  intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3113,1 +3113,1 @@\n-      intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs, false);\n+      intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -68,2 +69,2 @@\n-void StartNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n-  Matcher::calling_convention( sig_bt, parm_regs, argcnt, false );\n+void StartNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {\n+  SharedRuntime::java_calling_convention(sig_bt, parm_regs, argcnt);\n@@ -699,1 +700,1 @@\n-void CallNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n+void CallNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {\n@@ -701,1 +702,1 @@\n-  Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );\n+  SharedRuntime::java_calling_convention(sig_bt, parm_regs, argcnt);\n@@ -723,2 +724,2 @@\n-      ? match->c_return_value(ideal_reg,true)  \/\/ Calls into C runtime\n-      : match->  return_value(ideal_reg,true); \/\/ Calls into compiled Java code\n+      ? match->c_return_value(ideal_reg)  \/\/ Calls into C runtime\n+      : match->  return_value(ideal_reg); \/\/ Calls into compiled Java code\n@@ -1125,2 +1126,2 @@\n-void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n-  Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );\n+void CallRuntimeNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {\n+  SharedRuntime::c_calling_convention(sig_bt, parm_regs, \/*regs2=*\/nullptr, argcnt);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -1036,1 +1037,3 @@\n-  uint in_preserve_stack_slots();\n+  uint in_preserve_stack_slots() {\n+    return SharedRuntime::in_preserve_stack_slots();\n+  }\n@@ -1041,3 +1044,3 @@\n-  \/\/ On Sparc this describes the words reserved for storing a register window\n-  \/\/ when an interrupt occurs.\n-  static uint out_preserve_stack_slots();\n+  static uint out_preserve_stack_slots() {\n+    return SharedRuntime::out_preserve_stack_slots();\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    OptoRegPair regs = return_value(ireg, false);\n+    OptoRegPair regs = return_value(ireg);\n@@ -751,1 +751,1 @@\n-  OptoReg::Name reg = find_receiver(false);\n+  OptoReg::Name reg = find_receiver();\n@@ -1997,1 +1997,1 @@\n-OptoReg::Name Matcher::find_receiver( bool is_outgoing ) {\n+OptoReg::Name Matcher::find_receiver() {\n@@ -2000,1 +2000,1 @@\n-  calling_convention(&sig_bt, &regs, 1, is_outgoing);\n+  SharedRuntime::java_calling_convention(&sig_bt, &regs, 1);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -376,4 +376,0 @@\n-  \/\/ Array mapping arguments to registers.  Argument 0 is usually the 'this'\n-  \/\/ pointer.  Registers can include stack-slots and regular registers.\n-  static void calling_convention( BasicType *, VMRegPair *, uint len, bool is_outgoing );\n-\n@@ -382,1 +378,1 @@\n-  static OptoReg::Name  find_receiver( bool is_outgoing );\n+  static OptoReg::Name  find_receiver();\n@@ -387,3 +383,3 @@\n-  \/\/ Return value register.  On Intel it is EAX.  On Sparc i0\/o0.\n-  static OptoRegPair   return_value(uint ideal_reg, bool is_outgoing);\n-  static OptoRegPair c_return_value(uint ideal_reg, bool is_outgoing);\n+  \/\/ Return value register.  On Intel it is EAX.\n+  static OptoRegPair   return_value(uint ideal_reg);\n+  static OptoRegPair c_return_value(uint ideal_reg);\n@@ -427,3 +423,0 @@\n-  \/\/ Array mapping arguments to registers.  Argument 0 is usually the 'this'\n-  \/\/ pointer.  Registers can include stack-slots and regular registers.\n-  static void c_calling_convention( BasicType*, VMRegPair *, uint );\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1874,2 +1874,1 @@\n-  const bool is_outgoing = method->is_method_handle_intrinsic();\n-  int comp_args_on_stack = java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1, is_outgoing);\n+  int comp_args_on_stack = java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1);\n@@ -2691,1 +2690,1 @@\n-    int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, false);\n+    int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n@@ -2899,5 +2898,2 @@\n-      \/\/ Now get the compiled-Java layout as input (or output) arguments.\n-      \/\/ NOTE: Stubs for compiled entry points of method handle intrinsics\n-      \/\/ are just trampolines so the argument registers must be outgoing ones.\n-      const bool is_outgoing = method->is_method_handle_intrinsic();\n-      int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, is_outgoing);\n+      \/\/ Now get the compiled-Java arguments layout.\n+      int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n@@ -2947,1 +2943,1 @@\n-  (void) java_calling_convention(&sig_bt, &regs, 1, true);\n+  (void) java_calling_convention(&sig_bt, &regs, 1);\n@@ -2978,1 +2974,1 @@\n-  comp_args_on_stack = java_calling_convention(sig_bt, regs, cnt, true);\n+  comp_args_on_stack = java_calling_convention(sig_bt, regs, cnt);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -371,3 +371,1 @@\n-  \/\/ 4-bytes higher. So for sparc because the register window save area is at\n-  \/\/ the bottom of the frame the first 16 words will be skipped and SharedInfo::stack0\n-  \/\/ will be just above it. (\n+  \/\/ 4-bytes higher.\n@@ -375,1 +373,1 @@\n-  static int java_calling_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed, int is_outgoing);\n+  static int java_calling_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed);\n@@ -464,0 +462,5 @@\n+  \/\/ Stack slots that may be unused by the calling convention but must\n+  \/\/ otherwise be preserved.  On Intel this includes the return address.\n+  \/\/ On PowerPC it includes the 4 words holding the old TOC & LR glue.\n+  static uint in_preserve_stack_slots();\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}