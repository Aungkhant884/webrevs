{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,2 @@\n+        pipe = IOPipe.startDebuggerPipe(binder);\n+\n@@ -69,2 +71,0 @@\n-        pipe = new IOPipe(debuggee);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/TestProcessLauncher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        if (cmd.equals(\"quit\")) {\n+        if (\"quit\".equals(cmd)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/process\/TestJavaProcess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import nsk.share.jdi.Binder;\n@@ -45,2 +46,0 @@\n-    private DebugeeProcess debugee;\n-\n@@ -64,1 +63,3 @@\n-      * @deprecated Use Debugee.createIOPipe() instead.\n+      * @deprecated Preferred way is to start IOPipe before launching debuggee process.\n+      *\n+      * @see #startDebuggerPipe\n@@ -73,2 +74,1 @@\n-\n-        this.debugee = debugee;\n+        setServerSocket(debugee.getPipeServerSocket());\n@@ -84,5 +84,13 @@\n-    protected void connect() {\n-        if (listening) {\n-            setServerSocket(debugee.getPipeServerSocket());\n-            setConnectingProcess(debugee.getProcess());\n-        }\n+    \/**\n+     * Creates and starts listening <code>IOPipe<\/code> at debugger side.\n+     *\/\n+    public static IOPipe startDebuggerPipe(Binder binder) {\n+        IOPipe ioPipe = new IOPipe(binder.getLog(),\n+                binder.getArgumentHandler().getDebugeeHost(),\n+                binder.getArgumentHandler().getPipePortNumber(),\n+                (long)binder.getArgumentHandler().getWaitTime() * 60 * 1000,\n+                true);\n+        ioPipe.setServerSocket(binder.getPipeServerSocket());\n+        ioPipe.startListening();\n+        return ioPipe;\n+    }\n@@ -90,0 +98,2 @@\n+\n+    protected void connect() {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/IOPipe.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,0 @@\n-    protected Process connectingProcess = null;\n-\n@@ -260,5 +258,0 @@\n-                    \/\/ check if listening process still alive\n-                    if (!checkConnectingProcess()) {\n-                        shouldStop = true;\n-                        throw new Failure(\"Break attaching to \" + name + \" connection: \" + \"listening process exited\");\n-                    }\n@@ -313,25 +306,0 @@\n-    \/**\n-     * Return true if another connecting process is still alive.\n-     *\/\n-    public boolean checkConnectingProcess() {\n-        if (connectingProcess == null) {\n-            \/\/ no process to check\n-            return true;\n-        }\n-        try {\n-            int exitCode = connectingProcess.exitValue();\n-        } catch (IllegalThreadStateException e) {\n-            \/\/ process is still alive\n-            return true;\n-        }\n-        \/\/ process exited\n-        return false;\n-    }\n-\n-    \/**\n-     * Set another connecting process to control if it is still alive.\n-     *\/\n-    public void setConnectingProcess(Process process) {\n-        connectingProcess = process;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/SocketConnection.java","additions":1,"deletions":33,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,2 +82,0 @@\n-    protected Process connectingProcess;\n-\n@@ -163,4 +161,0 @@\n-    protected void setConnectingProcess(Process connectingProcess) {\n-        this.connectingProcess = connectingProcess;\n-    }\n-\n@@ -210,0 +204,57 @@\n+    protected class ListenerThread extends Thread {\n+        private SocketConnection connection;\n+        private RuntimeException error;\n+\n+        ListenerThread() {\n+            super(\"PipeIO Listener Thread\");\n+            setDaemon(true);\n+\n+            connection = new SocketConnection(SocketIOPipe.this, getName());\n+\n+            if (serverSocket == null) {\n+                connection.bind(port, timeout);\n+            } else {\n+                connection.setServerSocket(serverSocket);\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            synchronized (this) {\n+                try {\n+                    connection.accept(timeout);\n+                } catch (Throwable th) {\n+                    error = th instanceof RuntimeException\n+                            ? (RuntimeException)th\n+                            : new RuntimeException(th);\n+                }\n+                notifyAll();\n+            }\n+        }\n+\n+        public SocketConnection getConnection() {\n+            synchronized (this) {\n+                while (!connection.isConnected() && error != null) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                    }\n+                }\n+                if (error != null) {\n+                    throw error;\n+                }\n+                return connection;\n+            }\n+        }\n+    }\n+\n+    private ListenerThread listenerThread;\n+\n+    protected void startListening() {\n+        if (listenerThread != null) {\n+            throw new TestBug(\"already listening\");\n+        }\n+        listenerThread = new ListenerThread();\n+        listenerThread.start();\n+    }\n+\n@@ -222,2 +273,0 @@\n-        connection = new SocketConnection(this, getName());\n-\n@@ -225,5 +274,6 @@\n-            connection.setConnectingProcess(connectingProcess);\n-            if (serverSocket == null) {\n-                connection.bind(port, timeout);\n-            } else {\n-                connection.setServerSocket(serverSocket);\n+            \/\/ listenerThread == null means the test is not updated yet\n+            \/\/ to start IOPipe listening before launching debuggee.\n+            if (listenerThread == null) {\n+                \/\/ start listening and accept connection on the current thread\n+                listenerThread = new ListenerThread();\n+                listenerThread.run();\n@@ -231,7 +281,1 @@\n-\n-            if (shouldStop)\n-                return;\n-\n-            \/\/ wait for connection from remote host\n-            connection.accept(timeout);\n-\n+            connection = listenerThread.getConnection();\n@@ -239,0 +283,1 @@\n+            connection = new SocketConnection(this, getName());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/SocketIOPipe.java","additions":66,"deletions":21,"binary":false,"changes":87,"status":"modified"}]}