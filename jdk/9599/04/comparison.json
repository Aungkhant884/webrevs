{"files":[{"patch":"@@ -56,0 +56,2 @@\n+TEST_LIB_NATIVE_SRC := $(TOPDIR)\/test\/lib\/native\n+\n@@ -70,10 +72,8 @@\n-  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncStackWalk := \/EHsc\n-  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncInvokers := \/EHsc\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLinkerInvokerUnnamed := \/EHsc\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLinkerInvokerModule := \/EHsc\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLoaderLookupInvoker := \/EHsc\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncStackWalk := $(LIBCXX)\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncInvokers := $(LIBCXX)\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLinkerInvokerUnnamed := $(LIBCXX)\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLinkerInvokerModule := $(LIBCXX)\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLoaderLookupInvoker := $(LIBCXX)\n+\n+  # java.lang.foreign tests\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncStackWalk := -I$(TEST_LIB_NATIVE_SRC)\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libLinkerInvokerUnnamed := -I$(TEST_LIB_NATIVE_SRC)\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libLinkerInvokerModule := -I$(TEST_LIB_NATIVE_SRC)\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libLoaderLookupInvoker := -I$(TEST_LIB_NATIVE_SRC)\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncInvokers := -I$(TEST_LIB_NATIVE_SRC)\n+\n@@ -85,5 +85,13 @@\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncStackWalk := $(LIBCXX) -pthread\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncInvokers := $(LIBCXX) -pthread\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLinkerInvokerUnnamed := $(LIBCXX) -pthread\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLinkerInvokerModule := $(LIBCXX) -pthread\n-  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLoaderLookupInvoker := $(LIBCXX) -pthread\n+\n+  # java.lang.foreign tests\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncStackWalk := -I$(TEST_LIB_NATIVE_SRC)\n+  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncStackWalk := -pthread\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncInvokers := -I$(TEST_LIB_NATIVE_SRC)\n+  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncInvokers := -pthread\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libLinkerInvokerUnnamed := -I$(TEST_LIB_NATIVE_SRC)\n+  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLinkerInvokerUnnamed := -pthread\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libLinkerInvokerModule := -I$(TEST_LIB_NATIVE_SRC)\n+  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLinkerInvokerModule := -pthread\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libLoaderLookupInvoker := -I$(TEST_LIB_NATIVE_SRC)\n+  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libLoaderLookupInvoker := -pthread\n+\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include <thread>\n+#include \"testlib_threads.h\"\n@@ -28,1 +28,2 @@\n-void call(JavaVM *jvm) {\n+void call(void* ctxt) {\n+    JavaVM* jvm = (JavaVM*) ctxt;\n@@ -42,2 +43,1 @@\n-        std::thread thrd(call, jvm);\n-        thrd.join();\n+        run_in_new_thread_and_join(call, jvm);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/libLinkerInvokerUnnamed.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include <thread>\n+#include \"testlib_threads.h\"\n@@ -28,1 +28,2 @@\n-void call(JavaVM *jvm) {\n+void call(void* ctxt) {\n+    JavaVM *jvm = (JavaVM*) ctxt;\n@@ -42,2 +43,1 @@\n-        std::thread thrd(call, jvm);\n-        thrd.join();\n+        run_in_new_thread_and_join(call, jvm);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-#include <thread>\n+#include \"testlib_threads.h\"\n@@ -28,0 +28,5 @@\n+template<typename CB>\n+void proc_v(void* v_cb) {\n+    ((CB) v_cb)();\n+}\n+\n@@ -30,2 +35,1 @@\n-    std::thread thrd(cb);\n-    thrd.join();\n+    run_in_new_thread_and_join(&proc_v<CB>, (void*) cb);\n@@ -35,2 +39,9 @@\n-void start(O& out, CB cb) {\n-    out = cb();\n+struct Context {\n+    CB cb;\n+    O o;\n+};\n+\n+template<typename O, typename CB>\n+void proc(void* context) {\n+    Context<O, CB>* ctxt = (Context<O, CB>*) context;\n+    ctxt->o = ctxt->cb();\n@@ -41,4 +52,6 @@\n-    O result;\n-    std::thread thrd(&start<O, CB>, std::ref(result), cb);\n-    thrd.join();\n-    return result;\n+    Context<O, CB> ctxt;\n+    ctxt.cb = cb;\n+\n+    run_in_new_thread_and_join(&proc<O, CB>, &ctxt);\n+\n+    return ctxt.o;\n","filename":"test\/jdk\/java\/foreign\/libAsyncInvokers.cpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include <thread>\n+#include \"testlib_threads.h\"\n@@ -28,1 +28,4 @@\n-jobject res;\n+struct Context {\n+    JavaVM* jvm;\n+    jobject res;\n+};\n@@ -30,1 +33,2 @@\n-jobject call(JavaVM *jvm) {\n+void call(void* ctxt) {\n+    Context* context = (Context*) ctxt;\n@@ -32,1 +36,1 @@\n-    jvm->AttachCurrentThread((void**)&env, NULL);\n+    context->jvm->AttachCurrentThread((void**)&env, NULL);\n@@ -35,3 +39,2 @@\n-    res = env->NewGlobalRef(env->CallStaticObjectMethod(symbolLookupClass, loaderLookupMethod));\n-    jvm->DetachCurrentThread();\n-    return res;\n+    context->res = env->NewGlobalRef(env->CallStaticObjectMethod(symbolLookupClass, loaderLookupMethod));\n+    context->jvm->DetachCurrentThread();\n@@ -45,3 +48,4 @@\n-        std::thread thrd(call, jvm);\n-        thrd.join();\n-        return res;\n+        Context context;\n+        context.jvm = jvm;\n+        run_in_new_thread_and_join(call, &context);\n+        return context.res;\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/libLoaderLookupInvoker.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include <thread>\n+#include \"testlib_threads.h\"\n@@ -33,1 +33,4 @@\n-static void start(void (*cb)(void)) {\n+typedef void (*CB_t)(void);\n+\n+static void start(void* ctxt) {\n+    CB_t cb = (CB_t) ctxt;\n@@ -40,3 +43,2 @@\n-EXPORT void asyncStackWalk(void (*cb)(void)) {\n-    std::thread thrd(start, cb);\n-    thrd.join();\n+EXPORT void asyncStackWalk(CB_t cb) {\n+    run_in_new_thread_and_join(start, (void*) cb);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/libAsyncStackWalk.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef TEST_LIB_NATIVE_THREAD_H\n+#define TEST_LIB_NATIVE_THREAD_H\n+\n+\/\/ Header only library for using threads in tests\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#ifdef _WIN32\n+#include <windows.h>\n+#else\n+#include <unistd.h>\n+#include <pthread.h>\n+#endif\n+\n+extern \"C\" {\n+\n+typedef void(*PROCEDURE)(void*);\n+\n+struct Helper {\n+    PROCEDURE proc;\n+    void* context;\n+};\n+\n+static void fatal(const char* message, int code) {\n+    fputs(message, stderr);\n+    \/\/ exit the test with a non-zero exit code to avoid accidental false positives\n+    exit(code);\n+}\n+\n+\/\/ Adapt from the callback type the OS API expects to\n+\/\/ our OS-independent PROCEDURE type.\n+#ifdef _WIN32\n+static DWORD procedure(_In_ LPVOID ctxt) {\n+#else\n+void* procedure(void* ctxt) {\n+#endif\n+    Helper* helper = (Helper*)ctxt;\n+    helper->proc(helper->context);\n+    return 0;\n+}\n+\n+\/\/ Run 'proc' in a newly started thread, passing 'context' to it\n+\/\/ as an argument, and then join that thread.\n+void run_in_new_thread_and_join(PROCEDURE proc, void* context) {\n+    struct Helper helper;\n+    helper.proc = proc;\n+    helper.context = context;\n+#ifdef _WIN32\n+    HANDLE thread = CreateThread(NULL, 0, procedure, &helper, 0, NULL);\n+    if (thread == NULL) {\n+        fatal(\"failed to create thread\", GetLastError());\n+    }\n+    if (WaitForSingleObject(thread, INFINITE) != WAIT_OBJECT_0) {\n+        \/\/ Should be WAIT_FAILED, since this is not a mutex, and\n+        \/\/ we set no timeout.\n+        fatal(\"failed to join thread\", GetLastError());\n+    }\n+#else\n+    pthread_t thread;\n+    int result = pthread_create(&thread, NULL, procedure, &helper);\n+    if (result != 0) {\n+        fatal(\"failed to create thread\", result);\n+    }\n+    result = pthread_join(thread, NULL);\n+    if (result != 0) {\n+        fatal(\"failed to join thread\", result);\n+    }\n+#endif\n+}\n+\n+}\n+\n+#endif \/\/ TEST_LIB_NATIVE_THREAD_H\n","filename":"test\/lib\/native\/testlib_threads.h","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}