{"files":[{"patch":"@@ -43,1 +43,1 @@\n-        run_async(call, jvm);\n+        run_in_new_thread(call, jvm);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/libLinkerInvokerUnnamed.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        run_async(call, jvm);\n+        run_in_new_thread(call, jvm);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    run_async(&proc_v<CB>, (void*) cb);\n+    run_in_new_thread(&proc_v<CB>, (void*) cb);\n@@ -55,1 +55,1 @@\n-    run_async(&proc<O, CB>, &ctxt);\n+    run_in_new_thread(&proc<O, CB>, &ctxt);\n","filename":"test\/jdk\/java\/foreign\/libAsyncInvokers.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        run_async(call, &context);\n+        run_in_new_thread(call, &context);\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/libLoaderLookupInvoker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    run_async(start, (void*) cb);\n+    run_in_new_thread(start, (void*) cb);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/libAsyncStackWalk.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,3 +48,4 @@\n-static void fatal(const char* message) {\n-    perror(message);\n-    exit(-1);\n+static void fatal(const char* message, int code) {\n+    fputs(message, stderr);\n+    \/\/ exit the test with a non-zero exit code to avoid accidental false positives\n+    exit(code);\n@@ -53,0 +54,2 @@\n+\/\/ Adapt from the callback type the OS API expects to\n+\/\/ our OS-independent PROCEDURE type.\n@@ -54,1 +57,1 @@\n-static DWORD __stdcall procedure(void* ctxt) {\n+static DWORD procedure(_In_ LPVOID ctxt) {\n@@ -63,1 +66,3 @@\n-void run_async(PROCEDURE proc, void* context) {\n+\/\/ Run 'proc' in a newly started thread, passing 'context' to it\n+\/\/ as an argument, and then join that thread.\n+void run_in_new_thread(PROCEDURE proc, void* context) {\n@@ -70,1 +75,1 @@\n-        fatal(\"failed to create thread\");\n+        fatal(\"failed to create thread\", GetLastError());\n@@ -73,1 +78,1 @@\n-        fatal(\"failed to join thread\");\n+        fatal(\"failed to join thread\", GetLastError());\n@@ -79,1 +84,1 @@\n-        fatal(\"failed to create thread\");\n+        fatal(\"failed to create thread\", result);\n@@ -81,2 +86,3 @@\n-    if (pthread_join(thread, NULL) != 0) {\n-        fatal(\"failed to join thread\");\n+    result = pthread_join(thread, NULL);\n+    if (result != 0) {\n+        fatal(\"failed to join thread\", result);\n","filename":"test\/lib\/native\/testlib_threads.h","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"}]}