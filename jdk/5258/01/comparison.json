{"files":[{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.ref.WeakReference;\n@@ -366,3 +365,1 @@\n-            if (UNSAFE.shouldBeInitialized(cls)) {\n-                UNSAFE.ensureClassInitialized(cls);\n-            }\n+            UNSAFE.ensureClassInitialized(cls);\n@@ -374,13 +371,0 @@\n-    private static class EnsureInitialized extends ClassValue<WeakReference<Thread>> {\n-        @Override\n-        protected WeakReference<Thread> computeValue(Class<?> type) {\n-            UNSAFE.ensureClassInitialized(type);\n-            if (UNSAFE.shouldBeInitialized(type))\n-                \/\/ If the previous call didn't block, this can happen.\n-                \/\/ We are executing inside <clinit>.\n-                return new WeakReference<>(Thread.currentThread());\n-            return null;\n-        }\n-        static final EnsureInitialized INSTANCE = new EnsureInitialized();\n-    }\n-\n@@ -400,18 +384,6 @@\n-        WeakReference<Thread> ref = EnsureInitialized.INSTANCE.get(defc);\n-        if (ref == null) {\n-            return true;  \/\/ the final state\n-        }\n-        \/\/ Somebody may still be running defc.<clinit>.\n-        if (ref.refersTo(Thread.currentThread())) {\n-            \/\/ If anybody is running defc.<clinit>, it is this thread.\n-            if (UNSAFE.shouldBeInitialized(defc))\n-                \/\/ Yes, we are running it; keep the barrier for now.\n-                return false;\n-        } else {\n-            \/\/ We are in a random thread.  Block.\n-            UNSAFE.ensureClassInitialized(defc);\n-        }\n-        assert(!UNSAFE.shouldBeInitialized(defc));\n-        \/\/ put it into the final state\n-        EnsureInitialized.INSTANCE.remove(defc);\n-        return true;\n+        UNSAFE.ensureClassInitialized(defc);\n+        \/\/ Once we get here either defc was fully initialized by another thread, or\n+        \/\/ defc was already being initialized by the current thread. In the latter case\n+        \/\/ the barrier must remain. We can detect this simply by checking if initialization\n+        \/\/ is still needed.\n+        return !UNSAFE.shouldBeInitialized(defc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":7,"deletions":35,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1146,3 +1146,7 @@\n-     * Ensures the given class has been initialized. This is often\n-     * needed in conjunction with obtaining the static field base of a\n-     * class.\n+     * Ensures the given class has been initialized (see JVMS-5.5 for details).\n+     * This is often needed in conjunction with obtaining the static field base\n+     * of a class.\n+     *\n+     * The call returns when either class {@code c} is fully initialized or\n+     * class {@code c} is being initialized and the call is performed from\n+     * the initializing thread.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}