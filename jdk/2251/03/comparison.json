{"files":[{"patch":"@@ -50,0 +50,11 @@\n+\n+static const char* get_signal_name(int sig, char* out, size_t outlen);\n+\n+\/\/ Returns address of a handler associated with the given sigaction\n+static address get_signal_handler(const struct sigaction* action);\n+\n+#define HANDLER_IS(handler, address)    ((handler) == CAST_FROM_FN_PTR(void*, (address)))\n+#define HANDLER_IS_IGN(handler)         (HANDLER_IS(handler, SIG_IGN))\n+#define HANDLER_IS_DFL(handler)         (HANDLER_IS(handler, SIG_DFL))\n+#define HANDLER_IS_IGN_OR_DFL(handler)  (HANDLER_IS_IGN(handler) || HANDLER_IS_DFL(handler))\n+\n@@ -79,3 +90,50 @@\n-\/\/ For diagnostics to print a message once. see run_periodic_checks\n-static sigset_t check_signal_done;\n-static bool check_signals = true;\n+\/\/ At various places we store handler information for each installed handler.\n+\/\/  SavedSignalHandlers is a helper class for those cases, keeping an array of sigaction\n+\/\/  structures.\n+class SavedSignalHandlers {\n+  \/\/ Note: NSIG can be largish, depending on platform, and this array is expected\n+  \/\/ to be sparsely populated. To save space the contained structures are\n+  \/\/ C-heap allocated. Since they only get added outside of signal handling\n+  \/\/ this is no problem.\n+  struct sigaction* _sa[NSIG];\n+\n+  bool check_signal_number(int sig) const {\n+    assert(sig > 0 && sig < NSIG, \"invalid signal number %d\", sig);\n+    return sig > 0 && sig < NSIG;\n+  }\n+\n+public:\n+\n+  SavedSignalHandlers() {\n+    ::memset(_sa, 0, sizeof(_sa));\n+  }\n+\n+  ~SavedSignalHandlers() {\n+    for (int i = 0; i < NSIG; i ++) {\n+      FREE_C_HEAP_OBJ(_sa[i]);\n+    }\n+  }\n+\n+  void set(int sig, const struct sigaction* act) {\n+    if (check_signal_number(sig)) {\n+      assert(_sa[sig] == NULL, \"Overwriting signal handler?\");\n+      _sa[sig] = NEW_C_HEAP_OBJ(struct sigaction, mtInternal);\n+      *_sa[sig] = *act;\n+    }\n+  }\n+\n+  void clear(int sig) {\n+    if (check_signal_number(sig)) {\n+      FREE_C_HEAP_OBJ(_sa[sig]);\n+      _sa[sig] = NULL;\n+    }\n+  }\n+\n+  const struct sigaction* get(int sig) const {\n+    if (check_signal_number(sig)) {\n+      return _sa[sig];\n+    }\n+    return NULL;\n+  }\n+};\n+\n@@ -85,1 +143,0 @@\n-struct sigaction sigact[NSIG];\n@@ -87,1 +144,11 @@\n-\/\/ For signal-chaining\n+\/\/ For CheckJNI:\n+\/\/  Our own hotspot signal handlers should never ever get replaced by a third\n+\/\/  party one. To check that, store a copy of the handler setup and compare it\n+\/\/  periodically against reality (see os::run_periodic_checks()).\n+static bool check_signals = true;\n+static SavedSignalHandlers expected_handlers;\n+\n+\/\/ For signal-chaining:\n+\/\/  if chaining is active, chained_handlers contains all handlers which we\n+\/\/  replaced with our own and to which we must delegate.\n+static SavedSignalHandlers chained_handlers;\n@@ -92,3 +159,0 @@\n-\/\/ For diagnostic\n-int sigflags[NSIG];\n-\n@@ -273,2 +337,0 @@\n-static const char* get_signal_name(int sig, char* out, size_t outlen);\n-\n@@ -338,13 +400,0 @@\n-static struct sigaction* get_preinstalled_handler(int sig) {\n-  if (sigismember(&preinstalled_sigs, sig)) {\n-    return &sigact[sig];\n-  }\n-  return NULL;\n-}\n-\n-static void save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigact[sig] = oldAct;\n-  sigaddset(&preinstalled_sigs, sig);\n-}\n-\n@@ -360,1 +409,1 @@\n-    actp = get_preinstalled_handler(sig);\n+    actp = const_cast<struct sigaction*>(chained_handlers.get(sig));\n@@ -739,12 +788,0 @@\n-static int get_our_sigflags(int sig) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  return sigflags[sig];\n-}\n-\n-static void set_our_sigflags(int sig, int flags) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  if (sig > 0 && sig < NSIG) {\n-    sigflags[sig] = flags;\n-  }\n-}\n-\n@@ -766,0 +803,2 @@\n+\/\/ If we installed one of our signal handlers for sig, check that the current\n+\/\/  setup matches what we originally installed.\n@@ -768,1 +807,1 @@\n-  address jvmHandler = NULL;\n+  bool mismatch = false;\n@@ -770,0 +809,8 @@\n+  \/\/ Retrieve expected signal setup. If there is none we either had no handler installed\n+  \/\/ in the first place or had a mismatch already; in both cases, nothing to do here.\n+  const struct sigaction* expected_act = expected_handlers.get(sig);\n+  if (expected_act == NULL) {\n+    return;\n+  }\n+\n+  \/\/ Retrieve current signal setup.\n@@ -780,30 +827,1 @@\n-  \/\/ See comment for SA_RESTORER_FLAG_MASK\n-  LINUX_ONLY(act.sa_flags &= SA_RESTORER_FLAG_MASK;)\n-\n-  address thisHandler = get_signal_handler(&act);\n-\n-  switch (sig) {\n-  case SIGSEGV:\n-  case SIGBUS:\n-  case SIGFPE:\n-  case SIGPIPE:\n-  case SIGILL:\n-  case SIGXFSZ:\n-    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler);\n-    break;\n-\n-  case SHUTDOWN1_SIGNAL:\n-  case SHUTDOWN2_SIGNAL:\n-  case SHUTDOWN3_SIGNAL:\n-  case BREAK_SIGNAL:\n-    jvmHandler = (address)os::user_handler();\n-    break;\n-\n-  default:\n-    if (sig == PosixSignals::SR_signum) {\n-      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n-    } else {\n-      return;\n-    }\n-    break;\n-  }\n+  \/\/ Compare both sigaction structures (intelligently; only the members we care about).\n@@ -811,1 +829,5 @@\n-  if (thisHandler != jvmHandler) {\n+  \/\/ Check handler\n+  address this_handler = get_signal_handler(&act);\n+  address expected_handler = get_signal_handler(expected_act);\n+  if (this_handler != expected_handler) {\n+    mismatch = true;\n@@ -814,1 +836,1 @@\n-    print_signal_handler_name(tty, jvmHandler, buf, O_BUFLEN);\n+    print_signal_handler_name(tty, expected_handler, buf, O_BUFLEN);\n@@ -816,3 +838,2 @@\n-    print_signal_handler_name(tty, thisHandler, buf, O_BUFLEN);\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n+    print_signal_handler_name(tty, this_handler, buf, O_BUFLEN);\n+    tty->cr();\n@@ -824,1 +845,10 @@\n-  } else if (get_our_sigflags(sig) != 0 && (int)act.sa_flags != get_our_sigflags(sig)) {\n+  }\n+\n+  \/\/ Check flags\n+\n+  \/\/ When comparing, ignore the SA_RESTORER flag on Linux\n+  int this_flags = act.sa_flags;\n+  const int expected_flags = expected_act->sa_flags;\n+  LINUX_ONLY(this_flags &= SA_RESTORER_FLAG_MASK;)\n+  if (this_flags != expected_flags) {\n+    mismatch = true;\n@@ -827,1 +857,1 @@\n-    print_sa_flags(tty, get_our_sigflags(sig));\n+    print_sa_flags(tty, expected_flags);\n@@ -830,1 +860,1 @@\n-    print_sa_flags(tty, act.sa_flags);\n+    print_sa_flags(tty, this_flags);\n@@ -832,2 +862,0 @@\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n@@ -836,2 +864,5 @@\n-  \/\/ Dump all the signal\n-  if (sigismember(&check_signal_done, sig)) {\n+  \/\/ If we had a mismatch:\n+  \/\/ - remove the signal setup from the expected set since we do not need to check again\n+  \/\/ - print all signal handlers for diagnostics\n+  if (mismatch) {\n+    expected_handlers.clear(sig);\n@@ -860,1 +891,1 @@\n-  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n+  return get_signal_handler(&oldSigAct);\n@@ -872,6 +903,0 @@\n-static void do_signal_check(int signal) {\n-  if (!sigismember(&check_signal_done, signal)) {\n-    check_signal_handler(signal);\n-  }\n-}\n-\n@@ -880,1 +905,0 @@\n-\n@@ -889,7 +913,7 @@\n-  do_signal_check(SIGSEGV);\n-  do_signal_check(SIGILL);\n-  do_signal_check(SIGFPE);\n-  do_signal_check(SIGBUS);\n-  do_signal_check(SIGPIPE);\n-  do_signal_check(SIGXFSZ);\n-  PPC64_ONLY(do_signal_check(SIGTRAP);)\n+  check_signal_handler(SIGSEGV);\n+  check_signal_handler(SIGILL);\n+  check_signal_handler(SIGFPE);\n+  check_signal_handler(SIGBUS);\n+  check_signal_handler(SIGPIPE);\n+  check_signal_handler(SIGXFSZ);\n+  PPC64_ONLY(check_signal_handler(SIGTRAP);)\n@@ -900,4 +924,4 @@\n-    do_signal_check(SHUTDOWN1_SIGNAL);\n-    do_signal_check(SHUTDOWN2_SIGNAL);\n-    do_signal_check(SHUTDOWN3_SIGNAL);\n-    do_signal_check(BREAK_SIGNAL);\n+    check_signal_handler(SHUTDOWN1_SIGNAL);\n+    check_signal_handler(SHUTDOWN2_SIGNAL);\n+    check_signal_handler(SHUTDOWN3_SIGNAL);\n+    check_signal_handler(BREAK_SIGNAL);\n@@ -906,1 +930,1 @@\n-  do_signal_check(PosixSignals::SR_signum);\n+  check_signal_handler(PosixSignals::SR_signum);\n@@ -1206,0 +1230,2 @@\n+  \/\/ Query the current signal handler. Needs to be a separate operation\n+  \/\/ from installing a new handler since we need to honor AllowUserSignalHandlers.\n@@ -1207,3 +1233,2 @@\n-  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)javaSignalHandler)) {\n+  if (!HANDLER_IS_IGN_OR_DFL(oldhand) &&\n+      !HANDLER_IS(oldhand, javaSignalHandler)) {\n@@ -1215,1 +1240,1 @@\n-      save_preinstalled_handler(sig, oldAct);\n+      chained_handlers.set(sig, &oldAct);\n@@ -1242,3 +1267,2 @@\n-  \/\/ Save flags, which are set by ours\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigflags[sig] = sigAct.sa_flags;\n+  \/\/ Save handler setup for later checking\n+  expected_handlers.set(sig, &sigAct);\n@@ -1251,0 +1275,1 @@\n+\n@@ -1349,7 +1374,3 @@\n-void PosixSignals::print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen) {\n-  struct sigaction sa;\n-  sigaction(sig, NULL, &sa);\n-\n-  \/\/ See comment for SA_RESTORER_FLAG_MASK\n-  LINUX_ONLY(sa.sa_flags &= SA_RESTORER_FLAG_MASK;)\n+static void print_single_signal_handler(outputStream* st, int sig,\n+                                        const struct sigaction* act,\n+                                        char* buf, size_t buflen) {\n@@ -1359,3 +1380,2 @@\n-  address handler = get_signal_handler(&sa);\n-\n-  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n+  address handler = get_signal_handler(act);\n+  if (HANDLER_IS_DFL(handler)) {\n@@ -1363,1 +1383,1 @@\n-  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n+  } else if (HANDLER_IS_IGN(handler)) {\n@@ -1366,1 +1386,1 @@\n-    print_signal_handler_name(st, handler, buf, O_BUFLEN);\n+    print_signal_handler_name(st, handler, buf, buflen);\n@@ -1369,2 +1389,2 @@\n-  st->print(\", sa_mask[0]=\");\n-  print_signal_set_short(st, &sa.sa_mask);\n+  st->print(\", mask=\");\n+  print_signal_set_short(st, &(act->sa_mask));\n@@ -1372,7 +1392,7 @@\n-  address rh = VMError::get_resetted_sighandler(sig);\n-  \/\/ May be, handler was resetted by VMError?\n-  if (rh != NULL) {\n-    handler = rh;\n-    \/\/ See comment for SA_RESTORER_FLAG_MASK\n-    sa.sa_flags = VMError::get_resetted_sigflags(sig) LINUX_ONLY(& SA_RESTORER_FLAG_MASK);\n-  }\n+  st->print(\", flags=\");\n+  int flags = act->sa_flags;\n+  \/\/ On Linux, hide the SA_RESTORER flag\n+  LINUX_ONLY(flags &= SA_RESTORER_FLAG_MASK;)\n+  print_sa_flags(st, flags);\n+\n+}\n@@ -1380,3 +1400,12 @@\n-  \/\/ Print textual representation of sa_flags.\n-  st->print(\", sa_flags=\");\n-  print_sa_flags(st, sa.sa_flags);\n+\/\/ Print established signal handler for this signal.\n+\/\/ - if this signal handler was installed by us and is chained to a pre-established user handler\n+\/\/    it replaced, print that one too.\n+\/\/ - otherwise, if this signal handler was installed by us and replaced another handler to which we\n+\/\/    are not chained (e.g. if chaining is off), print that one too.\n+void PosixSignals::print_signal_handler(outputStream* st, int sig,\n+                                        char* buf, size_t buflen) {\n+  struct sigaction current_act;\n+  sigaction(sig, NULL, &current_act);\n+\n+  print_single_signal_handler(st, sig, &current_act, buf, buflen);\n+  st->cr();\n@@ -1384,9 +1413,15 @@\n-  \/\/ Check: is it our handler?\n-  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler) ||\n-      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n-    \/\/ It is our signal handler\n-    \/\/ check for flags, reset system-used one!\n-    if ((int)sa.sa_flags != get_our_sigflags(sig)) {\n-      st->print(\n-                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n-                get_our_sigflags(sig));\n+  \/\/ If we expected to see our own hotspot signal handler but found a different one,\n+  \/\/  print a warning. Unless it had been replaced with our own secondary crash handler.\n+  const struct sigaction* expected_act = expected_handlers.get(sig);\n+  if (expected_act != NULL) {\n+    const address current_handler = get_signal_handler(&current_act);\n+    if (!(HANDLER_IS(current_handler, VMError::crash_handler_address))) {\n+      const address expected_handler = get_signal_handler(expected_act);\n+      if (current_handler != expected_handler) {\n+        st->print_cr(\"  *** Handler changed! Expected hotspot signal handler. Consider using jsig library.\");\n+      }\n+      int this_flag = current_act.sa_flags;\n+      LINUX_ONLY(this_flag &= SA_RESTORER_FLAG_MASK;)\n+      if (this_flag != expected_act->sa_flags) {\n+        st->print_cr(\"  *** Flags changed! Consider using jsig library.\");\n+      }\n@@ -1395,1 +1430,8 @@\n-  st->cr();\n+\n+  \/\/ If there is a chained handler waiting behind the current one, print it too.\n+  const struct sigaction* chained_act = get_chained_signal_action(sig);\n+  if (chained_act != NULL) {\n+    st->print(\"  chained to: \");\n+    print_single_signal_handler(st, sig, &current_act, buf, buflen);\n+    st->cr();\n+  }\n@@ -1424,2 +1466,1 @@\n-  void* ohlr = get_signal_handler(&oact);\n-  if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN)) {\n+  if (HANDLER_IS_IGN(get_signal_handler(&oact))) {\n@@ -1675,2 +1716,3 @@\n-  \/\/ Save signal flag\n-  set_our_sigflags(PosixSignals::SR_signum, act.sa_flags);\n+  \/\/ Save signal setup information for later checking.\n+  expected_handlers.set(PosixSignals::SR_signum, &act);\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":186,"deletions":144,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -52,10 +52,0 @@\n-\/\/ handle all synchronous program error signals which may happen during error\n-\/\/ reporting. They must be unblocked, caught, handled.\n-\n-static const int SIGNALS[] = { SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP }; \/\/ add more if needed\n-static const int NUM_SIGNALS = sizeof(SIGNALS) \/ sizeof(int);\n-\n-\/\/ Space for our \"saved\" signal flags and handlers\n-static int resettedSigflags[NUM_SIGNALS];\n-static address resettedSighandler[NUM_SIGNALS];\n-\n@@ -77,28 +67,0 @@\n-static void save_signal(int idx, int sig)\n-{\n-  struct sigaction sa;\n-  sigaction(sig, NULL, &sa);\n-  resettedSigflags[idx]   = sa.sa_flags;\n-  resettedSighandler[idx] = (sa.sa_flags & SA_SIGINFO)\n-                              ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n-                              : CAST_FROM_FN_PTR(address, sa.sa_handler);\n-}\n-\n-int VMError::get_resetted_sigflags(int sig) {\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    if (SIGNALS[i] == sig) {\n-      return resettedSigflags[i];\n-    }\n-  }\n-  return -1;\n-}\n-\n-address VMError::get_resetted_sighandler(int sig) {\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    if (SIGNALS[i] == sig) {\n-      return resettedSighandler[i];\n-    }\n-  }\n-  return NULL;\n-}\n-\n@@ -136,0 +98,2 @@\n+const void* VMError::crash_handler_address = CAST_FROM_FN_PTR(void *, crash_handler);\n+\n@@ -137,3 +101,6 @@\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    save_signal(i, SIGNALS[i]);\n-    os::signal(SIGNALS[i], CAST_FROM_FN_PTR(void *, crash_handler));\n+  static const int signals_to_handle[] = {\n+    SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP,\n+    0 \/\/ end\n+  };\n+  for (int i = 0; signals_to_handle[i] != 0; i++) {\n+    os::signal(signals_to_handle[i], CAST_FROM_FN_PTR(void *, crash_handler));\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":8,"deletions":41,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -32,8 +32,0 @@\n-int VMError::get_resetted_sigflags(int sig) {\n-  return -1;\n-}\n-\n-address VMError::get_resetted_sighandler(int sig) {\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -163,8 +163,0 @@\n-  \/\/ returns original flags for signal, if it was resetted, or -1 if\n-  \/\/ signal was not changed by error reporter\n-  static int get_resetted_sigflags(int sig);\n-\n-  \/\/ returns original handler for signal, if it was resetted, or NULL if\n-  \/\/ signal was not changed by error reporter\n-  static address get_resetted_sighandler(int sig);\n-\n@@ -188,0 +180,3 @@\n+  \/\/ Needed when printing signal handlers.\n+  NOT_WINDOWS(static const void* crash_handler_address;)\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"}]}