{"files":[{"patch":"@@ -50,0 +50,11 @@\n+\n+static const char* get_signal_name(int sig, char* out, size_t outlen);\n+\n+\/\/ Returns address of a handler associated with the given sigaction\n+static address get_signal_handler(const struct sigaction* action);\n+\n+#define HANDLER_IS(handler, address)    ((handler) == CAST_FROM_FN_PTR(void*, (address)))\n+#define HANDLER_IS_IGN(handler)         (HANDLER_IS(handler, SIG_IGN))\n+#define HANDLER_IS_DFL(handler)         (HANDLER_IS(handler, SIG_DFL))\n+#define HANDLER_IS_IGN_OR_DFL(handler)  (HANDLER_IS_IGN(handler) || HANDLER_IS_DFL(handler))\n+\n@@ -79,3 +90,45 @@\n-\/\/ For diagnostics to print a message once. see run_periodic_checks\n-static sigset_t check_signal_done;\n-static bool check_signals = true;\n+\/\/ At various places we store handler information for each installed handler.\n+\/\/  SavedSignalHandlers is a helper class for those cases, keeping an array of sigaction\n+\/\/  structures and membership information.\n+class SavedSignalHandlers {\n+  struct sigaction _v[NSIG];\n+  sigset_t _set;\n+\n+  bool check_signal_number(int sig) const {\n+    assert(sig > 0 || sig < NSIG, \"invalid signal number %d\", sig);\n+    return sig > 0 || sig < NSIG;\n+  }\n+\n+  bool is_set(int sig) const  { return sigismember(&_set, sig); }\n+  void mark_as_set(int sig)   { sigaddset(&_set, sig); }\n+  void mark_as_clear(int sig) { sigdelset(&_set, sig); }\n+\n+public:\n+\n+  SavedSignalHandlers() {\n+    sigemptyset(&_set);\n+    ::memset(_v, 0, sizeof(_v));\n+  }\n+\n+  void set(int sig, const struct sigaction* act) {\n+    if (check_signal_number(sig)) {\n+      _v[sig] = *act;\n+      mark_as_set(sig);\n+    }\n+  }\n+\n+  void clear(int sig) {\n+    if (check_signal_number(sig)) {\n+      mark_as_clear(sig);\n+      ::memset(_v + sig, 0, sizeof(struct sigaction));\n+    }\n+  }\n+\n+  const struct sigaction* get(int sig) const {\n+    if (check_signal_number(sig) && is_set(sig)) {\n+      return _v + sig;\n+    }\n+    return NULL;\n+  }\n+};\n+\n@@ -85,1 +138,0 @@\n-struct sigaction sigact[NSIG];\n@@ -87,1 +139,11 @@\n-\/\/ For signal-chaining\n+\/\/ For CheckJNI:\n+\/\/  Our own hotspot signal handlers should never ever get replaced by a third\n+\/\/  party one. To check that, store a copy of the handler setup and compare it\n+\/\/  periodically against reality (see see os::run_periodic_checks()).\n+static bool check_signals = true;\n+static SavedSignalHandlers expected_handlers;\n+\n+\/\/ For signal-chaining:\n+\/\/  if chaining is active, chained_handlers contains all handlers which we\n+\/\/  did replace with our own and to which we must delegate.\n+static SavedSignalHandlers chained_handlers;\n@@ -92,2 +154,5 @@\n-\/\/ For diagnostic\n-int sigflags[NSIG];\n+\/\/ For diagnostics:\n+\/\/  when installing a signal handler (any - our own and on behalf of user code),\n+\/\/  keep a copy of the old setup for display purposes. This is independent from\n+\/\/  signal chaining.\n+static SavedSignalHandlers replaced_handlers;\n@@ -273,2 +338,0 @@\n-static const char* get_signal_name(int sig, char* out, size_t outlen);\n-\n@@ -338,13 +401,0 @@\n-static struct sigaction* get_preinstalled_handler(int sig) {\n-  if (sigismember(&preinstalled_sigs, sig)) {\n-    return &sigact[sig];\n-  }\n-  return NULL;\n-}\n-\n-static void save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigact[sig] = oldAct;\n-  sigaddset(&preinstalled_sigs, sig);\n-}\n-\n@@ -360,1 +410,1 @@\n-    actp = get_preinstalled_handler(sig);\n+    actp = const_cast<struct sigaction*>(chained_handlers.get(sig));\n@@ -739,12 +789,0 @@\n-static int get_our_sigflags(int sig) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  return sigflags[sig];\n-}\n-\n-static void set_our_sigflags(int sig, int flags) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  if (sig > 0 && sig < NSIG) {\n-    sigflags[sig] = flags;\n-  }\n-}\n-\n@@ -766,0 +804,2 @@\n+\/\/ If we installed one of our signal handlers for sig, check that the current\n+\/\/  setup matches what we originally installed.\n@@ -768,1 +808,1 @@\n-  address jvmHandler = NULL;\n+  bool mismatch = false;\n@@ -770,0 +810,8 @@\n+  \/\/ Retrieve expected signal setup. If there is none we either had no handler installed\n+  \/\/ in the first place or had a mismatch already; in both cases, nothing to do here.\n+  const struct sigaction* expected_act = expected_handlers.get(sig);\n+  if (expected_act == NULL) {\n+    return;\n+  }\n+\n+  \/\/ Retrieve current signal setup.\n@@ -780,30 +828,1 @@\n-  \/\/ See comment for SA_RESTORER_FLAG_MASK\n-  LINUX_ONLY(act.sa_flags &= SA_RESTORER_FLAG_MASK;)\n-\n-  address thisHandler = get_signal_handler(&act);\n-\n-  switch (sig) {\n-  case SIGSEGV:\n-  case SIGBUS:\n-  case SIGFPE:\n-  case SIGPIPE:\n-  case SIGILL:\n-  case SIGXFSZ:\n-    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler);\n-    break;\n-\n-  case SHUTDOWN1_SIGNAL:\n-  case SHUTDOWN2_SIGNAL:\n-  case SHUTDOWN3_SIGNAL:\n-  case BREAK_SIGNAL:\n-    jvmHandler = (address)os::user_handler();\n-    break;\n-\n-  default:\n-    if (sig == PosixSignals::SR_signum) {\n-      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n-    } else {\n-      return;\n-    }\n-    break;\n-  }\n+  \/\/ Compare both sigaction structures (intelligently; only the members we care about).\n@@ -811,1 +830,5 @@\n-  if (thisHandler != jvmHandler) {\n+  \/\/ Handler?\n+  address this_handler = get_signal_handler(&act);\n+  address expected_handler = get_signal_handler(expected_act);\n+  if (this_handler != expected_handler) {\n+    mismatch = true;\n@@ -814,1 +837,1 @@\n-    print_signal_handler_name(tty, jvmHandler, buf, O_BUFLEN);\n+    print_signal_handler_name(tty, expected_handler, buf, O_BUFLEN);\n@@ -816,3 +839,2 @@\n-    print_signal_handler_name(tty, thisHandler, buf, O_BUFLEN);\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n+    print_signal_handler_name(tty, this_handler, buf, O_BUFLEN);\n+    tty->cr();\n@@ -820,1 +842,1 @@\n-    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n+    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {    \/\/ Flags?\n@@ -822,1 +844,1 @@\n-                    os::exception_name(sig, buf, O_BUFLEN));\n+                    os::exception_name(sig, buf, O_BUFLEN));    \/\/ When comparing, ignore the SA_RESTORER flag on Linux\n@@ -824,1 +846,10 @@\n-  } else if (get_our_sigflags(sig) != 0 && (int)act.sa_flags != get_our_sigflags(sig)) {\n+  }\n+\n+  \/\/ Flags?\n+\n+  \/\/ When comparing, ignore the SA_RESTORER flag on Linux\n+  int this_flags = act.sa_flags;\n+  const int expected_flags = expected_act->sa_flags;\n+  LINUX_ONLY(this_flags &= SA_RESTORER_FLAG_MASK;)\n+  if (this_flags != expected_flags) {\n+    mismatch = true;\n@@ -827,1 +858,1 @@\n-    print_sa_flags(tty, get_our_sigflags(sig));\n+    print_sa_flags(tty, expected_flags);\n@@ -830,1 +861,1 @@\n-    print_sa_flags(tty, act.sa_flags);\n+    print_sa_flags(tty, this_flags);\n@@ -832,2 +863,0 @@\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n@@ -836,2 +865,7 @@\n-  \/\/ Dump all the signal\n-  if (sigismember(&check_signal_done, sig)) {\n+  \/\/ Mask? omitted for now.\n+\n+  \/\/ If we had a mismatch:\n+  \/\/ - remove the signal setup from the expected set since we do not need to check again\n+  \/\/ - print all signal handlers for diagnostics\n+  if (mismatch) {\n+    expected_handlers.clear(sig);\n@@ -860,1 +894,8 @@\n-  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n+  \/\/ For diagnostic purposes (see print_signal_handler) store information about\n+  \/\/ the preexisting handler if one had been installed.\n+  address oldhand = get_signal_handler(&oldSigAct);\n+  if (!HANDLER_IS_IGN_OR_DFL(oldhand)) {\n+    replaced_handlers.set(signal_number, &oldSigAct);\n+  }\n+\n+  return oldhand;\n@@ -872,6 +913,0 @@\n-static void do_signal_check(int signal) {\n-  if (!sigismember(&check_signal_done, signal)) {\n-    check_signal_handler(signal);\n-  }\n-}\n-\n@@ -880,1 +915,0 @@\n-\n@@ -889,7 +923,7 @@\n-  do_signal_check(SIGSEGV);\n-  do_signal_check(SIGILL);\n-  do_signal_check(SIGFPE);\n-  do_signal_check(SIGBUS);\n-  do_signal_check(SIGPIPE);\n-  do_signal_check(SIGXFSZ);\n-  PPC64_ONLY(do_signal_check(SIGTRAP);)\n+  check_signal_handler(SIGSEGV);\n+  check_signal_handler(SIGILL);\n+  check_signal_handler(SIGFPE);\n+  check_signal_handler(SIGBUS);\n+  check_signal_handler(SIGPIPE);\n+  check_signal_handler(SIGXFSZ);\n+  PPC64_ONLY(check_signal_handler(SIGTRAP);)\n@@ -900,4 +934,4 @@\n-    do_signal_check(SHUTDOWN1_SIGNAL);\n-    do_signal_check(SHUTDOWN2_SIGNAL);\n-    do_signal_check(SHUTDOWN3_SIGNAL);\n-    do_signal_check(BREAK_SIGNAL);\n+    check_signal_handler(SHUTDOWN1_SIGNAL);\n+    check_signal_handler(SHUTDOWN2_SIGNAL);\n+    check_signal_handler(SHUTDOWN3_SIGNAL);\n+    check_signal_handler(BREAK_SIGNAL);\n@@ -906,1 +940,1 @@\n-  do_signal_check(PosixSignals::SR_signum);\n+  check_signal_handler(PosixSignals::SR_signum);\n@@ -1206,0 +1240,2 @@\n+  \/\/ Query the current signal handler. Needs to be a separate operation\n+  \/\/ from installing a new handler since we need to honor AllowUserSignalHandlers.\n@@ -1207,3 +1243,2 @@\n-  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)javaSignalHandler)) {\n+  if (!HANDLER_IS_IGN_OR_DFL(oldhand) &&\n+      !HANDLER_IS(oldhand, javaSignalHandler)) {\n@@ -1215,1 +1250,1 @@\n-      save_preinstalled_handler(sig, oldAct);\n+      chained_handlers.set(sig, &oldAct);\n@@ -1242,3 +1277,2 @@\n-  \/\/ Save flags, which are set by ours\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigflags[sig] = sigAct.sa_flags;\n+  \/\/ Save handler setup for later checking\n+  expected_handlers.set(sig, &sigAct);\n@@ -1251,0 +1285,6 @@\n+\n+  \/\/ For diagnostic purposes (see print_signal_handler) store information about\n+  \/\/ the preexisting handler if it was non-default and non-ignore\n+  if (!HANDLER_IS_IGN_OR_DFL(oldhand2)) {\n+    replaced_handlers.set(sig, &oldAct);\n+  }\n@@ -1349,7 +1389,3 @@\n-void PosixSignals::print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen) {\n-  struct sigaction sa;\n-  sigaction(sig, NULL, &sa);\n-\n-  \/\/ See comment for SA_RESTORER_FLAG_MASK\n-  LINUX_ONLY(sa.sa_flags &= SA_RESTORER_FLAG_MASK;)\n+static void print_single_signal_handler(outputStream* st, int sig,\n+                                        const struct sigaction* act,\n+                                        char* buf, size_t buflen) {\n@@ -1359,3 +1395,2 @@\n-  address handler = get_signal_handler(&sa);\n-\n-  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n+  address handler = get_signal_handler(act);\n+  if (HANDLER_IS_DFL(handler)) {\n@@ -1363,1 +1398,1 @@\n-  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n+  } else if (HANDLER_IS_IGN(handler)) {\n@@ -1366,1 +1401,1 @@\n-    print_signal_handler_name(st, handler, buf, O_BUFLEN);\n+    print_signal_handler_name(st, handler, buf, buflen);\n@@ -1369,2 +1404,2 @@\n-  st->print(\", sa_mask[0]=\");\n-  print_signal_set_short(st, &sa.sa_mask);\n+  st->print(\", mask=\");\n+  print_signal_set_short(st, &(act->sa_mask));\n@@ -1372,7 +1407,5 @@\n-  address rh = VMError::get_resetted_sighandler(sig);\n-  \/\/ May be, handler was resetted by VMError?\n-  if (rh != NULL) {\n-    handler = rh;\n-    \/\/ See comment for SA_RESTORER_FLAG_MASK\n-    sa.sa_flags = VMError::get_resetted_sigflags(sig) LINUX_ONLY(& SA_RESTORER_FLAG_MASK);\n-  }\n+  st->print(\", flags=\");\n+  int flags = act->sa_flags;\n+  \/\/ On Linux, hide the SA_RESTORE flag\n+  LINUX_ONLY(flags &= SA_RESTORER_FLAG_MASK;)\n+  print_sa_flags(st, flags);\n@@ -1380,3 +1413,14 @@\n-  \/\/ Print textual representation of sa_flags.\n-  st->print(\", sa_flags=\");\n-  print_sa_flags(st, sa.sa_flags);\n+}\n+\n+\/\/ Print established signal handler for this signal.\n+\/\/ - if this signal handler was installed by us and is chained to a pre-established user handler\n+\/\/    it did replace, print that one too.\n+\/\/ - otherwise, if this signal handler was installed by us and replaced another handler to which we\n+\/\/    are not chained (e.g. if chaining is off), print that one too.\n+void PosixSignals::print_signal_handler(outputStream* st, int sig,\n+                                        char* buf, size_t buflen) {\n+  struct sigaction current_act;\n+  sigaction(sig, NULL, &current_act);\n+\n+  print_single_signal_handler(st, sig, &current_act, buf, buflen);\n+  st->cr();\n@@ -1384,9 +1428,11 @@\n-  \/\/ Check: is it our handler?\n-  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler) ||\n-      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n-    \/\/ It is our signal handler\n-    \/\/ check for flags, reset system-used one!\n-    if ((int)sa.sa_flags != get_our_sigflags(sig)) {\n-      st->print(\n-                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n-                get_our_sigflags(sig));\n+  const struct sigaction* chained_act = get_chained_signal_action(sig);\n+  if (chained_act != NULL) {\n+    st->print(\"  chained to: \");\n+    print_single_signal_handler(st, sig, &current_act, buf, buflen);\n+    st->cr();\n+  } else {\n+    const struct sigaction* replaced_act = replaced_handlers.get(sig);\n+    if (replaced_act != NULL) {\n+      st->print(\"  replaced: \");\n+      print_single_signal_handler(st, sig, replaced_act, buf, buflen);\n+      st->cr();\n@@ -1395,1 +1441,0 @@\n-  st->cr();\n@@ -1424,2 +1469,1 @@\n-  void* ohlr = get_signal_handler(&oact);\n-  if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN)) {\n+  if (HANDLER_IS_IGN(get_signal_handler(&oact))) {\n@@ -1675,2 +1719,3 @@\n-  \/\/ Save signal flag\n-  set_our_sigflags(PosixSignals::SR_signum, act.sa_flags);\n+  \/\/ Save signal setup information for later checking.\n+  expected_handlers.set(PosixSignals::SR_signum, &act);\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":190,"deletions":145,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -52,10 +52,0 @@\n-\/\/ handle all synchronous program error signals which may happen during error\n-\/\/ reporting. They must be unblocked, caught, handled.\n-\n-static const int SIGNALS[] = { SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP }; \/\/ add more if needed\n-static const int NUM_SIGNALS = sizeof(SIGNALS) \/ sizeof(int);\n-\n-\/\/ Space for our \"saved\" signal flags and handlers\n-static int resettedSigflags[NUM_SIGNALS];\n-static address resettedSighandler[NUM_SIGNALS];\n-\n@@ -77,28 +67,0 @@\n-static void save_signal(int idx, int sig)\n-{\n-  struct sigaction sa;\n-  sigaction(sig, NULL, &sa);\n-  resettedSigflags[idx]   = sa.sa_flags;\n-  resettedSighandler[idx] = (sa.sa_flags & SA_SIGINFO)\n-                              ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n-                              : CAST_FROM_FN_PTR(address, sa.sa_handler);\n-}\n-\n-int VMError::get_resetted_sigflags(int sig) {\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    if (SIGNALS[i] == sig) {\n-      return resettedSigflags[i];\n-    }\n-  }\n-  return -1;\n-}\n-\n-address VMError::get_resetted_sighandler(int sig) {\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    if (SIGNALS[i] == sig) {\n-      return resettedSighandler[i];\n-    }\n-  }\n-  return NULL;\n-}\n-\n@@ -137,3 +99,6 @@\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    save_signal(i, SIGNALS[i]);\n-    os::signal(SIGNALS[i], CAST_FROM_FN_PTR(void *, crash_handler));\n+  static const int signals_to_handle[] = {\n+    SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP,\n+    0 \/\/ end\n+  };\n+  for (int i = 0; signals_to_handle[i] != 0; i++) {\n+    os::signal(signals_to_handle[i], CAST_FROM_FN_PTR(void *, crash_handler));\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":6,"deletions":41,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -32,8 +32,0 @@\n-int VMError::get_resetted_sigflags(int sig) {\n-  return -1;\n-}\n-\n-address VMError::get_resetted_sighandler(int sig) {\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -163,8 +163,0 @@\n-  \/\/ returns original flags for signal, if it was resetted, or -1 if\n-  \/\/ signal was not changed by error reporter\n-  static int get_resetted_sigflags(int sig);\n-\n-  \/\/ returns original handler for signal, if it was resetted, or NULL if\n-  \/\/ signal was not changed by error reporter\n-  static address get_resetted_sighandler(int sig);\n-\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}