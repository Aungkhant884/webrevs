{"files":[{"patch":"@@ -68,7 +68,19 @@\n-\/\/ Glibc on Linux uses the SA_RESTORER flag to indicate\n-\/\/ the use of a \"signal trampoline\". We have no interest\n-\/\/ in this flag and need to ignore it when checking our\n-\/\/ own flag settings.\n-\/\/ Note: SA_RESTORER is not exposed through signal.h so we\n-\/\/ have to hardwire its 0x04000000 value in the mask.\n-LINUX_ONLY(const int SA_RESTORER_FLAG_MASK = ~0x04000000;)\n+\/\/ Helper function to strip any flags from a sigaction sa_flag\n+\/\/ which are not needed for semantic comparison (see remarks below\n+\/\/ about SA_RESTORER on Linux).\n+\/\/ Also to work around the fact that not all platforms define sa_flags\n+\/\/ as signed int (looking at you, zlinux).\n+static int get_sanitized_sa_flags(const struct sigaction* sa) {\n+  int f = (int) sa->sa_flags;\n+#ifdef LINUX\n+  \/\/ Glibc on Linux uses the SA_RESTORER flag to indicate\n+  \/\/ the use of a \"signal trampoline\". We have no interest\n+  \/\/ in this flag and need to ignore it when checking our\n+  \/\/ own flag settings.\n+  \/\/ Note: SA_RESTORER is not exposed through signal.h so we\n+  \/\/ have to hardcode its 0x04000000 value here.\n+  const int sa_restorer_flag = 0x04000000;\n+  f &= ~sa_restorer_flag;\n+#endif \/\/ LINUX\n+  return f;\n+}\n@@ -125,7 +137,0 @@\n-  void clear(int sig) {\n-    if (check_signal_number(sig)) {\n-      FREE_C_HEAP_OBJ(_sa[sig]);\n-      _sa[sig] = NULL;\n-    }\n-  }\n-\n@@ -144,4 +149,3 @@\n-\/\/ For CheckJNI:\n-\/\/  Our own hotspot signal handlers should never ever get replaced by a third\n-\/\/  party one. To check that, store a copy of the handler setup and compare it\n-\/\/  periodically against reality (see os::run_periodic_checks()).\n+\/\/ Our own signal handlers should never ever get replaced by a third party one.\n+\/\/  To check that, and to aid with diagnostics, store a copy of the handler setup\n+\/\/  and compare it periodically against reality (see os::run_periodic_checks()).\n@@ -150,0 +154,1 @@\n+static bool do_check_signal_periodically[NSIG];\n@@ -803,0 +808,12 @@\n+\/\/ Semantically compare two sigaction structures. Return true if they are referring to\n+\/\/ the same handler, using the same flags.\n+static bool compare_handler_info(const struct sigaction* sa,\n+                                 const struct sigaction* expected_sa) {\n+  address this_handler = get_signal_handler(sa);\n+  address expected_handler = get_signal_handler(expected_sa);\n+  const int this_flags = get_sanitized_sa_flags(sa);\n+  const int expected_flags = get_sanitized_sa_flags(expected_sa);\n+  return this_handler == expected_handler &&\n+         this_flags == expected_flags;\n+}\n+\n@@ -809,4 +826,1 @@\n-  \/\/ Retrieve expected signal setup. If there is none we either had no handler installed\n-  \/\/ in the first place or had a mismatch already; in both cases, nothing to do here.\n-  const struct sigaction* expected_act = expected_handlers.get(sig);\n-  if (expected_act == NULL) {\n+  if (!do_check_signal_periodically[sig]) {\n@@ -816,0 +830,3 @@\n+  const struct sigaction* expected_act = expected_handlers.get(sig);\n+  assert(expected_act != NULL, \"Sanity\");\n+\n@@ -828,12 +845,10 @@\n-\n-  \/\/ Check handler\n-  address this_handler = get_signal_handler(&act);\n-  address expected_handler = get_signal_handler(expected_act);\n-  if (this_handler != expected_handler) {\n-    mismatch = true;\n-    tty->print(\"Warning: %s handler \", os::exception_name(sig, buf, O_BUFLEN));\n-    tty->print_raw(\"expected:\");\n-    print_signal_handler_name(tty, expected_handler, buf, O_BUFLEN);\n-    tty->print_raw(\"  found:\");\n-    print_signal_handler_name(tty, this_handler, buf, O_BUFLEN);\n-    tty->cr();\n+  if (!compare_handler_info(&act, expected_act)) {\n+    tty->print_cr(\"Warning: %s handler modified!\", os::exception_name(sig, buf, sizeof(buf)));\n+    \/\/ If we had a mismatch:\n+    \/\/ - print all signal handlers. As part of that printout details will be printed\n+    \/\/   about any modified handlers.\n+    \/\/ - Disable any further checks for this signal - we do not want to flood stdout. Though\n+    \/\/   depending on which signal had been overwritten, we may die very soon anyway.\n+    os::print_signal_handlers(tty, buf, O_BUFLEN);\n+    do_check_signal_periodically[sig] = false;\n+    tty->print_cr(\"Consider using jsig library.\");\n@@ -842,1 +857,1 @@\n-      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n+      tty->print_cr(\"Note: Running in non-interactive shell, %s handler is replaced by shell\",\n@@ -846,25 +861,0 @@\n-\n-  \/\/ Check flags\n-\n-  \/\/ When comparing, ignore the SA_RESTORER flag on Linux\n-  int this_flags = act.sa_flags;\n-  const int expected_flags = expected_act->sa_flags;\n-  LINUX_ONLY(this_flags &= SA_RESTORER_FLAG_MASK;)\n-  if (this_flags != expected_flags) {\n-    mismatch = true;\n-    tty->print(\"Warning: %s handler flags \", os::exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:\");\n-    print_sa_flags(tty, expected_flags);\n-    tty->cr();\n-    tty->print(\"  found:\");\n-    print_sa_flags(tty, this_flags);\n-    tty->cr();\n-  }\n-\n-  \/\/ If we had a mismatch:\n-  \/\/ - remove the signal setup from the expected set since we do not need to check again\n-  \/\/ - print all signal handlers for diagnostics\n-  if (mismatch) {\n-    expected_handlers.clear(sig);\n-    os::print_signal_handlers(tty, buf, O_BUFLEN);\n-  }\n@@ -1269,0 +1259,1 @@\n+  do_check_signal_periodically[sig] = true;\n@@ -1374,1 +1365,1 @@\n-static void print_single_signal_handler(outputStream* st, int sig,\n+static void print_single_signal_handler(outputStream* st,\n@@ -1378,2 +1369,0 @@\n-  st->print(\"%10s: \", os::exception_name(sig, buf, buflen));\n-\n@@ -1393,3 +1382,1 @@\n-  int flags = act->sa_flags;\n-  \/\/ On Linux, hide the SA_RESTORER flag\n-  LINUX_ONLY(flags &= SA_RESTORER_FLAG_MASK;)\n+  int flags = get_sanitized_sa_flags(act);\n@@ -1407,0 +1394,3 @@\n+\n+  st->print(\"%10s: \", os::exception_name(sig, buf, buflen));\n+\n@@ -1410,1 +1400,1 @@\n-  print_single_signal_handler(st, sig, &current_act, buf, buflen);\n+  print_single_signal_handler(st, &current_act, buf, buflen);\n@@ -1414,1 +1404,2 @@\n-  \/\/  print a warning. Unless it had been replaced with our own secondary crash handler.\n+  \/\/  print a warning (unless the handler replacing it is our own crash handler, which can\n+  \/\/  happen if this function is called during error reporting).\n@@ -1419,8 +1410,5 @@\n-      const address expected_handler = get_signal_handler(expected_act);\n-      if (current_handler != expected_handler) {\n-        st->print_cr(\"  *** Handler changed! Expected hotspot signal handler. Consider using jsig library.\");\n-      }\n-      int this_flag = current_act.sa_flags;\n-      LINUX_ONLY(this_flag &= SA_RESTORER_FLAG_MASK;)\n-      if (this_flag != expected_act->sa_flags) {\n-        st->print_cr(\"  *** Flags changed! Consider using jsig library.\");\n+      if (!compare_handler_info(&current_act, expected_act)) {\n+        st->print_cr(\"  *** Handler was modified!\");\n+        st->print   (\"  *** Expected: \");\n+        print_single_signal_handler(st, expected_act, buf, buflen);\n+        st->cr();\n@@ -1435,1 +1423,1 @@\n-    print_single_signal_handler(st, sig, &current_act, buf, buflen);\n+    print_single_signal_handler(st, &current_act, buf, buflen);\n@@ -1718,0 +1706,1 @@\n+  do_check_signal_periodically[PosixSignals::SR_signum] = true;\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":66,"deletions":77,"binary":false,"changes":143,"status":"modified"}]}