{"files":[{"patch":"@@ -92,1 +92,1 @@\n-\/\/  structures and membership information.\n+\/\/  structures.\n@@ -94,2 +94,5 @@\n-  struct sigaction _v[NSIG];\n-  sigset_t _set;\n+  \/\/ Note: NSIG can be largish, depending on platform, and this array is expected\n+  \/\/ to be sparsely populated. To save space the contained structures are\n+  \/\/ C-heap allocated. Since they only get added outside of signal handling\n+  \/\/ this is no problem.\n+  struct sigaction* _sa[NSIG];\n@@ -98,2 +101,2 @@\n-    assert(sig > 0 || sig < NSIG, \"invalid signal number %d\", sig);\n-    return sig > 0 || sig < NSIG;\n+    assert(sig > 0 && sig < NSIG, \"invalid signal number %d\", sig);\n+    return sig > 0 && sig < NSIG;\n@@ -102,4 +105,0 @@\n-  bool is_set(int sig) const  { return sigismember(&_set, sig); }\n-  void mark_as_set(int sig)   { sigaddset(&_set, sig); }\n-  void mark_as_clear(int sig) { sigdelset(&_set, sig); }\n-\n@@ -109,2 +108,7 @@\n-    sigemptyset(&_set);\n-    ::memset(_v, 0, sizeof(_v));\n+    ::memset(_sa, 0, sizeof(_sa));\n+  }\n+\n+  ~SavedSignalHandlers() {\n+    for (int i = 0; i < NSIG; i ++) {\n+      FREE_C_HEAP_OBJ(_sa[i]);\n+    }\n@@ -115,2 +119,2 @@\n-      _v[sig] = *act;\n-      mark_as_set(sig);\n+      assert(_sa[sig] == NULL, \"Overwriting signal handler?\");\n+      _sa[sig] = NEW_C_HEAP_OBJ(struct sigaction, mtInternal);\n@@ -122,2 +126,2 @@\n-      mark_as_clear(sig);\n-      ::memset(_v + sig, 0, sizeof(struct sigaction));\n+      FREE_C_HEAP_OBJ(_sa[sig]);\n+      _sa[sig] = NULL;\n@@ -128,2 +132,2 @@\n-    if (check_signal_number(sig) && is_set(sig)) {\n-      return _v + sig;\n+    if (check_signal_number(sig)) {\n+      return _sa[sig];\n@@ -142,1 +146,1 @@\n-\/\/  periodically against reality (see see os::run_periodic_checks()).\n+\/\/  periodically against reality (see os::run_periodic_checks()).\n@@ -154,6 +158,0 @@\n-\/\/ For diagnostics:\n-\/\/  when installing a signal handler (any - our own and on behalf of user code),\n-\/\/  keep a copy of the old setup for display purposes. This is independent from\n-\/\/  signal chaining.\n-static SavedSignalHandlers replaced_handlers;\n-\n@@ -830,1 +828,1 @@\n-  \/\/ Handler?\n+  \/\/ Check handler\n@@ -842,1 +840,1 @@\n-    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {    \/\/ Flags?\n+    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n@@ -848,1 +846,1 @@\n-  \/\/ Flags?\n+  \/\/ Check flags\n@@ -865,2 +863,0 @@\n-  \/\/ Mask? omitted for now.\n-\n@@ -894,8 +890,1 @@\n-  \/\/ For diagnostic purposes (see print_signal_handler) store information about\n-  \/\/ the preexisting handler if one had been installed.\n-  address oldhand = get_signal_handler(&oldSigAct);\n-  if (!HANDLER_IS_IGN_OR_DFL(oldhand)) {\n-    replaced_handlers.set(signal_number, &oldSigAct);\n-  }\n-\n-  return oldhand;\n+  return get_signal_handler(&oldSigAct);\n@@ -1286,5 +1275,0 @@\n-  \/\/ For diagnostic purposes (see print_signal_handler) store information about\n-  \/\/ the preexisting handler if it was non-default and non-ignore\n-  if (!HANDLER_IS_IGN_OR_DFL(oldhand2)) {\n-    replaced_handlers.set(sig, &oldAct);\n-  }\n@@ -1433,7 +1417,0 @@\n-  } else {\n-    const struct sigaction* replaced_act = replaced_handlers.get(sig);\n-    if (replaced_act != NULL) {\n-      st->print(\"  replaced: \");\n-      print_single_signal_handler(st, sig, replaced_act, buf, buflen);\n-      st->cr();\n-    }\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":26,"deletions":49,"binary":false,"changes":75,"status":"modified"}]}