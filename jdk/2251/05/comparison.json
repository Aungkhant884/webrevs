{"files":[{"patch":"@@ -50,0 +50,11 @@\n+\n+static const char* get_signal_name(int sig, char* out, size_t outlen);\n+\n+\/\/ Returns address of a handler associated with the given sigaction\n+static address get_signal_handler(const struct sigaction* action);\n+\n+#define HANDLER_IS(handler, address)    ((handler) == CAST_FROM_FN_PTR(void*, (address)))\n+#define HANDLER_IS_IGN(handler)         (HANDLER_IS(handler, SIG_IGN))\n+#define HANDLER_IS_DFL(handler)         (HANDLER_IS(handler, SIG_DFL))\n+#define HANDLER_IS_IGN_OR_DFL(handler)  (HANDLER_IS_IGN(handler) || HANDLER_IS_DFL(handler))\n+\n@@ -57,7 +68,19 @@\n-\/\/ Glibc on Linux uses the SA_RESTORER flag to indicate\n-\/\/ the use of a \"signal trampoline\". We have no interest\n-\/\/ in this flag and need to ignore it when checking our\n-\/\/ own flag settings.\n-\/\/ Note: SA_RESTORER is not exposed through signal.h so we\n-\/\/ have to hardwire its 0x04000000 value in the mask.\n-LINUX_ONLY(const int SA_RESTORER_FLAG_MASK = ~0x04000000;)\n+\/\/ Helper function to strip any flags from a sigaction sa_flag\n+\/\/ which are not needed for semantic comparison (see remarks below\n+\/\/ about SA_RESTORER on Linux).\n+\/\/ Also to work around the fact that not all platforms define sa_flags\n+\/\/ as signed int (looking at you, zlinux).\n+static int get_sanitized_sa_flags(const struct sigaction* sa) {\n+  int f = (int) sa->sa_flags;\n+#ifdef LINUX\n+  \/\/ Glibc on Linux uses the SA_RESTORER flag to indicate\n+  \/\/ the use of a \"signal trampoline\". We have no interest\n+  \/\/ in this flag and need to ignore it when checking our\n+  \/\/ own flag settings.\n+  \/\/ Note: SA_RESTORER is not exposed through signal.h so we\n+  \/\/ have to hardcode its 0x04000000 value here.\n+  const int sa_restorer_flag = 0x04000000;\n+  f &= ~sa_restorer_flag;\n+#endif \/\/ LINUX\n+  return f;\n+}\n@@ -79,3 +102,43 @@\n-\/\/ For diagnostics to print a message once. see run_periodic_checks\n-static sigset_t check_signal_done;\n-static bool check_signals = true;\n+\/\/ At various places we store handler information for each installed handler.\n+\/\/  SavedSignalHandlers is a helper class for those cases, keeping an array of sigaction\n+\/\/  structures.\n+class SavedSignalHandlers {\n+  \/\/ Note: NSIG can be largish, depending on platform, and this array is expected\n+  \/\/ to be sparsely populated. To save space the contained structures are\n+  \/\/ C-heap allocated. Since they only get added outside of signal handling\n+  \/\/ this is no problem.\n+  struct sigaction* _sa[NSIG];\n+\n+  bool check_signal_number(int sig) const {\n+    assert(sig > 0 && sig < NSIG, \"invalid signal number %d\", sig);\n+    return sig > 0 && sig < NSIG;\n+  }\n+\n+public:\n+\n+  SavedSignalHandlers() {\n+    ::memset(_sa, 0, sizeof(_sa));\n+  }\n+\n+  ~SavedSignalHandlers() {\n+    for (int i = 0; i < NSIG; i ++) {\n+      FREE_C_HEAP_OBJ(_sa[i]);\n+    }\n+  }\n+\n+  void set(int sig, const struct sigaction* act) {\n+    if (check_signal_number(sig)) {\n+      assert(_sa[sig] == NULL, \"Overwriting signal handler?\");\n+      _sa[sig] = NEW_C_HEAP_OBJ(struct sigaction, mtInternal);\n+      *_sa[sig] = *act;\n+    }\n+  }\n+\n+  const struct sigaction* get(int sig) const {\n+    if (check_signal_number(sig)) {\n+      return _sa[sig];\n+    }\n+    return NULL;\n+  }\n+};\n+\n@@ -85,1 +148,0 @@\n-struct sigaction sigact[NSIG];\n@@ -87,1 +149,11 @@\n-\/\/ For signal-chaining\n+\/\/ Our own signal handlers should never ever get replaced by a third party one.\n+\/\/  To check that, and to aid with diagnostics, store a copy of the handler setup\n+\/\/  and compare it periodically against reality (see os::run_periodic_checks()).\n+static bool check_signals = true;\n+static SavedSignalHandlers expected_handlers;\n+static bool do_check_signal_periodically[NSIG] = { 0 };\n+\n+\/\/ For signal-chaining:\n+\/\/  if chaining is active, chained_handlers contains all handlers which we\n+\/\/  replaced with our own and to which we must delegate.\n+static SavedSignalHandlers chained_handlers;\n@@ -92,3 +164,0 @@\n-\/\/ For diagnostic\n-int sigflags[NSIG];\n-\n@@ -273,2 +342,0 @@\n-static const char* get_signal_name(int sig, char* out, size_t outlen);\n-\n@@ -338,13 +405,0 @@\n-static struct sigaction* get_preinstalled_handler(int sig) {\n-  if (sigismember(&preinstalled_sigs, sig)) {\n-    return &sigact[sig];\n-  }\n-  return NULL;\n-}\n-\n-static void save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigact[sig] = oldAct;\n-  sigaddset(&preinstalled_sigs, sig);\n-}\n-\n@@ -360,1 +414,1 @@\n-    actp = get_preinstalled_handler(sig);\n+    actp = const_cast<struct sigaction*>(chained_handlers.get(sig));\n@@ -739,12 +793,0 @@\n-static int get_our_sigflags(int sig) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  return sigflags[sig];\n-}\n-\n-static void set_our_sigflags(int sig, int flags) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  if (sig > 0 && sig < NSIG) {\n-    sigflags[sig] = flags;\n-  }\n-}\n-\n@@ -766,0 +808,14 @@\n+\/\/ Semantically compare two sigaction structures. Return true if they are referring to\n+\/\/ the same handler, using the same flags.\n+static bool compare_handler_info(const struct sigaction* sa,\n+                                 const struct sigaction* expected_sa) {\n+  address this_handler = get_signal_handler(sa);\n+  address expected_handler = get_signal_handler(expected_sa);\n+  const int this_flags = get_sanitized_sa_flags(sa);\n+  const int expected_flags = get_sanitized_sa_flags(expected_sa);\n+  return this_handler == expected_handler &&\n+         this_flags == expected_flags;\n+}\n+\n+\/\/ If we installed one of our signal handlers for sig, check that the current\n+\/\/  setup matches what we originally installed.\n@@ -768,1 +824,8 @@\n-  address jvmHandler = NULL;\n+  bool mismatch = false;\n+\n+  if (!do_check_signal_periodically[sig]) {\n+    return;\n+  }\n+\n+  const struct sigaction* expected_act = expected_handlers.get(sig);\n+  assert(expected_act != NULL, \"Sanity\");\n@@ -770,0 +833,1 @@\n+  \/\/ Retrieve current signal setup.\n@@ -780,39 +844,11 @@\n-  \/\/ See comment for SA_RESTORER_FLAG_MASK\n-  LINUX_ONLY(act.sa_flags &= SA_RESTORER_FLAG_MASK;)\n-\n-  address thisHandler = get_signal_handler(&act);\n-\n-  switch (sig) {\n-  case SIGSEGV:\n-  case SIGBUS:\n-  case SIGFPE:\n-  case SIGPIPE:\n-  case SIGILL:\n-  case SIGXFSZ:\n-    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler);\n-    break;\n-\n-  case SHUTDOWN1_SIGNAL:\n-  case SHUTDOWN2_SIGNAL:\n-  case SHUTDOWN3_SIGNAL:\n-  case BREAK_SIGNAL:\n-    jvmHandler = (address)os::user_handler();\n-    break;\n-\n-  default:\n-    if (sig == PosixSignals::SR_signum) {\n-      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n-    } else {\n-      return;\n-    }\n-    break;\n-  }\n-\n-  if (thisHandler != jvmHandler) {\n-    tty->print(\"Warning: %s handler \", os::exception_name(sig, buf, O_BUFLEN));\n-    tty->print_raw(\"expected:\");\n-    print_signal_handler_name(tty, jvmHandler, buf, O_BUFLEN);\n-    tty->print_raw(\"  found:\");\n-    print_signal_handler_name(tty, thisHandler, buf, O_BUFLEN);\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n+  \/\/ Compare both sigaction structures (intelligently; only the members we care about).\n+  if (!compare_handler_info(&act, expected_act)) {\n+    tty->print_cr(\"Warning: %s handler modified!\", os::exception_name(sig, buf, sizeof(buf)));\n+    \/\/ If we had a mismatch:\n+    \/\/ - print all signal handlers. As part of that printout details will be printed\n+    \/\/   about any modified handlers.\n+    \/\/ - Disable any further checks for this signal - we do not want to flood stdout. Though\n+    \/\/   depending on which signal had been overwritten, we may die very soon anyway.\n+    os::print_signal_handlers(tty, buf, O_BUFLEN);\n+    do_check_signal_periodically[sig] = false;\n+    tty->print_cr(\"Consider using jsig library.\");\n@@ -821,1 +857,1 @@\n-      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n+      tty->print_cr(\"Note: Running in non-interactive shell, %s handler is replaced by shell\",\n@@ -824,15 +860,0 @@\n-  } else if (get_our_sigflags(sig) != 0 && (int)act.sa_flags != get_our_sigflags(sig)) {\n-    tty->print(\"Warning: %s handler flags \", os::exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:\");\n-    print_sa_flags(tty, get_our_sigflags(sig));\n-    tty->cr();\n-    tty->print(\"  found:\");\n-    print_sa_flags(tty, act.sa_flags);\n-    tty->cr();\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n-  }\n-\n-  \/\/ Dump all the signal\n-  if (sigismember(&check_signal_done, sig)) {\n-    os::print_signal_handlers(tty, buf, O_BUFLEN);\n@@ -860,1 +881,1 @@\n-  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n+  return get_signal_handler(&oldSigAct);\n@@ -872,6 +893,0 @@\n-static void do_signal_check(int signal) {\n-  if (!sigismember(&check_signal_done, signal)) {\n-    check_signal_handler(signal);\n-  }\n-}\n-\n@@ -880,1 +895,0 @@\n-\n@@ -889,7 +903,7 @@\n-  do_signal_check(SIGSEGV);\n-  do_signal_check(SIGILL);\n-  do_signal_check(SIGFPE);\n-  do_signal_check(SIGBUS);\n-  do_signal_check(SIGPIPE);\n-  do_signal_check(SIGXFSZ);\n-  PPC64_ONLY(do_signal_check(SIGTRAP);)\n+  check_signal_handler(SIGSEGV);\n+  check_signal_handler(SIGILL);\n+  check_signal_handler(SIGFPE);\n+  check_signal_handler(SIGBUS);\n+  check_signal_handler(SIGPIPE);\n+  check_signal_handler(SIGXFSZ);\n+  PPC64_ONLY(check_signal_handler(SIGTRAP);)\n@@ -900,4 +914,4 @@\n-    do_signal_check(SHUTDOWN1_SIGNAL);\n-    do_signal_check(SHUTDOWN2_SIGNAL);\n-    do_signal_check(SHUTDOWN3_SIGNAL);\n-    do_signal_check(BREAK_SIGNAL);\n+    check_signal_handler(SHUTDOWN1_SIGNAL);\n+    check_signal_handler(SHUTDOWN2_SIGNAL);\n+    check_signal_handler(SHUTDOWN3_SIGNAL);\n+    check_signal_handler(BREAK_SIGNAL);\n@@ -906,1 +920,1 @@\n-  do_signal_check(PosixSignals::SR_signum);\n+  check_signal_handler(PosixSignals::SR_signum);\n@@ -1206,0 +1220,2 @@\n+  \/\/ Query the current signal handler. Needs to be a separate operation\n+  \/\/ from installing a new handler since we need to honor AllowUserSignalHandlers.\n@@ -1207,3 +1223,2 @@\n-  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)javaSignalHandler)) {\n+  if (!HANDLER_IS_IGN_OR_DFL(oldhand) &&\n+      !HANDLER_IS(oldhand, javaSignalHandler)) {\n@@ -1215,1 +1230,1 @@\n-      save_preinstalled_handler(sig, oldAct);\n+      chained_handlers.set(sig, &oldAct);\n@@ -1242,3 +1257,3 @@\n-  \/\/ Save flags, which are set by ours\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigflags[sig] = sigAct.sa_flags;\n+  \/\/ Save handler setup for later checking\n+  expected_handlers.set(sig, &sigAct);\n+  do_check_signal_periodically[sig] = true;\n@@ -1251,0 +1266,1 @@\n+\n@@ -1349,4 +1365,3 @@\n-void PosixSignals::print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen) {\n-  struct sigaction sa;\n-  sigaction(sig, NULL, &sa);\n+static void print_single_signal_handler(outputStream* st,\n+                                        const struct sigaction* act,\n+                                        char* buf, size_t buflen) {\n@@ -1354,8 +1369,2 @@\n-  \/\/ See comment for SA_RESTORER_FLAG_MASK\n-  LINUX_ONLY(sa.sa_flags &= SA_RESTORER_FLAG_MASK;)\n-\n-  st->print(\"%10s: \", os::exception_name(sig, buf, buflen));\n-\n-  address handler = get_signal_handler(&sa);\n-\n-  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n+  address handler = get_signal_handler(act);\n+  if (HANDLER_IS_DFL(handler)) {\n@@ -1363,1 +1372,1 @@\n-  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n+  } else if (HANDLER_IS_IGN(handler)) {\n@@ -1366,1 +1375,1 @@\n-    print_signal_handler_name(st, handler, buf, O_BUFLEN);\n+    print_signal_handler_name(st, handler, buf, buflen);\n@@ -1369,2 +1378,2 @@\n-  st->print(\", sa_mask[0]=\");\n-  print_signal_set_short(st, &sa.sa_mask);\n+  st->print(\", mask=\");\n+  print_signal_set_short(st, &(act->sa_mask));\n@@ -1372,7 +1381,3 @@\n-  address rh = VMError::get_resetted_sighandler(sig);\n-  \/\/ May be, handler was resetted by VMError?\n-  if (rh != NULL) {\n-    handler = rh;\n-    \/\/ See comment for SA_RESTORER_FLAG_MASK\n-    sa.sa_flags = VMError::get_resetted_sigflags(sig) LINUX_ONLY(& SA_RESTORER_FLAG_MASK);\n-  }\n+  st->print(\", flags=\");\n+  int flags = get_sanitized_sa_flags(act);\n+  print_sa_flags(st, flags);\n@@ -1380,13 +1385,31 @@\n-  \/\/ Print textual representation of sa_flags.\n-  st->print(\", sa_flags=\");\n-  print_sa_flags(st, sa.sa_flags);\n-\n-  \/\/ Check: is it our handler?\n-  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler) ||\n-      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n-    \/\/ It is our signal handler\n-    \/\/ check for flags, reset system-used one!\n-    if ((int)sa.sa_flags != get_our_sigflags(sig)) {\n-      st->print(\n-                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n-                get_our_sigflags(sig));\n+}\n+\n+\/\/ Print established signal handler for this signal.\n+\/\/ - if this signal handler was installed by us and is chained to a pre-established user handler\n+\/\/    it replaced, print that one too.\n+\/\/ - otherwise, if this signal handler was installed by us and replaced another handler to which we\n+\/\/    are not chained (e.g. if chaining is off), print that one too.\n+void PosixSignals::print_signal_handler(outputStream* st, int sig,\n+                                        char* buf, size_t buflen) {\n+\n+  st->print(\"%10s: \", os::exception_name(sig, buf, buflen));\n+\n+  struct sigaction current_act;\n+  sigaction(sig, NULL, &current_act);\n+\n+  print_single_signal_handler(st, &current_act, buf, buflen);\n+  st->cr();\n+\n+  \/\/ If we expected to see our own hotspot signal handler but found a different one,\n+  \/\/  print a warning (unless the handler replacing it is our own crash handler, which can\n+  \/\/  happen if this function is called during error reporting).\n+  const struct sigaction* expected_act = expected_handlers.get(sig);\n+  if (expected_act != NULL) {\n+    const address current_handler = get_signal_handler(&current_act);\n+    if (!(HANDLER_IS(current_handler, VMError::crash_handler_address))) {\n+      if (!compare_handler_info(&current_act, expected_act)) {\n+        st->print_cr(\"  *** Handler was modified!\");\n+        st->print   (\"  *** Expected: \");\n+        print_single_signal_handler(st, expected_act, buf, buflen);\n+        st->cr();\n+      }\n@@ -1395,1 +1418,8 @@\n-  st->cr();\n+\n+  \/\/ If there is a chained handler waiting behind the current one, print it too.\n+  const struct sigaction* chained_act = get_chained_signal_action(sig);\n+  if (chained_act != NULL) {\n+    st->print(\"  chained to: \");\n+    print_single_signal_handler(st, &current_act, buf, buflen);\n+    st->cr();\n+  }\n@@ -1424,2 +1454,1 @@\n-  void* ohlr = get_signal_handler(&oact);\n-  if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN)) {\n+  if (HANDLER_IS_IGN(get_signal_handler(&oact))) {\n@@ -1675,2 +1704,4 @@\n-  \/\/ Save signal flag\n-  set_our_sigflags(PosixSignals::SR_signum, act.sa_flags);\n+  \/\/ Save signal setup information for later checking.\n+  expected_handlers.set(PosixSignals::SR_signum, &act);\n+  do_check_signal_periodically[PosixSignals::SR_signum] = true;\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":198,"deletions":167,"binary":false,"changes":365,"status":"modified"},{"patch":"@@ -52,10 +52,0 @@\n-\/\/ handle all synchronous program error signals which may happen during error\n-\/\/ reporting. They must be unblocked, caught, handled.\n-\n-static const int SIGNALS[] = { SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP }; \/\/ add more if needed\n-static const int NUM_SIGNALS = sizeof(SIGNALS) \/ sizeof(int);\n-\n-\/\/ Space for our \"saved\" signal flags and handlers\n-static int resettedSigflags[NUM_SIGNALS];\n-static address resettedSighandler[NUM_SIGNALS];\n-\n@@ -77,28 +67,0 @@\n-static void save_signal(int idx, int sig)\n-{\n-  struct sigaction sa;\n-  sigaction(sig, NULL, &sa);\n-  resettedSigflags[idx]   = sa.sa_flags;\n-  resettedSighandler[idx] = (sa.sa_flags & SA_SIGINFO)\n-                              ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n-                              : CAST_FROM_FN_PTR(address, sa.sa_handler);\n-}\n-\n-int VMError::get_resetted_sigflags(int sig) {\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    if (SIGNALS[i] == sig) {\n-      return resettedSigflags[i];\n-    }\n-  }\n-  return -1;\n-}\n-\n-address VMError::get_resetted_sighandler(int sig) {\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    if (SIGNALS[i] == sig) {\n-      return resettedSighandler[i];\n-    }\n-  }\n-  return NULL;\n-}\n-\n@@ -136,0 +98,2 @@\n+const void* VMError::crash_handler_address = CAST_FROM_FN_PTR(void *, crash_handler);\n+\n@@ -137,3 +101,6 @@\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    save_signal(i, SIGNALS[i]);\n-    os::signal(SIGNALS[i], CAST_FROM_FN_PTR(void *, crash_handler));\n+  static const int signals_to_handle[] = {\n+    SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP,\n+    0 \/\/ end\n+  };\n+  for (int i = 0; signals_to_handle[i] != 0; i++) {\n+    os::signal(signals_to_handle[i], CAST_FROM_FN_PTR(void *, crash_handler));\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":8,"deletions":41,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -32,8 +32,0 @@\n-int VMError::get_resetted_sigflags(int sig) {\n-  return -1;\n-}\n-\n-address VMError::get_resetted_sighandler(int sig) {\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -163,8 +163,0 @@\n-  \/\/ returns original flags for signal, if it was resetted, or -1 if\n-  \/\/ signal was not changed by error reporter\n-  static int get_resetted_sigflags(int sig);\n-\n-  \/\/ returns original handler for signal, if it was resetted, or NULL if\n-  \/\/ signal was not changed by error reporter\n-  static address get_resetted_sighandler(int sig);\n-\n@@ -188,0 +180,3 @@\n+  \/\/ Needed when printing signal handlers.\n+  NOT_WINDOWS(static const void* crash_handler_address;)\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"}]}