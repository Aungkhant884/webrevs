{"files":[{"patch":"@@ -1182,2 +1182,1 @@\n-      \/\/ supported. Clear the _java_mirror within the archived class.\n-      k->clear_java_mirror_handle();\n+      \/\/ supported.\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+intx ArchiveBuilder::_buffer_to_target_delta = 0;\n@@ -567,0 +568,28 @@\n+void ArchiveBuilder::make_klasses_shareable() {\n+  for (int i = 0; i < klasses()->length(); i++) {\n+    Klass* k = klasses()->at(i);\n+    k->remove_java_mirror();\n+    if (k->is_objArray_klass()) {\n+      \/\/ InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info\n+      \/\/ on their array classes.\n+    } else if (k->is_typeArray_klass()) {\n+      k->remove_unshareable_info();\n+    } else {\n+      assert(k->is_instance_klass(), \" must be\");\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      if (DynamicDumpSharedSpaces) {\n+        \/\/ For static dump, class loader type are already set.\n+        ik->assign_class_loader_type();\n+      }\n+\n+      MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread::current(), ik);\n+      ik->remove_unshareable_info();\n+\n+      if (log_is_enabled(Debug, cds, class)) {\n+        ResourceMark rm;\n+        log_debug(cds, class)(\"klasses[%4d] = \" PTR_FORMAT \" %s\", i, p2i(to_target(ik)), ik->external_name());\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -196,0 +196,31 @@\n+protected:\n+  DumpRegion* _current_dump_space;\n+  address _alloc_bottom;\n+\n+  DumpRegion* current_dump_space() const {  return _current_dump_space;  }\n+\n+public:\n+  void set_current_dump_space(DumpRegion* r) { _current_dump_space = r; }\n+\n+  bool is_in_buffer_space(address p) const {\n+    return (_alloc_bottom <= p && p < (address)current_dump_space()->top());\n+  }\n+\n+  template <typename T> bool is_in_target_space(T target_obj) const {\n+    address buff_obj = address(target_obj) - _buffer_to_target_delta;\n+    return is_in_buffer_space(buff_obj);\n+  }\n+\n+  template <typename T> bool is_in_buffer_space(T obj) const {\n+    return is_in_buffer_space(address(obj));\n+  }\n+\n+  template <typename T> T to_target_no_check(T obj) const {\n+    return (T)(address(obj) + _buffer_to_target_delta);\n+  }\n+\n+  template <typename T> T to_target(T obj) const {\n+    assert(is_in_buffer_space(obj), \"must be\");\n+    return (T)(address(obj) + _buffer_to_target_delta);\n+  }\n+\n@@ -211,1 +242,1 @@\n-\n+  void make_klasses_shareable();\n@@ -238,0 +269,1 @@\n+  static intx _buffer_to_target_delta;\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-  static intx _buffer_to_target_delta;\n-  DumpRegion* _current_dump_space;\n@@ -62,26 +60,0 @@\n-  DumpRegion* current_dump_space() const {\n-    return _current_dump_space;\n-  }\n-\n-  bool is_in_buffer_space(address p) const {\n-    return (_alloc_bottom <= p && p < (address)current_dump_space()->top());\n-  }\n-\n-  template <typename T> bool is_in_target_space(T target_obj) const {\n-    address buff_obj = address(target_obj) - _buffer_to_target_delta;\n-    return is_in_buffer_space(buff_obj);\n-  }\n-\n-  template <typename T> bool is_in_buffer_space(T obj) const {\n-    return is_in_buffer_space(address(obj));\n-  }\n-\n-  template <typename T> T to_target_no_check(T obj) const {\n-    return (T)(address(obj) + _buffer_to_target_delta);\n-  }\n-\n-  template <typename T> T to_target(T obj) const {\n-    assert(is_in_buffer_space(obj), \"must be\");\n-    return (T)(address(obj) + _buffer_to_target_delta);\n-  }\n-\n@@ -116,1 +88,0 @@\n-  address _alloc_bottom;\n@@ -131,1 +102,1 @@\n-  void make_klasses_shareable();\n+  void sort_methods();\n@@ -253,0 +224,1 @@\n+    sort_methods();\n@@ -278,2 +250,0 @@\n-intx DynamicArchiveBuilder::_buffer_to_target_delta;\n-\n@@ -411,3 +381,1 @@\n-void DynamicArchiveBuilder::make_klasses_shareable() {\n-  int i, count = klasses()->length();\n-\n+void DynamicArchiveBuilder::sort_methods() {\n@@ -415,1 +383,1 @@\n-  for (i = 0; i < count; i++) {\n+  for (int i = 0; i < klasses()->length(); i++) {\n@@ -421,19 +389,0 @@\n-\n-  for (i = 0; i < count; i++) {\n-    Klass* k = klasses()->at(i);\n-    if (!k->is_instance_klass()) {\n-      continue;\n-    }\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    ik->assign_class_loader_type();\n-\n-    MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread::current(), ik);\n-    ik->remove_unshareable_info();\n-\n-    assert(ik->array_klasses() == NULL, \"sanity\");\n-\n-    if (log_is_enabled(Debug, cds, dynamic)) {\n-      ResourceMark rm;\n-      log_debug(cds, dynamic)(\"klasses[%4i] = \" PTR_FORMAT \" %s\", i, p2i(to_target(ik)), ik->external_name());\n-    }\n-  }\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":4,"deletions":55,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"memory\/archiveBuilder.hpp\"\n@@ -401,1 +402,1 @@\n-  assert(relocated_k->is_shared(), \"must be a shared class\");\n+  assert(ArchiveBuilder::singleton()->is_in_buffer_space(relocated_k), \"must be a shared class\");\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -547,24 +547,0 @@\n-static void remove_unshareable_in_classes() {\n-  for (int i = 0; i < _global_klass_objects->length(); i++) {\n-    Klass* k = _global_klass_objects->at(i);\n-    if (!k->is_objArray_klass()) {\n-      \/\/ InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info\n-      \/\/ on their array classes.\n-      assert(k->is_instance_klass() || k->is_typeArray_klass(), \"must be\");\n-      k->remove_unshareable_info();\n-    }\n-  }\n-}\n-\n-static void remove_java_mirror_in_classes() {\n-  for (int i = 0; i < _global_klass_objects->length(); i++) {\n-    Klass* k = _global_klass_objects->at(i);\n-    if (!k->is_objArray_klass()) {\n-      \/\/ InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info\n-      \/\/ on their array classes.\n-      assert(k->is_instance_klass() || k->is_typeArray_klass(), \"must be\");\n-      k->remove_java_mirror();\n-    }\n-  }\n-}\n-\n@@ -590,2 +566,0 @@\n-\/\/ Walk all methods in the class list to ensure that they won't be modified at\n-\/\/ run time. This includes:\n@@ -595,10 +569,0 @@\n-static void rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread) {\n-  for (int i = 0; i < _global_klass_objects->length(); i++) {\n-    Klass* k = _global_klass_objects->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(thread, ik);\n-    }\n-  }\n-}\n-\n@@ -648,1 +612,4 @@\n-    : ArchiveBuilder(rw_region, ro_region) {}\n+    : ArchiveBuilder(rw_region, ro_region) {\n+    _alloc_bottom = address(SharedBaseAddress);\n+    _buffer_to_target_delta = 0;\n+  }\n@@ -672,7 +639,0 @@\n-  log_info(cds)(\"Removing java_mirror ... \");\n-  if (!HeapShared::is_heap_object_archiving_allowed()) {\n-    Universe::clear_basic_type_mirrors();\n-  }\n-  remove_java_mirror_in_classes();\n-  log_info(cds)(\"done. \");\n-\n@@ -768,0 +728,1 @@\n+  builder.set_current_dump_space(&_mc_region);\n@@ -771,10 +732,0 @@\n-  \/\/ Ensure the ConstMethods won't be modified at run-time\n-  log_info(cds)(\"Updating ConstMethods ... \");\n-  rewrite_nofast_bytecodes_and_calculate_fingerprints(THREAD);\n-  log_info(cds)(\"done. \");\n-\n-  \/\/ Remove all references outside the metadata\n-  log_info(cds)(\"Removing unshareable information ... \");\n-  remove_unshareable_in_classes();\n-  log_info(cds)(\"done. \");\n-\n@@ -789,0 +740,1 @@\n+    builder.set_current_dump_space(&_rw_region);\n@@ -801,0 +753,1 @@\n+    builder.set_current_dump_space(&_ro_region);\n@@ -821,0 +774,3 @@\n+  log_info(cds)(\"Make classes shareable\");\n+  builder.make_klasses_shareable();\n+\n@@ -874,3 +830,3 @@\n-  \/\/ There may be other pending VM operations that operate on the InstanceKlasses,\n-  \/\/ which will fail because InstanceKlasses::remove_unshareable_info()\n-  \/\/ has been called. Forget these operations and exit the VM directly.\n+  \/\/ There may be pending VM operations. We have changed some global states\n+  \/\/ (such as SystemDictionary::_well_known_klasses) that may cause these VM operations\n+  \/\/ to fail. For safety, forget these operations and exit the VM directly.\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":13,"deletions":57,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -188,9 +188,0 @@\n-\/\/ Not sure why CDS has to do this\n-void Universe::clear_basic_type_mirrors() {\n-  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-    if (!is_reference_type((BasicType)i)) {\n-      Universe::_mirrors[i].replace(NULL);\n-    }\n-  }\n-}\n-\n@@ -248,1 +239,5 @@\n-        mirror_oop = _mirrors[i].resolve();\n+        if (HeapShared::is_heap_object_archiving_allowed()) {\n+          mirror_oop = _mirrors[i].resolve();\n+        } else {\n+          mirror_oop = NULL;\n+        }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -235,1 +235,0 @@\n-  static void clear_basic_type_mirrors();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-    set_resolved_references(OopHandle());\n@@ -319,1 +318,0 @@\n-    set_resolved_references(OopHandle());\n@@ -399,9 +397,1 @@\n-\n-  \/\/ If archiving heap objects is not allowed, clear the resolved references.\n-  \/\/ Otherwise, it is cleared after the resolved references array is cached\n-  \/\/ (see archive_resolved_references()).\n-  \/\/ If DynamicDumpSharedSpaces is enabled, clear the resolved references also\n-  \/\/ as java objects are not archived in the top layer.\n-  if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {\n-    set_resolved_references(OopHandle());\n-  }\n+  set_resolved_references(OopHandle());\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"}]}