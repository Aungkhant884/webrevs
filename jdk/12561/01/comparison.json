{"files":[{"patch":"@@ -1780,2 +1780,0 @@\n-  G1CMOopClosure _cm_cl;\n-  MarkingCodeBlobClosure _code_cl;\n@@ -1785,3 +1783,1 @@\n-    _qset(G1BarrierSet::satb_mark_queue_set()),\n-    _cm_cl(g1h, task),\n-    _code_cl(&_cm_cl, !CodeBlobToOopClosure::FixRelocations, true \/* keepalive nmethods *\/) {}\n+    _qset(G1BarrierSet::satb_mark_queue_set()) {}\n@@ -1792,9 +1788,0 @@\n-    if (thread->is_Java_thread()) {\n-      \/\/ In theory it should not be necessary to explicitly walk the nmethods to find roots for concurrent marking\n-      \/\/ however the liveness of oops reachable from nmethods have very complex lifecycles:\n-      \/\/ * Alive if on the stack of an executing method\n-      \/\/ * Weakly reachable otherwise\n-      \/\/ Some objects reachable from nmethods, such as the class loader (or klass_holder) of the receiver should be\n-      \/\/ live by the SATB invariant but other oops recorded in nmethods may behave differently.\n-      JavaThread::cast(thread)->nmethods_do(&_code_cl);\n-    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  \/\/ Also, with concurrent GC, it is possible that frames in continuation stack\n+  \/\/ chunks are not visited if they are allocated after concurrent GC started.\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}