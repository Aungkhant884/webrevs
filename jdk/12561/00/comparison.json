{"files":[{"patch":"@@ -1780,2 +1780,0 @@\n-  G1CMOopClosure _cm_cl;\n-  MarkingCodeBlobClosure _code_cl;\n@@ -1785,3 +1783,1 @@\n-    _qset(G1BarrierSet::satb_mark_queue_set()),\n-    _cm_cl(g1h, task),\n-    _code_cl(&_cm_cl, !CodeBlobToOopClosure::FixRelocations, true \/* keepalive nmethods *\/) {}\n+    _qset(G1BarrierSet::satb_mark_queue_set()) {}\n@@ -1792,9 +1788,0 @@\n-    if (thread->is_Java_thread()) {\n-      \/\/ In theory it should not be necessary to explicitly walk the nmethods to find roots for concurrent marking\n-      \/\/ however the liveness of oops reachable from nmethods have very complex lifecycles:\n-      \/\/ * Alive if on the stack of an executing method\n-      \/\/ * Weakly reachable otherwise\n-      \/\/ Some objects reachable from nmethods, such as the class loader (or klass_holder) of the receiver should be\n-      \/\/ live by the SATB invariant but other oops recorded in nmethods may behave differently.\n-      JavaThread::cast(thread)->nmethods_do(&_code_cl);\n-    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -60,2 +60,5 @@\n-    \/\/ The GC needs nmethod entry barriers to deal with continuations\n-    \/\/ and code cache unloading\n+    \/\/ The GC needs nmethod entry barriers for code cache unloading.\n+    \/\/ Concurrent GC needs them also for preserving the weakly referenced objects in\n+    \/\/ the constant pool of nmethods as part of the SATB snapshot, and to deal with\n+    \/\/ compiled frames contained in continuation stack chunks allocated after\n+    \/\/ concurent mark start.\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}