{"files":[{"patch":"@@ -35,0 +35,2 @@\n+#elif defined(_ALLBSD_SOURCE)\n+#include <copyfile.h>\n@@ -36,1 +38,0 @@\n-\n@@ -53,0 +54,17 @@\n+#if defined(_ALLBSD_SOURCE)\n+int fcopyfile_callback(int what, int stage, copyfile_state_t state,\n+    const char* src, const char* dst, void* cancel)\n+{\n+    if (what == COPYFILE_COPY_DATA) {\n+        if (stage == COPYFILE_ERR\n+                || (stage == COPYFILE_PROGRESS && *((int*)cancel) != 0)) {\n+            \/\/ errno will be set to ECANCELED if the operation is cancelled,\n+            \/\/ or to the appropriate error number if there is an error,\n+            \/\/ but in either case we need to quit.\n+            return COPYFILE_QUIT;\n+        }\n+    }\n+    return COPYFILE_CONTINUE;\n+}\n+#endif\n+\n@@ -65,1 +83,3 @@\n-    const size_t count = 1048576; \/\/ 1 MB to give cancellation a chance\n+    const size_t count = cancel != NULL ?\n+        1048576 :   \/\/ 1 MB to give cancellation a chance\n+        0x7ffff000; \/\/ maximum number of bytes that sendfile() can transfer\n@@ -68,1 +88,0 @@\n-        \/\/ sendfile() can transfer at most 0x7ffff000 bytes\n@@ -79,0 +98,18 @@\n+#elif defined(_ALLBSD_SOURCE)\n+    copyfile_state_t state;\n+    if (cancel != NULL) {\n+        state = copyfile_state_alloc();\n+        copyfile_state_set(state, COPYFILE_STATE_STATUS_CB, fcopyfile_callback);\n+        copyfile_state_set(state, COPYFILE_STATE_STATUS_CTX, (void*)cancel);\n+    } else {\n+        state = NULL;\n+    }\n+    if (fcopyfile(src, dst, state, COPYFILE_DATA) < 0) {\n+        int errno_fcopyfile = errno;\n+        if (state != NULL)\n+            copyfile_state_free(state);\n+        throwUnixException(env, errno_fcopyfile);\n+        return;\n+    }\n+    if (state != NULL)\n+        copyfile_state_free(state);\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"}]}