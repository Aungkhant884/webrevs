{"files":[{"patch":"@@ -1198,0 +1198,101 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register temp_itbl_klass,\n+                                                  Register scan_temp,\n+                                                  Register holder_offset,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  assert_different_registers(resolved_klass, recv_klass, holder_klass, temp_itbl_klass, scan_temp, holder_offset);\n+  assert_different_registers(method_result, recv_klass, holder_klass, temp_itbl_klass, scan_temp, holder_offset);\n+\n+  int vtable_base = in_bytes(Klass::vtable_start_offset());\n+  int itentry_off = in_bytes(itableMethodEntry::method_offset());\n+  int scan_step = itableOffsetEntry::size() * wordSize;\n+  int vte_size = vtableEntry::size_in_bytes();\n+  int ioffset = in_bytes(itableOffsetEntry::interface_offset());\n+  int ooffset = in_bytes(itableOffsetEntry::offset_offset());\n+  assert(vte_size == wordSize, \"else adjust times_vte_scale\");\n+\n+  Label L_loop_scan_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  \/\/ temp_itbl_klass = recv_klass.itable[0]\n+  \/\/ scan_temp = &recv_klass.itable[0]\n+  ldrw(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  add(recv_klass, recv_klass, vtable_base + ioffset);\n+  ldr(temp_itbl_klass, Address(recv_klass, scan_temp, Address::lsl(3)));\n+  mov(holder_offset, zr);\n+  lea(scan_temp, Address(recv_klass, scan_temp, Address::lsl(3)));\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  cmp(resolved_klass, holder_klass);\n+  br(Assembler::NE, L_loop_scan_resolved_entry);\n+  cmp(holder_klass, temp_itbl_klass);\n+  br(Assembler::EQ, L_holder_found);\n+  cbz(temp_itbl_klass, L_no_such_interface);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     temp_itbl_klass = *(scan_temp += scan_step);\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/       goto L_holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (temp_itbl_klass != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  Label L_scan_holder;\n+  bind(L_scan_holder);\n+    ldr(temp_itbl_klass, Address(pre(scan_temp, scan_step)));\n+    cmp(holder_klass, temp_itbl_klass);\n+    br(Assembler::EQ, L_holder_found);\n+    cbnz(temp_itbl_klass, L_scan_holder);\n+\n+  b(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   do {\n+  \/\/     temp_itbl_klass = *(scan_temp += scan_step);\n+  \/\/     if (temp_itbl_klass == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/        holder_offset = scan_temp;\n+  \/\/     }\n+  \/\/   } while (temp_itbl_klass != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  \/\/\n+  Label L_loop_scan_resolved;\n+  bind(L_loop_scan_resolved);\n+    ldr(temp_itbl_klass, Address(pre(scan_temp, scan_step)));\n+  bind(L_loop_scan_resolved_entry);\n+    cmp(resolved_klass, temp_itbl_klass);\n+    br(Assembler::EQ, L_resolved_found);\n+    cmp(holder_klass, temp_itbl_klass);\n+    br(Assembler::NE, L_loop_scan_resolved);\n+    mov(holder_offset, scan_temp);\n+    cbnz(temp_itbl_klass, L_loop_scan_resolved);\n+\n+  b(L_no_such_interface);\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  cbz(holder_offset, L_scan_holder);\n+  mov(scan_temp, holder_offset);\n+\n+  \/\/ Finally, scan_temp contains holder_klass vtable offset\n+  bind(L_holder_found);\n+  ldrw(method_result, Address(scan_temp, ooffset - ioffset));\n+  add(recv_klass, recv_klass, (itable_index << 3) + itentry_off - (vtable_base + ioffset));\n+  ldr(method_result, Address(recv_klass, method_result, Address::uxtw(0)));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -945,0 +945,10 @@\n+  void lookup_interface_method_stub(Register recv_klass,\n+                                    Register holder_klass,\n+                                    Register resolved_klass,\n+                                    Register method_result,\n+                                    Register temp_reg,\n+                                    Register temp_reg2,\n+                                    Register temp_reg3,\n+                                    int itable_index,\n+                                    Label& L_no_such_interface);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  const Register temp_reg3          = r17;\n@@ -195,10 +196,0 @@\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             temp_reg2, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t  typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n@@ -206,5 +197,2 @@\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             rmethod, temp_reg,\n-                             L_no_such_interface);\n+  __ lookup_interface_method_stub(recv_klass_reg, holder_klass_reg, resolved_klass_reg, rmethod,\n+                                  temp_reg, temp_reg2, temp_reg3, itable_index, L_no_such_interface);\n@@ -216,1 +204,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize;\n+  const ptrdiff_t codesize = lookupSize;\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"}]}