{"files":[{"patch":"@@ -576,0 +576,6 @@\n+char* ArchiveBuilder::ro_strdup(const char* s) {\n+  char* archived_str = ro_region_alloc((int)strlen(s) + 1);\n+  strcpy(archived_str, s);\n+  return archived_str;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -377,0 +377,2 @@\n+  char* ro_strdup(const char* s);\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  {\"jdk\/internal\/module\/ArchivedBootLayer\",       \"archivedBootLayer\"},\n+  {ARCHIVED_BOOT_LAYER_CLASS,                     ARCHIVED_BOOT_LAYER_FIELD},\n@@ -1753,0 +1753,22 @@\n+bool HeapShared::is_archived_boot_layer_available(JavaThread* current) {\n+  TempNewSymbol klass_name = SymbolTable::new_symbol(ARCHIVED_BOOT_LAYER_CLASS);\n+  InstanceKlass* k = SystemDictionary::find_instance_klass(current, klass_name, Handle(), Handle());\n+  if (k == nullptr) {\n+    return false;\n+  } else {\n+    TempNewSymbol field_name = SymbolTable::new_symbol(ARCHIVED_BOOT_LAYER_FIELD);\n+    TempNewSymbol field_signature = SymbolTable::new_symbol(\"Ljdk\/internal\/module\/ArchivedBootLayer;\");\n+    fieldDescriptor fd;\n+    if (k->find_field(field_name, field_signature, true, &fd) != nullptr) {\n+      oop m = k->java_mirror();\n+      oop f = m->obj_field(fd.offset());\n+      if (CompressedOops::is_null(f)) {\n+        return false;\n+      }\n+    } else {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+#define ARCHIVED_BOOT_LAYER_CLASS \"jdk\/internal\/module\/ArchivedBootLayer\"\n+#define ARCHIVED_BOOT_LAYER_FIELD \"archivedBootLayer\"\n+\n@@ -163,0 +166,1 @@\n+  static bool is_archived_boot_layer_available(JavaThread* current) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"classfile\/modules.hpp\"\n@@ -388,0 +389,1 @@\n+  CDS_JAVA_HEAP_ONLY(Modules::serialize(soc);)\n@@ -480,0 +482,2 @@\n+  \/\/ Write module name into archive\n+  CDS_JAVA_HEAP_ONLY(Modules::dump_main_module_name();)\n@@ -778,0 +782,4 @@\n+  if (!HeapShared::is_archived_boot_layer_available(THREAD)) {\n+    log_info(cds)(\"archivedBootLayer not available, disabling full module graph\");\n+    disable_full_module_graph();\n+  }\n@@ -1162,2 +1170,2 @@\n-    log_info(cds)(\"optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"initial optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"initial full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -562,0 +563,43 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+char* Modules::_archived_main_module_name = nullptr;\n+#endif\n+\n+void Modules::dump_main_module_name() {\n+  const char* module_name = Arguments::get_property(\"jdk.module.main\");\n+  if (module_name != nullptr) {\n+    _archived_main_module_name = ArchiveBuilder::current()->ro_strdup(module_name);\n+  }\n+  ArchivePtrMarker::mark_pointer(&_archived_main_module_name);\n+}\n+\n+void Modules::serialize(SerializeClosure* soc) {\n+  soc->do_ptr(&_archived_main_module_name);\n+  if (soc->reading()) {\n+    const char* runtime_main_module = Arguments::get_property(\"jdk.module.main\");\n+    log_info(cds)(\"_archived_main_module_name %s\",\n+      _archived_main_module_name != nullptr ? _archived_main_module_name : \"(null)\");\n+    bool disable = false;\n+    if (runtime_main_module == nullptr) {\n+      if (_archived_main_module_name != nullptr) {\n+        log_info(cds)(\"Module %s specified during dump time but not during runtime\", _archived_main_module_name);\n+        disable = true;\n+      }\n+    } else {\n+      if (_archived_main_module_name == nullptr) {\n+        log_info(cds)(\"Module %s specified during runtime but not during dump time\", runtime_main_module);\n+        disable = true;\n+      } else if (strcmp(runtime_main_module, _archived_main_module_name) != 0) {\n+        log_info(cds)(\"Mismatched modules: runtime %s dump time %s\", runtime_main_module, _archived_main_module_name);\n+        disable = true;\n+      }\n+    }\n+\n+    if (disable) {\n+      log_info(cds)(\"Disabling optimized module handling\");\n+      MetaspaceShared::disable_optimized_module_handling();\n+    }\n+    log_info(cds)(\"optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -62,0 +62,6 @@\n+  static void dump_main_module_name() NOT_CDS_JAVA_HEAP_RETURN;\n+  static void serialize(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static char* _archived_main_module_name;\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1261,2 +1261,1 @@\n-  if (is_internal_module_property(key) ||\n-      strcmp(key, \"jdk.module.main\") == 0) {\n+  if (is_internal_module_property(key)) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    private static final boolean isDumpingStaticArchive;\n@@ -51,0 +52,1 @@\n+        isDumpingStaticArchive = isDumpingArchive && !isSharingEnabled;\n@@ -74,0 +76,7 @@\n+    \/**\n+      * Is dumping static archive.\n+      *\/\n+    public static boolean isDumpingStaticArchive() {\n+        return isDumpingStaticArchive;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -144,1 +144,0 @@\n-               getProperty(\"jdk.module.main\") == null &&          \/\/ --module\n@@ -472,0 +471,16 @@\n+        \/\/ If -Xshare:dump and mainModule are specified, check if the mainModule\n+        \/\/ is in the runtime image and not on the upgrade module path. If so,\n+        \/\/ set canArchive to true so that the module graph can be archived.\n+        if (CDS.isDumpingStaticArchive() && mainModule != null) {\n+            String scheme = systemModuleFinder.find(mainModule)\n+                    .stream()\n+                    .map(ModuleReference::location)\n+                    .flatMap(Optional::stream)\n+                    .findAny()\n+                    .map(URI::getScheme)\n+                    .orElse(null);\n+            if (\"jrt\".equalsIgnoreCase(scheme)) {\n+                canArchive = true;\n+            }\n+        }\n+\n@@ -473,2 +488,1 @@\n-        \/\/ Only allow the unnamed module case for now.\n-        if (canArchive && (mainModule == null)) {\n+        if (canArchive) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8316969\n+ * @summary Test handling of module option (-m).\n+ * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @run driver ModuleOption\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ModuleOption {\n+    public static void main(String[] args) throws Exception {\n+        final String moduleOption = \"jdk.httpserver\/sun.net.httpserver.simpleserver.Main\";\n+        final String incubatorModule = \"jdk.incubator.vector\";\n+        final String loggingOption = \"-Xlog:cds=debug,cds+module=debug,module=trace\";\n+        final String versionPattern = \"java.[0-9][0-9][-].*\";\n+        String archiveName = TestCommon.getNewArchiveName(\"module-option\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+\n+        \/\/ dump a base archive with -m jdk.httpserver\n+        OutputAnalyzer oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ same module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          \/\/ version of the jdk.httpserver module, e.g. java 22-ea\n+          .shouldMatch(versionPattern)\n+          .shouldMatch(\"cds,module.*Restored from archive: entry.0x.*name jdk.httpserver\");\n+\n+        \/\/ different module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-m\", \"jdk.compiler\/com.sun.tools.javac.Main\",\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Mismatched modules: runtime jdk.compiler dump time jdk.httpserver\");\n+\n+        \/\/ no module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Module jdk.httpserver specified during dump time but not during runtime\");\n+\n+        \/\/ dump an archive without the module option\n+        archiveName = TestCommon.getNewArchiveName(\"no-module-option\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+        oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ run with module option\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Module jdk.httpserver specified during runtime but not during dump time\")\n+          \/\/ version of the jdk.httpserver module, e.g. java 22-ea\n+          .shouldMatch(versionPattern);\n+\n+        \/\/ dump an archive with an incubator module, -m jdk.incubator.vector\n+        archiveName = TestCommon.getNewArchiveName(\"incubator-module\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+        oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"-m\", incubatorModule,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          \/\/ module graph won't be archived with an incubator module\n+          .shouldContain(\"archivedBootLayer not available, disabling full module graph\");\n+\n+        \/\/ run with the same incubator module\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-m\", incubatorModule,\n+            \"-version\");\n+        oa.shouldContain(\"full module graph: disabled\")\n+          \/\/ module is not restored from archive\n+          .shouldContain(\"define_module(): creation of module: jdk.incubator.vector\")\n+          .shouldContain(\"WARNING: Using incubator modules: jdk.incubator.vector\")\n+          .shouldContain(\"module jdk.incubator.vector does not have a ModuleMainClass attribute, use -m <module>\/<main-class>\")\n+          .shouldHaveExitValue(1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/module\/ModuleOption.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}