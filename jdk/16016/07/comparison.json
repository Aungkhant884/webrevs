{"files":[{"patch":"@@ -576,0 +576,6 @@\n+char* ArchiveBuilder::ro_strdup(const char* s) {\n+  char* archived_str = ro_region_alloc((int)strlen(s) + 1);\n+  strcpy(archived_str, s);\n+  return archived_str;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -377,0 +377,2 @@\n+  char* ro_strdup(const char* s);\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+  {\"jdk\/internal\/module\/ArchivedModuleGraph\",     \"mainModule\"},\n@@ -128,1 +129,1 @@\n-  {\"jdk\/internal\/module\/ArchivedBootLayer\",       \"archivedBootLayer\"},\n+  {ARCHIVED_BOOT_LAYER_CLASS,                     ARCHIVED_BOOT_LAYER_FIELD},\n@@ -967,1 +968,8 @@\n-  if (record != nullptr) {\n+  if (record == nullptr) {\n+    if (log_is_enabled(Info, cds, heap)) {\n+      ResourceMark rm(THREAD);\n+      log_info(cds, heap)(\"subgraph %s is not recorded\",\n+                          k->external_name());\n+    }\n+    return nullptr;\n+  } else {\n@@ -1754,0 +1762,22 @@\n+bool HeapShared::is_archived_boot_layer_available(JavaThread* current) {\n+  TempNewSymbol klass_name = SymbolTable::new_symbol(ARCHIVED_BOOT_LAYER_CLASS);\n+  InstanceKlass* k = SystemDictionary::find_instance_klass(current, klass_name, Handle(), Handle());\n+  if (k == nullptr) {\n+    return false;\n+  } else {\n+    TempNewSymbol field_name = SymbolTable::new_symbol(ARCHIVED_BOOT_LAYER_FIELD);\n+    TempNewSymbol field_signature = SymbolTable::new_symbol(\"Ljdk\/internal\/module\/ArchivedBootLayer;\");\n+    fieldDescriptor fd;\n+    if (k->find_field(field_name, field_signature, true, &fd) != nullptr) {\n+      oop m = k->java_mirror();\n+      oop f = m->obj_field(fd.offset());\n+      if (CompressedOops::is_null(f)) {\n+        return false;\n+      }\n+    } else {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+#define ARCHIVED_BOOT_LAYER_CLASS \"jdk\/internal\/module\/ArchivedBootLayer\"\n+#define ARCHIVED_BOOT_LAYER_FIELD \"archivedBootLayer\"\n+\n@@ -163,0 +166,1 @@\n+  static bool is_archived_boot_layer_available(JavaThread* current) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"classfile\/modules.hpp\"\n@@ -390,0 +391,1 @@\n+  CDS_JAVA_HEAP_ONLY(Modules::serialize(soc);)\n@@ -482,0 +484,2 @@\n+  \/\/ Write module name into archive\n+  CDS_JAVA_HEAP_ONLY(Modules::dump_main_module_name();)\n@@ -766,2 +770,0 @@\n-  HeapShared::init_for_dumping(CHECK);\n-\n@@ -781,0 +783,5 @@\n+    if (!HeapShared::is_archived_boot_layer_available(THREAD)) {\n+      log_info(cds)(\"archivedBootLayer not available, disabling full module graph\");\n+      disable_full_module_graph();\n+    }\n+    HeapShared::init_for_dumping(CHECK);\n@@ -1166,2 +1173,2 @@\n-    log_info(cds)(\"optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"initial optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"initial full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -562,0 +563,43 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+char* Modules::_archived_main_module_name = nullptr;\n+#endif\n+\n+void Modules::dump_main_module_name() {\n+  const char* module_name = Arguments::get_property(\"jdk.module.main\");\n+  if (module_name != nullptr) {\n+    _archived_main_module_name = ArchiveBuilder::current()->ro_strdup(module_name);\n+  }\n+  ArchivePtrMarker::mark_pointer(&_archived_main_module_name);\n+}\n+\n+void Modules::serialize(SerializeClosure* soc) {\n+  soc->do_ptr(&_archived_main_module_name);\n+  if (soc->reading()) {\n+    const char* runtime_main_module = Arguments::get_property(\"jdk.module.main\");\n+    log_info(cds)(\"_archived_main_module_name %s\",\n+      _archived_main_module_name != nullptr ? _archived_main_module_name : \"(null)\");\n+    bool disable = false;\n+    if (runtime_main_module == nullptr) {\n+      if (_archived_main_module_name != nullptr) {\n+        log_info(cds)(\"Module %s specified during dump time but not during runtime\", _archived_main_module_name);\n+        disable = true;\n+      }\n+    } else {\n+      if (_archived_main_module_name == nullptr) {\n+        log_info(cds)(\"Module %s specified during runtime but not during dump time\", runtime_main_module);\n+        disable = true;\n+      } else if (strcmp(runtime_main_module, _archived_main_module_name) != 0) {\n+        log_info(cds)(\"Mismatched modules: runtime %s dump time %s\", runtime_main_module, _archived_main_module_name);\n+        disable = true;\n+      }\n+    }\n+\n+    if (disable) {\n+      log_info(cds)(\"Disabling optimized module handling\");\n+      MetaspaceShared::disable_optimized_module_handling();\n+    }\n+    log_info(cds)(\"optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -62,0 +62,6 @@\n+  static void dump_main_module_name() NOT_CDS_JAVA_HEAP_RETURN;\n+  static void serialize(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static char* _archived_main_module_name;\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1265,2 +1265,1 @@\n-  if (is_internal_module_property(key) ||\n-      strcmp(key, \"jdk.module.main\") == 0) {\n+  if (is_internal_module_property(key)) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    private static final boolean isDumpingStaticArchive;\n@@ -51,0 +52,1 @@\n+        isDumpingStaticArchive = isDumpingArchive && !isSharingEnabled;\n@@ -74,0 +76,7 @@\n+    \/**\n+      * Is dumping static archive.\n+      *\/\n+    public static boolean isDumpingStaticArchive() {\n+        return isDumpingStaticArchive;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.Objects;\n@@ -44,0 +45,1 @@\n+    private static String mainModule;\n@@ -49,1 +51,2 @@\n-                                Function<String, ClassLoader> classLoaderFunction) {\n+                                Function<String, ClassLoader> classLoaderFunction,\n+                                String mainModuleName) {\n@@ -55,0 +58,1 @@\n+        mainModule = mainModuleName;\n@@ -80,1 +84,1 @@\n-    static ArchivedModuleGraph get(String mainModule) {\n+    static ArchivedModuleGraph get(String mainModuleName) {\n@@ -82,2 +86,1 @@\n-        \/\/ We only allow the unnamed module (default) case for now\n-        if (mainModule == null) {\n+        if (Objects.equals(mainModule, mainModuleName)) {\n@@ -97,1 +100,2 @@\n-                        Function<String, ClassLoader> classLoaderFunction) {\n+                        Function<String, ClassLoader> classLoaderFunction,\n+                        String mainModule) {\n@@ -102,1 +106,2 @@\n-                                                      classLoaderFunction);\n+                                                      classLoaderFunction,\n+                                                      mainModule);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ArchivedModuleGraph.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,1 +144,0 @@\n-               getProperty(\"jdk.module.main\") == null &&          \/\/ --module\n@@ -231,1 +230,2 @@\n-                    canArchive = true;\n+                    if (CDS.isDumpingStaticArchive())\n+                        canArchive = true;\n@@ -472,0 +472,16 @@\n+        \/\/ If -Xshare:dump and mainModule are specified, check if the mainModule\n+        \/\/ is in the runtime image and not on the upgrade module path. If so,\n+        \/\/ set canArchive to true so that the module graph can be archived.\n+        if (CDS.isDumpingStaticArchive() && mainModule != null) {\n+            String scheme = systemModuleFinder.find(mainModule)\n+                    .stream()\n+                    .map(ModuleReference::location)\n+                    .flatMap(Optional::stream)\n+                    .findAny()\n+                    .map(URI::getScheme)\n+                    .orElse(null);\n+            if (\"jrt\".equalsIgnoreCase(scheme)) {\n+                canArchive = true;\n+            }\n+        }\n+\n@@ -473,2 +489,1 @@\n-        \/\/ Only allow the unnamed module case for now.\n-        if (canArchive && (mainModule == null)) {\n+        if (canArchive) {\n@@ -479,1 +494,2 @@\n-                                        clf);\n+                                        clf,\n+                                        mainModule);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,22 @@\n+\n+        \/\/ Test case 3)\n+        \/\/ dump an archive with the -m jdk.compiler option\n+        \/\/ run with -Xshare:off without -m option\n+        \/\/ run with archive without -m option\n+        \/\/ the list of modules from both runs should be the same\n+        System.out.println(\"---------------- Test case 3 -----------------\");\n+        output = TestCommon.dump(appJar,\n+                     TestCommon.list(\"PrintSystemModulesApp\"),\n+                     \"-m\", \"jdk.compiler\");\n+        TestCommon.checkDump(output);\n+\n+        output = TestCommon.execOff(\"-cp\", appJar, \"PrintSystemModulesApp\");\n+        output.shouldHaveExitValue(0);\n+        bootModules1 = TestCommon.filterOutLogs(output.getStdout());\n+\n+        output = TestCommon.exec(appJar, \"PrintSystemModulesApp\");\n+        TestCommon.checkExec(output);\n+        if (output.getStderr().contains(\"sharing\")) {\n+            String bootModules2 = TestCommon.filterOutLogs(output.getStdout());\n+            TestCommon.checkOutputStrings(bootModules1, bootModules2, \", \");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedModuleCompareTest.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8316969\n+ * @summary Test handling of module option (-m).\n+ * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @run driver ModuleOption\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ModuleOption {\n+    public static void main(String[] args) throws Exception {\n+        final String moduleOption = \"jdk.httpserver\/sun.net.httpserver.simpleserver.Main\";\n+        final String incubatorModule = \"jdk.incubator.vector\";\n+        final String loggingOption = \"-Xlog:cds=debug,cds+module=debug,cds+heap=info,module=trace\";\n+        final String versionPattern = \"java.[0-9][0-9][-].*\";\n+        final String subgraphCannotBeUsed = \"subgraph jdk.internal.module.ArchivedBootLayer cannot be used because full module graph is disabled\";\n+        String archiveName = TestCommon.getNewArchiveName(\"module-option\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+\n+        \/\/ dump a base archive with -m jdk.httpserver\n+        OutputAnalyzer oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ same module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          \/\/ version of the jdk.httpserver module, e.g. java 22-ea\n+          .shouldMatch(versionPattern)\n+          .shouldMatch(\"cds,module.*Restored from archive: entry.0x.*name jdk.httpserver\");\n+\n+        \/\/ different module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-m\", \"jdk.compiler\/com.sun.tools.javac.Main\",\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Mismatched modules: runtime jdk.compiler dump time jdk.httpserver\")\n+          .shouldContain(subgraphCannotBeUsed);\n+\n+        \/\/ no module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Module jdk.httpserver specified during dump time but not during runtime\")\n+          .shouldContain(subgraphCannotBeUsed);\n+\n+        \/\/ dump an archive without the module option\n+        archiveName = TestCommon.getNewArchiveName(\"no-module-option\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+        oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ run with module option\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Module jdk.httpserver specified during runtime but not during dump time\")\n+          \/\/ version of the jdk.httpserver module, e.g. java 22-ea\n+          .shouldMatch(versionPattern)\n+          .shouldContain(subgraphCannotBeUsed);\n+\n+        \/\/ dump an archive with an incubator module, -m jdk.incubator.vector\n+        archiveName = TestCommon.getNewArchiveName(\"incubator-module\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+        oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"-m\", incubatorModule,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          \/\/ module graph won't be archived with an incubator module\n+          .shouldContain(\"archivedBootLayer not available, disabling full module graph\");\n+\n+        \/\/ run with the same incubator module\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-m\", incubatorModule,\n+            \"-version\");\n+        oa.shouldContain(\"full module graph: disabled\")\n+          \/\/ module is not restored from archive\n+          .shouldContain(\"define_module(): creation of module: jdk.incubator.vector\")\n+          .shouldContain(\"WARNING: Using incubator modules: jdk.incubator.vector\")\n+          .shouldContain(\"subgraph jdk.internal.module.ArchivedBootLayer is not recorde\")\n+          .shouldContain(\"module jdk.incubator.vector does not have a ModuleMainClass attribute, use -m <module>\/<main-class>\")\n+          .shouldHaveExitValue(1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/module\/ModuleOption.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"}]}