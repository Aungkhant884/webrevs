{"files":[{"patch":"@@ -349,1 +349,1 @@\n-  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,\n+  assert(is_aligned(alignment, os::vm_allocation_granularity()),\n@@ -351,1 +351,2 @@\n-  assert((size & (alignment -1)) == 0, \"size must be 'alignment' aligned\");\n+  assert(is_aligned(size, os::vm_allocation_granularity()),\n+      \"Size must be a multiple of allocation granularity (page size)\");\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3370,3 +3370,4 @@\n-  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,\n-         \"Alignment must be a multiple of allocation granularity (page size)\");\n-  assert((size & (alignment -1)) == 0, \"size must be 'alignment' aligned\");\n+  assert(is_aligned(alignment, os::vm_allocation_granularity()),\n+      \"Alignment must be a multiple of allocation granularity (page size)\");\n+  assert(is_aligned(size, os::vm_allocation_granularity()),\n+      \"Size must be a multiple of allocation granularity (page size)\");\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -630,0 +630,11 @@\n+\n+#ifdef AARCH64\n+    if (result == nullptr) {\n+      \/\/ If that failed, attempt to allocate at any 4G aligned address. The disadvantage to the\n+      \/\/ approach taken above is that os::reserve_memory_aligned needs to overallocate to guarantee\n+      \/\/ the alignment, and that will temporarily spike the vsize of the process.\n+      const size_t alignment2 = 4 * G;\n+      log_debug(metaspace, map)(\"Trying to allocate at any \" SIZE_FORMAT_X \"-aligned address\", alignment2);\n+      result = os::reserve_memory_aligned(size, alignment2, false);\n+    }\n+#endif \/\/ AARCH64\n@@ -634,1 +645,1 @@\n-    \/\/ Fallback: reserve anywhere and hope the resulting block is usable.\n+    \/\/ Fallback: reserve anywhere and (for aarch64) hope the resulting block is usable.\n@@ -642,0 +653,1 @@\n+    log_debug(metaspace, map)(\"Mapped at \" PTR_FORMAT, p2i(result));\n@@ -646,0 +658,1 @@\n+    log_debug(metaspace, map)(\"Failed to map.\");\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  assert(is_valid_base(requested_base), \"Address must be a valid encoding base\");\n+  assert(is_valid_base(requested_base), \"Address must be a valid encoding base (\" PTR_FORMAT \")\", p2i(requested_base));\n@@ -93,1 +93,1 @@\n-  assert(is_valid_base(_base), \"Address must be a valid encoding base\");\n+  assert(is_valid_base(_base), \"Address must be a valid encoding base (\" PTR_FORMAT \")\", p2i(_base));\n@@ -100,6 +100,6 @@\n-  \/\/ Below 32G, base must be aligned to 4G.\n-  \/\/ Above that point, base must be aligned to 32G\n-  if (p < (address)(32 * G)) {\n-    return is_aligned(p, 4 * G);\n-  }\n-  return is_aligned(p, (4 << LogKlassAlignmentInBytes) * G);\n+  \/\/ Any base that is 4G aligned (including null) can probably be made to work.\n+  \/\/ Without knowing the location and size of the range-to-be-encoded in relation\n+  \/\/  to the base it is not possible to say more. If the base is not 0, we assume\n+  \/\/  the range starts at the specified encoding base and its size will not be\n+  \/\/  larger than 4GB).\n+  return is_aligned(p, 4 * G);\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}