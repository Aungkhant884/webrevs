{"files":[{"patch":"@@ -783,1 +783,1 @@\n-HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm, bool use_block_table) const {\n+HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const {\n@@ -804,10 +804,3 @@\n-  \/\/ Otherwise, the new location is region->destination + #live words to left\n-  \/\/ of addr in this region. Calculating #live words naively means walking the\n-  \/\/ mark bitmap from the start of this region. Block table can be used to\n-  \/\/ speed up this process, but it would incur some side-effect. In debug-only\n-  \/\/ code (such as asserts), we prefer the slower but side-effect free version,\n-  \/\/ to avoid side effects that would not occur for release code and could\n-  \/\/ potentially affect future calculations.\n-  if (use_block_table) {\n-    \/\/ #live words = block offset + #live words in the Block that are\n-    \/\/ (a) to the left of addr and (b) due to objects that start in the Block.\n+  \/\/ Otherwise, the new location is region->destination + block offset + the\n+  \/\/ number of live words in the Block that are (a) to the left of addr and (b)\n+  \/\/ due to objects that start in the Block.\n@@ -815,20 +808,6 @@\n-    \/\/ Fill in the block table if necessary.  This is unsynchronized, so multiple\n-    \/\/ threads may fill the block table for a region (harmless, since it is\n-    \/\/ idempotent).\n-    if (!region_ptr->blocks_filled()) {\n-      PSParallelCompact::fill_blocks(addr_to_region_idx(addr));\n-      region_ptr->set_blocks_filled();\n-    }\n-\n-    HeapWord* const search_start = block_align_down(addr);\n-    const size_t block_offset = addr_to_block_ptr(addr)->offset();\n-\n-    const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();\n-    const size_t live = bitmap->live_words_in_range(cm, search_start, oop(addr));\n-    result += block_offset + live;\n-  } else {\n-    guarantee(trueInDebug, \"Only in debug build\");\n-\n-    const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();\n-    const size_t live = bitmap->live_words_in_range(cm, region_align_down(addr), oop(addr));\n-    result += region_ptr->partial_obj_size() + live;\n+  \/\/ Fill in the block table if necessary.  This is unsynchronized, so multiple\n+  \/\/ threads may fill the block table for a region (harmless, since it is\n+  \/\/ idempotent).\n+  if (!region_ptr->blocks_filled()) {\n+    PSParallelCompact::fill_blocks(addr_to_region_idx(addr));\n+    region_ptr->set_blocks_filled();\n@@ -837,0 +816,6 @@\n+  HeapWord* const search_start = block_align_down(addr);\n+  const size_t block_offset = addr_to_block_ptr(addr)->offset();\n+\n+  const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();\n+  const size_t live = bitmap->live_words_in_range(cm, search_start, oop(addr));\n+  result += block_offset + live;\n@@ -3299,1 +3284,1 @@\n-  assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager(), false) ==\n+  assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager()) ==\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":17,"deletions":32,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -483,3 +483,1 @@\n-  HeapWord* calc_new_pointer(HeapWord* addr,\n-                             ParCompactionManager* cm,\n-                             bool use_block_table = true) const;\n+  HeapWord* calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}