{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -386,1 +386,1 @@\n-  char* action = NULL;\n+  char* action = nullptr;\n@@ -411,2 +411,2 @@\n-  char* young_gen_action = NULL;\n-  char* tenured_gen_action = NULL;\n+  char* young_gen_action = nullptr;\n+  char* tenured_gen_action = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-BarrierSet* BarrierSet::_barrier_set = NULL;\n+BarrierSet* BarrierSet::_barrier_set = nullptr;\n@@ -38,1 +38,1 @@\n-  assert(_barrier_set == NULL, \"Already initialized\");\n+  assert(_barrier_set == nullptr, \"Already initialized\");\n@@ -56,1 +56,1 @@\n-  if (barrier_set_nmethod != NULL) {\n+  if (barrier_set_nmethod != nullptr) {\n@@ -67,1 +67,1 @@\n-  if (barrier_set_stack_chunk != NULL) {\n+  if (barrier_set_stack_chunk != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    return NOT_ZERO(new BarrierSetAssemblerT()) ZERO_ONLY(NULL);\n+    return NOT_ZERO(new BarrierSetAssemblerT()) ZERO_ONLY(nullptr);\n@@ -114,1 +114,1 @@\n-    return COMPILER1_PRESENT(new BarrierSetC1T()) NOT_COMPILER1(NULL);\n+    return COMPILER1_PRESENT(new BarrierSetC1T()) NOT_COMPILER1(nullptr);\n@@ -119,1 +119,1 @@\n-    return COMPILER2_PRESENT(new BarrierSetC2T()) NOT_COMPILER2(NULL);\n+    return COMPILER2_PRESENT(new BarrierSetC2T()) NOT_COMPILER2(nullptr);\n@@ -153,1 +153,1 @@\n-    assert(_barrier_set_assembler != NULL, \"should be set\");\n+    assert(_barrier_set_assembler != nullptr, \"should be set\");\n@@ -158,1 +158,1 @@\n-    assert(_barrier_set_c1 != NULL, \"should be set\");\n+    assert(_barrier_set_c1 != nullptr, \"should be set\");\n@@ -163,1 +163,1 @@\n-    assert(_barrier_set_c2 != NULL, \"should be set\");\n+    assert(_barrier_set_c2 != nullptr, \"should be set\");\n@@ -172,1 +172,1 @@\n-    assert(_barrier_set_stack_chunk != NULL, \"should be set\");\n+    assert(_barrier_set_stack_chunk != nullptr, \"should be set\");\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    return Raw::oop_arraycopy(NULL, 0, src, NULL, 0, dst, length);\n+    return Raw::oop_arraycopy(nullptr, 0, src, nullptr, 0, dst, length);\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,1 @@\n-  assert(cb != NULL, \"invariant\");\n+  assert(cb != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-  _head(NULL), _tail(NULL), _entry_count(0) {}\n+  _head(nullptr), _tail(nullptr), _entry_count(0) {}\n@@ -37,2 +37,2 @@\n-  assert((_head == NULL) == (_tail == NULL), \"invariant\");\n-  assert((_head == NULL) == (_entry_count == 0), \"invariant\");\n+  assert((_head == nullptr) == (_tail == nullptr), \"invariant\");\n+  assert((_head == nullptr) == (_entry_count == 0), \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/shared\/bufferNodeList.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n-  BufferNode* _head;            \/\/ First node in list or NULL if empty.\n-  BufferNode* _tail;            \/\/ Last node in list or NULL if empty.\n+  BufferNode* _head;            \/\/ First node in list or null if empty.\n+  BufferNode* _tail;            \/\/ Last node in list or null if empty.\n","filename":"src\/hotspot\/share\/gc\/shared\/bufferNodeList.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,1 +227,1 @@\n-  \/\/   if (src != NULL) {\n+  \/\/   if (src != nullptr) {\n@@ -272,1 +272,1 @@\n-      guarantee(src_con != NULL, \"no source constant\");\n+      guarantee(src_con != nullptr, \"no source constant\");\n@@ -290,1 +290,1 @@\n-    if ((type != NULL) && type->is_loaded()) {\n+    if ((type != nullptr) && type->is_loaded()) {\n@@ -330,1 +330,1 @@\n-      __ cmp(lir_cond_equal, base_reg, LIR_OprFact::oopConst(NULL));\n+      __ cmp(lir_cond_equal, base_reg, LIR_OprFact::oopConst(nullptr));\n@@ -337,1 +337,1 @@\n-      gen->load_klass(base_reg, src_klass, NULL);\n+      gen->load_klass(base_reg, src_klass, nullptr);\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  LIRAddressOpr(LIR_Opr opr) : _item(NULL), _opr(opr) {}\n+  LIRAddressOpr(LIR_Opr opr) : _item(nullptr), _opr(opr) {}\n@@ -49,1 +49,1 @@\n-    assert(_item != NULL, \"sanity\");\n+    assert(_item != nullptr, \"sanity\");\n@@ -54,1 +54,1 @@\n-    if (_item == NULL) {\n+    if (_item == nullptr) {\n@@ -77,1 +77,1 @@\n-            CodeEmitInfo* patch_emit_info = NULL, CodeEmitInfo* access_emit_info = NULL) :\n+            CodeEmitInfo* patch_emit_info = nullptr, CodeEmitInfo* access_emit_info = nullptr) :\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-                LIR_OprFact::illegalOpr \/* pre_val *\/, NULL);\n+                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n@@ -72,1 +72,1 @@\n-                LIR_OprFact::illegalOpr \/* pre_val *\/, NULL);\n+                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/modRefBarrierSetC1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-    Node* control = control_dependent ? kit->control() : NULL;\n+    Node* control = control_dependent ? kit->control() : nullptr;\n@@ -168,1 +168,1 @@\n-    Node* control = control_dependent ? opt_access.ctl() : NULL;\n+    Node* control = control_dependent ? opt_access.ctl() : nullptr;\n@@ -187,2 +187,2 @@\n-    _access(access), _leading_membar(NULL) {\n-    GraphKit* kit = NULL;\n+    _access(access), _leading_membar(nullptr) {\n+    GraphKit* kit = nullptr;\n@@ -203,1 +203,1 @@\n-      assert(kit != NULL, \"unsupported at optimization time\");\n+      assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -222,1 +222,1 @@\n-        assert(kit != NULL, \"unsupported at optimization time\");\n+        assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -232,1 +232,1 @@\n-        assert(kit != NULL, \"unsupported at optimization time\");\n+        assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -238,1 +238,1 @@\n-      assert(kit != NULL, \"unsupported at optimization time\");\n+      assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -251,1 +251,1 @@\n-    GraphKit* kit = NULL;\n+    GraphKit* kit = nullptr;\n@@ -272,1 +272,1 @@\n-      assert(kit != NULL, \"unsupported at optimization time\");\n+      assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -276,1 +276,1 @@\n-        if (_leading_membar != NULL) {\n+        if (_leading_membar != nullptr) {\n@@ -283,1 +283,1 @@\n-        assert(kit != NULL, \"unsupported at optimization time\");\n+        assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -286,1 +286,1 @@\n-        if (_leading_membar != NULL) {\n+        if (_leading_membar != nullptr) {\n@@ -292,1 +292,1 @@\n-        assert(kit != NULL, \"unsupported at optimization time\");\n+        assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -294,1 +294,1 @@\n-        assert(_leading_membar == NULL || support_IRIW_for_not_multiple_copy_atomic_cpu, \"no leading membar expected\");\n+        assert(_leading_membar == nullptr || support_IRIW_for_not_multiple_copy_atomic_cpu, \"no leading membar expected\");\n@@ -391,1 +391,1 @@\n-  assert(load_store != NULL, \"must pin atomic op\");\n+  assert(load_store != nullptr, \"must pin atomic op\");\n@@ -410,1 +410,1 @@\n-  Node* load_store = NULL;\n+  Node* load_store = nullptr;\n@@ -468,1 +468,1 @@\n-  Node* load_store = NULL;\n+  Node* load_store = nullptr;\n@@ -543,1 +543,1 @@\n-  Node* load_store = NULL;\n+  Node* load_store = nullptr;\n@@ -590,1 +590,1 @@\n-  Node* load_store = NULL;\n+  Node* load_store = nullptr;\n@@ -770,1 +770,1 @@\n-  address     copyfunc_addr = phase->basictype2arraycopy(T_LONG, NULL, NULL, true, copyfunc_name, true);\n+  address     copyfunc_addr = phase->basictype2arraycopy(T_LONG, nullptr, nullptr, true, copyfunc_name, true);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-    _raw_access(NULL),\n+    _raw_access(nullptr),\n@@ -176,1 +176,1 @@\n-    _memory(NULL),\n+    _memory(nullptr),\n@@ -245,1 +245,1 @@\n-  virtual Node* ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const { return NULL; }\n+  virtual Node* ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const { return nullptr; }\n@@ -273,1 +273,1 @@\n-  virtual void* create_barrier_state(Arena* comp_arena) const { return NULL; }\n+  virtual void* create_barrier_state(Arena* comp_arena) const { return nullptr; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-   if (card_table_base != NULL) {\n+   if (card_table_base != nullptr) {\n@@ -61,2 +61,2 @@\n-  \/\/ No store check needed if we're storing a NULL.\n-  if (val != NULL && val->is_Con()) {\n+  \/\/ No store check needed if we're storing a null.\n+  if (val != nullptr && val->is_Con()) {\n@@ -86,1 +86,1 @@\n-  assert(adr != NULL, \"\");\n+  assert(adr != nullptr, \"\");\n@@ -139,2 +139,2 @@\n-    Node* no_particular_value = NULL;\n-    Node* no_particular_field = NULL;\n+    Node* no_particular_value = nullptr;\n+    Node* no_particular_field = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-              static_cast<const TypeOopPtr*>(val.type()), NULL \/* pre_val *\/, access.type());\n+              static_cast<const TypeOopPtr*>(val.type()), nullptr \/* pre_val *\/, access.type());\n@@ -74,1 +74,1 @@\n-              kit->control(), NULL, NULL, max_juint, NULL, NULL,\n+              kit->control(), nullptr, nullptr, max_juint, nullptr, nullptr,\n@@ -94,1 +94,1 @@\n-              kit->control(), NULL, NULL, max_juint, NULL, NULL,\n+              kit->control(), nullptr, nullptr, max_juint, nullptr, nullptr,\n@@ -133,1 +133,1 @@\n-              kit->control(), NULL, NULL, max_juint, NULL, NULL,\n+              kit->control(), nullptr, nullptr, max_juint, nullptr, nullptr,\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/modRefBarrierSetC2.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,2 @@\n-  _byte_map(NULL),\n-  _byte_map_base(NULL),\n+  _byte_map(nullptr),\n+  _byte_map_base(nullptr),\n@@ -160,1 +160,1 @@\n-  HeapWord* max_end = NULL;\n+  HeapWord* max_end = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-  \/\/ covered region before covered region \"ind\", or else \"NULL\" if \"ind\" is\n+  \/\/ covered region before covered region \"ind\", or else \"null\" if \"ind\" is\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,1 +179,1 @@\n-    guarantee(obj == NULL || cast_from_oop<HeapWord*>(obj) >= _boundary,\n+    guarantee(obj == nullptr || cast_from_oop<HeapWord*>(obj) >= _boundary,\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-Klass* CollectedHeap::_filler_object_klass = NULL;\n+Klass* CollectedHeap::_filler_object_klass = nullptr;\n@@ -102,1 +102,1 @@\n-  _records[index].thread = NULL; \/\/ Its the GC thread so it's not that interesting.\n+  _records[index].thread = nullptr; \/\/ Its the GC thread so it's not that interesting.\n@@ -164,1 +164,1 @@\n-  if (_gc_heap_log != NULL) {\n+  if (_gc_heap_log != nullptr) {\n@@ -178,1 +178,1 @@\n-  if (_gc_heap_log != NULL) {\n+  if (_gc_heap_log != nullptr) {\n@@ -191,1 +191,1 @@\n-  if (bs != NULL) {\n+  if (bs != nullptr) {\n@@ -278,1 +278,1 @@\n-    _gc_heap_log = NULL;\n+    _gc_heap_log = nullptr;\n@@ -323,1 +323,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -332,1 +332,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -349,1 +349,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -523,1 +523,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -566,1 +566,1 @@\n-  assert(timer != NULL, \"timer is null\");\n+  assert(timer != nullptr, \"timer is null\");\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-    assert(heap != NULL, \"Uninitialized heap\");\n+    assert(heap != nullptr, \"Uninitialized heap\");\n@@ -281,1 +281,1 @@\n-  DEBUG_ONLY(bool is_in_or_null(const void* p) const { return p == NULL || is_in(p); })\n+  DEBUG_ONLY(bool is_in_or_null(const void* p) const { return p == nullptr || is_in(p); })\n@@ -417,1 +417,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -493,1 +493,1 @@\n-  \/\/ method returns NULL, cleanup tasks are done serially in the VMThread. See\n+  \/\/ method returns null, cleanup tasks are done serially in the VMThread. See\n@@ -501,1 +501,1 @@\n-  virtual WorkerThreads* safepoint_workers() { return NULL; }\n+  virtual WorkerThreads* safepoint_workers() { return nullptr; }\n@@ -516,1 +516,1 @@\n-  virtual HeapWord* allocate_loaded_archive_space(size_t size) { return NULL; }\n+  virtual HeapWord* allocate_loaded_archive_space(size_t size) { return nullptr; }\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,5 +37,5 @@\n-\/\/ (1) No active request            NULL         false          false\n-\/\/ (2) Active run_to() running     non-NULL      false          false\n-\/\/ (3) Active run_to() in at()      NULL         false          true\n-\/\/ (4) Active run_to_idle()         NULL         true           false\n-const char* ConcurrentGCBreakpoints::_run_to = NULL;\n+\/\/ (1) No active request            null         false          false\n+\/\/ (2) Active run_to() running     non-null      false          false\n+\/\/ (3) Active run_to() in at()      null         false          true\n+\/\/ (4) Active run_to_idle()         null         true           false\n+const char* ConcurrentGCBreakpoints::_run_to = nullptr;\n@@ -49,1 +49,1 @@\n-  _run_to = NULL;\n+  _run_to = nullptr;\n@@ -60,1 +60,1 @@\n-  return _want_idle || _is_stopped || (_run_to != NULL);\n+  return _want_idle || _is_stopped || (_run_to != nullptr);\n@@ -102,1 +102,1 @@\n-  assert(breakpoint != NULL, \"precondition\");\n+  assert(breakpoint != nullptr, \"precondition\");\n@@ -135,1 +135,1 @@\n-  assert(breakpoint != NULL, \"precondition\");\n+  assert(breakpoint != nullptr, \"precondition\");\n@@ -139,1 +139,1 @@\n-  if ((_run_to == NULL) || (strcmp(_run_to, breakpoint) != 0)) {\n+  if ((_run_to == nullptr) || (strcmp(_run_to, breakpoint) != 0)) {\n@@ -146,1 +146,1 @@\n-  _run_to = NULL;\n+  _run_to = nullptr;\n@@ -161,1 +161,1 @@\n-  if (_run_to != NULL) {\n+  if (_run_to != nullptr) {\n@@ -164,1 +164,1 @@\n-    _run_to = NULL;\n+    _run_to = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCBreakpoints.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,2 @@\n-    FreeNode* _head;     \/\/ First node in list or nullptr if empty.\n-    FreeNode* _tail;     \/\/ Last node in list or nullptr if empty.\n+    FreeNode* _head;     \/\/ First node in list or null if empty.\n+    FreeNode* _tail;     \/\/ Last node in list or null if empty.\n","filename":"src\/hotspot\/share\/gc\/shared\/freeListAllocator.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-IsUnloadingBehaviour* IsUnloadingBehaviour::_current = NULL;\n+IsUnloadingBehaviour* IsUnloadingBehaviour::_current = nullptr;\n@@ -56,1 +56,1 @@\n-    if (obj == NULL) {\n+    if (obj == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcBehaviours.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-GCArguments* GCConfig::_arguments = NULL;\n+GCArguments* GCConfig::_arguments = nullptr;\n@@ -153,1 +153,1 @@\n-                                    \"(default collector explicitly disabled)\", NULL);\n+                                    \"(default collector explicitly disabled)\", nullptr);\n@@ -162,1 +162,1 @@\n-    vm_exit_during_initialization(\"Multiple garbage collectors selected\", NULL);\n+    vm_exit_during_initialization(\"Multiple garbage collectors selected\", nullptr);\n@@ -174,1 +174,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -178,1 +178,1 @@\n-  assert(_arguments == NULL, \"Already initialized\");\n+  assert(_arguments == nullptr, \"Already initialized\");\n@@ -234,1 +234,1 @@\n-  assert(_arguments != NULL, \"Not initialized\");\n+  assert(_arguments != nullptr, \"Not initialized\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcConfig.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-      _start(NULL), _committed_end(NULL), _reserved_end(NULL) { }\n+      _start(nullptr), _committed_end(nullptr), _reserved_end(nullptr) { }\n@@ -55,1 +55,1 @@\n-      _start(NULL), _end(NULL), _used(0) { }\n+      _start(nullptr), _end(nullptr), _used(0) { }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcHeapSummary.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  if (thread != NULL) {\n+  if (thread != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcId.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,3 @@\n-stringStream* GCLogPrecious::_lines = NULL;\n-stringStream* GCLogPrecious::_temp = NULL;\n-Mutex* GCLogPrecious::_lock = NULL;\n+stringStream* GCLogPrecious::_lines = nullptr;\n+stringStream* GCLogPrecious::_temp = nullptr;\n+Mutex* GCLogPrecious::_lock = nullptr;\n@@ -82,1 +82,1 @@\n-  if (_lines == NULL) {\n+  if (_lines == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-      default: ShouldNotReachHere(); return NULL;\n+      default: ShouldNotReachHere(); return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcName.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-  _phases = NULL;\n+  _phases = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTimer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-  assert(is_alive_cl != NULL, \"Must supply function to check liveness\");\n+  assert(is_alive_cl != nullptr, \"Must supply function to check liveness\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  ParallelOldGCInfo() : _dense_prefix(NULL) {}\n+  ParallelOldGCInfo() : _dense_prefix(nullptr) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,3 +78,3 @@\n-  GCTraceTimeDriver(TimespanCallback* cb0 = NULL,\n-                    TimespanCallback* cb1 = NULL,\n-                    TimespanCallback* cb2 = NULL);\n+  GCTraceTimeDriver(TimespanCallback* cb0 = nullptr,\n+                    TimespanCallback* cb1 = nullptr,\n+                    TimespanCallback* cb2 = nullptr);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceTime.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  return _cb0 != NULL || _cb1 != NULL || _cb2 != NULL;\n+  return _cb0 != nullptr || _cb1 != nullptr || _cb2 != nullptr;\n@@ -71,1 +71,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -77,1 +77,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -116,1 +116,1 @@\n-  if (_timer != NULL) {\n+  if (_timer != nullptr) {\n@@ -123,1 +123,1 @@\n-  if (_timer != NULL) {\n+  if (_timer != nullptr) {\n@@ -131,1 +131,1 @@\n-  if (_timer != NULL) {\n+  if (_timer != nullptr) {\n@@ -137,1 +137,1 @@\n-  if (_timer != NULL) {\n+  if (_timer != nullptr) {\n@@ -156,2 +156,2 @@\n-        _driver((_logger.is_enabled() ? &_logger : NULL),\n-                (timer != NULL ? &_timer : NULL)) {}\n+        _driver((_logger.is_enabled() ? &_logger : nullptr),\n+                (timer != nullptr ? &_timer : nullptr)) {}\n@@ -189,1 +189,1 @@\n-      GCTimer* timer = NULL,\n+      GCTimer* timer = nullptr,\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceTime.inline.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,1 +180,1 @@\n-  assert(_result == NULL || gch->is_in_reserved(_result), \"result not in heap\");\n+  assert(_result == nullptr || gch->is_in_reserved(_result), \"result not in heap\");\n@@ -182,1 +182,1 @@\n-  if (_result == NULL && GCLocker::is_active_and_needs_gc()) {\n+  if (_result == nullptr && GCLocker::is_active_and_needs_gc()) {\n@@ -202,1 +202,1 @@\n-      _result(NULL), _size(size), _mdtype(mdtype), _loader_data(loader_data) {\n+      _result(nullptr), _size(size), _mdtype(mdtype), _loader_data(loader_data) {\n@@ -218,1 +218,1 @@\n-    if (_result != NULL) {\n+    if (_result != nullptr) {\n@@ -228,1 +228,1 @@\n-    if (_result != NULL) {\n+    if (_result != nullptr) {\n@@ -241,1 +241,1 @@\n-  if (_result != NULL) {\n+  if (_result != nullptr) {\n@@ -251,1 +251,1 @@\n-  if (_result != NULL) {\n+  if (_result != nullptr) {\n@@ -258,1 +258,1 @@\n-  if (_result != NULL) {\n+  if (_result != nullptr) {\n@@ -270,1 +270,1 @@\n-    : VM_GC_Operation(gc_count_before, cause), _word_size(word_size), _result(NULL) {\n+    : VM_GC_Operation(gc_count_before, cause), _word_size(word_size), _result(nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,1 +182,1 @@\n-  HeapWord* _result;    \/\/ Allocation result (NULL if allocation failed)\n+  HeapWord* _result;    \/\/ Allocation result (null if allocation failed)\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    default: ShouldNotReachHere(); return NULL;\n+    default: ShouldNotReachHere(); return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcWhen.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,2 +88,2 @@\n-  _young_gen(NULL),\n-  _old_gen(NULL),\n+  _young_gen(nullptr),\n+  _old_gen(nullptr),\n@@ -98,1 +98,1 @@\n-  _rem_set(NULL),\n+  _rem_set(nullptr),\n@@ -100,1 +100,1 @@\n-  _size_policy(NULL),\n+  _size_policy(nullptr),\n@@ -104,2 +104,2 @@\n-  _young_manager(NULL),\n-  _old_manager(NULL) {\n+  _young_manager(nullptr),\n+  _old_manager(nullptr) {\n@@ -272,1 +272,1 @@\n-  HeapWord* result = NULL;\n+  HeapWord* result = nullptr;\n@@ -276,1 +276,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -281,1 +281,1 @@\n-  assert(result == NULL || is_in_reserved(result), \"result not in heap\");\n+  assert(result == nullptr || is_in_reserved(result), \"result not in heap\");\n@@ -293,1 +293,1 @@\n-  HeapWord* result = NULL;\n+  HeapWord* result = nullptr;\n@@ -302,1 +302,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -316,1 +316,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -323,1 +323,1 @@\n-          return NULL;  \/\/ Caller will retry allocating individual object.\n+          return nullptr;  \/\/ Caller will retry allocating individual object.\n@@ -329,1 +329,1 @@\n-          if (result != NULL) {\n+          if (result != nullptr) {\n@@ -335,1 +335,1 @@\n-          return NULL; \/\/ We didn't get to do a GC and we didn't get any memory.\n+          return nullptr; \/\/ We didn't get to do a GC and we didn't get any memory.\n@@ -356,1 +356,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -369,1 +369,1 @@\n-         assert(result == NULL, \"must be NULL if gc_locked() is true\");\n+         assert(result == nullptr, \"must be null if gc_locked() is true\");\n@@ -375,1 +375,1 @@\n-      \/\/ this time, return NULL so that an out-of-memory\n+      \/\/ this time, return null so that an out-of-memory\n@@ -385,1 +385,1 @@\n-        if (op.result() != NULL) {\n+        if (op.result() != nullptr) {\n@@ -388,1 +388,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -390,1 +390,1 @@\n-      assert(result == NULL || is_in_reserved(result),\n+      assert(result == nullptr || is_in_reserved(result),\n@@ -407,1 +407,1 @@\n-  HeapWord* res = NULL;\n+  HeapWord* res = nullptr;\n@@ -411,1 +411,1 @@\n-    if (res != NULL || first_only) {\n+    if (res != nullptr || first_only) {\n@@ -533,1 +533,1 @@\n-    GCTraceTime(Info, gc) t(\"Pause Young\", NULL, gc_cause(), true);\n+    GCTraceTime(Info, gc) t(\"Pause Young\", nullptr, gc_cause(), true);\n@@ -583,1 +583,1 @@\n-    GCTraceTime(Info, gc) t(\"Pause Full\", NULL, gc_cause(), true);\n+    GCTraceTime(Info, gc) t(\"Pause Full\", nullptr, gc_cause(), true);\n@@ -668,1 +668,1 @@\n-  HeapWord* result = NULL;\n+  HeapWord* result = nullptr;\n@@ -700,1 +700,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -707,1 +707,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -727,1 +727,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -739,1 +739,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -759,1 +759,1 @@\n-  assert(code_roots != NULL, \"code root closure should always be set\");\n+  assert(code_roots != nullptr, \"code root closure should always be set\");\n@@ -764,1 +764,1 @@\n-  CodeBlobToOopClosure* roots_from_code_p = (so & SO_AllCodeCache) ? NULL : code_roots;\n+  CodeBlobToOopClosure* roots_from_code_p = (so & SO_AllCodeCache) ? nullptr : code_roots;\n@@ -771,1 +771,1 @@\n-    assert(code_roots != NULL, \"must supply closure for code cache\");\n+    assert(code_roots != nullptr, \"must supply closure for code cache\");\n@@ -777,1 +777,1 @@\n-    assert(code_roots != NULL, \"must supply closure for code cache\");\n+    assert(code_roots != nullptr, \"must supply closure for code cache\");\n@@ -875,1 +875,1 @@\n-  assert(is_in_reserved(p) || p == NULL,\n+  assert(is_in_reserved(p) || p == nullptr,\n@@ -877,1 +877,1 @@\n-  return p < _young_gen->reserved().end() && p != NULL;\n+  return p < _young_gen->reserved().end() && p != nullptr;\n@@ -893,1 +893,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -897,1 +897,1 @@\n-  assert(res != NULL, \"Could not find containing space\");\n+  assert(res != nullptr, \"Could not find containing space\");\n@@ -949,1 +949,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -956,1 +956,1 @@\n-\/\/ Requires \"*prev_ptr\" to be non-NULL.  Deletes and a block of minimal size\n+\/\/ Requires \"*prev_ptr\" to be non-null.  Deletes and a block of minimal size\n@@ -982,1 +982,1 @@\n-  ScratchBlock* sorted = NULL;\n+  ScratchBlock* sorted = nullptr;\n@@ -994,1 +994,1 @@\n-  ScratchBlock* res = NULL;\n+  ScratchBlock* res = nullptr;\n@@ -1056,1 +1056,1 @@\n-  if (_young_gen != NULL) {\n+  if (_young_gen != nullptr) {\n@@ -1059,1 +1059,1 @@\n-  if (_old_gen != NULL) {\n+  if (_old_gen != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":45,"deletions":45,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-    assert(cld == NULL || _scanned_cld == NULL, \"Must be\");\n+    assert(cld == nullptr || _scanned_cld == nullptr, \"Must be\");\n","filename":"src\/hotspot\/share\/gc\/shared\/genOopClosures.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    FastScanClosure<DefNewScanClosure>(g), _scanned_cld(NULL) {}\n+    FastScanClosure<DefNewScanClosure>(g), _scanned_cld(nullptr) {}\n@@ -96,1 +96,1 @@\n-  if (_scanned_cld != NULL && !_scanned_cld->has_modified_oops()) {\n+  if (_scanned_cld != nullptr && !_scanned_cld->has_modified_oops()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/genOopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-  _gc_manager(NULL),\n-  _ref_processor(NULL) {\n+  _gc_manager(nullptr),\n+  _ref_processor(nullptr) {\n@@ -78,1 +78,1 @@\n-  assert(_ref_processor == NULL, \"a reference processor already exists\");\n+  assert(_ref_processor == nullptr, \"a reference processor already exists\");\n@@ -114,1 +114,1 @@\n-    if (sp == NULL) {\n+    if (sp == nullptr) {\n@@ -118,1 +118,1 @@\n-  GenerationIsInReservedClosure(const void* p) : _p(p), sp(NULL) {}\n+  GenerationIsInReservedClosure(const void* p) : _p(p), sp(nullptr) {}\n@@ -126,1 +126,1 @@\n-    if (sp == NULL) {\n+    if (sp == nullptr) {\n@@ -130,1 +130,1 @@\n-  GenerationIsInClosure(const void* p) : _p(p), sp(NULL) {}\n+  GenerationIsInClosure(const void* p) : _p(p), sp(nullptr) {}\n@@ -136,1 +136,1 @@\n-  return blk.sp != NULL;\n+  return blk.sp != nullptr;\n@@ -163,1 +163,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -169,1 +169,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -172,2 +172,2 @@\n-    if (result == NULL) {\n-      return NULL;\n+    if (result == nullptr) {\n+      return nullptr;\n@@ -202,1 +202,1 @@\n-    if (_start == NULL && s->is_in_reserved(_p)) {\n+    if (_start == nullptr && s->is_in_reserved(_p)) {\n@@ -206,1 +206,1 @@\n-  GenerationBlockStartClosure(const void* p) { _p = p; _start = NULL; }\n+  GenerationBlockStartClosure(const void* p) { _p = p; _start = nullptr; }\n@@ -290,1 +290,1 @@\n-  while (space != NULL) {\n+  while (space != nullptr) {\n@@ -312,1 +312,1 @@\n-  while (sp != NULL) {\n+  while (sp != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-    assert(_ref_processor == NULL, \"clobbering existing _ref_processor\");\n+    assert(_ref_processor == nullptr, \"clobbering existing _ref_processor\");\n@@ -197,1 +197,1 @@\n-  \/\/ pointer to that space, else return \"NULL\".\n+  \/\/ pointer to that space, else return \"null\".\n@@ -204,1 +204,1 @@\n-  \/\/ in compaction, or else \"NULL\".\n+  \/\/ in compaction, or else \"null\".\n@@ -221,1 +221,1 @@\n-  \/\/ Allocate and returns a block of the requested size, or returns \"NULL\".\n+  \/\/ Allocate and returns a block of the requested size, or returns \"null\".\n@@ -245,1 +245,1 @@\n-  \/\/ the newly allocated space, if possible, returning the result (or NULL if\n+  \/\/ the newly allocated space, if possible, returning the result (or null if\n@@ -291,1 +291,1 @@\n-  \/\/ still unsuccessful, return \"NULL\".\n+  \/\/ still unsuccessful, return \"null\".\n@@ -423,1 +423,1 @@\n-    assert(_gc_manager != NULL, \"not initialized yet\");\n+    assert(_gc_manager != nullptr, \"not initialized yet\");\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  assert(v != NULL, \"don't call this constructor if v == NULL\");\n+  assert(v != nullptr, \"don't call this constructor if v == nullptr\");\n@@ -79,1 +79,1 @@\n-  : _virtual_space(NULL) {\n+  : _virtual_space(nullptr) {\n@@ -88,1 +88,1 @@\n-  assert(_virtual_space != NULL, \"otherwise, override this method\");\n+  assert(_virtual_space != nullptr, \"otherwise, override this method\");\n","filename":"src\/hotspot\/share\/gc\/shared\/generationCounters.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-             : _current_size(NULL), _virtual_space(NULL), _name_space(NULL) {}\n+             : _current_size(nullptr), _virtual_space(nullptr), _name_space(nullptr) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/generationCounters.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/generationSpec.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  if (p != NULL && CollectedHeapT::heap()->block_is_obj(p)) {\n+  if (p != nullptr && CollectedHeapT::heap()->block_is_obj(p)) {\n@@ -44,1 +44,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -49,1 +49,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -57,1 +57,1 @@\n-    if (o != NULL) {\n+    if (o != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/locationPrinter.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,2 +82,2 @@\n-  \/\/ \"addr\", and before \"limit\", if \"limit\" is non-NULL.  If there is no\n-  \/\/ such bit, returns \"limit\" if that is non-NULL, or else \"endWord()\".\n+  \/\/ \"addr\", and before \"limit\", if \"limit\" is non-null.  If there is no\n+  \/\/ such bit, returns \"limit\" if that is non-null, or else \"endWord()\".\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(limit != NULL, \"limit must not be NULL\");\n+  assert(limit != nullptr, \"limit must not be null\");\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-    *obj_ptr = NULL;\n+    *obj_ptr = nullptr;\n@@ -121,1 +121,1 @@\n-  if (obj() != NULL) {\n+  if (obj() != nullptr) {\n@@ -243,1 +243,1 @@\n-    if (klass != NULL && klass->name() != NULL) {\n+    if (klass != nullptr && klass->name() != nullptr) {\n@@ -259,1 +259,1 @@\n-  if (mem == NULL) {\n+  if (mem == nullptr) {\n@@ -275,1 +275,1 @@\n-  if (mem != NULL) {\n+  if (mem != nullptr) {\n@@ -288,1 +288,1 @@\n-  HeapWord* mem = NULL;\n+  HeapWord* mem = nullptr;\n@@ -299,1 +299,1 @@\n-    if (mem != NULL) {\n+    if (mem != nullptr) {\n@@ -308,1 +308,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -318,1 +318,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -325,1 +325,1 @@\n-  if (mem == NULL) {\n+  if (mem == nullptr) {\n@@ -330,1 +330,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -362,1 +362,1 @@\n-    if (mem != NULL) {\n+    if (mem != nullptr) {\n@@ -374,1 +374,1 @@\n-    if (mem != NULL) {\n+    if (mem != nullptr) {\n@@ -383,1 +383,1 @@\n-  oop obj = NULL;\n+  oop obj = nullptr;\n@@ -387,1 +387,1 @@\n-    if (mem != NULL) {\n+    if (mem != nullptr) {\n@@ -391,2 +391,2 @@\n-      \/\/ so reset it to NULL if mem is NULL.\n-      obj = NULL;\n+      \/\/ so reset it to null if mem is null.\n+      obj = nullptr;\n@@ -399,1 +399,1 @@\n-  assert(mem != NULL, \"cannot initialize NULL object\");\n+  assert(mem != nullptr, \"cannot initialize null object\");\n@@ -407,1 +407,1 @@\n-  assert(mem != NULL, \"NULL object pointer\");\n+  assert(mem != nullptr, \"null object pointer\");\n@@ -411,1 +411,1 @@\n-  \/\/ object zeroing are visible before setting the klass non-NULL, for\n+  \/\/ object zeroing are visible before setting the klass non-null, for\n@@ -433,1 +433,1 @@\n-  \/\/ non-NULL klass field indicates that the object is parsable by\n+  \/\/ non-null klass field indicates that the object is parsable by\n@@ -445,1 +445,1 @@\n-  \/\/ non-NULL _klass field indicates that the object is parsable by\n+  \/\/ non-null _klass field indicates that the object is parsable by\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-                 NULL \/* barrier_set_nmethod *\/,\n-                 NULL \/* barrier_set_stack_chunk *\/,\n+                 nullptr \/* barrier_set_nmethod *\/,\n+                 nullptr \/* barrier_set_stack_chunk *\/,\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-    Raw::oop_arraycopy(NULL, 0, src_raw, NULL, 0, dst_raw, length);\n+    Raw::oop_arraycopy(nullptr, 0, src_raw, nullptr, 0, dst_raw, length);\n@@ -111,1 +111,1 @@\n-    assert(dst_obj != NULL, \"better have an actual oop\");\n+    assert(dst_obj != nullptr, \"better have an actual oop\");\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-OopStorage::AllocationListEntry::AllocationListEntry() : _prev(NULL), _next(NULL) {}\n+OopStorage::AllocationListEntry::AllocationListEntry() : _prev(nullptr), _next(nullptr) {}\n@@ -55,2 +55,2 @@\n-  assert(_prev == NULL, \"deleting attached block\");\n-  assert(_next == NULL, \"deleting attached block\");\n+  assert(_prev == nullptr, \"deleting attached block\");\n+  assert(_next == nullptr, \"deleting attached block\");\n@@ -59,1 +59,1 @@\n-OopStorage::AllocationList::AllocationList() : _head(NULL), _tail(NULL) {}\n+OopStorage::AllocationList::AllocationList() : _head(nullptr), _tail(nullptr) {}\n@@ -63,2 +63,2 @@\n-  assert(_head == NULL, \"deleting non-empty block list\");\n-  assert(_tail == NULL, \"deleting non-empty block list\");\n+  assert(_head == nullptr, \"deleting non-empty block list\");\n+  assert(_tail == nullptr, \"deleting non-empty block list\");\n@@ -69,2 +69,2 @@\n-  if (old == NULL) {\n-    assert(_tail == NULL, \"invariant\");\n+  if (old == nullptr) {\n+    assert(_tail == nullptr, \"invariant\");\n@@ -81,2 +81,2 @@\n-  if (old == NULL) {\n-    assert(_head == NULL, \"invariant\");\n+  if (old == nullptr) {\n+    assert(_head == nullptr, \"invariant\");\n@@ -95,3 +95,3 @@\n-  block_entry._prev = NULL;\n-  block_entry._next = NULL;\n-  if ((prev_blk == NULL) && (next_blk == NULL)) {\n+  block_entry._prev = nullptr;\n+  block_entry._next = nullptr;\n+  if ((prev_blk == nullptr) && (next_blk == nullptr)) {\n@@ -100,2 +100,2 @@\n-    _head = _tail = NULL;\n-  } else if (prev_blk == NULL) {\n+    _head = _tail = nullptr;\n+  } else if (prev_blk == nullptr) {\n@@ -103,1 +103,1 @@\n-    next_blk->allocation_list_entry()._prev = NULL;\n+    next_blk->allocation_list_entry()._prev = nullptr;\n@@ -105,1 +105,1 @@\n-  } else if (next_blk == NULL) {\n+  } else if (next_blk == nullptr) {\n@@ -107,1 +107,1 @@\n-    prev_blk->allocation_list_entry()._next = NULL;\n+    prev_blk->allocation_list_entry()._next = nullptr;\n@@ -116,1 +116,1 @@\n-  return (next(block) != NULL) || (ctail() == &block);\n+  return (next(block) != nullptr) || (ctail() == &block);\n@@ -134,1 +134,1 @@\n-  if (mem == NULL) return NULL;\n+  if (mem == nullptr) return nullptr;\n@@ -224,1 +224,1 @@\n-  _deferred_updates_next(NULL),\n+  _deferred_updates_next(nullptr),\n@@ -230,1 +230,1 @@\n-  assert(owner != NULL, \"NULL owner\");\n+  assert(owner != nullptr, \"null owner\");\n@@ -236,1 +236,1 @@\n-  assert(_deferred_updates_next == NULL, \"deleting block with deferred update\");\n+  assert(_deferred_updates_next == nullptr, \"deleting block with deferred update\");\n@@ -277,1 +277,1 @@\n-         (Atomic::load_acquire(&_deferred_updates_next) == NULL);\n+         (Atomic::load_acquire(&_deferred_updates_next) == nullptr);\n@@ -347,2 +347,2 @@\n-  if (memory == NULL) {\n-    return NULL;\n+  if (memory == nullptr) {\n+    return nullptr;\n@@ -378,1 +378,1 @@\n-  \/\/ (possibly NULL), which can never match the owner.\n+  \/\/ (possibly null), which can never match the owner.\n@@ -386,1 +386,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -440,1 +440,1 @@\n-  if (block == NULL) return NULL; \/\/ Block allocation failed.\n+  if (block == nullptr) return nullptr; \/\/ Block allocation failed.\n@@ -447,1 +447,1 @@\n-  assert(result != NULL, \"allocation failed\");\n+  assert(result != nullptr, \"allocation failed\");\n@@ -475,1 +475,1 @@\n-    if (block == NULL) return 0; \/\/ Block allocation failed.\n+    if (block == nullptr) return 0; \/\/ Block allocation failed.\n@@ -521,1 +521,1 @@\n-  if (block == NULL) return false;\n+  if (block == nullptr) return false;\n@@ -548,1 +548,1 @@\n-    if (block != NULL) {\n+    if (block != nullptr) {\n@@ -554,2 +554,2 @@\n-      assert(_allocation_list.chead() != NULL, \"invariant\");\n-    } else if (_allocation_list.chead() != NULL) {\n+      assert(_allocation_list.chead() != nullptr, \"invariant\");\n+    } else if (_allocation_list.chead() != nullptr) {\n@@ -562,1 +562,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -580,1 +580,1 @@\n-  if (new_array == NULL) return false;\n+  if (new_array == nullptr) return false;\n@@ -647,1 +647,1 @@\n-  assert(ptr != NULL, \"precondition\");\n+  assert(ptr != nullptr, \"precondition\");\n@@ -692,1 +692,1 @@\n-    \/\/ list, by setting the link to non-NULL by self-looping.  If this fails,\n+    \/\/ list, by setting the link to non-null by self-looping.  If this fails,\n@@ -700,1 +700,1 @@\n-        _deferred_updates_next = (head == NULL) ? this : head;\n+        _deferred_updates_next = (head == nullptr) ? this : head;\n@@ -729,1 +729,1 @@\n-    if (block == NULL) return false;\n+    if (block == nullptr) return false;\n@@ -732,1 +732,1 @@\n-    if (block == tail) tail = NULL; \/\/ Handle self-loop end marker.\n+    if (block == tail) tail = nullptr; \/\/ Handle self-loop end marker.\n@@ -737,1 +737,1 @@\n-  block->set_deferred_updates_next(NULL); \/\/ Clear tail after updating head.\n+  block->set_deferred_updates_next(nullptr); \/\/ Clear tail after updating head.\n@@ -768,2 +768,2 @@\n-  assert(entry != NULL, \"Releasing NULL\");\n-  assert(*entry == NULL, \"Releasing uncleared entry: \" PTR_FORMAT, p2i(entry));\n+  assert(entry != nullptr, \"Releasing null\");\n+  assert(*entry == nullptr, \"Releasing uncleared entry: \" PTR_FORMAT, p2i(entry));\n@@ -775,1 +775,1 @@\n-  assert(block != NULL, \"%s: invalid release \" PTR_FORMAT, name(), p2i(ptr));\n+  assert(block != nullptr, \"%s: invalid release \" PTR_FORMAT, name(), p2i(ptr));\n@@ -786,1 +786,1 @@\n-    assert(block != NULL, \"%s: invalid release \" PTR_FORMAT, name(), p2i(ptrs[i]));\n+    assert(block != nullptr, \"%s: invalid release \" PTR_FORMAT, name(), p2i(ptrs[i]));\n@@ -826,1 +826,1 @@\n-  _deferred_updates(NULL),\n+  _deferred_updates(nullptr),\n@@ -829,1 +829,1 @@\n-  _num_dead_callback(NULL),\n+  _num_dead_callback(nullptr),\n@@ -850,1 +850,1 @@\n-  while ((block = _deferred_updates) != NULL) {\n+  while ((block = _deferred_updates) != nullptr) {\n@@ -852,1 +852,1 @@\n-    block->set_deferred_updates_next(NULL);\n+    block->set_deferred_updates_next(nullptr);\n@@ -854,1 +854,1 @@\n-  while ((block = _allocation_list.head()) != NULL) {\n+  while ((block = _allocation_list.head()) != nullptr) {\n@@ -868,1 +868,1 @@\n-  assert(_num_dead_callback == NULL, \"Only one callback function supported\");\n+  assert(_num_dead_callback == nullptr, \"Only one callback function supported\");\n@@ -873,1 +873,1 @@\n-  if (_num_dead_callback != NULL) {\n+  if (_num_dead_callback != nullptr) {\n@@ -879,1 +879,1 @@\n-  return _num_dead_callback != NULL;\n+  return _num_dead_callback != nullptr;\n@@ -945,1 +945,1 @@\n-      (Atomic::load_acquire(&_deferred_updates) == NULL)) {\n+      (Atomic::load_acquire(&_deferred_updates) == nullptr)) {\n@@ -976,1 +976,1 @@\n-      if ((block == NULL) || !block->is_empty()) {\n+      if ((block == nullptr) || !block->is_empty()) {\n@@ -1011,1 +1011,1 @@\n-  if (block != NULL) {\n+  if (block != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":59,"deletions":59,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-  \/\/ precondition: ptr != NULL.\n+  \/\/ precondition: ptr != nullptr.\n@@ -105,1 +105,1 @@\n-  \/\/ Allocates and returns a new entry.  Returns NULL if memory allocation\n+  \/\/ Allocates and returns a new entry.  Returns null if memory allocation\n@@ -107,1 +107,1 @@\n-  \/\/ postcondition: result == NULL or *result == NULL.\n+  \/\/ postcondition: result == null or *result == nullptr.\n@@ -123,1 +123,1 @@\n-  \/\/ postcondition: *ptrs[i] == NULL for i in [0, result).\n+  \/\/ postcondition: *ptrs[i] == nullptr for i in [0, result).\n@@ -128,1 +128,1 @@\n-  \/\/ precondition: *ptr == NULL.\n+  \/\/ precondition: *ptr == nullptr.\n@@ -134,1 +134,1 @@\n-  \/\/ precondition: *ptrs[i] == NULL, for i in [0,size).\n+  \/\/ precondition: *ptrs[i] == nullptr, for i in [0,size).\n@@ -158,1 +158,1 @@\n-  \/\/ For weak_oops_do, if *p == NULL then neither is_alive nor closure will be\n+  \/\/ For weak_oops_do, if *p == nullptr then neither is_alive nor closure will be\n@@ -160,1 +160,1 @@\n-  \/\/ not be invoked on p, and *p will be set to NULL.\n+  \/\/ not be invoked on p, and *p will be set to null.\n@@ -184,1 +184,1 @@\n-  \/\/ number of entries which were either already NULL or were cleared by the\n+  \/\/ number of entries which were either already null or were cleared by the\n@@ -320,1 +320,1 @@\n-  \/\/ Wrapper for iteration handler, automatically skipping NULL entries.\n+  \/\/ Wrapper for iteration handler, automatically skipping null entries.\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-  \/\/ Returns NULL if ptr is not in a block or not allocated in that block.\n+  \/\/ Returns null if ptr is not in a block or not allocated in that block.\n@@ -261,1 +261,1 @@\n-    if (v != NULL) {\n+    if (v != nullptr) {\n@@ -265,1 +265,1 @@\n-        *ptr = NULL;            \/\/ Clear dead value.\n+        *ptr = nullptr;            \/\/ Clear dead value.\n@@ -288,1 +288,1 @@\n-    return (*ptr != NULL) ? _f(ptr) : true;\n+    return (*ptr != nullptr) ? _f(ptr) : true;\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-\/\/ that an entry's value must be NULL when it is not in use.\n+\/\/ that an entry's value must be null when it is not in use.\n@@ -127,1 +127,1 @@\n-\/\/   If *p == NULL then neither is_alive nor cl will be invoked for p.\n+\/\/   If *p == nullptr then neither is_alive nor cl will be invoked for p.\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageParState.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-  assert(_storages[index] != NULL, \"oopstorage_init not yet called\");\n+  assert(_storages[index] != nullptr, \"oopstorage_init not yet called\");\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-      _num_dead++;              \/\/ Count both already NULL and cleared by closure.\n+      _num_dead++;              \/\/ Count both already null and cleared by closure.\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSetParState.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-  _first_nmethod(NULL),\n-  _claimed_nmethod(NULL) {\n+  _first_nmethod(nullptr),\n+  _claimed_nmethod(nullptr) {\n@@ -63,1 +63,1 @@\n-    if (first != NULL) {\n+    if (first != nullptr) {\n@@ -79,1 +79,1 @@\n-  if (worker_id == 0 && _first_nmethod != NULL) {\n+  if (worker_id == 0 && _first_nmethod != nullptr) {\n@@ -81,1 +81,1 @@\n-    _first_nmethod = NULL;\n+    _first_nmethod = nullptr;\n@@ -117,1 +117,1 @@\n-  } while (klass != NULL && !klass->is_instance_klass());\n+  } while (klass != nullptr && !klass->is_instance_klass());\n@@ -133,1 +133,1 @@\n-  while ((klass = claim_next_klass()) != NULL) {\n+  while ((klass = claim_next_klass()) != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-  _word_sz(desired_plab_sz_), _bottom(NULL), _top(NULL),\n-  _end(NULL), _hard_end(NULL), _allocated(0), _wasted(0), _undo_wasted(0)\n+  _word_sz(desired_plab_sz_), _bottom(nullptr), _top(nullptr),\n+  _end(nullptr), _hard_end(nullptr), _allocated(0), _wasted(0), _undo_wasted(0)\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  \/\/ return NULL.\n+  \/\/ return null.\n@@ -94,1 +94,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,2 +89,2 @@\n-  \/\/ This should be != NULL if the stacks have been initialized,\n-  \/\/ or == NULL if they have not.\n+  \/\/ This should be != null if the stacks have been initialized,\n+  \/\/ or == null if they have not.\n@@ -98,1 +98,1 @@\n-    assert(_num > 0 && _stacks != NULL, \"stacks should have been initialized\");\n+    assert(_num > 0 && _stacks != nullptr, \"stacks should have been initialized\");\n@@ -108,1 +108,1 @@\n-  \/\/ is NULL, perform the work serially in the current thread.\n+  \/\/ is null, perform the work serially in the current thread.\n@@ -120,1 +120,1 @@\n-      : _in_c_heap(in_c_heap), _num(0), _stacks(NULL) { }\n+      : _in_c_heap(in_c_heap), _num(0), _stacks(nullptr) { }\n@@ -123,1 +123,1 @@\n-    assert(_stacks == NULL && _num == 0, \"stacks should have been reclaimed\");\n+    assert(_stacks == nullptr && _num == 0, \"stacks should have been reclaimed\");\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-  if (pretouch_workers != NULL) {\n+  if (pretouch_workers != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-  _buf(NULL)\n+  _buf(nullptr)\n@@ -38,1 +38,1 @@\n-  assert(_buf == NULL, \"queue must be flushed before delete\");\n+  assert(_buf == nullptr, \"queue must be flushed before delete\");\n@@ -69,2 +69,2 @@\n-  assert(node != NULL, \"precondition\");\n-  assert(node->next() == NULL, \"precondition\");\n+  assert(node != nullptr, \"precondition\");\n+  assert(node->next() == nullptr, \"precondition\");\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-  BufferNode() : _index(0), _next(NULL) { }\n+  BufferNode() : _index(0), _next(nullptr) { }\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,2 @@\n-ReferencePolicy* ReferenceProcessor::_always_clear_soft_ref_policy = NULL;\n-ReferencePolicy* ReferenceProcessor::_default_soft_ref_policy      = NULL;\n+ReferencePolicy* ReferenceProcessor::_always_clear_soft_ref_policy = nullptr;\n+ReferencePolicy* ReferenceProcessor::_default_soft_ref_policy      = nullptr;\n@@ -99,1 +99,1 @@\n-  assert(is_subject_to_discovery != NULL, \"must be set\");\n+  assert(is_subject_to_discovery != nullptr, \"must be set\");\n@@ -113,1 +113,1 @@\n-  \/\/ Initialize all entries to NULL\n+  \/\/ Initialize all entries to null\n@@ -241,1 +241,1 @@\n-         \"Expected an oop or NULL for discovered field at \" PTR_FORMAT, p2i(discovered));\n+         \"Expected an oop or null for discovered field at \" PTR_FORMAT, p2i(discovered));\n@@ -250,1 +250,1 @@\n-         (allow_null_referent ? \" or NULL\" : \"\"),\n+         (allow_null_referent ? \" or null\" : \"\"),\n@@ -256,1 +256,1 @@\n-  RawAccess<>::oop_store(_current_discovered_addr, oop(NULL));\n+  RawAccess<>::oop_store(_current_discovered_addr, oop(nullptr));\n@@ -263,1 +263,1 @@\n-    \/\/ and _prev will be NULL.\n+    \/\/ and _prev will be null.\n@@ -341,1 +341,1 @@\n-    if (iter.referent() == NULL) {\n+    if (iter.referent() == nullptr) {\n@@ -382,1 +382,1 @@\n-  DiscoveredListIterator iter(refs_list, keep_alive, NULL, enqueue);\n+  DiscoveredListIterator iter(refs_list, keep_alive, nullptr, enqueue);\n@@ -389,1 +389,1 @@\n-    assert(java_lang_ref_Reference::next(iter.obj()) == NULL, \"enqueued FinalReference\");\n+    assert(java_lang_ref_Reference::next(iter.obj()) == nullptr, \"enqueued FinalReference\");\n@@ -405,1 +405,1 @@\n-  oop obj = NULL;\n+  oop obj = nullptr;\n@@ -410,1 +410,1 @@\n-    java_lang_ref_Reference::set_discovered_raw(obj, NULL);\n+    java_lang_ref_Reference::set_discovered_raw(obj, nullptr);\n@@ -426,1 +426,1 @@\n-  DiscoveredList* list = NULL;\n+  DiscoveredList* list = nullptr;\n@@ -673,1 +673,1 @@\n-        if (ref_lists[to_idx].head() == NULL) {\n+        if (ref_lists[to_idx].head() == nullptr) {\n@@ -685,1 +685,1 @@\n-          ref_lists[from_idx].set_head(NULL);\n+          ref_lists[from_idx].set_head(nullptr);\n@@ -717,1 +717,1 @@\n-    assert(workers != NULL, \"can not dispatch multi threaded without workers\");\n+    assert(workers != nullptr, \"can not dispatch multi threaded without workers\");\n@@ -829,1 +829,1 @@\n-  DiscoveredList* list = NULL;\n+  DiscoveredList* list = nullptr;\n@@ -863,1 +863,1 @@\n-  oop next_discovered = (current_head != NULL) ? current_head : obj;\n+  oop next_discovered = (current_head != nullptr) ? current_head : obj;\n@@ -902,1 +902,1 @@\n-    retest = RawAccess<>::oop_atomic_cmpxchg(discovered_addr, oop(NULL), next_discovered);\n+    retest = RawAccess<>::oop_atomic_cmpxchg(discovered_addr, oop(nullptr), next_discovered);\n@@ -904,1 +904,1 @@\n-    retest = HeapAccess<AS_NO_KEEPALIVE>::oop_atomic_cmpxchg(discovered_addr, oop(NULL), next_discovered);\n+    retest = HeapAccess<AS_NO_KEEPALIVE>::oop_atomic_cmpxchg(discovered_addr, oop(nullptr), next_discovered);\n@@ -906,1 +906,1 @@\n-  return retest == NULL;\n+  return retest == nullptr;\n@@ -910,1 +910,1 @@\n-\/\/ Concurrent discovery might allow us to observe j.l.References with NULL\n+\/\/ Concurrent discovery might allow us to observe j.l.References with null\n@@ -958,1 +958,1 @@\n-  if ((rt == REF_FINAL) && (java_lang_ref_Reference::next(obj) != NULL)) {\n+  if ((rt == REF_FINAL) && (java_lang_ref_Reference::next(obj) != nullptr)) {\n@@ -973,1 +973,1 @@\n-  if (is_alive_non_header() != NULL) {\n+  if (is_alive_non_header() != nullptr) {\n@@ -997,2 +997,2 @@\n-  assert(oopDesc::is_oop_or_null(discovered), \"Expected an oop or NULL for discovered field at \" PTR_FORMAT, p2i(discovered));\n-  if (discovered != NULL) {\n+  assert(oopDesc::is_oop_or_null(discovered), \"Expected an oop or null for discovered field at \" PTR_FORMAT, p2i(discovered));\n+  if (discovered != nullptr) {\n@@ -1160,1 +1160,1 @@\n-   return NULL;\n+   return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  DiscoveredList() : _oop_head(NULL), _compressed_head(narrowOop::null), _len(0) { }\n+  DiscoveredList() : _oop_head(nullptr), _compressed_head(narrowOop::null), _len(0) { }\n@@ -117,1 +117,1 @@\n-  inline bool has_next() const { return _current_discovered != NULL; }\n+  inline bool has_next() const { return _current_discovered != nullptr; }\n@@ -132,1 +132,1 @@\n-  \/\/ of a NULL referent in the discovered Reference object. This typically\n+  \/\/ of a null referent in the discovered Reference object. This typically\n@@ -156,1 +156,1 @@\n-  \/\/ NULL out referent pointer.\n+  \/\/ null out referent pointer.\n@@ -166,1 +166,1 @@\n-      _current_discovered = NULL;\n+      _current_discovered = nullptr;\n@@ -258,1 +258,1 @@\n-  \/\/ Drop Soft\/Weak\/Final references with a NULL or live referent, and clear\n+  \/\/ Drop Soft\/Weak\/Final references with a null or live referent, and clear\n@@ -275,1 +275,1 @@\n-  \/\/ or NULL if discovery is concurrent. Enqueue and clear the reference for\n+  \/\/ or null if discovery is concurrent. Enqueue and clear the reference for\n@@ -308,1 +308,1 @@\n-  \/\/ referents are NULL or strongly reachable (`is_alive` returns true).\n+  \/\/ referents are null or strongly reachable (`is_alive` returns true).\n@@ -379,1 +379,1 @@\n-                     BoolObjectClosure* is_alive_non_header = NULL);\n+                     BoolObjectClosure* is_alive_non_header = nullptr);\n@@ -431,1 +431,1 @@\n-  \/\/ have NULL discovered fields.  Must be called only at a safepoint.\n+  \/\/ have null discovered fields.  Must be called only at a safepoint.\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- return head() == NULL;\n+ return head() == nullptr;\n@@ -57,1 +57,1 @@\n-  set_head(NULL);\n+  set_head(nullptr);\n@@ -67,1 +67,1 @@\n-  _prev_discovered(NULL),\n+  _prev_discovered(nullptr),\n@@ -69,3 +69,3 @@\n-  _current_discovered_addr(NULL),\n-  _next_discovered(NULL),\n-  _referent(NULL),\n+  _current_discovered_addr(nullptr),\n+  _next_discovered(nullptr),\n+  _referent(nullptr),\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-  assert(worker_time != NULL, \"Invariant\");\n+  assert(worker_time != nullptr, \"Invariant\");\n@@ -111,1 +111,1 @@\n-  assert(_phase_times != NULL, \"Invariant\");\n+  assert(_phase_times != nullptr, \"Invariant\");\n@@ -160,1 +160,1 @@\n-    _sub_phases_worker_time_sec[i] = new WorkerDataArray<double>(NULL, SubPhasesParWorkTitle[i], max_gc_threads);\n+    _sub_phases_worker_time_sec[i] = new WorkerDataArray<double>(nullptr, SubPhasesParWorkTitle[i], max_gc_threads);\n@@ -162,1 +162,1 @@\n-  _soft_weak_final_refs_phase_worker_time_sec = new WorkerDataArray<double>(NULL, SoftWeakFinalRefsPhaseParWorkTitle, max_gc_threads);\n+  _soft_weak_final_refs_phase_worker_time_sec = new WorkerDataArray<double>(nullptr, SoftWeakFinalRefsPhaseParWorkTitle, max_gc_threads);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,1 +209,1 @@\n-  if (nd != NULL) {\n+  if (nd != nullptr) {\n@@ -275,1 +275,1 @@\n-  assert(node != NULL, \"precondition\");\n+  assert(node != nullptr, \"precondition\");\n@@ -289,1 +289,1 @@\n-  if (node != NULL) {\n+  if (node != nullptr) {\n@@ -310,1 +310,1 @@\n-  while (nd != NULL) {\n+  while (nd != nullptr) {\n@@ -340,1 +340,1 @@\n-  while (buffers_to_delete != NULL) {\n+  while (buffers_to_delete != nullptr) {\n@@ -343,1 +343,1 @@\n-    bn->set_next(NULL);\n+    bn->set_next(nullptr);\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,1 +177,1 @@\n-  if (buf == NULL) {\n+  if (buf == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n-nmethod* ScavengableNMethods::_head = NULL;\n-BoolObjectClosure* ScavengableNMethods::_is_scavengable = NULL;\n+nmethod* ScavengableNMethods::_head = nullptr;\n+BoolObjectClosure* ScavengableNMethods::_is_scavengable = nullptr;\n@@ -65,2 +65,2 @@\n-    nmethod* prev = NULL;\n-    for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {\n+    nmethod* prev = nullptr;\n+    for (nmethod* cur = _head; cur != nullptr; cur = gc_data(cur).next()) {\n@@ -90,1 +90,1 @@\n-    if (*p == NULL || !_is_scavengable->do_object_b(*p)) {\n+    if (*p == nullptr || !_is_scavengable->do_object_b(*p)) {\n@@ -130,1 +130,1 @@\n-    if (!_found && *p != NULL && _is_scavengable->do_object_b(*p)) {\n+    if (!_found && *p != nullptr && _is_scavengable->do_object_b(*p)) {\n@@ -149,1 +149,1 @@\n-  nmethod* prev = NULL;\n+  nmethod* prev = nullptr;\n@@ -151,1 +151,1 @@\n-  while (cur != NULL) {\n+  while (cur != nullptr) {\n@@ -156,1 +156,1 @@\n-    if (cl != NULL) {\n+    if (cl != nullptr) {\n@@ -172,1 +172,1 @@\n-  debug_only(verify_unlisted_nmethods(NULL));\n+  debug_only(verify_unlisted_nmethods(nullptr));\n@@ -176,1 +176,1 @@\n-  nmethods_do_and_prune(NULL \/* No closure *\/);\n+  nmethods_do_and_prune(nullptr \/* No closure *\/);\n@@ -188,1 +188,1 @@\n-  for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {\n+  for (nmethod* cur = _head; cur != nullptr; cur = gc_data(cur).next()) {\n@@ -199,2 +199,2 @@\n-  assert((prev == NULL && _head == nm) ||\n-         (prev != NULL && gc_data(prev).next() == nm), \"precondition\");\n+  assert((prev == nullptr && _head == nm) ||\n+         (prev != nullptr && gc_data(prev).next() == nm), \"precondition\");\n@@ -204,1 +204,1 @@\n-  if (prev == NULL) {\n+  if (prev == nullptr) {\n@@ -209,1 +209,1 @@\n-  data.set_next(NULL);\n+  data.set_next(nullptr);\n@@ -235,1 +235,1 @@\n-    if (cl != NULL && !gc_data(nm).on_list()) {\n+    if (cl != nullptr && !gc_data(nm).on_list()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  if (size_policy != NULL) {\n+  if (size_policy != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/softRefGenPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  if (top_obj != NULL && top_obj < (_sp->toContiguousSpace())->top()) {\n+  if (top_obj != nullptr && top_obj < (_sp->toContiguousSpace())->top()) {\n@@ -106,1 +106,1 @@\n-  assert(_last_bottom == NULL || top <= _last_bottom,\n+  assert(_last_bottom == nullptr || top <= _last_bottom,\n@@ -122,1 +122,1 @@\n-  if (_min_done != NULL && _min_done < top) {\n+  if (_min_done != nullptr && _min_done < top) {\n@@ -132,1 +132,1 @@\n-         (_min_done == NULL || top <= _min_done),\n+         (_min_done == nullptr || top <= _min_done),\n@@ -195,1 +195,1 @@\n-ContiguousSpace::ContiguousSpace(): CompactibleSpace(), _top(NULL) {\n+ContiguousSpace::ContiguousSpace(): CompactibleSpace(), _top(nullptr) {\n@@ -271,1 +271,1 @@\n-  _next_compaction_space = NULL;\n+  _next_compaction_space = nullptr;\n@@ -289,1 +289,1 @@\n-    if (cp->space == NULL) {\n+    if (cp->space == nullptr) {\n@@ -291,1 +291,1 @@\n-      assert(cp->gen != NULL, \"compaction must succeed\");\n+      assert(cp->gen != nullptr, \"compaction must succeed\");\n@@ -293,1 +293,1 @@\n-      assert(cp->space != NULL, \"generation must have a first compaction space\");\n+      assert(cp->space != nullptr, \"generation must have a first compaction space\");\n@@ -331,2 +331,2 @@\n-  if (cp->space == NULL) {\n-    assert(cp->gen != NULL, \"need a generation\");\n+  if (cp->space == nullptr) {\n+    assert(cp->gen != nullptr, \"need a generation\");\n@@ -344,1 +344,1 @@\n-  HeapWord*  first_dead = NULL; \/\/ The first dead object.\n+  HeapWord*  first_dead = nullptr; \/\/ The first dead object.\n@@ -381,1 +381,1 @@\n-        if (first_dead == NULL) {\n+        if (first_dead == nullptr) {\n@@ -393,1 +393,1 @@\n-  if (first_dead != NULL) {\n+  if (first_dead != nullptr) {\n@@ -420,1 +420,1 @@\n-  debug_only(HeapWord* prev_obj = NULL);\n+  debug_only(HeapWord* prev_obj = nullptr);\n@@ -467,1 +467,1 @@\n-  debug_only(HeapWord* prev_obj = NULL);\n+  debug_only(HeapWord* prev_obj = nullptr);\n@@ -493,1 +493,1 @@\n-      assert(new_obj->klass() != NULL, \"should have a class\");\n+      assert(new_obj->klass() != nullptr, \"should have a class\");\n@@ -538,1 +538,1 @@\n-  HeapWord* prev_p = NULL;\n+  HeapWord* prev_p = nullptr;\n@@ -635,1 +635,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -654,1 +654,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -692,1 +692,1 @@\n-  HeapWord* prev_p = NULL;\n+  HeapWord* prev_p = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-    _bottom(NULL), _end(NULL) { }\n+    _bottom(nullptr), _end(nullptr) { }\n@@ -179,1 +179,1 @@\n-  \/\/ object or a non-object.  If \"p\" is not in the space, return NULL.\n+  \/\/ object or a non-object.  If \"p\" is not in the space, return null.\n@@ -201,1 +201,1 @@\n-  \/\/ Allocation (return NULL if full).  Assumes the caller has established\n+  \/\/ Allocation (return null if full).  Assumes the caller has established\n@@ -205,1 +205,1 @@\n-  \/\/ Allocation (return NULL if full).  Enforces mutual exclusion internally.\n+  \/\/ Allocation (return null if full).  Enforces mutual exclusion internally.\n@@ -220,1 +220,1 @@\n-  \/\/ IF \"this\" is a ContiguousSpace, return it, else return NULL.\n+  \/\/ IF \"this\" is a ContiguousSpace, return it, else return null.\n@@ -222,1 +222,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -246,1 +246,1 @@\n-  HeapWord* _boundary;          \/\/ If non-NULL, process only non-NULL oops\n+  HeapWord* _boundary;          \/\/ If non-null, process only non-null oops\n@@ -252,1 +252,1 @@\n-                                \/\/ shouldn't be done again.  NULL means infinity.)\n+                                \/\/ shouldn't be done again.  null means infinity.)\n@@ -289,2 +289,2 @@\n-    _min_done(NULL) {\n-    NOT_PRODUCT(_last_bottom = NULL);\n+    _min_done(nullptr) {\n+    NOT_PRODUCT(_last_bottom = nullptr);\n@@ -303,2 +303,2 @@\n-  CompactPoint(Generation* g = NULL) :\n-    gen(g), space(NULL) {}\n+  CompactPoint(Generation* g = nullptr) :\n+    gen(g), space(nullptr) {}\n@@ -325,1 +325,1 @@\n-   _compaction_top(NULL), _next_compaction_space(NULL) {}\n+   _compaction_top(nullptr), _next_compaction_space(nullptr) {}\n@@ -335,1 +335,1 @@\n-    assert(value == NULL || (value >= bottom() && value <= end()),\n+    assert(value == nullptr || (value >= bottom() && value <= end()),\n@@ -420,1 +420,1 @@\n-  \/\/ Allocation helpers (return NULL if full).\n+  \/\/ Allocation helpers (return null if full).\n@@ -457,1 +457,1 @@\n-  \/\/ This code may be NULL depending on the macro DEBUG_MANGLING.\n+  \/\/ This code may be null depending on the macro DEBUG_MANGLING.\n@@ -470,1 +470,1 @@\n-  \/\/ Allocation (return NULL if full)\n+  \/\/ Allocation (return null if full)\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -69,1 +69,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -140,1 +140,1 @@\n-     HeapWord* prev_obj = NULL;\n+     HeapWord* prev_obj = nullptr;\n@@ -175,1 +175,1 @@\n-  assert(p != NULL, \"expected saved mark\");\n+  assert(p != nullptr, \"expected saved mark\");\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  \/\/ Setting _top_for_allocations to NULL at initialization\n+  \/\/ Setting _top_for_allocations to null at initialization\n@@ -91,1 +91,1 @@\n-  SpaceMangler() : _top_for_allocations(NULL) {}\n+  SpaceMangler() : _top_for_allocations(nullptr) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/spaceDecorator.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static Semaphore* _synchronize_wakeup = NULL;\n+static Semaphore* _synchronize_wakeup = nullptr;\n@@ -40,1 +40,1 @@\n-  assert(_synchronize_wakeup == NULL, \"STS already initialized\");\n+  assert(_synchronize_wakeup == nullptr, \"STS already initialized\");\n","filename":"src\/hotspot\/share\/gc\/shared\/suspendibleThreadSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-  _spin_master(NULL) { }\n+  _spin_master(nullptr) { }\n@@ -83,1 +83,1 @@\n-  assert(_spin_master == NULL, \"Should have been reset\");\n+  assert(_spin_master == nullptr, \"Should have been reset\");\n@@ -96,1 +96,1 @@\n-    assert(_spin_master == NULL, \"Leftover spin master \" PTR_FORMAT, p2i(_spin_master));\n+    assert(_spin_master == nullptr, \"Leftover spin master \" PTR_FORMAT, p2i(_spin_master));\n@@ -107,1 +107,1 @@\n-  return tasks > 0 || (terminator != NULL && terminator->should_exit_termination());\n+  return tasks > 0 || (terminator != nullptr && terminator->should_exit_termination());\n@@ -120,1 +120,1 @@\n-    _spin_master = NULL;\n+    _spin_master = nullptr;\n@@ -155,1 +155,1 @@\n-    if (_spin_master == NULL) {\n+    if (_spin_master == nullptr) {\n@@ -182,1 +182,1 @@\n-      _spin_master = NULL;\n+      _spin_master = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/taskTerminator.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-    return offer_termination(NULL);\n+    return offer_termination(nullptr);\n@@ -113,1 +113,1 @@\n-  \/\/ NULL, then it is ignored.\n+  \/\/ null, then it is ignored.\n","filename":"src\/hotspot\/share\/gc\/shared\/taskTerminator.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-  return _obj != NULL && _obj->is_objArray() && _index >= 0 &&\n+  return _obj != nullptr && _obj->is_objArray() && _index >= 0 &&\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -560,1 +560,1 @@\n-  ObjArrayTask(oop o = NULL, int idx = 0): _obj(o), _index(idx) { }\n+  ObjArrayTask(oop o = nullptr, int idx = 0): _obj(o), _index(idx) { }\n@@ -621,1 +621,1 @@\n-  ScannerTask() : _p(NULL) {}\n+  ScannerTask() : _p(nullptr) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    _queues[i] = NULL;\n+    _queues[i] = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,5 +45,5 @@\n-  _start(NULL),\n-  _top(NULL),\n-  _pf_top(NULL),\n-  _end(NULL),\n-  _allocation_end(NULL),\n+  _start(nullptr),\n+  _top(nullptr),\n+  _pf_top(nullptr),\n+  _end(nullptr),\n+  _allocation_end(nullptr),\n@@ -69,1 +69,1 @@\n-  if (end() == NULL) {\n+  if (end() == nullptr) {\n@@ -120,1 +120,1 @@\n-  assert(end() != NULL, \"Must not be retired\");\n+  assert(end() != nullptr, \"Must not be retired\");\n@@ -127,1 +127,1 @@\n-  if (end() != NULL) {\n+  if (end() != nullptr) {\n@@ -138,1 +138,1 @@\n-  if (stats != NULL) {\n+  if (stats != nullptr) {\n@@ -142,1 +142,1 @@\n-  if (end() != NULL) {\n+  if (end() != nullptr) {\n@@ -146,1 +146,1 @@\n-    initialize(NULL, NULL, NULL);\n+    initialize(nullptr, nullptr, nullptr);\n@@ -209,3 +209,3 @@\n-  initialize(NULL,                    \/\/ start\n-             NULL,                    \/\/ top\n-             NULL);                   \/\/ end\n+  initialize(nullptr,                    \/\/ start\n+             nullptr,                    \/\/ top\n+             nullptr);                   \/\/ end\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-  void retire(ThreadLocalAllocStats* stats = NULL);\n+  void retire(ThreadLocalAllocStats* stats = nullptr);\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    if (obj == NULL) {\n+    if (obj == nullptr) {\n@@ -68,1 +68,1 @@\n-      *p = NULL;\n+      *p = nullptr;\n@@ -93,1 +93,1 @@\n-    if (_times != NULL) {\n+    if (_times != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    *wpt = new WorkerDataArray<double>(NULL, description, _max_threads);\n+    *wpt = new WorkerDataArray<double>(nullptr, description, _max_threads);\n@@ -140,1 +140,1 @@\n-  if (_times != NULL) {\n+  if (_times != nullptr) {\n@@ -154,1 +154,1 @@\n-  assert(_times == NULL || worker_id < _times->active_workers(),\n+  assert(_times == nullptr || worker_id < _times->active_workers(),\n@@ -160,1 +160,1 @@\n-  if (_times != NULL) {\n+  if (_times != nullptr) {\n@@ -187,1 +187,1 @@\n-    if (work_items != NULL) {\n+    if (work_items != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorTimes.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-\/\/ Does nothing if times is NULL.\n+\/\/ Does nothing if times is null.\n@@ -92,1 +92,1 @@\n-\/\/ Does nothing if times is NULL.\n+\/\/ Does nothing if times is null.\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorTimes.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- _data(NULL),\n+ _data(nullptr),\n@@ -42,1 +42,1 @@\n-    _thread_work_items[i] = NULL;\n+    _thread_work_items[i] = nullptr;\n@@ -81,1 +81,1 @@\n-  assert(_thread_work_items[index] == NULL, \"Tried to overwrite existing thread work item\");\n+  assert(_thread_work_items[index] == nullptr, \"Tried to overwrite existing thread work item\");\n@@ -83,1 +83,1 @@\n-  _thread_work_items[index] = new WorkerDataArray<size_t>(NULL, title, length);\n+  _thread_work_items[index] = new WorkerDataArray<size_t>(nullptr, title, length);\n@@ -89,1 +89,1 @@\n-  assert(_thread_work_items[index] != NULL, \"No sub count\");\n+  assert(_thread_work_items[index] != nullptr, \"No sub count\");\n@@ -96,1 +96,1 @@\n-  assert(_thread_work_items[index] != NULL, \"No sub count\");\n+  assert(_thread_work_items[index] != nullptr, \"No sub count\");\n@@ -103,1 +103,1 @@\n-  assert(_thread_work_items[index] != NULL, \"No sub count\");\n+  assert(_thread_work_items[index] != nullptr, \"No sub count\");\n@@ -114,1 +114,1 @@\n-  assert(_thread_work_items[index] != NULL, \"No sub count\");\n+  assert(_thread_work_items[index] != nullptr, \"No sub count\");\n@@ -199,1 +199,1 @@\n-    if (_thread_work_items[i] != NULL) {\n+    if (_thread_work_items[i] != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.inline.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-    _task(NULL),\n+    _task(nullptr),\n@@ -55,1 +55,1 @@\n-  _task = NULL;\n+  _task = nullptr;\n@@ -98,1 +98,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -105,1 +105,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -122,1 +122,1 @@\n-    if (worker == NULL) {\n+    if (worker == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-  _tasks(NULL), _n_tasks(n) {\n+  _tasks(nullptr), _n_tasks(n) {\n","filename":"src\/hotspot\/share\/gc\/shared\/workerUtils.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}