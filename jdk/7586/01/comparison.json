{"files":[{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.Event;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.internal.test.WhiteBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import jdk.jfr.Configuration;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @run main\/othervm -XX:TLABSize=2k jdk.jfr.jvm.TestWaste\n+ *\/\n+public class TestWaste {\n+    static List<Object> list = new LinkedList<>();\n+    static Random random = new Random();\n+\n+    public static void main(String... args) throws Exception {\n+        WhiteBox.setWriteAllObjectSamples(true);\n+        Configuration c = Configuration.getConfiguration(\"profile\");\n+        Path file = Path.of(\"recording.jfr\");\n+        Path scrubbed = Path.of(\"scrubbed.jfr\");\n+        try (Recording r = new Recording(c)) {\n+            \/\/ Old objects that are cleared out should not create waste\n+            r.enable(\"jdk.OldObjectSample\")\n+             .with(\"cutoff\", \"infinity\")\n+             .withStackTrace();\n+            \/\/ No stack trace waste from allocation sample\n+            r.enable(\"jdk.ObjectAllocationSample\")\n+             .with(\"throttle\", \"1000\/s\")\n+             .withoutStackTrace();\n+            \/\/ Unused threads should not create unreasonable amount of waste\n+            r.disable(\"jdk.ThreadStart\");\n+            r.disable(\"jdk.ThreadStop\");\n+            \/\/ jdk.GCPhaseParallel can often, but not always, take up a very\n+            \/\/ large part of the recording. Disable to make test more stable\n+            r.disable(\"jdk.GCPhaseParallel\");\n+            r.start();\n+            \/\/ Generate data\n+            for (int i = 0; i < 5_000_000; i++) {\n+                foo(50);\n+                if (i % 3_000_000 == 0) {\n+                    System.gc();\n+                }\n+                if (i % 10_000 == 0) {\n+                    Thread t = new Thread();\n+                    t.start();\n+                }\n+            }\n+            r.stop();\n+            r.dump(file);\n+            final Map<String, Long> histogram = new HashMap<>();\n+            try (RecordingFile rf = new RecordingFile(file)) {\n+                rf.write(scrubbed, event -> {\n+                    String key = event.getEventType().getName();\n+                    histogram.merge(key, 1L, (x, y) -> x + y);\n+                    return true;\n+                });\n+            }\n+            for (var entry : histogram.entrySet()) {\n+                System.out.println(entry.getKey() + \" \" + entry.getValue());\n+            }\n+            float fileSize = Files.size(file);\n+            System.out.printf(\"File size: %.2f MB\\n\", fileSize \/ (1024 * 1024));\n+            float scrubbedSize = Files.size(scrubbed);\n+            System.out.printf(\"Scrubbed size: %.2f MB\\n\", scrubbedSize \/ (1024 * 1024));\n+            float waste = 1 - scrubbedSize \/ fileSize;\n+            System.out.printf(\"Waste: %.2f%%\\n\", 100 * waste);\n+            if (waste > 0.10) {\n+                throw new AssertionError(\"Found more than 10% waste\");\n+            }\n+        }\n+    }\n+\n+    static void foo(int depth) {\n+        bar(depth - 1);\n+    }\n+\n+    static void bar(int depth) {\n+        if (depth > 1) {\n+            if (random.nextBoolean()) {\n+                foo(depth);\n+            } else {\n+                bar(depth - 1);\n+            }\n+        } else {\n+            list.add(new String(\"hello\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestWaste.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}